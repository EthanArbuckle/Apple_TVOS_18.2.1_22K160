uint64_t compare_extents_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1LL;
  }
}

void rawimg_destroy(uint64_t *a1)
{
  if (a1)
  {
    if (a1[270])
    {
      unint64_t v2 = 0LL;
      uint64_t v3 = 384LL;
      do
      {
        free(*(void **)(a1[268] + v3));
        ++v2;
        v3 += 440LL;
      }

      while (v2 < a1[270]);
    }

    pc_array_free(a1[267]);
    pc_array_free(a1[268]);
    free(a1);
  }
}

uint64_t rawimg_show(uint64_t result, int a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    v5 = (void *)result;
    char v17 = 0;
    memset(v16, 0, sizeof(v16));
    uint64_t v6 = *(void *)(result + 2160);
    if (v6)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
      v9 = (void *)(*(void *)(result + 2144) + 400LL);
      do
      {
        v7 += *v9;
        v8 += *(v9 - 1);
        v9 += 55;
        --v6;
      }

      while (v6);
    }

    else
    {
      uint64_t v8 = 0LL;
      uint64_t v7 = 0LL;
    }

    result = serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)(result + 2088));
    if (a3 > 1)
    {
      v10 = (FILE **)MEMORY[0x1895F89D0];
      v11 = "Output";
      if (!a2) {
        v11 = "Input";
      }
      v12 = (const char *)&unk_1862C62C1;
      if (v5[256]) {
        v12 = (const char *)v5[256];
      }
      result = fprintf( (FILE *)*MEMORY[0x1895F89D0],  "%s variant <%s> | %llu bytes | %zu extents | %zu forks (%llu/%llu) | digest=%s\n",  v11,  v12,  v5[265],  v5[269],  v5[270],  v7,  v8,  (const char *)v16);
      if (a3 != 2)
      {
        result = fprintf(*v10, " fork | %64s | algo |       size | compressed | V | C\n", "digest");
        if (v5[270])
        {
          uint64_t v13 = 0LL;
          unint64_t v14 = 0LL;
          do
          {
            uint64_t v15 = v5[268] + v13;
            serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)v15);
            result = fprintf( *v10,  "%5zu | %s | %4d | %10llu | %10llu | %d | %d\n",  ++v14,  (const char *)v16,  *(unsigned __int8 *)(v15 + 432),  *(void *)(v15 + 392),  *(void *)(v15 + 400),  *(_DWORD *)(v15 + 408) & 1,  (*(_DWORD *)(v15 + 408) >> 1) & 1);
            v13 += 440LL;
          }

          while (v14 < v5[270]);
        }
      }
    }
  }

  return result;
}

uint64_t *rawimg_create_with_path(const char *a1)
{
  unint64_t v2 = (uint64_t *)calloc(1uLL, 0x878uLL);
  memset(&v23, 0, sizeof(v23));
  if (!v2)
  {
    int v20 = *__error();
    uint64_t v18 = "aaCalloc";
    __int16 v19 = 468;
    goto LABEL_17;
  }

  if (lstat(a1, &v23) || (v23.st_mode & 0xF000) != 0x8000)
  {
    uint64_t v18 = "lstat";
    __int16 v19 = 469;
LABEL_15:
    int v20 = 0;
LABEL_17:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_create_with_path",  v19,  138,  v20,  v18,  v3,  v4,  v23.st_dev);
    rawimg_destroy(v2);
    return 0LL;
  }

  v2[256] = (uint64_t)a1;
  v2[265] = v23.st_size;
  v2[267] = (uint64_t)pc_array_init(16LL);
  v5 = pc_array_init(440LL);
  v2[268] = (uint64_t)v5;
  if (!v2[267] || !v5)
  {
    uint64_t v18 = "pc_array_init";
    __int16 v19 = 476;
    goto LABEL_15;
  }

  if ((apfs_scan_diskimage( a1,  (uint64_t (*)(__int128 *, uint64_t))rawimg_add_fork,  (uint64_t)rawimg_add_volume,  (uint64_t)v2) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_query_forks";
    __int16 v19 = 479;
    goto LABEL_15;
  }

  uint64_t v6 = (void *)v2[268];
  uint64_t v7 = *(v6 - 8);
  v2[270] = v7;
  v2[269] = *(void *)(v2[267] - 64);
  if (v7)
  {
    pc_array_sort(v6, (int (__cdecl *)(const void *, const void *))compare_forks_by_extent);
    if ((pc_array_aggregate( (char *)v2[268],  (unsigned int (*)(char *, char *))compare_forks_by_extent,  (uint64_t (*)(char *, char *))aggregate_identical_forks) & 0x80000000) != 0)
    {
      v22 = "rawimg_remove_fork_duplicates";
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_remove_fork_duplicates",  454,  138,  0,  "bad duplicate",  v8,  v9,  v23.st_dev);
      __int16 v19 = 484;
      goto LABEL_23;
    }

    uint64_t v6 = (void *)v2[268];
    v2[270] = *(v6 - 8);
  }

  v2[268] = (uint64_t)pc_array_compact((uint64_t)v6);
  v10 = pc_array_compact(v2[267]);
  v2[267] = (uint64_t)v10;
  if (!v10 || !v2[268])
  {
    v22 = "rawimg_compact";
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_compact",  77,  138,  0,  "pc_array_compress",  v16,  v17,  v23.st_dev);
    __int16 v19 = 485;
LABEL_23:
    int v20 = 0;
    uint64_t v18 = v22;
    goto LABEL_17;
  }

  if ((rawimg_verify(v2, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_verify";
    __int16 v19 = 486;
    goto LABEL_15;
  }

  qsort_r( (void *)v2[268],  v2[270],  0x1B8uLL,  v2,  (int (__cdecl *)(void *, const void *, const void *))compare_forks_by_position);
  return v2;
}

uint64_t rawimg_add_fork( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v27 = 0LL;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v24 = 0u;
  memset(__src, 0, sizeof(__src));
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v8 && *(void *)a1)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    *((void *)&v24 + 1) = *(void *)a1;
    *(void *)&__int128 v25 = v11;
    *(void *)&__int128 v26 = *(void *)(*(void *)(a2 + 2136) - 64LL);
    *((void *)&v26 + 1) = v8;
    LOBYTE(v27) = *(_DWORD *)(a1 + 16);
    uint64_t v12 = pc_array_append(*(void *)(a2 + 2144), __src, a3, a4, a5, a6, a7, a8);
    *(void *)(a2 + 2144) = v12;
    if (v12)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = *(void **)(a2 + 2136);
      while (1)
      {
        __int128 v22 = 0uLL;
        __int128 v22 = *(_OWORD *)(*(void *)(a1 + 24) + 16 * v17);
        uint64_t v18 = pc_array_append((uint64_t)v18, &v22, v13, v14, v15, v16, a7, a8);
        *(void *)(a2 + 2136) = v18;
        if (!v18) {
          break;
        }
      }

      int v20 = "pc_array_append";
      __int16 v21 = 440;
    }

    else
    {
      int v20 = "pc_array_append";
      __int16 v21 = 427;
    }
  }

  else
  {
    int v20 = "bad fork";
    __int16 v21 = 416;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_add_fork",  v21,  138,  0,  v20,  a7,  a8,  v22);
  return 0xFFFFFFFFLL;
}

uint64_t rawimg_add_volume()
{
  return 0LL;
}

uint64_t rawimg_verify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[270];
  uint64_t v9 = a1[269];
  if (!v8 || !v9)
  {
    if (!(v8 + v9)) {
      return 0LL;
    }
    __int128 v26 = "bad variant";
    __int16 v27 = 184;
LABEL_22:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_verify",  v27,  138,  0,  v26,  a7,  a8,  v61);
    uint64_t v28 = 0LL;
    uint64_t v17 = 0LL;
    goto LABEL_23;
  }

  uint64_t v11 = a1[267];
  uint64_t v12 = (void *)(v11 + 8);
  do
  {
    uint64_t v13 = *(v12 - 1);
    if ((unint64_t)(*v12 + v13) > a1[265])
    {
      __int128 v26 = "bad extent";
      __int16 v27 = 195;
      goto LABEL_22;
    }

    if ((v13 & 0xFFF) != 0)
    {
      __int128 v26 = "bad extent pos";
      __int16 v27 = 196;
      goto LABEL_22;
    }

    if ((*v12 & 0xFFFLL) != 0)
    {
      __int128 v26 = "bad extent size";
      __int16 v27 = 197;
      goto LABEL_22;
    }

    v12 += 2;
    --v9;
  }

  while (v9);
  uint64_t v14 = pc_array_indirect_sort(v11, compare_extents_by_position);
  uint64_t v17 = v14;
  if (!v14)
  {
    stat v23 = "pc_array_indirect_sort";
    __int16 v24 = 202;
    goto LABEL_27;
  }

  uint64_t v18 = 0LL;
  unint64_t v19 = a1[269];
  if (v19 <= 1) {
    uint64_t v20 = 1LL;
  }
  else {
    uint64_t v20 = a1[269];
  }
  uint64_t v21 = v20 - 1;
  while (v21 != v18)
  {
    __int128 v22 = (void **)&v14[v18++];
    if ((*v22)[1] + **v22 > *v22[1])
    {
      stat v23 = "extents overlapping";
      __int16 v24 = 205;
      goto LABEL_27;
    }
  }

  uint64_t v30 = a1[270];
  uint64_t v31 = a1[268];
  if (!v30)
  {
LABEL_42:
    uint64_t v28 = pc_array_indirect_sort(v31, compare_forks_by_extent);
    if (v28)
    {
      unint64_t v45 = a1[270];
      if (v45 <= 1) {
        uint64_t v46 = 1LL;
      }
      else {
        uint64_t v46 = a1[270];
      }
      uint64_t v47 = 856LL;
      while (--v46)
      {
        v48 = (void *)(a1[268] + v47);
        v47 += 440LL;
        if (*(v48 - 55) == *v48)
        {
          v49 = "duplicate fork";
          __int16 v50 = 239;
          goto LABEL_69;
        }
      }

      if (!v45)
      {
LABEL_59:
        uint64_t v25 = 0LL;
        goto LABEL_24;
      }

      uint64_t v51 = 0LL;
      uint64_t v52 = a1[268];
      while (1)
      {
        uint64_t v53 = *(void *)(v52 + 440 * v51 + 56);
        if (v53) {
          break;
        }
LABEL_58:
        if (++v51 == v45) {
          goto LABEL_59;
        }
      }

      unint64_t v54 = 0LL;
      uint64_t v55 = v52 + 440 * v51;
      uint64_t v56 = *(void *)(v55 + 384);
      v57 = (unint64_t *)(v55 + 400);
      v58 = (unsigned int *)(v56 + 8);
      while (1)
      {
        unint64_t v59 = *((void *)v58 - 1);
        if (v59 < v54)
        {
          v49 = "bad chunk order";
          __int16 v50 = 256;
          goto LABEL_69;
        }

        unint64_t v54 = v59 + *v58;
        if (v54 > *v57) {
          break;
        }
        v58 += 3;
        if (!--v53) {
          goto LABEL_58;
        }
      }

      v49 = "chunk out of bounds";
      __int16 v50 = 257;
    }

    else
    {
      v49 = "pc_array_indirect_sort";
      __int16 v50 = 236;
    }

LABEL_69:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_verify",  v50,  138,  0,  v49,  v43,  v44,  v61);
    goto LABEL_23;
  }

  uint64_t v32 = 0LL;
  while (2)
  {
    uint64_t v33 = v31 + 440 * v32;
    uint64_t v35 = *(void *)(v33 + 416);
    uint64_t v34 = *(void *)(v33 + 424);
    if (v34 + v35 > v19)
    {
      stat v23 = "bad fork";
      __int16 v24 = 216;
      goto LABEL_27;
    }

    if (!v34)
    {
      stat v23 = "no fork extents";
      __int16 v24 = 219;
      goto LABEL_27;
    }

    if (!*(void *)(v31 + 440 * v32 + 392))
    {
      stat v23 = "bad fork size";
      __int16 v24 = 222;
      goto LABEL_27;
    }

    uint64_t v36 = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
    if (!*(_BYTE *)(v31 + 440 * v32 + 432))
    {
      __int16 v60 = 155;
      goto LABEL_66;
    }

    v37 = &a1[*(unsigned __int8 *)(v31 + 440 * v32 + 432)];
    if (*v37)
    {
LABEL_38:
      unint64_t v40 = 0LL;
      v41 = (uint64_t *)(a1[267] + 16 * v35 + 8);
      do
      {
        uint64_t v42 = *v41;
        v41 += 2;
        v40 += v42;
        --v34;
      }

      while (v34);
      if (v40 < *(void *)(v31 + 440 * v32 + 400))
      {
        stat v23 = "bad fork size";
        __int16 v24 = 231;
        goto LABEL_27;
      }

      if (++v32 == v30) {
        goto LABEL_42;
      }
      continue;
    }

    break;
  }

  HIDWORD(v39) = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
  LODWORD(v39) = v36 - 4;
  unsigned int v38 = v39 >> 1;
  if (v38 < 6 && ((0x35u >> v38) & 1) != 0)
  {
    _DWORD *v37 = dword_1862D77C0[v38];
    BYTE4(a1[v36]) = 0xFFFFFF06FFFFuLL >> (8 * v38);
    goto LABEL_38;
  }

  __int16 v60 = 167;
LABEL_66:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_init_algorithm",  v60,  138,  0,  "bad algo",  v15,  v16,  v61);
  __int16 v24 = 225;
  stat v23 = "rawimg_init_algorithm";
LABEL_27:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_verify",  v24,  138,  0,  v23,  v15,  v16,  v61);
  uint64_t v28 = 0LL;
LABEL_23:
  uint64_t v25 = 0xFFFFFFFFLL;
LABEL_24:
  free(v17);
  free(v28);
  return v25;
}

      LOBYTE(v45) = *((_BYTE *)v30 + 21);
      uint64_t v42 = "could not resolve qualifier (type %c): %s";
      uint64_t v43 = 486;
LABEL_77:
      v41 = 0;
LABEL_78:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobApplyToFD",  v43,  100,  v41,  v42,  v21,  v22,  v45);
LABEL_79:
      uint64_t v9 = 0xFFFFFFFFLL;
LABEL_80:
      if (acl_p) {
        acl_free(acl_p);
      }
      free(v23);
      return v9;
    case 7u:
      memset(&v47, 0, sizeof(v47));
      uint64_t v46 = 0LL;
      unint64_t v39 = getpwnam_r(in, &v47, v23, v19, (passwd **)&v46);
      v37 = 0;
      if (v39 || !v46) {
        goto LABEL_50;
      }
      unsigned int v38 = mbr_uid_to_uuid(v47.pw_uid, uu);
      goto LABEL_49;
    default:
      LOBYTE(v45) = *((_BYTE *)v30 + 21);
      uint64_t v42 = "invalid qualifier type: %d";
      uint64_t v43 = 483;
      goto LABEL_77;
  }

uint64_t rawimg_get_digests(uint64_t a1, signed int a2, int a3, int a4)
{
  uint64_t v8 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 2048), 0, 0);
  uint64_t v11 = (AAByteStream_impl *)v8;
  if (!v8)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  570,  138,  0,  "AAFileStreamOpenWithPath",  v9,  v10,  v150);
LABEL_78:
    v79 = 0LL;
    v82 = 0LL;
    v80 = 0LL;
    v93 = 0LL;
    v76 = 0LL;
    uint64_t v20 = 0LL;
LABEL_95:
    int v113 = 0;
    goto LABEL_96;
  }

  if (a4 && (io_set_nocache(v8) & 0x80000000) != 0) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  571,  138,  "io_set_nocache %s",  v12,  v13,  v14,  *(void *)(a1 + 2048));
  }
  if (AAByteStreamSeek(v11, 0LL, 2) != *(void *)(a1 + 2120))
  {
    if (!a3) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  575,  138,  "image size mismatch",  v15,  v16,  v17,  v150);
    }
    goto LABEL_78;
  }

  uint64_t v20 = aaSegmentStreamOpen(v11, (void *)a1);
  if (!v20)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  581,  138,  0,  "aaSegmentStreamOpen",  v18,  v19,  v150);
LABEL_94:
    v79 = 0LL;
    v82 = 0LL;
    v80 = 0LL;
    v93 = 0LL;
    v76 = 0LL;
    goto LABEL_95;
  }

  rawimg_free_chunks((void *)a1);
  if (*(void *)(a1 + 2160))
  {
    unint64_t v26 = 0LL;
    signed int v160 = a2;
    while (1)
    {
      uint64_t v27 = *(void *)(a1 + 2144);
      uint64_t v28 = v27 + 440 * v26;
      unint64_t v29 = *(void *)(v28 + 392) + 0xFFFFLL;
      *(void *)(v28 + 56) = v29 >> 16;
      uint64_t v30 = (uint64_t *)(v28 + 56);
      if (v29 >= 0x2AAAAAAAB0000LL)
      {
        *__error() = 12;
        *(void *)(v27 + 440 * v26 + 384) = 0LL;
LABEL_102:
        v117 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_load_chunks_from_stream",  307,  138,  *v117,  "aaCalloc",  v118,  v119,  v150);
        uint64_t v55 = 0LL;
        goto LABEL_92;
      }

      uint64_t v31 = calloc(v29 >> 16, 0xCuLL);
      uint64_t v34 = v27 + 440 * v26;
      *(void *)(v34 + 384) = v31;
      if (!v31) {
        goto LABEL_102;
      }
      uint64_t v35 = (void **)(v34 + 384);
      uint64_t v36 = *v30;
      uint64_t v164 = v27;
      if (*(_BYTE *)(v27 + 440 * v26 + 432) == 4)
      {
        int v156 = a3;
        v158 = v11;
        unint64_t v162 = v26;
        v37 = (void *)(v27 + 440 * v26);
        uint64_t v38 = v37[5];
        v152 = v35;
        uint64_t v154 = v37[50];
        v37[51] |= 4uLL;
        if (v20[4])
        {
          uint64_t v39 = 0LL;
          size_t v40 = 8 * v36;
          uint64_t v151 = 8 * v36 + 264;
          uint64_t v41 = v38 + 264;
          uint64_t v42 = v27 + 440 * v26 + 64;
          uint64_t v43 = v38;
          uint64_t v44 = 264LL;
          while (1)
          {
            uint64_t v45 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v42, v44, v43);
            if (v45 < 0) {
              break;
            }
            if (v45)
            {
              v42 += v45;
              v39 += v45;
              v43 += v45;
              v44 -= v45;
              if (v44) {
                continue;
              }
            }

            if (v39 != 264) {
              break;
            }
            if (v20[4])
            {
              uint64_t v46 = 0LL;
              uint64_t v47 = v164 + 440 * v162 + 328;
              uint64_t v48 = v38 + v154 - 50;
              uint64_t v49 = 50LL;
              while (1)
              {
                uint64_t v50 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v47, v49, v48);
                if (v50 < 0) {
                  break;
                }
                if (v50)
                {
                  v47 += v50;
                  v46 += v50;
                  v48 += v50;
                  v49 -= v50;
                  if (v49) {
                    continue;
                  }
                }

                if (v46 != 50) {
                  break;
                }
                if (v40 >= 0x2000000001LL)
                {
                  uint64_t v55 = 0LL;
                  *__error() = 12;
                  goto LABEL_91;
                }

                uint64_t v51 = (int *)malloc(v40);
                uint64_t v55 = v51;
                if (!v51) {
                  goto LABEL_91;
                }
                if (!v20[4]) {
                  goto LABEL_111;
                }
                if (v40)
                {
                  uint64_t v56 = 0LL;
                  v57 = (char *)v51;
                  size_t v58 = v40;
                  while (1)
                  {
                    uint64_t v59 = ((uint64_t (*)(uint64_t *, char *, size_t, uint64_t))v20[4])(*v20, v57, v58, v41);
                    if (v59 < 0) {
                      break;
                    }
                    if (v59)
                    {
                      v57 += v59;
                      v56 += v59;
                      v41 += v59;
                      v58 -= v59;
                      if (v58) {
                        continue;
                      }
                    }

                    goto LABEL_42;
                  }

                  uint64_t v56 = v59;
LABEL_42:
                  if (v40 != v56)
                  {
LABEL_111:
                    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_load_chunks_from_stream",  333,  138,  0,  "fork chunks",  v53,  v54,  v150);
                    goto LABEL_91;
                  }
                }

                uint64_t v61 = *v30;
                v62 = *v152;
                if (!*v30)
                {
                  uint64_t v63 = 50LL;
                  size_t v60 = v151;
                  size_t v67 = v151;
                  uint64_t v11 = v158;
                  a3 = v156;
                  unint64_t v26 = v162;
                  goto LABEL_53;
                }

                v68 = v62 + 1;
                v69 = v55 + 1;
                uint64_t v70 = *v30;
                uint64_t v11 = v158;
                unint64_t v26 = v162;
                size_t v60 = v151;
                do
                {
                  *((void *)v68 - 1) = (*(v69 - 1) + 260);
                  int v71 = *v69;
                  v69 += 2;
                  _DWORD *v68 = v71;
                  v68 += 3;
                  --v70;
                }

                while (v70);
                uint64_t v63 = 50LL;
                a3 = v156;
                goto LABEL_47;
              }
            }

            v105 = "fork footer";
            __int16 v106 = 328;
            goto LABEL_90;
          }
        }

        v105 = "fork header";
        __int16 v106 = 325;
LABEL_90:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_load_chunks_from_stream",  v106,  138,  0,  v105,  v32,  v33,  v150);
        uint64_t v55 = 0LL;
LABEL_91:
        uint64_t v11 = v158;
        a3 = v156;
        goto LABEL_92;
      }

      size_t v60 = 4 * v36 + 4;
      if (v60 >= 0x2000000001LL)
      {
        uint64_t v55 = 0LL;
        *__error() = 12;
        goto LABEL_92;
      }

      uint64_t v55 = (int *)malloc(v60);
      if (!v55) {
        goto LABEL_92;
      }
      if (v60 != AAByteStreamPRead((AAByteStream)v20, v55, v60, *(void *)(v164 + 440 * v26 + 40)))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_load_chunks_from_stream",  351,  138,  0,  "fork chunks",  v53,  v54,  v150);
        goto LABEL_92;
      }

      uint64_t v61 = *v30;
      v62 = *v35;
      uint64_t v63 = 0LL;
      if (*v30)
      {
        v64 = v62 + 1;
        do
        {
          v65 = (unsigned int *)&v55[v63];
          uint64_t v66 = *v65;
          *((void *)v64 - 1) = v66;
          ++v63;
          _DWORD *v64 = v65[1] - v66;
          v64 += 3;
        }

        while (v61 != v63);
        uint64_t v63 = 0LL;
LABEL_47:
        v72 = (unsigned int *)(v62 + 1);
        size_t v67 = v60;
        while (1)
        {
          size_t v73 = *((void *)v72 - 1);
          if (v73 < v67) {
            break;
          }
          size_t v67 = v73 + *v72;
          if (v67 > *(void *)(v164 + 440 * v26 + 400)) {
            break;
          }
          v72 += 3;
          if (!--v61) {
            goto LABEL_53;
          }
        }

        if (!a3)
        {
          v103 = "bad chunk";
          __int16 v104 = 372;
LABEL_82:
          pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_load_chunks_from_stream",  v104,  138,  v103,  v52,  v53,  v54,  v150);
          goto LABEL_92;
        }

        goto LABEL_92;
      }

      size_t v67 = v60;
LABEL_53:
      if (*v62 != v60 || v67 + v63 != *(void *)(v164 + 440 * v26 + 400)) {
        break;
      }
      free(v55);
      ++v26;
      a2 = v160;
      if (v26 >= *(void *)(a1 + 2160)) {
        goto LABEL_56;
      }
    }

    if (!a3)
    {
      v103 = "bad index";
      __int16 v104 = 381;
      goto LABEL_82;
    }

LABEL_92:
    free(v55);
    rawimg_free_chunks((void *)a1);
    if (!a3) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  587,  138,  "bad chunk info",  v110,  v111,  v112,  v150);
    }
    goto LABEL_94;
  }

    ++v62;
    if (v82) {
      goto LABEL_121;
    }
  }

  atomic_load(v115);
LABEL_121:
  if ((ThreadPipelineDestroy(v61) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  447,  37,  0,  "ThreadPipelineDestroy",  v100,  v101,  v106);
    free(v49);
    goto LABEL_105;
  }

  free(v49);
  if (!v63)
  {
LABEL_105:
    uint64_t v89 = "processStream";
    uint64_t v90 = 513;
    goto LABEL_106;
  }

  unint64_t v102 = (*(uint64_t (**)(void, void, void))(a2 + 24))(*(void *)(a2 + 40), 0LL, 0LL);
  if (v102 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"pcWrite",  121,  37,  0,  "pcWrite EOF failed",  v103,  v104,  v106);
    uint64_t v89 = "writing EOF";
    uint64_t v90 = 520;
    goto LABEL_106;
  }

  uint64_t v95 = 0;
  *((void *)&v113 + 1) += v102;
  unint64_t v94 = 1;
LABEL_107:
  v96 = v114[1];
  if (v114[1])
  {
    if (SDWORD2(v108) >= 1)
    {
      v97 = 0LL;
      uint64_t v98 = 0LL;
      do
      {
        free(*(void **)((char *)v114[1] + v97 + 8));
        free(*(void **)((char *)v114[1] + v97 + 40));
        ++v98;
        v97 += 72LL;
      }

      while (v98 < SDWORD2(v108));
      v96 = v114[1];
    }

    free(v96);
    v114[1] = 0LL;
  }

  uint64_t v99 = v94 ^ 1;
  if (!a3) {
    uint64_t v99 = 1;
  }
  if ((v99 & 1) == 0)
  {
    unint64_t v29 = 0;
    *(_OWORD *)a3 = v113;
    goto LABEL_40;
  }

  if (!v95)
  {
    unint64_t v29 = 0;
    goto LABEL_40;
  }

        v78 = -1;
LABEL_93:
        if (*(_DWORD *)(v81 + 2300) != v78)
        {
          *(_DWORD *)(v81 + 2300) = v78;
          v79 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 1040);
          if (v79)
          {
            if (v78 == -1) {
              v80 = 22LL;
            }
            else {
              v80 = 21LL;
            }
            v79(*(void *)(v11 + 1032), v80, v81, v81 + 2272);
          }
        }

        v72 = v81;
LABEL_100:
        entryRelease(v72, v40, v41, v42, v43, v44, v45, v46);
      }

      if (link((const char *)&buf, v151) < 0)
      {
        size_t v73 = *__error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamProcessClusters",  1108,  72,  v73,  "failed to create hard link: %s",  v74,  v75,  v81);
        goto LABEL_92;
      }

      int v71 = 1;
      goto LABEL_80;
    }

LABEL_56:
  *(void *)(a1 + 2128) |= 8uLL;
  v76 = aaForkInputStreamOpen(v20, a1, 1, v21, v22, v23, v24, v25);
  if (!v76)
  {
    v107 = "aaForkInputStreamOpen";
    __int16 v108 = 593;
    int v109 = 0;
LABEL_87:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  v108,  138,  v109,  v107,  v74,  v75,  v150);
    v79 = 0LL;
    v82 = 0LL;
    v80 = 0LL;
LABEL_88:
    v93 = 0LL;
    goto LABEL_95;
  }

  unint64_t v77 = *(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23);
  if (!is_mul_ok(v77, 0x38uLL) || 56 * v77 > 0x2000000000LL)
  {
    *__error() = 12;
    goto LABEL_86;
  }

  v78 = calloc(*(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23), 0x38uLL);
  if (!v78)
  {
LABEL_86:
    int v109 = *__error();
    v107 = "aaCalloc";
    __int16 v108 = 601;
    goto LABEL_87;
  }

  v79 = v78;
  if (a2 < 0)
  {
    *__error() = 12;
    v80 = 0LL;
    v82 = 0LL;
    *__error() = 12;
LABEL_104:
    v120 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  606,  138,  *v120,  "aaCalloc",  v121,  v122,  v150);
    goto LABEL_88;
  }

  v80 = (uint64_t **)calloc(a2, 0x10uLL);
  v81 = calloc(a2, 8uLL);
  v82 = v81;
  if (!v80 || !v81) {
    goto LABEL_104;
  }
  if (a2)
  {
    uint64_t v83 = a2;
    v84 = v80;
    v85 = (uint64_t ***)v81;
    do
    {
      *v85++ = v84;
      *v84 = v76;
      v84 += 2;
      --v83;
    }

    while (v83);
  }

  v93 = ThreadPoolCreate(a2, (uint64_t)v81, (uint64_t)rawimg_digest_worker);
  if (!v93)
  {
    v123 = "ThreadPoolCreate";
    __int16 v124 = 613;
    goto LABEL_110;
  }

  unint64_t v153 = v77;
  v159 = v11;
  unint64_t v94 = *(void *)(a1 + 2056);
  if (v94 < *(void *)(a1 + 2072))
  {
    size_t v165 = 0LL;
    uint64_t v95 = -(uint64_t)v94;
    v96 = v79;
    while (1)
    {
      uint64_t Worker = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
      if (!Worker)
      {
        v143 = "ThreadPoolGetWorker";
        __int16 v144 = 622;
        goto LABEL_133;
      }

      *(void *)(Worker + 8) = v96;
      v96[6] = -1LL;
      v96[4] = v94;
      unint64_t v102 = v95 + *(void *)(a1 + 2072);
      if (v102 >= 0x800000) {
        unint64_t v102 = 0x800000LL;
      }
      v96[5] = v102;
      ++v165;
      v94 += 0x800000LL;
      v96 += 7;
      v95 -= 0x800000LL;
      if (v94 >= *(void *)(a1 + 2072)) {
        goto LABEL_113;
      }
    }

    v143 = "ThreadPoolRunWorker";
    __int16 v144 = 627;
    goto LABEL_133;
  }

  size_t v165 = 0LL;
LABEL_113:
  unint64_t v125 = *(void *)(a1 + 2160);
  if (!v125)
  {
    uint64_t v11 = v159;
    size_t v127 = v153;
    size_t v128 = v165;
LABEL_127:
    if (v128 <= v127)
    {
      if ((ThreadPoolSync(v93) & 0x80000000) == 0)
      {
        qsort(v79, v128, 0x38uLL, (int (__cdecl *)(const void *, const void *))compare_digest_tasks);
        CC_SHA256_Init(&c);
        if (v128)
        {
          v145 = (char *)v79;
          do
          {
            CC_SHA256_Update(&c, v145, 0x20u);
            v145 += 56;
            --v128;
          }

          while (v128);
        }

        CC_SHA256_Final((unsigned __int8 *)(a1 + 2088), &c);
        if (*(void *)(a1 + 2160))
        {
          uint64_t v146 = 0LL;
          unint64_t v147 = 0LL;
          do
          {
            CC_SHA256_Init(&c);
            if (v79[7 * v146 + 6] == v147)
            {
              v148 = &v79[7 * v146];
              do
              {
                CC_SHA256_Update(&c, v148, 0x20u);
                ++v146;
                uint64_t v149 = v148[13];
                v148 += 7;
              }

              while (v149 == v147);
            }

            CC_SHA256_Final((unsigned __int8 *)(*(void *)(a1 + 2144) + 440 * v147++), &c);
          }

          while (v147 < *(void *)(a1 + 2160));
        }

        *(void *)(a1 + 2128) |= 0x10uLL;
        int v113 = 1;
        goto LABEL_134;
      }

      v123 = "ThreadPoolSync";
      __int16 v124 = 655;
    }

    else
    {
      v123 = "too many tasks";
      __int16 v124 = 649;
    }

  uint64_t v48 = *(unsigned int *)(a4 + 8);
  if (!(_DWORD)v48)
  {
LABEL_66:
    uint64_t v8 = "Input doesn't match any of the expected patch inputs";
    uint64_t v9 = 310;
    goto LABEL_48;
  }

  uint64_t v49 = 0LL;
  uint64_t v50 = a4 + 68;
  while (1)
  {
    uint64_t v51 = *(void *)md == *(void *)v50 && v155 == *(void *)(v50 + 8);
    ++v49;
    v50 += 28LL;
    if (v48 == v49) {
      goto LABEL_66;
    }
  }

  uint64_t v146 = v49;
  if (v149)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Patch matching entry %u\n", v49);
    uint64_t v49 = v146;
    uint64_t v48 = *(unsigned int *)(a4 + 8);
  }

  uint64_t v135 = v36;
  uint64_t v53 = v151;
  unint64_t v142 = (uint64_t)v151 + 28 * v48;
  __int16 v144 = *(void *)(a4 + 24);
  uint64_t v54 = v142 + v144;
  if ((_DWORD)v48)
  {
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
    do
    {
      if (v49 == v55) {
        uint64_t v56 = v54;
      }
      v57 = *v53;
      uint64_t v53 = (uint64_t *)((char *)v53 + 28);
      v54 += v57;
      ++v55;
    }

    while (v48 != v55);
  }

  else
  {
    uint64_t v56 = 0LL;
  }

  uint64_t v138 = *(void *)(a4 + 32);
  uint64_t v140 = *(void *)(v50 - 8);
  if (v54 + v138 - a4 != a5)
  {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  331,  42,  "Warning: extra bytes in patch (ignored)\n",  v35,  a7,  a8,  v130);
    LODWORD(v48) = *(_DWORD *)(a4 + 8);
  }

  uint64_t v137 = *(void *)(a4 + 16);
  size_t v58 = 8LL * (v48 + 2);
  v152 = (char *)malloc(0x20000uLL);
  uint64_t v59 = malloc(0x20000uLL);
  v136 = v58;
  size_t v60 = v58;
  uint64_t v61 = v152;
  char v150 = malloc(v60);
  enterThreadErrorContext((uint64_t)v150, v62, v63, v64, v65, v66, v67, v68, v130);
  v148 = v59;
  if (!v59 || !v152 || !v150)
  {
    uint64_t v112 = *__error();
    int v113 = "malloc";
    uint64_t v114 = 351;
LABEL_133:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  v114,  42,  v112,  v113,  v69,  v70,  v131);
    int v109 = 0LL;
    uint64_t v110 = 0LL;
    uint64_t v115 = 0LL;
    size_t v73 = 0LL;
    v116 = 0LL;
    uint64_t v111 = -1;
    uint64_t v91 = v148;
    goto LABEL_155;
  }

  v145 = ILowMemoryDecoderStreamCreateWithBuffer(v142, v144, 0x20000uLL);
  if (!v145)
  {
    int v113 = "Control stream init";
    uint64_t v114 = 352;
    uint64_t v112 = 0;
    goto LABEL_133;
  }

  size_t v73 = ILowMemoryDecoderStreamCreateWithBuffer(v56, v140, 0x20000uLL);
  if (!v73)
  {
    v117 = "Diff stream init";
    uint64_t v118 = 353;
LABEL_136:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  v118,  42,  0,  v117,  v71,  v72,  v131);
    int v109 = 0LL;
    uint64_t v110 = 0LL;
    uint64_t v115 = 0LL;
    uint64_t v111 = -1;
    uint64_t v91 = v148;
    v116 = v145;
    goto LABEL_155;
  }

  v143 = ILowMemoryDecoderStreamCreateWithBuffer(v54, v138, 0x20000uLL);
  if (!v143)
  {
    v117 = "Archive stream init";
    uint64_t v118 = 354;
    goto LABEL_136;
  }

  uint64_t v74 = (CC_SHA1_CTX *)OSHA1StreamCreate((uint64_t)a6, 0LL, a7);
  if (!v74)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  355,  42,  0,  "Digest stream init",  v75,  v76,  v131);
    int v109 = 0LL;
    uint64_t v110 = 0LL;
    uint64_t v111 = -1;
    uint64_t v91 = v148;
    v116 = v145;
LABEL_141:
    uint64_t v115 = v143;
    goto LABEL_155;
  }

  uint64_t v139 = v73;
  v134 = v74;
  uint64_t v141 = OBufferedStreamCreate((uint64_t)OSHA1StreamWrite, (uint64_t)OSHA1StreamAbort, (uint64_t)v74, 0x20000uLL);
  if (!v141)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  356,  42,  0,  "OBufferedStreamCreate",  v82,  v83,  v131);
    uint64_t v110 = 0LL;
    uint64_t v111 = -1;
    uint64_t v61 = v152;
    uint64_t v91 = v148;
    uint64_t v115 = v143;
    v116 = v145;
    goto LABEL_154;
  }

  if (!v137)
  {
LABEL_123:
    OBufferedStreamDestroy((void ***)v141, v77, v78, v79, v80, v81, v82, v83);
    OSHA1StreamDestroy(v134, md);
    if (*(void *)md == *(void *)v135
      && v155 == *(void *)(v135 + 8)
      && v156 == (unint64_t)*(unsigned int *)(v135 + 16))
    {
      uint64_t v111 = 0;
      int v109 = 0LL;
      uint64_t v110 = 0LL;
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  421,  42,  0,  "Invalid output digest after patch application",  v105,  v106,  v131);
      int v109 = 0LL;
      uint64_t v110 = 0LL;
      uint64_t v111 = -1;
    }

    uint64_t v61 = v152;
    uint64_t v91 = v148;
    v116 = v145;
    size_t v73 = v139;
    goto LABEL_141;
  }

  v84 = 0LL;
  v85 = 0LL;
  v133 = (v146 + 2);
  while (1)
  {
    if (ILowMemoryDecoderStreamRead(v145, (char *)v150, v136) != v136)
    {
      uint64_t v121 = "reading from control stream";
      uint64_t v122 = 362;
      goto LABEL_151;
    }

    uint64_t v86 = *((void *)v150 + 1);
    else {
      uint64_t v87 = 0x8000000000000000LL - *(void *)v150;
    }
    uint64_t v88 = 0x8000000000000000LL - v86;
    if (v86 >= 0) {
      uint64_t v88 = *((void *)v150 + 1);
    }
    unint64_t v147 = v88;
    uint64_t v89 = *((void *)v150 + v133);
    if (v89 < 0) {
      uint64_t v89 = 0x8000000000000000LL - v89;
    }
    uint64_t v132 = v89;
    if (v84 < 0 || v87 + v84 > a3)
    {
      uint64_t v121 = "Invalid in segment in patch";
      uint64_t v122 = 369;
      goto LABEL_151;
    }

    if (v87 + v85 + v147 > *(void *)(a4 + 16))
    {
      uint64_t v121 = "Invalid out segment in patch";
      uint64_t v122 = 370;
LABEL_151:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  v122,  42,  0,  v121,  v82,  v83,  v131);
      uint64_t v111 = -1;
      uint64_t v61 = v152;
LABEL_152:
      uint64_t v91 = v148;
      goto LABEL_153;
    }

    if (v87) {
      break;
    }
LABEL_114:
    if (v147)
    {
      uint64_t v99 = 0LL;
      uint64_t v100 = v147;
      while (1)
      {
        uint64_t v101 = v100 - v99;
        if (v101 >= 0x20000) {
          unint64_t v102 = 0x20000LL;
        }
        else {
          unint64_t v102 = v101;
        }
        if (ILowMemoryDecoderStreamRead(v143, v152, v102) != v102)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  405,  42,  0,  "reading from archive stream",  v103,  v104,  v131);
          uint64_t v111 = -1;
          uint64_t v61 = v152;
          goto LABEL_152;
        }

        v99 += v102;
        v85 += v102;
        uint64_t v100 = v147;
        if (v99 >= v147) {
          goto LABEL_122;
        }
      }

      uint64_t v121 = "writing to digest stream";
      uint64_t v122 = 407;
      goto LABEL_151;
    }

  nbyte = v3;
  __n = v6;
  v117 = (_DWORD *)(a1 + 668);
  uint64_t v118 = a2;
  uint64_t v43 = *(_DWORD *)(a1 + 404);
  uint64_t v44 = v43 - 1;
  while (v43)
  {
    uint64_t v45 = *(_DWORD *)(a1 + 20);
    v120 = v44;
    uint64_t v121 = v43 - 1;
    uint64_t v46 = (v45 * (v43 - 1));
    uint64_t v47 = v45 * v43;
    uint64_t v48 = *(_DWORD *)(a1 + 400);
    if (v47 >= v48) {
      uint64_t v49 = v48;
    }
    else {
      uint64_t v49 = v47;
    }
    uint64_t v50 = *(void *)(a1 + 392);
    uint64_t v119 = *(void *)(v50 + 544LL * v46 + 16);
    uint64_t v51 = *(void *)(a1 + 368);
    uint64_t v122 = *(void *)(a1 + 376);
    uint64_t v52 = 0LL;
    if (v46 < v49)
    {
      uint64_t v53 = (_DWORD *)(v50 + 544LL * (v45 * v44));
      do
      {
        uint64_t v54 = &v9[v52];
        *(_DWORD *)uint64_t v54 = v53[1];
        *((_DWORD *)v54 + 1) = v53[2];
        uint64_t v55 = v52 + 8;
        memcpy(&v9[v55], v53 + 7, v53[6]);
        uint64_t v52 = v55 + v53[6];
        memcpy(&v9[v51], v53 + 72, v53[71]);
        v51 += v53[71];
        ++v46;
        v53 += 136;
      }

      while (v46 < v49);
    }

    uint64_t v56 = *(void *)(a1 + 360);
    v57 = v122;
    if (v56 > v52)
    {
      memset_s(&v9[v52], v56 - v52, 0, v56 - v52);
      v57 = *(void *)(a1 + 376);
    }

    size_t v58 = v57 - v51;
    a2 = v118;
    if (v57 > v51)
    {
      uint64_t v59 = *(uint64_t (**)(char *, unint64_t))(a1 + 136);
      if (!v59 || (v59(&v9[v51], v58) & 0x80000000) != 0)
      {
        v69 = "generating random padding";
        uint64_t v70 = 687;
        goto LABEL_109;
      }
    }

    memcpy(&v9[*(void *)(a1 + 360)], (char *)__s + 4, LODWORD(__s[0]));
    v205 = 0;
    v204 = 0u;
    v203 = 0u;
    v202 = 0u;
    v201 = 0u;
    v200 = 0u;
    v199 = 0u;
    v198 = 0u;
    v197 = 0u;
    v196 = 0u;
    v195 = 0u;
    v194 = 0u;
    v193 = 0u;
    v192 = 0u;
    v191 = 0u;
    v190 = 0u;
    v189 = 0u;
    memset(&v207[8], 0, 252);
    memset(v206, 0, 260);
    *(_WORD *)&v207[8] = 19267;
    *(void *)v207 = 0x5F41454100000006LL;
    result = memset_s(&v207[10], 0xFAuLL, 0, 0xFAuLL);
    size_t v60 = *(unsigned int *)v207;
    if (*(_DWORD *)v207 >= 0xFDu) {
      goto LABEL_162;
    }
    *(_DWORD *)&v207[*(unsigned int *)v207 + 4] = v121;
    *(_DWORD *)v207 = v60 + 4;
    memset_s(&v207[v60 + 8], 252 - v60, 0, 252 - v60);
    uint64_t v61 = *(uint64_t (**)(__int128 *, void, _DWORD *, _BYTE *, _OWORD *))(a1 + 144);
    if (!v61 || !*v117)
    {
      memset_s(v207, 0x104uLL, 0, 0x104uLL);
LABEL_75:
      uint64_t v63 = 1;
      goto LABEL_76;
    }

    v62 = v61(&v189, *(unsigned int *)(a1 + 72), v117, v207, v206);
    memset_s(v207, 0x104uLL, 0, 0x104uLL);
    uint64_t v63 = 0;
    if (v62 < 0) {
      goto LABEL_75;
    }
LABEL_76:
    memset((char *)v206 + 12, 0, 248);
    *(void *)((char *)v206 + 4) = 0x4B4548435F414541LL;
    LODWORD(v206[0]) = 8;
    memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v207, 0, sizeof(v207));
    v64 = *(uint64_t (**)(_OWORD *, void, __int128 *, _OWORD *, _BYTE *))(a1 + 144);
    if (!v64 || !(_DWORD)v189)
    {
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
LABEL_107:
      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
LABEL_108:
      v69 = "derivating secondary key";
      uint64_t v70 = 695;
LABEL_109:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  v70,  28,  0,  v69,  v11,  v12,  nbyte);
      uint64_t v30 = 0;
      uint64_t v27 = 0LL;
      uint64_t v28 = 0LL;
LABEL_110:
      unint64_t v29 = 0xFFFFFFFFLL;
LABEL_111:
      uint64_t v6 = __n;
      goto LABEL_25;
    }

    v65 = v64(v151, *(unsigned int *)(a1 + 76), &v189, v206, v207);
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    if (v65 < 0) {
      goto LABEL_107;
    }
    memset_s(&v189, 0x104uLL, 0, 0x104uLL);
    if (v63) {
      goto LABEL_108;
    }
    uint64_t v66 = *(uint64_t (**)(char *, void, _OWORD *, _OWORD *, char *, size_t))(a1 + 160);
    if (!v66
      || (size_t v67 = v66(v9, *(void *)(a1 + 360), __s, v151, &v9[*(void *)(a1 + 360)], v4 - *(void *)(a1 + 360)),
          LODWORD(__s[0]) != *(_DWORD *)(a1 + 84))
      || v67 < 0)
    {
      v69 = "Cluster header encryption";
      uint64_t v70 = 702;
      goto LABEL_109;
    }

    v68 = AAByteStreamPWrite(v118, v9, v4, v119 - v122);
    uint64_t v44 = v120 - 1;
    uint64_t v43 = v121;
    if (v68 != v4)
    {
      v69 = "writing cluster header";
      uint64_t v70 = 707;
      goto LABEL_109;
    }
  }

  uint64_t v6 = __n;
  memset_s(v9, __n, 0, __n);
  if ((aeaMagicInit(&v123, (_DWORD *)a1) & 0x80000000) != 0)
  {
    uint64_t v31 = "encoding magic";
    uint64_t v32 = 717;
    goto LABEL_23;
  }

  int v71 = *(void *)(a1 + 288);
  v72 = &v9[*(void *)(a1 + 280)];
  *(void *)v72 = v123;
  *((_DWORD *)v72 + 2) = v124;
  memcpy(&v9[v71], *(const void **)(a1 + 384), *(unsigned int *)(a1 + 4));
  memcpy(&v9[*(void *)(a1 + 336)], (char *)__s + 4, LODWORD(__s[0]));
  if ((aeaRootHeaderInit((uint64_t)&v125, a1, v73, v74, v75, v76, v77, v78) & 0x80000000) != 0)
  {
    uint64_t v31 = "encoding root header";
    uint64_t v32 = 727;
    goto LABEL_23;
  }

  v79 = LODWORD(__s[0]);
  v80 = *(unsigned int *)(a1 + 4);
  uint64_t v27 = (v80 + LODWORD(__s[0]));
  v81 = (char *)malloc(v27);
  uint64_t v28 = v81;
  if (!v81)
  {
    v103 = *__error();
    uint64_t v99 = "malloc";
    uint64_t v100 = 732;
LABEL_121:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  v100,  28,  v103,  v99,  v93,  v94,  nbyte);
    uint64_t v30 = 0;
    goto LABEL_110;
  }

  memcpy(v81, (char *)__s + 4, v79);
  memcpy(&v28[v79], *(const void **)(a1 + 384), v80);
  memset((char *)v206 + 12, 0, 248);
  *(void *)((char *)v206 + 4) = 0x4B4548525F414541LL;
  LODWORD(v206[0]) = 8;
  memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v207, 0, sizeof(v207));
  v82 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _BYTE *))(a1 + 144);
  if (!v82 || !*v117)
  {
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    uint64_t v6 = __n;
    goto LABEL_118;
  }

  uint64_t v83 = v82(v151, *(unsigned int *)(a1 + 76), v117, v206, v207);
  memset_s(v206, 0x104uLL, 0, 0x104uLL);
  uint64_t v6 = __n;
  if (v83 < 0)
  {
LABEL_118:
    uint64_t v101 = "derivating RHEK";
    unint64_t v102 = 739;
LABEL_119:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  v102,  28,  0,  v101,  v84,  v85,  nbyte);
    uint64_t v30 = 0;
    goto LABEL_24;
  }

  uint64_t v86 = *(uint64_t (**)(__int128 *, uint64_t, size_t *, _OWORD *, char *, rsize_t))(a1 + 160);
  if (!v86
    || (uint64_t v87 = v86(&v125, 48LL, v153, v151, v28, v27), v88 = LODWORD(v153[0]), LODWORD(v153[0]) != *(_DWORD *)(a1 + 84))
    || v87 < 0)
  {
    uint64_t v101 = "Root header encryption";
    unint64_t v102 = 745;
    goto LABEL_119;
  }

  uint64_t v89 = *(void *)(a1 + 320);
  uint64_t v90 = &v9[*(void *)(a1 + 328)];
  uint64_t v91 = v126;
  *(_OWORD *)uint64_t v90 = v125;
  *((_OWORD *)v90 + 1) = v91;
  *((_OWORD *)v90 + 2) = v127;
  memcpy(&v9[v89], (char *)v153 + 4, v88);
  memcpy(&v9[*(void *)(a1 + 312)], (const void *)(a1 + 412), *(unsigned int *)(a1 + 408));
  uint64_t v92 = *(unsigned int *)(a1 + 928);
  if ((_DWORD)v92 != *(_DWORD *)(a1 + 120))
  {
    uint64_t v101 = "Invalid encryption data size";
    unint64_t v102 = 753;
    goto LABEL_119;
  }

  memcpy(&v9[*(void *)(a1 + 304)], (const void *)(a1 + 932), v92);
  if (!*(_DWORD *)(a1 + 1188) && !*(void *)(a1 + 1712))
  {
LABEL_153:
    int v113 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 272);
    if (v113
      && (uint64_t v114 = v113(a1 + 1448, v9, nbyte), *(_DWORD *)(a1 + 1448) == *(_DWORD *)(a1 + 124))
      && (v114 & 0x80000000) == 0)
    {
      if (AAByteStreamPWrite(a2, v9, nbyte, 0LL) == nbyte)
      {
        uint64_t v30 = 0;
        unint64_t v29 = 0LL;
        goto LABEL_111;
      }

      uint64_t v99 = "writing container headers";
      uint64_t v100 = 801;
    }

    else
    {
      uint64_t v99 = "digesting prologue";
      uint64_t v100 = 797;
    }

    goto LABEL_125;
  }

  uint64_t v95 = *(uint64_t (**)(_OWORD *, char *, size_t))(a1 + 192);
  if (!v95 || (v96 = v95(v128, v9, nbyte), LODWORD(v128[0]) != *(_DWORD *)(a1 + 108)) || v96 < 0)
  {
    uint64_t v99 = "digesting prologue";
    uint64_t v100 = 760;
LABEL_125:
    v103 = 0;
    goto LABEL_121;
  }

  v97 = *(uint64_t (**)(void, uint64_t, char *, _BYTE *, char *))(a1 + 1712);
  if (!v97)
  {
    __int16 v104 = *(uint64_t (**)(_OWORD *, uint64_t, _OWORD *))(a1 + 200);
    if (!v104
      || (result = v104(v149, a1 + 1188, v128), LODWORD(v149[0]) != *(_DWORD *)(a1 + 112))
      || (result & 0x80000000) != 0)
    {
      uint64_t v99 = "signing prologue";
      uint64_t v100 = 779;
      goto LABEL_125;
    }

      if (fremovexattr(*(_DWORD *)a1, "com.apple.ResourceFork", 32) < 0)
      {
        uint64_t v11 = *__error();
        uint64_t v9 = "Removing xattr";
        uint64_t v10 = 459;
        goto LABEL_6;
      }

      if (fremovexattr(*(_DWORD *)a1, "com.apple.decmpfs", 32) < 0)
      {
        uint64_t v11 = *__error();
        uint64_t v9 = "Removing xattr";
        uint64_t v10 = 460;
        goto LABEL_6;
      }
    }

    uint64_t v12 = 0LL;
    goto LABEL_7;
  }

  uint64_t v9 = "not enough bytes received";
  uint64_t v10 = 325;
LABEL_5:
  uint64_t v11 = 0;
LABEL_6:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCStreamClose",  v10,  86,  v11,  v9,  a7,  a8,  v42);
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_7:
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free((void *)a1);
  return v12;
}

          uint64_t v34 = *v33;
          uint64_t v35 = realloc(*v33, v31);
          if (v35)
          {
            *(void *)(a1 + 120) = v31;
            *(void *)(a1 + 128) = v35;
            goto LABEL_58;
          }

          free(v34);
LABEL_65:
          *uint64_t v33 = 0LL;
          *uint64_t v28 = 0LL;
          *(void *)(a1 + 120) = 0LL;
          goto LABEL_66;
        }

LABEL_110:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  v124,  138,  0,  v123,  v91,  v92,  v150);
    goto LABEL_95;
  }

  uint64_t v126 = 0LL;
  uint64_t v11 = v159;
  size_t v127 = v153;
  size_t v128 = v165;
  while (1)
  {
    uint64_t v129 = *(void *)(a1 + 2144);
    uint64_t v130 = v129 + 440 * v126;
    if (*(void *)(v130 + 392)) {
      break;
    }
LABEL_123:
    if (++v126 >= v125) {
      goto LABEL_127;
    }
  }

  uint64_t v131 = 0LL;
  uint64_t v132 = 0LL;
  v133 = (void *)(v130 + 392);
  uint64_t v161 = v126;
  v155 = v133;
  v157 = (void *)(v129 + 440 * v126 + 48);
  size_t v166 = v128;
  v134 = &v79[7 * v128];
  while (1)
  {
    uint64_t v163 = v131;
    uint64_t v135 = v132;
    v136 = v133;
    uint64_t v137 = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
    if (!v137)
    {
      v143 = "ThreadPoolGetWorker";
      __int16 v144 = 641;
      goto LABEL_133;
    }

    *(void *)(v137 + 8) = v134;
    v134[6] = v161;
    v134[4] = v135 + *v157;
    unint64_t v142 = v163 + *v136;
    if (v142 >= 0x800000) {
      unint64_t v142 = 0x800000LL;
    }
    v134[5] = v142;
    ++v166;
    v133 = v155;
    uint64_t v131 = v163 - 0x800000;
    v134 += 7;
    uint64_t v132 = v135 + 0x800000;
    if ((unint64_t)(v135 + 0x800000) >= *v155)
    {
      unint64_t v125 = *(void *)(a1 + 2160);
      uint64_t v11 = v159;
      uint64_t v126 = v161;
      size_t v127 = v153;
      size_t v128 = v166;
      goto LABEL_123;
    }
  }

  v143 = "ThreadPoolRunWorker";
  __int16 v144 = 646;
LABEL_133:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  v144,  138,  0,  v143,  v91,  v92,  v150);
  int v113 = 0;
LABEL_134:
  uint64_t v11 = v159;
LABEL_96:
  if ((ThreadPoolDestroy((uint64_t)v93) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_get_digests",  683,  138,  0,  "ThreadPoolDestroy",  v114,  v115,  v150);
    int v113 = 0;
  }

  free(v80);
  free(v82);
  free(v79);
  AAByteStreamClose((AAByteStream)v76);
  AAByteStreamClose((AAByteStream)v20);
  AAByteStreamClose(v11);
  if (v113) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void rawimg_free_chunks(void *a1)
{
  if (a1[270])
  {
    unint64_t v2 = 0LL;
    uint64_t v3 = 384LL;
    do
    {
      uint64_t v4 = a1[268] + v3;
      free(*(void **)v4);
      *(void *)uint64_t v4 = 0LL;
      *(void *)(v4 - 328) = 0LL;
      *(void *)(v4 + 24) &= ~4uLL;
      ++v2;
      v3 += 440LL;
    }

    while (v2 < a1[270]);
  }

  a1[266] &= ~8uLL;
}

uint64_t rawimg_digest_worker(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = (char *)malloc(0x10000uLL);
  if (!v3)
  {
    int v17 = *__error();
    uint64_t v18 = "aaMalloc";
    __int16 v19 = 530;
LABEL_20:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_digest_worker",  v19,  138,  v17,  v18,  v4,  v5,  v21);
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }

  CC_SHA256_Init(&c);
  unint64_t v6 = *(void *)(v2 + 40);
  if (v6)
  {
    unint64_t v7 = 0LL;
    while (1)
    {
      unint64_t v8 = v6 - v7;
      uint64_t v9 = v8 >= 0x10000 ? 0x10000LL : v8;
      uint64_t v10 = *a1;
      if (!*(void *)(*a1 + 32LL)) {
        break;
      }
      if (v9)
      {
        uint64_t v11 = 0LL;
        unint64_t v12 = *(void *)(v2 + 32) + v7;
        uint64_t v13 = v3;
        uint64_t v14 = v9;
        while (1)
        {
          uint64_t v15 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v10 + 32))( *(void *)v10,  v13,  v14,  v12);
          if (v15 < 0) {
            break;
          }
          if (v15)
          {
            v13 += v15;
            v11 += v15;
            v12 += v15;
            v14 -= v15;
            if (v14) {
              continue;
            }
          }

          goto LABEL_15;
        }

        uint64_t v11 = v15;
LABEL_15:
        if (v9 != v11) {
          break;
        }
      }

      CC_SHA256_Update(&c, v3, v9);
      v7 += 0x10000LL;
      unint64_t v6 = *(void *)(v2 + 40);
      if (v7 >= v6) {
        goto LABEL_17;
      }
    }

    uint64_t v18 = "aaByteStreamPReadExpected";
    __int16 v19 = 537;
    int v17 = 0;
    goto LABEL_20;
  }

LABEL_17:
  CC_SHA256_Final((unsigned __int8 *)v2, &c);
  uint64_t v16 = 0LL;
LABEL_21:
  free(v3);
  return v16;
}

  uint64_t v27 = ThreadPipelineGetWorker(*(void *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
  if (!v27)
  {
    size_t v40 = "getting worker from pipeline";
    uint64_t v41 = 280;
    goto LABEL_26;
  }

  uint64_t v28 = v27;
  *(_DWORD *)(v27 + 568) = 1;
  memset_s((void *)(v27 + 8), 0x220uLL, 0, 0x220uLL);
  if ((ThreadPipelineRunWorker(*(void *)(a1 + 128), v28, v29, v30, v31, v32, v33, v34) & 0x80000000) != 0)
  {
    size_t v40 = "running worker";
    uint64_t v41 = 283;
    goto LABEL_26;
  }

  if (!v10) {
    goto LABEL_27;
  }
  return a1;
}

    a5 = (a5 & 0xFFFFFFFFFFFFC000LL) + 0x4000;
    if (a5 >= v9) {
      return a4;
    }
  }

  if (a2 != 1)
  {
    uint64_t v15 = v10 + 5 * (a5 >> 14);
    int v17 = *(unsigned __int8 *)(v15 + 4);
    uint64_t v16 = (_BYTE *)(v15 + 4);
    if (!v17)
    {
      *uint64_t v16 = 1;
      uint64_t v18 = *(_DWORD *)(a1 + 20);
      if (v18) {
        *(_DWORD *)(a1 + 20) = v18 - 1;
      }
      else {
        ++*(_DWORD *)(a1 + 28);
      }
      ++*(_DWORD *)(a1 + 24);
    }

    goto LABEL_17;
  }

  if (*v11 > 0)
  {
    unint64_t v12 = *v11 - 1;
    AAByteStream_impl *v11 = v12;
    if (!v12) {
      ++*(_DWORD *)(a1 + 20);
    }
    goto LABEL_17;
  }

  uint64_t v20 = "data not locked";
  char v21 = 99;
LABEL_20:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"SimStreamSimulate",  v21,  141,  0,  v20,  a7,  a8,  v8);
  return -1LL;
}

  uint64_t v18 = v10 + 24;
  if (v10 < 0xFFFFFFFFFFFFFFE8LL && (v18 & 0x8000000000000000LL) == 0)
  {
    if (v13 >= v18)
    {
      uint64_t v23 = *(char **)(a1 + 128);
LABEL_35:
      uint64_t v25 = &v23[v10];
      *(AAFieldKey *)uint64_t v25 = a2;
      *((void *)v25 + 1) = a3;
      *v11 += 24LL;
      goto LABEL_3;
    }

    do
    {
      while (!v13)
      {
        uint64_t v13 = 0x4000LL;
        if (v18 <= 0x4000)
        {
          uint64_t v20 = (void **)(a1 + 128);
          uint64_t v13 = 0x4000LL;
          goto LABEL_33;
        }
      }

      __int16 v19 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0) {
        __int16 v19 = v13 & (v13 >> 1);
      }
      v13 += v19;
    }

    while (v13 < v18);
    uint64_t v20 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_37;
    }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"AAHeaderSetFieldUInt",  v19,  101,  0,  v18,  v6,  v7,  v25);
  return -1;
}

      uint64_t v18 = *(_DWORD *)(v8 + 32) - (v15 != 0);
      __int16 v19 = *(_DWORD *)v8;
      __s = 0uLL;
      uint64_t v41 = 0LL;
      if ((v18 - 7) >= 8 && (v18 - 3) >= 2)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"storeDecmpfsXattr",  286,  55,  0,  "unsupported compression type: %d",  a7,  a8,  v18);
        uint64_t v23 = 0LL;
LABEL_55:
        free(v23);
        memset_s(&__s, 0x18uLL, 0, 0x18uLL);
        unint64_t v12 = "store decmpfs xattr";
        uint64_t v13 = 837;
        goto LABEL_5;
      }

      uint64_t v20 = (char *)malloc(0x4000uLL);
      if (!v20) {
        goto LABEL_52;
      }
      uint64_t v23 = v20;
      uint64_t v41 = v20;
      *(_DWORD *)uint64_t v20 = 1668116582;
      *((_DWORD *)v20 + 1) = v18;
      *((void *)v20 + 1) = v11;
      __s = xmmword_1862D8240;
      uint64_t v24 = v15 + 16;
      if (v15 >= 0xFFFFFFFFFFFFFFF0LL || (v24 & 0x8000000000000000LL) != 0) {
        goto LABEL_53;
      }
      uint64_t v25 = *(const void **)(v8 + 104);
      if (v24 > 0x4000)
      {
        for (i = 0x4000LL; i < v24; i += v27)
        {
          uint64_t v27 = i >> 1;
          if ((i & (i >> 1)) != 0) {
            uint64_t v27 = i & (i >> 1);
          }
        }

        if (i >= 0x2000000001LL)
        {
          *__error() = 12;
LABEL_52:
          uint64_t v23 = 0LL;
          __s = 0uLL;
          uint64_t v41 = 0LL;
          goto LABEL_53;
        }

        uint64_t v30 = (char *)realloc(v20, i);
        if (!v30)
        {
          free(v23);
          goto LABEL_52;
        }

        *((void *)&__s + 1) = i;
        uint64_t v41 = v30;
        uint64_t v23 = v30;
      }

      uint64_t v31 = v23 + 16;
      if (v25) {
        memcpy(v31, v25, v15);
      }
      else {
        memset_s(v31, v15, 0, v15);
      }
      *(void *)&__s = v15 + 16;
      if ((v15 & 0x8000000000000000LL) == 0)
      {
        if ((fsetxattr(v19, "com.apple.decmpfs", v23, v15 + 16, 0, 0) & 0x80000000) == 0)
        {
          free(v23);
          memset_s(&__s, 0x18uLL, 0, 0x18uLL);
          if (ftruncate(*(_DWORD *)v8, 0LL))
          {
            uint64_t v14 = *__error();
            unint64_t v12 = "ftruncate";
            uint64_t v13 = 840;
            goto LABEL_6;
          }

          if ((*(_BYTE *)(v8 + 8) & 4) != 0
            || (uint64_t v35 = *(unsigned int *)(v8 + 40), !(_DWORD)v35)
            || 93LL * *(void *)(v8 + 16) / 0x64uLL >= v35
            || *(_DWORD *)(v8 + 32) == 10
            || *(_DWORD *)(v8 + 112))
          {
            uint64_t v36 = *(_DWORD *)(v8 + 112);
            if (!v36 || v36 == v18)
            {
              v37 = *(_DWORD *)(v8 + 116);
              if (v37
                && (uint64_t v38 = *(_DWORD *)(v8 + 40)) != 0
                && v37 != v38
                && (resizeResourceFork(*(_DWORD *)v8, v37) & 0x80000000) != 0)
              {
                unint64_t v12 = "resizing resource fork";
                uint64_t v13 = 861;
              }

              else
              {
                if ((setUFCompressedBit(*(_DWORD *)v8) & 0x80000000) == 0) {
                  goto LABEL_7;
                }
                unint64_t v12 = "set UF_COMPRESSED";
                uint64_t v13 = 865;
              }
            }

            else
            {
              unint64_t v12 = "compression type mismatch";
              uint64_t v13 = 858;
            }
          }

          else
          {
            if ((decompressToData(*(_DWORD *)v8) & 0x80000000) == 0) {
              goto LABEL_7;
            }
            unint64_t v12 = "decompressing to regular data file";
            uint64_t v13 = 853;
          }

    uint64_t v20 = (char *)malloc(v18);
    if (v20)
    {
      char v21 = v20;
      uint64_t v31 = v18;
      uint64_t v32 = v20;
      uint64_t v22 = fgetxattr(fd, "com.apple.ResourceFork", v20, v9 & 0xFFFFFFFC, 0, 32);
      goto LABEL_20;
    }

uint64_t compare_digest_tasks(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a2 + 48);
  BOOL v4 = v2 >= v3;
  if (v2 == v3) {
    BOOL v4 = *(void *)(a1 + 32) >= *(void *)(a2 + 32);
  }
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1LL;
  }
}

uint64_t rawimg_set_fork_types( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x21)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_set_fork_types",  751,  138,  0,  "too many variants",  a7,  a8,  v41);
    unint64_t v8 = 0LL;
    goto LABEL_33;
  }

  if (a2 != 1)
  {
    unint64_t v8 = pc_array_init(16LL);
    if (v8)
    {
      if (!a2)
      {
LABEL_18:
        pc_array_sort(v8, (int (__cdecl *)(const void *, const void *))compare_copy_fork_5);
        pc_array_aggregate( (char *)v8,  (unsigned int (*)(char *, char *))compare_copy_fork_4,  (uint64_t (*)(char *, char *))aggregate_copy_fork);
        uint64_t v24 = *(v8 - 8);
        if (v24)
        {
          uint64_t v25 = v8 + 1;
          do
          {
            if ((*v25 & 1) == 0) {
              *(void *)(*((void *)v25 - 1) + 408LL) |= 1uLL;
            }
            v25 += 16;
            --v24;
          }

          while (v24);
        }

        pc_array_aggregate( (char *)v8,  (unsigned int (*)(char *, char *))compare_copy_fork_3,  (uint64_t (*)(char *, char *))aggregate_copy_fork);
        unint64_t v26 = *(v8 - 8);
        if (v26)
        {
          unint64_t v27 = 0LL;
          uint64_t v28 = 0LL;
          unint64_t v29 = v8 + 1;
          do
          {
            if (*v29 == ~(-1 << a2))
            {
              *(_OWORD *)&v8[2 * v28++] = *(_OWORD *)(v29 - 2);
              unint64_t v26 = *(v8 - 8);
            }

            ++v27;
            v29 += 4;
          }

          while (v27 < v26);
        }

        else
        {
          uint64_t v28 = 0LL;
        }

        *(v8 - 8) = v28;
        if (a2)
        {
          uint64_t v33 = 0LL;
          do
          {
            uint64_t v34 = *(void *)(a1 + 8 * v33);
            if (*(void *)(v34 + 2160))
            {
              unint64_t v35 = 0LL;
              uint64_t v36 = 408LL;
              do
              {
                uint64_t v37 = *(void *)(v34 + 2144);
                uint64_t v41 = v37 + v36 - 408;
                LODWORD(v42) = 0;
                uint64_t v38 = bsearch( &v41,  v8,  *(v8 - 8),  0x10uLL,  (int (__cdecl *)(const void *, const void *))compare_copy_fork_3);
                if (v38) {
                  BOOL v39 = 1;
                }
                else {
                  BOOL v39 = v33 == 0;
                }
                if (v39)
                {
                  if (v38) {
                    uint64_t v40 = 2LL;
                  }
                  else {
                    uint64_t v40 = 1LL;
                  }
                  *(void *)(v37 + v36) |= v40;
                }

                ++v35;
                v36 += 440LL;
              }

              while (v35 < *(void *)(v34 + 2160));
            }

            ++v33;
          }

          while (v33 != a2);
        }

        uint64_t v13 = 0LL;
        goto LABEL_34;
      }

      uint64_t v20 = 0LL;
      while (1)
      {
        uint64_t v21 = *(void *)(a1 + 8 * v20);
        if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0)
        {
          uint64_t v30 = "no digests found";
          __int16 v31 = 778;
          goto LABEL_32;
        }

        if (*(void *)(v21 + 2160)) {
          break;
        }
LABEL_17:
        if (++v20 == a2) {
          goto LABEL_18;
        }
      }

      uint64_t v22 = 0LL;
      unint64_t v23 = 0LL;
      while (1)
      {
        uint64_t v41 = *(void *)(v21 + 2144) + v22;
        uint64_t v42 = (1 << v20);
        if ((*(_BYTE *)(v41 + 408) & 3) != 0)
        {
          uint64_t v30 = "bad flags";
          __int16 v31 = 789;
          goto LABEL_32;
        }

        unint64_t v8 = pc_array_append((uint64_t)v8, &v41, v14, v15, v16, v17, v18, v19);
        if (!v8) {
          break;
        }
        ++v23;
        v22 += 440LL;
        if (v23 >= *(void *)(v21 + 2160)) {
          goto LABEL_17;
        }
      }

      uint64_t v30 = "pc_array_append";
      __int16 v31 = 793;
    }

    else
    {
      uint64_t v30 = "pc_array_init";
      __int16 v31 = 771;
    }

LABEL_32:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_set_fork_types",  v31,  138,  0,  v30,  v18,  v19,  v41);
LABEL_33:
    uint64_t v13 = 0xFFFFFFFFLL;
LABEL_34:
    pc_array_free((uint64_t)v8);
    return v13;
  }

  uint64_t v11 = *(void *)(*(void *)a1 + 2160LL);
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(*(void *)(*(void *)a1 + 2144LL) + 408LL);
    do
    {
      unint64_t *v12 = *v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v12 += 55;
      --v11;
    }

    while (v11);
  }

  return 0LL;
}

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"aaAssetExtractorCreateWithCheckpoint",  v35,  15,  0,  v34,  v9,  v10,  v54);
      }

      else
      {
        __int16 v31 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"aaAssetExtractorCreateWithCheckpoint",  102,  15,  *v31,  "open: %s",  v32,  v33,  (char)path);
        Common = 0LL;
      }

      AAByteStreamClose(v8);
      AAAssetExtractorDestroy((char *)Common, 0LL, v36, v37, v38, v39, v40, v41);
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorCreate",  229,  15,  "could not resume from saved checkpoint",  v42,  v43,  v44,  v55);
      unlink(path);
    }

    Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
    if (Common)
    {
      StreamOpen = aaAssetExtractStreamOpen(a1, a3);
      Common[521] = StreamOpen;
      if (StreamOpen) {
        return Common;
      }
      uint64_t v48 = "extractor stream";
      uint64_t v49 = 245;
    }

    else
    {
      uint64_t v48 = "common constructor";
      uint64_t v49 = 240;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorCreate",  v49,  15,  0,  v48,  v45,  v46,  v54);
  }

  AAAssetExtractorDestroy((char *)Common, 0LL, v24, v25, v26, v27, v28, v29);
  return 0LL;
}

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"fullReplacementBXPatch5",  v27,  42,  0,  v26,  v15,  v16,  v32);
    }

    else
    {
      uint64_t v28 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"fullReplacementBXPatch5",  50,  42,  *v28,  "malloc",  v29,  v30,  v32);
      uint64_t v17 = 0LL;
    }

    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"fullReplacementBXPatch5",  45,  42,  0,  "Missing bytes in patch",  a7,  a8,  v32);
  return 0xFFFFFFFFLL;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"AAHeaderSetFieldBlob",  v25,  101,  0,  v24,  v6,  v7,  v27);
  return -1;
}

  __int16 v31 = *v15;
  uint64_t v32 = *v15 + v14;
  if (__CFADD__(*v15, v14) || (v32 & 0x8000000000000000LL) != 0) {
    goto LABEL_49;
  }
  if (v27 < v32)
  {
    do
    {
      while (!v27)
      {
        unint64_t v27 = 0x4000LL;
        if (v32 <= 0x4000)
        {
          uint64_t v34 = (void **)((char *)acl + 40);
          unint64_t v27 = 0x4000LL;
          goto LABEL_53;
        }
      }

      uint64_t v33 = v27 >> 1;
      if ((v27 & (v27 >> 1)) != 0) {
        uint64_t v33 = v27 & (v27 >> 1);
      }
      v27 += v33;
    }

    while (v27 < v32);
    uint64_t v34 = (void **)((char *)acl + 40);
    if (v27 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_62;
    }

    if (v22 != v20)
    {
      BOOL v39 = &v18[v20];
      uint64_t v40 = &v18[v20 + v27];
      uint64_t v41 = v21;
      uint64_t v42 = v27;
      memmove(v40, v39, v23);
      unint64_t v27 = v42;
      uint64_t v21 = v41;
    }

    uint64_t v22 = *v21 + v27;
    goto LABEL_35;
  }

  if (v15 < v19)
  {
    uint64_t v32 = v19 - v15;
    if (v22 != v20)
    {
      uint64_t v33 = &v18[v20];
      uint64_t v34 = &v18[v20 - v32];
      unint64_t v35 = v32;
      memmove(v34, v33, v23);
      uint64_t v32 = v35;
      uint64_t v21 = (unint64_t *)((char *)acl + 24);
      uint64_t v20 = *((void *)acl + 3);
    }

    uint64_t v22 = v20 - v32;
LABEL_35:
    *uint64_t v21 = v22;
  }

  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > v22) {
    goto LABEL_7;
  }
  *(_DWORD *)(*((void *)acl + 5) + v17) = v15;
  uint64_t v43 = *(void *)acl;
  if (*(void *)acl > v16)
  {
    uint64_t v44 = v16;
    while (v17 < 0xFFFFFFFFFFFFFFFCLL && v17 + 4 <= *v21)
    {
      uint64_t v45 = *(unsigned int *)(*((void *)acl + 5) + v17);
      *(void *)(*((void *)acl + 2) + 8 * v44) = v17;
      v17 += v45;
      ++v44;
      uint64_t v43 = *(void *)acl;
      if (v44 >= *(void *)acl) {
        goto LABEL_43;
      }
    }

    goto LABEL_7;
  }

  unint64_t v35 = 0LL;
LABEL_38:
  AAHeaderDestroy(v13);
  return v35;
}

                unint64_t v35 = (void *)a1[2];
                uint64_t v36 = realloc(v35, v27);
                if (v36)
                {
                  a1[1] = v27;
                  a1[2] = v36;
                  goto LABEL_34;
                }

                free(v35);
LABEL_40:
                a1[1] = 0LL;
                a1[2] = 0LL;
                *a1 = 0LL;
                goto LABEL_41;
              }

uint64_t compare_copy_fork_5(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result)
  {
    int v5 = *(_DWORD *)(a1 + 8);
    int v6 = *(_DWORD *)(a2 + 8);
    uint64_t result = (v5 - v6);
    if (v5 == v6)
    {
      if (*(void *)(*(void *)a1 + 416LL) < *(void *)(*(void *)a2 + 416LL)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1LL;
      }
    }
  }

  return result;
}

uint64_t compare_copy_fork_4(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result) {
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  }
  return result;
}

uint64_t aggregate_copy_fork(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) |= *(_DWORD *)(a2 + 8);
  return 0LL;
}

uint64_t compare_copy_fork_3(unint64_t **a1, unint64_t **a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = *a2;
  unint64_t v4 = bswap64(**a1);
  unint64_t v5 = bswap64(**a2);
  if (v4 == v5
    && (unint64_t v4 = bswap64(v2[1]), v5 = bswap64(v3[1]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[2]), v5 = bswap64(v3[2]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[3]), v5 = bswap64(v3[3]), v4 == v5))
  {
    uint64_t v7 = v2[50] - v3[50];
    if (v7)
    {
      if (v7 < 0) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1LL;
      }
    }

    else
    {
      return *((unsigned __int8 *)v2 + 432) - *((unsigned __int8 *)v3 + 432);
    }
  }

  else if (v4 < v5)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return 1LL;
  }

uint64_t rawimg_save_to_stream( void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *(void *)(a2 + 2128);
  if ((v8 & 0x10) != 0)
  {
    if ((v8 & 8) != 0)
    {
      __int128 v14 = *(_OWORD *)(a2 + 2104);
      v50[0] = *(_OWORD *)(a2 + 2088);
      v50[1] = v14;
      uint64_t v15 = 24LL;
      if (!a3) {
        uint64_t v15 = 16LL;
      }
      uint64_t v51 = *(void *)(a2 + 2120);
      uint64_t v52 = v15;
      __int128 v53 = *(_OWORD *)(a2 + 2152);
      if (a1[3])
      {
        uint64_t v16 = 0LL;
        uint64_t v17 = v50;
        uint64_t v18 = 64LL;
        while (1)
        {
          uint64_t v19 = ((uint64_t (*)(void, _OWORD *, uint64_t))a1[3])(*a1, v17, v18);
          if (v19 < 1) {
            break;
          }
          uint64_t v17 = (_OWORD *)((char *)v17 + v19);
          v16 += v19;
          v18 -= v19;
          if (!v18)
          {
            if (v16 != 64) {
              break;
            }
            if (!a1[3]) {
              goto LABEL_55;
            }
            uint64_t v20 = 16 * v53;
            if (16LL * (void)v53)
            {
              uint64_t v21 = 0LL;
              uint64_t v22 = *(void *)(a2 + 2136);
              uint64_t v23 = 16 * v53;
              while (1)
              {
                uint64_t v24 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v22, v23);
                if (v24 < 1) {
                  break;
                }
                v22 += v24;
                v21 += v24;
                v23 -= v24;
                if (!v23) {
                  goto LABEL_21;
                }
              }

              uint64_t v21 = v24;
LABEL_21:
              if (v20 != v21)
              {
LABEL_55:
                uint64_t v9 = "aaByteStreamWriteExpected";
                __int16 v10 = 893;
                goto LABEL_19;
              }
            }

            if (!*((void *)&v53 + 1)) {
              return 0LL;
            }
            uint64_t v26 = 0LL;
            __n128 v27 = 0uLL;
LABEL_24:
            uint64_t v28 = *(void *)(a2 + 2144);
            *(__n128 *)((char *)v49 + 9) = v27;
            __n128 v48 = v27;
            v49[0] = v27;
            uint64_t v29 = v28 + 440 * v26;
            __n128 v48 = *(__n128 *)(v29 + 392);
            __int128 v30 = *(_OWORD *)(v29 + 408);
            v49[0] = v30;
            *(void *)&v49[1] = *(void *)(v29 + 424);
            BYTE8(v49[1]) = *(_BYTE *)(v29 + 432);
            if ((v30 & 1) == 0) {
              *(void *)&v49[0] = v30 & 0xFFFFFFFFFFFFFFFBLL;
            }
            if (a1[3])
            {
              uint64_t v31 = 0LL;
              uint64_t v32 = &v48;
              uint64_t v33 = 41LL;
              while (1)
              {
                uint64_t v34 = ((uint64_t (*)(void, __n128 *, uint64_t))a1[3])(*a1, v32, v33);
                if (v34 < 1) {
                  break;
                }
                uint64_t v32 = (__n128 *)((char *)v32 + v34);
                v31 += v34;
                v33 -= v34;
                if (!v33)
                {
                  if (v31 != 41) {
                    break;
                  }
                  __n128 v27 = 0uLL;
                  if (a3 && (v49[0] & 1) != 0)
                  {
                    if (!a1[3]) {
                      goto LABEL_60;
                    }
                    uint64_t v35 = 12LL * *(void *)(v28 + 440 * v26 + 56);
                    if (v35)
                    {
                      uint64_t v36 = 0LL;
                      uint64_t v37 = *(void *)(v28 + 440 * v26 + 384);
                      uint64_t v38 = 12LL * *(void *)(v28 + 440 * v26 + 56);
                      while (1)
                      {
                        uint64_t v39 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v37, v38, v27);
                        if (v39 < 1) {
                          break;
                        }
                        v37 += v39;
                        v36 += v39;
                        v38 -= v39;
                        if (!v38) {
                          goto LABEL_40;
                        }
                      }

                      uint64_t v36 = v39;
LABEL_40:
                      __n128 v27 = 0uLL;
                      if (v35 != v36)
                      {
LABEL_60:
                        __int16 v10 = 925;
                        goto LABEL_57;
                      }
                    }

                    if ((v49[0] & 4) != 0)
                    {
                      if (a1[3])
                      {
                        uint64_t v40 = 0LL;
                        uint64_t v41 = v28 + 440 * v26 + 64;
                        uint64_t v42 = 264LL;
                        while (1)
                        {
                          uint64_t v43 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v41, v42, v27);
                          if (v43 < 1) {
                            break;
                          }
                          v41 += v43;
                          v40 += v43;
                          v42 -= v43;
                          if (!v42)
                          {
                            if (v40 != 264) {
                              break;
                            }
                            if (a1[3])
                            {
                              uint64_t v44 = 0LL;
                              uint64_t v45 = v28 + 440 * v26 + 328;
                              uint64_t v46 = 50LL;
                              while (1)
                              {
                                uint64_t v47 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v45, v46);
                                if (v47 < 1) {
                                  break;
                                }
                                v45 += v47;
                                v44 += v47;
                                v46 -= v47;
                                if (!v46)
                                {
                                  __n128 v27 = 0uLL;
                                  if (v44 == 50) {
                                    goto LABEL_42;
                                  }
                                  break;
                                }
                              }
                            }

                            __int16 v10 = 934;
                            goto LABEL_57;
                          }
                        }
                      }

                      __int16 v10 = 932;
                      goto LABEL_57;
                    }
                  }

LABEL_42:
                  uint64_t result = 0LL;
                  return result;
                }
              }
            }

            __int16 v10 = 917;
LABEL_57:
            uint64_t v9 = "aaByteStreamWriteExpected";
            goto LABEL_19;
          }
        }
      }

      uint64_t v9 = "aaByteStreamWriteExpected";
      __int16 v10 = 888;
    }

    else
    {
      uint64_t v9 = "no chunk info";
      __int16 v10 = 877;
    }
  }

  else
  {
    uint64_t v9 = "no digest info";
    __int16 v10 = 876;
  }

  uint64_t v45 = *((void *)auth_data + 5);
  uint64_t v46 = *(void *)(*((void *)auth_data + 2) + 8 * v16);
  *(_DWORD *)(v45 + v46) = v15;
  uint64_t v47 = (char *)(v45 + v46 + 4);
  memcpy(v47, key, v13);
  memcpy(&v47[v13], data, data_size);
  return 0;
}

      __clrex();
      return -1LL;
    }

    if (v13 <= *(void *)a1) {
      uint64_t v21 = *(void *)a1;
    }
    else {
      uint64_t v21 = v8 + nbyte;
    }
    if ((resizeStream(a1, v21, v15, v16, v17, v18, v19, v20) & 0x80000000) != 0)
    {
      uint64_t v31 = "resizing stream";
      uint64_t v32 = 170;
    }

    else
    {
      uint64_t v24 = *(AAByteStream_impl **)(a1 + 112);
      if (!v24)
      {
        uint64_t v45 = a1 + 40;
        if (v13 <= v8)
        {
          int v6 = 0LL;
        }

        else
        {
          int v6 = 0LL;
          uint64_t v33 = *(void *)(a1 + 8);
          uint64_t v34 = v8 / v33;
          uint64_t v35 = v8 / v33 * v33;
          uint64_t v36 = v35 + v33;
          uint64_t v46 = v13;
          do
          {
            if (v36 >= v13) {
              uint64_t v37 = v46;
            }
            else {
              uint64_t v37 = v36;
            }
            memcpy((void *)(*(void *)(*(void *)(a1 + 32) + 8 * v34) + v8 - v35), v10, v37 - v8);
            v10 += v37 - v8;
            v6 += v37 - v8;
            ++v34;
            uint64_t v38 = *(void *)(a1 + 8);
            v35 += v38;
            uint64_t v8 = v37;
            uint64_t v13 = v46;
            uint64_t v39 = v46 > v36;
            v36 += v38;
          }

          while (v39);
        }

        uint64_t v26 = 0;
        uint64_t v40 = *(void *)a1;
        if (v13 > *(void *)a1) {
          uint64_t v40 = v13;
        }
        *(void *)a1 = v40;
        __int128 v14 = (pthread_mutex_t *)(a1 + 40);
        goto LABEL_34;
      }

      uint64_t v25 = AAByteStreamPWrite(v24, v10, nbyte, v8);
      if ((v25 & 0x8000000000000000LL) == 0)
      {
        int v6 = v25;
        uint64_t v26 = 0;
LABEL_34:
        if (pthread_mutex_unlock(v14) < 0)
        {
          uint64_t v41 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamPWrite",  209,  50,  *v41,  "mutex unlock",  v42,  v43,  v45);
        }

        else if (!v26)
        {
          return v6;
        }

        int v6 = -1LL;
        while (!__ldaxr(v4))
        {
          if (!__stlxr(1u, v4)) {
            return v6;
          }
        }

        goto LABEL_42;
      }

      uint64_t v31 = "temp file write";
      uint64_t v32 = 176;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamPWrite",  v32,  50,  0,  v31,  v22,  v23,  v45);
    int v6 = 0LL;
    uint64_t v26 = 1;
    goto LABEL_34;
  }

  return AAByteStreamPWrite(v12, buf, nbyte, offset);
}

          uint64_t v47 = 1;
          goto LABEL_68;
        }

        if (v15 == v14) {
          goto LABEL_42;
        }
        if (atomic_load((unsigned int *)(v39 + 48)))
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkWriteData",  152,  59,  0,  "Chunk has already been written",  v20,  v21,  v97);
        }

        else
        {
          uint64_t v61 = *(void *)(v39 + 32);
          if (v61)
          {
            v62 = 0LL;
            uint64_t v63 = 0LL;
            v64 = *(void *)(v39 + 40);
            v65 = __n + v38;
            while (1)
            {
              uint64_t v66 = *(void *)(v64 + v62 + 8);
              if (v66 <= v38)
              {
                size_t v67 = *(void *)(v64 + v62) + v66;
                if (v65 <= v67 && (v66 == v38 || v65 == v67)) {
                  break;
                }
              }

              ++v63;
              v62 += 16LL;
              if (v61 == v63) {
                goto LABEL_65;
              }
            }

            if (v63 < v61)
            {
              memcpy((void *)(*(void *)v39 + v38), __src, __n);
              int v71 = *(void *)(v39 + 40);
              if (*(void *)(v71 + v62 + 8) == v38) {
                *(void *)(v71 + v62 + 8) = v65;
              }
              v72 = *(void *)(v71 + v62) - __n;
              *(void *)(v71 + v62) = v72;
              if (v72)
              {
                uint64_t v47 = 1;
                a2 = __src;
                goto LABEL_68;
              }

              size_t v73 = *(void *)(v39 + 32) - 1LL;
              *(void *)(v39 + 32) = v73;
              a2 = __src;
              if (v63 < v73)
              {
                do
                {
                  ++v63;
                  *(_OWORD *)(*(void *)(v39 + 40) + v62) = *(_OWORD *)(*(void *)(v39 + 40) + v62 + 16);
                  v62 += 16LL;
                  uint64_t v47 = 1;
                }

                while (v63 < *(void *)(v39 + 32));
                goto LABEL_68;
              }

              goto LABEL_42;
            }
          }

    *((_DWORD *)a1 + 4) = v30.st_mode & 0xFFF;
    if ((a4 & 4) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

        if (!fchown(a2, v25, v26) || (uint64_t v28 = __error(), (a3 & 1) != 0) && *v28 == 1)
        {
          __n128 v27 = 1;
        }

        else
        {
          uint64_t v29 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToFD",  655,  102,  *v29,  "fchown",  v30,  v31,  v48[0]);
          __n128 v27 = 0;
        }

        goto LABEL_47;
      }

  uint64_t v45 = *((void *)xat + 5);
  uint64_t v46 = *(void *)(*((void *)xat + 2) + 8 * v16);
  *(_DWORD *)(v45 + v46) = v15;
  uint64_t v47 = (char *)(v45 + v46 + 4);
  memcpy(v47, key, v13);
  memcpy(&v47[v13], data, data_size);
  return 0;
}

LABEL_19:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_save_to_stream",  v10,  138,  0,  v9,  a7,  a8,  v48.n128_i8[0]);
  return 0xFFFFFFFFLL;
}

  if ((AAAsyncByteStreamClose(v15) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c",  (uint64_t)"AEADecryptAndExtractChunk",  128,  117,  0,  "AAAsyncByteStreamClose",  v24,  v25,  v27);
    uint64_t v21 = 0;
  }

  if (v21) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

    uint64_t v19 = (unint64_t *)(v10 + 32);
    do
      uint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 + v15, v19));
    uint64_t v21 = *(_DWORD *)(v10 + 40);
    __n128 v48 = 0;
    memset(v47, 0, sizeof(v47));
    memset(&__s[8], 0, 252);
    *(_WORD *)&__s[8] = 19267;
    memset(v49, 0, 260);
    memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
    *(_DWORD *)&__s[10] = v21;
    *(void *)__s = 0x5F4145410000000ALL;
    memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
    uint64_t v22 = *(uint64_t (**)(_OWORD *, void))(v10 + 288);
    if (v22 && *(_DWORD *)(v10 + 788))
    {
      uint64_t v23 = v22(v47, *(unsigned int *)(v10 + 216));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      uint64_t v24 = 0;
      if ((v23 & 0x80000000) == 0)
      {
LABEL_28:
        memset((char *)v49 + 12, 0, 248);
        *(void *)((char *)v49 + 4) = 0x4B4548435F414541LL;
        LODWORD(v49[0]) = 8;
        memset_s((char *)v49 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(__s, 0, sizeof(__s));
        __n128 v27 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _BYTE *))(v10 + 288);
        if (v27 && LODWORD(v47[0]))
        {
          uint64_t v28 = v27(v45, *(unsigned int *)(v10 + 220), v47, v49, __s);
          memset_s(v49, 0x104uLL, 0, 0x104uLL);
          if ((v28 & 0x80000000) == 0)
          {
            memset_s(v47, 0x104uLL, 0, 0x104uLL);
            if (!v24)
            {
              uint64_t v29 = *(uint64_t (**)(void, void, uint64_t, _OWORD *, void, void))(v10 + 312);
              if (v29)
              {
                if (*(_DWORD *)(v10 + 528) == *(_DWORD *)(v10 + 228))
                {
                  uint64_t result = v29( *(void *)(v10 + 1048),  *(void *)(v10 + 504),  v10 + 528,  v45,  *(void *)(v10 + 1048) + *(void *)(v10 + 504),  *(void *)(v10 + 520) - *(void *)(v10 + 504));
                  if ((result & 0x80000000) == 0)
                  {
                    __int128 v30 = *(unsigned int *)(v10 + 228);
                    if (v30 >= 0x101)
                    {
LABEL_66:
                      __break(1u);
                      return result;
                    }

                    memcpy( (void *)(v10 + 532),  (const void *)(*(void *)(v10 + 1048) + *(void *)(v10 + 504)),  *(unsigned int *)(v10 + 228));
                    *(_DWORD *)(v10 + 528) = v30;
                    memset_s((void *)(v10 + 532 + v30), 256 - v30, 0, 256 - v30);
                    ++*(_DWORD *)(v10 + 40);
                    uint64_t v31 = *(_DWORD *)(v10 + 164);
                    if (v31 >= *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48)) {
                      uint64_t v31 = *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48);
                    }
                    *(_DWORD *)(v10 + 56) = 0;
                    *(_DWORD *)(v10 + 60) = v31;
                    *(void *)(v10 + 64) = 0LL;
                    uint64_t result = memset_s(v45, 0x104uLL, 0, 0x104uLL);
                    uint64_t v13 = *(_DWORD *)(v10 + 60);
                    goto LABEL_39;
                  }
                }
              }

              uint64_t v25 = "decrypting cluster";
              uint64_t v26 = 95;
LABEL_58:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDe cryptionStream.c",  (uint64_t)"aeaInputStreamUnlockCluster",  v26,  30,  0,  v25,  a7,  a8,  v45[0]);
              memset_s(v45, 0x104uLL, 0, 0x104uLL);
              uint64_t v8 = "unlocking next cluster";
              uint64_t v9 = 174;
              goto LABEL_3;
            }

      if (v23 == v22) {
        continue;
      }
    }

    __n128 v27 = "aaByteStreamReadExpected";
    uint64_t v28 = 91;
    goto LABEL_24;
  }

  if ((AAAsyncByteStreamClose(v14) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c",  (uint64_t)"AEADecryptToFileChunk",  119,  56,  0,  "AAAsyncByteStreamClose",  v23,  v24,  v26);
    uint64_t v20 = 0;
  }

  if (v20) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

    if (v21 != v62)
    {
LABEL_60:
      uint64_t v50 = "loading compressed segment";
      uint64_t v51 = 412;
      goto LABEL_68;
    }

    uint64_t v86 = 0;
    v85 = 0uLL;
    v84 = 0uLL;
    v82 = 0uLL;
    uint64_t v83 = 0uLL;
    v80 = 0uLL;
    v81 = 0uLL;
    v78 = 0uLL;
    v79 = 0uLL;
    v76 = 0uLL;
    unint64_t v77 = 0uLL;
    uint64_t v74 = 0uLL;
    uint64_t v75 = 0uLL;
    v72 = 0uLL;
    size_t v73 = 0uLL;
    uint64_t v70 = 0uLL;
    int v71 = 0uLL;
    memset(&v88[2], 0, 252);
    memset(v87, 0, 260);
    qmemcpy(&v88[1], "AEA_CK", 6);
    v88[0] = 6;
    memset_s((char *)&v88[2] + 2, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v25 = v88[0];
    if (v88[0] >= 0xFDu) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)&v88[1] + v88[0]) = v17 / v59;
    v88[0] = v25 + 4;
    memset_s((char *)&v88[2] + v25, 252 - v25, 0, 252 - v25);
    uint64_t v26 = *(uint64_t (**)(__int128 *, void, _DWORD *, _DWORD *, _DWORD *))(a1 + 144);
    if (v26 && *v56)
    {
      __n128 v27 = v26(&v70, *v57, v56, v88, v87);
      memset_s(v88, 0x104uLL, 0, 0x104uLL);
      uint64_t v28 = 0;
      if ((v27 & 0x80000000) == 0) {
        goto LABEL_27;
      }
    }

    else
    {
      memset_s(v88, 0x104uLL, 0, 0x104uLL);
    }

    uint64_t v28 = 1;
LABEL_27:
    memset(&v87[2], 0, 252);
    qmemcpy(&v87[1], "AEA_SK", 6);
    v87[0] = 6;
    memset_s((char *)&v87[2] + 2, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v29 = v87[0];
    if (v87[0] >= 0xFDu) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)&v87[1] + v87[0]) = v17 % v59;
    v87[0] = v29 + 4;
    memset_s((char *)&v87[2] + v29, 252 - v29, 0, 252 - v29);
    memset(v88, 0, 260);
    __int128 v30 = *(uint64_t (**)(_BYTE *, void, __int128 *, _DWORD *, _DWORD *))(a1 + 144);
    if (!v30 || !(_DWORD)v70)
    {
      memset_s(v87, 0x104uLL, 0, 0x104uLL);
LABEL_63:
      memset_s(&v70, 0x104uLL, 0, 0x104uLL);
LABEL_64:
      uint64_t v50 = "deriving segment key";
      uint64_t v51 = 416;
      goto LABEL_68;
    }

    uint64_t v31 = v30(v63, *(unsigned int *)(a1 + 76), &v70, v87, v88);
    memset_s(v87, 0x104uLL, 0, 0x104uLL);
    if (v31 < 0) {
      goto LABEL_63;
    }
    memset_s(&v70, 0x104uLL, 0, 0x104uLL);
    if (v28) {
      goto LABEL_64;
    }
    uint64_t v32 = *(uint64_t (**)(char *, size_t, uint64_t, _BYTE *, void, void))(a1 + 168);
    if (!v32
      || (uint64_t v33 = (_DWORD *)(v58 + 544LL * v17 + 284), *v33 != *(_DWORD *)(a1 + 84))
      || (v32(v14, v62, v58 + 544LL * v17 + 284, v63, 0LL, 0LL) & 0x80000000) != 0)
    {
      uint64_t v50 = "decrypting segment data";
      uint64_t v51 = 418;
      goto LABEL_68;
    }

    uint64_t v86 = 0;
    v85 = 0u;
    v84 = 0u;
    v82 = 0u;
    uint64_t v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    unint64_t v77 = 0u;
    uint64_t v74 = 0u;
    uint64_t v75 = 0u;
    v72 = 0u;
    size_t v73 = 0u;
    uint64_t v70 = 0u;
    int v71 = 0u;
    memset(&v88[2], 0, 252);
    memset(v87, 0, 260);
    qmemcpy(&v88[1], "AEA_CK", 6);
    v88[0] = 6;
    memset_s((char *)&v88[2] + 2, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v34 = v88[0];
    if (v88[0] >= 0xFDu) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)&v88[1] + v88[0]) = v17 / v59;
    v88[0] = v34 + 4;
    memset_s((char *)&v88[2] + v34, 252 - v34, 0, 252 - v34);
    uint64_t v35 = *(uint64_t (**)(__int128 *, void, __int128 *, _DWORD *, _DWORD *))(a1 + 144);
    if (v35 && LODWORD(v66[0]))
    {
      uint64_t v36 = v35(&v70, *v57, v66, v88, v87);
      memset_s(v88, 0x104uLL, 0, 0x104uLL);
      uint64_t v37 = 0;
      if ((v36 & 0x80000000) == 0) {
        goto LABEL_42;
      }
    }

    else
    {
      memset_s(v88, 0x104uLL, 0, 0x104uLL);
    }

    uint64_t v37 = 1;
LABEL_42:
    memset(&v87[2], 0, 252);
    qmemcpy(&v87[1], "AEA_SK", 6);
    v87[0] = 6;
    memset_s((char *)&v87[2] + 2, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v38 = v87[0];
    if (v87[0] >= 0xFDu) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)&v87[1] + v87[0]) = v17 % v59;
    v87[0] = v38 + 4;
    memset_s((char *)&v87[2] + v38, 252 - v38, 0, 252 - v38);
    memset(v88, 0, 260);
    uint64_t v39 = *(uint64_t (**)(_BYTE *, void, __int128 *, _DWORD *, _DWORD *))(a1 + 144);
    if (!v39 || !(_DWORD)v70)
    {
      memset_s(v87, 0x104uLL, 0, 0x104uLL);
LABEL_66:
      memset_s(&v70, 0x104uLL, 0, 0x104uLL);
LABEL_67:
      uint64_t v50 = "deriving segment key";
      uint64_t v51 = 422;
      goto LABEL_68;
    }

    uint64_t v40 = v39(v63, *(unsigned int *)(a1 + 76), &v70, v87, v88);
    memset_s(v87, 0x104uLL, 0, 0x104uLL);
    if (v40 < 0) {
      goto LABEL_66;
    }
    memset_s(&v70, 0x104uLL, 0, 0x104uLL);
    if (v37) {
      goto LABEL_67;
    }
    uint64_t v41 = *(uint64_t (**)(char *, size_t, _DWORD *, _BYTE *, void, void))(a1 + 160);
    if (!v41 || (uint64_t v42 = v41(v14, v62, v33, v63, 0LL, 0LL), *v33 != *(_DWORD *)(a1 + 84)) || v42 < 0)
    {
      uint64_t v50 = "decrypting segment data";
      uint64_t v51 = 424;
      goto LABEL_68;
    }

    if (!v60 && AAByteStreamPWrite(a2, v14, v62, *v55) != v62) {
      break;
    }
    if (++v17 >= *(_DWORD *)(a1 + 400)) {
      goto LABEL_53;
    }
  }

  uint64_t v50 = "storing compressed segment";
  uint64_t v51 = 429;
LABEL_68:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerReencrypt",  v51,  28,  0,  v50,  v15,  v16,  v54);
  uint64_t v46 = 0;
LABEL_69:
  memset_s(v14, __smax, 0, __smax);
LABEL_70:
  free(v14);
  memset_s(v66, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v64, 0x104uLL, 0, 0x104uLL);
  memset_s(v63, 0x104uLL, 0, 0x104uLL);
  if (v46) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  uint64_t v25 = 0LL;
  uint64_t v26 = 0;
  do
    uint64_t v26 = -1640531535 * (v26 + v8[v25++]);
  while (v25 != 16);
  __n128 v27 = a1[3];
  if (v27 < 0x11)
  {
LABEL_29:
    unint64_t v3 = 0LL;
    a1[1] = (uint64_t)v15;
    uint64_t v15 = 0LL;
    goto LABEL_33;
  }

  uint64_t v28 = 0;
  uint64_t v29 = 0LL;
  __int128 v30 = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v32 = *(_DWORD *)(v6 + 72) << 8;
  while (1)
  {
    if (v31 < v30 || v31 < v29 && (*(_DWORD *)(v6 + 68) & ~v26) != 0) {
      goto LABEL_28;
    }
    uint64_t v33 = *(unsigned int *)(v6 + 72);
    uint64_t v40 = v31 + a1[2];
    uint64_t v34 = __ROR8__(__ROR8__(2654435761LL * *(void *)&v8[v31], 41) + 2654435761LL * *(void *)&v8[v31 + 8], 41);
    uint64_t v35 = v26 >> -*(_BYTE *)(v6 + 64);
    uint64_t v41 = HIDWORD(v34) ^ v34;
    uint64_t v42 = v35;
    uint64_t v15 = pc_array_append((uint64_t)v15, &v40, v9, v10, v11, v12, v13, v14);
    if (!v15) {
      break;
    }
    uint64_t v29 = v31 + (2 * v33);
    uint64_t v36 = v28 + (v32 >> 8);
    uint64_t v37 = v32 + v31;
    uint64_t v32 = v31 + v32 - v36;
    __int128 v30 = v31 + v33 - ((unint64_t)(v37 - v36) >> 8);
    __n128 v27 = a1[3];
    uint64_t v28 = v31;
LABEL_28:
    uint64_t v26 = -1640531535 * (v26 + v8[v31 + 16]) - *(_DWORD *)(v6 + 76) * v8[v31];
    uint64_t v38 = v31 + 17;
    ++v31;
    if (v38 >= v27) {
      goto LABEL_29;
    }
  }

  uint64_t v23 = "pc_array_append";
  uint64_t v24 = 361;
LABEL_31:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"fingerprint_worker",  v24,  112,  0,  v23,  v13,  v14,  v40);
LABEL_32:
  unint64_t v3 = 0xFFFFFFFFLL;
LABEL_33:
  free(v8);
  pc_array_free((uint64_t)v15);
  return v3;
}

  close(v23);
  if ((rename(__old, __new) & 0x80000000) == 0)
  {
    uint64_t v32 = 0;
    goto LABEL_26;
  }

  uint64_t v51 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"storeRemainingRange",  235,  115,  *v51,  "rename: %s",  v52,  v53,  (char)__new);
LABEL_25:
  uint64_t v32 = 1;
LABEL_26:
  if (__old[0]) {
    unlink(__old);
  }
  free(v24);
  if (v32)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"retireEntryRange",  300,  115,  0,  "store remaining range",  v34,  v35,  v54);
    uint64_t v18 = 0;
  }

  if (*(void *)(a1 + 16))
  {
    uint64_t v36 = *(void *)(a1 + 2304);
    uint64_t v37 = *(void *)(a1 + 2472);
    uint64_t v38 = AAByteRangeSizeAtOffset(v37, 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v39 = AAByteRangeSizeAtOffset(v37, 0x8000000000000000LL);
    if (((*(uint64_t (**)(void, float))(a1 + 16))( *(void *)a1,  (float)((float)(v36 - v38 + v39) * 100.0) / (float)v36) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"retireEntryRange",  301,  115,  0,  "User cancelled operation",  v40,  v41,  v54);
      uint64_t v18 = 0;
    }
  }

  *(double *)(a1 + 2480) = RealTime;
LABEL_34:
  if (pthread_mutex_unlock(v6))
  {
    uint64_t v42 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"retireEntryRange",  305,  115,  *v42,  "pthread_mutex_unlock",  v43,  v44,  v54);
    uint64_t v18 = 0;
  }

  if (v18) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

char *rawimg_create_with_stream(void *a1, int a2)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (char *)calloc(1uLL, 0x878uLL);
  uint64_t v7 = v4;
  if (!v4)
  {
    int v29 = *__error();
    __n128 v27 = "aaCalloc";
    __int16 v28 = 953;
    goto LABEL_20;
  }

  if (!a1[2]) {
    goto LABEL_17;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = v4 + 2120;
  __int16 v10 = v62;
  uint64_t v11 = 64LL;
  do
  {
    uint64_t v12 = ((uint64_t (*)(void, _OWORD *, uint64_t))a1[2])(*a1, v10, v11);
    if (v12 < 0) {
      goto LABEL_17;
    }
    if (!v12) {
      break;
    }
    __int16 v10 = (_OWORD *)((char *)v10 + v12);
    v8 += v12;
    v11 -= v12;
  }

  while (v11);
  if (v8 == 64)
  {
    __int128 v13 = v62[1];
    *(_OWORD *)(v7 + 2088) = v62[0];
    *(_OWORD *)(v7 + 2104) = v13;
    __int128 v14 = v63;
    _OWORD *v9 = v62[2];
    *(_OWORD *)(v7 + 2152) = v14;
    *((void *)v7 + 267) = pc_array_init(16LL, v14);
    uint64_t v15 = pc_array_init(440LL, *((void *)v7 + 270));
    *((void *)v7 + 268) = v15;
    uint64_t v21 = *((void *)v7 + 267);
    if (v21 && v15)
    {
      uint64_t v22 = *((void *)v7 + 269);
      *(void *)(v21 - 64) = v22;
      *(v15 - 8) = *((void *)v7 + 270);
      if (!a1[2]) {
        goto LABEL_62;
      }
      uint64_t v23 = 16 * v22;
      if (!(16 * v22)) {
        goto LABEL_25;
      }
      uint64_t v24 = 0LL;
      uint64_t v25 = 16 * v22;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v21, v25);
        if (v26 < 0) {
          break;
        }
        if (v26)
        {
          v21 += v26;
          v24 += v26;
          v25 -= v26;
          if (v25) {
            continue;
          }
        }

        goto LABEL_24;
      }

      uint64_t v24 = v26;
LABEL_24:
      if (v23 == v24)
      {
LABEL_25:
        if (!*((void *)&v63 + 1))
        {
LABEL_60:
          if ((rawimg_verify(v7, v16, v17, v18, v19, v20, v5, v6) & 0x80000000) == 0) {
            return v7;
          }
          __n128 v27 = "rawimg_verify";
          __int16 v28 = 1023;
          goto LABEL_18;
        }

        uint64_t v31 = 0LL;
        while (2)
        {
          if (a1[2])
          {
            uint64_t v32 = 0LL;
            uint64_t v33 = *((void *)v7 + 268);
            uint64_t v34 = &v58;
            uint64_t v35 = 41LL;
            do
            {
              uint64_t v36 = ((uint64_t (*)(void, __int128 *, uint64_t))a1[2])(*a1, v34, v35);
              if (v36 < 0) {
                goto LABEL_63;
              }
              if (!v36) {
                break;
              }
              uint64_t v34 = (__int128 *)((char *)v34 + v36);
              v32 += v36;
              v35 -= v36;
            }

            while (v35);
            if (v32 != 41) {
              break;
            }
            uint64_t v37 = v33 + 440 * v31;
            *(void *)(v37 + 432) = 0LL;
            *(_OWORD *)(v37 + 400) = 0u;
            *(_OWORD *)(v37 + 416) = 0u;
            *(_OWORD *)(v37 + 368) = 0u;
            *(_OWORD *)(v37 + 384) = 0u;
            *(_OWORD *)(v37 + 336) = 0u;
            *(_OWORD *)(v37 + 352) = 0u;
            *(_OWORD *)(v37 + 304) = 0u;
            *(_OWORD *)(v37 + 320) = 0u;
            *(_OWORD *)(v37 + 272) = 0u;
            *(_OWORD *)(v37 + 288) = 0u;
            *(_OWORD *)(v37 + 240) = 0u;
            *(_OWORD *)(v37 + 256) = 0u;
            *(_OWORD *)(v37 + 208) = 0u;
            *(_OWORD *)(v37 + 224) = 0u;
            *(_OWORD *)(v37 + 176) = 0u;
            *(_OWORD *)(v37 + 192) = 0u;
            *(_OWORD *)(v37 + 144) = 0u;
            *(_OWORD *)(v37 + 160) = 0u;
            *(_OWORD *)(v37 + 112) = 0u;
            *(_OWORD *)(v37 + 128) = 0u;
            *(_OWORD *)(v37 + 80) = 0u;
            *(_OWORD *)(v37 + 96) = 0u;
            *(_OWORD *)(v37 + 48) = 0u;
            *(_OWORD *)(v37 + 64) = 0u;
            *(_OWORD *)(v37 + 16) = 0u;
            *(_OWORD *)(v37 + 32) = 0u;
            *(_OWORD *)uint64_t v37 = 0u;
            uint64_t v38 = v58;
            *(_OWORD *)(v37 + 392) = v58;
            uint64_t v39 = (_BYTE *)(v37 + 408);
            char v40 = v59;
            *(_OWORD *)(v37 + 408) = v59;
            *(void *)(v37 + 424) = v60;
            *(_BYTE *)(v37 + 432) = v61;
            if (a2 && (v40 & 1) != 0)
            {
              size_t v41 = (unint64_t)(v38 + 0xFFFF) >> 16;
              uint64_t v42 = v33 + 440 * v31;
              *(void *)(v42 + 56) = v41;
              uint64_t v43 = (void *)(v42 + 56);
              if ((unint64_t)(v38 + 0xFFFF) >= 0x2AAAAAAAB0000LL)
              {
                *__error() = 12;
                *(void *)(v33 + 440 * v31 + 384) = 0LL;
              }

              else
              {
                uint64_t v44 = (char *)calloc(v41, 0xCuLL);
                *(void *)(v33 + 440 * v31 + 384) = v44;
                if (v44)
                {
                  if (!a1[2]) {
                    goto LABEL_66;
                  }
                  uint64_t v45 = 12LL * *v43;
                  if (v45)
                  {
                    uint64_t v46 = v44;
                    uint64_t v47 = 0LL;
                    uint64_t v48 = 12LL * *v43;
                    while (1)
                    {
                      uint64_t v49 = ((uint64_t (*)(void, char *, uint64_t))a1[2])(*a1, v46, v48);
                      if (v49 < 0) {
                        break;
                      }
                      if (v49)
                      {
                        v46 += v49;
                        v47 += v49;
                        v48 -= v49;
                        if (v48) {
                          continue;
                        }
                      }

                      goto LABEL_45;
                    }

                    uint64_t v47 = v49;
LABEL_45:
                    if (v45 != v47)
                    {
LABEL_66:
                      __n128 v27 = "aaByteStreamReadExpected";
                      __int16 v28 = 1008;
                      goto LABEL_18;
                    }
                  }

                  if ((*v39 & 4) != 0)
                  {
                    if (a1[2])
                    {
                      uint64_t v50 = 0LL;
                      uint64_t v51 = v33 + 440 * v31 + 64;
                      uint64_t v52 = 264LL;
                      while (1)
                      {
                        uint64_t v53 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v51, v52);
                        if (v53 < 0) {
                          break;
                        }
                        if (v53)
                        {
                          v51 += v53;
                          v50 += v53;
                          v52 -= v53;
                          if (v52) {
                            continue;
                          }
                        }

                        if (v50 != 264) {
                          break;
                        }
                        if (a1[2])
                        {
                          uint64_t v54 = 0LL;
                          uint64_t v55 = v33 + 440 * v31 + 328;
                          uint64_t v56 = 50LL;
                          while (1)
                          {
                            uint64_t v57 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v55, v56);
                            if (v57 < 0) {
                              break;
                            }
                            if (v57)
                            {
                              v55 += v57;
                              v54 += v57;
                              v56 -= v57;
                              if (v56) {
                                continue;
                              }
                            }

                            if (v54 != 50) {
                              break;
                            }
                            goto LABEL_59;
                          }
                        }

                        __n128 v27 = "aaByteStreamReadExpected";
                        __int16 v28 = 1017;
                        goto LABEL_18;
                      }
                    }

                    __n128 v27 = "aaByteStreamReadExpected";
                    __int16 v28 = 1015;
                    goto LABEL_18;
                  }

                  goto LABEL_59;
                }
              }

              int v29 = *__error();
              __n128 v27 = "aaCalloc";
              __int16 v28 = 1003;
              goto LABEL_20;
            }

LABEL_59:
            goto LABEL_60;
          }

          break;
        }

  memset_s(v33, v31, 0, v31);
LABEL_76:
  free(v33);
  memset_s(v65, 0xD0uLL, 0, 0xD0uLL);
  memset_s(v60, 0x68uLL, 0, 0x68uLL);
  memset_s(&v125, 0x30uLL, 0, 0x30uLL);
  memset_s(v87, 0x104uLL, 0, 0x104uLL);
  memset_s(v85, 0x104uLL, 0, 0x104uLL);
  memset_s(v83, 0x104uLL, 0, 0x104uLL);
  memset_s(v81, 0x104uLL, 0, 0x104uLL);
  memset_s(v108, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v79, 0x104uLL, 0, 0x104uLL);
  memset_s(v77, 0x104uLL, 0, 0x104uLL);
  memset_s(v89, 0x104uLL, 0, 0x104uLL);
  return v43;
}

          uint64_t v32 = (void *)v14[2];
          uint64_t v33 = realloc(v32, v24);
          if (v33)
          {
            v14[1] = v24;
            v14[2] = v33;
            goto LABEL_61;
          }

          free(v32);
LABEL_81:
          v14[1] = 0LL;
          v14[2] = 0LL;
          *__int128 v14 = 0LL;
        }
      }

      uint64_t v18 = "blob append";
      uint64_t v19 = 351;
    }

    else
    {
      uint64_t v18 = "invalid blob size";
      uint64_t v19 = 350;
    }

    uint64_t v54 = v61;
    uint64_t v55 = reallocToFit(v62, 24 * v61);
    *((void *)&v61 + 1) = v54;
    v62 = v55;
    free((void *)v44[2]);
    *(_OWORD *)uint64_t v44 = v61;
    v44[2] = (unint64_t)v62;
    v62 = 0LL;
    char v61 = 0uLL;
    uint64_t v42 = v57 + 1;
    if (v57 + 1 == v56)
    {
      char v40 = 0LL;
      goto LABEL_34;
    }
  }

LABEL_63:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 986;
      }

      else
      {
LABEL_62:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 976;
      }
    }

    else
    {
      __n128 v27 = "pc_array_init";
      __int16 v28 = 969;
    }
  }

  else
  {
LABEL_17:
    __n128 v27 = "aaByteStreamReadExpected";
    __int16 v28 = 957;
  }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processSequential",  v39,  89,  0,  v38,  v25,  v26,  v89);
      }

      size_t v73 = 1;
LABEL_65:
      ThreadPipelineDestroy((uint64_t)v27);
      if ((_DWORD)v8)
      {
        uint64_t v83 = v14;
        do
        {
          v84 = *v83++;
          free(v84[3]);
          free(v84);
          --v8;
        }

        while (v8);
      }

      free(v14);
      if ((v73 & 1) == 0) {
        return __s[1];
      }
    }

    else
    {
      size_t v67 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processSequential",  121,  89,  *v67,  "malloc",  v68,  v69,  v89);
      ThreadPipelineDestroy(0LL);
    }

    return -1LL;
  }

  if (n_threads <= 0) {
    LODWORD(v8) = getDefaultNThreads();
  }
  LODWORD(__s[0]) = 0;
  unint64_t v94 = 0;
  char v40 = v8;
  size_t v41 = (AAByteStream **)calloc(v8, 8uLL);
  if (!v41)
  {
    uint64_t v70 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processRandomAccess",  246,  89,  *v70,  "malloc",  v71,  v72,  v89);
    ThreadPoolDestroy(0LL);
    return -1LL;
  }

  uint64_t v90 = (uint64_t)v41;
  if ((_DWORD)v8)
  {
    uint64_t v42 = v41;
    uint64_t v8 = v8;
    while (1)
    {
      uint64_t v43 = (AAByteStream *)malloc(0x48uLL);
      if (!v43)
      {
        v79 = *__error();
        v82 = 250;
        goto LABEL_61;
      }

      uint64_t v44 = v43;
      memset_s(v43, 0x48uLL, 0, 0x48uLL);
      *uint64_t v42 = v44;
      *uint64_t v44 = istream;
      v44[1] = ostream;
      v44[4] = (AAByteStream)__s;
      v44[5] = (AAByteStream)&v94;
      v44[2] = (AAByteStream)block_size;
      if (block_size >= 0x2000000001LL) {
        break;
      }
      uint64_t v45 = (AAByteStream_impl *)malloc(block_size);
      v44[3] = v45;
      if (!v45) {
        goto LABEL_60;
      }
      ++v42;
      if (!--v8) {
        goto LABEL_35;
      }
    }

    *__error() = 12;
    v44[3] = 0LL;
LABEL_60:
    v79 = *__error();
    v82 = 258;
LABEL_61:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processRandomAccess",  v82,  89,  v79,  "malloc",  v80,  v81,  max_offset);
    uint64_t v54 = 0LL;
    uint64_t v74 = 1;
    uint64_t v46 = (uint64_t *)v90;
  }

  else
  {
LABEL_35:
    uint64_t v46 = (uint64_t *)v90;
    uint64_t v54 = ThreadPoolCreate(v40, v90, (uint64_t)randomAccessWorkerProc);
    if (v54)
    {
      uint64_t v55 = 0LL;
      else {
        uint64_t v56 = max_offset;
      }
      while (1)
      {
        uint64_t v57 = atomic_load((unsigned int *)__s);
        if (v57
          || (__int128 v58 = atomic_load(&v94)) != 0
          || ((uint64_t)(v55 + block_size) >= v56 ? (__int128 v59 = v56) : (__int128 v59 = v55 + block_size), v59 < v55))
        {
          uint64_t v74 = 0;
          goto LABEL_72;
        }

        uint64_t v60 = ThreadPoolGetWorker((uint64_t)v54, v47, v48, v49, v50, v51, v52, v53);
        if (!v60) {
          break;
        }
        *(void *)(v60 + 56) = v59 - v55;
        *(void *)(v60 + 64) = v55;
        uint64_t v55 = v59;
        if ((ThreadPoolRunWorker((uint64_t)v54, v60, v61, v62, v63, v64, v52, v53) & 0x80000000) != 0)
        {
          v65 = "running task";
          uint64_t v66 = 285;
          goto LABEL_71;
        }
      }

      v65 = "allocating reader";
      uint64_t v66 = 280;
    }

    else
    {
      v65 = "ThreadPipelineCreate";
      uint64_t v66 = 263;
    }

        if ((v15[3] & 0x10) != 0)
        {
          uint64_t v46 = v45 + 2;
          if (v45 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            uint64_t v20 = 545;
            goto LABEL_26;
          }

          if (v45 + 2 < DataSize)
          {
            while (v15[v45 + 1])
            {
              if (DataSize - 2 == ++v45)
              {
                uint64_t v46 = DataSize;
                goto LABEL_65;
              }
            }

            uint64_t v46 = v45 + 2;
          }
        }

        else
        {
          uint64_t v46 = v45;
        }

  uint64_t v35 = v60;
  if ((void)v60)
  {
    uint64_t v36 = 0LL;
    uint64_t v38 = *((void *)v9 + 7);
    uint64_t v37 = *((void *)v9 + 8);
    do
    {
      if (v38 == v37)
      {
        uint64_t v39 = v37 + 0x40000;
        if (v37 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v37)
            {
              uint64_t v37 = 0x4000LL;
              size_t v41 = 0x4000LL;
              if (v39 <= 0x4000) {
                goto LABEL_78;
              }
            }

            char v40 = v37 >> 1;
            if ((v37 & (v37 >> 1)) != 0) {
              char v40 = v37 & (v37 >> 1);
            }
            v37 += v40;
          }

          while (v37 < v39);
          size_t v41 = v37;
          if (v37 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_125;
          }

LABEL_18:
  int v29 = 0;
LABEL_20:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c",  (uint64_t)"rawimg_create_with_stream",  v28,  138,  v29,  v27,  v5,  v6,  v58);
  rawimg_destroy((uint64_t *)v7);
  return 0LL;
}

  if (pthread_mutex_init((pthread_mutex_t *)(v12 + 32), 0LL) < 0)
  {
    uint64_t v21 = *__error();
    uint64_t v24 = "pthread_mutex_init";
    uint64_t v25 = 298;
    goto LABEL_23;
  }

  _OWORD *v10 = v12;
  v10[1] = streamClose;
  v10[4] = streamPRead;
  v10[2] = streamRead;
  v10[6] = streamSeek;
  v10[7] = streamAbort;
  return v10;
}

        ++v12;
      }

      while (v12 < *(void *)(v360 + 24));
LABEL_19:
      if (v11) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 0LL;
      }
    case 1:
      uint64_t v26 = *(void *)(v8 + 8);
      bzero(__s, 0x800uLL);
      bzero(&v379, 0x400uLL);
      v375 = 0LL;
      length = 0LL;
      v364 = 0LL;
      v365 = 0LL;
      v362 = 0LL;
      v363 = 0LL;
      v361 = 0LL;
      v374 = 0LL;
      v372 = 0u;
      v373 = 0u;
      v370 = 0u;
      v371 = 0u;
      v369 = 0LL;
      v367 = 0u;
      v368 = 0u;
      *(_OWORD *)data_size = 0u;
      __int128 v30 = *(unsigned int *)(v26 + 1152);
      if (!(_DWORD)v30) {
        goto LABEL_28;
      }
      uint64_t v31 = 0LL;
      while (*(void *)(*(void *)(v26 + 1160) + 8 * v31) != v9)
      {
        if (v30 == ++v31)
        {
LABEL_28:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  489,  120,  0,  "couldn't determine worker_id",  v27,  v28,  v340);
LABEL_29:
          uint64_t v32 = 0LL;
          goto LABEL_30;
        }
      }

      size_t v166 = AAHeaderCreate();
      uint64_t v32 = v166;
      if (!v166)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  492,  120,  0,  "AAHeaderCreate",  v171,  v172,  v340);
LABEL_30:
        uint64_t v25 = 0xFFFFFFFFLL;
        goto LABEL_31;
      }

      v173 = *(void *)(v9 + 16);
      if (v173 >= *(void *)(v9 + 24))
      {
LABEL_431:
        uint64_t v25 = 0LL;
        goto LABEL_31;
      }

      v349 = (char *)(v26 + 16);
      v350 = (unsigned int *)(v26 + 1288);
      v348 = (unint64_t *)(v26 + 1304);
      v174 = (unint64_t *)(v26 + 1296);
      v351 = v166;
      v352 = v26;
      while (1)
      {
        v175 = *(void *)(v26 + 1144);
        v364 = 0LL;
        v362 = 0LL;
        v375 = 0LL;
        headera = (AAHeader)(v175 + 72 * v173);
        v176 = (int *)((char *)headera + 60);
        if (*((_DWORD *)headera + 15) == 68)
        {
          if (*(_DWORD *)(v26 + 1072)) {
            goto LABEL_236;
          }
          v177 = v175;
          EntryData = stateGetEntryData(v26, (uint64_t)headera, v167, v168, v169, v170, v171, v172);
          if (!EntryData)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  512,  120,  0,  "invalid entry data",  v171,  v172,  v340);
            goto LABEL_431;
          }

          v179 = *(void **)v26;
          v354 = v173;
          v180 = v177 + 72 * v173;
          v183 = *(void *)(v180 + 8);
          v181 = (void *)(v180 + 8);
          v182 = v183;
          if (!v179[4])
          {
            if (v182 != -1) {
              goto LABEL_432;
            }
LABEL_203:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  520,  120,  0,  "invalid dir entry",  v171,  v172,  v340);
            v189 = 0LL;
            uint64_t v32 = v351;
            uint64_t v26 = v352;
LABEL_204:
            v173 = v354;
            goto LABEL_230;
          }

          if (!v182) {
            goto LABEL_203;
          }
          v184 = (_DWORD *)EntryData;
          v185 = 0LL;
          v186 = *(void *)headera;
          v187 = EntryData;
          while (1)
          {
            v188 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v179[4])(*v179, v187, v182, v186);
            if (v188 < 0) {
              break;
            }
            if (v188)
            {
              v187 += v188;
              v185 += v188;
              v186 += v188;
              v182 -= v188;
              if (v182) {
                continue;
              }
            }

            goto LABEL_199;
          }

          v185 = v188;
LABEL_199:
          if (v185 != *v181)
          {
LABEL_432:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  516,  120,  0,  "loading dir entry",  v171,  v172,  v340);
            goto LABEL_433;
          }

          if (v185 < 4 || *v184 != 825246017 && *v184 != 826360153) {
            goto LABEL_203;
          }
          uint64_t v26 = v352;
          uint64_t v9 = v360;
          uint64_t v32 = v351;
          v173 = v354;
          v175 = v177;
          v176 = (int *)((char *)headera + 60);
          if (*((_DWORD *)headera + 15) == 68) {
            goto LABEL_236;
          }
        }

        v353 = v175;
        v357 = (const char *)(*(void *)(*(void *)(v26 + 1096) + 32LL)
                            + *(void *)(*(void *)(*(void *)(v26 + 1096) + 8LL)
                                        + 16LL * *(unsigned int *)(v175 + 72 * v173 + 64)));
        if ((stateConcatPath(v26, __s, v357) & 0x80000000) != 0)
        {
          v211 = 528;
          v212 = "invalid path";
          goto LABEL_223;
        }

        v192 = strrchr(__s, 47);
        if (!v192)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  532,  120,  0,  "invalid path",  v193,  v194,  v340);
          v189 = 0LL;
          goto LABEL_230;
        }

        v195 = v192;
        v354 = v173;
        *v192 = 0;
        v196 = v192 + 1;
        if ((workerUpdateDir(v9, __s) & 0x80000000) != 0)
        {
          v213 = 535;
          v214 = "opening parent directory";
          goto LABEL_228;
        }

        *v195 = 47;
        v199 = *(void **)v26;
        if (!v199[4]) {
          goto LABEL_225;
        }
        v200 = 0LL;
        v201 = *(void *)headera;
        v202 = *(void *)(v360 + 32);
        v203 = 6LL;
        do
        {
          v204 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v199[4])(*v199, v202, v203, v201);
          if (v204 < 0) {
            goto LABEL_225;
          }
          if (!v204) {
            break;
          }
          v202 += v204;
          v200 += v204;
          v201 += v204;
          v203 -= v204;
        }

        while (v203);
        if (v200 != 6)
        {
LABEL_225:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  541,  120,  0,  "invalid entry",  v197,  v198,  v340);
          v189 = 0LL;
          goto LABEL_226;
        }

        uint64_t v26 = v352;
        v205 = *(void *)v352;
        if (!*(void *)(*(void *)v352 + 32LL)) {
          goto LABEL_279;
        }
        v206 = *(void *)(v360 + 32);
        v207 = *(unsigned __int16 *)(v206 + 4);
        v346 = v207;
        v208 = 0LL;
        if (*(_WORD *)(v206 + 4))
        {
          v209 = *(void *)headera;
          while (1)
          {
            v210 = (*(uint64_t (**)(void, uint64_t, unint64_t, uint64_t))(v205 + 32))( *(void *)v205,  v206,  v207,  v209);
            if (v210 < 0) {
              break;
            }
            if (v210)
            {
              v206 += v210;
              v208 += v210;
              v209 += v210;
              v207 -= v210;
              if (v207) {
                continue;
              }
            }

            goto LABEL_239;
          }

          v208 = v210;
        }

uint64_t compare_forks_by_extent(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 416);
  unint64_t v3 = *(void *)(a2 + 416);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aggregate_identical_forks(const void *a1, const void *a2)
{
  if (!memcmp(a1, a2, 0x1B8uLL)) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t compare_forks_by_position(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 2136) + 16LL * *(void *)(a2 + 416)) < *(void *)(*(void *)(a1 + 2136)
                                                                                      + 16LL * *(void *)(a3 + 416)))
    return 0xFFFFFFFFLL;
  else {
    return 1LL;
  }
}

uint64_t pc_array_compare(uint64_t (*a1)(void, void), void *a2, void *a3)
{
  return a1(*a2, *a3);
}

void *pc_array_init(uint64_t a1, uint64_t a2)
{
  BOOL v4 = malloc(a2 * a1 + 64);
  if (v4)
  {
    *BOOL v4 = 0LL;
    v4[1] = a2;
    BOOL v5 = v4 + 8;
    v4[2] = a1;
  }

  else
  {
    uint64_t v6 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c",  (uint64_t)"pc_array_init",  26,  139,  *v6,  "malloc",  v7,  v8,  v10);
    return 0LL;
  }

  return v5;
}

void *pc_array_init(uint64_t a1)
{
  return pc_array_init(a1, 8LL);
}

void pc_array_free(uint64_t a1)
{
  if (a1) {
    free((void *)(a1 - 64));
  }
}

char *pc_array_compact(uint64_t a1)
{
  unint64_t v3 = *(void *)(a1 - 64);
  unint64_t v4 = *(void *)(a1 - 56);
  unint64_t v2 = (char *)(a1 - 64);
  if (v4 <= v3) {
    return v2 + 64;
  }
  *(void *)(a1 - 56) = v3;
  unint64_t v2 = (char *)reallocf(v2, *(void *)(a1 - 48) * v3 + 64);
  if (v2) {
    return v2 + 64;
  }
  uint64_t v6 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c",  (uint64_t)"pc_array_compact",  56,  139,  *v6,  "reallocf",  v7,  v8,  vars0);
  return 0LL;
}

void *pc_array_append( uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(void *)(a1 - 64);
  unint64_t v10 = *(void *)(a1 - 56);
  uint64_t v11 = (void *)(a1 - 64);
  if (v10 > v9) {
    goto LABEL_7;
  }
  uint64_t v12 = 2 * v10;
  BOOL v13 = v10 == 0;
  unint64_t v14 = 16LL;
  if (!v13) {
    unint64_t v14 = v12;
  }
  *(void *)(a1 - 56) = v14;
  if (v14 <= v9)
  {
    uint64_t v17 = "too many elements";
    __int16 v18 = 70;
    int v19 = 0;
LABEL_10:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c",  (uint64_t)"pc_array_append",  v18,  139,  v19,  v17,  a7,  a8,  v21);
    return 0LL;
  }

  uint64_t v15 = reallocf((void *)(a1 - 64), *(void *)(a1 - 48) * v14 + 64);
  if (!v15)
  {
    int v19 = *__error();
    uint64_t v17 = "reallocf";
    __int16 v18 = 72;
    goto LABEL_10;
  }

  uint64_t v11 = v15;
  unint64_t v9 = *v15;
LABEL_7:
  uint64_t v16 = v11 + 8;
  memcpy((char *)v11 + v11[2] * v9 + 64, __src, v11[2]);
  ++*v11;
  return v16;
}

void pc_array_sort(void *a1, int (__cdecl *__compar)(const void *, const void *))
{
}

void *pc_array_indirect_sort(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  size_t v4 = *(void *)(a1 - 64);
  BOOL v5 = malloc(8 * v4);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(v3 - 48);
      uint64_t v8 = v5;
      size_t v9 = v4;
      do
      {
        *v8++ = v3;
        v3 += v7;
        --v9;
      }

      while (v9);
    }

    qsort_r(v5, v4, 8uLL, a2, (int (__cdecl *)(void *, const void *, const void *))pc_array_compare);
  }

  else
  {
    unint64_t v10 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c",  (uint64_t)"pc_array_indirect_sort",  95,  139,  *v10,  "malloc",  v11,  v12,  v14);
  }

  return v6;
}

uint64_t pc_array_aggregate( char *a1, unsigned int (*a2)(char *, char *), uint64_t (*a3)(char *, char *))
{
  if (*((void *)a1 - 8) < 2uLL) {
    return 0LL;
  }
  uint64_t v7 = &a1[*((void *)a1 - 6)];
  unint64_t v8 = 1LL;
  uint64_t v9 = 1LL;
  unint64_t v10 = a1;
  while (1)
  {
    if (a2(v10, v7))
    {
      size_t v11 = *((void *)a1 - 6);
      v10 += v11;
      if (v10 < v7) {
        memcpy(v10, v7, v11);
      }
      ++v9;
      goto LABEL_9;
    }

    if ((a3(v10, v7) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
LABEL_9:
    ++v8;
    v7 += *((void *)a1 - 6);
    if (v8 >= *((void *)a1 - 8))
    {
      uint64_t result = 0LL;
      *((void *)a1 - 8) = v9;
      return result;
    }
  }

char *PCompressGetEncoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0LL;
  }
  else {
    return off_189E3ADC8[a1];
  }
}

uint64_t PCompressGetEncoderDecoder(uint64_t result)
{
  else {
    return result;
  }
}

unint64_t PCompressGetDecoderKey(unsigned int a1)
{
  unint64_t v1 = 0x2D62653466787AuLL >> (8 * a1);
  if (a1 >= 7) {
    LOBYTE(v1) = 63;
  }
  return v1 & 0x7F;
}

char *PCompressGetDecoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0LL;
  }
  else {
    return off_189E3AE00[a1];
  }
}

void *AEADecryptAsyncStreamOpen( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  unsigned int DefaultNThreads = a6;
  if (!a6) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v12 = malloc(0x4A0uLL);
  uint64_t v13 = (uint64_t)v12;
  if (!v12)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 884;
    goto LABEL_8;
  }

  memset_s(v12, 0x4A0uLL, 0, 0x4A0uLL);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 56), 0LL))
  {
    uint64_t v16 = "pthread_mutex_init";
    __int16 v17 = 885;
LABEL_6:
    int v18 = 0;
LABEL_8:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"AEADecryptAsyncStreamOpen",  v17,  114,  v18,  v16,  v14,  v15,  v29);
    decryptAsyncClose(v13);
    AAAsyncByteStreamClose(0LL);
    return 0LL;
  }

  *(void *)uint64_t v13 = a1;
  *(void *)(v13 + 8) = a2;
  *(void *)(v13 + 16) = a3;
  *(void *)(v13 + 24) = a4;
  *(void *)(v13 + 1128) = -1LL;
  *(void *)(v13 + 1144) = -1LL;
  *(void *)(v13 + 1152) = -1LL;
  *(_DWORD *)(v13 + 32) = a5 >> 62;
  *(void *)(v13 + 40) = a5;
  *(_DWORD *)(v13 + 1160) = DefaultNThreads;
  uint64_t v20 = calloc(DefaultNThreads, 8uLL);
  *(void *)(v13 + 1168) = v20;
  if (!v20)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 899;
    goto LABEL_8;
  }

  if (*(_DWORD *)(v13 + 1160))
  {
    unint64_t v21 = 0LL;
    while (1)
    {
      uint64_t v22 = (uint64_t *)malloc(0x468uLL);
      uint64_t v23 = v22;
      if (v22)
      {
        memset_s(v22, 0x468uLL, 0, 0x468uLL);
        *uint64_t v23 = v13;
      }

      else
      {
        uint64_t v24 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"workerAlloc",  129,  114,  *v24,  "malloc",  v25,  v26,  v29);
      }

      *(void *)(*(void *)(v13 + 1168) + 8 * v21) = v23;
      uint64_t v27 = *(void *)(v13 + 1168);
      if (!*(void *)(v27 + 8 * v21)) {
        break;
      }
      ++v21;
      uint64_t v20 = (void *)*(unsigned int *)(v13 + 1160);
    }

    uint64_t v16 = "Worker alloc";
    __int16 v17 = 903;
    goto LABEL_6;
  }

  uint64_t v27 = (uint64_t)v20;
  LODWORD(v20) = 0;
LABEL_20:
  __int16 v28 = ThreadPoolCreate(v20, v27, (uint64_t)workerProc);
  *(void *)(v13 + 1176) = v28;
  if (!v28)
  {
    uint64_t v16 = "creating worker pool";
    __int16 v17 = 906;
    goto LABEL_6;
  }

  *(_DWORD *)(v13 + 52) = 0;
  if (pushRange((void *)v13, 12LL))
  {
    uint64_t v16 = "add range";
    __int16 v17 = 910;
    goto LABEL_6;
  }

  *(void *)(v13 + 1128) = 0LL;
  uint64_t result = aaAsyncByteStreamAlloc(v13, (uint64_t)decryptAsyncClose, ~(a5 >> 55) & 4, 20.0, 1.0);
  if (!result)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 921;
    goto LABEL_8;
  }

  result[2] = decryptAsyncGetRange;
  result[3] = decryptAsyncProcess;
  result[4] = decryptAsyncCancel;
  result[5] = decryptAsyncIsCancelled;
  return result;
}

uint64_t workerProc( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *(void *)result;
  unint64_t v8 = *(void *)(result + 8);
  if (v8 >= *(void *)(*(void *)result + 1120LL))
  {
    __int16 v28 = "Invalid range index";
    __int16 v29 = 183;
    goto LABEL_50;
  }

  uint64_t v10 = *(void *)(v9 + 1136) + 32 * v8;
  int v13 = *(_DWORD *)(v10 + 28);
  size_t v11 = (_DWORD *)(v10 + 28);
  int v12 = v13;
  unint64_t v14 = *(v11 - 1);
  if (*(void *)(v9 + 1096) <= v14)
  {
    __int16 v28 = "Invalid segment index";
    __int16 v29 = 191;
    goto LABEL_50;
  }

  size_t v15 = *(void *)(v9 + 784);
  if (v15 >= 0x101) {
    goto LABEL_71;
  }
  uint64_t v16 = result;
  __int16 v17 = (unsigned int *)(*(void *)(v9 + 1104) + *(void *)(v9 + 800) * v14);
  unint64_t v55 = *(unsigned int *)(v9 + 152) * (unint64_t)v14;
  uint64_t v18 = *v17;
  uint64_t v19 = v17[1];
  uint64_t v20 = v17 + 2;
  unint64_t v21 = (char *)(result + 612);
  memcpy((void *)(result + 612), v17 + 2, v15);
  *(_DWORD *)(v16 + 608) = v15;
  memset_s(&v21[v15], 256 - v15, 0, 256 - v15);
  uint64_t result = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v9 + 160));
  if ((_DWORD)v18 == (_DWORD)v19) {
    compression_algorithm v22 = 0;
  }
  else {
    compression_algorithm v22 = result;
  }
  int v23 = *(_DWORD *)(v16 + 16);
  if (v23 != 1)
  {
    if (v23)
    {
      __int16 v28 = "Invalid op";
      __int16 v29 = 307;
    }

    else if (v12 == 3)
    {
      uint64_t v24 = *(uint64_t (**)(void, uint64_t, unint64_t, void, char *, void))(v9 + 16);
      if (!v24)
      {
LABEL_31:
        uint64_t result = 0LL;
        _DWORD *v11 = 4;
        return result;
      }

      int v25 = v24(*(void *)v9, v18, v55, *(unsigned int *)(v9 + 148), v21, *(unsigned int *)(v16 + 608));
      if ((v25 & 0x80000000) == 0)
      {
        if (v25)
        {
          _DWORD *v11 = 6;
          uint64_t v26 = (unsigned int *)(v9 + 120);
          do
            unsigned int v27 = __ldaxr(v26);
          while (__stlxr(v27 + 1, v26));
          if (*(_DWORD *)(v9 + 32) >= 3u) {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u skipped, offset=%jd, payload=%u, raw=%u\n");
          }
          return 0LL;
        }

        goto LABEL_31;
      }

      __int16 v28 = "Client selection callback reported an error";
      __int16 v29 = 220;
    }

    else
    {
      __int16 v28 = "Invalid segment state";
      __int16 v29 = 207;
    }

    goto LABEL_50;
  }

  if (v12 != 2)
  {
    __int16 v28 = "Invalid segment state";
    __int16 v29 = 239;
    goto LABEL_50;
  }

  if (*(void *)(v16 + 32) != v19)
  {
    __int16 v28 = "Segment payload size mismatch";
    __int16 v29 = 242;
    goto LABEL_50;
  }

  compression_algorithm algorithm = v22;
  uint64_t v30 = *(unsigned int *)(v9 + 324);
  if (v30 >= 0x101)
  {
LABEL_71:
    __break(1u);
    return result;
  }

  memcpy((void *)(v16 + 352), (char *)v20 + *(void *)(v9 + 784), *(unsigned int *)(v9 + 324));
  *(_DWORD *)(v16 + 348) = v30;
  memset_s((void *)(v16 + 352 + v30), 256 - v30, 0, 256 - v30);
  unsigned int v31 = *(_DWORD *)(v9 + 156);
  int v57 = 0;
  memset(v56, 0, sizeof(v56));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(void *)__s = 0x5F41454100000006LL;
  memset(v58, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  unsigned int v54 = v31;
  unsigned int v32 = v14 / v31;
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v32;
  *(_DWORD *)__s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  uint64_t v33 = *(uint64_t (**)(_OWORD *, void))(v9 + 384);
  if (v33 && *(_DWORD *)(v9 + 520))
  {
    int v34 = v33(v56, *(unsigned int *)(v9 + 312));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    int v35 = 0;
    if ((v34 & 0x80000000) == 0) {
      goto LABEL_35;
    }
  }

  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }

  int v35 = 1;
LABEL_35:
  int v53 = v35;
  memset((char *)v58 + 8, 0, 224);
  memset((char *)&v58[14] + 8, 0, 28);
  WORD4(v58[0]) = 19283;
  *(void *)&v58[0] = 0x5F41454100000006LL;
  uint64_t result = memset_s((char *)v58 + 10, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v36 = LODWORD(v58[0]);
  if (LODWORD(v58[0]) >= 0xFD) {
    goto LABEL_71;
  }
  *(_DWORD *)((char *)v58 + LODWORD(v58[0]) + 4) = v14 - v32 * v54;
  LODWORD(v58[0]) = v36 + 4;
  memset_s((char *)v58 + v36 + 8, 252 - v36, 0, 252 - v36);
  memset(__s, 0, sizeof(__s));
  uint64_t v37 = *(uint64_t (**)(uint64_t, void, _OWORD *, _OWORD *, _BYTE *))(v9 + 384);
  if (v37 && LODWORD(v56[0]))
  {
    int v38 = v37(v16 + 88, *(unsigned int *)(v9 + 316), v56, v58, __s);
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
    if ((v38 & 0x80000000) == 0)
    {
      memset_s(v56, 0x104uLL, 0, 0x104uLL);
      if (!v53)
      {
        uint64_t v39 = *(uint64_t (**)(void, void))(v9 + 408);
        if (v39
          && *(_DWORD *)(v16 + 348) == *(_DWORD *)(v9 + 324)
          && (char v40 = (void **)(v16 + 40), (v39(*(void *)(v16 + 40), *(void *)(v16 + 32)) & 0x80000000) == 0))
        {
          uint64_t v42 = algorithm;
          if (algorithm)
          {
            char v40 = (void **)(v16 + 64);
            size_t v43 = compression_decode_buffer( *(uint8_t **)(v16 + 64),  *(void *)(v16 + 48),  *(const uint8_t **)(v16 + 40),  *(void *)(v16 + 32),  *(void **)(v16 + 80),  algorithm);
            *(void *)(v16 + 56) = v43;
          }

          else
          {
            size_t v43 = *(void *)(v16 + 32);
          }

          if (v43 == v18
            && (uint64_t v46 = (uint64_t)*v40,
                (aeaChecksum(v16 + 868, *(_DWORD *)(v9 + 148), *v40, v43, v41, v42, a7, a8) & 0x80000000) == 0)
            && (size_t v47 = *(unsigned int *)(v16 + 868), *(void *)(v9 + 784) == v47)
            && (_DWORD)v47 == *(_DWORD *)(v16 + 608)
            && !memcmp((const void *)(v16 + 872), v21, v47))
          {
            uint64_t v48 = *(uint64_t (**)(void, size_t, unint64_t, uint64_t))(v9 + 24);
            if (!v48 || (v48(*(void *)v9, v43, v55, v46) & 0x80000000) == 0)
            {
              _DWORD *v11 = 5;
              uint64_t v49 = (unsigned int *)(v9 + 120);
              do
                unsigned int v50 = __ldaxr(v49);
              while (__stlxr(v50 + 1, v49));
              if (*(_DWORD *)(v9 + 32) >= 3u) {
                fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u processed, offset=%jd, payload=%u, raw=%u\n");
              }
              return 0LL;
            }

            __int16 v28 = "Client processing callback reported an error";
            __int16 v29 = 297;
          }

          else
          {
            __int16 v28 = "Segment data failed verification";
            __int16 v29 = 285;
          }
        }

        else
        {
          __int16 v28 = "Segment decryption";
          __int16 v29 = 259;
        }

        goto LABEL_50;
      }

      goto LABEL_47;
    }
  }

  else
  {
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
  }

  memset_s(v56, 0x104uLL, 0, 0x104uLL);
LABEL_47:
  __int16 v28 = "derive segment encryption key";
  __int16 v29 = 252;
LABEL_50:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"workerProc",  v29,  114,  0,  v28,  a7,  a8,  v51);
  uint64_t v44 = (unsigned int *)(v9 + 48);
  while (!__ldaxr(v44))
  {
    if (!__stlxr(1u, v44)) {
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t pushRange(void *a1, uint64_t a2)
{
  unint64_t v4 = a1[140];
  unint64_t v5 = a1[139];
  if (v4 >= v5)
  {
    uint64_t v6 = 2 * v5;
    BOOL v7 = v5 == 0;
    uint64_t v8 = 32LL;
    if (!v7) {
      uint64_t v8 = v6;
    }
    a1[139] = v8;
    if ((unint64_t)(32 * v8) >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_13:
      a1[142] = 0LL;
      unint64_t v14 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"pushRange",  346,  114,  *v14,  "malloc",  v15,  v16,  v18);
      a1[139] = 0LL;
      a1[140] = 0LL;
      return -1LL;
    }

    uint64_t v9 = (void *)a1[142];
    uint64_t v10 = realloc(v9, 32 * v8);
    if (!v10)
    {
      free(v9);
      goto LABEL_13;
    }

    a1[142] = v10;
    unint64_t v4 = a1[140];
  }

  uint64_t v11 = a1[142];
  if (v4) {
    uint64_t v12 = *(void *)(v11 + 32 * v4 - 32) + *(void *)(v11 + 32 * v4 - 24);
  }
  else {
    uint64_t v12 = 0LL;
  }
  a1[140] = v4 + 1;
  int v13 = (void *)(v11 + 32 * v4);
  memset_s(v13, 0x20uLL, 0, 0x20uLL);
  *int v13 = a2;
  v13[1] = v12;
  v13[2] = -1LL;
  *((_DWORD *)v13 + 6) = -1;
  return v4;
}

uint64_t decryptAsyncClose(uint64_t a1)
{
  unsigned int v2 = atomic_load((unsigned int *)(a1 + 48));
  BOOL v3 = v2 == 0;
  if ((ThreadPoolDestroy(*(void *)(a1 + 1176)) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncClose",  850,  114,  0,  "ThreadPoolDestroy",  v4,  v5,  v18);
    BOOL v3 = 0;
  }

  uint64_t v6 = *(void **)(a1 + 1168);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 1160);
    if ((_DWORD)v7)
    {
      for (unint64_t i = 0LL; i < v7; ++i)
      {
        uint64_t v9 = *(void *)(*(void *)(a1 + 1168) + 8 * i);
        if (v9)
        {
          uint64_t v10 = *(void **)(v9 + 40);
          if (v10) {
            memset_s(*(void **)(v9 + 40), *(void *)(v9 + 24), 0, *(void *)(v9 + 24));
          }
          free(v10);
          uint64_t v11 = *(void **)(v9 + 64);
          if (v11) {
            memset_s(*(void **)(v9 + 64), *(void *)(v9 + 48), 0, *(void *)(v9 + 48));
          }
          free(v11);
          uint64_t v12 = *(void **)(v9 + 80);
          if (v12) {
            memset_s(*(void **)(v9 + 80), *(void *)(v9 + 72), 0, *(void *)(v9 + 72));
          }
          free(v12);
          memset_s((void *)v9, 0x468uLL, 0, 0x468uLL);
          free((void *)v9);
          unint64_t v7 = *(unsigned int *)(a1 + 1160);
        }
      }

      uint64_t v6 = *(void **)(a1 + 1168);
    }

    free(v6);
  }

  int v13 = *(void **)(a1 + 808);
  if (v13) {
    memset_s(*(void **)(a1 + 808), *(void *)(a1 + 792), 0, *(void *)(a1 + 792));
  }
  free(v13);
  unint64_t v14 = *(void **)(a1 + 1136);
  if (v14) {
    memset_s(*(void **)(a1 + 1136), 32LL * *(void *)(a1 + 1112), 0, 32LL * *(void *)(a1 + 1112));
  }
  free(v14);
  uint64_t v15 = *(void **)(a1 + 1104);
  if (v15)
  {
    rsize_t v16 = *(void *)(a1 + 800) * *(void *)(a1 + 1088);
    memset_s(*(void **)(a1 + 1104), v16, 0, v16);
  }

  free(v15);
  AEAContextDestroy(*(AEAContext *)(a1 + 128));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  memset_s((void *)a1, 0x4A0uLL, 0, 0x4A0uLL);
  free((void *)a1);
  return (v3 - 1);
}

uint64_t decryptAsyncGetRange(uint64_t a1, void *a2, void *a3)
{
  BOOL v3 = (unsigned int *)(a1 + 48);
  uint64_t v8 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v11 = "lockState";
    __int16 v12 = 743;
    goto LABEL_18;
  }

  if (*(_DWORD *)(a1 + 52) == 4)
  {
    uint64_t v13 = *(void *)(a1 + 1128);
    if (v13 < 0)
    {
LABEL_9:
      uint64_t v16 = atomic_load((unsigned int *)(a1 + 120));
      if (*(void *)(a1 + 1096) == v16) {
        *(_DWORD *)(a1 + 52) = 5;
      }
    }

    else
    {
      uint64_t v14 = *(void *)(a1 + 1136);
      while (1)
      {
        uint64_t v15 = v14 + 32 * v13;
        if (*(_DWORD *)(v15 + 28) == 4) {
          break;
        }
        uint64_t v13 = *(void *)(v15 + 16);
        *(void *)(a1 + 1128) = v13;
        if (v13 < 0) {
          goto LABEL_9;
        }
      }
    }
  }

  uint64_t v17 = *(void *)(a1 + 1128);
  if (v17 < 0)
  {
    if (*(_DWORD *)(a1 + 52) == 5)
    {
      *a2 = 0LL;
      *a3 = 0LL;
      uint64_t v20 = 1LL;
    }

    else
    {
      uint64_t v20 = 0LL;
    }
  }

  else
  {
    uint64_t v18 = *(void *)(a1 + 1136) + 32 * v17;
    uint64_t v19 = *(void *)(v18 + 8);
    *a2 = *(void *)v18;
    *a3 = v19;
    uint64_t v20 = 1LL;
    *(_DWORD *)(v18 + 28) = 1;
    *(void *)(a1 + 1128) = *(void *)(v18 + 16);
  }

  if (pthread_mutex_unlock(v8))
  {
    uint64_t v11 = "unlockState";
    __int16 v12 = 782;
LABEL_18:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncGetRange",  v12,  114,  0,  v11,  v9,  v10,  v23);
    while (!__ldaxr(v3))
    {
      if (!__stlxr(1u, v3)) {
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  return v20;
}

uint64_t decryptAsyncProcess(uint64_t a1, uint64_t *a2, size_t a3, uint64_t a4)
{
  uint64_t v4 = (unsigned int *)(a1 + 48);
  uint64_t v10 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v13 = "lockState";
    __int16 v14 = 796;
LABEL_21:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncProcess",  v14,  114,  0,  v13,  v11,  v12,  v25);
    goto LABEL_22;
  }

  __key[0] = 0LL;
  __int128 v27 = 0u;
  __key[1] = a4;
  uint64_t v15 = bsearch( __key,  *(const void **)(a1 + 1136),  *(void *)(a1 + 1120),  0x20uLL,  (int (__cdecl *)(const void *, const void *))cmpRange);
  if (!v15)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncProcess",  800,  114,  0,  "Invalid offset received: %jd\n",  v19,  v20,  a4);
LABEL_18:
    int v22 = 1;
    goto LABEL_19;
  }

  if (v15[7] == 1)
  {
    v15[7] = 2;
    if (*(void *)v15 == a3)
    {
      switch(*(_DWORD *)(a1 + 52))
      {
        case 0:
          int v21 = processMagic(a1, a2, a3, v16, v17, v18, v19, v20);
          goto LABEL_15;
        case 1:
          int v21 = processPrologue((void *)a1, a2, a3);
          goto LABEL_15;
        case 2:
          int v21 = processClusterHeader(a1, a2, a3, v16, v17, v18, v19, v20);
          goto LABEL_15;
        case 3:
          int v21 = processPadding(a1, (uint64_t)a2, a3);
          goto LABEL_15;
        case 4:
          int v21 = processSegment(a1, ((uint64_t)v15 - *(void *)(a1 + 1136)) >> 5, a2, a3, v17, v18, v19, v20);
LABEL_15:
          if ((v21 & 0x80000000) == 0) {
            goto LABEL_16;
          }
          goto LABEL_17;
        default:
LABEL_17:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncProcess",  822,  114,  0,  "Invalid archive",  v19,  v20,  v25);
          break;
      }
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"decryptAsyncProcess",  808,  114,  0,  "Invalid size received: %zu\n",  v19,  v20,  a3);
    }

    goto LABEL_18;
  }

LABEL_16:
  int v22 = 0;
LABEL_19:
  if (pthread_mutex_unlock(v10))
  {
    uint64_t v13 = "unlockState";
    __int16 v14 = 825;
    goto LABEL_21;
  }

  if (!v22) {
    return 0LL;
  }
LABEL_22:
  while (!__ldaxr(v4))
  {
    if (!__stlxr(1u, v4)) {
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

    __int128 v27 = 0;
    __int16 v28 = a5 - 1;
    __int16 v29 = *(unsigned int *)(a2 + 4LL * v28);
    LODWORD(v30) = v9 - v29;
    else {
      uint64_t v30 = v10;
    }
    while (1)
    {
      unsigned int v31 = v27 + 8;
      unsigned int v32 = *(void *)(v12 + v29 + v27);
      uint64_t v33 = *(void *)(v14 + v27);
      v27 += 8;
      int v34 = v33 ^ v32;
      if (v34)
      {
        LODWORD(v30) = v31 + (__clz(__rbit64(v34)) >> 3) - 8;
        goto LABEL_28;
      }
    }

    if (v27 < v30)
    {
      int v35 = v30 - v27;
      uint64_t v36 = (unsigned __int8 *)(v13 + a3 + v27);
      uint64_t v37 = (unsigned __int8 *)(v12 + v29 + v27);
      while (1)
      {
        uint64_t v39 = *v37++;
        int v38 = v39;
        char v40 = *v36++;
        if (v38 != v40) {
          break;
        }
        ++v27;
        if (!--v35) {
          goto LABEL_28;
        }
      }

      LODWORD(v30) = v27;
    }

  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v189, &v191, &v190) & 0x80000000) != 0)
  {
LABEL_130:
    v167 = (char)a1;
    int v21 = "obtain AFSC data: %s";
    int v22 = 615;
    goto LABEL_132;
  }

  uint64_t v24 = 0;
  v177 = (unint64_t *)(v18 + 66);
  v178 = v18 + 3;
  v176 = bswap32(a3 - 310);
  char v25 = (int8x8_t)vadd_s32(vdup_n_s32(a3), (int32x2_t)0xFFFFFECEFFFFFFCELL);
  uint64_t v26 = vrev32_s8(v25);
  position = v25.i32[0];
  __int128 v27 = (int)v19 - 4;
  v181 = (0x551u >> (v19 - 4)) & 1;
  while (1)
  {
    __int16 v28 = v189;
    if (v189 >= 0xFA000001)
    {
      int v21 = "Invalid AFSC data";
      int v22 = 616;
      goto LABEL_132;
    }

    v183 = v24;
    if (v191 == (_DWORD)v19)
    {
      if (!a3 || v190 == a3) {
        goto LABEL_152;
      }
      if ((v19 & 0x80000000) == 0) {
        goto LABEL_55;
      }
    }

    else if ((v19 & 0x80000000) == 0)
    {
      v173 = v27;
      __int16 v29 = 4;
      if (v19 > 0xE)
      {
        unsigned int v32 = v19;
      }

      else
      {
        uint64_t v30 = 1 << v19;
        if (((1 << v19) & 0x5510) != 0) {
          unsigned int v31 = 6;
        }
        else {
          unsigned int v31 = 4;
        }
        if ((v30 & 0x2A88) != 0) {
          __int16 v29 = 4;
        }
        else {
          __int16 v29 = v31;
        }
        if ((v30 & 0x2A88) != 0) {
          unsigned int v32 = v19 + 1;
        }
        else {
          unsigned int v32 = v19;
        }
      }

      uint64_t v33 = open(a1, 0);
      int v34 = v33;
      if ((v33 & 0x80000000) == 0)
      {
        if (!fstat(v33, &v188))
        {
          int v35 = mkstemp(__old);
          uint64_t v36 = v35;
          if (v35 < 0)
          {
            uint64_t v154 = __error();
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  664,  86,  *v154,  "mkstemp",  v155,  v156,  v167);
            uint64_t v17 = 0;
            uint64_t v44 = 0LL;
          }

          else
          {
            uint64_t v44 = ParallelCompressionAFSCStreamOpen(v35, v28, v32, v29);
            if (v44)
            {
              v179 = v19;
              fd = v34;
              v184 = v18;
              uint64_t v45 = 0LL;
              uint64_t v46 = 0LL;
              size_t v47 = 0x100000LL;
              uint64_t v48 = 0x100000LL;
              while (1)
              {
                uint64_t v49 = v28 >= v48 ? v48 : v28;
                if (v48 - 0x100000 >= v28) {
                  break;
                }
                unsigned int v50 = v49 + v45;
                char v51 = read(fd, v184, v49 + v45);
                if (v51 < 0)
                {
                  v123 = *__error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  675,  86,  v123,  "read: %s",  v124,  v125,  (char)a1);
                  goto LABEL_149;
                }

                if (v51 < v50)
                {
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  676,  86,  0,  "truncated read: %s",  v55,  v56,  (char)a1);
LABEL_149:
                  uint64_t v17 = 0;
LABEL_150:
                  uint64_t v74 = 0LL;
                  v76 = 0LL;
                  uint64_t v18 = v184;
                  goto LABEL_151;
                }

                v46 += 0x100000LL;
                int v57 = ParallelCompressionAFSCStreamWrite((uint64_t)v44, (uint64_t)v184, v50, v52, v53, v54, v55, v56);
                v48 += 0x100000LL;
                v45 -= 0x100000LL;
                if (v28 >= v46) {
                  __int128 v58 = v46;
                }
                else {
                  __int128 v58 = v28;
                }
                v47 -= 0x100000LL;
                if (v57 < (uint64_t)(v58 + v47))
                {
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  678,  86,  0,  "write to stream failed: %s",  v42,  v43,  (char)a1);
                  goto LABEL_149;
                }
              }

              if ((ParallelCompressionAFSCStreamClose((uint64_t)v44, v37, v38, v39, v40, v41, v42, v43) & 0x80000000) != 0)
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  683,  86,  0,  "Stream close error",  v92,  v93,  v167);
                uint64_t v17 = 0;
                uint64_t v44 = 0LL;
                goto LABEL_150;
              }

              fchown(v36, v188.st_uid, v188.st_gid);
              fchmod(v36, v188.st_mode & 0xFFF);
              close(fd);
              close(v36);
              unint64_t v94 = rename(__old, a1);
              unlink(__old);
              uint64_t v18 = v184;
              uint64_t v19 = v179;
              __int128 v27 = v173;
              if ((v94 & 0x80000000) == 0) {
                goto LABEL_55;
              }
              char v23 = *__error();
              v167 = (char)a1;
              int v21 = "rename: %s";
              int v22 = 694;
              goto LABEL_133;
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  667,  86,  0,  "creating compression stream %s",  v42,  v43,  (char)a1);
            uint64_t v17 = 0;
          }

          uint64_t v74 = 0LL;
          v76 = 0LL;
          goto LABEL_136;
        }

        uint64_t v138 = *__error();
        v167 = (char)a1;
        uint64_t v141 = "stat: %s";
        unint64_t v142 = 661;
        goto LABEL_170;
      }

      v143 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  660,  86,  v143,  "open: %s",  v144,  v145,  (char)a1);
LABEL_171:
      uint64_t v17 = 0;
      uint64_t v44 = 0LL;
      uint64_t v74 = 0LL;
      v76 = 0LL;
      goto LABEL_135;
    }

    __int128 v59 = open(a1, 9);
    int v34 = v59;
    if (v59 < 0)
    {
      uint64_t v132 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  629,  86,  v132,  "open %s",  v133,  v134,  (char)a1);
      goto LABEL_171;
    }

    if (write(v59, 0LL, 0LL) < 0)
    {
      uint64_t v138 = *__error();
      uint64_t v141 = "write";
      unint64_t v142 = 630;
LABEL_170:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v142,  86,  v138,  v141,  v139,  v140,  v167);
      goto LABEL_171;
    }

    if (close(v34) < 0)
    {
      char v23 = *__error();
      int v21 = "close";
      int v22 = 631;
      goto LABEL_133;
    }

    v191 = -1;
    v190 = 0;
LABEL_55:
    if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v189, &v191, &v190) & 0x80000000) != 0)
    {
      v167 = (char)a1;
      int v21 = "obtain AFSC data: %s";
      int v22 = 699;
      goto LABEL_132;
    }

    if (v191 != (_DWORD)v19)
    {
      int v21 = "Couldn't convert to requested compression type";
      int v22 = 700;
      goto LABEL_132;
    }

    if (!a3) {
      goto LABEL_152;
    }
    uint64_t v60 = v190;
    char v61 = a3 - v190;
    if (a3 == v190) {
      goto LABEL_152;
    }
    if (a3 >= v190) {
      break;
    }
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  711,  86,  "Can't shrink resource fork: %s (current %u, target %u)",  v12,  v13,  v14,  (char)a1);
LABEL_61:
    if ((v183 & 1) != 0)
    {
      int v21 = "Second pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)";
      v167 = (char)a1;
      int v22 = 852;
      goto LABEL_132;
    }

    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  859,  86,  "First pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)",  v12,  v13,  v14,  (char)a1);
    v62 = open(a1, 9);
    int v34 = v62;
    if (v62 < 0)
    {
      uint64_t v135 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  864,  86,  v135,  "open %s",  v136,  v137,  (char)a1);
      goto LABEL_171;
    }

    if (write(v62, 0LL, 0LL) < 0)
    {
      uint64_t v138 = *__error();
      uint64_t v141 = "write";
      unint64_t v142 = 865;
      goto LABEL_170;
    }

    if (close(v34) < 0)
    {
      char v23 = *__error();
      int v21 = "close";
      int v22 = 866;
      goto LABEL_133;
    }

    v191 = -1;
    v190 = 0;
    __int128 v63 = ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v189, &v191, &v190);
    uint64_t v24 = 1;
    if (v63 < 0) {
      goto LABEL_130;
    }
  }

  if (v27 > 0xA || !v181)
  {
    v167 = v19;
    int v21 = "Invalid compression type %u";
    int v22 = 722;
    goto LABEL_132;
  }

  v180 = v19;
  v182 = dword_1862D7B6C[v27];
  uint64_t v64 = open(a1, 0);
  v65 = v64;
  if (v64 < 0)
  {
    uint64_t v146 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  727,  86,  v146,  "open: %s",  v147,  v148,  (char)a1);
LABEL_176:
    uint64_t v17 = 0;
    uint64_t v44 = 0LL;
    uint64_t v74 = 0LL;
    v76 = 0LL;
    uint64_t v36 = -1;
    int v34 = v65;
    goto LABEL_136;
  }

  if (fstat(v64, &v188))
  {
    uint64_t v149 = *__error();
    v152 = "fstat";
    unint64_t v153 = 728;
LABEL_175:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v153,  86,  v149,  v152,  v150,  v151,  v167);
    goto LABEL_176;
  }

  if (fgetxattr(v65, "com.apple.decmpfs", value, 0x10uLL, 0, 32) != 16)
  {
    uint64_t v149 = *__error();
    v152 = "Reading decmpfs";
    unint64_t v153 = 729;
    goto LABEL_175;
  }

  fd = v65;
  if (fchflags(v65, v188.st_flags & 0xFFFFFFDF) < 0)
  {
    uint64_t v118 = *__error();
    uint64_t v121 = "fchflags UF_COMPRESSED";
    uint64_t v122 = 730;
LABEL_145:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v122,  86,  v118,  v121,  v119,  v120,  v167);
    uint64_t v17 = 0;
    uint64_t v44 = 0LL;
    uint64_t v74 = 0LL;
    v76 = 0LL;
    goto LABEL_146;
  }

  uint64_t v66 = v28 + 0xFFFF;
  v172 = (v28 + 0xFFFF) >> 16;
  v174 = v27;
  size_t v67 = v60 + 0x100000;
  v68 = -v60;
  v69 = v60;
  while (1)
  {
    uint64_t v70 = a3 >= v67 ? v67 : a3;
    if (v69 >= a3) {
      break;
    }
    int v71 = v70 + v68;
    if (v69 == v60) {
      __memset_chk();
    }
    v72 = fsetxattr(fd, "com.apple.ResourceFork", v18, v71, v69, 0);
    v67 += 0x100000;
    v68 -= 0x100000;
    v69 += 0x100000;
    if (v72)
    {
      uint64_t v118 = *__error();
      uint64_t v121 = "Expanding resource fork";
      uint64_t v122 = 738;
      goto LABEL_145;
    }
  }

  size_t v73 = v172;
  uint64_t v74 = malloc((4 * v172 + 4));
  size = (4 * v172 + 4);
  uint64_t v75 = (int *)malloc(size);
  v76 = v75;
  if (v74) {
    unint64_t v77 = v75 == 0LL;
  }
  else {
    unint64_t v77 = 1;
  }
  if (v77)
  {
    v157 = *__error();
    signed int v160 = "malloc";
    uint64_t v161 = 744;
    goto LABEL_183;
  }

  v170 = (v66 >> 16);
  if ((_DWORD)v180 != 4)
  {
    int v34 = fd;
    uint64_t v88 = (4 * v172 + 4);
    if (fgetxattr(fd, "com.apple.ResourceFork", v74, size, 0, 32) == size)
    {
LABEL_98:
      v185 = v18;
      memcpy(v76, v74, v88);
      v76[v172] = v74[v172] + v61;
      while (v61 && v73)
      {
        uint64_t v95 = (v73 - 1);
        v96 = v74[v95];
        v97 = v74[v73] - v96;
        if (fgetxattr(v34, "com.apple.ResourceFork", v185, v97, v96, 32) != v97)
        {
          uint64_t v126 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  777,  86,  *v126,  "Reading chunk",  v127,  v128,  v167);
          uint64_t v17 = 0;
          uint64_t v44 = 0LL;
          uint64_t v36 = -1;
          uint64_t v18 = v185;
          goto LABEL_136;
        }

        uint64_t v98 = 0x10000 - v97;
        if (v61 >= v98) {
          uint64_t v100 = v98;
        }
        else {
          uint64_t v100 = v61;
        }
        if ((_DWORD)v100) {
          bzero((char *)v185 + v97, v100);
        }
        uint64_t v101 = (v100 + v97);
        unint64_t v102 = v76[v73] - v101;
        v76[v95] = v102;
        v61 -= v100;
        int v34 = fd;
        --v73;
        if (fsetxattr(fd, "com.apple.ResourceFork", v185, v101, v102, 0))
        {
          uint64_t v129 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  791,  86,  *v129,  "Writing chunk",  v130,  v131,  v167);
          uint64_t v17 = 0;
          uint64_t v44 = 0LL;
          uint64_t v36 = -1;
          uint64_t v18 = v185;
          goto LABEL_136;
        }
      }

      uint64_t v19 = v180;
      if ((_DWORD)v180 == 4)
      {
        uint64_t v18 = v185;
        *v185 = v169;
        *(int8x8_t *)(v185 + 1) = v26;
        v103 = v205;
        *((_OWORD *)v178 + 12) = v204;
        *((_OWORD *)v178 + 13) = v103;
        *((_OWORD *)v178 + 14) = v206;
        v178[60] = v207;
        __int16 v104 = v201;
        *((_OWORD *)v178 + 8) = v200;
        *((_OWORD *)v178 + 9) = v104;
        v105 = v203;
        *((_OWORD *)v178 + 10) = v202;
        *((_OWORD *)v178 + 11) = v105;
        __int16 v106 = v197;
        *((_OWORD *)v178 + 4) = v196;
        *((_OWORD *)v178 + 5) = v106;
        v107 = v199;
        *((_OWORD *)v178 + 6) = v198;
        *((_OWORD *)v178 + 7) = v107;
        __int16 v108 = v193;
        *(_OWORD *)v178 = v192;
        *((_OWORD *)v178 + 1) = v108;
        int v109 = v195;
        *((_OWORD *)v178 + 2) = v194;
        *((_OWORD *)v178 + 3) = v109;
        v185[64] = v176;
        v185[65] = v168;
        uint64_t v110 = v170;
        if ((_DWORD)v172)
        {
          uint64_t v111 = v76 + 1;
          uint64_t v112 = *v76;
          int v113 = v177;
          do
          {
            uint64_t v114 = *v111++;
            *v113++ = (v112 - 260) | ((unint64_t)(v114 - v112) << 32);
            uint64_t v112 = v114;
            --v110;
          }

          while (v110);
        }

        if (fsetxattr(v34, "com.apple.ResourceFork", v185, (8 * v172) + 264LL, 0, 0))
        {
          unint64_t v162 = *__error();
          size_t v165 = "Writing resource fork header";
          size_t v166 = 817;
          goto LABEL_189;
        }

        if (fsetxattr(v34, "com.apple.ResourceFork", &old_resource_fork_map, 0x32uLL, position, 0))
        {
          unint64_t v162 = *__error();
          size_t v165 = "Writing resource map";
          size_t v166 = 820;
          goto LABEL_189;
        }
      }

      else
      {
        uint64_t v18 = v185;
        if (fsetxattr(v34, "com.apple.ResourceFork", v76, size, 0, 0))
        {
          unint64_t v162 = *__error();
          size_t v165 = "Writing chunk sizes";
          size_t v166 = 827;
          goto LABEL_189;
        }
      }

      if (fsetxattr(v34, "com.apple.decmpfs", value, 0x10uLL, 0, 0))
      {
        unint64_t v162 = *__error();
        size_t v165 = "Writing decmpfs";
        size_t v166 = 831;
      }

      else
      {
        if ((fchflags(v34, v188.st_flags | 0x20) & 0x80000000) == 0)
        {
          close(v34);
          free(v74);
          free(v76);
          if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v189, &v191, &v190) & 0x80000000) == 0)
          {
            if (v191 != (_DWORD)v180)
            {
              __int128 v27 = v174;
              goto LABEL_61;
            }

            __int128 v27 = v174;
            if (v190 != a3) {
              goto LABEL_61;
            }
LABEL_152:
            if ((v183 & 1) != 0) {
              pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  876,  86,  "Second pass fixup succeeded: %s",  v12,  v13,  v14,  (char)a1);
            }
            uint64_t v44 = 0LL;
            uint64_t v74 = 0LL;
            v76 = 0LL;
            int v34 = -1;
            uint64_t v17 = 1;
            goto LABEL_135;
          }

          v167 = (char)a1;
          int v21 = "obtain AFSC data: %s";
          int v22 = 840;
          goto LABEL_132;
        }

        unint64_t v162 = *__error();
        size_t v165 = "fchflags UF_COMPRESSED";
        size_t v166 = 832;
      }
    }

    else
    {
      unint64_t v162 = *__error();
      size_t v165 = "Reading chunk sizes";
      size_t v166 = 763;
    }

  uint64_t v16 = *((void *)a1 + 262);
  uint64_t v17 = v9 >> 62;
  switch(v16)
  {
    case 'C':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        char v25 = 398;
        goto LABEL_31;
      }

      if (!v11)
      {
        uint64_t v24 = "no input dir";
        char v25 = 399;
        goto LABEL_31;
      }

      if (v12) {
        goto LABEL_39;
      }
      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  402,  133,  0,  "invalid PAT: %s",  v18,  v19,  (_BYTE)a1 + 40);
        goto LABEL_32;
      }

      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  403,  133,  0,  "invalid PAT: %s",  v20,  v21,  (_BYTE)a1 + 40);
        goto LABEL_32;
      }

      if ((aaCopyFile(v114, __s, v13) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  404,  133,  0,  "copy file: %s",  v22,  v23,  (char)__s);
        goto LABEL_32;
      }

      if (*((void *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        uint64_t v24 = "apply YEC (copy)";
        char v25 = 406;
        goto LABEL_31;
      }

      goto LABEL_39;
    case 'E':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        char v25 = 262;
        goto LABEL_31;
      }

      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  263,  133,  0,  "invalid PAT: %s",  v30,  v31,  (_BYTE)a1 + 40);
        goto LABEL_32;
      }

      unsigned int v32 = strlen(__s);
      makePath(__s, v32);
      uint64_t v33 = *((void *)a1 + 261);
      switch(v33)
      {
        case 'L':
          int v71 = (AAHeader_impl *)*((void *)a1 + 596);
          v72.ikey = 4935244;
          KeyIndex = AAHeaderGetKeyIndex(v71, v72);
          if ((KeyIndex & 0x80000000) != 0
            || ((FieldString = AAHeaderGetFieldString(v71, KeyIndex, 0x400uLL, v114, &length), FieldString <= 1)
              ? (uint64_t v75 = 1)
              : (uint64_t v75 = FieldString),
                v75 <= 0))
          {
            uint64_t v24 = "missing LNK";
            char v25 = 279;
            goto LABEL_31;
          }

          unlink(__s);
          if ((symlink(v114, __s) & 0x80000000) == 0) {
            goto LABEL_39;
          }
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  281,  133,  0,  "creating symlink: %s",  v76,  v77,  (char)__s);
          goto LABEL_32;
        case 'F':
          v78 = (AAByteStream_impl *)*((void *)a1 + 607);
          if (!v78)
          {
            uint64_t v24 = "no file stream";
            char v25 = 286;
            goto LABEL_31;
          }

          AAByteStreamClose(v78);
          *((void *)a1 + 607) = 0LL;
          if (*((void *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
          {
            uint64_t v24 = "apply YEC (extract)";
            char v25 = 288;
            goto LABEL_31;
          }

          break;
        case 'D':
          unlink(__s);
          if (mkdir(__s, 0x1EDu) < 0 && (*__error() != 17 || stat(__s, &v106) || (v106.st_mode & 0xF000) != 0x4000))
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  274,  133,  0,  "creating dir: %s",  v34,  v35,  (char)__s);
            goto LABEL_32;
          }

          break;
        default:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  292,  133,  0,  "Unsupported entry type (extract): %c\n",  a7,  a8,  v33);
          goto LABEL_32;
      }

      goto LABEL_39;
    case 'I':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        char v25 = 425;
        goto LABEL_31;
      }

      if (!v11)
      {
        uint64_t v24 = "no input dir";
        char v25 = 426;
        goto LABEL_31;
      }

      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  427,  133,  0,  "invalid PAT: %s",  v36,  v37,  (_BYTE)a1 + 40);
        goto LABEL_32;
      }

      FieldCount = AAHeaderGetFieldCount(*((AAHeader *)a1 + 596));
      *(_OWORD *)__s = 0u;
      memset(v113, 0, 156);
      if (!FieldCount)
      {
LABEL_102:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  465,  133,  0,  "patch doesn't match source file: %s",  v39,  v40,  (char)v114);
        goto LABEL_149;
      }

      uint64_t v41 = FieldCount;
      uint64_t v42 = 0;
      size_t v43 = 0LL;
      while (1)
      {
        if (AAHeaderGetFieldType(*((AAHeader *)a1 + 596), v42) != 3) {
          goto LABEL_98;
        }
        FieldKey = AAHeaderGetFieldKey(*((AAHeader *)a1 + 596), v42);
        if (!v43)
        {
          uint64_t v52 = FieldKey.ikey & 0xFFFFFF;
          if ((FieldKey.ikey & 0xFFFFFF) == 0x324853)
          {
            size_t v43 = 0x2000LL;
          }

          else if (v52 == 3491923)
          {
            size_t v43 = 0x8000LL;
          }

          else
          {
            if (v52 != 3360851)
            {
              size_t v43 = 0LL;
LABEL_98:
              int v53 = 0;
              goto LABEL_99;
            }

            size_t v43 = 0x4000LL;
          }
        }

        if (!*(_DWORD *)__s && (aaEntryHashesInitWithPath(__s, v43, v10, a1 + 1064) & 0x80000000) != 0) {
          break;
        }
        if (AAHeaderGetFieldHash(*((AAHeader *)a1 + 596), v42, 0x40uLL, &hash_function, value) < 0)
        {
          uint64_t v60 = "retrieving digest from header";
          char v61 = 458;
LABEL_148:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  v61,  133,  0,  v60,  v39,  v40,  (char)v98);
          goto LABEL_149;
        }

        if ((__s[0] & 4) != 0 && hash_function == 3)
        {
          uint64_t v49 = *(void *)((char *)v113 + 12) == *(void *)value
             && *(void *)((char *)&v113[1] + 4) == *(void *)&value[8]
             && *(void *)((char *)&v113[1] + 12) == (void)v109
             && *(void *)((char *)&v113[2] + 4) == *((void *)&v109 + 1);
        }

        else
        {
          if ((__s[0] & 8) != 0 && hash_function == 4)
          {
            unsigned int v50 = (char *)&v113[2] + 12;
            char v51 = 48LL;
          }

          else
          {
            int v53 = 0;
            if ((__s[0] & 0x10) == 0 || hash_function != 5) {
              goto LABEL_99;
            }
            unsigned int v50 = (char *)&v113[5] + 12;
            char v51 = 64LL;
          }

          uint64_t v49 = memcmp(v50, value, v51) == 0;
        }

        int v53 = v49;
LABEL_99:
        if (++v42 >= v41 || v53)
        {
          if ((v53 & 1) != 0) {
            goto LABEL_129;
          }
          goto LABEL_102;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  454,  133,  0,  "computing file digest: %s",  v45,  v46,  (char)v114);
LABEL_149:
      __int16 v28 = 0;
LABEL_150:
      uint64_t v26 = 0LL;
LABEL_151:
      __int128 v27 = 0LL;
LABEL_34:
      AAHeaderDestroy(*((AAHeader *)a1 + 596));
      *((void *)a1 + 596) = 0LL;
      AAByteStreamClose(*((AAByteStream *)a1 + 608));
      *((void *)a1 + 608) = 0LL;
      AAByteStreamClose(*((AAByteStream *)a1 + 607));
      *((void *)a1 + 607) = 0LL;
      *((void *)a1 + 609) = 0LL;
      *((void *)a1 + 598) = 0LL;
      *((void *)a1 + 601) = 0LL;
      *((void *)a1 + 604) = 0LL;
      memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
      memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
      memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
      memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
      AAByteStreamClose(v27);
      MappedBufferDestroy(v26);
      if (v28) {
        return 0LL;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    case 'M':
      uint64_t v26 = 0LL;
      __int128 v27 = 0LL;
      __int16 v28 = 1;
      *((_DWORD *)a1 + 1186) = 1;
      goto LABEL_34;
    case 'O':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        char v25 = 472;
        goto LABEL_31;
      }

      uint64_t v126 = 0LL;
      unint64_t v125 = 0u;
      __int16 v124 = 0u;
      v123 = 0u;
      uint64_t v122 = 0u;
      uint64_t v121 = 0u;
      v120 = 0u;
      uint64_t v119 = 0u;
      uint64_t v118 = 0u;
      v117 = 0u;
      v116 = 0u;
      uint64_t v115 = 0u;
      *(_OWORD *)uint64_t v114 = 0u;
      unsigned int v54 = a1[2112];
      if ((v54 & 1) != 0)
      {
        __strlcat_chk();
        unsigned int v54 = a1[2112];
        if ((v54 & 2) == 0)
        {
LABEL_108:
          if ((v54 & 8) == 0) {
            goto LABEL_109;
          }
          goto LABEL_155;
        }
      }

      else if ((a1[2112] & 2) == 0)
      {
        goto LABEL_108;
      }

      __strlcat_chk();
      unsigned int v54 = a1[2112];
      if ((v54 & 8) == 0)
      {
LABEL_109:
        if ((v54 & 4) == 0) {
          goto LABEL_110;
        }
        goto LABEL_156;
      }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"sendHeader",  v13,  111,  0,  v12,  v3,  v4,  v14);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

  if (!a2) {
    goto LABEL_29;
  }
  memset_s(a2, 0x38uLL, 0, 0x38uLL);
  *a2 = (a4 >> 7) & 0xF | *a2 & 0xF0;
  st_mode = v30.st_mode;
  __int16 v14 = v30.st_mode & 0xF000;
  if (v14 == 0x8000)
  {
    if (((a4 >> 7) & 2) == 0 && ((char)a4 & 0x80000000) == 0)
    {
LABEL_24:
      if ((*a2 & 4) != 0)
      {
        *((void *)a2 + 2) = getFileAPFSInternalFlagsFD();
        st_mode = v30.st_mode;
      }

      goto LABEL_26;
    }

    *(void *)&v31[0] = 0LL;
    __int16 v28 = 0;
    LODWORD(v29[0]) = 0;
    if ((ParallelCompressionAFSCGetMetadata(v32, (off_t *)v31, (unsigned int *)v29, &v28) & 0x80000000) == 0)
    {
      uint64_t v15 = v28;
      *((_DWORD *)a2 + 2) = v29[0];
      *((_DWORD *)a2 + 3) = v15;
      st_mode = v30.st_mode;
      __int16 v14 = v30.st_mode & 0xF000;
      goto LABEL_22;
    }

    __int128 v27 = v32;
    int v21 = "querying AFSC metadata: %s";
    int v22 = 362;
    goto LABEL_36;
  }

  uint64_t v12 = *(void **)(a1 + 24);
  uint64_t v13 = realloc(v12, v11);
  if (v13)
  {
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v13;
    uint64_t v8 = *(void *)(a1 + 8);
    goto LABEL_18;
  }

  free(v12);
LABEL_32:
  *uint64_t v6 = 0LL;
  v6[1] = 0LL;
  uint64_t v4 = -1LL;
  v6[2] = 0LL;
  return v4;
}

        if (v22 != __size)
        {
          uint64_t v8 = 0LL;
          uint64_t v10 = v36;
          goto LABEL_22;
        }

        uint64_t v10 = v36;
        uint64_t v26 = aeaChecksum((uint64_t)v37, a4, v36, __size, v17, v18, v19, v20);
        uint64_t v8 = 0LL;
        if (v26 < 0 || LODWORD(v37[0]) != a6) {
          goto LABEL_22;
        }
        if (!memcmp((char *)v37 + 4, a5, a6))
        {
          __int16 v28 = *(uint64_t (**)(void, float))(a1 + 128);
          if (!v28) {
            goto LABEL_29;
          }
          __int16 v29 = *(void *)(a1 + 72);
          if (!v29) {
            goto LABEL_29;
          }
          uint64_t v30 = (unint64_t *)(a1 + 368);
          do
          {
            unsigned int v31 = __ldxr(v30);
            unsigned int v32 = v31 + __size;
          }

          while (__stxr(v32, v30));
          if ((v28(*(void *)(a1 + 112), (float)((float)v32 * 100.0) / (float)v29) & 0x80000000) != 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"verifySegmentProc",  128,  128,  0,  "progress_proc",  v33,  v34,  v35);
            uint64_t v8 = 0xFFFFFFFFLL;
          }

          else
          {
LABEL_29:
            uint64_t v8 = 1LL;
          }

          goto LABEL_22;
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      uint64_t v8 = 0LL;
    }

    else
    {
      uint64_t v10 = 0LL;
      uint64_t v8 = 0LL;
      *__error() = 12;
    }

  if (v16 != v10)
  {
    uint64_t v13 = "aaByteStreamPWriteExpected";
    __int16 v14 = 166;
    goto LABEL_24;
  }

  int v22 = *(uint64_t (**)(void, float))(a1 + 128);
  if (v22)
  {
    char v23 = *(void *)(a1 + 72);
    if (v23)
    {
      uint64_t v24 = (unint64_t *)(a1 + 368);
      do
      {
        char v25 = __ldxr(v24);
        uint64_t v26 = v25 + v10;
      }

      while (__stxr(v26, v24));
      if ((v22(*(void *)(a1 + 112), (float)((float)v26 * 100.0) / (float)v23) & 0x80000000) != 0)
      {
        uint64_t v13 = "progress_proc";
        __int16 v14 = 167;
        goto LABEL_24;
      }
    }
  }

  return 0LL;
}

    uint64_t v24 = v20 >= v19;
    char v25 = v20 - v19;
    if (!v24 || v20 >= *(_DWORD *)(a1 + 32))
    {
      __int16 v29 = "could not move output page in cache";
      uint64_t v30 = 305;
      goto LABEL_29;
    }

    uint64_t v26 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v26 + 1;
    *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v25) = v26;
    __int128 v27 = cacheData(a1, v20, v23, v14, v15, v16, v17, v18);
    if (!v27) {
      goto LABEL_30;
    }
    memcpy((void *)(v27 + (a2 & 0xFFF)), v8, v12);
    a2 += v12;
    v8 += v12;
    v9 -= v12;
    if (!v9) {
      return 0LL;
    }
  }

  if (!movePage(a1, v20, v23, v14, v15, v16, v17, v18))
  {
    LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v21);
    uint64_t v19 = *(_DWORD *)(a1 + 24);
    goto LABEL_16;
  }

  __int16 v29 = "moving page from disk to cache";
  uint64_t v30 = 301;
LABEL_29:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c",  (uint64_t)"outputPageData",  v30,  21,  0,  v29,  v17,  v18,  v33);
LABEL_30:
  unsigned int v31 = "unable to load output page";
  unsigned int v32 = 643;
LABEL_31:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c",  (uint64_t)"PagedFileRetainAndWriteOut",  v32,  21,  0,  v31,  v17,  v18,  v33);
  return 0xFFFFFFFFLL;
}

uint64_t decryptAsyncCancel(uint64_t result)
{
  unint64_t v1 = (unsigned int *)(result + 48);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

uint64_t decryptAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 48));
}

uint64_t processMagic( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Magic received: %zu B\n", a3);
  }
  if (a3 == 12)
  {
    uint64_t v18 = *a2;
    int v19 = *((_DWORD *)a2 + 2);
    if ((aeaContainerParamsInitWithMagic((int *)v17, &v18, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0
      && (aeaCryptoInit((char *)(a1 + 312), v17) & 0x80000000) == 0
      && (aeaContainerOffsetsInit((uint64_t)v15, v17, (unsigned int *)(a1 + 312)) & 0x80000000) == 0)
    {
      uint64_t result = 0LL;
      **(void **)(a1 + 1136) = v16;
      *(_DWORD *)(a1 + 52) = 1;
      *(void *)(a1 + 1128) = 0LL;
      return result;
    }

    uint64_t v12 = "Invalid archive";
    __int16 v13 = 494;
  }

  else
  {
    uint64_t v12 = "Invalid magic";
    __int16 v13 = 487;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processMagic",  v13,  114,  0,  v12,  a7,  a8,  v14);
  return 0xFFFFFFFFLL;
}

uint64_t processPrologue(void *a1, _DWORD *a2, size_t a3)
{
  if (*((_DWORD *)a1 + 8) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Prologue received: %zu B\n", a3);
  }
  uint64_t v6 = aeaContextCreateWithPrologue(a2, a3);
  a1[16] = v6;
  if (!v6)
  {
    uint64_t v12 = "creating encryption context";
    __int16 v13 = 514;
    goto LABEL_29;
  }

  uint64_t v9 = v6;
  uint64_t v10 = (uint64_t (*)(void, uint64_t))a1[1];
  if (v10)
  {
    if ((v10(*a1, v6) & 0x80000000) != 0)
    {
      uint64_t v12 = "Context setup callback returned an error";
      __int16 v13 = 518;
      goto LABEL_29;
    }

    uint64_t v9 = a1[16];
  }

  if ((aeaContextUnlock(v9, (uint64_t)(a1 + 17), (_DWORD *)a1 + 130, 0LL, 1, 0) & 0x80000000) != 0)
  {
    uint64_t v12 = "Archive unlock";
    __int16 v13 = 521;
    goto LABEL_29;
  }

  unsigned int v11 = aeaChecksumSize(*((_DWORD *)a1 + 37));
  a1[98] = v11;
  if (v11 <= 0x1F)
  {
    uint64_t v12 = "Invalid checksum mode for decrypt to file, at least 256 bits are required";
    __int16 v13 = 525;
LABEL_29:
    int v25 = 0;
LABEL_30:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processPrologue",  v13,  114,  v25,  v12,  v7,  v8,  v35);
    return 0xFFFFFFFFLL;
  }

  uint64_t result = aeaContainerOffsetsInit((uint64_t)(a1 + 26), (unsigned int *)a1 + 34, (unsigned int *)a1 + 78);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v12 = "Invalid archive";
    __int16 v13 = 528;
    goto LABEL_29;
  }

  if (a1[1])
  {
    uint64_t v15 = a1[16];
    *(_OWORD *)uint64_t v15 = *(_OWORD *)(a1 + 17);
    __int128 v16 = *(_OWORD *)(a1 + 19);
    __int128 v17 = *(_OWORD *)(a1 + 21);
    __int128 v18 = *(_OWORD *)(a1 + 23);
    *(void *)(v15 + 64) = a1[25];
    *(_OWORD *)(v15 + 32) = v17;
    *(_OWORD *)(v15 + 48) = v18;
    *(_OWORD *)(v15 + 16) = v16;
    uint64_t result = ((uint64_t (*)(void, void))a1[1])(*a1, a1[16]);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v12 = "Client post-unlock callback returned an error";
      __int16 v13 = 534;
      goto LABEL_29;
    }
  }

  if ((*((_BYTE *)a1 + 47) & 4) != 0) {
    *(_DWORD *)(a1[16] + 2740LL) = 1;
  }
  unint64_t v19 = *((unsigned int *)a1 + 39);
  unint64_t v20 = ((a1[21] + (unint64_t)*((unsigned int *)a1 + 38) - 1) / *((unsigned int *)a1 + 38) + v19 - 1) / v19;
  if (HIDWORD(v20)) {
    BOOL v21 = 0;
  }
  else {
    BOOL v21 = (v20 * v19) >> 32 == 0;
  }
  if (!v21)
  {
    uint64_t v12 = "Invalid archive, too many clusters";
    __int16 v13 = 546;
    goto LABEL_29;
  }

  *((_DWORD *)a1 + 195) = v20;
  uint64_t v22 = *((unsigned int *)a1 + 81);
  if (v22 >= 0x101)
  {
    __break(1u);
  }

  else
  {
    memcpy((char *)a1 + 820, (char *)a2 + a1[33], *((unsigned int *)a1 + 81));
    *((_DWORD *)a1 + 204) = v22;
    memset_s((char *)a1 + v22 + 820, 256 - v22, 0, 256 - v22);
    if (*((_DWORD *)a1 + 195))
    {
      uint64_t v23 = a1[98] + *((unsigned int *)a1 + 81) + 8LL;
      a1[100] = v23;
      unint64_t v24 = v20 * *((unsigned int *)a1 + 39);
      a1[136] = v24;
      a1[137] = 0LL;
      if (v24 * v23 >= 0x2000000001LL)
      {
        *__error() = 12;
        a1[138] = 0LL;
LABEL_38:
        int v25 = *__error();
        uint64_t v12 = "malloc";
        __int16 v13 = 569;
        goto LABEL_30;
      }

      unsigned int v32 = malloc(v24 * v23);
      a1[138] = v32;
      if (!v32) {
        goto LABEL_38;
      }
      uint64_t v33 = pushRange(a1, a1[38]);
      if (v33 < 0)
      {
        uint64_t v12 = "inserting first cluster header range";
        __int16 v13 = 573;
        goto LABEL_29;
      }

      uint64_t v34 = v33;
      uint64_t result = 0LL;
      *((_DWORD *)a1 + 13) = 2;
      a1[141] = v34;
      *((_DWORD *)a1 + 269) = 0;
    }

    else
    {
      int v26 = pushPaddingRange((uint64_t)a1);
      if (v26 < 0)
      {
        uint64_t v12 = "inserting padding range";
        __int16 v13 = 556;
        goto LABEL_29;
      }

      if (!v26 && (startStreaming((uint64_t)a1, v27, v28, v29, v30, v31, v7, v8) & 0x80000000) != 0)
      {
        uint64_t v12 = "Streaming data setup";
        __int16 v13 = 559;
        goto LABEL_29;
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t processClusterHeader( uint64_t a1, void *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  int v55 = 0;
  memset(v54, 0, sizeof(v54));
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Cluster header received: %zu B\n", __n);
  }
  unsigned int v11 = *(void **)(a1 + 808);
  if (v11)
  {
    size_t v12 = *(void *)(a1 + 792);
    goto LABEL_5;
  }

  size_t v12 = *(void *)(a1 + 304);
  *(void *)(a1 + 792) = v12;
  if (v12 >= 0x2000000001LL)
  {
    *__error() = 12;
    *(void *)(a1 + 808) = 0LL;
LABEL_50:
    int v51 = *__error();
    __int128 v17 = "malloc";
    __int16 v18 = 596;
LABEL_55:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processClusterHeader",  v18,  114,  v51,  v17,  a7,  a8,  v53);
    uint64_t v50 = 0xFFFFFFFFLL;
    goto LABEL_56;
  }

  unsigned int v11 = malloc(v12);
  *(void *)(a1 + 808) = v11;
  if (!v11) {
    goto LABEL_50;
  }
LABEL_5:
  if (v12 != __n)
  {
    __int128 v17 = "Invalid cluster header size";
    __int16 v18 = 600;
LABEL_54:
    int v51 = 0;
    goto LABEL_55;
  }

  memcpy(v11, __src, __n);
  int v13 = *(_DWORD *)(a1 + 1076);
  int v57 = 0;
  memset(v56, 0, sizeof(v56));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(void *)__s = 0x5F41454100000006LL;
  memset(v58, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v13;
  *(_DWORD *)__s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  char v14 = *(uint64_t (**)(_OWORD *, void))(a1 + 384);
  if (!v14 || !*(_DWORD *)(a1 + 520))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_15:
    int v16 = 1;
    goto LABEL_16;
  }

  int v15 = v14(v56, *(unsigned int *)(a1 + 312));
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  int v16 = 0;
  if (v15 < 0) {
    goto LABEL_15;
  }
LABEL_16:
  memset((char *)v58 + 12, 0, 248);
  *(void *)((char *)v58 + 4) = 0x4B4548435F414541LL;
  LODWORD(v58[0]) = 8;
  memset_s((char *)v58 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(__s, 0, sizeof(__s));
  unint64_t v19 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _BYTE *))(a1 + 384);
  if (!v19 || !LODWORD(v56[0]))
  {
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
    goto LABEL_52;
  }

  int v20 = v19(v54, *(unsigned int *)(a1 + 316), v56, v58, __s);
  memset_s(v58, 0x104uLL, 0, 0x104uLL);
  if (v20 < 0)
  {
LABEL_52:
    memset_s(v56, 0x104uLL, 0, 0x104uLL);
    goto LABEL_53;
  }

  memset_s(v56, 0x104uLL, 0, 0x104uLL);
  if (v16)
  {
LABEL_53:
    __int128 v17 = "Cluster header encryption key derivation";
    __int16 v18 = 611;
    goto LABEL_54;
  }

  BOOL v21 = *(uint64_t (**)(void, void, uint64_t, _OWORD *, void, void))(a1 + 408);
  if (!v21
    || *(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324)
    || (uint64_t result = v21( *(void *)(a1 + 808),  *(void *)(a1 + 288),  a1 + 816,  v54,  *(void *)(a1 + 808) + *(void *)(a1 + 288),  *(void *)(a1 + 304) - *(void *)(a1 + 288)),  (result & 0x80000000) != 0))
  {
    __int128 v17 = "Cluster header decryption";
    __int16 v18 = 622;
    goto LABEL_54;
  }

  size_t v23 = *(unsigned int *)(a1 + 324);
  int v24 = *(_DWORD *)(a1 + 156);
  if (v24)
  {
    int v25 = 0;
    size_t v26 = *(void *)(a1 + 784) + 8LL;
    int v27 = v24 * *(_DWORD *)(a1 + 1076);
    uint64_t v28 = *(void *)(a1 + 296);
    uint64_t v29 = *(void *)(a1 + 280);
    while (1)
    {
      unint64_t v30 = *(void *)(a1 + 1096);
      if (v30 >= *(void *)(a1 + 1088))
      {
        __int128 v17 = "Invalid archive";
        __int16 v18 = 634;
        goto LABEL_54;
      }

      uint64_t v31 = (unsigned int *)(*(void *)(a1 + 1104) + *(void *)(a1 + 800) * v30);
      memcpy(v31, (const void *)(*(void *)(a1 + 808) + v29), v26);
      uint64_t result = (uint64_t)memcpy((char *)v31 + v26, (const void *)(*(void *)(a1 + 808) + v28), v23);
      uint64_t v32 = *v31;
      if (!(_DWORD)v32) {
        goto LABEL_42;
      }
      uint64_t v33 = *(void *)(a1 + 1120);
      if (v33) {
        uint64_t v33 = *(void *)(*(void *)(a1 + 1136) + 32 * v33 - 32) + *(void *)(*(void *)(a1 + 1136) + 32 * v33 - 24);
      }
      uint64_t v34 = v31[1];
      if ((unint64_t)(v33 + v34) > *(void *)(a1 + 176)
        || (unint64_t v35 = *(void *)(a1 + 1080) + v32, v36 = *(void *)(a1 + 168), v35 > v36))
      {
        __int128 v17 = "Invalid archive: segment size mismatch";
        __int16 v18 = 648;
        goto LABEL_54;
      }

      if (v34 > v32
        || (v35 != v36 ? (BOOL v37 = v32 >= *(_DWORD *)(a1 + 152)) : (BOOL v37 = 1), !v37))
      {
        unsigned int v53 = v31[1];
        __int128 v17 = "Invalid segment sizes: payload=%u raw=%u";
        __int16 v18 = 651;
        goto LABEL_54;
      }

      ++*(void *)(a1 + 1096);
      *(void *)(a1 + 1080) = v35;
      uint64_t result = pushRange((void *)a1, v34);
      if (result < 0) {
        break;
      }
      v29 += v26;
      v28 += v23;
      uint64_t v38 = *(void *)(a1 + 1136);
      uint64_t v39 = v38 + 32 * result;
      *(_DWORD *)(v39 + 24) = v27 + v25;
      *(_DWORD *)(v39 + 28) = 3;
      uint64_t v40 = *(void *)(a1 + 1152);
      uint64_t v41 = v38 + 32 * v40 + 16;
      if (v40 >= 0) {
        uint64_t v42 = (void *)v41;
      }
      else {
        uint64_t v42 = (void *)(a1 + 1144);
      }
      *uint64_t v42 = result;
      *(void *)(a1 + 1152) = result;
      if (++v25 >= *(_DWORD *)(a1 + 156))
      {
LABEL_42:
        LODWORD(v23) = *(_DWORD *)(a1 + 324);
        goto LABEL_43;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"pushSegmentRange",  386,  114,  0,  "inserting segment range",  a7,  a8,  v53);
    __int16 v18 = 658;
    int v51 = 0;
    __int128 v17 = "inserting segment range";
    goto LABEL_55;
  }

LABEL_43:
  if (v23 < 0x101)
  {
    memcpy((void *)(a1 + 820), (const void *)(*(void *)(a1 + 808) + *(void *)(a1 + 288)), v23);
    *(_DWORD *)(a1 + 816) = v23;
    memset_s((void *)(a1 + 820 + v23), 256LL - v23, 0, 256LL - v23);
    int v43 = *(_DWORD *)(a1 + 1076) + 1;
    *(_DWORD *)(a1 + 1076) = v43;
    if (v43 == *(_DWORD *)(a1 + 780))
    {
      int v44 = pushPaddingRange(a1);
      if (v44 < 0)
      {
        __int128 v17 = "inserting padding range";
        __int16 v18 = 669;
      }

      else
      {
        if (v44 || (startStreaming(a1, v45, v46, v47, v48, v49, a7, a8) & 0x80000000) == 0)
        {
          uint64_t v50 = 0LL;
LABEL_56:
          memset_s(v54, 0x104uLL, 0, 0x104uLL);
          return v50;
        }

        __int128 v17 = "Streaming data setup";
        __int16 v18 = 672;
      }
    }

    else
    {
      uint64_t v52 = pushRange((void *)a1, *(void *)(a1 + 304));
      if ((v52 & 0x8000000000000000LL) == 0)
      {
        uint64_t v50 = 0LL;
        *(void *)(a1 + 1128) = v52;
        goto LABEL_56;
      }

      __int128 v17 = "inserting next cluster header range";
      __int16 v18 = 679;
    }

    goto LABEL_54;
  }

  __break(1u);
  return result;
}

      AAByteRangeDestroy(*(void ***)(a1 + 2296));
      *(void *)(a1 + 2296) = v11;
    }

    else
    {
      unsigned int v11 = *(void ***)(a1 + 2296);
    }

    int v43 = AAByteRangeClone((uint64_t)v11);
    *(void *)(a1 + 2472) = v43;
    if (!v43)
    {
      uint64_t v9 = "AAByteRangeClone";
      uint64_t v10 = 564;
      goto LABEL_18;
    }

    *(_DWORD *)(a1 + 2400) = -1;
    if (!*(_DWORD *)(a1 + 2384))
    {
      size_t v12 = 0LL;
      if (!*(_DWORD *)(a1 + 2120))
      {
        unsigned int v11 = 0LL;
        goto LABEL_21;
      }

      __int128 v63 = 0LL;
      char v61 = 0LL;
      uint64_t v60 = 0LL;
      LODWORD(v62) = 0;
      LODWORD(v58) = 0;
      goto LABEL_107;
    }

    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    while (1)
    {
      uint64_t v49 = *(void *)(a1 + 2152);
      uint64_t v50 = v49 * v48;
      int v51 = v49 * v48 + v49;
      uint64_t v52 = v51 >= *(void *)(a1 + 2144) ? *(void *)(a1 + 2144) : v51;
      if (v50 > v52) {
        break;
      }
      unsigned int v54 = *(void *)(a1 + 2296);
      int v55 = AAByteRangeSizeAtOffset(v54, v52);
      uint64_t v56 = AAByteRangeSizeAtOffset(v54, v50);
      unsigned int v53 = *(void *)(a1 + 2392);
      if (v55 != v56) {
        goto LABEL_71;
      }
      *(_DWORD *)(v53 + v47) = 3;
      unlinkTempSegment(a1, v48, v57, v44, v45, v46, v5, v6);
LABEL_73:
      ++v48;
      __int128 v58 = *(unsigned int *)(a1 + 2384);
      v47 += 16LL;
      if (v48 >= v58)
      {
        if (*(_DWORD *)(a1 + 2120))
        {
          if ((_DWORD)v58)
          {
            __int128 v59 = 0LL;
            uint64_t v60 = 0LL;
            char v61 = 0LL;
            v62 = 0LL;
            LODWORD(v12) = 0;
            __int128 v63 = 0LL;
            while (1)
            {
              uint64_t v64 = *(void *)(a1 + 2152);
              v65 = v64 * v59;
              uint64_t v66 = v64 * v59 + v64;
              size_t v67 = v66 >= *(void *)(a1 + 2144) ? *(void *)(a1 + 2144) : v66;
              if (v65 > v67) {
                break;
              }
              unint64_t v77 = v62;
              v62 = v63;
              v69 = v60;
              uint64_t v70 = v61;
              int v71 = *(void *)(a1 + 2296);
              v72 = AAByteRangeSizeAtOffset(v71, v67);
              size_t v73 = AAByteRangeSizeAtOffset(v71, v65);
              v68 = v72 - v73;
              if (v72 != v73)
              {
                char v61 = v70;
                uint64_t v60 = v69;
                __int128 v63 = v62;
                LODWORD(v62) = v77;
LABEL_84:
                if (getTempSegmentFilename(a1, v59, __str, v44, v45, v46, v5, v6) || stat(__str, &buf))
                {
                  st_size = 0LL;
                }

                else if ((buf.st_mode & 0xF000) == 0x8000)
                {
                  st_size = buf.st_size;
                }

                else
                {
                  st_size = 0LL;
                }

                v63 += v68;
                LODWORD(v12) = v12 + 1;
                char v61 = v61 - v65 + v67;
                if (st_size) {
                  v62 = (v62 + 1);
                }
                else {
                  v62 = v62;
                }
                v60 += st_size;
                goto LABEL_91;
              }

              char v61 = v70;
              uint64_t v60 = v69;
              __int128 v63 = v62;
              v62 = v77;
LABEL_91:
              ++v59;
              __int128 v58 = *(unsigned int *)(a1 + 2384);
              if (v59 >= v58) {
                goto LABEL_107;
              }
            }

            v68 = -1LL;
            goto LABEL_84;
          }

          __int128 v63 = 0LL;
          LODWORD(v12) = 0;
          LODWORD(v62) = 0;
          char v61 = 0LL;
          uint64_t v60 = 0LL;
LABEL_107:
          uint64_t v75 = (FILE **)MEMORY[0x1895F89D0];
          fprintf((FILE *)*MEMORY[0x1895F89D0], "%12u segments in archive\n", v58);
          fprintf(*v75, "%12u segments to process\n", v12);
          fprintf(*v75, "%12u segments in cache\n", v62);
          fprintf(*v75, "%12u segments to download\n", v12 - v62);
          fprintf(*v75, "%12llu bytes in archive\n", *(void *)(a1 + 2144));
          fprintf(*v75, "%12llu bytes to process\n", v63);
          fprintf(*v75, "%12llu segment bytes in cache\n", v60);
          fprintf(*v75, "%12llu segment bytes to download\n", v61 - v60);
        }

        unsigned int v11 = 0LL;
        size_t v12 = 0LL;
        goto LABEL_21;
      }
    }

    unsigned int v53 = *(void *)(a1 + 2392);
LABEL_71:
    *(_DWORD *)(v53 + v47) = 0;
    if (*(_DWORD *)(a1 + 2400) == -1) {
      *(_DWORD *)(a1 + 2400) = v48;
    }
    goto LABEL_73;
  }

  unsigned int v11 = 0LL;
  size_t v12 = 0LL;
  *(_DWORD *)(a1 + 2140) = 1;
LABEL_21:
  AAByteRangeDestroy(v11);
  return v12;
}

  if (v113 < 0)
  {
    *__error() = 12;
    uint64_t v46 = 0LL;
    uint64_t v47 = 0LL;
    *__error() = 12;
  }

  else
  {
    uint64_t v46 = (char *)calloc(v113, 0x28uLL);
    uint64_t v47 = calloc(v113, 0x38uLL);
  }

  if ((unint64_t)(8LL * v113) >= 0x2000000001LL)
  {
    uint64_t v49 = 0LL;
    *__error() = 12;
LABEL_65:
    __int128 v58 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  578,  60,  *v58,  "malloc",  v59,  v60,  v106);
    uint64_t v48 = 0LL;
    goto LABEL_49;
  }

  char v61 = malloc(8LL * v113);
  uint64_t v49 = v61;
  if (!v46 || !v47 || !v61) {
    goto LABEL_65;
  }
  if (v113 >= 1)
  {
    v62 = v47;
    __int128 v63 = v113;
    uint64_t v64 = v61;
    do
    {
      v62[2] = v14;
      _OWORD v62[3] = v12;
      v62[4] = &v116;
      void *v62 = v27;
      v62[1] = v120;
      *((_DWORD *)v62 + 10) = (v10 >> 6) & 1;
      *v64++ = v62;
      v62 += 7;
      --v63;
    }

    while (v63);
  }

  uint64_t v48 = ThreadPoolCreate(v113, (uint64_t)v61, (uint64_t)expandDirThreadProc);
  if (!v48)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  591,  60,  0,  "ThreadPoolCreate",  v70,  v71,  v106);
    goto LABEL_49;
  }

  uint64_t v111 = v49;
  int v109 = v47;
  v72 = *v27;
  if (!*v27) {
    goto LABEL_108;
  }
  size_t v73 = 0;
  uint64_t v74 = v72 - 1;
  __int16 v108 = v72 - 1;
  do
  {
    if ((DefaultNThreads + v72 + ~v74) / DefaultNThreads <= 0x64) {
      uint64_t v75 = 100;
    }
    else {
      uint64_t v75 = (DefaultNThreads + v72 + ~v74) / DefaultNThreads;
    }
    uint64_t v110 = v73;
    v76 = 0;
    uint64_t v114 = !v73;
    uint64_t v112 = 1;
    unint64_t v77 = v113;
    v78 = (int *)v46;
    do
    {
      v79 = v74 + v75 * v76;
      void *v78 = v114;
      v78[1] = v79;
      v80 = v79 + v75;
      v78[2] = v79 + v75;
      if (v79 > v72)
      {
        v78[1] = v72;
        v79 = v72;
      }

      if (v80 > v72)
      {
        v78[2] = v72;
        v80 = v72;
      }

      if (v79 < v80)
      {
        uint64_t Worker = ThreadPoolGetWorker((uint64_t)v48, v65, v66, v67, v68, v69, v70, v71);
        if (Worker)
        {
          *(void *)(Worker + 48) = v78;
          uint64_t v86 = 618;
          uint64_t v87 = "ThreadPoolRunWorker";
        }

        else
        {
          uint64_t v86 = 616;
          uint64_t v87 = "ThreadPoolGetWorker";
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  v86,  60,  0,  v87,  v70,  v71,  v106);
        uint64_t v112 = 0;
      }

  if (v43 <= v16) {
    uint64_t v46 = 0LL;
  }
  else {
    uint64_t v46 = *((void *)acl + 5) + *(void *)(*((void *)acl + 2) + 8 * v16);
  }
  *(_DWORD *)uint64_t v46 = v15;
  if (ace->tag == ACL_EXTENDED_DENY) {
    uint64_t v47 = 68;
  }
  else {
    uint64_t v47 = 0;
  }
  if (ace->tag == ACL_EXTENDED_ALLOW) {
    uint64_t v48 = 65;
  }
  else {
    uint64_t v48 = v47;
  }
  *(_BYTE *)(v46 + 4) = v48;
  *(void *)(v46 + 5) = ace->flags;
  *(void *)(v46 + 13) = ace->perms;
  *(_BYTE *)(v46 + 21) = ace->qualifier_type;
  if (qualifier_size) {
    memcpy((void *)(v46 + 22), qualifier_value, qualifier_size);
  }
  return 0;
}

uint64_t processPadding(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Padding received: %zu B\n", a3);
  }
  int v43 = 0;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 __s = 0u;
  __int128 v28 = 0u;
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  if (*(void *)(a1 + 488)
    && (*(_DWORD *)((char *)v25 + 7) = 1262571615,
        *(void *)&v25[0] = 0x5F41454100000007LL,
        memset_s((void *)((unint64_t)v25 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (uint64_t v6 = *(uint64_t (**)(__int128 *, void))(a1 + 384)) != 0LL)
    && *(_DWORD *)(a1 + 520)
    && (v6(&__s, *(unsigned int *)(a1 + 312)) & 0x80000000) == 0)
  {
    uint64_t v7 = (*(uint64_t (**)(__int128 *))(a1 + 488))(&__s);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v25, 0x104uLL, 0, 0x104uLL);
  if (!v7)
  {
    int v16 = "authenticating padding";
    __int16 v17 = 699;
    goto LABEL_25;
  }

  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 496);
  BOOL v11 = !v10 || (v10(v7, a2, a3) & 0x80000000) != 0;
  int v43 = 0;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 __s = 0u;
  __int128 v28 = 0u;
  size_t v12 = *(uint64_t (**)(uint64_t, __int128 *))(a1 + 504);
  if (!v12) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324)) {
    goto LABEL_22;
  }
  if ((v12(v7, &__s) & 0x80000000) != 0) {
    goto LABEL_22;
  }
  if ((_DWORD)__s != *(_DWORD *)(a1 + 324)) {
    goto LABEL_22;
  }
  if (__s >= 8)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    do
    {
      v14 |= *(void *)((char *)&__s + v13 + 4) ^ *(void *)(a1 + 820 + v13);
      unint64_t v15 = v13 + 16;
      v13 += 8LL;
    }

    while (v15 <= __s);
    if (v14)
    {
LABEL_22:
      memset_s(&__s, 0x104uLL, 0, 0x104uLL);
LABEL_23:
      int v16 = "authenticating padding";
      __int16 v17 = 702;
      goto LABEL_25;
    }
  }

  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  if (v11) {
    goto LABEL_23;
  }
  if ((startStreaming(a1, v19, v20, v21, v22, v23, v8, v9) & 0x80000000) == 0) {
    return 0LL;
  }
  int v16 = "Streaming data setup";
  __int16 v17 = 705;
LABEL_25:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processPadding",  v17,  114,  0,  v16,  v8,  v9,  v24);
  return 0xFFFFFFFFLL;
}

uint64_t processSegment( uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = a4;
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment received: %zu B\n", a4);
  }
  uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1176), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!Worker)
  {
    uint64_t v23 = "ThreadPoolGetWorker";
    __int16 v24 = 720;
    goto LABEL_9;
  }

  uint64_t v15 = Worker;
  int v16 = 1;
  if (*(void *)(Worker + 24) < v8)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processSegment",  723,  114,  0,  "Invalid segment size",  v13,  v14,  v26);
    int v16 = 0;
    size_t v8 = 0LL;
  }

  memcpy(*(void **)(v15 + 40), a3, v8);
  *(void *)(v15 + 32) = v8;
  *(_DWORD *)(v15 + 16) = 1;
  *(void *)(v15 + 8) = a2;
  if ((ThreadPoolRunWorker(*(void *)(a1 + 1176), v15, v17, v18, v19, v20, v21, v22) & 0x80000000) != 0)
  {
    uint64_t v23 = "ThreadPoolRunWorker";
    __int16 v24 = 728;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"processSegment",  v24,  114,  0,  v23,  v13,  v14,  v26);
    int v16 = 0;
  }

  if (v16) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t cmpRange(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t pushPaddingRange(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 128) + 2740LL)) {
    return 0LL;
  }
  unint64_t v2 = *(void *)(a1 + 1120);
  if (v2) {
    unint64_t v2 = *(void *)(*(void *)(a1 + 1136) + 32 * v2 - 32) + *(void *)(*(void *)(a1 + 1136) + 32 * v2 - 24);
  }
  unint64_t v3 = *(void *)(a1 + 176);
  if (v3 == v2) {
    return 0LL;
  }
  if (v3 >= v2)
  {
    uint64_t v5 = pushRange((void *)a1, v3 - v2);
    if ((v5 & 0x8000000000000000LL) == 0)
    {
      *(_DWORD *)(a1 + 52) = 3;
      *(void *)(a1 + 1128) = v5;
      return 1LL;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"pushPaddingRange",  375,  114,  0,  "inserting padding range",  v6,  v7,  v8);
  }

  return 0xFFFFFFFFLL;
}

uint64_t startStreaming( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 780))
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 52) = 5;
    return result;
  }

  if (!*(_DWORD *)(a1 + 1160))
  {
LABEL_14:
    unint64_t v20 = *(void *)(a1 + 1120);
    if (v20)
    {
      unint64_t v21 = 0LL;
      uint64_t v22 = 24LL;
      do
      {
        if (*(_DWORD *)(*(void *)(a1 + 1136) + v22) != -1)
        {
          uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1176), a2, a3, a4, a5, a6, a7, a8);
          if (!Worker)
          {
            __int128 v36 = "ThreadPoolGetWorker";
            __int16 v37 = 449;
            goto LABEL_45;
          }

          *(_DWORD *)(Worker + 16) = 0;
          *(void *)(Worker + 8) = v21;
          if ((ThreadPoolRunWorker(*(void *)(a1 + 1176), Worker, v24, v25, v26, v27, a7, a8) & 0x80000000) != 0)
          {
            __int128 v36 = "ThreadPoolRunWorker";
            __int16 v37 = 452;
            goto LABEL_45;
          }

          unint64_t v20 = *(void *)(a1 + 1120);
        }

        ++v21;
        v22 += 32LL;
      }

      while (v21 < v20);
    }

    if ((ThreadPoolSync(*(unsigned int **)(a1 + 1176)) & 0x80000000) != 0)
    {
      __int128 v36 = "ThreadPoolSync";
      __int16 v37 = 454;
      goto LABEL_45;
    }

    uint64_t v28 = *(void *)(a1 + 1120);
    if (v28)
    {
      int v29 = 0;
      int v30 = 0;
      __int128 v31 = (int *)(*(void *)(a1 + 1136) + 28LL);
      do
      {
        int v33 = *v31;
        v31 += 8;
        int v32 = v33;
        if (v33 == 4) {
          int v34 = v30 + 1;
        }
        else {
          int v34 = v30;
        }
        if (v32 == 6) {
          ++v29;
        }
        else {
          int v30 = v34;
        }
        --v28;
      }

      while (v28);
      uint64_t v28 = (v29 + v30);
    }

    if (*(void *)(a1 + 1096) != v28 || *(void *)(a1 + 1080) != *(void *)(a1 + 168))
    {
      __int128 v36 = "Segment count/size mismatch";
      __int16 v37 = 467;
      goto LABEL_45;
    }

    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 52) = 4;
    *(void *)(a1 + 1128) = *(void *)(a1 + 1144);
    return result;
  }

  uint64_t v9 = 0LL;
  while (1)
  {
    uint64_t v10 = *(void **)(*(void *)(a1 + 1168) + 8 * v9);
    if (v10[3]) {
      goto LABEL_5;
    }
    uint64_t v11 = *v10;
    size_t v12 = *(unsigned int *)(*v10 + 152LL);
    uint64_t v13 = malloc(v12);
    v10[5] = v13;
    if (!v13)
    {
      __int16 v38 = 144;
      goto LABEL_44;
    }

    v10[3] = v12;
    compression_algorithm v14 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v11 + 160));
    if (!v14) {
      goto LABEL_5;
    }
    compression_algorithm v15 = v14;
    int v16 = malloc(v12);
    v10[8] = v16;
    if (!v16)
    {
      __int16 v38 = 152;
      goto LABEL_44;
    }

    v10[6] = v12;
    size_t v17 = compression_decode_scratch_buffer_size(v15);
    if (!v17) {
      goto LABEL_5;
    }
    size_t v18 = v17;
    if (v17 >= 0x2000000001LL) {
      break;
    }
    uint64_t v19 = malloc(v17);
    v10[10] = v19;
    if (!v19) {
      goto LABEL_43;
    }
    v10[9] = v18;
LABEL_5:
  }

  *__error() = 12;
  v10[10] = 0LL;
LABEL_43:
  __int16 v38 = 159;
LABEL_44:
  __int128 v39 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"workerAllocBuffers",  v38,  114,  *v39,  "malloc",  v40,  v41,  v42);
  __int128 v36 = "Worker buffer allocation";
  __int16 v37 = 440;
LABEL_45:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c",  (uint64_t)"startStreaming",  v37,  114,  0,  v36,  a7,  a8,  v42);
  return 0xFFFFFFFFLL;
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  unint64_t v2 = (uint64_t (*)(void, AAHeader *))*((void *)s + 5);
  if (v2) {
    return v2(*(void *)s, header);
  }
  else {
    return -1;
  }
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  BOOL v4 = (uint64_t (*)(void, void, void *, size_t))*((void *)s + 6);
  if (v4) {
    return v4(*(void *)s, key.ikey, buf, nbyte);
  }
  else {
    return -1;
  }
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  unint64_t v2 = (uint64_t (*)(void, AAHeader))*((void *)s + 3);
  if (v2) {
    return v2(*(void *)s, header);
  }
  else {
    return -1;
  }
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  BOOL v4 = (uint64_t (*)(void, void, const void *, size_t))*((void *)s + 4);
  if (v4) {
    return v4(*(void *)s, key.ikey, buf, nbyte);
  }
  else {
    return -1;
  }
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  if (!s) {
    return 0;
  }
  if (*(void *)s) {
    int v2 = (*((uint64_t (**)(void))s + 1))();
  }
  else {
    int v2 = 0;
  }
  free(s);
  return v2;
}

void AAArchiveStreamCancel(AAArchiveStream s)
{
  unint64_t v1 = (void (*)(void))*((void *)s + 2);
  if (v1) {
    v1(*(void *)s);
  }
}

AAArchiveStream AACustomArchiveStreamOpen(void)
{
  v0 = (AAArchiveStream_impl *)malloc(0x38uLL);
  unint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x38uLL, 0, 0x38uLL);
  }

  else
  {
    int v2 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AACustomArchiveStreamOpen",  49,  14,  *v2,  "malloc",  v3,  v4,  v6);
  }

  return v1;
}

void AACustomArchiveStreamSetData(AAArchiveStream s, void *data)
{
  *(void *)s = data;
}

void AACustomArchiveStreamSetCloseProc(AAArchiveStream s, AAArchiveStreamCloseProc proc)
{
  *((void *)s + 1) = proc;
}

void AACustomArchiveStreamSetCancelProc(AAArchiveStream s, AAArchiveStreamCancelProc proc)
{
  *((void *)s + 2) = proc;
}

void AACustomArchiveStreamSetWriteHeaderProc(AAArchiveStream s, AAArchiveStreamWriteHeaderProc proc)
{
  *((void *)s + 3) = proc;
}

void AACustomArchiveStreamSetWriteBlobProc(AAArchiveStream s, AAArchiveStreamWriteBlobProc proc)
{
  *((void *)s + 4) = proc;
}

void AACustomArchiveStreamSetReadHeaderProc(AAArchiveStream s, AAArchiveStreamReadHeaderProc proc)
{
  *((void *)s + 5) = proc;
}

void AACustomArchiveStreamSetReadBlobProc(AAArchiveStream s, AAArchiveStreamReadBlobProc proc)
{
  *((void *)s + 6) = proc;
}

uint64_t appendPathListWorkerProc(uint64_t **a1)
{
  uint64_t v201 = *MEMORY[0x1895F89C0];
  int v2 = *a1;
  uint64_t v189 = **a1;
  bzero(path, 0x400uLL);
  bzero(v199, 0x800uLL);
  uint64_t v5 = AAHeaderCreate();
  if (v5)
  {
    int v6 = 1;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  168,  14,  0,  "creating header",  v3,  v4,  (char)v162);
    int v6 = 0;
  }

  AAEntryXATBlob v9 = AAEntryXATBlobCreate();
  if (!v9)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  170,  14,  0,  "creating XAT field",  v7,  v8,  (char)v162);
    int v6 = 0;
  }

  size_t v12 = AAEntryACLBlobCreate();
  if (!v12)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  172,  14,  0,  "creating XAT field",  v10,  v11,  (char)v162);
    int v6 = 0;
  }

  xat = v9;
  compression_algorithm v15 = (void **)AAEntryYECBlobCreate();
  if (!v15)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  174,  14,  0,  "creating YEC field",  v13,  v14,  (char)v162);
    int v6 = 0;
  }

  size[0] = 0LL;
  size[1] = 0LL;
  v195 = 0LL;
  uint64_t v16 = v2[136];
  size_t v17 = a1[1];
  size_t v18 = (unint64_t *)(v16 + 40LL * (void)v17);
  unint64_t v19 = *v18;
  unint64_t v21 = v18[1];
  unint64_t v20 = v18 + 1;
  if (v19 < v21)
  {
    uint64_t v22 = (unsigned int *)(v2 + 140);
    unsigned int v23 = *((_DWORD *)v2 + 280) != 0;
    __int128 __s = (char *)(v2 + 3);
    uint64_t v24 = v16 + 40LL * (void)v17;
    v186 = (size_t *)(v24 + 24);
    v187 = (void **)(v24 + 32);
    v188 = (size_t *)(v24 + 16);
    do
    {
      uint64_t v25 = v2[144];
      uint64_t v26 = v25 + (v19 << 7);
      if (v23 || *v22)
      {
        int v6 = 0;
        int v27 = 1;
        unsigned int v23 = 1;
        goto LABEL_15;
      }

      size_t path_length = 0LL;
      if (AAPathListNodeGetPath((AAPathList)v2[1], *(void *)(v25 + (v19 << 7) + 24), 0x400uLL, path, &path_length) < 0)
      {
        __int16 v43 = 192;
        uint64_t v44 = "AAPathListNodeGetPath";
        goto LABEL_39;
      }

      if ((concatPath(v199, 0x800uLL, __s, path) & 0x80000000) != 0)
      {
        __int16 v43 = 193;
        uint64_t v44 = "invalid path";
        goto LABEL_39;
      }

      int v30 = (uint64_t (*)(uint64_t, uint64_t, char *, void))v2[132];
      if (v30 && (v30(v2[131], 30LL, path, 0LL) & 0x80000000) != 0)
      {
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  199,  14,  "operation aborted",  v31,  v32,  v33,  (char)v162);
        while (!__ldaxr(v22))
        {
          int v27 = 1;
          unsigned int v23 = __stlxr(1u, v22);
          if (!v23)
          {
            int v6 = 0;
            goto LABEL_15;
          }
        }

        unsigned int v23 = 0;
        int v6 = 0;
        __clrex();
        goto LABEL_41;
      }

      if (lstat(v199, &v196) < 0)
      {
        int v45 = *__error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  202,  14,  v45,  "lstat %s",  v46,  v47,  (char)v199);
LABEL_40:
        unsigned int v23 = 0;
        int v6 = 0;
LABEL_41:
        int v27 = 1;
        goto LABEL_15;
      }

      if ((aaHeaderInitWithPath(v5, (AAFieldKeySet_impl *)v2[2], __s, path) & 0x80000000) != 0)
      {
        __int16 v43 = 203;
        uint64_t v44 = "initializing header from path";
LABEL_39:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  v43,  14,  0,  v44,  v28,  v29,  (char)v162);
        goto LABEL_40;
      }

      v34.ikey = 5521732;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v34))
      {
        if ((v196.st_mode & 0xF000) == 0x8000)
        {
          v35.ikey = 5521732;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v35, v196.st_size) < 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  209,  14,  0,  "inserting DAT: %s",  v36,  v37,  (char)v199);
            goto LABEL_40;
          }
        }
      }

      v38.ikey = 5521752;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v38))
      {
        if ((aaEntryXATBlobInitWithPath(xat, __s, path) & 0x80000000) != 0)
        {
          __int16 v49 = 216;
          uint64_t v50 = "initializing XAT field from path";
LABEL_127:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  v49,  14,  0,  v50,  v39,  v40,  (char)v162);
          unsigned int v23 = 0;
          int v6 = 0;
          int v27 = 1;
          goto LABEL_15;
        }

        if (AAEntryXATBlobGetEntryCount(xat))
        {
          size_t EncodedSize = AAEntryXATBlobGetEncodedSize(xat);
          v42.ikey = 5521752;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v42, EncodedSize) < 0)
          {
            unint64_t v162 = v199;
            __int16 v49 = 220;
            uint64_t v50 = "inserting XAT: %s";
            goto LABEL_127;
          }

          __srCC_SHA256_CTX c = 0;
        }

        else
        {
          __srCC_SHA256_CTX c = 1;
        }
      }

      else
      {
        __srCC_SHA256_CTX c = 1;
      }

      v51.ikey = 4997953;
      if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v51)) {
        goto LABEL_54;
      }
      int v52 = v196.st_mode & 0xF000;
      if (v52 != 0x8000 && v52 != 0x4000) {
        goto LABEL_54;
      }
      unsigned int v53 = AAEntryACLBlobCreate();
      size_t v12 = v53;
      if (!v53)
      {
        __int16 v43 = 229;
        uint64_t v44 = "creating ACL field";
        goto LABEL_39;
      }

      if ((aaEntryACLBlobInitWithPath(v53, __s, path, v189) & 0x80000000) != 0)
      {
        __int16 v43 = 230;
        uint64_t v44 = "initializing ACL field from path";
        goto LABEL_39;
      }

      if (AAEntryACLBlobGetEntryCount(v12))
      {
        size_t v54 = AAEntryACLBlobGetEncodedSize(v12);
        v55.ikey = 4997953;
        if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v55, v54) < 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  234,  14,  0,  "inserting ACL: %s",  v56,  v57,  (char)v199);
          goto LABEL_40;
        }

        char v173 = 0;
      }

      else
      {
LABEL_54:
        char v173 = 1;
      }

      v58.ikey = 4408665;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v58))
      {
        char v177 = 1;
        if ((v196.st_mode & 0xF000) == 0x8000 && v196.st_size >= 1)
        {
          if ((aaEntryYECBlobInitWithPath(v15, 65552, __s, path) & 0x80000000) != 0)
          {
            __int16 v43 = 242;
            uint64_t v44 = "initializing YEC field from path";
            goto LABEL_39;
          }

          uint64_t v59 = AAEntryYECBlobGetEncodedSize((uint64_t)v15);
          v60.ikey = 4408665;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v60, v59) < 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  244,  14,  0,  "inserting YEC: %s",  v61,  v62,  (char)v199);
            goto LABEL_40;
          }

          char v177 = 0;
        }
      }

      else
      {
        char v177 = 1;
      }

      v63.ikey = 5260889;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v63))
      {
        int v172 = 1;
        if ((v196.st_mode & 0xF000) == 0x8000 && v196.st_size >= 1)
        {
          if ((aaEntryYFPBlobInitWithPath(size, __s, path) & 0x80000000) != 0)
          {
            __int16 v43 = 251;
            uint64_t v44 = "initializing YFP field from path";
            goto LABEL_39;
          }

          v64.ikey = 5260889;
          if (AAHeaderSetFieldBlob(v5, 0xFFFFFFFF, v64, size[0]) < 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  253,  14,  0,  "inserting YFP: %s",  v65,  v66,  (char)v199);
            goto LABEL_40;
          }

          int v172 = 0;
        }
      }

      else
      {
        int v172 = 1;
      }

      v67.ikey = 4410440;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v67)
        && (v196.st_mode & 0xF000) == 0x8000
        && v196.st_nlink >= 2u)
      {
        *(void *)(v25 + (v19 << 7) + 32) = v196.st_ino;
      }

      v68.ikey = 4410435;
      int v69 = AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v68);
      mode_t st_mode = v196.st_mode;
      if (v69 && (v196.st_mode & 0xF000) == 0x8000)
      {
        if (!fsctl(v199, 0x40104A0EuLL, &v197, 0) && (void)v197 == 2LL) {
          *(void *)(v25 + (v19 << 7) + 40) = *((void *)&v197 + 1);
        }
        mode_t st_mode = v196.st_mode;
      }

      uint64_t v176 = (uint64_t)v15;
      if ((st_mode & 0xF000) == 0x8000)
      {
        v71.ikey = 4410451;
        if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v71))
        {
          uint64_t v72 = v25 + (v19 << 7);
          *(void *)(v72 + 48) = 0LL;
          value = (uint8_t *)(v72 + 56);
          memset_s((void *)(v72 + 56), 0x40uLL, 0, 0x40uLL);
          AAHashFunction hash_function = 0;
          v73.ikey = 3491923;
          if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v73)) {
            goto LABEL_92;
          }
          v74.ikey = 3491923;
          uint32_t KeyIndex = AAHeaderGetKeyIndex(v5, v74);
          if ((KeyIndex & 0x80000000) != 0) {
            goto LABEL_92;
          }
          unsigned int FieldHash = AAHeaderGetFieldHash(v5, KeyIndex, 0x40uLL, &hash_function, value);
          int v77 = FieldHash <= 1 ? 1 : FieldHash;
          if (v77 <= 0)
          {
LABEL_92:
            if ((v78.ikey = 3360851, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v78))
              || (v79.ikey = 3360851, uint32_t v80 = AAHeaderGetKeyIndex(v5, v79), (v80 & 0x80000000) != 0)
              || ((unsigned int v81 = AAHeaderGetFieldHash(v5, v80, 0x40uLL, &hash_function, value), v81 <= 1)
                ? (int v82 = 1)
                : (int v82 = v81),
                  v82 <= 0))
            {
              if ((v83.ikey = 3295315, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v83))
                || (v84.ikey = 3295315, uint32_t v85 = AAHeaderGetKeyIndex(v5, v84), (v85 & 0x80000000) != 0)
                || ((unsigned int v86 = AAHeaderGetFieldHash(v5, v85, 0x40uLL, &hash_function, value), v86 <= 1)
                  ? (int v87 = 1)
                  : (int v87 = v86),
                    v87 <= 0))
              {
                if ((v88.ikey = 3229779, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v88))
                  || (v89.ikey = 3229779, uint32_t v90 = AAHeaderGetKeyIndex(v5, v89), (v90 & 0x80000000) != 0)
                  || ((unsigned int v91 = AAHeaderGetFieldHash(v5, v90, 0x40uLL, &hash_function, value), v91 <= 1)
                    ? (int v92 = 1)
                    : (int v92 = v91),
                      v92 <= 0))
                {
                  __int128 v197 = 0uLL;
                  int v198 = 0;
                  if ((getFileSHA1Digest(v199, (uint64_t)&v197) & 0x80000000) != 0)
                  {
                    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"appendPathListWorkerProc",  284,  14,  0,  "hashing file: %s",  v93,  v94,  (char)v199);
                    unsigned int v23 = 0;
                    int v6 = 0;
                    int v27 = 1;
LABEL_261:
                    compression_algorithm v15 = (void **)v176;
                    goto LABEL_15;
                  }

                  __int128 v95 = v197;
                  *((_DWORD *)value + 4) = v198;
                  *(_OWORD *)value = v95;
                }
              }
            }
          }
        }
      }

      size_t v96 = AAHeaderGetEncodedSize(v5);
      if ((__src & 1) == 0) {
        v96 += AAEntryXATBlobGetEncodedSize(xat);
      }
      if ((v173 & 1) == 0) {
        v96 += AAEntryACLBlobGetEncodedSize(v12);
      }
      if ((v177 & 1) == 0) {
        v96 += AAEntryYECBlobGetEncodedSize(v176);
      }
      uint64_t v97 = size[0];
      if (v172) {
        uint64_t v97 = 0LL;
      }
      uint64_t v98 = v97 + v96;
      *(void *)uint64_t v26 = *v188;
      uint64_t v99 = v25 + (v19 << 7);
      *(void *)(v99 + 8) = v98;
      *(void *)(v99 + 16) = AAHeaderGetEncodedSize(v5);
      unint64_t v100 = *v188 + v98;
      compression_algorithm v15 = (void **)v176;
      if ((v100 & 0x8000000000000000LL) != 0LL) {
        goto LABEL_152;
      }
      unint64_t v101 = *v186;
      if (*v186 < v100)
      {
        do
        {
          while (!v101)
          {
            unint64_t v101 = 0x4000LL;
            size_t v103 = 0x4000LL;
            if (v100 <= 0x4000) {
              goto LABEL_131;
            }
          }

          unint64_t v102 = v101 >> 1;
          if ((v101 & (v101 >> 1)) != 0) {
            unint64_t v102 = v101 & (v101 >> 1);
          }
          v101 += v102;
        }

        while (v101 < v100);
        size_t v103 = v101;
        if (v101 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_151;
        }

LABEL_131:
        valuea = (uint8_t *)*v187;
        __int16 v104 = realloc(*v187, v103);
        if (v104)
        {
          *v187 = v104;
          size_t *v186 = v103;
          compression_algorithm v15 = (void **)v176;
          goto LABEL_133;
        }

        free(valuea);
LABEL_151:
        size_t *v188 = 0LL;
        v188[1] = 0LL;
        v188[2] = 0LL;
        compression_algorithm v15 = (void **)v176;
LABEL_152:
        __int16 v43 = 302;
        uint64_t v44 = "reallocating block blob";
        goto LABEL_39;
      }

LABEL_133:
      EncodedData = AAHeaderGetEncodedData(v5);
      size_t v106 = AAHeaderGetEncodedSize(v5);
      size_t v107 = *v188;
      unint64_t v108 = *v188 + v106;
      if (__CFADD__(*v188, v106)) {
        goto LABEL_135;
      }
      int v109 = v187;
      if ((v108 & 0x8000000000000000LL) == 0)
      {
        size_t v110 = v106;
        unint64_t v111 = *v186;
        if (*v186 < v108)
        {
          do
          {
            while (!v111)
            {
              unint64_t v111 = 0x4000LL;
              size_t v113 = 0x4000LL;
              if (v108 <= 0x4000) {
                goto LABEL_155;
              }
            }

            unint64_t v112 = v111 >> 1;
            if ((v111 & (v111 >> 1)) != 0) {
              unint64_t v112 = v111 & (v111 >> 1);
            }
            v111 += v112;
          }

          while (v111 < v108);
          size_t v113 = v111;
          if (v111 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_252;
          }

    if (*(_DWORD *)a1)
    {
      memset(&v207[8], 0, 252);
      memset(v206, 0, 260);
      *(_DWORD *)&v207[7] = 1262834527;
      *(void *)v207 = 0x5F41454100000007LL;
      memset_s(&v207[11], 0xF9uLL, 0, 0xF9uLL);
      v105 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _BYTE *, _OWORD *))(a1 + 144);
      if (v105 && *v117)
      {
        size_t v106 = v105(v130, *(unsigned int *)(a1 + 72), v117, v207, v206);
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
        if ((v106 & 0x80000000) == 0)
        {
          if (*(void *)(a1 + 216))
          {
            memset(v206, 0, 260);
            v205 = 0;
            v204 = 0u;
            v203 = 0u;
            v202 = 0u;
            uint64_t v201 = 0u;
            v200 = 0u;
            v199 = 0u;
            int v198 = 0u;
            __int128 v197 = 0u;
            stat v196 = 0u;
            v195 = 0u;
            v194 = 0u;
            v193 = 0u;
            v192 = 0u;
            v191 = 0u;
            v190 = 0u;
            uint64_t v189 = 0u;
            v188 = 0;
            v187 = 0u;
            v186 = 0u;
            v185 = 0u;
            v184 = 0u;
            v183 = 0u;
            v182 = 0u;
            v181 = 0u;
            v180 = 0u;
            v179 = 0u;
            v178 = 0u;
            char v177 = 0u;
            uint64_t v176 = 0u;
            v175 = 0u;
            v174 = 0u;
            char v173 = 0u;
            *(_OWORD *)int v172 = 0u;
            if (LODWORD(v149[0]) == *(_DWORD *)(a1 + 112) && LODWORD(v130[0]) == *(_DWORD *)(a1 + 72))
            {
              *(void *)((char *)&v189 + 4) = 0x324B45535F414541LL;
              LODWORD(v189) = 8;
              memset_s((void *)((unint64_t)&v189 | 0xC), 0xF8uLL, 0, 0xF8uLL);
              memset(v207, 0, sizeof(v207));
              size_t v107 = *(uint64_t (**)(_OWORD *, void, _OWORD *, __int128 *, _BYTE *))(a1 + 144);
              if (v107)
              {
                if (LODWORD(v130[0]))
                {
                  uint64_t result = v107(v206, *(unsigned int *)(a1 + 76), v130, &v189, v207);
                  if ((result & 0x80000000) == 0)
                  {
                    unint64_t v108 = LODWORD(v149[0]);
                    if (LODWORD(v149[0]) >= 0x101) {
                      goto LABEL_162;
                    }
                    __memcpy_chk();
                    LODWORD(v132[0]) = v108;
                    memset_s((char *)v132 + v108 + 4, 256 - v108, 0, 256 - v108);
                    uint64_t result = (*(uint64_t (**)(char *, void, size_t *, _OWORD *, void, void))(a1 + 216))( (char *)v132 + 4,  LODWORD(v149[0]),  v172,  v206,  0LL,  0LL);
                    if ((result & 0x80000000) == 0)
                    {
                      int v109 = LODWORD(v132[0]) + (unint64_t)LODWORD(v172[0]);
                      if (v109 >= 0x101) {
                        goto LABEL_162;
                      }
                      memcpy((char *)v132 + LODWORD(v132[0]) + 4, (char *)v172 + 4, LODWORD(v172[0]));
                      LODWORD(v132[0]) = v109;
                      memset_s((char *)v132 + v109 + 4, 256 - v109, 0, 256 - v109);
                      size_t v110 = v132[0];
                      unint64_t v111 = *(_DWORD *)(a1 + 116);
                      memset_s(v206, 0x104uLL, 0, 0x104uLL);
                      memset_s(v172, 0x104uLL, 0, 0x104uLL);
                      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
                      if (v110 != v111) {
                        goto LABEL_161;
                      }
                      goto LABEL_152;
                    }
                  }
                }
              }
            }

            memset_s(v206, 0x104uLL, 0, 0x104uLL);
            memset_s(v172, 0x104uLL, 0, 0x104uLL);
            memset_s(&v189, 0x104uLL, 0, 0x104uLL);
          }

  unsigned int v81 = (uint64_t (**)(void))a1[607];
  if (!v81)
  {
    AAFieldKey v73 = a1 + 604;
    goto LABEL_138;
  }

  AAFieldKey v73 = a1 + 604;
  if ((AAByteStreamCloseWithState(v81) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"closeWithStateProc",  775,  133,  0,  "write state",  v82,  v83,  v84);
    a1[607] = 0LL;
    uint64_t v4 = 0xFFFFFFFFLL;
LABEL_122:
    uint64_t v75 = a1 + 598;
    AAFieldKey v74 = a1 + 601;
    goto LABEL_123;
  }

  a1[607] = 0LL;
LABEL_138:
  uint64_t v75 = a1 + 598;
  AAFieldKey v74 = a1 + 601;
  uint64_t v4 = 0LL;
  if (a3) {
    *a3 = -1LL;
  }
LABEL_123:
  free(v89);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy((AAHeader)a1[596]);
  free((void *)a1[600]);
  memset_s(v75, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[603]);
  memset_s(v74, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[606]);
  memset_s(v73, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[611]);
  memset_s(a1 + 609, 0x18uLL, 0, 0x18uLL);
  AAByteStreamClose((AAByteStream)a1[608]);
  AAByteStreamClose((AAByteStream)a1[607]);
  free(a1);
  return v4;
}

LABEL_155:
          valueb = (uint8_t *)v106;
          uint64_t v163 = *v187;
          uint64_t v114 = realloc(*v187, v113);
          if (v114)
          {
            *v187 = v114;
            size_t *v186 = v113;
            compression_algorithm v15 = (void **)v176;
            int v109 = v187;
            size_t v110 = (size_t)valueb;
            goto LABEL_157;
          }

          free(v163);
LABEL_252:
          size_t v107 = 0LL;
          size_t *v188 = 0LL;
          v188[1] = 0LL;
          v188[2] = 0LL;
          compression_algorithm v15 = (void **)v176;
LABEL_135:
          int v109 = v187;
          goto LABEL_163;
        }

      __strlcat_chk();
      size_t v54 = a1[2112];
      if ((v54 & 4) == 0)
      {
LABEL_110:
        if ((v54 & 0x40) == 0) {
          goto LABEL_111;
        }
        goto LABEL_157;
      }

LABEL_157:
        uint64_t v115 = (char *)*v109;
        if (EncodedData)
        {
          valuee = (uint8_t *)v110;
          memcpy(&v115[*v188], EncodedData, v110);
          size_t v110 = (size_t)valuee;
          int v109 = v187;
          v116 = v188;
        }

        else
        {
          v116 = v188;
          if (v115)
          {
            size_t v117 = v110;
            memset_s(&v115[*v188], v110, 0, v110);
            size_t v110 = v117;
            int v109 = v187;
            v116 = v188;
          }
        }

        size_t v107 = *v116 + v110;
        size_t *v116 = v107;
      }

      __strlcat_chk();
      size_t v54 = a1[2112];
      if ((v54 & 0x10) == 0)
      {
LABEL_112:
        if ((v54 & 0x20) == 0) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }

LABEL_163:
      if ((__src & 1) != 0) {
        goto LABEL_185;
      }
      __srca = AAEntryXATBlobGetEncodedData(xat);
      size_t v118 = AAEntryXATBlobGetEncodedSize(xat);
      size_t v107 = *v188;
      unint64_t v119 = *v188 + v118;
      if (__CFADD__(*v188, v118)) {
        goto LABEL_166;
      }
      int v109 = v187;
      if ((v119 & 0x8000000000000000LL) == 0)
      {
        size_t v120 = v118;
        unint64_t v121 = *v186;
        if (*v186 < v119)
        {
          do
          {
            while (!v121)
            {
              unint64_t v121 = 0x4000LL;
              size_t v123 = 0x4000LL;
              if (v119 <= 0x4000) {
                goto LABEL_178;
              }
            }

            unint64_t v122 = v121 >> 1;
            if ((v121 & (v121 >> 1)) != 0) {
              unint64_t v122 = v121 & (v121 >> 1);
            }
            v121 += v122;
          }

          while (v121 < v119);
          size_t v123 = v121;
          if (v121 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_254;
          }

LABEL_178:
          uint64_t v164 = *v187;
          valueCC_SHA256_CTX c = (uint8_t *)v118;
          __int16 v124 = realloc(*v187, v123);
          if (v124)
          {
            *v187 = v124;
            size_t *v186 = v123;
            compression_algorithm v15 = (void **)v176;
            int v109 = v187;
            size_t v120 = (size_t)valuec;
            goto LABEL_180;
          }

          free(v164);
LABEL_254:
          size_t v107 = 0LL;
          size_t *v188 = 0LL;
          v188[1] = 0LL;
          v188[2] = 0LL;
          compression_algorithm v15 = (void **)v176;
LABEL_166:
          int v109 = v187;
          goto LABEL_185;
        }

            v257 += v159;
            v175 = 1LL;
            uint64_t v176 = v270;
LABEL_179:
            size_t v149 = v270 + v175;
            if (v159)
            {
              v174 = (uint64_t *)&v294[v259 + 48];
              do
              {
                void *v174 = v176;
                v174 += 16;
                --v159;
              }

              while (v159);
            }

            size_t v150 = v163;
            goto LABEL_183;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  525,  14,  0,  "AAPathListNodeGetPath",  v166,  v167,  (char)v238);
          uint64_t v47 = 0;
          size_t v150 = v165;
        }

LABEL_180:
        unint64_t v125 = (char *)*v109;
        if (__srca)
        {
          valuef = (uint8_t *)v120;
          memcpy(&v125[*v188], __srca, v120);
          size_t v120 = (size_t)valuef;
          int v109 = v187;
          uint64_t v126 = v188;
        }

        else
        {
          uint64_t v126 = v188;
          if (v125)
          {
            size_t v127 = v120;
            memset_s(&v125[*v188], v120, 0, v120);
            size_t v120 = v127;
            int v109 = v187;
            uint64_t v126 = v188;
          }
        }

        size_t v107 = *v126 + v120;
        *uint64_t v126 = v107;
      }

    if (v90 != v80)
    {
      uint64_t v14 = "write DAT file";
      compression_algorithm v15 = 976;
      goto LABEL_225;
    }

    v76 = v80 + v111;
    uint64_t v75 = v118;
    break;
  }

  if (v76 != v75)
  {
    uint64_t v14 = "truncated state";
    compression_algorithm v15 = 979;
    goto LABEL_225;
  }

LABEL_185:
      if ((v173 & 1) != 0) {
        goto LABEL_207;
      }
      size_t v128 = AAEntryACLBlobGetEncodedData(v12);
      size_t v129 = AAEntryACLBlobGetEncodedSize(v12);
      size_t v107 = *v188;
      unint64_t v130 = *v188 + v129;
      if (__CFADD__(*v188, v129)) {
        goto LABEL_188;
      }
      int v109 = v187;
      if ((v130 & 0x8000000000000000LL) == 0)
      {
        size_t v131 = v129;
        unint64_t v132 = *v186;
        if (*v186 < v130)
        {
          do
          {
            while (!v132)
            {
              unint64_t v132 = 0x4000LL;
              size_t v134 = 0x4000LL;
              if (v130 <= 0x4000) {
                goto LABEL_200;
              }
            }

            unint64_t v133 = v132 >> 1;
            if ((v132 & (v132 >> 1)) != 0) {
              unint64_t v133 = v132 & (v132 >> 1);
            }
            v132 += v133;
          }

          while (v132 < v130);
          size_t v134 = v132;
          if (v132 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_256;
          }

      getRealTime();
    }

    goto LABEL_186;
  }

  if (!v63)
  {
LABEL_186:
    if ((int)v177 >= 2)
    {
      free(*(void **)(v16 + 56));
      *(void *)(v16 + 56) = 0LL;
    }

    return v16;
  }

  uint64_t v94 = -13;
  do
  {
    __int128 v95 = v94 + 33;
    size_t v96 = 1 << (v94++ + 33 + v178);
  }

  while (v95 < SHIDWORD(v179) && v96 < *(_DWORD *)(v16 + 32));
  *(_DWORD *)(v16 + 40) = v94 + 32;
  *(_DWORD *)(v16 + 44) = -v94;
  uint64_t v97 = v179;
  getRealTime();
  uint64_t v98 = *(unsigned int *)(v16 + 8);
  v180 = 0LL;
  v181 = 0LL;
  uint64_t v99 = 1;
  unint64_t v101 = *(_DWORD *)(v16 + 32);
  unint64_t v100 = *(_DWORD *)(v16 + 36);
  if (v101 >= v100) {
    unint64_t v101 = *(_DWORD *)(v16 + 36);
  }
  if (v101 < 2 * v97)
  {
    unint64_t v102 = 0LL;
    size_t v103 = 0LL;
    goto LABEL_184;
  }

  __int16 v104 = 0LL;
  v105 = 6LL * (1 << *(_DWORD *)(v16 + 40));
  uint64_t v176 = ((v98 + v100 - 1) / v98 + 0xFFFF) & 0xFFFF0000;
  size_t v106 = 1;
  do
  {
    size_t v107 = calloc(1uLL, v105);
    *(&v180 + v104) = v107;
    if (!v107)
    {
      size_t v123 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"initBestMatchFromHashes",  852,  92,  *v123,  "malloc",  v124,  v125,  v167);
      unint64_t v102 = 0LL;
      size_t v103 = 0LL;
LABEL_183:
      uint64_t v99 = 0;
      goto LABEL_184;
    }

    unint64_t v108 = ((_DWORD)v98 != 1) & v106;
    __int16 v104 = 1LL;
    size_t v106 = 0;
  }

  while ((v108 & 1) != 0);
  unint64_t v102 = calloc(v98, 0x28uLL);
  int v109 = (uint64_t *)malloc(8 * v98);
  size_t v103 = v109;
  if (!v102 || !v109)
  {
    uint64_t v126 = *__error();
    unint64_t v121 = "malloc";
    unint64_t v122 = 862;
LABEL_182:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"initBestMatchFromHashes",  v122,  92,  v126,  v121,  v115,  v116,  v167);
    goto LABEL_183;
  }

  if (!(_DWORD)v98) {
    goto LABEL_129;
  }
  size_t v117 = v109;
  size_t v118 = v102;
  unint64_t v119 = v98;
  do
  {
    *v117++ = (uint64_t)v118;
    v118[5] = v97;
    *(void *)size_t v118 = v16;
    v118 += 10;
    --v119;
  }

  while (v119);
  if ((_DWORD)v98 == 1)
  {
    size_t v120 = 0LL;
  }

  else
  {
LABEL_129:
    size_t v120 = ThreadPoolCreate(v98, (uint64_t)v109, (uint64_t)initBestMatchThreadProc);
    if (!v120)
    {
      unint64_t v121 = "ThreadPoolCreate";
      unint64_t v122 = 874;
      goto LABEL_181;
    }
  }

  size_t v127 = *(_DWORD *)(v16 + 32);
  if (v127)
  {
    v171 = v103;
    v168 = v102;
    size_t v128 = 0;
    size_t v129 = 0;
    while (1)
    {
      v169 = v128;
      unint64_t v130 = *(&v180 + v128);
      uint32_t v80 = v127 >= v97;
      size_t v131 = v127 - v97;
      if (!v80) {
        size_t v131 = 0;
      }
      char v173 = v129 + v96;
      if (v129 + v96 < v131) {
        size_t v131 = v129 + v96;
      }
      unint64_t v132 = v129 + 4;
      if (v129 + 4 < v131)
      {
        unint64_t v133 = *(void *)(v16 + 16);
        size_t v134 = v129;
        do
        {
          uint64_t v135 = v132;
          if (v97)
          {
            v136 = 0;
            uint64_t v137 = (int *)(v133 + v134);
            size_t v138 = v137;
            uint64_t v139 = v97;
            do
            {
              uint64_t v140 = *v138++;
              v136 = -1640531535 * (v140 + v136) - 1640531535;
              v139 -= 4;
            }

            while (v139);
            unint64_t v141 = 0;
            size_t v142 = *(_DWORD *)(v16 + 44);
            unint64_t v143 = v136 >> v142;
            unint64_t v144 = (int *)((char *)v137 + 1);
            size_t v145 = v97;
            do
            {
              uint64_t v146 = *v144++;
              unint64_t v141 = -1640531535 * (v146 + v141) - 1640531535;
              v145 -= 4;
            }

            while (v145);
            unint64_t v147 = 0;
            v148 = v141 >> v142;
            size_t v149 = (int *)((char *)v137 + 2);
            size_t v150 = v97;
            do
            {
              BOOL v151 = *v149++;
              unint64_t v147 = -1640531535 * (v151 + v147) - 1640531535;
              v150 -= 4;
            }

            while (v150);
            LODWORD(v110) = 0;
            unint64_t v152 = HIWORD(v136) ^ v136;
            unint64_t v153 = v147 >> v142;
            unint64_t v154 = (unsigned int *)((char *)v137 + 3);
            unint64_t v155 = v97;
            do
            {
              size_t v156 = *v154++;
              uint64_t v115 = v156;
              size_t v110 = -1640531535 * (v156 + v110) - 1640531535;
              v155 -= 4;
            }

            while (v155);
            v157 = HIWORD(v141) ^ v141;
            v158 = HIWORD(v147) ^ v147;
            unint64_t v112 = (_DWORD *)((char *)v130 + 6 * v143);
            size_t v113 = (_DWORD *)((char *)v130 + 6 * v148);
            unint64_t v111 = (_DWORD *)((char *)v130 + 6 * v153);
          }

          else
          {
            unint64_t v153 = 0;
            v158 = 0;
            unint64_t v143 = 0;
            unint64_t v152 = 0;
            v157 = 0;
            v148 = 0;
            size_t v110 = 0LL;
            size_t v142 = *(_DWORD *)(v16 + 44);
            unint64_t v111 = v130;
            unint64_t v112 = v130;
            size_t v113 = v130;
          }

          uint64_t v114 = v110 ^ WORD1(v110);
          v159 = (char *)v130 + 6 * (v110 >> v142);
          *unint64_t v112 = v134;
          *((_WORD *)v130 + 3 * v143 + 2) = v152;
          *size_t v113 = v134 + 1;
          *((_WORD *)v130 + 3 * v148 + 2) = v157;
          *unint64_t v111 = v134 + 2;
          *((_WORD *)v130 + 3 * v153 + 2) = v158;
          *(_DWORD *)v159 = v134 + 3;
          *((_WORD *)v159 + 2) = v110 ^ WORD1(v110);
          unint64_t v132 = v135 + 4;
          size_t v134 = v135;
        }

        while (v135 + 4 < v131);
      }

      if (v120 && (ThreadPoolSync(v120) & 0x80000000) != 0) {
        break;
      }
      if ((_DWORD)v98)
      {
        signed int v160 = 0;
        uint64_t v161 = v98;
        while (1)
        {
          unint64_t v162 = v120
          if (!v162) {
            break;
          }
          *(void *)(v162 + 32) = v130;
          *(_DWORD *)(v162 + 24) = v173 >= *(_DWORD *)(v16 + 32);
          *(_DWORD *)(v162 + 8) = v129;
          *(_DWORD *)(v162 + 12) = v160 * v176;
          uint64_t v163 = v160 * v176 + v176;
          *(_DWORD *)(v162 + 16) = v163;
          uint64_t v164 = *(_DWORD *)(v16 + 36);
          if (v160 * v176 > v164) {
            *(_DWORD *)(v162 + 12) = v164;
          }
          if (v163 > v164) {
            *(_DWORD *)(v162 + 16) = v164;
          }
          if (v120)
          {
            if ((ThreadPoolRunWorker( (uint64_t)v120,  v162,  (uint64_t)v111,  (uint64_t)v112,  (uint64_t)v113,  v114,  v115,  v116) & 0x80000000) != 0)
            {
              size_t v165 = "ThreadPoolRunWorker";
              size_t v166 = 920;
              goto LABEL_178;
            }
          }

          else
          {
            initBestMatchThreadProc(v162, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116);
          }

          ++v160;
          if (!--v161) {
            goto LABEL_171;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"initBestMatchFromHashes",  910,  92,  0,  "ThreadPoolGetWorker",  v115,  v116,  v167);
        uint64_t v99 = 0;
        goto LABEL_175;
      }

        if (v128 != v125)
        {
          v235 = "write header";
          v236 = 1448;
          goto LABEL_352;
        }

        size_t v131 = value;
        unint64_t v19 = v274;
        uint64_t v10 = header;
        if (value != 70 || !size) {
          goto LABEL_215;
        }
        *(void *)&offset.st_dev = 0LL;
        v279 = 0LL;
        EntryHeader = stateLoadEntryHeader(a1, v276, v28);
        uint64_t v135 = EntryHeader;
        if (!EntryHeader)
        {
          v237 = "loading entry header";
          v238 = 767;
          goto LABEL_350;
        }

        v136.ikey = 5521732;
        uint32_t KeyIndex = AAHeaderGetKeyIndex(EntryHeader, v136);
        if ((KeyIndex & 0x80000000) != 0
          || ((FieldBlob = AAHeaderGetFieldBlob(v135, KeyIndex, &v279, (uint64_t *)&offset), FieldBlob <= 1)
            ? (uint64_t v139 = 1)
            : (uint64_t v139 = FieldBlob),
              v139 <= 0))
        {
          v237 = "blob not found";
          v238 = 768;
LABEL_350:
          v241 = 0;
LABEL_357:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateStreamEntryBlob",  v238,  27,  v241,  v237,  v133,  v134,  v248);
          bufb = 0LL;
LABEL_358:
          AAHeaderDestroy(v135);
          free(bufb);
          v233 = "write DAT";
          v234 = 1453;
          goto LABEL_359;
        }

        bufb = (char *)malloc(0x40000uLL);
        if (!bufb)
        {
          v241 = *__error();
          v237 = "malloc";
          v238 = 771;
          goto LABEL_357;
        }

        uint64_t v140 = *(void *)(*(void *)(a1 + 80) + 984 * v28 + 72 * v276 + 288);
        v252 = v135;
        unint64_t v141 = AAHeaderGetEncodedSize(v135);
        size_t v142 = v279;
        if (v279)
        {
          unint64_t v143 = v141 + v140 + *(void *)&offset.st_dev;
          while (1)
          {
            if (v142 >= 0x40000) {
              unint64_t v144 = 0x40000LL;
            }
            else {
              unint64_t v144 = v142;
            }
            size_t v145 = AAByteStreamPRead(*(AAByteStream *)(*(void *)(a1 + 8) + 8 * v276 + 24), bufb, v144, v143);
            unint64_t v19 = v274;
            if (v145 < 0)
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateStreamEntryBlob",  779,  27,  0,  "read blob from archive",  v146,  v147,  v248);
              goto LABEL_333;
            }

            v148 = v145;
            if (!v145) {
              goto LABEL_212;
            }
            if (v127[3])
            {
              size_t v149 = 0LL;
              size_t v150 = bufb;
              BOOL v151 = v145;
              while (1)
              {
                unint64_t v152 = ((uint64_t (*)(void, char *, ssize_t))v127[3])(*v127, v150, v151);
                if (v152 < 1) {
                  break;
                }
                v150 += v152;
                v149 += v152;
                v151 -= v152;
                if (!v151) {
                  goto LABEL_209;
                }
              }

              size_t v149 = v152;
            }

            else
            {
              size_t v149 = -1LL;
            }

LABEL_200:
          __srcb = (void *)v129;
          valued = (uint8_t *)*v187;
          uint64_t v135 = realloc(*v187, v134);
          if (v135)
          {
            *v187 = v135;
            size_t *v186 = v134;
            int v109 = v187;
            size_t v131 = (size_t)__srcb;
            compression_algorithm v15 = (void **)v176;
            goto LABEL_202;
          }

          free(valued);
LABEL_256:
          size_t v107 = 0LL;
          size_t *v188 = 0LL;
          v188[1] = 0LL;
          v188[2] = 0LL;
          compression_algorithm v15 = (void **)v176;
LABEL_188:
          int v109 = v187;
          goto LABEL_207;
        }

LABEL_202:
        v136 = (char *)*v109;
        if (v128)
        {
          __srce = (void *)v131;
          memcpy(&v136[*v188], v128, v131);
          size_t v131 = (size_t)__srce;
          int v109 = v187;
          uint64_t v137 = v188;
        }

        else
        {
          uint64_t v137 = v188;
          if (v136)
          {
            size_t v138 = v131;
            memset_s(&v136[*v188], v131, 0, v131);
            size_t v131 = v138;
            int v109 = v187;
            uint64_t v137 = v188;
          }
        }

        size_t v107 = *v137 + v131;
        *uint64_t v137 = v107;
      }

LABEL_207:
      if ((v177 & 1) != 0) {
        goto LABEL_229;
      }
      uint64_t v139 = (const void *)AAEntryYECBlobGetEncodedData((uint64_t)v15);
      uint64_t v140 = AAEntryYECBlobGetEncodedSize((uint64_t)v15);
      size_t v107 = *v188;
      unint64_t v141 = *v188 + v140;
      if (__CFADD__(*v188, v140)) {
        goto LABEL_210;
      }
      int v109 = v187;
      if ((v141 & 0x8000000000000000LL) == 0)
      {
        size_t v142 = v140;
        unint64_t v143 = *v186;
        if (*v186 >= v141)
        {
LABEL_224:
          unint64_t v147 = (char *)*v109;
          if (v139)
          {
            __srcf = (void *)v142;
            memcpy(&v147[*v188], v139, v142);
            size_t v142 = (size_t)__srcf;
            int v109 = v187;
            v148 = v188;
          }

          else
          {
            v148 = v188;
            if (v147)
            {
              size_t v149 = v142;
              memset_s(&v147[*v188], v142, 0, v142);
              size_t v142 = v149;
              int v109 = v187;
              v148 = v188;
            }
          }

          size_t v107 = *v148 + v142;
          size_t *v148 = v107;
          goto LABEL_229;
        }

        do
        {
          while (!v143)
          {
            unint64_t v143 = 0x4000LL;
            size_t v145 = 0x4000LL;
            if (v141 <= 0x4000) {
              goto LABEL_222;
            }
          }

          unint64_t v144 = v143 >> 1;
          if ((v143 & (v143 >> 1)) != 0) {
            unint64_t v144 = v143 & (v143 >> 1);
          }
          v143 += v144;
        }

        while (v143 < v141);
        size_t v145 = v143;
        if (v143 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_258;
        }

LABEL_222:
        __srcCC_SHA256_CTX c = (void *)v140;
        v174 = *v187;
        uint64_t v146 = realloc(*v187, v145);
        if (v146)
        {
          *v187 = v146;
          size_t *v186 = v145;
          int v109 = v187;
          size_t v142 = (size_t)__srcc;
          compression_algorithm v15 = (void **)v176;
          goto LABEL_224;
        }

        free(v174);
LABEL_258:
        size_t v107 = 0LL;
        size_t *v188 = 0LL;
        v188[1] = 0LL;
        v188[2] = 0LL;
        compression_algorithm v15 = (void **)v176;
LABEL_210:
        int v109 = v187;
      }

    v241 = v186;
    v199 = &v187[128 * *(void *)v268];
    v200 = *((void *)v199 + 4);
    if (v200 != -1LL)
    {
      v201.ikey = 4410440;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v201, v200) < 0)
      {
        v227 = "add HLC field";
        v228 = 605;
        goto LABEL_312;
      }
    }

    v202 = *((void *)v199 + 5);
    if (v202 != -1LL)
    {
      v203.ikey = 4410435;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v203, v202) < 0)
      {
        v227 = "add CLC field";
        v228 = 606;
        goto LABEL_312;
      }
    }

    v204 = *(void *)&v187[128 * *(void *)v268 + 48];
    if (v204 != -1LL)
    {
      v205.ikey = 4410451;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v205, v204) < 0)
      {
        v227 = "add SLC field";
        v228 = 607;
        goto LABEL_312;
      }
    }

    v206 = (uint64_t (*)(void, AAHeader_impl *))v252[3];
    if (!v206 || (v206(*v252, v43) & 0x80000000) != 0)
    {
      v227 = "encoding header";
      v228 = 610;
      goto LABEL_312;
    }

    FieldCount = AAHeaderGetFieldCount(v43);
    if (FieldCount) {
      break;
    }
LABEL_265:
    if (v256)
    {
      v227 = "blob byte count mismatch";
      v228 = 681;
      goto LABEL_312;
    }

    v185 = (v241 + 1);
    v186 = v241 + 1;
    if (v283 <= v185) {
      goto LABEL_276;
    }
  }

  v260 = 0LL;
  v247 = v244 + v246;
  v207 = &v187[128 * *(void *)v268];
  v208 = 0;
  v240 = (uint64_t *)(v207 + 24);
  while (AAHeaderGetFieldType(v43, v208) != 5)
  {
LABEL_264:
    if (++v208 == FieldCount) {
      goto LABEL_265;
    }
  }

  size = 0LL;
  offset = 0LL;
  FieldKey = AAHeaderGetFieldKey(v43, v208);
  v210 = v208;
  v211 = FieldKey;
  v272 = FieldKey;
  v243 = v210;
  if (AAHeaderGetFieldBlob(v43, v210, &size, &offset) < 0)
  {
    v227 = "get blob location";
    v228 = 622;
    goto LABEL_312;
  }

  if (v260 != offset)
  {
    v227 = "blob segment mismatch";
    v228 = 623;
    goto LABEL_312;
  }

  v212 = v211.ikey & 0xFFFFFF;
  if ((v211.ikey & 0xFFFFFF) == 0x4C4341) {
    v213 = v266 + 1;
  }
  else {
    v213 = v266;
  }
  v266 = v213;
  if (v212 == 5521752) {
    v214 = v262 + 1;
  }
  else {
    v214 = v262;
  }
  v262 = v214;
  v215 = v264;
  if (v212 == 4408665) {
    v215 = v264 + 1;
  }
  v264 = v215;
  if (v212 != 5521732)
  {
    if (size > v256)
    {
      v238 = &v272;
      v227 = "Blob segment out of range, key=%s";
      v228 = 667;
      goto LABEL_312;
    }

    v225 = (uint64_t (*)(void, void, char *))v252[4];
    if (!v225 || (v225(*v252, v211.ikey, &v293[v247]) & 0x80000000) != 0)
    {
      v227 = "sending blob data";
      v228 = 668;
      goto LABEL_312;
    }

    v224 = size;
    v247 += size;
    v256 -= size;
    goto LABEL_263;
  }

  v239 = size;
  if (AAPathListNodeGetPath(v278, *v240, 0x400uLL, v276, 0LL) < 0)
  {
    v227 = "getting entry path";
    v228 = 638;
    goto LABEL_312;
  }

  if ((concatPath(path, 0x800uLL, v280, v276) & 0x80000000) != 0)
  {
    v227 = "getting entry full path";
    v228 = 639;
    goto LABEL_312;
  }

  v269 = open(path, 0);
  if (v269 < 0)
  {
    v226 = *__error();
    v238 = (AAFieldKey *)path;
    v227 = "%s";
    v228 = 641;
    goto LABEL_313;
  }

  v216 = size;
  if (!size)
  {
LABEL_257:
    close(v269);
    if (!v47) {
      goto LABEL_21;
    }
    v242 += v239;
    uint64_t v47 = 1;
    v224 = size;
LABEL_263:
    v260 += v224;
    v208 = v243;
    goto LABEL_264;
  }

  v217 = 0LL;
  ikey = v211.ikey;
  while (1)
  {
    if (v217 + 0x40000 <= v216) {
      v218 = 0x40000LL;
    }
    else {
      v218 = v216 - v217;
    }
    v219 = read(v269, v42, v218);
    if (v219 < 0)
    {
      v235 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  651,  14,  v235,  "read: %s",  v236,  v237,  (char)path);
      goto LABEL_297;
    }

    v222 = v219;
    if (!v219) {
      break;
    }
    v223 = (uint64_t (*)(void, uint64_t, void *, ssize_t))v252[4];
    if (!v223 || (v223(*v252, ikey, v42, v219) & 0x80000000) != 0)
    {
      v233 = "sending blob data";
      v234 = 653;
      goto LABEL_296;
    }

    v217 += v222;
    v216 = size;
    if (v217 >= size) {
      goto LABEL_257;
    }
  }

  v238 = (AAFieldKey *)path;
  v233 = "truncated: %s";
  v234 = 652;
LABEL_296:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  v234,  14,  0,  v233,  v220,  v221,  (char)v238);
LABEL_297:
  close(v269);
LABEL_21:
  uint64_t v47 = 0;
LABEL_22:
  if ((ThreadPoolDestroy(0LL) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  705,  14,  0,  "ThreadPoolDestroy",  v48,  v49,  (char)v238);
    uint64_t v47 = 0;
  }

  if (v286 && v285)
  {
    uint64_t v50 = 0LL;
    AAFieldKey v51 = 32LL;
    do
    {
      int v52 = &v286[v51 - 16];
      free(*(void **)&v286[v51]);
      memset_s(v52, 0x18uLL, 0, 0x18uLL);
      ++v50;
      v51 += 40LL;
    }

    while (v50 < v285);
  }

  free(v289);
  free(v288);
  free(v286);
  free(v294);
  free(v42);
  free(v46);
  free(v45);
  free(v44);
  AAHeaderDestroy(v43);
  free(v293);
  memset_s(&v291, 0x18uLL, 0, 0x18uLL);
  if (v47) {
    return 0;
  }
  else {
    return -1;
  }
}

LABEL_229:
      if ((v172 & 1) == 0)
      {
        size_t v150 = size[0];
        BOOL v151 = __CFADD__(v107, size[0]);
        unint64_t v152 = v107 + size[0];
        if (!v151 && (v152 & 0x8000000000000000LL) == 0)
        {
          unint64_t v153 = v195;
          unint64_t v154 = *v186;
          __srcd = (void *)size[0];
          if (*v186 < v152)
          {
            do
            {
              while (!v154)
              {
                unint64_t v154 = 0x4000LL;
                size_t v156 = 0x4000LL;
                if (v152 <= 0x4000) {
                  goto LABEL_243;
                }
              }

              unint64_t v155 = v154 >> 1;
              if ((v154 & (v154 >> 1)) != 0) {
                unint64_t v155 = v154 & (v154 >> 1);
              }
              v154 += v155;
            }

            while (v154 < v152);
            size_t v156 = v154;
            if (v154 >= 0x2000000001LL)
            {
              *__error() = 12;
              goto LABEL_260;
            }

      LODWORD(v97) = 0;
LABEL_230:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  v90,  133,  (int)v97,  v89,  v67,  v68,  (char)v98);
LABEL_231:
      uint64_t v28 = 0;
      goto LABEL_151;
    case 'R':
      if (*((_DWORD *)a1 + 264))
      {
        if (v11)
        {
          if (v12)
          {
            if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  417,  133,  0,  "invalid PAT: %s",  v58,  v59,  (_BYTE)a1 + 40);
              goto LABEL_32;
            }

            unlink(__s);
          }

LABEL_243:
            v178 = v195;
            v175 = *v109;
            v157 = v109;
            v158 = realloc(*v109, v156);
            if (v158)
            {
              void *v157 = v158;
              size_t *v186 = v156;
              compression_algorithm v15 = (void **)v176;
              unint64_t v153 = v178;
              int v109 = v157;
              size_t v150 = (size_t)__srcd;
              goto LABEL_245;
            }

            free(v175);
LABEL_260:
            int v27 = 0;
            unsigned int v23 = 0;
            size_t *v188 = 0LL;
            v188[1] = 0LL;
            v188[2] = 0LL;
            goto LABEL_261;
          }

LABEL_245:
          v159 = (char *)*v109;
          if (v153)
          {
            signed int v160 = v188;
            memcpy(&v159[*v188], v153, v150);
            goto LABEL_249;
          }

          signed int v160 = v188;
          if (v159)
          {
            memset_s(&v159[*v188], v150, 0, (rsize_t)__srcd);
LABEL_249:
            size_t v150 = (size_t)__srcd;
          }

          int v27 = 0;
          unsigned int v23 = 0;
          *v160 += v150;
          goto LABEL_15;
        }
      }

      int v27 = 0;
      unsigned int v23 = 0;
LABEL_15:
      *(_DWORD *)(v26 + 120) = v27;
      ++v19;
    }

    while (v19 < *v20);
  }

  AAHeaderDestroy(v5);
  AAEntryXATBlobDestroy(xat);
  AAEntryACLBlobDestroy(v12);
  AAEntryYECBlobDestroy(v15);
  free(v195);
  memset_s(size, 0x18uLL, 0, 0x18uLL);
  if (v6) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

int AAArchiveStreamWritePathList( AAArchiveStream s, AAPathList path_list, AAFieldKeySet key_set, const char *dir, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v8 = MEMORY[0x1895F8858](s, path_list, key_set, dir, msg_data, msg_proc, flags, *(void *)&n_threads);
  int DefaultNThreads = v9;
  unint64_t v12 = v11;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  size_t v18 = v17;
  unint64_t v20 = v19;
  uint64_t v22 = v21;
  unsigned int v23 = (void *)v8;
  uint64_t v295 = *MEMORY[0x1895F89C0];
  bzero(v280, 0x470uLL);
  double RealTime = getRealTime();
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  AAPathList v278 = v22;
  v279 = v20;
  unint64_t v284 = 1024LL;
  LODWORD(__count) = DefaultNThreads;
  unint64_t v277 = v12;
  uint64_t v281 = v16;
  uint64_t v282 = v14;
  if (!realpath_DARWIN_EXTSN(v18, v280))
  {
    int v28 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  375,  14,  v28,  "%s",  v29,  v30,  (char)v18);
LABEL_19:
    AAFieldKey v42 = 0LL;
    __int16 v43 = 0LL;
    uint64_t v44 = 0LL;
LABEL_20:
    int v45 = 0LL;
    uint64_t v46 = 0LL;
    goto LABEL_21;
  }

  uint64_t v25 = AAPathListNodeFirst(v22);
  if (v25 != -1LL)
  {
    for (uint64_t i = v25; i != -1LL; uint64_t i = AAPathListNodeNext(v22, i))
      ++v283;
  }

  size_t v285 = (v283 + v284 - 1) / v284;
  size_t v27 = v283 << 7;
  if (v283 << 7 >= 0x2000000001LL)
  {
    *__error() = 12;
    v294 = 0LL;
LABEL_17:
    int v37 = *__error();
    uint64_t v40 = "malloc";
    __int16 v41 = 381;
LABEL_18:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  v41,  14,  v37,  v40,  v38,  v39,  (char)v238);
    goto LABEL_19;
  }

  uint64_t v31 = (char *)malloc(v27);
  v294 = v31;
  if (!v31) {
    goto LABEL_17;
  }
  memset(v31, 255, v27);
  uint64_t v32 = AAPathListNodeFirst(v22);
  if (v32 != -1LL)
  {
    uint64_t v33 = v32;
    uint64_t v34 = 24LL;
    do
    {
      *(void *)&v294[v34] = v33;
      uint64_t v33 = AAPathListNodeNext(v22, v33);
      v34 += 128LL;
    }

    while (v33 != -1LL);
  }

  if (is_mul_ok(v285, 0x28uLL) && 40 * v285 < 0x2000000001LL)
  {
    uint64_t v36 = (char *)calloc(v285, 0x28uLL);
  }

  else
  {
    AAFieldKey v35 = __error();
    uint64_t v36 = 0LL;
    *AAFieldKey v35 = 12;
  }

  v286 = v36;
  v288 = (char *)calloc(__count, 0x10uLL);
  size_t v54 = calloc(__count, 8uLL);
  v289 = v54;
  if (!v286 || !v288 || (uint64_t v55 = (uint64_t)v54) == 0)
  {
    int v37 = *__error();
    uint64_t v40 = "malloc";
    __int16 v41 = 389;
    goto LABEL_18;
  }

  uint64_t v56 = __count;
  if ((_DWORD)__count)
  {
    uint64_t v57 = 0LL;
    do
    {
      AAFieldKey v58 = &v288[16 * v57];
      *(void *)AAFieldKey v58 = &v277;
      v289[v57++] = v58;
    }

    while (v57 != v56);
    uint64_t v55 = (uint64_t)v289;
  }

  uint64_t v44 = ThreadPoolCreate(v56, v55, (uint64_t)appendPathListWorkerProc);
  if (!v44)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  398,  14,  0,  "ThreadPoolCreate",  v64,  v65,  (char)v238);
    AAFieldKey v42 = 0LL;
    __int16 v43 = 0LL;
    goto LABEL_20;
  }

  if (v285)
  {
    unint64_t v66 = v12;
    uint64_t v67 = 0LL;
    unsigned int v68 = 1;
    while (1)
    {
      if (v290)
      {
LABEL_50:
        char v80 = 0;
        goto LABEL_57;
      }

      unint64_t v69 = v284;
      size_t v70 = v284 * v67;
      AAFieldKey v71 = &v286[40 * v67];
      *(void *)AAFieldKey v71 = v284 * v67;
      size_t v72 = v69 * v67 + v69;
      *((void *)v71 + 1) = v72;
      size_t v73 = v283;
      if (v70 >= v283) {
        *(void *)AAFieldKey v71 = v283;
      }
      if (v72 >= v73) {
        *((void *)v71 + 1) = v73;
      }
      uint64_t Worker = ThreadPoolGetWorker((uint64_t)v44, v59, v60, v61, v62, v63, v64, v65);
      if (!Worker)
      {
        unsigned int v81 = "ThreadPoolGetWorker";
        __int16 v82 = 410;
        goto LABEL_56;
      }

      *(void *)(Worker + 8) = v67;
      uint64_t v67 = v68;
      BOOL v79 = v285 > v68++;
      if (!v79) {
        goto LABEL_50;
      }
    }

    unsigned int v81 = "ThreadPoolRunWorker";
    __int16 v82 = 412;
LABEL_56:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  v82,  14,  0,  v81,  v64,  v65,  (char)v238);
    char v80 = 1;
LABEL_57:
    unint64_t v12 = v66;
  }

  else
  {
    char v80 = 0;
  }

  if ((ThreadPoolDestroy((uint64_t)v44) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  416,  14,  0,  "ThreadPoolDestroy",  v38,  v39,  (char)v238);
    if (!atomic_load(&v290)) {
      goto LABEL_19;
    }
LABEL_78:
    uint64_t v98 = (void (*)(void))v23[2];
    if (v98) {
      v98(*v23);
    }
    goto LABEL_19;
  }

  if (atomic_load(&v290)) {
    goto LABEL_78;
  }
  if ((v80 & 1) != 0) {
    goto LABEL_19;
  }
  unint64_t v251 = v12;
  v252 = v23;
  size_t v84 = v285;
  if (v285)
  {
    unint64_t v85 = 0LL;
    uint64_t v86 = 0LL;
    int v87 = v286;
    AAFieldKey v88 = v294;
    do
    {
      AAFieldKey v89 = &v87[40 * v86];
      unint64_t v91 = *(void *)v89;
      unint64_t v90 = *((void *)v89 + 1);
      BOOL v79 = v90 > v91;
      unint64_t v92 = v90 - v91;
      if (v79)
      {
        uint64_t v93 = &v88[128 * v91];
        do
        {
          *(void *)v93 += v85;
          v93 += 128;
          --v92;
        }

        while (v92);
      }

      v85 += *(void *)&v87[40 * v86++ + 16];
    }

    while (v86 != v84);
    if ((v85 & 0x8000000000000000LL) == 0)
    {
      size_t v94 = v292;
      if (v292 >= v85)
      {
        size_t v99 = 1LL;
        goto LABEL_86;
      }

      do
      {
        while (!v94)
        {
          size_t v94 = 0x4000LL;
          if (v85 <= 0x4000)
          {
            size_t v96 = v293;
            size_t v94 = 0x4000LL;
            goto LABEL_84;
          }
        }

        size_t v95 = v94 >> 1;
        if ((v94 & (v94 >> 1)) != 0) {
          size_t v95 = v94 & (v94 >> 1);
        }
        v94 += v95;
      }

      while (v94 < v85);
      if (v94 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_272;
      }

      size_t v96 = v293;
LABEL_84:
      unint64_t v100 = (char *)realloc(v96, v94);
      if (v100)
      {
        v293 = v100;
        unint64_t v292 = v94;
        size_t v99 = v285;
LABEL_86:
        if (v99)
        {
          size_t v101 = 0LL;
          do
          {
            unint64_t v102 = &v286[40 * v101];
            size_t v103 = *((void *)v102 + 2);
            unint64_t v104 = v291 + v103;
            if (!__CFADD__(v291, v103) && (v104 & 0x8000000000000000LL) == 0)
            {
              v105 = (const void *)*((void *)v102 + 4);
              size_t v106 = v292;
              if (v292 >= v104)
              {
LABEL_103:
                if (v105)
                {
                  memcpy(&v293[v291], v105, v103);
                }

                else if (v293)
                {
                  memset_s(&v293[v291], v103, 0, v103);
                }

                v291 += v103;
              }

              else
              {
                do
                {
                  while (!v106)
                  {
                    size_t v106 = 0x4000LL;
                    if (v104 <= 0x4000)
                    {
                      unint64_t v108 = v293;
                      size_t v106 = 0x4000LL;
                      goto LABEL_101;
                    }
                  }

                  size_t v107 = v106 >> 1;
                  if ((v106 & (v106 >> 1)) != 0) {
                    size_t v107 = v106 & (v106 >> 1);
                  }
                  v106 += v107;
                }

                while (v106 < v104);
                if (v106 >= 0x2000000001LL)
                {
                  *__error() = 12;
                  goto LABEL_109;
                }

                unint64_t v108 = v293;
LABEL_101:
                int v109 = v108;
                size_t v110 = (char *)realloc(v108, v106);
                if (v110)
                {
                  v293 = v110;
                  unint64_t v292 = v106;
                  goto LABEL_103;
                }

                free(v109);
LABEL_109:
                unint64_t v291 = 0LL;
                unint64_t v292 = 0LL;
                v293 = 0LL;
              }
            }

            unint64_t v111 = (void **)&v286[40 * v101];
            unint64_t v112 = v111 + 2;
            free(v111[4]);
            memset_s(v112, 0x18uLL, 0, 0x18uLL);
            ++v101;
          }

          while (v101 < v285);
        }

        goto LABEL_111;
      }

      free(v96);
LABEL_272:
      v293 = 0LL;
      unint64_t v291 = 0LL;
      unint64_t v292 = 0LL;
    }

    uint64_t v40 = "allocating final blob";
    __int16 v41 = 430;
    int v37 = 0;
    goto LABEL_18;
  }

LABEL_111:
  v113.uint64_t ikey = 4410440;
  if (AAFieldKeySetContainsKey(v20, v113))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_hlc);
    unint64_t v114 = v283;
    if (v283)
    {
      uint64_t v115 = 0LL;
      uint64_t v116 = 0LL;
      uint64_t v117 = 0LL;
      size_t v118 = v294;
      while (1)
      {
        unint64_t v119 = &v118[128 * v117];
        uint64_t v122 = *((void *)v119 + 4);
        size_t v120 = v119 + 32;
        uint64_t v121 = v122;
        if (v122 == -1)
        {
LABEL_128:
          uint64_t v250 = v116;
          uint64_t v254 = v115;
          goto LABEL_131;
        }

        unint64_t v123 = v117 + 1;
        if (v117 + 1 < v114)
        {
          uint64_t v124 = 1LL;
          unint64_t v125 = &v118[128 * v117 + 160];
          while (1)
          {
            uint64_t v126 = *(void *)v125;
            v125 += 128;
            if (v126 != v121) {
              break;
            }
            ++v124;
            if (!(v117 - v114 + v124))
            {
              uint64_t v124 = v114 - v117;
              unint64_t v123 = v114;
              goto LABEL_121;
            }
          }

          unint64_t v123 = v117 + v124;
LABEL_121:
          if (!v124) {
            goto LABEL_126;
          }
          if (v124 != 1) {
            break;
          }
        }

        void *v120 = -1LL;
LABEL_127:
        uint64_t v117 = v123;
        if (v123 >= v114) {
          goto LABEL_128;
        }
      }

      uint64_t v127 = v124;
      do
      {
        void *v120 = v115;
        v120 += 16;
        --v127;
      }

      while (v127);
LABEL_126:
      ++v115;
      v116 += v124;
      goto LABEL_127;
    }

    uint64_t v254 = 0LL;
    uint64_t v250 = 0LL;
LABEL_131:
    int v128 = 1;
  }

  else
  {
    uint64_t v254 = 0LL;
    uint64_t v250 = 0LL;
    int v128 = 0;
  }

  v129.uint64_t ikey = 4410435;
  if (AAFieldKeySetContainsKey(v20, v129))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_clc);
    unint64_t v130 = v283;
    if (v283)
    {
      uint64_t v131 = 0LL;
      uint64_t v132 = 0LL;
      uint64_t v133 = 0LL;
      size_t v134 = v294;
      while (1)
      {
        uint64_t v135 = &v134[128 * v133];
        uint64_t v138 = *((void *)v135 + 5);
        v136 = v135 + 40;
        uint64_t v137 = v138;
        if (v138 == -1)
        {
LABEL_149:
          uint64_t v249 = v132;
          uint64_t v253 = v131;
          goto LABEL_152;
        }

        unint64_t v139 = v133 + 1;
        if (v133 + 1 < v130)
        {
          uint64_t v140 = 1LL;
          unint64_t v141 = &v134[128 * v133 + 168];
          while (1)
          {
            uint64_t v142 = *(void *)v141;
            v141 += 128;
            if (v142 != v137) {
              break;
            }
            ++v140;
            if (!(v133 - v130 + v140))
            {
              uint64_t v140 = v130 - v133;
              unint64_t v139 = v130;
              goto LABEL_142;
            }
          }

          unint64_t v139 = v133 + v140;
LABEL_142:
          if (!v140) {
            goto LABEL_147;
          }
          if (v140 != 1) {
            break;
          }
        }

        void *v136 = -1LL;
LABEL_148:
        uint64_t v133 = v139;
        if (v139 >= v130) {
          goto LABEL_149;
        }
      }

      uint64_t v143 = v140;
      do
      {
        void *v136 = v131;
        v136 += 16;
        --v143;
      }

      while (v143);
LABEL_147:
      ++v131;
      v132 += v140;
      goto LABEL_148;
    }

    uint64_t v253 = 0LL;
    uint64_t v249 = 0LL;
LABEL_152:
    int v128 = 1;
  }

  else
  {
    uint64_t v253 = 0LL;
    uint64_t v249 = 0LL;
  }

  v144.uint64_t ikey = 4410451;
  if (AAFieldKeySetContainsKey(v20, v144))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_slc);
    v145.uint64_t ikey = 3295315;
    BOOL v255 = 1;
    if (!AAFieldKeySetContainsKey(v20, v145))
    {
      v146.uint64_t ikey = 3360851;
      if (!AAFieldKeySetContainsKey(v20, v146))
      {
        v147.uint64_t ikey = 3491923;
        if (!AAFieldKeySetContainsKey(v20, v147)) {
          BOOL v255 = 0;
        }
      }
    }

    size_t v148 = v283;
    if (v283)
    {
      uint64_t v149 = 0LL;
      size_t v150 = 0LL;
      uint64_t v257 = 0LL;
      v258 = v20;
      int v47 = 1;
      while (1)
      {
        BOOL v151 = v294;
        unint64_t v152 = &v294[128 * v150];
        uint64_t v154 = *((void *)v152 + 6);
        unint64_t v153 = v152 + 48;
        if (v154 == -1) {
          goto LABEL_189;
        }
        size_t v155 = v150 + 1;
        if (v150 + 1 >= v148) {
          goto LABEL_168;
        }
        size_t v263 = v148;
        size_t v265 = v150 + 1;
        *(void *)v267 = v150;
        uint64_t v270 = v149;
        size_t v156 = &v294[128 * v150 + 56];
        unint64_t v261 = v148 - v150;
        size_t v259 = v150 << 7;
        v157 = &v294[128 * v150 + 184];
        size_t v158 = v150 - v148;
        unint64_t v159 = 1LL;
        while (!memcmp(v156, v157, 0x40uLL))
        {
          ++v159;
          v157 += 128;
          if (!(v158 + v159))
          {
            unint64_t v159 = v261;
            unint64_t v160 = v263;
            size_t v161 = *(void *)v267;
            goto LABEL_167;
          }
        }

        size_t v161 = *(void *)v267;
        unint64_t v160 = *(void *)v267 + v159;
LABEL_167:
        unint64_t v162 = v159 - 1;
        unint64_t v20 = v258;
        uint64_t v149 = v270;
        size_t v155 = v265;
        if (v159 == 1)
        {
LABEL_168:
          *unint64_t v153 = -1LL;
          size_t v150 = v155;
        }

        else
        {
          size_t v163 = v160;
          if (v255) {
            goto LABEL_178;
          }
          uint64_t v164 = *(void *)&v151[128 * v161 + 24];
          size_t v165 = v161;
          if ((AAPathListNodeGetPath(v22, v164, 0x400uLL, path, 0LL) & 0x80000000) == 0)
          {
            if (v159 >= 2)
            {
              size_t v168 = v259 + 152;
              do
              {
                if (AAPathListNodeGetPath(v22, *(void *)&v294[v168], 0x400uLL, v276, 0LL) < 0)
                {
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  528,  14,  0,  "AAPathListNodeGetPath",  v169,  v170,  (char)v238);
                  int v47 = 0;
                }

                else if ((int)areFilesEqual2() < 1)
                {
                  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  529,  14,  "Hash collision detected: %s != %s",  v171,  v172,  v173,  (char)path);
                  uint64_t v175 = 0LL;
                  uint64_t v176 = -1LL;
                  goto LABEL_179;
                }

                v168 += 128LL;
                --v162;
              }

              while (v162);
            }

    ++v54;
    uint64_t v56 = v11 + 1312;
  }

  while (v54 != 3);
  if (!*(void *)(v11 + 1560))
  {
    *(void *)(v11 + 1560) = 0LL;
    goto LABEL_135;
  }

  size_t v84 = 0LL;
  unint64_t v85 = 1;
  while (2)
  {
    uint64_t v86 = *(void *)(*(void *)(v11 + 1568) + 8 * v84);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, (const char *)v86) & 0x80000000) != 0)
    {
      size_t v99 = 1007;
      unint64_t v100 = "invalid 'H' PAT";
      goto LABEL_122;
    }

    if ((concatExtractPath(v151, 0x800uLL, (char *)v11, (const char *)(v86 + 1024)) & 0x80000000) != 0)
    {
      size_t v99 = 1008;
      unint64_t v100 = "invalid 'H' LNK";
LABEL_122:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamProcessHLinks",  v99,  72,  0,  v100,  v87,  v88,  v139);
LABEL_123:
      size_t v101 = 0;
      unint64_t v102 = -1;
      goto LABEL_124;
    }

    if (*(_DWORD *)(v11 + 1056)) {
      removeFile((const char *)&buf);
    }
    if (link(v151, (const char *)&buf))
    {
      size_t v96 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamProcessHLinks",  1010,  72,  v96,  "link %s ->%s",  v97,  v98,  (char)&buf);
      goto LABEL_123;
    }

    size_t v101 = 1;
    unint64_t v102 = 3;
LABEL_124:
    if (*(_DWORD *)(v86 + 2300) != v102)
    {
      *(_DWORD *)(v86 + 2300) = v102;
      size_t v103 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 1040);
      if (v103)
      {
        if (v102 == -1) {
          unint64_t v104 = 22LL;
        }
        else {
          unint64_t v104 = 21LL;
        }
        v103(*(void *)(v11 + 1032), v104, v86, v86 + 2272);
      }
    }

    entryRelease(v86, v89, v90, v91, v92, v93, v94, v95);
    *(void *)(*(void *)(v11 + 1568) + 8 * v84) = 0LL;
    v85 &= v101;
    break;
  }

  *(void *)(v11 + 1560) = 0LL;
  if (!v85)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamClose",  1550,  72,  0,  "process hlinks",  v45,  v46,  v139);
    uint64_t v142 = 0;
  }

LABEL_183:
        size_t v148 = v283;
        if (v150 >= v283) {
          goto LABEL_189;
        }
      }
    }

    uint64_t v257 = 0LL;
    uint64_t v149 = 0LL;
    int v47 = 1;
  }

  else
  {
    if (!v128)
    {
      uint64_t v257 = 0LL;
      uint64_t v149 = 0LL;
      int v47 = 1;
      goto LABEL_190;
    }

    uint64_t v257 = 0LL;
    uint64_t v149 = 0LL;
    int v47 = 1;
    size_t v148 = v283;
  }

LABEL_189:
  qsort(v294, v148, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_offset);
LABEL_190:
  if ((unint64_t)(v254 + 1) < 0x2000000001LL)
  {
    uint64_t v46 = calloc(v254 + 1, 1uLL);
  }

  else
  {
    uint64_t v46 = 0LL;
    *__error() = 12;
  }

  if ((unint64_t)(v253 + 1) < 0x2000000001LL)
  {
    int v45 = calloc(v253 + 1, 1uLL);
  }

  else
  {
    int v45 = 0LL;
    *__error() = 12;
  }

  if ((unint64_t)(v149 + 1) >= 0x2000000001LL)
  {
    uint64_t v44 = 0LL;
    *__error() = 12;
LABEL_198:
    char v177 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  556,  14,  *v177,  "malloc",  v178,  v179,  (char)v238);
    AAFieldKey v42 = 0LL;
    __int16 v43 = 0LL;
    goto LABEL_21;
  }

  v180 = (unsigned int *)calloc(v149 + 1, 1uLL);
  uint64_t v44 = v180;
  if (!v46 || !v45 || !v180) {
    goto LABEL_198;
  }
  __int16 v43 = AAHeaderCreate();
  if (!v43)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  560,  14,  0,  "Header creation",  v181,  v182,  (char)v238);
    AAFieldKey v42 = 0LL;
    goto LABEL_21;
  }

  AAFieldKey v42 = malloc(0x40000uLL);
  if (!v42)
  {
    int v226 = *__error();
    v227 = "malloc";
    __int16 v228 = 562;
LABEL_313:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c",  (uint64_t)"AAArchiveStreamWritePathList",  v228,  14,  v226,  v227,  v183,  v184,  (char)v238);
    goto LABEL_21;
  }

  uint64_t v271 = v149;
  if (!v283)
  {
    int v264 = 0;
    int v262 = 0;
    int v266 = 0;
    uint64_t v242 = 0LL;
LABEL_276:
    double v229 = getRealTime();
    if (v251 >> 62)
    {
      double v230 = v229;
      v231 = (FILE **)MEMORY[0x1895F89D0];
      fwrite("Archive path list\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      bzero(path, 0x400uLL);
      if (!AAFieldKeySetSerialize(v20, 0x400uLL, path)) {
        fprintf(*v231, "%12s %s\n", "fields", path);
      }
      fprintf(*v231, "%12llu entries\n", v283);
      if (v254) {
        fprintf(*v231, "%12llu entries in %llu hard link clusters (HLC)\n", v250, v254);
      }
      if (v253) {
        fprintf(*v231, "%12llu entries in %llu clone clusters (CLC)\n", v249, v253);
      }
      if (v271) {
        fprintf(*v231, "%12llu entries in %llu same data clusters (SLC)\n", v257, v271);
      }
      if (v262) {
        fprintf(*v231, "%12u entries with XAT field\n", v262);
      }
      if (v266) {
        fprintf(*v231, "%12u entries with ACL field\n", v266);
      }
      double v232 = v230 - RealTime;
      if (v264) {
        fprintf(*v231, "%12u entries with YEC field\n", v266);
      }
      fprintf(*v231, "%12llu bytes in regular files DAT\n", v242);
      fprintf(*v231, "%12.2f time (s)\n", v232);
    }

    goto LABEL_22;
  }

  size_t v185 = 0LL;
  uint64_t v242 = 0LL;
  int v266 = 0;
  int v262 = 0;
  int v264 = 0;
  int v186 = 0;
  while (1)
  {
    v187 = v294;
    *(void *)v268 = v185;
    v188 = &v294[128 * v185];
    unint64_t v190 = *(void *)v188;
    unint64_t v189 = *((void *)v188 + 1);
    unint64_t v191 = *((void *)v188 + 2);
    uint64_t v256 = v189 - v191;
    if (v189 < v191 || v190 >= v291)
    {
      v227 = "invalid header blob size";
      __int16 v228 = 570;
LABEL_312:
      int v226 = 0;
      goto LABEL_313;
    }

    uint64_t v244 = *((void *)v188 + 2);
    unint64_t v246 = *(void *)v188;
    if ((aaHeaderInitWithEncodedData((uint64_t)v43, (unsigned __int16 *)&v293[v190], v191) & 0x80000000) != 0)
    {
      v227 = "parse stored header";
      __int16 v228 = 571;
      goto LABEL_312;
    }

    if ((v251 & 2) != 0)
    {
      v193 = &v187[128 * *(void *)v268];
      uint64_t v194 = *((void *)v193 + 4);
      if (v194 == -1)
      {
        uint64_t v195 = *((void *)v193 + 5);
        if (v195 == -1)
        {
          uint64_t v196 = *(void *)&v187[128 * *(void *)v268 + 48];
          if (v196 == -1) {
            goto LABEL_222;
          }
          if (!*((_BYTE *)v44 + v196))
          {
            *((_BYTE *)v44 + v196) = 1;
            goto LABEL_222;
          }
        }

        else if (!v45[v195])
        {
          v45[v195] = 1;
          goto LABEL_222;
        }
      }

      else if (!v46[v194])
      {
        v46[v194] = 1;
        goto LABEL_222;
      }

      v197.uint64_t ikey = 5521732;
      uint32_t KeyIndex = AAHeaderGetKeyIndex(v43, v197);
      if ((KeyIndex & 0x80000000) == 0) {
        AAHeaderRemoveField(v43, KeyIndex);
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v166,  86,  v162,  v165,  v163,  v164,  v167);
    size_t v17 = 0;
    uint64_t v44 = 0LL;
    goto LABEL_135;
  }

  if (fgetxattr(fd, "com.apple.ResourceFork", v18, (8 * v172) + 264LL, 0, 32) == (8 * v172)
                                                                                              + 264LL)
  {
    uint64_t v78 = *v18;
    BOOL v79 = *((_OWORD *)v178 + 13);
    uint64_t v204 = *((_OWORD *)v178 + 12);
    AAFieldKey v205 = v79;
    v206 = *((_OWORD *)v178 + 14);
    v207 = v178[60];
    char v80 = *((_OWORD *)v178 + 9);
    uint64_t v200 = *((_OWORD *)v178 + 8);
    AAFieldKey v201 = v80;
    unsigned int v81 = *((_OWORD *)v178 + 11);
    uint64_t v202 = *((_OWORD *)v178 + 10);
    AAFieldKey v203 = v81;
    __int16 v82 = *((_OWORD *)v178 + 5);
    uint64_t v196 = *((_OWORD *)v178 + 4);
    AAFieldKey v197 = v82;
    AAFieldKey v83 = *((_OWORD *)v178 + 7);
    int v198 = *((_OWORD *)v178 + 6);
    v199 = v83;
    size_t v84 = *((_OWORD *)v178 + 1);
    v192 = *(_OWORD *)v178;
    v193 = v84;
    unint64_t v85 = *((_OWORD *)v178 + 3);
    uint64_t v194 = *((_OWORD *)v178 + 2);
    uint64_t v195 = v85;
    uint64_t v34 = fd;
    size_t v168 = v18[65];
    uint64_t v169 = v78;
    if ((_DWORD)v172)
    {
      uint64_t v86 = v74 + 1;
      int v87 = (v66 >> 16);
      AAFieldKey v88 = (4 * v172 + 4);
      AAFieldKey v89 = v177;
      do
      {
        unint64_t v90 = *(_DWORD *)v89;
        unint64_t v91 = *((_DWORD *)v89++ + 1);
        v90 += 260;
        *(v86 - 1) = v90;
        *v86++ = v90 + v91;
        --v87;
      }

      while (v87);
    }

    else
    {
      AAFieldKey v88 = 4LL;
    }

    goto LABEL_98;
  }

  v157 = *__error();
  unint64_t v160 = "Reading chunk sizes";
  size_t v161 = 749;
LABEL_183:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v161,  86,  v157,  v160,  v158,  v159,  v167);
  size_t v17 = 0;
  uint64_t v44 = 0LL;
LABEL_146:
  uint64_t v36 = -1;
LABEL_151:
  uint64_t v34 = fd;
LABEL_136:
  if ((ParallelCompressionAFSCStreamClose((uint64_t)v44, v8, v9, v10, v11, v12, v13, v14) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  877,  86,  0,  "Stream close error",  v115,  v116,  v167);
    size_t v17 = 0;
  }

  if ((v34 & 0x80000000) == 0) {
    close(v34);
  }
  if ((v36 & 0x80000000) == 0)
  {
    close(v36);
    unlink(__old);
  }

  free(v18);
  free(v74);
  free(v76);
  if (v17) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t cmp_entries_hlc(void *a1, void *a2)
{
  unint64_t v4 = a1[4];
  unint64_t v2 = a2[4];
  BOOL v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = 0xFFFFFFFFLL;
  }
  if (!(_DWORD)v4)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }

  return v4;
}

uint64_t cmp_entries_clc(void *a1, void *a2)
{
  unint64_t v4 = a1[5];
  unint64_t v2 = a2[5];
  BOOL v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = 0xFFFFFFFFLL;
  }
  if (!(_DWORD)v4)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }

  return v4;
}

uint64_t cmp_entries_slc(void *a1, void *a2)
{
  unint64_t v3 = a1[6];
  unint64_t v4 = a2[6];
  BOOL v5 = v3 >= v4;
  BOOL v6 = v3 != v4;
  if (v5) {
    uint64_t result = v6;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  if (!(_DWORD)result)
  {
    uint64_t result = memcmp(a1 + 7, a2 + 7, 0x40uLL);
    if (!(_DWORD)result)
    {
      if (*a1 < *a2) {
        return 0xFFFFFFFFLL;
      }
      else {
        return *a1 != *a2;
      }
    }
  }

  return result;
}

uint64_t cmp_entries_offset(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

AAByteStream AEADecryptionRandomAccessInputStreamOpen( AAByteStream encrypted_stream, AEAContext context, size_t alloc_limit, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads = n_threads;
  if (n_threads <= 0) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((_DWORD *)context + 684) || !*((void *)context + 341))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c",  (uint64_t)"AEADecryptionRandomAccessInputStreamOpen",  90,  32,  0,  "Invalid context",  v5,  v6,  v34);
    uint64_t v12 = 0LL;
    goto LABEL_28;
  }

  unint64_t v11 = malloc(0x38uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11)
  {
    int v31 = *__error();
    uint64_t v32 = "malloc";
    __int16 v33 = 94;
    goto LABEL_27;
  }

  memset_s(v11, 0x38uLL, 0, 0x38uLL);
  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  if ((flags & 0x400000000000000LL) != 0) {
    *((_DWORD *)context + 685) = 1;
  }
  uint64_t Existing = aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 1, 0);
  *(void *)(v12 + 16) = Existing;
  if (!Existing)
  {
    uint64_t v32 = "unlock container";
    __int16 v33 = 106;
    int v31 = 0;
    goto LABEL_27;
  }

  *(_DWORD *)(v12 + 24) = DefaultNThreads;
  uint64_t v16 = calloc(DefaultNThreads, 0x10uLL);
  *(void *)(v12 + 32) = v16;
  if (!v16)
  {
    int v31 = *__error();
    uint64_t v32 = "malloc";
    __int16 v33 = 111;
    goto LABEL_27;
  }

  uint64_t v17 = *(void *)(v12 + 16);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  if ((_DWORD)v18)
  {
    compression_algorithm v19 = aeaEffectiveCompressionAlgorithm(v18);
    *(void *)(v12 + 40) = compression_decode_scratch_buffer_size(v19);
    uint64_t v17 = *(void *)(v12 + 16);
  }

  unsigned int v20 = *(_DWORD *)(v12 + 24);
  if (!v20)
  {
LABEL_19:
    *(_OWORD *)context = *(_OWORD *)v17;
    __int128 v27 = *(_OWORD *)(v17 + 16);
    __int128 v28 = *(_OWORD *)(v17 + 32);
    __int128 v29 = *(_OWORD *)(v17 + 48);
    *((void *)context + 8) = *(void *)(v17 + 64);
    *((_OWORD *)context + 2) = v28;
    *((_OWORD *)context + 3) = v29;
    *((_OWORD *)context + 1) = v27;
    return (AAByteStream)AAGenericRandomAccessInputStreamOpen( *(void *)(v17 + 32),  *(_DWORD *)(v17 + 16),  v20,  4 * v20,  v12,  (uint64_t)RandomAccessDecryptionStreamGetBlock,  (uint64_t)RandomAccessDecryptionStreamAbort,  (uint64_t)RandomAccessDecryptionStreamDestroy,  flags);
  }

  unint64_t v21 = *(void **)(v12 + 32);
  size_t v22 = *(unsigned int *)(v17 + 16);
  uint64_t v23 = *(unsigned int *)(v12 + 24);
  while (1)
  {
    uint64_t v24 = malloc(v22);
    v21[1] = v24;
    if (!v24)
    {
      int v31 = *__error();
      uint64_t v32 = "malloc";
      __int16 v33 = 120;
      goto LABEL_27;
    }

    size_t v25 = *(void *)(v12 + 40);
    if (!v25) {
      goto LABEL_18;
    }
    if (v25 >= 0x2000000001LL) {
      break;
    }
    uint64_t v26 = malloc(v25);
    *unint64_t v21 = v26;
    if (!v26) {
      goto LABEL_26;
    }
LABEL_18:
    v21 += 2;
    if (!--v23) {
      goto LABEL_19;
    }
  }

  *__error() = 12;
  *unint64_t v21 = 0LL;
LABEL_26:
  int v31 = *__error();
  uint64_t v32 = "malloc";
  __int16 v33 = 124;
LABEL_27:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c",  (uint64_t)"AEADecryptionRandomAccessInputStreamOpen",  v33,  32,  v31,  v32,  v14,  v15,  v34);
LABEL_28:
  RandomAccessDecryptionStreamDestroy(v12);
  return 0LL;
}

uint64_t RandomAccessDecryptionStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    unint64_t v2 = *(void **)(a1 + 32);
    if (!v2)
    {
LABEL_15:
      aeaContainerDestroy(*(void *)(a1 + 16));
      memset_s((void *)a1, 0x38uLL, 0, 0x38uLL);
      free((void *)a1);
      return 0LL;
    }

    if (*(_DWORD *)(a1 + 24))
    {
      uint64_t v3 = 0LL;
      unint64_t v4 = 0LL;
      do
      {
        uint64_t v5 = *(void *)(a1 + 32) + v3;
        uint64_t v6 = *(void **)(v5 + 8);
        if (v6)
        {
          rsize_t v7 = *(unsigned int *)(*(void *)(a1 + 16) + 16LL);
          memset_s(v6, v7, 0, v7);
        }

        free(v6);
        uint64_t v8 = *(void **)v5;
        if (*(void *)v5) {
          memset_s(*(void **)v5, *(void *)(a1 + 40), 0, *(void *)(a1 + 40));
        }
        free(v8);
        ++v4;
        unint64_t v9 = *(unsigned int *)(a1 + 24);
        v3 += 16LL;
      }

      while (v4 < v9);
      unint64_t v2 = *(void **)(a1 + 32);
      if (!v2) {
        goto LABEL_14;
      }
      rsize_t v10 = 16 * v9;
    }

    else
    {
      rsize_t v10 = 0LL;
    }

    memset_s(v2, v10, 0, v10);
LABEL_14:
    free(v2);
    goto LABEL_15;
  }

  return 0LL;
}

uint64_t RandomAccessDecryptionStreamGetBlock( uint64_t a1, unsigned int a2, unint64_t a3, uint8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24) > a2 && *(unsigned int *)(*(void *)(a1 + 16) + 400LL) > a3)
  {
    uint64_t v8 = *(void *)(a1 + 32) + 16LL * a2;
    if ((aeaContainerLoadSegment( *(void *)(a1 + 16),  *(void **)a1,  a3,  a4,  *(const uint8_t **)(v8 + 8),  *(void **)v8,  a7,  a8) & 0x8000000000000000LL) == 0) {
      return 0LL;
    }
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c",  (uint64_t)"RandomAccessDecryptionStreamGetBlock",  71,  32,  0,  "Loading segment",  v9,  v10,  vars0);
  }

  return 0xFFFFFFFFLL;
}

void RandomAccessDecryptionStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }

uint64_t aaAssetDecodeStreamDone( uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] == closeProc) {
    return *((_DWORD *)*a1 + 8) == 4;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamDone",  410,  131,  0,  "invalid stream",  a7,  a8,  vars0);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    uint64_t v3 = (void *)(result + 64);
    free(*(void **)(result + 80));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    AAHeaderDestroy(*(AAHeader *)(v1 + 88));
    free(*(void **)(v1 + 112));
    memset_s((void *)(v1 + 104), 0x10uLL, 0, 0x10uLL);
    unint64_t v4 = *(void (***)(void))(v1 + 128);
    if (v4)
    {
      if (*v4) {
        v4[1]();
      }
      free(v4);
    }

    uint64_t v5 = *(void (***)(void))(v1 + 136);
    if (v5)
    {
      if (*v5) {
        v5[1]();
      }
      free(v5);
    }

    memset_s((void *)v1, 0x90uLL, 0, 0x90uLL);
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t aaAssetDecodeStreamSetParameterPtr( uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((uint64_t (*)(uint64_t))a1[1] == closeProc)
  {
    uint64_t v9 = *a1;
    if (a2 == 103)
    {
      uint64_t result = 0LL;
      *(void *)(v9 + 24) = a3;
      return result;
    }

    if (a2 == 101)
    {
      uint64_t result = 0LL;
      *(void *)(v9 + 16) = a3;
      return result;
    }
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamSetParameterPtr",  420,  131,  0,  "invalid stream",  a7,  a8,  vars0);
  }

  return 0xFFFFFFFFLL;
}

void *aaAssetDecodeStreamOpen(uint64_t a1)
{
  unsigned int v2 = malloc(0x90uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 443;
LABEL_10:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamOpen",  v11,  131,  v9,  v10,  v5,  v6,  v13);
    closeProc((uint64_t)v3);
    return 0LL;
  }

  memset_s(v2, 0x90uLL, 0, 0x90uLL);
  *uint64_t v3 = a1;
  unint64_t v4 = AAHeaderCreate();
  v3[11] = v4;
  if (!v4)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 446;
    goto LABEL_10;
  }

  if ((aaHeaderBlobArrayInitWithHeader((uint64_t)(v3 + 13), v4) & 0x80000000) != 0)
  {
    uint64_t v10 = "blob array init";
    __int16 v11 = 447;
    int v9 = 0;
    goto LABEL_10;
  }

  v3[6] = -1LL;
  rsize_t v7 = malloc(0x38uLL);
  if (!v7)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 452;
    goto LABEL_10;
  }

  uint64_t v8 = v7;
  memset_s(v7, 0x38uLL, 0, 0x38uLL);
  *uint64_t v8 = v3;
  v8[1] = closeProc;
  v8[6] = closeWithStateProc;
  v8[2] = cancelProc;
  v8[3] = writeProc;
  return v8;
}

uint64_t closeWithStateProc(uint64_t a1, void *a2, void *a3)
{
  if (!a1) {
    return 0LL;
  }
  int v8 = *(_DWORD *)(a1 + 96);
  v46[0] = *(_DWORD *)(a1 + 32);
  v46[1] = v8;
  __int128 v47 = *(_OWORD *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 120);
  uint64_t v48 = *(void *)(a1 + 56);
  uint64_t v49 = v9;
  unsigned int EncodedSize = AAHeaderGetEncodedSize(*(AAHeader *)(a1 + 88));
  uint64_t v14 = (uint64_t *)(a1 + 64);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v16 = (_DWORD *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 104);
  unsigned int v50 = EncodedSize;
  int v51 = v15;
  uint64_t v52 = v13;
  uint64_t v17 = *(void *)(a1 + 136);
  BOOL v53 = *(void *)(a1 + 128) != 0LL;
  BOOL v54 = v17 != 0;
  if (a2[3])
  {
    uint64_t v18 = 0LL;
    compression_algorithm v19 = v46;
    uint64_t v20 = 58LL;
    while (1)
    {
      uint64_t v21 = ((uint64_t (*)(void, _DWORD *, uint64_t))a2[3])(*a2, v19, v20);
      if (v21 < 1) {
        break;
      }
      compression_algorithm v19 = (_DWORD *)((char *)v19 + v21);
      v18 += v21;
      v20 -= v21;
      if (!v20)
      {
        if (v18 < 0) {
          goto LABEL_36;
        }
        goto LABEL_12;
      }
    }

    if (v21 < 0) {
      goto LABEL_36;
    }
LABEL_12:
    EncodedData = AAHeaderGetEncodedData(*(AAHeader *)(a1 + 88));
    if (a2[3])
    {
      uint64_t v23 = v50;
      if (!v50) {
        goto LABEL_72;
      }
      uint64_t v24 = EncodedData;
      uint64_t v25 = 0LL;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, const uint8_t *, uint64_t))a2[3])(*a2, v24, v23);
        if (v26 < 1) {
          break;
        }
        v24 += v26;
        v25 += v26;
        v23 -= v26;
        if (!v23) {
          goto LABEL_19;
        }
      }

      uint64_t v25 = v26;
LABEL_19:
      if ((v25 & 0x8000000000000000LL) == 0)
      {
LABEL_72:
        if (*v16)
        {
          uint64_t v27 = 0LL;
          while (a2[3])
          {
            uint64_t v28 = 0LL;
            uint64_t v29 = *(void *)(a1 + 112) + 24 * v27 + 8;
            uint64_t v30 = 8LL;
            while (1)
            {
              uint64_t v31 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v30);
              if (v31 < 1) {
                break;
              }
              v29 += v31;
              v28 += v31;
              v30 -= v31;
              if (!v30) {
                goto LABEL_28;
              }
            }

            uint64_t v28 = v31;
LABEL_28:
            if (v28 < 0) {
              break;
            }
          }

          __int16 v36 = 376;
          goto LABEL_37;
        }

LABEL_30:
        if (!a2[3]) {
          goto LABEL_52;
        }
        uint64_t v32 = *v14;
        if (!*v14) {
          goto LABEL_51;
        }
        uint64_t v33 = 0LL;
        uint64_t v34 = *(void *)(a1 + 80);
        while (1)
        {
          uint64_t v35 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v34, v32);
          if (v35 < 1) {
            break;
          }
          v34 += v35;
          v33 += v35;
          v32 -= v35;
          if (!v32) {
            goto LABEL_50;
          }
        }

        uint64_t v33 = v35;
LABEL_50:
        if (v33 < 0) {
LABEL_52:
        }
          int v40 = 0;
        else {
LABEL_51:
        }
          int v40 = 1;
        if (v54)
        {
          __int16 v41 = *(void **)(a1 + 136);
          if (v41)
          {
            if (*v41)
            {
              int v42 = ((uint64_t (*)(void, void *, void))v41[6])(*v41, a2, 0LL);
              free(v41);
              if (v42 < 0) {
                int v40 = 0;
              }
            }

            else
            {
              free(*(void **)(a1 + 136));
            }
          }
        }

        *(void *)(a1 + 136) = 0LL;
        if (v53)
        {
          __int16 v43 = *(void **)(a1 + 128);
          if (v43)
          {
            if (*v43)
            {
              int v44 = ((uint64_t (*)(void, void *, void))v43[6])(*v43, a2, 0LL);
              free(v43);
              if (v44 < 0)
              {
                *(void *)(a1 + 128) = 0LL;
LABEL_69:
                __int16 v36 = 385;
                goto LABEL_37;
              }
            }

            else
            {
              free(*(void **)(a1 + 128));
            }
          }
        }

        *(void *)(a1 + 128) = 0LL;
        if (v40)
        {
          uint64_t v5 = 0LL;
          if (a3) {
            *a3 = *(void *)(a1 + 56);
          }
          goto LABEL_38;
        }

        goto LABEL_69;
      }
    }
  }

        uint64_t v33 = *(void *)(a1 + 8);
        uint64_t v34 = (void *)(v33 + 56 * v8);
        uint64_t v35 = v34[3];
        if (v35 < 0) {
          __int16 v36 = 0;
        }
        else {
          __int16 v36 = *(_DWORD *)(v33 + 56 * v35 + 48);
        }
        int v37 = *(void *)(v33 + 56 * v8 + 32);
        if (v37 < 0) {
          uint64_t v38 = 0;
        }
        else {
          uint64_t v38 = *(_DWORD *)(v33 + 56 * v37 + 48);
        }
        if (v38 > v36) {
          __int16 v36 = v38;
        }
        uint64_t v39 = v33 + 56 * v8;
        *(_DWORD *)(v39 + 48) = v36 + 1;
        int v40 = *(void *)(v39 + 8) - *v34;
        if (v35 < 0) {
          __int16 v41 = 0LL;
        }
        else {
          __int16 v41 = *(void *)(v33 + 56 * v35 + 40);
        }
        int v42 = v40 + v41;
        if (v37 < 0) {
          __int16 v43 = 0LL;
        }
        else {
          __int16 v43 = *(void *)(v33 + 56 * v37 + 40);
        }
        *(void *)(v33 + 56 * v8 + 40) = v42 + v43;
        if ((treeRebalance(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeDeleteRangeWithPoint",  499,  107,  0,  "treeRebalance: %zd",  v44,  v45,  v8);
          return 0xFFFFFFFFLL;
        }

        return 0LL;
      }

      uint64_t v29 = v8;
      while (1)
      {
        uint64_t v28 = *(void *)(v12 + 56 * v29 + 16);
        if (v28 < 0) {
          break;
        }
        uint64_t v30 = *(void *)(v12 + 56 * v28 + 24) == v29;
        uint64_t v29 = *(void *)(v12 + 56 * v29 + 16);
        if (!v30) {
          goto LABEL_25;
        }
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeDeleteRangeWithPoint",  490,  107,  0,  "no nodePrev/Next: %zd",  a7,  a8,  v8);
    return 0xFFFFFFFFLL;
  }

  if ((v25 & 0x8000000000000000LL) == 0)
  {
    uint64_t v27 = 0;
    uint64_t v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    goto LABEL_15;
  }

  uint64_t result = 0LL;
  *(void *)(v12 + 56 * v8 + 16) = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v8;
  *a2 = -1LL;
  return result;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferTransmit",  v20,  36,  0,  v19,  a7,  a8,  v22);
    return -1LL;
  }

  return a2;
}

    uint64_t v29 = (void *)*((void *)acl + 5);
    uint64_t v30 = realloc(v29, v27);
    if (v30)
    {
      *((void *)acl + 4) = v27;
      *((void *)acl + 5) = v30;
      goto LABEL_32;
    }

    free(v29);
LABEL_43:
    *((void *)acl + 4) = 0LL;
    *((void *)acl + 5) = 0LL;
LABEL_44:
    *(void *)acl = 0LL;
    *((void *)acl + 3) = 0LL;
    goto LABEL_49;
  }

      int v51 = v27;
      unsigned int v50 = v30;
      uint64_t v38 = (char *)realloc(v18, v30);
      if (v38)
      {
        uint64_t v27 = v51;
        *((void *)acl + 4) = v50;
        *((void *)acl + 5) = v38;
        uint64_t v18 = v38;
        uint64_t v23 = v22 - v20;
        uint64_t v21 = (unint64_t *)((char *)acl + 24);
        goto LABEL_32;
      }

      free(v18);
      int v37 = (void *)((char *)acl + 24);
LABEL_56:
      void *v37 = 0LL;
      v37[1] = 0LL;
      v37[2] = 0LL;
      goto LABEL_7;
    }

    int v37 = *(void **)(v21 + 80);
    uint64_t v38 = realloc(v37, v36);
    if (!v38)
    {
LABEL_71:
      free(v37);
LABEL_73:
      *uint64_t v31 = 0LL;
      v31[1] = 0LL;
      v31[2] = 0LL;
      goto LABEL_74;
    }

    *(void *)(v21 + 72) = v36;
    *(void *)(v21 + 80) = v38;
    uint64_t v33 = *(void *)(v21 + 64);
LABEL_32:
    if (v36 - v33 >= v29) {
      uint64_t v39 = v29;
    }
    else {
      uint64_t v39 = v36 - v33;
    }
    int v40 = AAByteStreamRead(a2, (void *)(*(void *)(v21 + 80) + v33), v39);
    if (v40 < 0) {
      goto LABEL_74;
    }
    if (!v40) {
      break;
    }
    uint64_t v33 = *v31 + v40;
    if (!__CFADD__(*v31, v40))
    {
      uint64_t v32 = *(void *)(v21 + 72);
      if (v33 <= v32) {
        continue;
      }
    }

    goto LABEL_74;
    *uint64_t v31 = v33;
    v30 += v40;
    v29 -= v40;
  }

  while (v29);
  if (v30 < 0) {
    goto LABEL_74;
  }
LABEL_41:
  __int16 v41 = HIDWORD(v56);
  if (HIDWORD(v56))
  {
    int v42 = 0LL;
    uint64_t v31 = (unint64_t *)(v21 + 88);
    int v44 = *(void *)(v21 + 88);
    __int16 v43 = *(void *)(v21 + 96);
    while (1)
    {
      if (v44 == v43)
      {
        char v45 = v43 + 0x40000;
        if (v43 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v43)
            {
              __int16 v43 = 0x4000LL;
              __int128 v47 = 0x4000LL;
              if (v45 <= 0x4000) {
                goto LABEL_56;
              }
            }

            uint64_t v46 = v43 >> 1;
            if ((v43 & (v43 >> 1)) != 0) {
              uint64_t v46 = v43 & (v43 >> 1);
            }
            v43 += v46;
          }

          while (v43 < v45);
          __int128 v47 = v43;
          if (v43 >= 0x2000000001LL) {
            goto LABEL_72;
          }
LABEL_56:
          int v37 = *(void **)(v21 + 104);
          uint64_t v48 = realloc(v37, v47);
          if (!v48) {
            goto LABEL_71;
          }
          *(void *)(v21 + 96) = v47;
          *(void *)(v21 + 104) = v48;
          int v44 = *(void *)(v21 + 88);
          goto LABEL_58;
        }

        int v44 = v43;
      }

      __int128 v47 = v43;
LABEL_58:
      if (v47 - v44 >= v41) {
        uint64_t v49 = v41;
      }
      else {
        uint64_t v49 = v47 - v44;
      }
      unsigned int v50 = AAByteStreamRead(a2, (void *)(*(void *)(v21 + 104) + v44), v49);
      if (v50 < 0) {
        goto LABEL_74;
      }
      if (v50)
      {
        int v44 = *v31 + v50;
        if (__CFADD__(*v31, v50)) {
          goto LABEL_74;
        }
        __int16 v43 = *(void *)(v21 + 96);
        if (v44 > v43) {
          goto LABEL_74;
        }
        *uint64_t v31 = v44;
        v42 += v50;
        v41 -= v50;
        if (v41) {
          continue;
        }
      }

      if ((v42 & 0x8000000000000000LL) == 0) {
        break;
      }
      goto LABEL_74;
    }
  }

  if (a3) {
    *a3 = *(void *)(v21 + 24);
  }
  return v20;
}

    uint64_t v21 = 0LL;
    uint64_t v20 = "???";
    compression_algorithm v19 = 1;
    goto LABEL_31;
  }

  if (BYTE3(v56) > 0x77u)
  {
    if (BYTE3(v56) == 122)
    {
      compression_algorithm v19 = 0;
      uint64_t v20 = "zlib";
      uint64_t v21 = PCompressZLIBDecode;
      goto LABEL_31;
    }

    if (BYTE3(v56) == 120)
    {
      compression_algorithm v19 = 0;
      uint64_t v20 = "lzma";
      uint64_t v21 = PCompressLZMADecode;
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  if (BYTE3(v56) == 101)
  {
    compression_algorithm v19 = 0;
    uint64_t v20 = "lzfse";
    uint64_t v21 = PCompressLZFSEDecode;
    goto LABEL_31;
  }

  if (BYTE3(v56) != 102) {
    goto LABEL_30;
  }
  compression_algorithm v19 = 0;
  uint64_t v20 = "lzvn";
  uint64_t v21 = PCompressLZVNDecode;
LABEL_31:
  *(void *)(v8 + 16) = v21;
  if (v56 != 112 || BYTE1(v56) != 98 || BYTE2(v56) != 122 || v19)
  {
    uint64_t v23 = "invalid file header";
    uint64_t v24 = 128;
    goto LABEL_17;
  }

  v55[0] = *(void *)((char *)&v56 + 4);
  uint64_t v26 = bswap64(*(unint64_t *)((char *)&v56 + 4));
  if (HIDWORD(v26))
  {
    uint64_t v23 = "invalid block size";
    uint64_t v24 = 131;
    goto LABEL_17;
  }

  *(void *)(v8 + 24) = 0LL;
  if (v13 == 12)
  {
    uint64_t v27 = 0LL;
    goto LABEL_40;
  }

  BOOL v53 = v26;
  int v51 = v20;
  uint64_t v33 = 0LL;
  uint64_t v27 = 0LL;
  uint64_t v34 = 12LL;
  while (2)
  {
    if (v34 + 16 > v13)
    {
      uint64_t v23 = "truncated file";
      uint64_t v24 = 138;
      goto LABEL_17;
    }

    BOOL v54 = v34 + 16;
    uint64_t v52 = v33;
    uint64_t v35 = v27;
    __int16 v36 = *(void *)v8;
    if (!*(void *)(*(void *)v8 + 32LL))
    {
LABEL_75:
      uint64_t v23 = "reading block header";
      uint64_t v24 = 139;
      goto LABEL_17;
    }

    int v37 = 0LL;
    uint64_t v38 = v55;
    uint64_t v39 = 16LL;
    do
    {
      int v40 = (*(uint64_t (**)(void, unint64_t *, uint64_t, uint64_t))(v36 + 32))( *(void *)v36,  v38,  v39,  v34);
      if (v40 < 0) {
        goto LABEL_75;
      }
      if (!v40) {
        break;
      }
      uint64_t v38 = (unint64_t *)((char *)v38 + v40);
      v37 += v40;
      v34 += v40;
      v39 -= v40;
    }

    while (v39);
    if (v37 != 16) {
      goto LABEL_75;
    }
    __int16 v41 = bswap64(v55[0]);
    int v42 = bswap64(v55[1]);
    if (v41 > v53 || v42 > v53)
    {
      uint64_t v23 = "invalid block header";
      uint64_t v24 = 143;
      goto LABEL_17;
    }

    int v44 = v54;
    uint64_t v34 = v42 + v54;
    if (v42 + v54 > v13)
    {
      uint64_t v23 = "truncated file";
      uint64_t v24 = 144;
      goto LABEL_17;
    }

    char v45 = v35;
    uint64_t v46 = *(void *)(v8 + 24);
    if (v35 != v46 * v53)
    {
      uint64_t v23 = "invalid block size";
      uint64_t v24 = 147;
      goto LABEL_17;
    }

    uint64_t v33 = v52;
    if (v46 < v52)
    {
      __int128 v47 = *(char **)(v8 + 32);
      goto LABEL_72;
    }

    if (v52) {
      uint64_t v33 = 2 * v52;
    }
    else {
      uint64_t v33 = 32LL;
    }
    if ((unint64_t)(16 * v33) >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_84:
      *(void *)(v8 + 32) = 0LL;
      size_t v22 = *__error();
      uint64_t v23 = "malloc";
      uint64_t v24 = 154;
      goto LABEL_18;
    }

    uint64_t v48 = *(void **)(v8 + 32);
    __int128 v47 = (char *)realloc(v48, 16 * v33);
    if (!v47)
    {
      free(v48);
      goto LABEL_84;
    }

    *(void *)(v8 + 32) = v47;
    uint64_t v46 = *(void *)(v8 + 24);
    int v44 = v54;
LABEL_72:
    *(void *)(v8 + 24) = v46 + 1;
    uint64_t v49 = &v47[16 * v46];
    *(void *)uint64_t v49 = v44;
    *((_DWORD *)v49 + 2) = v42;
    *((_DWORD *)v49 + 3) = v41;
    uint64_t v27 = v41 + v45;
    if (v34 != v13) {
      continue;
    }
    break;
  }

  uint64_t v20 = v51;
  uint64_t v26 = v53;
  if (v27 < 0)
  {
    uint64_t v23 = "invalid file sizes";
    uint64_t v24 = 169;
    goto LABEL_17;
  }

LABEL_36:
  __int16 v36 = 373;
LABEL_37:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"closeWithStateProc",  v36,  131,  0,  "write state",  v11,  v12,  v45);
  uint64_t v5 = 0xFFFFFFFFLL;
LABEL_38:
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy(*(AAHeader *)(a1 + 88));
  free(*(void **)(a1 + 112));
  memset_s((void *)(a1 + 104), 0x10uLL, 0, 0x10uLL);
  int v37 = *(void (***)(void))(a1 + 128);
  if (v37)
  {
    if (*v37) {
      v37[1]();
    }
    free(v37);
  }

  uint64_t v38 = *(void (***)(void))(a1 + 136);
  if (v38)
  {
    if (*v38) {
      v38[1]();
    }
    free(v38);
  }

  memset_s((void *)a1, 0x90uLL, 0, 0x90uLL);
  free((void *)a1);
  return v5;
}

      uint64_t v14 = "encrypt signature";
      int v15 = 497;
      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v20 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) < 0x101)
    {
      __memcpy_chk();
      LODWORD(v44[0]) = v20;
      memset_s((char *)v44 + v20 + 4, 256 - v20, 0, 256 - v20);
      goto LABEL_39;
    }
  }

    uint64_t result = 0LL;
    *a2 = v35;
    return result;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeRebalance",  366,  107,  0,  "invalid imbalance: %d",  a7,  a8,  v16);
  return 0xFFFFFFFFLL;
}

    if (ftruncate(*(_DWORD *)a1, 0LL))
    {
      uint64_t v11 = *__error();
      uint64_t v9 = "ftruncate";
      uint64_t v10 = 422;
      goto LABEL_6;
    }

    if ((*(_BYTE *)(a1 + 28) & 4) != 0 || !*(_DWORD *)(a1 + 112) || 93LL * *(void *)(a1 + 8) / 0x64uLL >= v21)
    {
      if (fstat(*(_DWORD *)a1, &v43))
      {
        uint64_t v11 = *__error();
        uint64_t v9 = "fstat";
        uint64_t v10 = 465;
        goto LABEL_6;
      }

      if (fchflags(*(_DWORD *)a1, v43.st_flags | 0x20) < 0)
      {
        uint64_t v11 = *__error();
        uint64_t v9 = "fchflags UF_COMPRESSED";
        uint64_t v10 = 466;
        goto LABEL_6;
      }
    }

    else
    {
      if (*(_DWORD *)(a1 + 32))
      {
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        while (1)
        {
          uint64_t v26 = (u_int32_t *)(*(void *)(a1 + 40) + 4 * v24);
          uint64_t v27 = v26[1];
          uint64_t v28 = v27 - *v26;
          if (v27 == *v26 || v28 >= 0x10002)
          {
            uint64_t v9 = "Invalid chunk size";
            uint64_t v10 = 437;
            goto LABEL_5;
          }

          if (fgetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(void **)(a1 + 64), v27 - *v26, *v26, 32) != v28)
          {
            uint64_t v9 = "reading chunk";
            uint64_t v10 = 440;
            goto LABEL_5;
          }

          uint64_t v30 = *(const uint8_t **)(a1 + 64);
          if (*v30 == *(unsigned __int8 *)(a1 + 24))
          {
            uint64_t v31 = (v28 - 1);
            memcpy(*(void **)(a1 + 80), v30 + 1, v31);
          }

          else
          {
            uint64_t v31 = compression_decode_buffer( *(uint8_t **)(a1 + 80),  0x10000uLL,  v30,  v28,  *(void **)(a1 + 88),  (compression_algorithm)*(_DWORD *)(a1 + 20));
          }

          if (v31 != 0x10000)
          {
            if (!v31)
            {
              uint64_t v9 = "Decompression";
              uint64_t v10 = 451;
              goto LABEL_5;
            }

            if (v31 + v25 != *(void *)(a1 + 8)) {
              break;
            }
          }

          if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), v31, v25) != v31)
          {
            uint64_t v9 = "writing chunk";
            uint64_t v10 = 454;
            goto LABEL_5;
          }

          ++v24;
          v25 += v31;
        }

        uint64_t v9 = "Invalid uncompressed chunk size";
        uint64_t v10 = 452;
        goto LABEL_5;
      }

    __int16 v36 = 26;
LABEL_37:
    uint64_t v27 = 1;
LABEL_38:
    if (v36 == 27)
    {
      closedir(v26);
      if (v27) {
        goto LABEL_90;
      }
LABEL_100:
      uint64_t v14 = "Directory expansion";
      int v15 = 211;
      goto LABEL_101;
    }
  }

  if (*__error() != 11)
  {
    unint64_t v69 = *__error();
    uint64_t v67 = "readdir_r";
    unsigned int v68 = 144;
LABEL_98:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"expandDirThreadProc",  v68,  60,  v69,  v67,  v28,  v29,  (char)v73);
LABEL_99:
    closedir(v26);
    goto LABEL_100;
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"expandDirThreadProc",  143,  60,  "readdir on dataless directory: %s",  v63,  v64,  v65,  (char)v82);
LABEL_88:
  closedir(v26);
LABEL_90:
  if (!**(_DWORD **)(v8 + 32))
  {
    uint64_t v17 = v75;
    compression_algorithm v19 = v16 + 1;
    goto LABEL_21;
  }

  uint64_t v14 = "Abort requested";
  int v15 = 212;
LABEL_101:
  unint64_t v66 = 0;
LABEL_102:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"expandDirThreadProc",  v15,  60,  v66,  v14,  v11,  v12,  (char)v73);
  size_t v70 = *(unsigned int **)(v8 + 32);
  do
    AAFieldKey v71 = __ldaxr(v70);
  while (__stlxr(v71 + 1, v70));
  return 0LL;
}

    uint64_t v14 = 0;
    uint64_t v12 = 1;
    if ((v17 & 1) != 0) {
      continue;
    }
    break;
  }

  *int v8 = 0LL;
  if ((__smax & 0x8000000000000000LL) != 0) {
    goto LABEL_77;
  }
  uint64_t v32 = *v13;
  if (*v13 < __smax)
  {
    uint64_t v33 = 0x4000LL;
    do
    {
      while (!v32)
      {
        uint64_t v32 = 0x4000LL;
        if (__smax <= 0x4000) {
          goto LABEL_50;
        }
      }

      uint64_t v34 = v32 >> 1;
      if ((v32 & (v32 >> 1)) != 0) {
        uint64_t v34 = v32 & (v32 >> 1);
      }
      v32 += v34;
    }

    while (v32 < __smax);
    uint64_t v33 = v32;
    if (v32 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_76;
    }

    uint64_t v14 = 0;
    uint64_t v12 = 1;
    if ((v17 & 1) != 0) {
      continue;
    }
    break;
  }

  *int v8 = 0LL;
  if ((__smax & 0x8000000000000000LL) != 0) {
    goto LABEL_81;
  }
  uint64_t v32 = *v13;
  if (*v13 < __smax)
  {
    uint64_t v33 = 0x4000LL;
    do
    {
      while (!v32)
      {
        uint64_t v32 = 0x4000LL;
        if (__smax <= 0x4000) {
          goto LABEL_50;
        }
      }

      uint64_t v34 = v32 >> 1;
      if ((v32 & (v32 >> 1)) != 0) {
        uint64_t v34 = v32 & (v32 >> 1);
      }
      v32 += v34;
    }

    while (v32 < __smax);
    uint64_t v33 = v32;
    if (v32 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_80;
    }

uint64_t writeProc( void **a1, _WORD *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (unsigned int *)(a1 + 1);
  int v14 = *((_DWORD *)a1 + 8);
  if (v14 == 4)
  {
    uint64_t v10 = 0LL;
LABEL_6:
    if (a3 && !v10)
    {
      int v15 = "no more writes possible";
      __int16 v16 = 325;
      goto LABEL_193;
    }

LABEL_172:
    if (v10 < 1)
    {
LABEL_177:
      if (v10 < 0) {
        goto LABEL_195;
      }
    }

    else
    {
      unint64_t v102 = (unint64_t)a1[6];
      if (v102 + 1 >= 2)
      {
        size_t v103 = a1[3];
        if (v103)
        {
          if ((((uint64_t (*)(void *, _WORD *, float))v103)( a1[2],  __src,  (float)((float)(unint64_t)a1[7] * 100.0) / (float)v102) & 0x80000000) != 0)
          {
            int v15 = "user cancelled in progress callback";
            __int16 v16 = 335;
            goto LABEL_193;
          }
        }
      }
    }

    return v10;
  }

  uint64_t v17 = __src;
  uint64_t v10 = 0LL;
  uint64_t v18 = (unint64_t *)(a1 + 8);
  size_t v107 = (unsigned int *)(a1 + 13);
  while (2)
  {
    unint64_t v19 = *v18;
    if (!(*v18 | a3))
    {
      if (a1[7] >= a1[6]) {
        *((_DWORD *)a1 + 8) = 4;
      }
      goto LABEL_172;
    }

    switch(v14)
    {
      case 0:
        if (a1[7] >= a1[6])
        {
          *((_DWORD *)a1 + 8) = 4;
          goto LABEL_6;
        }

        if (v19 <= 5)
        {
          uint64_t v20 = 6LL;
          goto LABEL_22;
        }

        __srCC_SHA256_CTX c = a1[10];
        int v113 = *(_DWORD *)__src;
        unsigned __int16 v114 = __src[2];
        if (v113 != 825246017 && v113 != 826360153)
        {
          int v15 = "invalid header magic";
          __int16 v16 = 120;
          goto LABEL_193;
        }

        if (v114 <= 5uLL)
        {
          int v15 = "invalid header size";
          __int16 v16 = 122;
          goto LABEL_193;
        }

        size_t v25 = v114 - v19;
        if (v114 <= v19)
        {
          if (v114 != v19)
          {
            int v15 = "invalid state";
            __int16 v16 = 127;
            goto LABEL_193;
          }

          if ((aaHeaderInitWithEncodedData((uint64_t)a1[11], __src, v19) & 0x80000000) != 0
            || (aaHeaderBlobArrayInitWithHeader((uint64_t)v107, (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
          {
            int v15 = "invalid header";
            __int16 v16 = 130;
            goto LABEL_193;
          }

          uint64_t v111 = 0LL;
          uint64_t value = 0LL;
          uint64_t size = 0LL;
          uint64_t v110 = 0LL;
          uint64_t offset = 0LL;
          v64.uint64_t ikey = 5265748;
          uint64_t v65 = (AAHeader_impl *)a1[11];
          uint32_t KeyIndex = AAHeaderGetKeyIndex(v65, v64);
          if ((KeyIndex & 0x80000000) != 0
            || ((unsigned int FieldUInt = AAHeaderGetFieldUInt(v65, KeyIndex, &value), FieldUInt <= 1)
              ? (int v68 = 1)
              : (int v68 = FieldUInt),
                v68 <= 0))
          {
            int v15 = "missing TYP field";
            __int16 v16 = 137;
            goto LABEL_193;
          }

          unint64_t v69 = (AAHeader_impl *)a1[11];
          v70.uint64_t ikey = 5263193;
          uint32_t v71 = AAHeaderGetKeyIndex(v69, v70);
          if ((v71 & 0x80000000) != 0
            || ((v72 = AAHeaderGetFieldUInt(v69, v71, &v111), v72 <= 1) ? (int v73 = 1) : (int v73 = v72), v73 <= 0))
          {
            uint64_t v111 = 0LL;
          }

          AAFieldKey v74 = (AAHeader_impl *)a1[11];
          v75.uint64_t ikey = 5521732;
          uint32_t v76 = AAHeaderGetKeyIndex(v74, v75);
          if ((v76 & 0x80000000) != 0)
          {
            int v78 = 0;
          }

          else
          {
            unsigned int FieldBlob = AAHeaderGetFieldBlob(v74, v76, &size, &offset);
            if (FieldBlob <= 1) {
              int v78 = 1;
            }
            else {
              int v78 = FieldBlob;
            }
          }

          int v87 = (AAHeader_impl *)a1[11];
          v88.uint64_t ikey = 5915721;
          uint32_t v89 = AAHeaderGetKeyIndex(v87, v88);
          if ((v89 & 0x80000000) == 0)
          {
            unsigned int v90 = AAHeaderGetFieldUInt(v87, v89, &v110);
            int v91 = v90 <= 1 ? 1 : v90;
            if (v91 >= 1) {
              a1[5] = (void *)((char *)a1[5] + v110);
            }
          }

          a1[8] = 0LL;
          *((_DWORD *)a1 + 24) = 0;
          if (v78 >= 1 && value == 77 && v111 && v111 != 80)
          {
            unint64_t v92 = aaHeaderBlobArrayPayloadSize(v107);
            if (v92 != size)
            {
              int v15 = "invalid AssetArchive, extra blobs";
              __int16 v16 = 151;
              goto LABEL_193;
            }

            if (v92 <= 3)
            {
              int v15 = "invalid AssetArchive DAT blob size";
              __int16 v16 = 152;
              goto LABEL_193;
            }

            v93.uint64_t ikey = 5521732;
            uint32_t v94 = AAHeaderGetKeyIndex((AAHeader)a1[11], v93);
            if ((v94 & 0x80000000) != 0
              || AAHeaderRemoveField((AAHeader)a1[11], v94) < 0
              || (aaHeaderBlobArrayInitWithHeader((uint64_t)v107, (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
            {
              int v15 = "removing DAT";
              __int16 v16 = 160;
              goto LABEL_193;
            }

            v95.uint64_t ikey = 5328729;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v95, v111) < 0)
            {
              int v15 = "append YOQ";
              __int16 v16 = 162;
              goto LABEL_193;
            }

            v96.uint64_t ikey = 5263193;
            uint32_t v97 = AAHeaderGetKeyIndex((AAHeader)a1[11], v96);
            if ((v97 & 0x80000000) != 0)
            {
              int v15 = "invalid index";
              __int16 v16 = 164;
              goto LABEL_193;
            }

            v98.uint64_t ikey = 5263193;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], v97, v98, 0x5BuLL) < 0)
            {
              int v15 = "set YOP";
              __int16 v16 = 165;
              goto LABEL_193;
            }

            size_t v99 = (uint64_t (*)(void, void *))(*a1)[4];
            if (!v99 || (v99(**a1, a1[11]) & 0x80000000) != 0)
            {
              int v15 = "header processing";
              __int16 v16 = 167;
              goto LABEL_193;
            }

            a1[15] = (void *)size;
            int v100 = 2;
          }

          else
          {
            size_t v101 = (uint64_t (*)(void, void *))(*a1)[4];
            if (!v101 || (v101(**a1, a1[11]) & 0x80000000) != 0)
            {
              int v15 = "header processing";
              __int16 v16 = 175;
              goto LABEL_193;
            }

            int v100 = 1;
          }

          *((_DWORD *)a1 + 8) = v100;
        }

        else if (v114 != v19)
        {
          goto LABEL_23;
        }

        goto LABEL_164;
      case 1:
        unint64_t v21 = *((unsigned int *)a1 + 26);
        unint64_t v22 = *((unsigned int *)a1 + 24);
        if (v22 >= v21) {
          goto LABEL_95;
        }
        uint64_t v23 = &a1[14][3 * v22 + 1];
        while (1)
        {
          uint64_t v24 = *v23;
          v23 += 3;
          if (v24) {
            break;
          }
          *((_DWORD *)a1 + 24) = ++v22;
          if (v21 == v22) {
            goto LABEL_137;
          }
        }

        unint64_t v22 = v22;
LABEL_95:
        if (v22 == v21) {
          goto LABEL_137;
        }
        uint64_t v57 = a1[14];
        AAFieldKey v58 = &v57[3 * v22];
        size_t v61 = v58[1];
        uint64_t v60 = v58 + 1;
        size_t v59 = v61;
        if (a3 >= v61) {
          size_t v62 = v59;
        }
        else {
          size_t v62 = a3;
        }
        uint64_t v63 = (uint64_t (*)(void, void, _WORD *, size_t))(*a1)[5];
        if (!v63 || (v63(**a1, LODWORD(v57[3 * v22]), v17, v62) & 0x80000000) != 0)
        {
          int v15 = "blob processing";
          __int16 v16 = 202;
          goto LABEL_193;
        }

        *v60 -= v62;
        a3 -= v62;
        uint64_t v17 = (_WORD *)((char *)v17 + v62);
        v10 += v62;
        a1[7] = (void *)((char *)a1[7] + v62);
        goto LABEL_164;
      case 2:
        if (v19 > 3)
        {
          int v47 = *(_DWORD *)a1[10];
          LODWORD(value) = v47;
          if (v47 != 825246017 && v47 != 826360153)
          {
            BOOL v49 = (unsigned __int16)value == 25200 && BYTE2(value) == 122;
            if (!v49
              || ((int v50 = v47 >> 24, ((v47 >> 24) - 45) <= 0x39)
                ? (BOOL v51 = ((1LL << (HIBYTE(v47) - 45)) & 0x320000000000081LL) == 0)
                : (BOOL v51 = 1),
                  v51 && v50 != 120 && v50 != 122))
            {
              int v15 = "invalid DAT blob";
              __int16 v16 = 227;
              goto LABEL_193;
            }
          }

          uint64_t v52 = aaAssetDecodeStreamOpen(*a1);
          a1[17] = (void *)v52;
          if (!v52)
          {
            int v15 = "dat decoder stream";
            __int16 v16 = 231;
            goto LABEL_193;
          }

          if (v47 == 825246017 || v47 == 826360153)
          {
            BOOL v79 = a1[16];
            if (!v79) {
              BOOL v79 = a1[17];
            }
          }

          else
          {
            BOOL v79 = aaAssetDecompressionStreamOpen(v52);
            a1[16] = v79;
            if (!v79)
            {
              int v15 = "dat decompression stream";
              __int16 v16 = 237;
              goto LABEL_193;
            }
          }

          char v80 = (uint64_t (*)(void, uint64_t *, uint64_t))v79[3];
          if (!v80 || v80(*v79, &value, 4LL) != 4)
          {
            int v15 = "sending dat magic";
            __int16 v16 = 241;
            goto LABEL_193;
          }

          a1[15] = (void *)((char *)a1[15] - 4);
          a1[8] = 0LL;
          int v14 = 3;
          *((_DWORD *)a1 + 8) = 3;
LABEL_165:
          if (v14 == 4) {
            goto LABEL_6;
          }
          continue;
        }

        uint64_t v20 = 4LL;
LABEL_22:
        size_t v25 = v20 - v19;
LABEL_23:
        if (!a3) {
          goto LABEL_177;
        }
        if (v25 >= a3) {
          size_t v26 = a3;
        }
        else {
          size_t v26 = v25;
        }
        unint64_t v27 = v19 + v26;
        if (__CFADD__(v19, v26) || (v27 & 0x8000000000000000LL) != 0) {
          goto LABEL_192;
        }
        unint64_t v28 = (unint64_t)a1[9];
        if (v28 >= v27) {
          goto LABEL_88;
        }
        do
        {
          while (!v28)
          {
            unint64_t v28 = 0x4000LL;
            size_t v30 = 0x4000LL;
            if (v27 <= 0x4000) {
              goto LABEL_86;
            }
          }

          unint64_t v29 = v28 >> 1;
          if ((v28 & (v28 >> 1)) != 0) {
            unint64_t v29 = v28 & (v28 >> 1);
          }
          v28 += v29;
        }

        while (v28 < v27);
        size_t v30 = v28;
        if (v28 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_191;
        }

LABEL_86:
        BOOL v54 = a1[10];
        uint64_t v55 = realloc(v54, v30);
        if (v55)
        {
          a1[9] = (void *)v30;
          a1[10] = v55;
LABEL_88:
          uint64_t v56 = a1[10];
          if (v17)
          {
            memcpy((char *)v56 + *v18, v17, v26);
          }

          else if (v56)
          {
            memset_s((char *)v56 + *v18, v26, 0, v26);
          }

          *v18 += v26;
          if ((v26 & 0x8000000000000000LL) != 0) {
            goto LABEL_192;
          }
          a3 -= v26;
          uint64_t v17 = (_WORD *)((char *)v17 + v26);
          v10 += v26;
          a1[7] = (void *)((char *)a1[7] + v26);
LABEL_164:
          int v14 = *((_DWORD *)a1 + 8);
          goto LABEL_165;
        }

        free(v54);
LABEL_191:
        *uint64_t v18 = 0LL;
        a1[9] = 0LL;
        a1[10] = 0LL;
LABEL_192:
        int v15 = "malloc";
        __int16 v16 = 314;
LABEL_193:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"writeProc",  v16,  131,  0,  v15,  a7,  a8,  v106);
LABEL_194:
        uint64_t v10 = -1LL;
        do
        {
LABEL_195:
          if (__ldaxr(v8))
          {
            __clrex();
            return v10;
          }
        }

        while (__stlxr(1u, v8));
        v105 = (void (*)(void))(*a1)[2];
        if (v105) {
          v105(**a1);
        }
        return v10;
      case 3:
        uint64_t v31 = a1[15];
        else {
          uint64_t v32 = (void *)a3;
        }
        if (!v32) {
          goto LABEL_46;
        }
        uint64_t v33 = a1[16];
        if (!v33) {
          uint64_t v33 = a1[17];
        }
        uint64_t v34 = (uint64_t (*)(void, _WORD *))v33[3];
        if (!v34 || (uint64_t v35 = v34(*v33, v17), v35 < 0))
        {
          int v15 = "writing DAT bytes";
          __int16 v16 = 255;
          goto LABEL_193;
        }

        a3 -= v35;
        uint64_t v17 = (_WORD *)((char *)v17 + v35);
        v10 += v35;
        a1[7] = (void *)((char *)a1[7] + v35);
        uint64_t v31 = (void *)((char *)a1[15] - v35);
        a1[15] = v31;
LABEL_46:
        if (v31) {
          goto LABEL_164;
        }
        uint64_t value = 0LL;
        __int16 v36 = (AAHeader_impl *)a1[11];
        v37.uint64_t ikey = 5328729;
        uint32_t v38 = AAHeaderGetKeyIndex(v36, v37);
        if ((v38 & 0x80000000) == 0)
        {
          unsigned int v39 = AAHeaderGetFieldUInt(v36, v38, &value);
          int v40 = v39 <= 1 ? 1 : v39;
          if (v40 >= 1 && value == 77)
          {
            __int16 v41 = a1[17];
            if (v41)
            {
              uint64_t v42 = *(void *)(*v41 + 40LL);
              __int16 v43 = a1[7];
              a1[6] = (void *)((char *)v43 + v42);
              if (__CFADD__(v43, v42))
              {
                int v15 = "invalid sizes in manifest";
                __int16 v16 = 274;
                goto LABEL_193;
              }
            }
          }
        }

        int v44 = (uint64_t (**)(void))a1[16];
        if (!v44) {
          goto LABEL_126;
        }
        if (*v44)
        {
          int v45 = v44[1]();
          free(v44);
          BOOL v46 = v45 >= 0;
        }

        else
        {
          free(a1[16]);
LABEL_126:
          BOOL v46 = 1;
        }

        a1[16] = 0LL;
        unsigned int v81 = (uint64_t (**)(void))a1[17];
        if (!v81) {
          goto LABEL_132;
        }
        if (*v81)
        {
          int v82 = v81[1]();
          free(v81);
          if (v82 < 0)
          {
            a1[17] = 0LL;
LABEL_207:
            int v15 = "dat archive invalid";
            __int16 v16 = 282;
            goto LABEL_193;
          }
        }

        else
        {
          free(a1[17]);
        }

    ++v30;
  }

  while (v29 != v30);
  if (v73 && (sendHeader(a1) & 0x80000000) != 0)
  {
    AAFieldKey v70 = "sending header";
    uint32_t v71 = 392;
    goto LABEL_132;
  }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateCollectorStreamWriteBlob",  v19,  27,  0,  v18,  a7,  a8,  v38);
    return 0xFFFFFFFFLL;
  }

LABEL_132:
        a1[17] = 0LL;
        if (!v46) {
          goto LABEL_207;
        }
        v83.uint64_t ikey = 5263193;
        uint32_t v84 = AAHeaderGetKeyIndex((AAHeader)a1[11], v83);
        if ((v84 & 0x80000000) != 0)
        {
          int v15 = "invalid index";
          __int16 v16 = 288;
          goto LABEL_193;
        }

        v85.uint64_t ikey = 5263193;
        if (AAHeaderSetFieldUInt((AAHeader)a1[11], v84, v85, 0x5DuLL) < 0)
        {
          int v15 = "set YOP";
          __int16 v16 = 289;
          goto LABEL_193;
        }

        uint64_t v86 = (uint64_t (*)(void, void *))(*a1)[4];
        if (!v86 || (v86(**a1, a1[11]) & 0x80000000) != 0)
        {
          int v15 = "header processing";
          __int16 v16 = 291;
          goto LABEL_193;
        }

          free(v48);
        }

        *uint64_t v42 = 0LL;
        v42[1] = 0LL;
        v42[2] = 0LL;
        goto LABEL_135;
      }

      __int16 v43 = v44;
    }

    int v47 = v44;
LABEL_63:
    if (v47 - v43 >= v40) {
      int v50 = v40;
    }
    else {
      int v50 = v47 - v43;
    }
    BOOL v51 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 152) + v43), v50);
    if (v51 < 0) {
      goto LABEL_135;
    }
    if (!v51) {
      break;
    }
    __int16 v43 = *v42 + v51;
    if (__CFADD__(*v42, v51)) {
      goto LABEL_135;
    }
    int v44 = *((void *)v9 + 151);
    if (v43 > v44) {
      goto LABEL_135;
    }
    *uint64_t v42 = v43;
    v41 += v51;
    v40 -= v51;
  }

  while (v40);
  if (v41 < 0) {
    goto LABEL_135;
  }
LABEL_72:
  uint64_t v52 = v80;
  if (!(void)v80) {
    goto LABEL_98;
  }
  BOOL v53 = 0LL;
  uint64_t v42 = (unint64_t *)((char *)v9 + 1224);
  BOOL v54 = *((void *)v9 + 153);
  uint64_t v55 = *((void *)v9 + 154);
  while (2)
  {
    if (v54 != v55) {
      goto LABEL_85;
    }
    uint64_t v56 = v55 + 0x40000;
    if (v55 > 0xFFFFFFFFFFFBFFFFLL)
    {
      BOOL v54 = v55;
LABEL_85:
      AAFieldKey v58 = v55;
      goto LABEL_89;
    }

    do
    {
      while (!v55)
      {
        uint64_t v55 = 0x4000LL;
        AAFieldKey v58 = 0x4000LL;
        if (v56 <= 0x4000) {
          goto LABEL_87;
        }
      }

      uint64_t v57 = v55 >> 1;
      if ((v55 & (v55 >> 1)) != 0) {
        uint64_t v57 = v55 & (v55 >> 1);
      }
      v55 += v57;
    }

    while (v55 < v56);
    AAFieldKey v58 = v55;
    if (v55 >= 0x2000000001LL) {
      goto LABEL_133;
    }
LABEL_87:
    uint64_t v48 = (void *)*((void *)v9 + 155);
    size_t v59 = realloc(v48, v58);
    if (!v59) {
      goto LABEL_132;
    }
    *((void *)v9 + 155) = v59;
    *((void *)v9 + 154) = v58;
    BOOL v54 = *((void *)v9 + 153);
LABEL_89:
    if (v58 - v54 >= v52) {
      uint64_t v60 = v52;
    }
    else {
      uint64_t v60 = v58 - v54;
    }
    size_t v61 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 155) + v54), v60);
    if (v61 < 0) {
      goto LABEL_135;
    }
    if (!v61) {
      break;
    }
    BOOL v54 = *v42 + v61;
    if (__CFADD__(*v42, v61)) {
      goto LABEL_135;
    }
    uint64_t v55 = *((void *)v9 + 154);
    if (v54 > v55) {
      goto LABEL_135;
    }
    *uint64_t v42 = v54;
    v53 += v61;
    v52 -= v61;
    if (v52) {
      continue;
    }
    break;
  }

  if (v53 < 0) {
    goto LABEL_135;
  }
LABEL_98:
  size_t v62 = *((void *)&v80 + 1);
  if (!*((void *)&v80 + 1)) {
    goto LABEL_124;
  }
  uint64_t v63 = 0LL;
  uint64_t v42 = (unint64_t *)((char *)v9 + 1248);
  AAFieldKey v64 = *((void *)v9 + 156);
  uint64_t v65 = *((void *)v9 + 157);
  while (2)
  {
    if (v64 != v65)
    {
LABEL_111:
      int v68 = v65;
      goto LABEL_115;
    }

    unint64_t v66 = v65 + 0x40000;
    if (v65 > 0xFFFFFFFFFFFBFFFFLL)
    {
      AAFieldKey v64 = v65;
      goto LABEL_111;
    }

    do
    {
      while (!v65)
      {
        uint64_t v65 = 0x4000LL;
        int v68 = 0x4000LL;
        if (v66 <= 0x4000) {
          goto LABEL_113;
        }
      }

      uint64_t v67 = v65 >> 1;
      if ((v65 & (v65 >> 1)) != 0) {
        uint64_t v67 = v65 & (v65 >> 1);
      }
      v65 += v67;
    }

    while (v65 < v66);
    int v68 = v65;
    if (v65 >= 0x2000000001LL) {
      goto LABEL_133;
    }
LABEL_113:
    uint64_t v48 = (void *)*((void *)v9 + 158);
    unint64_t v69 = realloc(v48, v68);
    if (!v69) {
      goto LABEL_132;
    }
    *((void *)v9 + 158) = v69;
    *((void *)v9 + 157) = v68;
    AAFieldKey v64 = *((void *)v9 + 156);
LABEL_115:
    if (v68 - v64 >= v62) {
      AAFieldKey v70 = v62;
    }
    else {
      AAFieldKey v70 = v68 - v64;
    }
    uint32_t v71 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 158) + v64), v70);
    if (v71 < 0) {
      goto LABEL_135;
    }
    if (v71)
    {
      AAFieldKey v64 = *v42 + v71;
      if (__CFADD__(*v42, v71)) {
        goto LABEL_135;
      }
      uint64_t v65 = *((void *)v9 + 157);
      if (v64 > v65) {
        goto LABEL_135;
      }
      *uint64_t v42 = v64;
      v63 += v71;
      v62 -= v71;
      if (v62) {
        continue;
      }
    }

    break;
  }

  if (v63 < 0) {
    goto LABEL_135;
  }
LABEL_124:
  unsigned int v72 = DWORD1(v79);
  *((_DWORD *)v9 + 170) = v79;
  *((_DWORD *)v9 + 235) = v72;
  int v73 = *((_DWORD *)v9 + 318);
  memset(&__s[1], 0, 252);
  int v82 = 0;
  LOWORD(__s[1]) = 19267;
  __s[0] = 0x5F41454100000006LL;
  memset(&v81[2], 0, 256);
  uint64_t result = (void (**)(void))memset_s((char *)&__s[1] + 2, 0xFAuLL, 0, 0xFAuLL);
  AAFieldKey v74 = LODWORD(__s[0]);
  if (LODWORD(__s[0]) >= 0xFD)
  {
    __break(1u);
    return result;
  }

  *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v73;
  LODWORD(__s[0]) = v74 + 4;
  memset_s((char *)&__s[1] + v74, 252 - v74, 0, 252 - v74);
  AAFieldKey v75 = (uint64_t (*)(char *, void))*((void *)v9 + 13);
  if (!v75 || !*((_DWORD *)v9 + 170))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    goto LABEL_131;
  }

  uint32_t v76 = v75((char *)v9 + 416, *v22);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v76 < 0)
  {
LABEL_131:
    size_t v30 = "invalid state";
    uint64_t v31 = 533;
    goto LABEL_26;
  }

  if (a3) {
    *a3 = *((void *)v9 + 162);
  }
  return v8;
}

LABEL_137:
        AAHeaderClear((AAHeader)a1[11]);
        int v14 = 0;
        *((_DWORD *)a1 + 26) = 0;
        *((_DWORD *)a1 + 8) = 0;
        goto LABEL_165;
      default:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"writeProc",  304,  131,  0,  "invalid state %d",  a7,  a8,  v14);
        goto LABEL_194;
    }
  }

          int v8 = v16;
          if (!v10) {
            return v8;
          }
          break;
        case 2:
          *(void *)(a1 + 328) = v32;
          *(void *)(a1 + 336) = v21;
          *(void *)(a1 + 312) = v34;
          *(void *)(a1 + 320) = v33;
          uint64_t v42 = compression_stream_process((compression_stream *)(a1 + 312), *(_DWORD *)(a1 + 60) != 0);
          if (v42 < 0)
          {
            uint32_t v76 = "decoding compression payload";
            uint64_t v77 = 162;
            goto LABEL_154;
          }

          __int16 v43 = v42;
          int v44 = v15;
          int v45 = *(void *)(a1 + 336);
          BOOL v46 = *(void *)(a1 + 320);
          int v47 = v21 - v45;
          if (v21 != v45)
          {
            uint64_t v48 = *v83 - v47;
            if (*v83 >= v47)
            {
              if (*v83 != v47)
              {
                char v80 = *v83 - v47;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v47), v48);
                uint64_t v48 = v80;
              }

              *AAFieldKey v83 = v48;
            }
          }

          if (v33 != v46)
          {
            BOOL v49 = *(void *)(a1 + 32);
            int v50 = v49 + v33 - v46;
            if (!__CFADD__(v49, v33 - v46) && v50 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v50;
            }
          }

          if (v33 == v46 && v21 == v45) {
            int v15 = v44 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v43 != COMPRESSION_STATUS_END) {
            goto LABEL_136;
          }
          goto LABEL_120;
        case 3:
          *(void *)(a1 + 176) = v32;
          *(void *)(a1 + 184) = v21;
          *(void *)(a1 + 200) = v34;
          *(void *)(a1 + 208) = v33;
          uint64_t v52 = lzma_code();
          BOOL v53 = v52;
          if (v52 <= 0xA && ((1 << v52) & 0x403) != 0)
          {
            BOOL v54 = v15;
            uint64_t v55 = *(unint64_t **)(a1 + 176);
            uint64_t v56 = *(_BYTE **)(a1 + 200);
            uint64_t v57 = (char *)v55 - (char *)v32;
            if (v55 != v32)
            {
              AAFieldKey v58 = *v83 - v57;
              if (*v83 >= v57)
              {
                if (*v83 != v57)
                {
                  unsigned int v81 = *v83 - v57;
                  memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v57), v58);
                  AAFieldKey v58 = v81;
                }

                *AAFieldKey v83 = v58;
              }
            }

            if (v56 != v34)
            {
              size_t v59 = *(void *)(a1 + 32);
              uint64_t v60 = v59 + v56 - v34;
              if (!__CFADD__(v59, v56 - v34) && v60 <= *(void *)(a1 + 40)) {
                *(void *)(a1 + 32) = v60;
              }
            }

            if (v56 == v34 && v55 == v32) {
              int v15 = v54 + 1;
            }
            else {
              int v15 = 0;
            }
            if (v53 == 1) {
              goto LABEL_120;
            }
          }

          else
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c",  (uint64_t)"aaDecompressionStreamRead",  194,  20,  0,  "decoding lzma payload",  a7,  a8,  v78);
          }

          int v8 = -1LL;
          if (v53 <= 0xA && ((1 << v53) & 0x403) != 0) {
            goto LABEL_136;
          }
          return v8;
        case 4:
          *(void *)(a1 + 96) = v32;
          *(_DWORD *)(a1 + 104) = v21;
          *(void *)(a1 + 120) = v34;
          *(_DWORD *)(a1 + 128) = v33;
          size_t v62 = BZ2_bzDecompress((bz_stream *)(a1 + 96));
          if (v62 < 0)
          {
            uint32_t v76 = "decoding bzip2 payload";
            uint64_t v77 = 178;
            goto LABEL_154;
          }

          uint64_t v63 = v62;
          AAFieldKey v64 = v15;
          uint64_t v65 = *(unint64_t **)(a1 + 96);
          unint64_t v66 = *(_BYTE **)(a1 + 120);
          uint64_t v67 = (char *)v65 - (char *)v32;
          if (v65 != v32)
          {
            int v68 = *v83 - v67;
            if (*v83 >= v67)
            {
              if (*v83 != v67)
              {
                int v82 = *v83 - v67;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v67), v68);
                int v68 = v82;
              }

              *AAFieldKey v83 = v68;
            }
          }

          if (v66 != v34)
          {
            unint64_t v69 = *(void *)(a1 + 32);
            AAFieldKey v70 = v69 + v66 - v34;
            if (!__CFADD__(v69, v66 - v34) && v70 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v70;
            }
          }

          if (v66 == v34 && v65 == v32) {
            int v15 = v64 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v63 != 4) {
            goto LABEL_136;
          }
          goto LABEL_120;
        default:
          return -1LL;
      }

      goto LABEL_11;
    }
  }

  free(v27);
LABEL_152:
  *AAFieldKey v83 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  int v8 = -1LL;
  *(void *)(a1 + 24) = 0LL;
LABEL_141:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c",  (uint64_t)"aaDecompressionStreamRead",  144,  20,  0,  "stream read failed",  a7,  a8,  v78);
  return v8;
}

void **cancelProc(void **result)
{
  uint64_t v1 = (unsigned int *)(result + 1);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v1));
  uint64_t v3 = (uint64_t (*)(void))(*result)[2];
  if (v3) {
    return (void **)v3(**result);
  }
  return result;
}

void (**aaAssetDecodeStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  unint64_t __s = 0LL;
  size_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v5 = (void (**)(void))aaAssetDecodeStreamOpen(a1);
  int v8 = v5;
  if (v5)
  {
    uint64_t v9 = *v5;
    memset(v52, 0, 58);
    if (*((void *)a2 + 2))
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = v52;
      uint64_t v12 = 58LL;
      while (1)
      {
        uint64_t v13 = (*((uint64_t (**)(void, _OWORD *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
        if (v13 < 0) {
          break;
        }
        if (v13)
        {
          uint64_t v11 = (_OWORD *)((char *)v11 + v13);
          v10 += v13;
          v12 -= v13;
          if (v12) {
            continue;
          }
        }

        if (v10 != 58) {
          break;
        }
        int v14 = DWORD1(v52[0]);
        *((_DWORD *)v9 + 8) = v52[0];
        *((_DWORD *)v9 + 24) = v14;
        *(_OWORD *)((char *)v9 + 40) = *(_OWORD *)((char *)v52 + 8);
        uint64_t v15 = *(void *)&v52[2];
        *((void *)v9 + 7) = *((void *)&v52[1] + 1);
        *((void *)v9 + 15) = v15;
        size_t v16 = DWORD2(v52[2]);
        if ((DWORD2(v52[2]) - 0x10000) >= 0xFFFF0006)
        {
          uint64_t v20 = 0LL;
          unint64_t v21 = 0LL;
          size_t v22 = 0LL;
          uint64_t v23 = 0LL;
          do
          {
            if (v22 == v21)
            {
              unint64_t v24 = v21 + 0x40000;
              if (v21 <= 0xFFFFFFFFFFFBFFFFLL)
              {
                do
                {
                  while (!v21)
                  {
                    unint64_t v21 = 0x4000LL;
                    size_t v26 = 0x4000LL;
                    if (v24 <= 0x4000) {
                      goto LABEL_35;
                    }
                  }

                  unint64_t v25 = v21 >> 1;
                  if ((v21 & (v21 >> 1)) != 0) {
                    unint64_t v25 = v21 & (v21 >> 1);
                  }
                  v21 += v25;
                }

                while (v21 < v24);
                size_t v26 = v21;
                if (v21 >= 0x2000000001LL)
                {
                  *__error() = 12;
                  goto LABEL_93;
                }

LABEL_35:
                unint64_t v27 = (char *)realloc(v20, v26);
                if (v27)
                {
                  size_t v54 = v26;
                  uint64_t v55 = v27;
                  uint64_t v20 = v27;
                  goto LABEL_37;
                }

                free(v20);
LABEL_93:
                unint64_t __s = 0LL;
                size_t v54 = 0LL;
                uint64_t v55 = 0LL;
                goto LABEL_9;
              }
            }

            size_t v26 = v21;
LABEL_37:
            if (v26 - v22 >= v16) {
              size_t v28 = v16;
            }
            else {
              size_t v28 = v26 - v22;
            }
            ssize_t v29 = AAByteStreamRead(a2, &v20[v22], v28);
            if (v29 < 0) {
              goto LABEL_9;
            }
            if (!v29) {
              break;
            }
            size_t v22 = __s + v29;
            if (!__CFADD__(__s, v29))
            {
              unint64_t v21 = v54;
              if (v22 <= v54) {
                continue;
              }
            }

            goto LABEL_9;
            __s += v29;
            v23 += v29;
            v16 -= v29;
          }

          while (v16);
          if (v23 < 0) {
            goto LABEL_9;
          }
          uint64_t v18 = v55;
          size_t v30 = (_DWORD *)((char *)v9 + 104);
          if ((aaHeaderBlobArrayInitWithHeader((uint64_t)v9 + 104, *((AAHeader_impl **)v9 + 11)) & 0x80000000) != 0
            || *v30 != HIDWORD(v52[2]))
          {
            goto LABEL_9;
          }

          if (*v30)
          {
            uint64_t v31 = 0LL;
LABEL_51:
            if (*((void *)a2 + 2))
            {
              uint64_t v32 = 0LL;
              uint64_t v33 = *((void *)v9 + 14) + 24 * v31 + 8;
              uint64_t v34 = 8LL;
              while (1)
              {
                uint64_t v35 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v33, v34);
                if (v35 < 0) {
                  break;
                }
                if (v35)
                {
                  v33 += v35;
                  v32 += v35;
                  v34 -= v35;
                  if (v34) {
                    continue;
                  }
                }

                if (v32 < 0) {
                  break;
                }
                goto LABEL_58;
              }
            }

            int v50 = "invalid blob state";
            __int16 v51 = 505;
            goto LABEL_99;
          }

  unint64_t v27 = *(void (**)(void))(a2 + 32);
  if (v27) {
    v27(*(void *)(a2 + 40));
  }
  size_t v28 = *(void (**)(void))(a2 + 8);
  if (v28) {
    v28(*(void *)(a2 + 16));
  }
  ssize_t v29 = -1;
LABEL_40:
  LODWORD(result) = leaveThreadErrorContext(0LL, 0LL, 0);
  else {
    return result;
  }
}

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterApply",  v18,  130,  0,  v17,  v9,  v10,  v41);
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

  AAHeaderDestroy(header);
  free(v36);
  memset_s(&__s, 0x10uLL, 0, 0x10uLL);
  free(v10);
  return v12;
}

            size_t v28 = 1;
          }

          else
          {
LABEL_29:
            while (v23 + 8 <= v24)
            {
              unint64_t v27 = *(void *)v23;
              v23 += 8;
              if (v27) {
                goto LABEL_35;
              }
            }

            while (v23 < v24)
            {
              if (*v23) {
                goto LABEL_35;
              }
              ++v23;
            }

            size_t v28 = 0;
          }

          ssize_t v29 = *(_DWORD *)(a1 + 88) | v28;
          *(_DWORD *)(a1 + 88) = v29;
          v20 += v22;
          *(_DWORD *)(a1 + 76) = v20;
          if (v20 == (_DWORD)v19)
          {
            if (!v29)
            {
              size_t v30 = *(void *)(a1 + 80);
              uint64_t v31 = *(void *)(a1 + 56);
              if (v31
                && (uint64_t v32 = *(void *)(a1 + 64) + 24 * v31,
                    uint64_t v35 = *(void *)(v32 - 8),
                    uint64_t v33 = (void *)(v32 - 8),
                    uint64_t v34 = v35,
                    v35 + *(v33 - 1) == v30))
              {
                *uint64_t v33 = v34 + v19;
              }

              else
              {
                size_t v36 = *v48;
                if (v31 >= *v48)
                {
                  uint64_t v37 = v36 + (v36 >> 1);
                  uint32_t v38 = v36 == 0;
                  unint64_t v39 = 32LL;
                  if (!v38) {
                    unint64_t v39 = v37;
                  }
                  *(void *)(a1 + 48) = v39;
                  unint64_t v40 = reallocf(*(void **)(a1 + 64), 24 * v39);
                  *(void *)(a1 + 64) = v40;
                  if (!v40)
                  {
                    void *v48 = 0LL;
                    v48[1] = 0LL;
                    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamWrite",  994,  29,  "malloc holes failed",  a6,  a7,  a8,  v47);
                  }
                }

                unint64_t v41 = *(void *)(a1 + 56);
                if (v41 >= *(void *)(a1 + 48))
                {
                  LODWORD(v19) = *(_DWORD *)(a1 + 72);
                }

                else
                {
                  unint64_t v42 = *(void *)(a1 + 64);
                  *(void *)(a1 + 56) = v41 + 1;
                  size_t v43 = (void *)(v42 + 24 * v41);
                  *size_t v43 = 0LL;
                  v43[1] = 0LL;
                  v43[1] = v30;
                  v43[2] = 0LL;
                  unint64_t v19 = *(unsigned int *)(a1 + 72);
                  v43[2] = v19;
                }
              }
            }

            uint64_t v20 = 0;
            *(void *)(a1 + 80) += v19;
            *(_DWORD *)(a1 + 76) = 0;
            *(_DWORD *)(a1 + 88) = 0;
          }

          v18 += v22;
        }

        while (v18 < v14);
      }

      __buf += v17;
      v9 += v17;
      uint64_t v13 = *(void *)(a1 + 16) - v17;
      *(void *)(a1 + 16) = v13;
      v11 -= v17;
      if (!v11) {
        break;
      }
    }
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  *(void *)(a1 + 32) += v9;
  return v9;
}

    ++v30;
    uint64_t v10 = v61;
    a3 = v60;
    if (v30 >= v61[270]) {
      goto LABEL_36;
    }
  }

  uint64_t v32 = v65 + 440 * v30;
  if (!*(void *)(v32 + 384))
  {
    uint64_t v56 = "no chunks found";
    uint64_t v57 = 572;
    goto LABEL_42;
  }

  uint64_t v33 = v65 + 440 * v30;
  uint64_t v35 = *(void *)(v33 + 56);
  uint64_t v34 = (unint64_t *)(v33 + 56);
  *(v34 - 1) = *(void *)(v13 + 3176);
  if (!v35) {
    goto LABEL_35;
  }
  size_t v36 = 0LL;
  uint64_t v37 = 0LL;
  uint32_t v38 = (void *)(v32 + 384);
  unint64_t v39 = v65 + 440 * v30;
  unint64_t v40 = *(void *)(v39 + 392);
  unint64_t v41 = (void *)(v39 + 40);
  unint64_t v42 = (char *)(v39 + 432);
  size_t v43 = *(void **)(v13 + 3160);
  while (1)
  {
    int v44 = *v38 + v36;
    int v45 = v40 >= 0x10000 ? 0x10000LL : v40;
    size_t v46 = *(void *)v44 + *v41;
    ssize_t v47 = *(_DWORD *)(v44 + 8);
    uint64_t v48 = *v42;
    __srCC_SHA256_CTX c = *(void *)(v13 + 3176);
    *(void *)&uint64_t v67 = v45;
    *((void *)&v67 + 1) = v46;
    int v68 = v47;
    unint64_t v69 = v48;
    *(void *)(v13 + 3176) = __src + v45;
    size_t v43 = pc_array_append((uint64_t)v43, &__src, v17, v18, v19, v20, v21, v22);
    *(void *)(v13 + 3160) = v43;
    if (!v43) {
      break;
    }
    v40 -= v45;
    ++v37;
    v36 += 12LL;
    if (v37 >= *v34) {
      goto LABEL_33;
    }
  }

  uint64_t v56 = "segment_add";
  uint64_t v57 = 584;
LABEL_42:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaForkInputStreamOpen",  v57,  137,  0,  v56,  v21,  v22,  v58);
  int v8 = v59;
LABEL_16:
  free(v8);
  SegmentStreamClose(v13);
  return 0LL;
}

    *((_DWORD *)a1 + 4) = v23.st_mode & 0xFFF;
    if ((a4 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  int v17 = *__error();
  uint64_t v18 = "fstat";
  unint64_t v19 = 209;
LABEL_40:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesInitWithFD",  v19,  102,  v17,  v18,  v13,  v14,  v20);
  return 0xFFFFFFFFLL;
}

LABEL_58:
          size_t v36 = *(void *)&v52[3];
          if (*(void *)&v52[3])
          {
            uint64_t v37 = 0LL;
            uint32_t v38 = (unint64_t *)((char *)v9 + 64);
            unint64_t v40 = *((void *)v9 + 8);
            unint64_t v39 = *((void *)v9 + 9);
            do
            {
              if (v40 == v39)
              {
                unint64_t v41 = v39 + 0x40000;
                if (v39 <= 0xFFFFFFFFFFFBFFFFLL)
                {
                  do
                  {
                    while (!v39)
                    {
                      unint64_t v39 = 0x4000LL;
                      size_t v43 = 0x4000LL;
                      if (v41 <= 0x4000) {
                        goto LABEL_73;
                      }
                    }

                    unint64_t v42 = v39 >> 1;
                    if ((v39 & (v39 >> 1)) != 0) {
                      unint64_t v42 = v39 & (v39 >> 1);
                    }
                    v39 += v42;
                  }

                  while (v39 < v41);
                  size_t v43 = v39;
                  if (v39 >= 0x2000000001LL)
                  {
                    *__error() = 12;
                    goto LABEL_97;
                  }

                uint64_t v32 = (void *)*((void *)v2 + 5);
                uint64_t v33 = realloc(v32, v31);
                if (v33)
                {
                  *((void *)v2 + 4) = v31;
                  *((void *)v2 + 5) = v33;
                  goto LABEL_60;
                }

                free(v32);
LABEL_99:
                *uint64_t v13 = 0LL;
                *((void *)v2 + 4) = 0LL;
                *((void *)v2 + 5) = 0LL;
                goto LABEL_105;
              }

      int v8 = (void **)v155;
      if (v63 != v66) {
        break;
      }
LABEL_59:
      AAFieldKey v70 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        if (!v63) {
          goto LABEL_68;
        }
        uint32_t v71 = 0LL;
        unsigned int v72 = v62 + v48;
        int v73 = a1;
        AAFieldKey v74 = v63;
        while (1)
        {
          AAFieldKey v75 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v70 + 40))( *(void *)v70,  v73,  v74,  v72);
          if (v75 < 1) {
            break;
          }
          int v73 = (_DWORD *)((char *)v73 + v75);
          v71 += v75;
          v72 += v75;
          v74 -= v75;
          if (!v74) {
            goto LABEL_67;
          }
        }

        uint32_t v71 = v75;
      }

      else
      {
        uint32_t v71 = -1LL;
      }

        size_t v36 = *(void *)(a1 + 128);
        if (__src)
        {
          memcpy((void *)(v36 + *v28), __src, __smax);
        }

        else if (v36)
        {
          memset_s((void *)(v36 + *v28), __smax, 0, __smax);
        }

        *v28 += __smax;
        if ((__smax & 0x8000000000000000LL) != 0)
        {
LABEL_66:
          int v14 = "accumulating blob data";
          uint64_t v15 = 445;
          goto LABEL_9;
        }
      }

  unint64_t v25 = strlen((const char *)out);
  if ((AAEntryACLBlobAppendEntry(a1, &ace, out, v25) & 0x80000000) == 0)
  {
    acl_free(v23);
    goto LABEL_60;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobInitWithFD",  340,  100,  0,  "encoding entry",  v26,  v27,  v33);
  acl_free(v23);
LABEL_67:
  acl_free(v13);
  free(v11);
LABEL_15:
  *(void *)a1 = 0LL;
  *((void *)a1 + 3) = 0LL;
  return 0xFFFFFFFFLL;
}

    if (++v29 >= v28)
    {
      fd_np = acl_p;
      goto LABEL_60;
    }
  }

  uint64_t v33 = ACL_EXTENDED_ALLOW;
LABEL_34:
  if ((*(void *)((_BYTE *)v30 + 5) & 0xFFFFFFFFFCFDFE0FLL) != 0)
  {
    int v45 = *(void *)((char *)v30 + 5);
    unint64_t v42 = "invalid ACE flags: 0x%016llx";
    size_t v43 = 444;
    goto LABEL_77;
  }

  if ((*(void *)((_BYTE *)v30 + 13) & 0xFFFFFFFFFFEFC001LL) != 0)
  {
    int v45 = *(void *)((char *)v30 + 13);
    unint64_t v42 = "invalid ACE perms: 0x%016llx";
    size_t v43 = 445;
    goto LABEL_77;
  }

  if ((v31 - 278) <= 0xFFFFFEFE)
  {
    unint64_t v42 = "qualifier too long";
    size_t v43 = 448;
    goto LABEL_77;
  }

  uint64_t v34 = v31 - 22;
  __memcpy_chk();
  in[v34] = 0;
  HIDWORD(v35) = *((char *)v30 + 21) - 71;
  LODWORD(v35) = HIDWORD(v35);
  switch((v35 >> 1))
  {
    case 0u:
      memset(&v47, 0, 32);
      size_t v46 = 0LL;
      size_t v36 = getgrnam_r(in, (group *)&v47, v23, v19, &v46);
      uint64_t v37 = 0;
      if (v36 || !v46) {
        goto LABEL_50;
      }
      uint32_t v38 = mbr_gid_to_uuid(v47.pw_uid, uu);
      goto LABEL_49;
    case 1u:
      if (uuid_parse(in, uu)) {
        goto LABEL_69;
      }
      goto LABEL_51;
    case 6u:
      memset(&v47, 0, sizeof(v47));
      if (mbr_string_to_sid(in, (nt_sid_t *)&v47))
      {
        uint64_t v37 = 0;
      }

      else
      {
        uint32_t v38 = mbr_sid_to_uuid((const nt_sid_t *)&v47, uu);
LABEL_49:
        uint64_t v37 = v38 == 0;
      }

LABEL_73:
                  int v44 = (void *)*((void *)v9 + 10);
                  int v45 = realloc(v44, v43);
                  if (v45)
                  {
                    *((void *)v9 + 9) = v43;
                    *((void *)v9 + 10) = v45;
                    unint64_t v40 = *((void *)v9 + 8);
                    goto LABEL_75;
                  }

                  free(v44);
LABEL_97:
                  *uint32_t v38 = 0LL;
                  *((void *)v9 + 9) = 0LL;
                  *((void *)v9 + 10) = 0LL;
                  goto LABEL_98;
                }

                unint64_t v40 = v39;
              }

              size_t v43 = v39;
LABEL_75:
              if (v43 - v40 >= v36) {
                size_t v46 = v36;
              }
              else {
                size_t v46 = v43 - v40;
              }
              ssize_t v47 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 10) + v40), v46);
              if (v47 < 0) {
                goto LABEL_98;
              }
              if (!v47) {
                break;
              }
              unint64_t v40 = *v38 + v47;
              if (!__CFADD__(*v38, v47))
              {
                unint64_t v39 = *((void *)v9 + 9);
                if (v40 <= v39) {
                  continue;
                }
              }

              goto LABEL_98;
              *uint32_t v38 = v40;
              v37 += v47;
              v36 -= v47;
            }

            while (v36);
            if (v37 < 0) {
              goto LABEL_98;
            }
          }

          if (BYTE9(v52[3])
            && (uint64_t v48 = aaAssetDecodeStreamOpenWithState(*(void *)v9, a2, 0LL), (*((void *)v9 + 17) = v48) == 0LL)
            || BYTE8(v52[3])
            && (BOOL v49 = aaAssetDecompressionStreamOpenWithState(*((void *)v9 + 17), a2, 0LL),
                (*((void *)v9 + 16) = v49) == 0LL))
          {
LABEL_98:
            int v50 = "read state";
            __int16 v51 = 512;
LABEL_99:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamOpenWithState",  v51,  131,  0,  v50,  v6,  v7,  v52[0]);
            goto LABEL_12;
          }

          if (a3) {
            *a3 = *((void *)v9 + 7);
          }
          int v17 = 1;
        }

        else
        {
LABEL_9:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamOpenWithState",  502,  131,  0,  "invalid header state",  v6,  v7,  v52[0]);
          int v17 = 0;
          uint64_t v18 = v55;
        }

        goto LABEL_13;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c",  (uint64_t)"aaAssetDecodeStreamOpenWithState",  487,  131,  0,  "truncated state",  v6,  v7,  v52[0]);
  }

  uint64_t v18 = 0LL;
LABEL_12:
  int v17 = 0;
LABEL_13:
  free(v18);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v17) {
    uint64_t result = v8;
  }
  else {
    uint64_t result = 0LL;
  }
  if (v8 && (v17 & 1) == 0)
  {
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0LL;
  }

  return result;
}

    int v8 = "AEAContextGetFieldBlob";
    uint64_t v9 = 59;
    goto LABEL_74;
  }

  return v2;
}

    AAFieldKey v58 = (unsigned int *)(v24 + 40);
    uint64_t v9 = v71;
    do
      size_t v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
LABEL_75:
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAByteStreamCancel(*(AAByteStream *)v9);
        goto LABEL_79;
      }
    }

    __clrex();
LABEL_79:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamPRead",  215,  66,  0,  "Reading chunk data failed",  v33,  v34,  v62);
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAByteStreamCancel(*(AAByteStream *)v9);
        return -1LL;
      }
    }

    __clrex();
  }

  return -1LL;
}

      int v45 = *v14;
      size_t v46 = *v12;
      if (*((_DWORD *)a1 + 6) >= 3u)
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], ">>> range %10llx %10llx\n", *v12, v45);
        int v45 = *v14;
        size_t v46 = *v12;
      }

      ssize_t v47 = v171;
      if ((AAAsyncByteStreamProcess((uint64_t)*a1, (uint64_t)a1[23], v45 - v46, v46) & 0x80000000) == 0)
      {
        uint64_t v9 = 0;
        AAEntryACLBlob_impl *v12 = 0LL;
        v12[1] = 0LL;
        uint64_t v7 = a1[20];
        ++v8;
        uint64_t v171 = 1;
        continue;
      }

      break;
    }

    size_t v148 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateRetireRanges",  336,  143,  *v148,  "process range",  v149,  v150,  v168);
    uint64_t v48 = 1;
LABEL_130:
    if (pthread_mutex_unlock(v176))
    {
      size_t v158 = "unlock";
      unint64_t v159 = 347;
      goto LABEL_277;
    }

    if (v48) {
      goto LABEL_278;
    }
    if (!a1[20])
    {
      int v82 = 0;
      goto LABEL_258;
    }

    if (pthread_mutex_lock(v176)) {
      break;
    }
    AAFieldKey v74 = (unint64_t)a1[14];
    AAFieldKey v75 = (unint64_t)a1[12];
    uint32_t v76 = a1[20];
    if (v76)
    {
      uint64_t v77 = (unint64_t)a1[1];
      int v78 = a1[21] + 1;
      do
      {
        BOOL v79 = (v77 - 1 + *v78) / v77;
        if (v79 > v74) {
          AAFieldKey v74 = (v77 - 1 + *v78) / v77;
        }
        if (v79 - *(v78 - 1) / v77 > v75) {
          AAFieldKey v75 = v79 - *(v78 - 1) / v77;
        }
        v78 += 2;
        uint32_t v76 = (void *)((char *)v76 - 1);
      }

      while (v76);
    }

    if (*((_DWORD *)a1 + 6) >= 3u) {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "    %zu chunks\n", v74);
    }
    if (8 * v74 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_252;
    }

    AAFieldKey v83 = a1[15];
    uint32_t v84 = realloc(v83, 8 * v74);
    if (!v84)
    {
      free(v83);
LABEL_252:
      a1[15] = 0LL;
      AAFieldKey v144 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"lockedStateReserveChunks",  172,  143,  *v144,  "malloc",  v145,  v146,  v168);
      a1[14] = 0LL;
LABEL_253:
      uint64_t v115 = 375;
      uint64_t v116 = "reserving chunks";
      goto LABEL_254;
    }

    a1[15] = v84;
    AAFieldKey v85 = (unint64_t)a1[14];
    if (v85 < v74) {
      memset(&v84[v85], 255, 8 * v74 - 8 * v85);
    }
    a1[14] = (void *)v74;
LABEL_152:
    uint64_t v86 = a1[12];
    if (v86)
    {
      int v87 = a1[13] + 4;
      AAFieldKey v88 = a1[12];
      do
      {
        *int v87 = 0LL;
        v87 += 6;
        AAFieldKey v88 = (void *)((char *)v88 - 1);
      }

      while (v88);
    }

    uint32_t v89 = a1[20];
    if (v89)
    {
      unsigned int v90 = 0LL;
      int v91 = a1[21];
      unint64_t v92 = (unint64_t)a1[1];
      while (1)
      {
        AAFieldKey v93 = &v91[2 * v90];
        uint32_t v94 = *v93;
        AAFieldKey v95 = v93[1];
        AAFieldKey v96 = v94 / v92;
        uint32_t v97 = (v92 - 1 + v95) / v92;
        if (v94 / v92 < v97) {
          break;
        }
LABEL_195:
        if ((void *)++v90 == v89) {
          goto LABEL_196;
        }
      }

      AAFieldKey v98 = a1[15];
      size_t v99 = v95;
      while (2)
      {
        int v100 = v98[v96];
        if (v100 != -1)
        {
          size_t v101 = a1[13];
          if (!LODWORD(v101[6 * v100]) || v96 != v101[6 * v100 + 1])
          {
            uint64_t v115 = 389;
            uint64_t v116 = "invalid state";
LABEL_254:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateUpdateChunks",  v115,  143,  0,  v116,  v80,  v81,  v168);
            int v82 = 0;
LABEL_255:
            uint64_t v143 = 1;
            goto LABEL_256;
          }

          if (v94 == v99) {
            goto LABEL_168;
          }
          unint64_t v102 = v96 * v92;
          size_t v103 = (char *)(v96 * v92 + v92);
          if (v94 > v96 * v92) {
            unint64_t v102 = v94;
          }
          if (v102 >= (unint64_t)v103)
          {
LABEL_168:
            unint64_t v102 = 0LL;
            size_t v103 = 0LL;
          }

          char v80 = 0LL;
          unint64_t v104 = &v101[6 * v100];
          char v106 = v104[2];
          v105 = v104[3];
          if (v106 != v105) {
            size_t v99 = v94;
          }
          unsigned int v81 = 0LL;
          if (v94 != v95 && v106 != v105)
          {
            if (v94 <= v106) {
              unsigned int v81 = v106;
            }
            else {
              unsigned int v81 = v94;
            }
            if (v105 >= v95) {
              char v80 = v95;
            }
            else {
              char v80 = v105;
            }
            if (v81 >= v80)
            {
              char v80 = 0LL;
              unsigned int v81 = 0LL;
            }

            else
            {
              size_t v99 = v95;
            }

            size_t v99 = v95;
          }

          unint64_t v108 = v103 != (char *)v102 && v80 == v81;
        }

char *AAAssetBuilderCreate(uint64_t a1)
{
  unsigned int v2 = (char *)malloc(0xA0uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    memset_s(v2, 0xA0uLL, 0, 0xA0uLL);
    *(void *)uint64_t v3 = a1;
    *(_OWORD *)(v3 + 104) = xmmword_1862D77F0;
    *(_OWORD *)(v3 + 120) = xmmword_1862D7800;
    *((_DWORD *)v3 + 34) = 774;
    *((_OWORD *)v3 + 9) = xmmword_1862D7810;
  }

  else
  {
    unint64_t v4 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c",  (uint64_t)"AAAssetBuilderCreate",  13,  26,  *v4,  "malloc",  v5,  v6,  v8);
  }

  return v3;
}

void AAAssetBuilderDestroy(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t AAAssetBuilderAddVariantArchive( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 16);
  if (v8 >= 0xA)
  {
    uint64_t v9 = "too many inputs/outputs";
    __int16 v10 = 44;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c",  (uint64_t)"AAAssetBuilderAddVariantArchive",  v10,  26,  0,  v9,  a7,  a8,  v17);
    return 0xFFFFFFFFLL;
  }

  if ((a2 - 1) >= 2)
  {
    uint64_t v9 = "invalid variant";
    __int16 v10 = 53;
    goto LABEL_7;
  }

  uint64_t v13 = a1 + 24;
  if (a2 == 2)
  {
    int v14 = (void *)(v13 + 8 * v8);
  }

  else
  {
    uint64_t v16 = *(void *)(a1 + 8);
    int v14 = (void *)(v13 + 8 * v16);
    memmove(v14 + 1, v14, 8 * (v8 - v16));
    unint64_t v8 = *(void *)(a1 + 16);
    ++*(void *)(a1 + 8);
  }

  uint64_t result = 0LL;
  *(void *)(a1 + 16) = v8 + 1;
  *int v14 = a3;
  return result;
}

uint64_t AAAssetBuilderAddFilter()
{
  return 0xFFFFFFFFLL;
}

uint64_t AAAssetBuilderSetParameter( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 1:
      uint64_t result = 0LL;
      *(void *)(a1 + 104) = a3;
      break;
    case 2:
      uint64_t result = 0LL;
      *(void *)(a1 + 112) = a3;
      break;
    case 3:
      uint64_t result = 0LL;
      *(void *)(a1 + 120) = a3;
      break;
    case 4:
      uint64_t result = 0LL;
      *(void *)(a1 + 128) = a3;
      break;
    case 5:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 136) = a3;
      break;
    case 6:
      uint64_t result = 0LL;
      *(void *)(a1 + 144) = a3;
      break;
    default:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c",  (uint64_t)"AAAssetBuilderSetParameter",  104,  26,  0,  "unsupported parameter",  a7,  a8,  vars0);
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }

  return result;
}

uint64_t AAAssetBuilderGetParameter( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 1:
      uint64_t result = *(void *)(a1 + 104);
      break;
    case 2:
      uint64_t result = *(void *)(a1 + 112);
      break;
    case 3:
      uint64_t result = *(void *)(a1 + 120);
      break;
    case 4:
      uint64_t result = *(void *)(a1 + 128);
      break;
    case 5:
      uint64_t result = *(unsigned int *)(a1 + 136);
      break;
    case 6:
      uint64_t result = *(void *)(a1 + 144);
      break;
    default:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c",  (uint64_t)"AAAssetBuilderGetParameter",  129,  26,  0,  "unsupported parameter key",  a7,  a8,  vars0);
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t AEADecryptAndExtractChunk( void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9, unint64_t a10, unsigned int a11)
{
  v30[3] = a6;
  int v31 = 0;
  v30[0] = a2;
  v30[1] = a5;
  v30[2] = a7;
  int v32 = a10 >> 62;
  ChunkAsyncStreamOpen = (uint64_t (**)(void))AEADecryptAndExtractChunkAsyncStreamOpen( a3,  a4,  (uint64_t)v30,  (uint64_t)asyncContext,  (uint64_t)asyncSelect,  (uint64_t)asyncProgress,  a8,  a9,  a10,  a11);
  uint64_t v15 = ChunkAsyncStreamOpen;
  if (!ChunkAsyncStreamOpen)
  {
    unint64_t v19 = "AEADecryptAndExtractAsyncStreamOpen";
    __int16 v20 = 96;
LABEL_18:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c",  (uint64_t)"AEADecryptAndExtractChunk",  v20,  117,  0,  v19,  v13,  v14,  v27);
    int v21 = 0;
    goto LABEL_19;
  }

  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(ChunkAsyncStreamOpen, a1, a10, a11) & 0x8000000000000000LL) == 0)
    {
      int v21 = 1;
      goto LABEL_19;
    }

    unint64_t v19 = "AAAsyncByteStreamProcessAllRanges";
    __int16 v20 = 124;
    goto LABEL_18;
  }

  while (1)
  {
    uint64_t v28 = 0LL;
    unint64_t v29 = 0LL;
    int Range = AAAsyncByteStreamGetRange(v15, &v29, &v28);
    if (Range < 0) {
      break;
    }
    if (Range)
    {
      if (!v29)
      {
        int v21 = 1;
        goto LABEL_16;
      }

      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        size_t v22 = "AAByteStreamPReadAsync";
        __int16 v23 = 113;
        goto LABEL_15;
      }
    }

    else
    {
      usleep(0x186A0u);
    }
  }

  size_t v22 = "AAAsyncByteStreamGetRange";
  __int16 v23 = 108;
LABEL_15:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c",  (uint64_t)"AEADecryptAndExtractChunk",  v23,  117,  0,  v22,  v17,  v18,  v27);
  int v21 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    unint64_t v19 = "AAByteStreamPReadAsync barrier";
    __int16 v20 = 118;
    goto LABEL_18;
  }

uint64_t asyncContext(uint64_t result, _OWORD *context)
{
  uint64_t v3 = (_DWORD *)result;
  uint64_t v4 = *(void *)result;
  if (*(_DWORD *)(result + 32))
  {
    *(_OWORD *)uint64_t v4 = *context;
    __int128 v5 = context[1];
    __int128 v6 = context[2];
    __int128 v7 = context[3];
    *(void *)(v4 + 64) = *((void *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 36))
    {
      unint64_t v8 = (FILE **)MEMORY[0x1895F89D0];
      uint64_t v9 = (FILE *)*MEMORY[0x1895F89D0];
      int FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            uint64_t v15 = "none";
            goto LABEL_25;
          case 256:
            uint64_t v15 = "lz4";
            goto LABEL_25;
          case 774:
            uint64_t v15 = "lzma";
LABEL_25:
            uint64_t v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            uint64_t v17 = *v8;
            unsigned int v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2) {
              unint64_t v19 = "???";
            }
            else {
              unint64_t v19 = off_189E3AE38[v18];
            }
            fprintf(v17, "  checksum: %s\n", v19);
            __int16 v20 = *v8;
            uint64_t v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            size_t v22 = *v8;
            uint64_t v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            return 0LL;
        }
      }

      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            uint64_t v15 = "zlib";
            goto LABEL_25;
          }

          if (FieldUInt != 1794) {
            goto LABEL_24;
          }
          goto LABEL_20;
        }

        if (FieldUInt == 2049)
        {
LABEL_20:
          uint64_t v15 = "lzfse";
          goto LABEL_25;
        }

        if (FieldUInt == 2304)
        {
          uint64_t v15 = "lzvn";
          goto LABEL_25;
        }
      }

LABEL_24:
      uint64_t v15 = "???";
      goto LABEL_25;
    }

    return 0LL;
  }

  uint64_t v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    uint64_t result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    uint64_t v12 = *(unsigned int *)(*(void *)v3 + 72LL);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(void *)v3 + 76LL), *(unsigned int *)(*(void *)v3 + 72LL));
      *((_DWORD *)context + 18) = v12;
      uint64_t result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      uint64_t v13 = *(unsigned int *)(*(void *)v3 + 2152LL);
      if (v13 < 0x101)
      {
        memcpy( (char *)context + 2156,  (const void *)(*(void *)v3 + 2156LL),  *(unsigned int *)(*(void *)v3 + 2152LL));
        *((_DWORD *)context + 538) = v13;
        uint64_t result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        uint64_t v14 = *(unsigned int *)(*(void *)v3 + 332LL);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(void *)v3 + 336LL), *(unsigned int *)(*(void *)v3 + 332LL));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[8] = 1;
          return 0LL;
        }
      }
    }
  }

  __break(1u);
  return result;
}

      uint64_t v15 = "???";
      goto LABEL_25;
    }

    return 0LL;
  }

  uint64_t v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    uint64_t result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    uint64_t v12 = *(unsigned int *)(*(void *)v3 + 72LL);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(void *)v3 + 76LL), *(unsigned int *)(*(void *)v3 + 72LL));
      *((_DWORD *)context + 18) = v12;
      uint64_t result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      uint64_t v13 = *(unsigned int *)(*(void *)v3 + 2152LL);
      if (v13 < 0x101)
      {
        memcpy( (char *)context + 2156,  (const void *)(*(void *)v3 + 2156LL),  *(unsigned int *)(*(void *)v3 + 2152LL));
        *((_DWORD *)context + 538) = v13;
        uint64_t result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        uint64_t v14 = *(unsigned int *)(*(void *)v3 + 332LL);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(void *)v3 + 336LL), *(unsigned int *)(*(void *)v3 + 332LL));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[7] = 1;
          return 0LL;
        }
      }
    }
  }

  __break(1u);
  return result;
}

  uint64_t v28 = v92;
  if (v92)
  {
    unint64_t v29 = 0LL;
    while (1)
    {
      size_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v11, v28);
      if (v30 < 1) {
        break;
      }
      v11 += v30;
      v29 += v30;
      v28 -= v30;
      if (!v28) {
        goto LABEL_30;
      }
    }

    unint64_t v29 = v30;
LABEL_30:
    if (v29 < 0) {
      goto LABEL_120;
    }
  }

  if (!a2[3]) {
    goto LABEL_120;
  }
  int v31 = v93;
  if (v93)
  {
    int v32 = 0LL;
    while (1)
    {
      uint64_t v33 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v12, v31);
      if (v33 < 1) {
        break;
      }
      v12 += v33;
      v32 += v33;
      v31 -= v33;
      if (!v31) {
        goto LABEL_38;
      }
    }

    int v32 = v33;
LABEL_38:
    if (v32 < 0) {
      goto LABEL_120;
    }
  }

  uint64_t v34 = (AAHeader_impl *)a1[596];
  if (!v34) {
    goto LABEL_48;
  }
  EncodedData = AAHeaderGetEncodedData(v34);
  if (!a2[3]) {
    goto LABEL_120;
  }
  size_t v36 = v94;
  if (!v94) {
    goto LABEL_49;
  }
  uint64_t v37 = EncodedData;
  uint32_t v38 = 0LL;
  while (1)
  {
    unint64_t v39 = ((uint64_t (*)(void, const uint8_t *, uint64_t))a2[3])(*a2, v37, v36);
    if (v39 < 1) {
      break;
    }
    v37 += v39;
    v38 += v39;
    v36 -= v39;
    if (!v36) {
      goto LABEL_47;
    }
  }

  uint32_t v38 = v39;
LABEL_47:
  if (v38 < 0) {
    goto LABEL_120;
  }
LABEL_48:
  if (!a2[3]) {
    goto LABEL_120;
  }
LABEL_49:
  unint64_t v40 = *((void *)&v97 + 1);
  if (*((void *)&v97 + 1))
  {
    unint64_t v41 = 0LL;
    unint64_t v42 = a1[600];
    while (1)
    {
      size_t v43 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v42, v40);
      if (v43 < 1) {
        break;
      }
      v42 += v43;
      v41 += v43;
      v40 -= v43;
      if (!v40) {
        goto LABEL_55;
      }
    }

    unint64_t v41 = v43;
LABEL_55:
    if (v41 < 0) {
      goto LABEL_120;
    }
  }

  if (!a2[3]) {
    goto LABEL_120;
  }
  int v44 = v98;
  if ((void)v98)
  {
    int v45 = 0LL;
    size_t v46 = a1[603];
    while (1)
    {
      ssize_t v47 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v46, v44);
      if (v47 < 1) {
        break;
      }
      v46 += v47;
      v45 += v47;
      v44 -= v47;
      if (!v44) {
        goto LABEL_63;
      }
    }

    int v45 = v47;
LABEL_63:
    if (v45 < 0 || !a2[3]) {
      goto LABEL_120;
    }
  }

  uint64_t v48 = *((void *)&v98 + 1);
  if (*((void *)&v98 + 1))
  {
    BOOL v49 = 0LL;
    int v50 = a1[606];
    while (1)
    {
      __int16 v51 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v50, v48);
      if (v51 < 1) {
        break;
      }
      v50 += v51;
      v49 += v51;
      v48 -= v51;
      if (!v48) {
        goto LABEL_71;
      }
    }

    BOOL v49 = v51;
LABEL_71:
    if (v49 < 0) {
      goto LABEL_120;
    }
  }

  if (!a1[608])
  {
    if (a2[3])
    {
      uint64_t v77 = v97;
      if (!(void)v97) {
        goto LABEL_133;
      }
      int v78 = 0LL;
      BOOL v79 = a1[611];
      while (1)
      {
        char v80 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v79, v77);
        if (v80 < 1) {
          break;
        }
        v79 += v80;
        v78 += v80;
        v77 -= v80;
        if (!v77) {
          goto LABEL_132;
        }
      }

      int v78 = v80;
LABEL_132:
      if ((v78 & 0x8000000000000000LL) == 0) {
        goto LABEL_133;
      }
    }

    uint32_t v71 = "write state";
    unsigned int v72 = 769;
    goto LABEL_121;
  }

  uint64_t v52 = v97;
  if (!(void)v97) {
    goto LABEL_133;
  }
  AAFieldKey v85 = 0LL;
  BOOL v53 = 0LL;
  size_t v54 = 0LL;
  uint64_t v55 = 0LL;
  while (2)
  {
    unint64_t __s = 0LL;
    uint64_t v56 = v52 - v55;
    if (v56 >= 0x40000) {
      uint64_t v57 = 0x40000LL;
    }
    else {
      uint64_t v57 = v56;
    }
    if (!v57)
    {
LABEL_142:
      uint64_t v52 = v97;
      break;
    }

    AAFieldKey v58 = 0LL;
    size_t v59 = 0LL;
    s = (AAByteStream_impl *)a1[608];
    uint32_t v84 = v55;
    uint64_t v60 = v55;
    while (2)
    {
      if (v58 == v54)
      {
        size_t v61 = v54 + 0x40000;
        if (v54 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v54)
            {
              size_t v54 = 0x4000LL;
              uint64_t v63 = 0x4000LL;
              if (v61 <= 0x4000) {
                goto LABEL_93;
              }
            }

            size_t v62 = v54 >> 1;
            if ((v54 & (v54 >> 1)) != 0) {
              size_t v62 = v54 & (v54 >> 1);
            }
            v54 += v62;
          }

          while (v54 < v61);
          uint64_t v63 = v54;
          if (v54 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_146;
          }

    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return a3;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"blockReader",  111,  126,  0,  "MutexLock",  v10,  v11,  v19);
  *(_DWORD *)(a1 + 120) = 1;
  return -1LL;
}

        free((void *)a1);
        return v4;
      }
    }

    close(v11);
    if (!(_DWORD)v4) {
      goto LABEL_18;
    }
    goto LABEL_24;
  }

  return 0LL;
}

  close(v11);
  return v12;
}

    if ((__smax & 0x8000000000000000LL) != 0) {
      goto LABEL_77;
    }
    char v27 = *v13;
    if (*v13 < __smax)
    {
      do
      {
        while (!v27)
        {
          char v27 = 0x4000LL;
          unint64_t v29 = 0x4000LL;
          if (__smax <= 0x4000) {
            goto LABEL_34;
          }
        }

        uint64_t v28 = v27 >> 1;
        if ((v27 & (v27 >> 1)) != 0) {
          uint64_t v28 = v27 & (v27 >> 1);
        }
        v27 += v28;
      }

      while (v27 < __smax);
      unint64_t v29 = v27;
      if (v27 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_71;
      }

    if ((__smax & 0x8000000000000000LL) != 0) {
      goto LABEL_81;
    }
    char v27 = *v13;
    if (*v13 < __smax)
    {
      do
      {
        while (!v27)
        {
          char v27 = 0x4000LL;
          unint64_t v29 = 0x4000LL;
          if (__smax <= 0x4000) {
            goto LABEL_34;
          }
        }

        uint64_t v28 = v27 >> 1;
        if ((v27 & (v27 >> 1)) != 0) {
          uint64_t v28 = v27 & (v27 >> 1);
        }
        v27 += v28;
      }

      while (v27 < __smax);
      unint64_t v29 = v27;
      if (v27 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_74;
      }

uint64_t asyncSelect(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 24);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0LL;
  }
}

uint64_t asyncProgress(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 16);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0LL;
  }
}

uint64_t AEADecryptAndExtract( void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9)
{
  return AEADecryptAndExtractChunk(a1, a2, a3, a4, a5, a6, a7, 0LL, 0LL, a8, a9);
}

void *AAAssetExtractorCreate(const char *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  bzero(__s, 0x400uLL);
  bzero(path, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, __s)
    || stat(__s, &v56)
    || (v56.st_mode & 0xF000) != 0x4000
    || (concatPath(path, 0x400uLL, __s, ".AssetExtractCheckpoint") & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorCreate",  216,  15,  0,  "invalid work dir: %s",  v6,  v7,  (char)a1);
    Common = 0LL;
  }

  else
  {
    if (!stat(path, &v56))
    {
      uint64_t v61 = 0LL;
      uint64_t v62 = 0LL;
      uint64_t v60 = 0LL;
      AAByteStream v8 = AAFileStreamOpenWithPath(path, 0, 0);
      if (v8)
      {
        Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
        if (Common)
        {
          char v59 = 0;
          uint64_t v57 = 0LL;
          uint64_t v58 = 0LL;
          if (*((void *)v8 + 2))
          {
            uint64_t v12 = 0LL;
            uint64_t v13 = &v57;
            uint64_t v14 = 17LL;
            while (1)
            {
              uint64_t v15 = (*((uint64_t (**)(void, uint64_t *, uint64_t))v8 + 2))(*(void *)v8, v13, v14);
              if (v15 < 0) {
                break;
              }
              if (v15)
              {
                uint64_t v13 = (uint64_t *)((char *)v13 + v15);
                v12 += v15;
                v14 -= v15;
                if (v14) {
                  continue;
                }
              }

              if (v12 < 0) {
                break;
              }
              void *Common = v57;
              *((_DWORD *)Common + 1038) = v58;
              Common[520] = BYTE4(v58);
              if (!BYTE5(v58)) {
                goto LABEL_31;
              }
              StreamOpenWithState = aaAssetExtractStreamOpenWithState(__s, v8, 0LL);
              Common[521] = StreamOpenWithState;
              if (!StreamOpenWithState) {
                goto LABEL_31;
              }
              if (BYTE6(v58))
              {
                __int16 v20 = aaAssetDecodeStreamOpenWithState((uint64_t)StreamOpenWithState, v8, &v62);
                Common[522] = v20;
                if (!v20) {
                  goto LABEL_31;
                }
              }

              if (HIBYTE(v58)
                && (uint64_t v21 = aaAssetDecompressionStreamOpenWithState(Common[522], v8, &v61), (Common[523] = v21) == 0LL)
                || v59
                && (size_t v22 = aaAssetDecryptionStreamOpenWithState(Common[522], v8, &v60), (Common[524] = v22) == 0LL))
              {
LABEL_31:
                uint64_t v34 = "invalid state";
                __int16 v35 = 121;
                goto LABEL_32;
              }

              if (a2)
              {
                if (v59)
                {
                  uint64_t v23 = &v60;
                }

                else if (HIBYTE(v58))
                {
                  uint64_t v23 = &v61;
                }

                else
                {
                  uint64_t v23 = Common + 520;
                  if (BYTE6(v58)) {
                    uint64_t v23 = &v62;
                  }
                }

                *a2 = *v23;
              }

              int v50 = (uint64_t *)Common[522];
              if (!v50
                || (aaAssetDecodeStreamSetParameterPtr(v50, 101, (uint64_t)Common, v17, v18, v19, v9, v10) & 0x80000000) == 0
                && (aaAssetDecodeStreamSetParameterPtr( (uint64_t *)Common[522],  103,  (uint64_t)aaAssetExtractorProgress,  v51,  v52,  v53,  v9,  v10) & 0x80000000) == 0)
              {
                AAByteStreamClose(v8);
                return Common;
              }

              uint64_t v34 = "mapping decode stream progress";
              __int16 v35 = 137;
              goto LABEL_32;
            }
          }

          uint64_t v34 = "invalid state";
          __int16 v35 = 112;
        }

        else
        {
          uint64_t v34 = "common constructor";
          __int16 v35 = 109;
        }

void *aaAssetExtractorCreateCommon(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = malloc(0x1068uLL);
  __int128 v5 = v4;
  if (v4)
  {
    memset_s(v4, 0x1068uLL, 0, 0x1068uLL);
    void *v5 = a3;
    __strlcpy_chk();
    __strlcpy_chk();
  }

  else
  {
    uint64_t v6 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"aaAssetExtractorCreateCommon",  76,  15,  *v6,  "malloc",  v7,  v8,  v16);
    AAAssetExtractorDestroy(0LL, 0LL, v9, v10, v11, v12, v13, v14);
  }

  return v5;
}

uint64_t AAAssetExtractorDestroy( char *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (atomic_load((unsigned int *)a1 + 1034))
    {
LABEL_3:
      uint64_t v10 = 0xFFFFFFFFLL;
LABEL_4:
      int v11 = 1;
      goto LABEL_5;
    }

    uint64_t v17 = (uint64_t (**)(uint64_t))*((void *)a1 + 522);
    if (v17 && aaAssetDecodeStreamDone(v17, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
    {
      uint64_t v10 = 0LL;
      goto LABEL_4;
    }

    if (atomic_load((unsigned int *)a1 + 1036))
    {
      if (atomic_load((unsigned int *)a1 + 1034))
      {
LABEL_81:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorDestroy",  269,  15,  0,  "storing checkpoint",  a7,  a8,  v47);
        goto LABEL_3;
      }

      memset(v51, 0, 17);
      uint64_t v49 = -1LL;
      uint64_t v50 = -1LL;
      uint64_t v48 = -1LL;
      AAByteStream v22 = AAFileStreamOpenWithPath(a1 + 3080, 1537, 0x1A4u);
      uint64_t v25 = v22;
      if (!v22)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"aaAssetExtractorStoreCheckpoint",  160,  15,  0,  "open checkpoint path: %s",  v23,  v24,  (_BYTE)a1 + 8);
LABEL_80:
        AAByteStreamClose(v25);
        unlink(a1 + 3080);
        goto LABEL_81;
      }

      v51[0] = *(void *)a1;
      LODWORD(v51[1]) = *((_DWORD *)a1 + 1038);
      BYTE4(v51[1]) = *((void *)a1 + 520);
      uint64_t v26 = (void **)(a1 + 4168);
      int16x8_t v27 = (int16x8_t)vuzp1q_s32( (int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4168), *(int64x2_t *)(a1 + 4168)),  (int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4184), *(int64x2_t *)(a1 + 4184)));
      *(int8x8_t *)v27.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v27), (int8x8_t)0x1000100010001LL);
      *(_DWORD *)((char *)&v51[1] + 5) = vmovn_s16(v27).u32[0];
      if (!*((void *)v22 + 3)) {
        goto LABEL_47;
      }
      uint64_t v28 = 0LL;
      uint64_t v29 = v51;
      uint64_t v30 = 17LL;
      while (1)
      {
        uint64_t v31 = (*((uint64_t (**)(void, void *, uint64_t))v25 + 3))(*(void *)v25, v29, v30);
        if (v31 < 1) {
          break;
        }
        uint64_t v29 = (void *)((char *)v29 + v31);
        v28 += v31;
        v30 -= v31;
        if (!v30) {
          goto LABEL_45;
        }
      }

      uint64_t v28 = v31;
LABEL_45:
      if (v28 < 0) {
LABEL_47:
      }
        int v37 = 0;
      else {
        int v37 = 1;
      }
      if (BYTE5(v51[1]))
      {
        uint64_t v38 = *v26;
        if (*v26)
        {
          if (*v38)
          {
            int v39 = ((uint64_t (*)(void, AAByteStream_impl *, void))v38[6])(*v38, v25, 0LL);
            free(v38);
            if (v39 < 0) {
              int v37 = 0;
            }
          }

          else
          {
            free(*v26);
          }
        }
      }

      *uint64_t v26 = 0LL;
      if (BYTE6(v51[1]))
      {
        uint64_t v40 = (void *)*((void *)a1 + 522);
        if (v40)
        {
          if (*v40)
          {
            int v41 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v40[6])(*v40, v25, &v50);
            free(v40);
            if (v41 < 0) {
              int v37 = 0;
            }
          }

          else
          {
            free(*((void **)a1 + 522));
          }
        }
      }

      *((void *)a1 + 522) = 0LL;
      if (HIBYTE(v51[1]))
      {
        uint64_t v42 = (void *)*((void *)a1 + 523);
        if (v42)
        {
          if (*v42)
          {
            int v43 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v42[6])(*v42, v25, &v49);
            free(v42);
            if (v43 < 0) {
              int v37 = 0;
            }
          }

          else
          {
            free(*((void **)a1 + 523));
          }
        }
      }

      *((void *)a1 + 523) = 0LL;
      if (LOBYTE(v51[2]))
      {
        uint64_t v44 = (void *)*((void *)a1 + 524);
        if (v44)
        {
          if (*v44)
          {
            int v45 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v44[6])(*v44, v25, &v48);
            free(v44);
            if (v45 < 0)
            {
              *((void *)a1 + 524) = 0LL;
LABEL_79:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"aaAssetExtractorStoreCheckpoint",  179,  15,  0,  "write checkpoint",  v23,  v24,  v47);
              goto LABEL_80;
            }
          }

          else
          {
            free(*((void **)a1 + 524));
          }
        }
      }

      *((void *)a1 + 524) = 0LL;
      if (!v37) {
        goto LABEL_79;
      }
      AAByteStreamClose(v25);
      if (a2)
      {
        if (LOBYTE(v51[2]))
        {
          uint64_t v46 = &v48;
        }

        else if (HIBYTE(v51[1]))
        {
          uint64_t v46 = &v49;
        }

        else
        {
          uint64_t v46 = (uint64_t *)(a1 + 4160);
          if (BYTE6(v51[1])) {
            uint64_t v46 = &v50;
          }
        }

        *a2 = *v46;
      }

      AAByteStreamClose(0LL);
    }

    int v11 = 0;
    uint64_t v10 = 1LL;
LABEL_5:
    uint64_t v12 = (uint64_t (**)(void))*((void *)a1 + 523);
    if (v12)
    {
      if (*v12)
      {
        int v13 = v12[1]();
        free(v12);
        if (v13 < 0) {
          goto LABEL_37;
        }
      }

      else
      {
        free(*((void **)a1 + 523));
      }
    }

    uint64_t v18 = (uint64_t (**)(void))*((void *)a1 + 524);
    if (v18)
    {
      if (*v18)
      {
        int v19 = v18[1]();
        free(v18);
        if (v19 < 0) {
          goto LABEL_37;
        }
      }

      else
      {
        free(*((void **)a1 + 524));
      }
    }

    uint64_t v32 = (uint64_t (**)(void))*((void *)a1 + 522);
    if (v32)
    {
      if (*v32)
      {
        int v33 = v32[1]();
        free(v32);
        if (v33 < 0) {
          goto LABEL_37;
        }
      }

      else
      {
        free(*((void **)a1 + 522));
      }
    }

    uint64_t v34 = (uint64_t (**)(void))*((void *)a1 + 521);
    if (v34)
    {
      if (!*v34)
      {
        free(*((void **)a1 + 521));
        if (v11) {
          goto LABEL_38;
        }
        goto LABEL_40;
      }

      int v35 = v34[1]();
      free(v34);
      if (v35 < 0)
      {
LABEL_37:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorDestroy",  276,  15,  0,  "internal streams",  v14,  v15,  v47);
        uint64_t v10 = 0xFFFFFFFFLL;
        goto LABEL_38;
      }
    }

    if (v11)
    {
LABEL_38:
      unlink(a1 + 3080);
LABEL_41:
      memset_s(a1, 0x1068uLL, 0, 0x1068uLL);
      free(a1);
      return v10;
    }

LABEL_40:
    uint64_t v10 = 1LL;
    goto LABEL_41;
  }

  return 0LL;
}

  if (v13 > *(_DWORD *)(v10 + 164)) {
    goto LABEL_41;
  }
  uint64_t v32 = *(void *)(v10 + 496)
      + *(unsigned int *)(v10 + 56) * (unint64_t)(*(_DWORD *)(v10 + 192) + 8);
  *a2 = *(_DWORD *)(v10 + 48);
  a2[1] = *(_DWORD *)(*(void *)(v10 + 1048) + v32);
  a2[2] = *(_DWORD *)(v32 + *(void *)(v10 + 1048) + 4);
  int v33 = *(unsigned int *)(v10 + 192);
  memcpy(a2 + 7, (const void *)(v32 + *(void *)(v10 + 1048) + 8), *(unsigned int *)(v10 + 192));
  a2[6] = v33;
  uint64_t result = memset_s((char *)a2 + v33 + 28, 256 - v33, 0, 256 - v33);
  uint64_t v34 = *(unsigned int *)(v10 + 228);
  memcpy( a2 + 72,  (const void *)(*(void *)(v10 + 1048) + *(void *)(v10 + 512) + (*(_DWORD *)(v10 + 56) * v34)),  *(unsigned int *)(v10 + 228));
  a2[71] = v34;
  memset_s((char *)a2 + v34 + 288, 256 - v34, 0, 256 - v34);
  int v35 = a2[1];
  uint64_t v36 = *(_DWORD *)(v10 + 160);
  if (v35 > v36 || (int v37 = a2[2], v37 > v35) || v37 > v36)
  {
    uint64_t v8 = "Invalid segment sizes";
    uint64_t v9 = 194;
    goto LABEL_3;
  }

  uint64_t v38 = *(void *)v10;
  if (!*(void *)(*(void *)v10 + 16LL)) {
    goto LABEL_64;
  }
  int v39 = 0LL;
  if ((_DWORD)v37)
  {
    uint64_t v40 = a2[2];
    while (1)
    {
      int v41 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v38 + 16))(*(void *)v38, a3, v40);
      if (v41 < 0) {
        break;
      }
      if (v41)
      {
        a3 += v41;
        v39 += v41;
        v40 -= v41;
        if (v40) {
          continue;
        }
      }

      goto LABEL_60;
    }

    int v39 = v41;
  }

        uint64_t v21 = "deriving segment key";
        AAByteStream v22 = 481;
        goto LABEL_41;
      }
    }

    else
    {
      memset_s(v50, 0x104uLL, 0, 0x104uLL);
    }

    memset_s(v49, 0x104uLL, 0, 0x104uLL);
    goto LABEL_40;
  }

  __break(1u);
  return result;
}

  if (!n_threads) {
    n_threads = getDefaultNThreads();
  }
  *(_DWORD *)(v8 + 40) = n_threads;
  uint64_t v28 = (char *)calloc(n_threads, 8uLL);
  *(void *)(v8 + 48) = v28;
  if (!v28)
  {
    AAByteStream v22 = *__error();
    uint64_t v23 = "malloc";
    uint64_t v24 = 174;
    goto LABEL_18;
  }

  uint64_t v29 = v27;
  uint64_t v30 = (FILE **)*(unsigned int *)(v8 + 40);
  if ((_DWORD)v30)
  {
    uint64_t v31 = v28;
    uint64_t v32 = 0LL;
    while (1)
    {
      *(void *)&v31[v32] = malloc(v26);
      uint64_t v31 = *(char **)(v8 + 48);
      if (!*(void *)&v31[v32]) {
        break;
      }
      v32 += 8LL;
      if (8LL * (void)v30 == v32) {
        goto LABEL_47;
      }
    }

    AAByteStream v22 = *__error();
    uint64_t v23 = "malloc";
    uint64_t v24 = 178;
    goto LABEL_18;
  }

uint64_t AAAssetExtractorWrite( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 4136);
  uint64_t v12 = a3;
  if (!a3) {
    return 0LL;
  }
  uint64_t v15 = (char *)(a1 + 4152);
  char v16 = (unsigned int *)(a1 + 4144);
  while (!__ldaxr(v16))
  {
    if (!__stlxr(1u, v16))
    {
      unlink((const char *)(a1 + 3080));
      goto LABEL_11;
    }
  }

  __clrex();
LABEL_11:
  uint64_t v18 = *(void **)(a1 + 4176);
  if (v18)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    unint64_t v35 = *(void *)(a1 + 4160);
    if (v35 > 3)
    {
      uint64_t v10 = 0LL;
    }

    else
    {
      uint64_t v10 = 0LL;
      do
      {
        char v36 = *(_BYTE *)(a2 + v10);
        *(void *)(a1 + 4160) = v35 + 1;
        *(_BYTE *)(a1 + v35 + 4152) = v36;
        unint64_t v35 = *(void *)(a1 + 4160);
      }

      while (v35 <= 3 && v12 - 1 != v10++);
      if (v35 < 4) {
        return v10;
      }
      v12 -= v10;
      a2 += v10;
    }

    if (*(_DWORD *)v15 == 825246017 || *(_DWORD *)v15 == 826360153)
    {
      int v40 = 0;
      int v41 = 0;
    }

    else if (*(_DWORD *)v15 == 826361153)
    {
      int v41 = 0;
      int v40 = 1;
    }

    else
    {
      int v38 = v15[3];
      BOOL v39 = *(_WORD *)v15 == 25200 && v15[2] == 122;
      if (!v39
        || ((int v40 = 0, v41 = 1, (v38 - 45) > 0x39)
         || ((1LL << (v38 - 45)) & 0x320000000000081LL) == 0)
        && v38 != 120
        && v38 != 122)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorWrite",  323,  15,  0,  "invalid stream type (0x%02x 0x%02x 0x%02x 0x%02x)",  a7,  a8,  *v15);
        goto LABEL_29;
      }
    }

    uint64_t v42 = aaAssetDecodeStreamOpen(*(void *)(a1 + 4168));
    *(void *)(a1 + 4176) = v42;
    if (!v42)
    {
      uint64_t v32 = "decoder stream";
      __int16 v33 = 330;
      goto LABEL_28;
    }

    if (v40)
    {
      uint64_t v46 = aaAssetDecryptionStreamOpen((uint64_t)v42, *(void *)(a1 + 4104), *(void *)(a1 + 4112));
      *(void *)(a1 + 4192) = v46;
      if (!v46)
      {
        uint64_t v32 = "decryption stream";
        __int16 v33 = 334;
        goto LABEL_28;
      }
    }

    else
    {
      if (v41)
      {
        char v47 = aaAssetDecompressionStreamOpen((uint64_t)v42);
        *(void *)(a1 + 4184) = v47;
        if (!v47)
        {
          uint64_t v32 = "decompression stream";
          __int16 v33 = 339;
          goto LABEL_28;
        }
      }

      uint64_t v48 = *(uint64_t (**)(void, void))(a1 + 4112);
      if (v48 && (v48(*(void *)(a1 + 4104), 0LL) & 0x80000000) != 0)
      {
        uint64_t v32 = "callback cancel on non AEA container";
        __int16 v33 = 346;
        goto LABEL_28;
      }
    }

    if ((aaAssetDecodeStreamSetParameterPtr(*(uint64_t **)(a1 + 4176), 101, a1, v43, v44, v45, a7, a8) & 0x80000000) != 0
      || (aaAssetDecodeStreamSetParameterPtr( *(uint64_t **)(a1 + 4176),  103,  (uint64_t)aaAssetExtractorProgress,  v49,  v50,  v51,  a7,  a8) & 0x80000000) != 0)
    {
      uint64_t v32 = "mapping decode stream progress";
      __int16 v33 = 352;
      goto LABEL_28;
    }

    uint64_t v52 = *(void **)(a1 + 4176);
    if (*(void *)(a1 + 4184)) {
      uint64_t v52 = *(void **)(a1 + 4184);
    }
    uint64_t v53 = *(void **)(a1 + 4192);
    if (!v53) {
      uint64_t v53 = v52;
    }
    char v54 = (uint64_t (*)(void, char *, void))v53[3];
    if (v54) {
      uint64_t v55 = v54(*v53, v15, *(void *)(a1 + 4160));
    }
    else {
      uint64_t v55 = -1LL;
    }
    if (v55 != *(void *)(a1 + 4160))
    {
      uint64_t v32 = "invalid stream";
      __int16 v33 = 360;
      goto LABEL_28;
    }

    uint64_t v18 = *(void **)(a1 + 4176);
  }

  if (*(void *)(a1 + 4184)) {
    uint64_t v18 = *(void **)(a1 + 4184);
  }
  int v19 = *(void **)(a1 + 4192);
  if (!v19) {
    int v19 = v18;
  }
  __int16 v20 = (uint64_t (*)(void, uint64_t, uint64_t))v19[3];
  if (!v20 || (uint64_t v21 = v20(*v19, a2, v12), v21 < 0))
  {
    uint64_t v32 = "invalid stream";
    __int16 v33 = 370;
    goto LABEL_28;
  }

  uint64_t v27 = v21;
  uint64_t v28 = *(uint64_t (***)(uint64_t))(a1 + 4176);
  if (v28 && aaAssetDecodeStreamDone(v28, v22, v23, v24, v25, v26, a7, a8))
  {
    uint64_t v29 = (unsigned int *)(a1 + 4140);
    do
    {
      if (__ldaxr(v29))
      {
        __clrex();
        goto LABEL_71;
      }
    }

    while (__stlxr(1u, v29));
    uint64_t v31 = *(uint64_t (**)(void, uint64_t, void *, void))(a1 + 4128);
    if (v31 && (v31(*(void *)(a1 + 4104), 92LL, &unk_1862C62C1, 0LL) & 0x80000000) != 0)
    {
      uint64_t v32 = "end of stream cancel";
      __int16 v33 = 381;
LABEL_28:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c",  (uint64_t)"AAAssetExtractorWrite",  v33,  15,  0,  v32,  a7,  a8,  v56);
      goto LABEL_29;
    }
  }

LABEL_71:
  v10 += v27;
  if (v10 < 0)
  {
LABEL_29:
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8)) {
        return -1LL;
      }
    }

    __clrex();
    return -1LL;
  }

  return v10;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processRandomAccess",  v66,  89,  0,  v65,  v52,  v53,  max_offset);
    AAFieldKey v74 = 1;
  }

          uint64_t v14 = 0LL;
          a1[7] = 0LL;
          a1[10] = 0LL;
          *((_DWORD *)a1 + 6) = 1;
        }

        else
        {
          if (!a3) {
            goto LABEL_106;
          }
LABEL_7:
          if (v19 >= a3) {
            __int16 v20 = a3;
          }
          else {
            __int16 v20 = v19;
          }
          uint64_t v21 = v14 + v20;
          if (__CFADD__(v14, v20) || (v21 & 0x8000000000000000LL) != 0) {
            goto LABEL_119;
          }
          uint64_t v22 = (unint64_t)a1[8];
          if (v22 < v21)
          {
            do
            {
              while (!v22)
              {
                uint64_t v22 = 0x4000LL;
                uint64_t v24 = 0x4000LL;
                if (v21 <= 0x4000) {
                  goto LABEL_51;
                }
              }

              uint64_t v23 = v22 >> 1;
              if ((v22 & (v22 >> 1)) != 0) {
                uint64_t v23 = v22 & (v22 >> 1);
              }
              v22 += v23;
            }

            while (v22 < v21);
            uint64_t v24 = v22;
            if (v22 >= 0x2000000001LL)
            {
              *__error() = 12;
LABEL_118:
              *uint64_t v15 = 0LL;
              v15[1] = 0LL;
              v15[2] = 0LL;
LABEL_119:
              uint64_t v57 = "malloc";
              uint64_t v58 = 209;
              goto LABEL_126;
            }

uint64_t aaAssetExtractorProgress(uint64_t a1, float a2)
{
  if ((a2 >= 100.0 || ((float v2 = *(float *)(a1 + 4148), v2 > 0.0) ? (v3 = (float)(v2 + 1.0) <= a2) : (v3 = 1), v3))
    && (*(float *)(a1 + 4148) = a2, (uint64_t v4 = *(uint64_t (**)(void))(a1 + 4120)) != 0LL))
  {
    return v4(*(void *)(a1 + 4104));
  }

  else
  {
    return 0LL;
  }

uint64_t AAAssetExtractorSetParameterPtr( uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 101
    || (aaAssetExtractStreamSetParameterPtr(*(uint64_t **)(a1 + 4168), 101, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    return 0xFFFFFFFFLL;
  }

  uint64_t result = 0LL;
  *(void *)(a1 + 4104) = a3;
  return result;
}

uint64_t AAAssetExtractorSetParameterCallback( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 102)
  {
    uint64_t v12 = 4112LL;
  }

  else if (a2 == 103)
  {
    uint64_t v12 = 4120LL;
  }

  else
  {
    if (a2 != 104
      || (aaAssetExtractStreamSetParameterCallback( *(uint64_t (***)(uint64_t))(a1 + 4168),  104,  a3,  a4,  a5,  a6,  a7,  a8) & 0x80000000) != 0)
    {
      return 0xFFFFFFFFLL;
    }

    uint64_t v12 = 4128LL;
  }

  uint64_t result = 0LL;
  *(void *)(a1 + v12) = a3;
  return result;
}

uint64_t compressionWorkerProc( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  uint64_t v10 = (unsigned int *)(*a1 + 112);
  if (atomic_load(v10))
  {
    uint64_t result = 0LL;
    a1[6] = -1LL;
    return result;
  }

  uint64_t v13 = a1[2];
  a1[6] = v13;
  if (v13 == -2) {
    return 0LL;
  }
  if (v13 == -1)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"compressionWorkerProc",  244,  37,  0,  "NOP received",  a7,  a8,  v21);
    return 0LL;
  }

  if (v13 < 0)
  {
    uint64_t v15 = "Invalid iBlock received";
    __int16 v16 = 246;
  }

  else
  {
    if (!*(_DWORD *)(v9 + 4))
    {
      unint64_t v17 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 96))( a1[5],  *(void *)(v9 + 16),  a1[1],  a1[3]);
      size_t v18 = a1[3];
      if ((v17 & 0x8000000000000000LL) != 0 || v17 >= v18)
      {
        memcpy((void *)a1[5], (const void *)a1[1], v18);
        unint64_t v17 = a1[3];
        size_t v18 = v17;
      }

      a1[7] = v17;
      a1[8] = v18;
      return 0LL;
    }

    if (a1[3] == a1[4])
    {
      memcpy((void *)a1[5], (const void *)a1[1], a1[3]);
      uint64_t v14 = a1[3];
      a1[7] = v14;
      goto LABEL_19;
    }

    uint64_t v19 = (*(uint64_t (**)(uint64_t))(v9 + 96))(a1[5]);
    if ((v19 & 0x8000000000000000LL) == 0 && v19 == a1[4])
    {
      a1[7] = v19;
      uint64_t v14 = a1[3];
LABEL_19:
      a1[8] = v14;
      return 0LL;
    }

    uint64_t v21 = a1[6];
    uint64_t v15 = "invalid output size/decoder error: block=%lld, inSize=%lld, outSize=%lld, expectedOutSize=%lld";
    __int16 v16 = 292;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"compressionWorkerProc",  v16,  37,  0,  v15,  a7,  a8,  v21);
  a1[6] = -1LL;
  uint64_t result = 0xFFFFFFFFLL;
  while (!__ldaxr(v10))
  {
    if (!__stlxr(1u, v10)) {
      return result;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t outputStreamProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (unsigned int *)(a1 + 112);
  unint64_t v13 = *(void *)(a2 + 48);
  if (v13 > 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v14 = 0LL;
LABEL_5:
    uint64_t result = 0LL;
    *(void *)(a1 + 88) += v14;
    return result;
  }

  if ((v13 & 0x8000000000000000LL) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  327,  37,  0,  "invalid block ID in write thread %lld",  a7,  a8,  *(void *)(a2 + 48));
LABEL_20:
    uint64_t v14 = 0LL;
    goto LABEL_22;
  }

  if (*(_DWORD *)(a1 + 4) != 1)
  {
    int8x16_t v18 = vrev64q_s8(*(int8x16_t *)(a2 + 56));
    int8x16_t v27 = vextq_s8(v18, v18, 8uLL);
    uint64_t v19 = pcWrite( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56),  *(void *)(a1 + 72),  (uint64_t)&v27,  16LL);
    if ((v19 & 0x8000000000000000LL) == 0)
    {
      uint64_t v14 = v19;
      if (v19 == 16)
      {
        uint64_t v20 = pcWrite( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56),  *(void *)(a1 + 72),  *(void *)(a2 + 40),  *(void *)(a2 + 56));
        if (v20 < 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  351,  37,  0,  "writing block payload",  v21,  v22,  v26);
          uint64_t v14 = 16LL;
        }

        else
        {
          uint64_t v14 = v20 + 16;
          if (v20 == *(void *)(a2 + 56)) {
            goto LABEL_5;
          }
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  353,  37,  0,  "Truncated block payload (%lld/%llu bytes read)",  v21,  v22,  v20);
        }
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  347,  37,  0,  "Truncated block header (%lld/16 bytes written)",  v16,  v17,  v19);
      }

      goto LABEL_22;
    }

    uint64_t v23 = "writing block header";
    __int16 v24 = 345;
    goto LABEL_19;
  }

  uint64_t v15 = pcWrite( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56),  *(void *)(a1 + 72),  *(void *)(a2 + 40),  *(void *)(a2 + 56));
  if (v15 < 0)
  {
    uint64_t v23 = "writing block";
    __int16 v24 = 334;
LABEL_19:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  v24,  37,  0,  v23,  v16,  v17,  v26);
    goto LABEL_20;
  }

  uint64_t v14 = v15;
  if (v15 == *(void *)(a2 + 56)) {
    goto LABEL_5;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"outputStreamProc",  336,  37,  0,  "Truncated block payload (%lld/%llu bytes written)",  v16,  v17,  v15);
LABEL_22:
  *(void *)(a1 + 88) += v14;
  while (!__ldaxr(v8))
  {
    if (!__stlxr(1u, v8)) {
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t pcWrite(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = a4;
    uint64_t v8 = 0LL;
    while (1)
    {
      uint64_t v9 = a1(a2, a3, v6);
      uint64_t v12 = v9;
      if (v9 < 0) {
        break;
      }
      a3 += v9;
      v8 += v9;
      v6 -= v9;
      if (!v6) {
        return v8;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"pcWrite",  131,  37,  0,  "pcWrite failed",  v10,  v11,  v16);
    return v12;
  }

  else
  {
    uint64_t v8 = a1(a2, 0LL, 0LL);
    if (v8 < 0) {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"pcWrite",  121,  37,  0,  "pcWrite EOF failed",  v13,  v14,  v16);
    }
  }

  return v8;
}

uint64_t PCompressFilter( unsigned int *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v117[2] = *MEMORY[0x1895F89C0];
  enterThreadErrorContext((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v105);
  *(void *)uint64_t v115 = 0LL;
  __int128 v113 = 0u;
  *(_OWORD *)unsigned __int16 v114 = 0u;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  __int128 v108 = 0u;
  unsigned int DefaultNThreads = a1[2];
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  a1[2] = DefaultNThreads;
  if (a1[1] == 1)
  {
    if (pcRead( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2,  *(void *)(a2 + 16),  (uint64_t)&v116,  4LL) != 4) {
      goto LABEL_34;
    }
    if (a3) {
      *a3 += 4LL;
    }
    unsigned int v14 = 0;
    while (getHeader(v14, (uint64_t)v117) || v116 != LODWORD(v117[0]))
    {
      if (++v14 == 7)
      {
        if (compression_stream_identify_algorithm() == -1)
        {
          uint64_t v15 = "invalid header in input stream";
          __int16 v16 = 179;
        }

        else
        {
          uint64_t v15 = "compressed stream detected : try compression_tool";
          __int16 v16 = 178;
        }

LABEL_33:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processFileHeader",  v16,  37,  0,  v15,  v12,  v13,  v106);
LABEL_34:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"PCompressFilter",  507,  37,  0,  "processFileHeader",  v12,  v13,  v106);
        goto LABEL_35;
      }
    }

    v117[0] = 0LL;
    if (pcRead( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2,  *(void *)(a2 + 16),  (uint64_t)v117,  8LL) != 8) {
      goto LABEL_34;
    }
    if (a3) {
      *a3 += 8LL;
    }
    if (!v117[0])
    {
      uint64_t v15 = "invalid blockSize in input stream";
      __int16 v16 = 191;
      goto LABEL_33;
    }

    *((void *)a1 + 2) = bswap64(v117[0]);
    *a1 = v14;
    if ((int)a1[6] >= 1)
    {
      uint64_t v20 = (FILE **)MEMORY[0x1895F89D0];
      uint64_t v21 = (FILE *)*MEMORY[0x1895F89D0];
      DecoderDescription = PCompressGetDecoderDescription(v14);
      fprintf(v21, "Decoder: %s\n", DecoderDescription);
      fprintf(*v20, "Blocksize: %llu\n");
    }
  }

  else
  {
    unint64_t v17 = *((void *)a1 + 2);
    unsigned int EncoderDecoder = PCompressGetEncoderDecoder(*a1);
    if (getHeader(EncoderDecoder, (uint64_t)&v116)
      || pcWrite( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24),  *(void *)(a2 + 40),  (uint64_t)&v116,  4LL) != 4)
    {
      goto LABEL_34;
    }

    if (a3) {
      a3[1] += 4LL;
    }
    v117[0] = bswap64(v17);
    if (pcWrite( *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24),  *(void *)(a2 + 40),  (uint64_t)v117,  8LL) != 8) {
      goto LABEL_34;
    }
    if (a3) {
      a3[1] += 8LL;
    }
    if ((int)a1[6] >= 1)
    {
      uint64_t v19 = (FILE *)*MEMORY[0x1895F89D0];
      PCompressGetEncoderDescription(*a1);
      fprintf(v19, "Encoder: %s\n");
    }
  }

  __int128 v23 = *((_OWORD *)a1 + 1);
  __int128 v108 = *(_OWORD *)a1;
  __int128 v109 = v23;
  __int128 v113 = 0u;
  *(_OWORD *)unsigned __int16 v114 = 0u;
  *(void *)uint64_t v115 = 0LL;
  __int128 v24 = *(_OWORD *)(a2 + 16);
  __int128 v110 = *(_OWORD *)a2;
  __int128 v111 = v24;
  __int128 v112 = *(_OWORD *)(a2 + 32);
  if (a3) {
    __int128 v113 = *(_OWORD *)a3;
  }
  unsigned int v25 = *a1;
  if (a1[1]) {
    DecoderFilter = PCompressGetDecoderFilter(v25);
  }
  else {
    DecoderFilter = PCompressGetEncoderFilter(v25);
  }
  v114[0] = DecoderFilter;
  uint64_t v31 = calloc((int)a1[2], 0x48uLL);
  v114[1] = v31;
  if (!v31)
  {
    __int16 v37 = 468;
LABEL_99:
    uint64_t v86 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"initFilterState",  v37,  37,  *v86,  "malloc",  v87,  v88,  v106);
LABEL_100:
    uint32_t v89 = "initFilterState";
    __int16 v90 = 510;
LABEL_106:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"PCompressFilter",  v90,  37,  0,  v89,  v45,  v46,  v106);
    char v94 = 0;
    int v95 = 1;
    goto LABEL_107;
  }

  unint64_t v32 = a1[2];
  __int16 v33 = v31;
  size_t v34 = *((void *)a1 + 2);
  unint64_t v35 = malloc(v34);
  v33[1] = v35;
  char v36 = malloc(v34);
  v33[5] = v36;
  *__int16 v33 = &v108;
  __int16 v37 = 477;
  if (!v35 || !v36) {
    goto LABEL_99;
  }
  unint64_t v38 = 0LL;
  BOOL v39 = v33 + 9;
  do
  {
    if (v32 - 1 == v38) {
      goto LABEL_53;
    }
    int v40 = malloc(v34);
    v39[1] = v40;
    int v41 = malloc(v34);
    v39[5] = v41;
    *BOOL v39 = &v108;
    ++v38;
    if (!v40) {
      break;
    }
    v39 += 9;
  }

  while (v41);
  uint64_t v42 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"initFilterState",  477,  37,  *v42,  "malloc",  v43,  v44,  v106);
  if (v38 < v32) {
    goto LABEL_100;
  }
LABEL_53:
  unint64_t v107 = v109;
  signed int v47 = DWORD2(v108);
  uint64_t v48 = malloc(8LL * SDWORD2(v108));
  if (!v48)
  {
    int v91 = *__error();
    unint64_t v92 = "malloc";
    __int16 v93 = 372;
LABEL_104:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  v93,  37,  v91,  v92,  v59,  v60,  v106);
    goto LABEL_105;
  }

  uint64_t v49 = v48;
  if (v47 >= 1)
  {
    uint64_t v50 = (char *)v114[1];
    uint64_t v51 = v48;
    uint64_t v52 = v47;
    do
    {
      *v51++ = v50;
      v50 += 72;
      --v52;
    }

    while (v52);
  }

  uint64_t v53 = ThreadPipelineCreate( v47,  (uint64_t)v48,  (uint64_t)compressionWorkerProc,  (uint64_t)&v108,  (uint64_t)outputStreamProc,  0LL);
  if (!v53)
  {
    unint64_t v92 = "creating pipeline";
    __int16 v93 = 375;
    int v91 = 0;
    goto LABEL_104;
  }

  uint64_t v61 = (uint64_t)v53;
  uint64_t v62 = 0LL;
  int v63 = 1;
  unint64_t v64 = v107;
  while (1)
  {
    if (atomic_load(v115))
    {
      int v63 = 0;
      goto LABEL_121;
    }

    if (!v63) {
      break;
    }
    uint64_t Worker = ThreadPipelineGetWorker(v61, v54, v55, v56, v57, v58, v59, v60);
    if (!Worker)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  387,  37,  0,  "getting worker from pipeline",  v67,  v68,  v106);
      int v82 = 0;
LABEL_91:
      int v63 = 0;
      goto LABEL_92;
    }

    unint64_t v69 = (uint64_t *)Worker;
    if (DWORD1(v108) == 1)
    {
      uint64_t v70 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, (uint64_t)v117, 16LL);
      uint64_t v77 = v70;
      if (v70)
      {
        if (v70 < 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  397,  37,  0,  "reading block header",  v75,  v76,  v106);
          uint64_t v77 = 0LL;
        }

        else
        {
          if (v70 == 16)
          {
            unint64_t v78 = bswap64(v117[0]);
            unint64_t v79 = bswap64(v117[1]);
            if (v79 > v64 || v78 > v64)
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  405,  37,  0,  "Invalid block header payload=0x%llx raw=0x%llx block=0x%llx\n",  v75,  v76,  v79);
              int v82 = 0;
              int v83 = 0;
              uint64_t v77 = 16LL;
            }

            else
            {
              uint64_t v80 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, v69[1], v79);
              if (v80 < 0)
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  411,  37,  0,  "reading block payload",  v75,  v76,  v106);
                int v82 = 0;
                int v83 = 0;
                uint64_t v77 = 16LL;
              }

              else
              {
                uint64_t v77 = v80 + 16;
                if (v80 == v79)
                {
                  unint64_t v81 = v78;
                  int v82 = 0;
                  v69[3] = v79;
                  v69[4] = v81;
                  int v83 = 1;
                  v69[2] = v62;
                }

                else
                {
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  415,  37,  0,  "Truncated block payload (%lld/%llu bytes read)",  v75,  v76,  v80);
                  int v82 = 0;
                  int v83 = 0;
                }
              }

              unint64_t v64 = v107;
            }

            goto LABEL_81;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  399,  37,  0,  "Truncated block header (%lld/16 bytes read)",  v75,  v76,  v70);
        }

        int v82 = 0;
        int v83 = 0;
      }

      else
      {
        int v82 = 1;
        int v83 = 1;
      }
    }

    else
    {
      uint64_t v84 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, *(void *)(Worker + 8), v64);
      if (v84 < 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  428,  37,  0,  "reading block",  v75,  v76,  v106);
        int v82 = 0;
LABEL_87:
        int v63 = 0;
        uint64_t v85 = -1LL;
        goto LABEL_88;
      }

      uint64_t v77 = v84;
      if (!v84)
      {
        uint64_t v85 = -2LL;
        int v82 = 1;
        goto LABEL_86;
      }

      int v82 = 0;
      v69[3] = v84;
      v69[4] = 0LL;
      int v83 = 1;
      v69[2] = v62;
    }

  if (v24)
  {
    if (v24 >= 0x200000001LL)
    {
      *__error() = 12;
      *(void *)(v10 + 120) = 0LL;
LABEL_75:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState",  487,  67,  0,  "alloc holes",  v12,  v13,  164);
      *char v26 = 0LL;
      *(void *)(v10 + 112) = 0LL;
      goto LABEL_26;
    }

    BOOL v39 = calloc(v24, 0x10uLL);
    *(void *)(v10 + 120) = v39;
    if (!v39) {
      goto LABEL_75;
    }
  }

  int v40 = *((void *)&v59 + 1);
  if (*((void *)&v59 + 1))
  {
    int v41 = 0LL;
    uint64_t v43 = *(void *)(v10 + 64);
    uint64_t v42 = *(void *)(v10 + 72);
    do
    {
      if (v43 == v42)
      {
        uint64_t v44 = v42 + 0x40000;
        if (v42 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v42)
            {
              uint64_t v42 = 0x4000LL;
              uint64_t v46 = 0x4000LL;
              if (v44 <= 0x4000) {
                goto LABEL_52;
              }
            }

            uint64_t v45 = v42 >> 1;
            if ((v42 & (v42 >> 1)) != 0) {
              uint64_t v45 = v42 & (v42 >> 1);
            }
            v42 += v45;
          }

          while (v42 < v44);
          uint64_t v46 = v42;
          if (v42 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_82;
          }

  free(v9);
  return 0LL;
}

      uint64_t v20 = v12 + 24LL * v11;
      uint64_t v21 = *(void *)(v20 + 8) - __smax;
      *(void *)(v20 + 8) = v21;
      if (v21) {
        return 0LL;
      }
      if ((convertStreamEndBlob(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        unsigned int v14 = "finishing blob";
        uint64_t v15 = 457;
        goto LABEL_9;
      }

      *(_DWORD *)(a1 + 68) = 0;
      ++*(_DWORD *)(a1 + 76);
      if ((convertStreamToNextNonEmptyBlob(a1, v22, v23, v24, v25, v26, a7, a8) & 0x80000000) != 0)
      {
        unsigned int v14 = "iterating to next blob";
        uint64_t v15 = 461;
        goto LABEL_9;
      }

      if (*(_DWORD *)(a1 + 76) < *(_DWORD *)(a1 + 80) || (convertStreamEndEntry(a1) & 0x80000000) == 0) {
        return 0LL;
      }
      unsigned int v14 = "finishing entry";
      uint64_t v15 = 465;
LABEL_9:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamWriteBlob",  v15,  111,  0,  v14,  a7,  a8,  v37);
      if (!*(_DWORD *)(a1 + 48))
      {
        *(_DWORD *)(a1 + 48) = 1;
        AAArchiveStreamCancel(*(AAArchiveStream *)a1);
      }

      return 0xFFFFFFFFLL;
    }

    __int128 v24 = *v20;
    __int128 v23 = (char *)realloc(*v20, v13);
    if (v23)
    {
      *(void *)(a1 + 120) = v13;
      *(void *)(a1 + 128) = v23;
      uint64_t v10 = *(void *)(a1 + 112);
      goto LABEL_35;
    }

    free(v24);
LABEL_37:
    *uint64_t v20 = 0LL;
    _OWORD *v11 = 0LL;
    *(void *)(a1 + 120) = 0LL;
  }

  uint64_t v21 = "accumulating blob data";
  uint64_t v22 = 91;
LABEL_39:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamBeginBlob",  v22,  111,  0,  v21,  v7,  v8,  v27);
  uint64_t v9 = 0;
LABEL_40:
  if (v9) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

    memset(&v103, 0, sizeof(v103));
    uint64_t v53 = open(v108, 0);
    if (v53 < 0)
    {
      uint64_t v77 = *__error();
      uint64_t v80 = 830;
LABEL_90:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  v80,  102,  v77,  "open: %s",  v78,  v79,  (char)v108);
      goto LABEL_98;
    }

    uint64_t v54 = v53;
    if (fstat(v53, &v103) < 0)
    {
      unint64_t v81 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  831,  102,  v81,  "fstat: %s",  v82,  v83,  (char)v108);
      goto LABEL_97;
    }

    uint64_t v58 = ParallelArchiveECCVerifyFileSegment( v54,  0LL,  v103.st_size,  *((__int128 **)a4 + 1),  *((void *)a4 + 2),  v55,  v56,  v57);
    close(v54);
    if (v58 < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  834,  102,  0,  "verifying data: %s",  v47,  v48,  (char)v108);
      goto LABEL_98;
    }

    unint64_t v35 = v95;
    if (!v58)
    {
      v25 |= 0x80000u;
      goto LABEL_38;
    }

  int v40 = 0xFFFFFFFFLL;
LABEL_34:
  free(v12);
  free(v62);
  return v40;
}

LABEL_81:
    *(void *)&__int128 v113 = v113 + v77;
    if (!v82 && v83)
    {
      int v82 = 0;
      int v63 = 1;
      goto LABEL_89;
    }

    if (!v83) {
      goto LABEL_87;
    }
    uint64_t v85 = -2LL;
LABEL_86:
    int v63 = 1;
LABEL_88:
    v69[2] = v85;
LABEL_89:
    if ((ThreadPipelineRunWorker(v61, (uint64_t)v69, v71, v72, v73, v74, v75, v76) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"processStream",  445,  37,  0,  "RunWorker",  v59,  v60,  v106);
      goto LABEL_91;
    }

      uint64_t v50 = *v49;
      uint64_t v51 = realloc(*v49, v47);
      if (v51)
      {
        *((void *)v35 + 277) = v51;
        *((void *)v35 + 276) = v47;
        goto LABEL_83;
      }

      free(v50);
LABEL_168:
      void *v49 = 0LL;
      *((void *)v35 + 275) = 0LL;
      *((void *)v35 + 276) = 0LL;
      goto LABEL_169;
    }
  }

  uint64_t v61 = (char *)realloc(v67, v42);
  uint64_t v52 = v42;
  if (v61) {
    goto LABEL_82;
  }
  free(v67);
LABEL_101:
  unint64_t __s = 0LL;
  uint64_t v76 = 0LL;
  __ptr = 0LL;
  unint64_t v64 = "store padding";
  uint64_t v65 = 629;
LABEL_90:
  int v41 = 0;
LABEL_91:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"resizeResourceFork",  v65,  55,  v41,  v64,  v27,  v28,  v66);
LABEL_10:
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_11:
  free(__ptr);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  free(v11);
  free(v10);
  return v12;
}

uint64_t pcRead(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0LL;
  }
  uint64_t v4 = a4;
  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t v9 = a1(a2, a3, v4);
    uint64_t v12 = v9;
    if (v9 < 0) {
      break;
    }
    if (v9)
    {
      a3 += v9;
      v8 += v9;
      v4 -= v9;
      if (v4) {
        continue;
      }
    }

    return v8;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c",  (uint64_t)"pcRead",  82,  37,  0,  "pcRead failed",  v10,  v11,  v14);
  return v12;
}

uint64_t getHeader(unsigned int a1, uint64_t a2)
{
  int DecoderKey = PCompressGetDecoderKey(a1);
  if (DecoderKey == 63) {
    return 0xFFFFFFFFLL;
  }
  char v5 = DecoderKey;
  uint64_t result = 0LL;
  *(_DWORD *)a2 = 538976288;
  *(_WORD *)a2 = 25200;
  *(_BYTE *)(a2 + 2) = 122;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}

size_t PCompressCopyEncode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1LL;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

size_t PCompressCopyDecode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1LL;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

AEAAuthData AEAAuthDataCreate(void)
{
  v0 = (AEAAuthData_impl *)malloc(0x30uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
  }

  else
  {
    float v2 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataCreate",  19,  95,  *v2,  "malloc",  v3,  v4,  v6);
  }

  return v1;
}

void AEAAuthDataDestroy(AEAAuthData auth_data)
{
  if (auth_data)
  {
    free(*((void **)auth_data + 2));
    free(*((void **)auth_data + 5));
    memset_s((char *)auth_data + 24, 0x18uLL, 0, 0x18uLL);
    memset_s(auth_data, 0x30uLL, 0, 0x30uLL);
    free(auth_data);
  }

AEAAuthData AEAAuthDataCreateWithContext(AEAContext context)
{
  size_t __s = 0LL;
  size_t v51 = 0LL;
  __ptr = 0LL;
  size_t v49 = 0LL;
  AEAAuthData v2 = AEAAuthDataCreate();
  if (v2)
  {
    if (AEAContextGetFieldBlob(context, 5u, 0, 0LL, 0LL, &v49) < 0)
    {
      uint64_t v8 = "AEAContextGetFieldBlob";
      __int16 v9 = 46;
      goto LABEL_74;
    }

    if (!v49) {
      goto LABEL_95;
    }
    if ((v49 & 0x8000000000000000LL) == 0)
    {
      size_t v5 = v51;
      if (v51 >= v49)
      {
        uint64_t v10 = __ptr;
      }

      else
      {
        do
        {
          while (!v5)
          {
            size_t v5 = 0x4000LL;
            if (v49 <= 0x4000)
            {
              uint64_t v7 = __ptr;
              size_t v5 = 0x4000LL;
              goto LABEL_18;
            }
          }

          size_t v6 = v5 >> 1;
          if ((v5 & (v5 >> 1)) != 0) {
            size_t v6 = v5 & (v5 >> 1);
          }
          v5 += v6;
        }

        while (v5 < v49);
        if (v5 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_72;
        }

        uint64_t v7 = __ptr;
LABEL_18:
        uint64_t v10 = realloc(v7, v5);
        if (!v10)
        {
          free(v7);
LABEL_72:
          size_t v51 = 0LL;
          __ptr = 0LL;
          size_t __s = 0LL;
          goto LABEL_73;
        }

        size_t v51 = v5;
        __ptr = v10;
      }

      if ((AEAContextGetFieldBlob(context, 5u, 0, v5 - __s, (uint8_t *)v10 + __s, &v49) & 0x80000000) == 0)
      {
        size_t v11 = __s;
        if (!v49) {
          goto LABEL_25;
        }
        size_t v11 = __s + v49;
        if (!__CFADD__(__s, v49) && v11 <= v51)
        {
          __s += v49;
LABEL_25:
          uint64_t v12 = (char *)__ptr;
          *(void *)AEAAuthData v2 = 0LL;
          *((void *)v2 + 3) = 0LL;
          uint64_t v13 = (void *)((char *)v2 + 24);
          if (v11)
          {
            char v14 = 0;
            uint64_t v15 = (unint64_t *)((char *)v2 + 32);
            char v16 = 1;
            while (2)
            {
              size_t v17 = 0LL;
              unint64_t v18 = 0LL;
              char v19 = v16;
              do
              {
                if (v17 + 4 > v11) {
                  goto LABEL_105;
                }
                uint64_t v20 = *(unsigned int *)&v12[v17];
                BOOL v21 = __CFADD__(v20, v17);
                size_t v22 = v20 + v17;
                if (v21 || v22 > v11) {
                  goto LABEL_105;
                }
                if ((v14 & 1) != 0)
                {
                  uint64_t v23 = *((void *)v2 + 2);
                  uint64_t v24 = (*(void *)v2)++;
                  *(void *)(v23 + 8 * v24) = v17;
                }

                ++v18;
                size_t v17 = v22;
              }

              while (v22 < v11);
              if (v22 != v11) {
                goto LABEL_105;
              }
              if ((v19 & 1) == 0)
              {
LABEL_61:
                *uint64_t v13 = 0LL;
                if ((v11 & 0x8000000000000000LL) == 0)
                {
                  unint64_t v34 = *v15;
                  if (*v15 < v11)
                  {
                    size_t v35 = 0x4000LL;
                    do
                    {
                      while (!v34)
                      {
                        unint64_t v34 = 0x4000LL;
                        if (v11 <= 0x4000) {
                          goto LABEL_78;
                        }
                      }

                      unint64_t v36 = v34 >> 1;
                      if ((v34 & (v34 >> 1)) != 0) {
                        unint64_t v36 = v34 & (v34 >> 1);
                      }
                      v34 += v36;
                    }

                    while (v34 < v11);
                    size_t v35 = v34;
                    if (v34 >= 0x2000000001LL)
                    {
                      *__error() = 12;
                      goto LABEL_104;
                    }

LABEL_78:
                    __int16 v37 = (void *)*((void *)v2 + 5);
                    size_t v38 = v35;
                    BOOL v39 = realloc(v37, v35);
                    if (v39)
                    {
                      *((void *)v2 + 4) = v38;
                      *((void *)v2 + 5) = v39;
                      goto LABEL_80;
                    }

                    free(v37);
LABEL_104:
                    *uint64_t v15 = 0LL;
                    *((void *)v2 + 5) = 0LL;
                    goto LABEL_105;
                  }

          unint64_t v42 = (void *)*((void *)v9 + 9);
          uint64_t v43 = realloc(v42, v41);
          if (v43)
          {
            *((void *)v9 + 8) = v41;
            *((void *)v9 + 9) = v43;
            size_t v38 = *((void *)v9 + 7);
            goto LABEL_80;
          }

          free(v42);
LABEL_125:
          *uint64_t v24 = 0LL;
          *((void *)v9 + 8) = 0LL;
          *((void *)v9 + 9) = 0LL;
          goto LABEL_122;
        }

        size_t v38 = v37;
      }

      unint64_t v41 = v37;
LABEL_80:
      if (v41 - v38 >= v35) {
        uint64_t v44 = v35;
      }
      else {
        uint64_t v44 = v41 - v38;
      }
      uint64_t v45 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 9) + v38), v44);
      if (v45 < 0) {
        goto LABEL_122;
      }
      if (!v45) {
        break;
      }
      size_t v38 = *v24 + v45;
      if (!__CFADD__(*v24, v45))
      {
        __int16 v37 = *((void *)v9 + 8);
        if (v38 <= v37) {
          continue;
        }
      }

      goto LABEL_122;
      *uint64_t v24 = v38;
      v36 += v45;
      v35 -= v45;
    }

    while (v35);
    if (v36 < 0) {
      goto LABEL_122;
    }
  }

  uint64_t v46 = *((void *)&v60 + 1);
  if (*((void *)&v60 + 1))
  {
    signed int v47 = 0LL;
    size_t v49 = *((void *)v9 + 10);
    uint64_t v48 = *((void *)v9 + 11);
    do
    {
      if (v49 == v48)
      {
        uint64_t v50 = v48 + 0x40000;
        if (v48 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v48)
            {
              uint64_t v48 = 0x4000LL;
              uint64_t v52 = 0x4000LL;
              if (v50 <= 0x4000) {
                goto LABEL_104;
              }
            }

            size_t v51 = v48 >> 1;
            if ((v48 & (v48 >> 1)) != 0) {
              size_t v51 = v48 & (v48 >> 1);
            }
            v48 += v51;
          }

          while (v48 < v50);
          uint64_t v52 = v48;
          if (v48 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_128;
          }

    __break(1u);
  }

        uint64_t v50 = v12[283];
        if (__src)
        {
          memcpy((void *)(v50 + *v39), __src, __smax);
        }

        else if (v50)
        {
          memset_s((void *)(v50 + *v39), __smax, 0, __smax);
        }

        *v39 += __smax;
        if ((__smax & 0x8000000000000000LL) == 0)
        {
LABEL_96:
          if (v13 && (extractThreadSendCommand(v13, 89, __smax, __src) & 0x80000000) != 0)
          {
            char v14 = "sending blob";
            uint64_t v15 = 1444;
            goto LABEL_8;
          }

          goto LABEL_97;
        }
      }

LABEL_80:
                  uint64_t v40 = *((void *)v2 + 5);
                  if (v12)
                  {
                    memcpy((void *)(v40 + *v13), v12, v11);
                  }

                  else if (v40)
                  {
                    memset_s((void *)(v40 + *v13), v11, 0, v11);
                  }

                  *((void *)v2 + 3) += v11;
                  unint64_t v41 = *(void *)v2;
                  if (*(void *)v2)
                  {
                    unint64_t v42 = 0LL;
                    while (1)
                    {
                      if (v41 <= v42)
                      {
                        uint64_t v43 = 0LL;
                        uint64_t v44 = 0xFFFFFFFFLL;
                      }

                      else
                      {
                        uint64_t v43 = (unsigned int *)(*((void *)v2 + 5) + *(void *)(*((void *)v2 + 2) + 8 * v42));
                        uint64_t v44 = *v43;
                        if (v44 < 5)
                        {
LABEL_97:
                          uint64_t v8 = "invalid auth_data key";
                          __int16 v9 = 74;
                          goto LABEL_74;
                        }
                      }

                      uint64_t v45 = (unsigned __int8 *)(v43 + 1);
                      uint64_t v46 = v44 - 4;
                      while (*v45++)
                      {
                        if (!--v46) {
                          goto LABEL_97;
                        }
                      }

                      if (++v42 == v41) {
                        goto LABEL_95;
                      }
                    }
                  }

                  break;
                }

        if (Path < 0)
        {
          uint64_t v77 = 0;
          if ((v71 & 1) == 0) {
            goto LABEL_88;
          }
        }

        else
        {
          if (*(_DWORD *)(v81 + 2300) != 2) {
            *(_DWORD *)(v81 + 2300) = 2;
          }
          uint64_t v77 = 1;
          if ((v71 & 1) == 0) {
            goto LABEL_88;
          }
        }

LABEL_105:
                *(void *)AEAAuthData v2 = 0LL;
                *((void *)v2 + 3) = 0LL;
                uint64_t v8 = "invalid auth data blob";
                __int16 v9 = 62;
LABEL_74:
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataCreateWithContext",  v9,  95,  0,  v8,  v3,  v4,  v49);
                free(__ptr);
                memset_s(&__s, 0x18uLL, 0, 0x18uLL);
                AEAAuthDataDestroy(v2);
                return 0LL;
              }

              if (v18 > 0xFFFFFFFE) {
                goto LABEL_105;
              }
              unint64_t v25 = *((void *)v2 + 1);
              if (v25 < v18)
              {
                unint64_t v26 = *((void *)v2 + 1);
                do
                {
                  if (v26) {
                    v26 *= 2LL;
                  }
                  else {
                    unint64_t v26 = 16LL;
                  }
                }

                while (v26 < v18);
                if (v26 > v25)
                {
                  *((void *)v2 + 1) = v26;
                  if (8 * v26 >= 0x2000000001LL)
                  {
                    *__error() = 12;
                  }

                  else
                  {
                    int8x16_t v27 = (void *)*((void *)v2 + 2);
                    uint64_t v28 = realloc(v27, 8 * v26);
                    if (v28)
                    {
                      *((void *)v2 + 2) = v28;
                      goto LABEL_48;
                    }

                    free(v27);
                  }

                  *((void *)v2 + 2) = 0LL;
                  goto LABEL_105;
                }
              }

      if (*((_DWORD *)a1 + 6) >= 3u) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "<<< range %10llx %10llx\n", v56, v57);
      }
      unint64_t v69 = a1[20];
      uint64_t v68 = a1[21];
      a1[20] = (void *)((char *)v69 + 1);
      *(_OWORD *)&v68[2 * (void)v69] = v179;
      v51 += (unint64_t)v57 - v56;
      do
        uint64_t v70 = __ldxr(v3);
      while (__stxr((unint64_t)v57 + v70 - v56, v3));
      do
        uint64_t v71 = __ldxr(v4);
      while (__stxr(v71 + 1, v4));
      uint64_t v72 = a1[17];
      uint64_t v73 = a1[18];
      if (v72 == v73)
      {
        *uint64_t v169 = v179;
      }

      else if (v57 != (void *)v56)
      {
        if (v57 > v73) {
          uint64_t v73 = v57;
        }
        a1[17] = v72;
        a1[18] = v73;
      }

      uint64_t v175 = 1;
LABEL_119:
    }

    if (*((_DWORD *)a1 + 6) >= 3u) {
      fwrite("<<< range EOF\n", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
    *((_DWORD *)a1 + 32) = 1;
LABEL_126:
    if (!v175) {
      goto LABEL_4;
    }
    stateSortRanges((uint64_t)a1);
LABEL_5:
    if (pthread_mutex_lock(v176))
    {
      size_t v158 = "lock";
      unint64_t v159 = 276;
LABEL_277:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateRetireRanges",  v159,  143,  0,  v158,  v5,  v6,  v168);
LABEL_278:
      size_t v156 = "retiring ranges";
      v157 = 497;
      goto LABEL_283;
    }

    uint64_t v7 = a1[20];
    if (!v7) {
      goto LABEL_129;
    }
    uint64_t v171 = 0;
    uint64_t v8 = 0LL;
    __int16 v9 = 1;
    while (2)
    {
      uint64_t v10 = a1[21];
      size_t v11 = (unint64_t)a1[1];
      while (2)
      {
        uint64_t v12 = &v10[2 * v8];
        char v14 = (unint64_t *)(v12 + 1);
        uint64_t v13 = v12[1];
        uint64_t v15 = *v12;
        char v16 = *v12 / v11;
        size_t v17 = (v13 + v11 - 1) / v11;
        unint64_t v18 = v16 < v17;
        if (v16 < v17)
        {
          char v19 = (unint64_t)a1[14];
          if (v19 <= v16) {
            char v19 = v15 / v11;
          }
          uint64_t v20 = 1;
          BOOL v21 = v10[2 * v8];
          size_t v22 = v15 / v11;
          while (v22 != v19)
          {
            uint64_t v23 = a1[15][v22];
            if (v23 == -1) {
              break;
            }
            uint64_t v24 = a1[13];
            unint64_t v25 = v24[6 * v23];
            if (!v25 || v22 != v24[6 * v23 + 1])
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateRetireRanges",  291,  143,  0,  "invalid state",  v5,  v6,  v168);
              uint64_t v48 = 1;
              goto LABEL_79;
            }

            if (v25 != 3) {
              break;
            }
            if (v21 == v13
              || (v21 <= v22 * v11 ? (unint64_t v26 = v22 * v11) : (unint64_t v26 = v21),
                  v22 * v11 + v11 >= v13 ? (int8x16_t v27 = (char *)v12[1]) : (int8x16_t v27 = (char *)(v22 * v11 + v11)),
                  v26 >= (unint64_t)v27))
            {
              unint64_t v26 = 0LL;
              int8x16_t v27 = 0LL;
            }

            uint64_t v28 = 0LL;
            unint64_t v29 = &v24[6 * v23];
            size_t v31 = v29[2];
            unint64_t v30 = v29[3];
            if (v31 != v30) {
              BOOL v21 = v12[1];
            }
            unint64_t v32 = 0LL;
            if (v13 != v15 && v31 != v30)
            {
              if (v15 <= v31) {
                unint64_t v32 = v31;
              }
              else {
                unint64_t v32 = v10[2 * v8];
              }
              if (v30 >= v13) {
                uint64_t v28 = v12[1];
              }
              else {
                uint64_t v28 = v30;
              }
              if (v32 >= v28)
              {
                uint64_t v28 = 0LL;
                unint64_t v32 = 0LL;
              }

              else if (v27 == (char *)v26)
              {
                break;
              }

              BOOL v21 = v10[2 * v8];
            }

            __int16 v33 = v27 != (char *)v26 && v28 == v32;
            unint64_t v34 = v33;
            if (v28 < (unint64_t)v27)
            {
              if (!v20) {
                goto LABEL_57;
              }
              break;
            }

            uint64_t v20 = ++v22 < v17;
            if (v22 == v17)
            {
              unint64_t v18 = 1;
              goto LABEL_57;
            }
          }

          if ((v9 & 1) != 0)
          {
LABEL_129:
            uint64_t v48 = 0;
            signed int v47 = 0;
            goto LABEL_130;
          }

LABEL_48:
              if ((v11 & 0x8000000000000000LL) != 0) {
                goto LABEL_105;
              }
              unint64_t v29 = *v15;
              if (*v15 < v11)
              {
                do
                {
                  while (!v29)
                  {
                    unint64_t v29 = 0x4000LL;
                    size_t v31 = 0x4000LL;
                    if (v11 <= 0x4000) {
                      goto LABEL_58;
                    }
                  }

                  unint64_t v30 = v29 >> 1;
                  if ((v29 & (v29 >> 1)) != 0) {
                    unint64_t v30 = v29 & (v29 >> 1);
                  }
                  v29 += v30;
                }

                while (v29 < v11);
                size_t v31 = v29;
                if (v29 >= 0x2000000001LL)
                {
                  *__error() = 12;
                  goto LABEL_99;
                }

      BOOL v39 = 0;
    }

    else
    {
      BOOL v39 = *__error();
      uint64_t v40 = "malloc";
      unint64_t v41 = 24;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"processWithProgress",  v41,  127,  v39,  v40,  v13,  v14,  v42);
  }

  free(v12);
  AAByteStreamCancel(a1);
  AAByteStreamCancel(a2);
  return 0xFFFFFFFFLL;
}

                  close(v7);
                  if ((v20 & 0x80000000) != 0) {
                    goto LABEL_30;
                  }
                  close(v20);
                  if (!v47) {
                    goto LABEL_30;
                  }
                  goto LABEL_66;
                }

                uint64_t v48 = "setting attributes";
                size_t v49 = 1042;
LABEL_46:
                uint64_t v50 = 0;
LABEL_47:
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  v49,  102,  v50,  v48,  v45,  v46,  v62);
                unint64_t v36 = 0;
                signed int v47 = 1;
                goto LABEL_48;
              }

LABEL_60:
              char v16 = 0;
              char v14 = 1;
              if ((v19 & 1) != 0) {
                continue;
              }
              goto LABEL_61;
            }
          }

  if (v39 != v37)
  {
LABEL_64:
    uint64_t v8 = "reading segment data";
    __int16 v9 = 198;
    goto LABEL_3;
  }

  unint64_t v42 = (unint64_t *)(v10 + 32);
  do
    uint64_t v43 = __ldaxr(v42);
  while (__stlxr(v43 + v37, v42));
  uint64_t result = 0LL;
  ++*(_DWORD *)(v10 + 48);
  ++*(_DWORD *)(v10 + 56);
  uint64_t v44 = a2[1];
  *(_DWORD *)(v10 + 64) = 0;
  *(_DWORD *)(v10 + 68) = v44;
  return result;
}

    uint64_t v44 = "SemAcquire";
    uint64_t v45 = 135;
    goto LABEL_62;
  }

  __break(1u);
  return result;
}

              memset_s(v22, v19, 0, v19);
LABEL_61:
              free(v22);
              if (v25) {
                memset_s(v25, v19, 0, v19);
              }
              free(v25);
              if (v29) {
                memset_s(v29, v28, 0, v28);
              }
              free(v29);
              if (v36) {
                return (AAByteStream)v10;
              }
              goto LABEL_40;
            }

            unint64_t v42 = 0;
          }

          else
          {
            unint64_t v42 = 0;
            uint64_t v28 = 0LL;
          }

          unint64_t v29 = 0LL;
          goto LABEL_49;
        }

        size_t v31 = "removing padding";
        unint64_t v32 = 471;
        goto LABEL_38;
      }
    }

    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }

    size_t v31 = "deriving signature encryption key";
    unint64_t v32 = 467;
LABEL_38:
    unint64_t v30 = 0;
    goto LABEL_39;
  }

  __break(1u);
  return result;
}

  if (AAByteStreamClose(v15) < 0)
  {
    size_t v11 = "AFSC stream close";
    uint64_t v12 = 1222;
    goto LABEL_5;
  }

      uint64_t v15 = "Invalid stream compression key";
      char v16 = 317;
      goto LABEL_15;
    }

    unint64_t v79 = 0LL;
    unint64_t v30 = 2049;
  }

LABEL_95:
          free(__ptr);
          memset_s(&__s, 0x18uLL, 0, 0x18uLL);
          return v2;
        }
      }
    }

uint32_t AEAAuthDataGetEntryCount(AEAAuthData auth_data)
{
  return *(_DWORD *)auth_data;
}

int AEAAuthDataGetEntry( AEAAuthData auth_data, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  if (*(void *)auth_data <= (unint64_t)i)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataGetEntry",  98,  95,  0,  "invalid entry index %u",  (uint64_t)data,  (uint64_t)data_size,  i);
    return -1;
  }

  uint64_t v8 = (unsigned int *)(*((void *)auth_data + 5) + *(void *)(*((void *)auth_data + 2) + 8LL * i));
  __int16 v9 = v8 + 1;
  unint64_t v10 = *v8;
  size_t v14 = 0LL;
  while (v9[v14])
  {
  }

  if ((int)v10 - 5 - (int)v14 >= v10)
  {
LABEL_15:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataGetEntry",  109,  95,  0,  "invalid auth_data blob",  (uint64_t)data,  (uint64_t)data_size,  v17);
    return -1;
  }

  size_t v15 = (v10 - 5 - v14);
  if (key_length) {
    *key_length = v14;
  }
  if (data_size) {
    *data_uint64_t size = v15;
  }
  if (v14 >= key_capacity)
  {
    if (key_capacity) {
      return -1;
    }
  }

  else
  {
    memcpy(key, v9, v14);
    key[v14] = 0;
  }

  if (v15 > data_capacity)
  {
    if (!data_capacity) {
      return 0;
    }
    return -1;
  }

  memcpy(data, (char *)v8 + v10 - (v10 - 5 - v14), (v10 - 5 - v14));
  return 0;
}

int AEAAuthDataAppendEntry(AEAAuthData auth_data, const char *key, const uint8_t *data, size_t data_size)
{
  size_t v8 = strlen(key);
  size_t v11 = v8 + 1;
  size_t v12 = v8 + 5;
  if (v8 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (rsize_t v15 = data_size + v12, __CFADD__(data_size, v12)) || v15 >= 0xFFFFFFFF)
  {
    uint64_t v13 = "invalid attribute size";
    __int16 v14 = 148;
LABEL_49:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataAppendEntry",  v14,  95,  0,  v13,  v9,  v10,  (char)v43);
    return -1;
  }

  char v16 = (void *)((char *)auth_data + 24);
  unint64_t v17 = *((void *)auth_data + 3);
  unint64_t v18 = v17 + v15;
  if (__CFADD__(v17, v15)) {
    goto LABEL_48;
  }
  uint64_t v20 = *(void *)auth_data;
  unint64_t v19 = *((void *)auth_data + 1);
  unint64_t v21 = *(void *)auth_data + 1LL;
  if (v19 < v21)
  {
    unint64_t v22 = *((void *)auth_data + 1);
    do
    {
      if (v22) {
        v22 *= 2LL;
      }
      else {
        unint64_t v22 = 16LL;
      }
    }

    while (v22 < v21);
    if (v22 > v19)
    {
      uint64_t v24 = (void *)((char *)auth_data + 16);
      uint64_t v23 = (void **)*((void *)auth_data + 2);
      *((void *)auth_data + 1) = v22;
      if (8 * v22 >= 0x2000000001LL)
      {
        *__error() = 12;
LABEL_47:
        *(void *)auth_data = 0LL;
        *uint64_t v24 = 0LL;
        *((void *)auth_data + 3) = 0LL;
        goto LABEL_48;
      }

      uint64_t v43 = v23;
      uint64_t v44 = v20;
      unint64_t v25 = realloc(v23, 8 * v22);
      if (!v25)
      {
        free(v43);
        goto LABEL_47;
      }

      *uint64_t v24 = v25;
      uint64_t v20 = v44;
    }
  }

  if ((v18 & 0x8000000000000000LL) != 0) {
    goto LABEL_43;
  }
  size_t v26 = *((void *)auth_data + 4);
  if (v26 < v18)
  {
    do
    {
      while (!v26)
      {
        size_t v26 = 0x4000LL;
        if (v18 <= 0x4000)
        {
          size_t v26 = 0x4000LL;
          goto LABEL_29;
        }
      }

      size_t v27 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0) {
        size_t v27 = v26 & (v26 >> 1);
      }
      v26 += v27;
    }

    while (v26 < v18);
    if (v26 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_42;
    }

LABEL_29:
    uint64_t v45 = v20;
    uint64_t v28 = (void *)*((void *)auth_data + 5);
    unint64_t v29 = realloc(v28, v26);
    if (v29)
    {
      *((void *)auth_data + 4) = v26;
      *((void *)auth_data + 5) = v29;
      uint64_t v20 = v45;
      goto LABEL_31;
    }

    free(v28);
LABEL_42:
    *((void *)auth_data + 4) = 0LL;
    *((void *)auth_data + 5) = 0LL;
LABEL_43:
    *(void *)auth_data = 0LL;
    *((void *)auth_data + 3) = 0LL;
    goto LABEL_48;
  }

      uint64_t v50 = v27;
      size_t v51 = v16;
      size_t v49 = v30;
      __int16 v37 = (char *)realloc(v18, v30);
      if (v37)
      {
        size_t v27 = v50;
        *((void *)auth_data + 4) = v49;
        *((void *)auth_data + 5) = v37;
        unint64_t v18 = v37;
        char v16 = v51;
        unint64_t v21 = (unint64_t *)((char *)auth_data + 24);
        uint64_t v23 = v22 - v20;
        goto LABEL_31;
      }

      free(v18);
LABEL_44:
      *((void *)auth_data + 3) = 0LL;
      *((void *)auth_data + 4) = 0LL;
      *((void *)auth_data + 5) = 0LL;
      goto LABEL_8;
    }

    uint64_t v46 = v13;
    if (v42)
    {
      size_t v12 = (uint8_t *)v20;
      if (!v20) {
        size_t v12 = (uint8_t *)malloc(__size);
      }
      if (!v11)
      {
        uint64_t v30 = *(void *)(a1 + 24);
        if (v30)
        {
          if (v30 < 0x2000000001LL)
          {
            size_t v11 = malloc(v30);
          }

          else
          {
            size_t v11 = 0LL;
            *__error() = 12;
          }
        }
      }

      if (!v12 || !v11 && *(void *)(a1 + 24))
      {
        __int16 v33 = *__error();
        unint64_t v34 = "malloc";
        size_t v35 = 100;
        goto LABEL_52;
      }

      uint64_t v20 = v12;
      unint64_t v22 = *(void *)(a1 + 16);
    }

    unint64_t v31 = v22;
    size_t v12 = (uint8_t *)v20;
    if (aeaContainerLoadSegment(v31, *(void **)a1, v21, v47, v20, v11, a7, a8) < 0) {
      break;
    }
    if ((v45 & 1) == 0) {
      memcpy(a2, &v47[v43 - v23], v27);
    }
    v8 += v27;
    a2 += v27;
    v14 += v27;
    unint64_t v17 = v41;
    uint64_t v13 = v46;
    unint64_t v19 = __size;
    if (v8 >= v41) {
      goto LABEL_47;
    }
  }

  unint64_t v34 = "loading segment";
  size_t v35 = 105;
  __int16 v33 = 0;
LABEL_52:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c",  (uint64_t)"BlockDecryptionStreamPRead",  v35,  122,  v33,  v34,  a7,  a8,  v40);
  __int16 v14 = -1LL;
  uint64_t v13 = v46;
LABEL_47:
  free(v13);
  free(v12);
  free(v11);
  return v14;
}

    if (OECCStreamWrite(*(void *)(a1 + 776), (char *)__src, __smax, __smax, a5, a6, a7, a8) != __smax)
    {
      __int16 v14 = "updating YEC field";
      rsize_t v15 = 436;
      goto LABEL_9;
    }

    goto LABEL_30;
  }

  return result;
}

      if (pthread_mutex_unlock((pthread_mutex_t *)&v4[10 * v21]) < 0) {
        goto LABEL_58;
      }
LABEL_30:
      if (++v21 == 3)
      {
        uint64_t v20 = *(void *)(v7 + 2048);
        goto LABEL_32;
      }
    }

    if (v21 >= 2)
    {
      uint64_t v28 = *(void *)(v7 + 2320);
      if (v28 != -1)
      {
LABEL_25:
        *(void *)(v26 + 32 * v23 + 24) = v28;
        goto LABEL_29;
      }
    }

    unint64_t v29 = v7 + 8 * v21;
    if (!*(void *)(v29 + 2336))
    {
      uint64_t v30 = v26 + 32 * v23;
      *(void *)(v29 + 2336) = *(void *)(v30 + 8);
      *(void *)(v30 + 8) = v7;
      do
        unint64_t v31 = __ldaxr(v22);
      while (__stlxr(v31 + 1, v22));
      goto LABEL_29;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"clusterInsertEntry",  574,  72,  0,  "entry already linked",  v24,  v25,  v69);
    if ((pthread_mutex_unlock((pthread_mutex_t *)&v4[10 * v21]) & 0x80000000) == 0) {
      goto LABEL_60;
    }
LABEL_58:
    __int16 v37 = *__error();
    uint64_t v40 = 585;
    uint64_t v41 = "pthread_mutex_unlock";
LABEL_59:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"clusterInsertEntry",  v40,  72,  v37,  v41,  v38,  v39,  v69);
LABEL_60:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"retireThreadProc",  674,  72,  0,  "clusterInsertEntry failed: %s",  v52,  v53,  v7);
    if (*(_DWORD *)(v7 + 2300) != -1) {
      goto LABEL_67;
    }
LABEL_69:
    entryRelease(v7, v8, v9, v10, v11, v12, v13, v14);
LABEL_70:
    if (pthread_mutex_lock(v2))
    {
LABEL_71:
      uint64_t v65 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"retireThreadDequeue",  637,  72,  *v65,  "pthread_mutex_lock",  v66,  v67,  v69);
      return a1;
    }
  }

    uint64_t v45 = v20;
    uint64_t v28 = (void *)*((void *)xat + 5);
    unint64_t v29 = realloc(v28, v26);
    if (v29)
    {
      *((void *)xat + 4) = v26;
      *((void *)xat + 5) = v29;
      uint64_t v20 = v45;
      goto LABEL_31;
    }

    free(v28);
LABEL_42:
    *((void *)xat + 4) = 0LL;
    *((void *)xat + 5) = 0LL;
LABEL_43:
    *(void *)xat = 0LL;
    *((void *)xat + 3) = 0LL;
    goto LABEL_48;
  }

      uint64_t v50 = v27;
      size_t v51 = v16;
      size_t v49 = v30;
      __int16 v37 = (char *)realloc(v18, v30);
      if (v37)
      {
        size_t v27 = v50;
        *((void *)xat + 4) = v49;
        *((void *)xat + 5) = v37;
        unint64_t v18 = v37;
        char v16 = v51;
        unint64_t v21 = (unint64_t *)((char *)xat + 24);
        uint64_t v23 = v22 - v20;
        goto LABEL_31;
      }

      free(v18);
LABEL_44:
      *((void *)xat + 3) = 0LL;
      *((void *)xat + 4) = 0LL;
      *((void *)xat + 5) = 0LL;
      goto LABEL_8;
    }

  uint64_t v43 = v88 - 1;
  if ((**(_BYTE **)(v9 + 8) & 4) == 0 || (uint64_t v44 = strrchr(__s, 46)) == 0LL || strcasecmp(v44, ".dmg"))
  {
LABEL_32:
    uint64_t v45 = 1;
    HIDWORD(v100) = 1;
    uint64_t v46 = *((void *)v104 + v43);
    *(void *)&uint64_t v97 = *(void *)(v9 + 48);
    *((void *)&v97 + 1) = v104;
    *(void *)&uint64_t v98 = v105;
    *((void *)&v98 + 1) = v46;
    *(void *)&char v99 = *((void *)v105 + v43);
    LODWORD(v100) = 2 * (*(_DWORD *)(*v8 + 16) != 0);
    uint64_t v50 = "BXDiff5";
    size_t v51 = 586;
LABEL_53:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  v51,  27,  0,  v50,  v13,  v14,  v84);
    goto LABEL_54;
  }

  if (snprintf(v106, 0x400uLL, "%s/0x%08zx", (const char *)(v9 + 92), v8[1]) >= 0x400)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  525,  27,  0,  "patch path: %s",  v55,  v56,  (char)__s);
    goto LABEL_54;
  }

  unint64_t v64 = v15;
  uint64_t v65 = strlen(v106);
  unint64_t v66 = v65 + 1;
  if (v65 + 1 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_73:
    v95[1] = 0LL;
    uint64_t v50 = "aaStrdup";
    size_t v51 = 527;
    goto LABEL_53;
  }

  unint64_t v69 = (char *)malloc(v65 + 1);
  if (!v69) {
    goto LABEL_73;
  }
  uint64_t v70 = v69;
  memcpy(v69, v106, v66);
  v95[1] = v70;
  uint64_t v71 = *(void *)(v9 + 56);
  if (v71 >= 0x400000001LL)
  {
    *__error() = 12;
    v94[1] = 0LL;
LABEL_86:
    uint64_t v50 = "aaCalloc";
    size_t v51 = 531;
    goto LABEL_53;
  }

  uint64_t v72 = calloc(v71, 8uLL);
  v94[1] = v72;
  if (!v72) {
    goto LABEL_86;
  }
  if (*(void *)(v9 + 56))
  {
    uint64_t v73 = (char **)v72;
    uint64_t v74 = 0LL;
    while (1)
    {
      snprintf(v106, 0x400uLL, "%s-%zd.dmg", v70, v74);
      uint64_t v75 = strlen(v106);
      uint64_t v76 = v75 + 1;
      if (v75 + 1 >= 0x2000000001LL)
      {
        *__error() = 12;
LABEL_94:
        uint64_t v50 = "aaStrdup";
        size_t v51 = 539;
        goto LABEL_53;
      }

      uint64_t v77 = (char *)malloc(v75 + 1);
      if (!v77) {
        goto LABEL_94;
      }
      unint64_t v78 = v77;
      memcpy(v77, v106, v76);
      unint64_t v79 = v74 >= *(void *)(v9 + 56) - 1LL ? v95 : v73;
      void *v79 = v78;
      if ((storeFileContents(v106, *((void *)v104 + v74), *((void *)v105 + v74)) & 0x80000000) != 0) {
        break;
      }
      ++v74;
      int v82 = *(void *)(v9 + 56);
      ++v73;
      if (v74 >= v82)
      {
        int v83 = v82 - 1;
        goto LABEL_88;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  546,  27,  0,  "storeFileContents %s",  v80,  v81,  (char)v106);
    goto LABEL_54;
  }

  int v83 = -1LL;
LABEL_88:
  v94[0] = (void *)v83;
  LODWORD(v96) = 1;
  DWORD2(v96) = 1;
  saveThreadErrorContext(offset);
  rsize_t v15 = v64;
  if (RawImageDiff((uint64_t)v94))
  {
    unlink(v95[1]);
    char v16 = v89;
    if ((**(_BYTE **)(v9 + 8) & 8) != 0)
    {
      uint64_t v50 = "RawImageDiff";
      size_t v51 = 573;
      goto LABEL_53;
    }

    restoreThreadErrorContext(offset);
    goto LABEL_32;
  }

  if (stat(v95[1], &size))
  {
    uint64_t v50 = "stat";
    size_t v51 = 563;
    goto LABEL_53;
  }

  uint64_t v45 = 0;
  st_uint64_t size = size.st_size;
  char v16 = v89;
LABEL_33:
  CompressedSize = ParallelCompressionGetCompressedSize(*((void *)v104 + v43), *((void *)v105 + v43), 1);
  if (CompressedSize <= 0) {
    CompressedSize = *((void *)v105 + v43);
  }
  uint64_t v48 = st_size;
  if (CompressedSize >= st_size)
  {
    if ((v45 & 1) == 0)
    {
      uint64_t v54 = v16 + 984 * v15;
      free(*(void **)(v54 + 48));
      memset_s((void *)(v54 + 32), 0x18uLL, 0, 0x18uLL);
      size_t v49 = 0LL;
      *(void *)(v54 + 16) = st_size;
      goto LABEL_55;
    }

    if (st_size < *(void *)(*(void *)(v9 + 8) + 120LL))
    {
      *(void *)(v16 + 984 * v15 + 24) = v101;
      uint64_t v101 = 0LL;
LABEL_69:
      size_t v49 = 0LL;
      *(void *)(v16 + 984 * v15 + 16) = v48;
      goto LABEL_55;
    }

    if (snprintf(v106, 0x400uLL, "%s/0x%08zx", (const char *)(v9 + 92), v8[1]) >= 0x400)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  612,  27,  0,  "patch path: %s",  v62,  v63,  (char)__s);
      goto LABEL_54;
    }

    if ((storeFileContents(v106, (uint64_t)v101, st_size) & 0x80000000) == 0)
    {
      uint64_t v48 = st_size;
      goto LABEL_69;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  613,  27,  0,  "storing patch: %s",  v67,  v68,  (char)__s);
LABEL_54:
    size_t v49 = 0xFFFFFFFFLL;
    goto LABEL_55;
  }

  *(_DWORD *)(v16 + 984 * v15 + 8) = 3;
  if (*(_DWORD *)(v9 + 24) >= 2u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "ARCHIVE (smaller than patch): %s\n", __s);
  }
  size_t v49 = 0LL;
LABEL_55:
  if (*(void *)(v9 + 56))
  {
    uint64_t v57 = 0LL;
    do
    {
      free(*((void **)v104 + v57));
      if (v94[1]) {
        free(*((void **)v94[1] + v57));
      }
      ++v57;
    }

    while (v57 < *(void *)(v9 + 56));
  }

  free(v94[1]);
  free(v95[0]);
  free(v95[1]);
  free(v101);
  return v49;
}

LABEL_31:
  uint64_t v30 = *v16;
  unint64_t v31 = *v16 + v15;
  if (__CFADD__(*v16, v15) || (v31 & 0x8000000000000000LL) != 0) {
    goto LABEL_48;
  }
  if (v26 < v31)
  {
    do
    {
      while (!v26)
      {
        size_t v26 = 0x4000LL;
        if (v31 <= 0x4000)
        {
          uint64_t v46 = v20;
          __int16 v33 = (void **)((char *)auth_data + 40);
          size_t v26 = 0x4000LL;
          goto LABEL_53;
        }
      }

      size_t v32 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0) {
        size_t v32 = v26 & (v26 >> 1);
      }
      v26 += v32;
    }

    while (v26 < v31);
    __int16 v33 = (void **)((char *)auth_data + 40);
    if (v26 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_61;
    }

    uint64_t v46 = v20;
LABEL_53:
    uint64_t v43 = v33;
    __int16 v37 = *v33;
    unint64_t v34 = (char *)realloc(v37, v26);
    if (v34)
    {
      *((void *)auth_data + 5) = v34;
      size_t v35 = (void *)((char *)auth_data + 40);
      *((void *)auth_data + 4) = v26;
      uint64_t v30 = *((void *)auth_data + 3);
      goto LABEL_55;
    }

    free(v37);
    __int16 v33 = v43;
LABEL_61:
    *__int16 v33 = 0LL;
    *char v16 = 0LL;
    *((void *)auth_data + 4) = 0LL;
    goto LABEL_48;
  }

  uint64_t v46 = v20;
  size_t v35 = (void *)((char *)auth_data + 40);
  unint64_t v34 = (char *)*((void *)auth_data + 5);
  if (v34)
  {
LABEL_55:
    memset_s(&v34[v30], v15, 0, v15);
    uint64_t v30 = *v16;
  }

  *((void *)auth_data + 3) = v30 + v15;
  uint64_t v38 = *((void *)auth_data + 2);
  uint64_t v39 = (*(void *)auth_data)++;
  *(void *)(v38 + 8 * v39) = v17;
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > *v16 || (*(_DWORD *)(*v35 + v17) = v15, v46 < 0))
  {
LABEL_48:
    uint64_t v13 = "alloc auth_data entry";
    __int16 v14 = 152;
    goto LABEL_49;
  }

  uint64_t v40 = *((void *)auth_data + 5);
  uint64_t v41 = *(void *)(*((void *)auth_data + 2) + 8 * v46);
  *(_DWORD *)(v40 + v41) = v15;
  unint64_t v42 = (char *)(v40 + v41 + 4);
  memcpy(v42, key, v11);
  memcpy(&v42[v11], data, data_size);
  return 0;
}

    if (v22 != v20)
    {
      uint64_t v38 = &v18[v20];
      uint64_t v39 = &v18[v20 + v27];
      uint64_t v40 = v21;
      uint64_t v41 = v16;
      unint64_t v42 = v27;
      memmove(v39, v38, v23);
      size_t v27 = v42;
      char v16 = v41;
      unint64_t v21 = v40;
    }

    unint64_t v22 = *v21 + v27;
    goto LABEL_34;
  }

  if (v15 < v19)
  {
    size_t v32 = v19 - v15;
    if (v22 != v20)
    {
      __int16 v33 = &v18[v20];
      unint64_t v34 = &v18[v20 - v32];
      size_t v35 = v16;
      unint64_t v36 = v32;
      memmove(v34, v33, v23);
      size_t v32 = v36;
      char v16 = v35;
      unint64_t v21 = (unint64_t *)((char *)auth_data + 24);
      uint64_t v20 = *((void *)auth_data + 3);
    }

    unint64_t v22 = v20 - v32;
LABEL_34:
    *unint64_t v21 = v22;
  }

  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > v22) {
    goto LABEL_8;
  }
  *(_DWORD *)(*((void *)auth_data + 5) + v17) = v15;
  if (*(void *)auth_data > v16)
  {
    uint64_t v43 = v16;
    while (v17 < 0xFFFFFFFFFFFFFFFCLL && v17 + 4 <= *v21)
    {
      uint64_t v44 = *(unsigned int *)(*((void *)auth_data + 5) + v17);
      *(void *)(*((void *)auth_data + 2) + 8 * v43) = v17;
      v17 += v44;
      if (++v43 >= *(void *)auth_data) {
        goto LABEL_42;
      }
    }

    goto LABEL_8;
  }

    __int16 v37 = *v32;
    uint64_t v38 = realloc(*v32, v30);
    if (v38)
    {
      *(void *)(v10 + 72) = v30;
      *(void *)(v10 + 80) = v38;
      uint64_t v24 = *(void *)(v10 + 112);
      goto LABEL_33;
    }

    free(v37);
LABEL_77:
    *size_t v32 = 0LL;
    *unint64_t v29 = 0LL;
    *(void *)(v10 + 72) = 0LL;
    goto LABEL_78;
  }

    unint64_t v34 = 1;
    goto LABEL_47;
  }

  if (!*(_DWORD *)(a1 + 64))
  {
    if ((v9 & 2) != 0)
    {
      CC_SHA1_Deprecated_Final((unsigned __int8 *)md, (CC_SHA1_CTX *)(a1 + 160));
      v12.uint64_t ikey = 3229779;
      uint32_t KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v12);
      if ((KeyIndex & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 117;
        goto LABEL_46;
      }

      v14.uint64_t ikey = 3229779;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), KeyIndex, v14, 2u, (const uint8_t *)md) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 118;
        goto LABEL_46;
      }

      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }

    if ((v9 & 4) != 0)
    {
      CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(a1 + 256));
      v15.uint64_t ikey = 3295315;
      char v16 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v15);
      if ((v16 & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 125;
        goto LABEL_46;
      }

      v17.uint64_t ikey = 3295315;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v16, v17, 3u, (const uint8_t *)md) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 126;
        goto LABEL_46;
      }

      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }

    if ((v9 & 8) != 0)
    {
      CC_SHA384_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 360));
      v18.uint64_t ikey = 3360851;
      unint64_t v19 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v18);
      if ((v19 & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 133;
        goto LABEL_46;
      }

      v20.uint64_t ikey = 3360851;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v19, v20, 4u, (const uint8_t *)md) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 134;
        goto LABEL_46;
      }

      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }

    if ((v9 & 0x10) != 0)
    {
      CC_SHA512_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 568));
      v21.uint64_t ikey = 3491923;
      unint64_t v22 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v21);
      if ((v22 & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 141;
        goto LABEL_46;
      }

      v23.uint64_t ikey = 3491923;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v22, v23, 5u, (const uint8_t *)md) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 142;
        goto LABEL_46;
      }

      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }

    if ((v9 & 1) != 0)
    {
      CC_CKSUM_Final(md, a1 + 144);
      v24.uint64_t ikey = 5458755;
      unint64_t v25 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v24);
      if ((v25 & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 149;
        goto LABEL_46;
      }

      v26.uint64_t ikey = 5458755;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v25, v26, 1u, (const uint8_t *)md) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 150;
        goto LABEL_46;
      }

      LOBYTE(v9) = *(_BYTE *)(a1 + 136);
    }

    if ((v9 & 0x20) != 0)
    {
      size_t v27 = OECCStreamGetDataSize(*(void *)(a1 + 776));
      v28.uint64_t ikey = 4408665;
      unint64_t v29 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v28);
      if ((v29 & 0x80000000) != 0)
      {
        uint64_t v10 = "Missing field in new header";
        size_t v11 = 157;
        goto LABEL_46;
      }

      v30.uint64_t ikey = 4408665;
      if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), v29, v30, v27) < 0)
      {
        uint64_t v10 = "updating new header field";
        size_t v11 = 158;
        goto LABEL_46;
      }
    }

    goto LABEL_28;
  }

  uint64_t v10 = "Header has already been sent";
  size_t v11 = 111;
LABEL_46:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamEndBlob",  v11,  111,  0,  v10,  a7,  a8,  v36);
  unint64_t v34 = 0;
LABEL_47:
  if (v34) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  free(*(void **)(a1 + 32));
  *unint64_t v19 = 0LL;
  *(void *)(a1 + 32) = 0LL;
  if ((AAByteStreamTruncate(*(void **)(a1 + 112)) & 0x80000000) != 0)
  {
    size_t v8 = "truncate temp file";
    uint64_t v9 = 78;
    goto LABEL_3;
  }

  unint64_t v29 = *(AAByteStream_impl **)(a1 + 112);
  uint64_t v30 = atomic_load((unint64_t *)(a1 + 120));
  unint64_t v31 = AAByteStreamSeek(v29, v30, 0);
  uint64_t result = 0LL;
  if (v31 < 0)
  {
    size_t v8 = "seek temp file";
    uint64_t v9 = 80;
    goto LABEL_3;
  }

  return result;
}

    if (v22 == v12 - 12)
    {
      size_t v26 = aeaContextCreateWithPrologue(v16, v12);
      if (v26)
      {
        unint64_t v17 = (AEAContext_impl *)v26;
        free(v16);
        return v17;
      }

      size_t v27 = "Context creation";
      uint64_t v28 = 280;
    }

    else
    {
      size_t v27 = "reading prologue";
      uint64_t v28 = 276;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextCreateWithEncryptedStream",  v28,  57,  0,  v27,  v20,  v21,  v29);
  }

  else
  {
LABEL_12:
    uint64_t v13 = "reading magic";
    __int16 v14 = 263;
LABEL_13:
    rsize_t v15 = 0;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextCreateWithEncryptedStream",  v14,  57,  v15,  v13,  v1,  v2,  v29);
    char v16 = 0LL;
  }

  free(v16);
  AEAContextDestroy(0LL);
  return 0LL;
}

  uint64_t v30 = *v16;
  unint64_t v31 = *v16 + v15;
  if (__CFADD__(*v16, v15) || (v31 & 0x8000000000000000LL) != 0) {
    goto LABEL_48;
  }
  if (v26 < v31)
  {
    do
    {
      while (!v26)
      {
        size_t v26 = 0x4000LL;
        if (v31 <= 0x4000)
        {
          uint64_t v46 = v20;
          __int16 v33 = (void **)((char *)xat + 40);
          size_t v26 = 0x4000LL;
          goto LABEL_53;
        }
      }

      size_t v32 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0) {
        size_t v32 = v26 & (v26 >> 1);
      }
      v26 += v32;
    }

    while (v26 < v31);
    __int16 v33 = (void **)((char *)xat + 40);
    if (v26 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_61;
    }

    uint64_t v46 = v20;
LABEL_53:
    uint64_t v43 = v33;
    __int16 v37 = *v33;
    unint64_t v34 = (char *)realloc(v37, v26);
    if (v34)
    {
      *((void *)xat + 5) = v34;
      size_t v35 = (void *)((char *)xat + 40);
      *((void *)xat + 4) = v26;
      uint64_t v30 = *((void *)xat + 3);
      goto LABEL_55;
    }

    free(v37);
    __int16 v33 = v43;
LABEL_61:
    *__int16 v33 = 0LL;
    *char v16 = 0LL;
    *((void *)xat + 4) = 0LL;
    goto LABEL_48;
  }

  uint64_t v46 = v20;
  size_t v35 = (void *)((char *)xat + 40);
  unint64_t v34 = (char *)*((void *)xat + 5);
  if (v34)
  {
LABEL_55:
    memset_s(&v34[v30], v15, 0, v15);
    uint64_t v30 = *v16;
  }

  *((void *)xat + 3) = v30 + v15;
  uint64_t v38 = *((void *)xat + 2);
  uint64_t v39 = (*(void *)xat)++;
  *(void *)(v38 + 8 * v39) = v17;
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > *v16 || (*(_DWORD *)(*v35 + v17) = v15, v46 < 0))
  {
LABEL_48:
    uint64_t v13 = "alloc XAT entry";
    __int16 v14 = 381;
    goto LABEL_49;
  }

  uint64_t v40 = *((void *)xat + 5);
  uint64_t v41 = *(void *)(*((void *)xat + 2) + 8 * v46);
  *(_DWORD *)(v40 + v41) = v15;
  unint64_t v42 = (char *)(v40 + v41 + 4);
  memcpy(v42, key, v11);
  memcpy(&v42[v11], data, data_size);
  return 0;
}

    if (v22 != v20)
    {
      uint64_t v38 = &v18[v20];
      uint64_t v39 = &v18[v20 + v27];
      uint64_t v40 = v21;
      uint64_t v41 = v16;
      unint64_t v42 = v27;
      memmove(v39, v38, v23);
      size_t v27 = v42;
      char v16 = v41;
      unint64_t v21 = v40;
    }

    unint64_t v22 = *v21 + v27;
    goto LABEL_34;
  }

  if (v15 < v19)
  {
    size_t v32 = v19 - v15;
    if (v22 != v20)
    {
      __int16 v33 = &v18[v20];
      unint64_t v34 = &v18[v20 - v32];
      size_t v35 = v16;
      unint64_t v36 = v32;
      memmove(v34, v33, v23);
      size_t v32 = v36;
      char v16 = v35;
      unint64_t v21 = (unint64_t *)((char *)xat + 24);
      uint64_t v20 = *((void *)xat + 3);
    }

    unint64_t v22 = v20 - v32;
LABEL_34:
    *unint64_t v21 = v22;
  }

  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > v22) {
    goto LABEL_8;
  }
  *(_DWORD *)(*((void *)xat + 5) + v17) = v15;
  if (*(void *)xat > v16)
  {
    uint64_t v43 = v16;
    while (v17 < 0xFFFFFFFFFFFFFFFCLL && v17 + 4 <= *v21)
    {
      uint64_t v44 = *(unsigned int *)(*((void *)xat + 5) + v17);
      *(void *)(*((void *)xat + 2) + 8 * v43) = v17;
      v17 += v44;
      if (++v43 >= *(void *)xat) {
        goto LABEL_42;
      }
    }

    goto LABEL_8;
  }

  unint64_t v34 = v23;
  size_t v35 = bswap64(block_size);
  if (AAByteStreamWrite(compressed_stream, buf, 0xCuLL) != 12)
  {
    uint64_t v20 = "writing stream magic";
    unint64_t v21 = 277;
    goto LABEL_35;
  }

  v9[3] = aaCompressionOutputStreamWrite;
  v9[7] = aaCompressionOutputStreamAbort;
  _BYTE *v9 = v10;
  v9[1] = aaCompressionOutputStreamClose;
  v9[9] = aaCompressionOutputStreamFlush;
  return (AAByteStream)v9;
}

int AEAAuthDataSetEntry( AEAAuthData auth_data, uint32_t i, const char *key, const uint8_t *data, size_t data_size)
{
  if (*(void *)auth_data <= (unint64_t)i)
  {
    uint64_t v24 = "invalid auth_data index";
    __int16 v25 = 172;
    goto LABEL_11;
  }

  size_t v12 = strlen(key);
  size_t v13 = v12 + 1;
  size_t v14 = v12 + 5;
  if (v12 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (unint64_t v15 = data_size + v14, __CFADD__(data_size, v14)) || v15 >= 0xFFFFFFFF)
  {
    uint64_t v24 = "invalid attribute size";
    __int16 v25 = 180;
    goto LABEL_11;
  }

  unint64_t v16 = i;
  unint64_t v17 = *(void *)(*((void *)auth_data + 2) + 8LL * i);
  unint64_t v18 = (char *)*((void *)auth_data + 5);
  unint64_t v19 = *(unsigned int *)&v18[v17];
  unint64_t v20 = v17 + v19;
  if (__CFADD__(v17, v19)
    || (v21 = (unint64_t *)((char *)auth_data + 24), v22 = *((void *)auth_data + 3), size_t v23 = v22 - v20, v22 < v20))
  {
LABEL_8:
    uint64_t v24 = "alloc auth_data entry";
    __int16 v25 = 183;
LABEL_11:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataSetEntry",  v25,  95,  0,  v24,  v5,  v6,  v48);
    return -1;
  }

  uint64_t v27 = v15 - v19;
  if (v15 > v19)
  {
    unint64_t v28 = v22 + v27;
    unint64_t v29 = *((void *)auth_data + 4);
    if (v29 < v28)
    {
      size_t v30 = 0x4000LL;
      do
      {
        while (!v29)
        {
          unint64_t v29 = 0x4000LL;
          if (v28 <= 0x4000) {
            goto LABEL_29;
          }
        }

        unint64_t v31 = v29 >> 1;
        if ((v29 & (v29 >> 1)) != 0) {
          unint64_t v31 = v29 & (v29 >> 1);
        }
        v29 += v31;
      }

      while (v29 < v28);
      size_t v30 = v29;
      if (v29 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_44;
      }

int AEAAuthDataClear(AEAAuthData auth_data)
{
  *(void *)auth_data = 0LL;
  *((void *)auth_data + 3) = 0LL;
  return 0;
}

int AEAAuthDataRemoveEntry(AEAAuthData auth_data, uint32_t i)
{
  uint64_t v4 = *(void *)auth_data;
  if (*(void *)auth_data <= (unint64_t)i
    || (unint64_t v6 = i,
        uint64_t v7 = *(void *)(*((void *)auth_data + 2) + 8LL * i),
        uint64_t v8 = *((void *)auth_data + 5),
        uint64_t v9 = *(unsigned int *)(v8 + v7),
        BOOL v10 = __CFADD__(v7, v9),
        unint64_t v11 = v7 + v9,
        v10)
    || (unint64_t v12 = *((void *)auth_data + 3), v12 < v11))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c",  (uint64_t)"AEAAuthDataRemoveEntry",  205,  95,  0,  "invalid auth_data index %u",  v2,  v3,  i);
    return -1;
  }

  else
  {
    if ((_DWORD)v9)
    {
      if (v12 != v11)
      {
        memmove((void *)(v8 + v11 - v9), (const void *)(v8 + v11), v12 - v11);
        unint64_t v11 = *((void *)auth_data + 3);
        uint64_t v4 = *(void *)auth_data;
      }

      *((void *)auth_data + 3) = v11 - v9;
    }

    unint64_t v14 = v4 - 1;
    *(void *)auth_data = v14;
    if (v14 > v6)
    {
      uint64_t v15 = *((void *)auth_data + 2);
      do
      {
        *(void *)(v15 + 8 * v6) = *(void *)(v15 + 8 * v6 + 8) - v9;
        ++v6;
      }

      while (v6 < *(void *)auth_data);
    }

    return 0;
  }

size_t AEAAuthDataGetEncodedSize(AEAAuthData auth_data)
{
  return *((void *)auth_data + 3);
}

const uint8_t *__cdecl AEAAuthDataGetEncodedData(AEAAuthData auth_data)
{
  return (const uint8_t *)*((void *)auth_data + 5);
}

uint64_t apfs_scan_diskimage( const char *a1, uint64_t (*a2)(__int128 *, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (snprintf(__str, 0x400uLL, "%s.json", a1) > 0)
  {
    if (!stat(__str, &v60) && (v60.st_mode & 0xF000) == 0x8000)
    {
      unint64_t v11 = AAFileStreamOpenWithPath(__str, 0, 0);
      if (v11)
      {
        unint64_t v12 = 0LL;
LABEL_6:
        size_t v13 = (void **)AAJSONInputStreamOpen((uint64_t)v11);
        if (v13)
        {
          unint64_t v20 = v13;
          if ((AAJSONInputStreamRead((uint64_t)v13, (int *)&v61, v14, v15, v16, v17, v18, v19) & 0x80000000) == 0)
          {
            while (1)
            {
              int v27 = v64;
              if (!v64)
              {
                AAJSONInputStreamClose(v20);
                int v46 = 1;
                goto LABEL_66;
              }

              if (v61 < 2) {
                break;
              }
              if (v61 == 2)
              {
                if (v64 == 4)
                {
                  DWORD1(v67) = *(void *)(*((void *)&v67 + 1) - 64LL);
                  if ((a2(&v66, a4) & 0x80000000) != 0)
                  {
                    uint64_t v55 = "add_fork";
                    __int16 v56 = 58;
                    goto LABEL_88;
                  }

                  pc_array_free(*((uint64_t *)&v67 + 1));
                  *((void *)&v67 + 1) = 0LL;
                  int v27 = v64;
                }

                if (v27 == 6)
                {
                  *((void *)&v67 + 1) = pc_array_append(*((uint64_t *)&v67 + 1), __src, v21, v22, v23, v24, v25, v26);
                  if (!*((void *)&v67 + 1))
                  {
                    uint64_t v55 = "pc_array_append";
                    __int16 v56 = 67;
                    goto LABEL_88;
                  }
                }
              }

              else if (v61 == 4)
              {
                if (v64 == 7)
                {
                  unint64_t v29 = __s1;
                  if (!strcmp(__s1, "offset"))
                  {
                    __src[0] = v63;
                  }

                  else
                  {
                    if (strcmp(v29, "length"))
                    {
                      uint64_t v55 = "bad map";
                      __int16 v56 = 83;
                      goto LABEL_88;
                    }

                    __src[1] = v63;
                  }
                }

                else if (v64 == 5)
                {
                  unint64_t v28 = __s1;
                  if (!strcmp(__s1, "compression"))
                  {
                    LODWORD(v67) = v63;
                  }

                  else if (!strcmp(v28, "uncompressed_size"))
                  {
                    *(void *)&__int128 v66 = v63;
                  }

                  else
                  {
                    if (strcmp(v28, "size"))
                    {
                      uint64_t v55 = "bad map";
                      __int16 v56 = 77;
                      goto LABEL_88;
                    }

                    *((void *)&v66 + 1) = v63;
                  }
                }
              }

LABEL_38:
            }

            switch(v64)
            {
              case 2:
                if (!strcmp(__s1, "volumes")) {
                  goto LABEL_38;
                }
                uint64_t v55 = "bad map";
                __int16 v56 = 41;
                break;
              case 4:
                if (!strcmp(__s1, "files")) {
                  goto LABEL_38;
                }
                uint64_t v55 = "bad map";
                __int16 v56 = 42;
                break;
              case 5:
                __int128 v66 = 0u;
                __int128 v67 = 0u;
                *((void *)&v67 + 1) = pc_array_init(16LL);
                goto LABEL_38;
              case 6:
                if (!strcmp(__s1, "extents")) {
                  goto LABEL_38;
                }
                uint64_t v55 = "bad map";
                __int16 v56 = 43;
                break;
              case 8:
                uint64_t v55 = "bad map";
                __int16 v56 = 44;
                break;
              default:
                goto LABEL_38;
            }

    if (atomic_load(&v47)) {
      goto LABEL_16;
    }
  }

  uint64_t v23 = "ThreadPoolGetWorker";
  uint64_t v24 = 107;
LABEL_14:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"AAAsyncByteStreamProcessAllRanges",  v24,  116,  0,  v23,  v13,  v14,  v44);
LABEL_15:
  LODWORD(v12) = 0;
LABEL_16:
  if ((ThreadPoolDestroy((uint64_t)v15) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"AAAsyncByteStreamProcessAllRanges",  115,  116,  0,  "Threads reported errors",  v25,  v26,  v44);
    LODWORD(v12) = 0;
  }

  if (v8)
  {
    if ((_DWORD)v6)
    {
      int v27 = v8;
      do
      {
        unint64_t v28 = *v27;
        if (*v27)
        {
          free(v28[8]);
          free(v28);
        }

        ++v27;
        --v6;
      }

      while (v6);
    }

    free(v8);
  }

  if (atomic_load(&v47))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"AAAsyncByteStreamProcessAllRanges",  127,  116,  0,  "Threads reported errors",  v25,  v26,  v44);
    return -1LL;
  }

  if ((_DWORD)v12) {
    return atomic_load(&v46);
  }
  else {
    return -1LL;
  }
}

                if ((aaEntryAttributesApplyToFD((char *)v68, v20, a3) & 0x80000000) == 0
                  && (aaEntryXATBlobApplyToFD(v15, v20, a3, v42, v43, v44, v45, v46) & 0x80000000) == 0
                  && (aaEntryACLBlobApplyToFD(v19, v20, a3) & 0x80000000) == 0)
                {
                  signed int v47 = 0;
                  uint64_t v36 = 1;
                  if ((v64[0] & 4) != 0 && (void)v65)
                  {
                    if ((setFileAPFSInternalFlags(v20, v65) & 0x80000000) != 0)
                    {
                      char v48 = "setting internal attributes";
                      uint64_t v49 = 1047;
                      goto LABEL_46;
                    }

                    signed int v47 = 0;
                  }

        uint64_t v44 = *(size_t *)((char *)buf + 4);
        if (!*(size_t *)((char *)buf + 4))
        {
          uint64_t v14 = 1;
          continue;
        }

        uint64_t v124 = v42;
        while (1)
        {
          if (v44 >= 0x40000) {
            __int16 v45 = 0x40000LL;
          }
          else {
            __int16 v45 = v44;
          }
          int v46 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v45);
          if (v46 < 0)
          {
            unint64_t v35 = 912;
            goto LABEL_80;
          }

          signed int v47 = v46;
          char v48 = v15;
          uint64_t v49 = v9;
          uint64_t v50 = *(void *)(v124 + 2288);
          if (*(void *)(v50 + 24))
          {
            unint64_t v51 = 0LL;
            if (v46)
            {
              __int16 v52 = v13;
              int v53 = v46;
              while (1)
              {
                uint64_t v54 = (*(uint64_t (**)(void, char *, ssize_t))(v50 + 24))(*(void *)v50, v52, v53);
                if (v54 < 1) {
                  break;
                }
                v52 += v54;
                v51 += v54;
                v53 -= v54;
                if (!v53) {
                  goto LABEL_52;
                }
              }

              unint64_t v51 = v54;
            }
          }

          else
          {
            unint64_t v51 = -1LL;
          }

LABEL_88:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"parseAPFSJSON",  v56,  144,  0,  v55,  v25,  v26,  (char)v59);
          }

    uint64_t v8 = (void **)v155;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    if (v80 != v82)
    {
      uint64_t v9 = "aaByteStreamPWriteExpected";
      uint64_t v10 = 287;
      goto LABEL_3;
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  if (v31) {
    __strlcpy_chk();
  }
LABEL_28:
  uint64_t v32 = value;
  if (value == 70)
  {
    v33.uint64_t ikey = 4410440;
    uint64_t v34 = AAHeaderGetKeyIndex(header, v33);
    if ((v34 & 0x80000000) != 0
      || ((unint64_t v35 = AAHeaderGetFieldUInt(header, v34, &v80), v35 <= 1) ? (v36 = 1) : (v36 = v35), v36 <= 0))
    {
      uint64_t v80 = -1LL;
    }

    v37.uint64_t ikey = 4410435;
    uint64_t v38 = AAHeaderGetKeyIndex(header, v37);
    if ((v38 & 0x80000000) != 0
      || ((uint64_t v39 = AAHeaderGetFieldUInt(header, v38, &v79), v39 <= 1) ? (v40 = 1) : (v40 = v39), v40 <= 0))
    {
      unint64_t v79 = -1LL;
    }

    v41.uint64_t ikey = 4410451;
    size_t v42 = AAHeaderGetKeyIndex(header, v41);
    if ((v42 & 0x80000000) != 0
      || ((uint64_t v43 = AAHeaderGetFieldUInt(header, v42, &v78), v43 <= 1) ? (v44 = 1) : (v44 = v43), v44 <= 0))
    {
      unint64_t v78 = -1LL;
    }

    uint64_t v32 = value;
  }

  if (v32 == 68 && !*(_DWORD *)(a1 + 1076))
  {
    v82[0] = 0LL;
    v58.uint64_t ikey = 5067853;
    if ((AAHeaderGetKeyIndex(header, v58) & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 1076) = 1;
    }
    v59.uint64_t ikey = 4672582;
    stat v60 = AAHeaderGetKeyIndex(header, v59);
    if ((v60 & 0x80000000) == 0)
    {
      unsigned int v61 = AAHeaderGetFieldUInt(header, v60, v82);
      uint64_t v62 = v61 <= 1 ? 1 : v61;
      if (v62 >= 1 && (v82[0] & 0x20002) != 0) {
        *(_DWORD *)(a1 + 1076) = 1;
      }
    }
  }

  if ((StringTableAppend(*(unsigned int **)(a1 + 1096), &v83, length, &v77, v24, v25, v13, v14) & 0x80000000) != 0)
  {
    uint64_t v17 = "inserting path in table";
    uint64_t v18 = 958;
    goto LABEL_10;
  }

  if (value == 68)
  {
    __int16 v45 = *(void *)(a1 + 1104);
    int v46 = v45 + a4;
    if (__CFADD__(v45, a4) || (v46 & 0x8000000000000000LL) != 0) {
      goto LABEL_112;
    }
    signed int v47 = (uint64_t *)(a1 + 1104);
    char v48 = *(void *)(a1 + 1112);
    if (v48 < v46)
    {
      do
      {
        while (!v48)
        {
          char v48 = 0x4000LL;
          if (v46 <= 0x4000)
          {
            uint64_t v50 = (void **)(a1 + 1120);
            char v48 = 0x4000LL;
            goto LABEL_98;
          }
        }

        uint64_t v49 = v48 >> 1;
        if ((v48 & (v48 >> 1)) != 0) {
          uint64_t v49 = v48 & (v48 >> 1);
        }
        v48 += v49;
      }

      while (v48 < v46);
      uint64_t v50 = (void **)(a1 + 1120);
      if (v48 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_111;
      }

LABEL_89:
          uint64_t v54 = v20;
        }

        else
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"parseAPFSJSON",  27,  144,  0,  "AAJSONInputStreamOpen",  v18,  v19,  (char)v59);
          uint64_t v54 = 0LL;
        }

        AAJSONInputStreamClose(v54);
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  181,  144,  0,  "invalid image map JSON",  v57,  v58,  (char)v59);
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  114,  144,  0,  "AAFileStreamOpenWithPath",  v9,  v10,  (char)v59);
        unint64_t v12 = 0LL;
      }

      goto LABEL_65;
    }

    if (getenv("PC_APFS_DISKIMAGE_MAP") && (__strlcpy_chk(), !stat(__str, &v60)) && (v60.st_mode & 0xF000) == 0x8000
      || (size_t v30 = getenv("MASTERING_TOOLCHAIN_DIR")) != 0LL
      && (snprintf( __str,  0x400uLL,  "%s%s/%s",  v30,  "/System/Library/Filesystems/apfs.fs/Contents/Resources",  "apfs_diskimage_map"),  !stat(__str, &v60))
      && (v60.st_mode & 0xF000) == 0x8000
      || (snprintf( __str,  0x400uLL,  "%s/%s",  "/System/Library/Filesystems/apfs.fs/Contents/Resources",  "apfs_diskimage_map"),  !stat(__str, &v60))
      && (v60.st_mode & 0xF000) == 0x8000)
    {
      unint64_t v12 = (char *)malloc(0x40000uLL);
      if (v12)
      {
        unint64_t v11 = (AAByteStream_impl *)AATempStreamOpen(0x800000uLL);
        if (v11)
        {
          snprintf(v68, 0x400uLL, "%s %s", __str, a1);
          unint64_t v35 = popen(v68, "r");
          if (v35)
          {
            uint64_t v36 = v35;
            while (1)
            {
              if (feof(v36))
              {
                pclose(v36);
                AAByteStreamSeek(v11, 0LL, 0);
                goto LABEL_6;
              }

              size_t v37 = fread(v12, 1uLL, 0x40000uLL, v36);
              if (ferror(v36)) {
                break;
              }
              if (*((void *)v11 + 3))
              {
                uint64_t v40 = 0LL;
                if (v37)
                {
                  unint64_t v41 = v12;
                  size_t v42 = v37;
                  while (1)
                  {
                    uint64_t v43 = (*((uint64_t (**)(void, char *, size_t))v11 + 3))(*(void *)v11, v41, v42);
                    if (v43 < 1) {
                      break;
                    }
                    v41 += v43;
                    v40 += v43;
                    v42 -= v43;
                    if (!v42) {
                      goto LABEL_62;
                    }
                  }

                  uint64_t v40 = v43;
                }
              }

              else
              {
                uint64_t v40 = -1LL;
              }

    *v157 += v80;
    uint64_t v22 = v150;
    size_t v13 = (const uint8_t *)a1;
    uint64_t v14 = v145;
    if (*v152 == *v149)
    {
      uint64_t v88 = (void *)*v16;
      uint32_t v89 = *(void *)(*v16 + 408);
      __int16 v90 = *(void *)(*v16 + 56);
      int v91 = 2 * v90;
      if ((v89 & 4) == 0) {
        int v91 = v90 + 1;
      }
      unint64_t v92 = 4 * v91;
      if ((unint64_t)(4 * v91) >= 0x2000000001LL)
      {
        *__error() = 12;
LABEL_148:
        uint64_t v135 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"fork_write_index",  81,  136,  *v135,  "aaMalloc",  v136,  v137,  v138);
        AAFieldKey v96 = 0LL;
        goto LABEL_142;
      }

      __int16 v93 = malloc(v92);
      if (!v93) {
        goto LABEL_148;
      }
      AAFieldKey v96 = v93;
      if ((v89 & 4) != 0)
      {
        unint64_t v107 = (uint64_t)*v8;
        if ((*v8)[5])
        {
          __int128 v108 = 0LL;
          __int128 v109 = &v153[6 * (void)v147 + 5];
          __int128 v110 = v88 + 41;
          __int128 v111 = *v109 + v88[50] - 50;
          __int128 v112 = 50LL;
          while (1)
          {
            __int128 v113 = (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(v107 + 40))( *(void *)v107,  v110,  v112,  v111);
            if (v113 < 1) {
              break;
            }
            __int128 v110 = (void *)((char *)v110 + v113);
            v108 += v113;
            v111 += v113;
            v112 -= v113;
            if (!v112)
            {
              if (v108 != 50) {
                break;
              }
              unsigned __int16 v114 = (void *)*v155;
              if (*(void *)(*v155 + 40LL))
              {
                uint64_t v115 = 0LL;
                int v116 = v88 + 8;
                uint64_t v117 = *v109;
                size_t v118 = 264LL;
                while (1)
                {
                  unint64_t v119 = ((uint64_t (*)(void, void *, uint64_t, uint64_t))v114[5])(*v114, v116, v118, v117);
                  if (v119 < 1) {
                    break;
                  }
                  int v116 = (void *)((char *)v116 + v119);
                  v115 += v119;
                  v117 += v119;
                  v118 -= v119;
                  if (!v118)
                  {
                    if (v115 != 264) {
                      break;
                    }
                    size_t v120 = v88[7];
                    uint64_t v8 = (void **)v155;
                    if (v120)
                    {
                      uint64_t v121 = (void *)(v155[2] + 16LL);
                      uint64_t v122 = v96 + 1;
                      do
                      {
                        *(v122 - 1) = *((_DWORD *)v121 - 4) - 260;
                        unint64_t v123 = *v121;
                        v121 += 3;
                        *uint64_t v122 = v123;
                        v122 += 2;
                        --v120;
                      }

                      while (v120);
                    }

                    uint64_t v101 = *v109 + 264;
                    uint64_t v14 = v145;
                    goto LABEL_99;
                  }
                }
              }

              uint64_t v133 = "aaByteStreamPWriteExpected";
              size_t v134 = 94;
              goto LABEL_141;
            }
          }
        }

        uint64_t v133 = "aaByteStreamPWriteExpected";
        size_t v134 = 89;
LABEL_141:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"fork_write_index",  v134,  136,  0,  v133,  v94,  v95,  v138);
LABEL_142:
        free(v96);
        uint64_t v9 = "fork_write_index";
        uint64_t v10 = 294;
        goto LABEL_3;
      }

      if (v90)
      {
        uint64_t v97 = v93 + 1;
        uint64_t v98 = (int *)(v8[2] + 2);
        do
        {
          char v99 = *(v98 - 4);
          *(v97 - 1) = v99;
          uint64_t v100 = *v98;
          v98 += 6;
          *v97++ = v100 + v99;
          --v90;
        }

        while (v90);
      }

      uint64_t v101 = v153[6 * (void)v15 + 5];
      uint64_t v14 = v145;
LABEL_99:
      uint64_t v102 = (uint64_t)*v8;
      if (!(*v8)[5]) {
        goto LABEL_149;
      }
      if (v92)
      {
        uint64_t v103 = 0LL;
        uint64_t v104 = v96;
        char v105 = v92;
        while (1)
        {
          char v106 = (*(uint64_t (**)(void, _DWORD *, size_t, uint64_t))(v102 + 40))( *(void *)v102,  v104,  v105,  v101);
          if (v106 < 1) {
            break;
          }
          uint64_t v104 = (_DWORD *)((char *)v104 + v106);
          v103 += v106;
          v101 += v106;
          v105 -= v106;
          if (!v105) {
            goto LABEL_120;
          }
        }

        uint64_t v103 = v106;
LABEL_120:
        uint64_t v87 = v92 == v103;
        uint64_t v8 = (void **)v155;
        uint64_t v14 = v145;
        if (!v87)
        {
LABEL_149:
          uint64_t v133 = "aaByteStreamPWriteExpected";
          size_t v134 = 117;
          goto LABEL_141;
        }
      }

      uint64_t v124 = v88[4];
      unint64_t v125 = v88[50];
      uint64_t v126 = v124 - v125;
      if (v124 != v125)
      {
        if (v126 >= 0x1000)
        {
          uint64_t v133 = "too much padding";
          size_t v134 = 123;
          goto LABEL_141;
        }

        bzero(dst_buffer, v124 - v125);
        uint64_t v127 = (uint64_t)*v8;
        if (!(*v8)[5]) {
          goto LABEL_150;
        }
        if (v126)
        {
          int v128 = 0LL;
          AAFieldKey v129 = v153[6 * (void)v147 + 5] + v88[50];
          unint64_t v130 = dst_buffer;
          uint64_t v131 = v126;
          while (1)
          {
            uint64_t v132 = (*(uint64_t (**)(void, uint8_t *, unint64_t, uint64_t))(v127 + 40))( *(void *)v127,  v130,  v131,  v129);
            if (v132 < 1) {
              break;
            }
            v130 += v132;
            v128 += v132;
            v129 += v132;
            v131 -= v132;
            if (!v131) {
              goto LABEL_131;
            }
          }

          int v128 = v132;
LABEL_131:
          uint64_t v87 = v126 == v128;
          uint64_t v8 = (void **)v155;
          uint64_t v14 = v145;
          if (!v87)
          {
LABEL_150:
            uint64_t v133 = "aaByteStreamPWriteExpected";
            size_t v134 = 126;
            goto LABEL_141;
          }
        }
      }

      free(v96);
      unint64_t v11 = a3;
      size_t v13 = (const uint8_t *)a1;
      uint64_t v22 = v150;
    }

        uint64_t v50 = realloc(v25, v49);
        if (!v50)
        {
          free(v25);
LABEL_124:
          *uint64_t v15 = 0LL;
          v15[1] = 0LL;
          v15[2] = 0LL;
LABEL_125:
          uint64_t v57 = "reserve buffers";
          uint64_t v58 = 128;
LABEL_126:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c",  (uint64_t)"writeProc",  v58,  132,  0,  v57,  a7,  a8,  v62);
LABEL_127:
          uint64_t v10 = -1LL;
          goto LABEL_128;
        }

        a1[8] = (void *)v49;
        a1[9] = v50;
        int v46 = (unint64_t)a1[4];
        if ((v46 & 0x8000000000000000LL) != 0) {
          goto LABEL_125;
        }
      }

      unint64_t v51 = (unint64_t)a1[11];
      if (v51 < v46)
      {
        do
        {
          while (!v51)
          {
            unint64_t v51 = 0x4000LL;
            int v53 = 0x4000LL;
            if (v46 <= 0x4000) {
              goto LABEL_100;
            }
          }

          __int16 v52 = v51 >> 1;
          if ((v51 & (v51 >> 1)) != 0) {
            __int16 v52 = v51 & (v51 >> 1);
          }
          v51 += v52;
        }

        while (v51 < v46);
        int v53 = v51;
        if (v51 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_123;
        }

      ++v76;
      v78 += 10;
      --v77;
    }

    while (v77);
    if ((ThreadPoolSync(v48) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  620,  60,  0,  "ThreadPoolSync",  v70,  v71,  v106);
      char v105 = atomic_load(&v116);
      unsigned int DefaultNThreads = v113;
      uint64_t v49 = v111;
      if (v105 >= 1)
      {
LABEL_120:
        uint64_t v103 = "Abort";
        uint64_t v104 = 621;
LABEL_121:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  v104,  60,  0,  v103,  v70,  v71,  v106);
      }

        if (v77)
        {
          unint64_t v78 = 3;
          goto LABEL_93;
        }

        bufa = v26;
        valuea = v33[18 * v276 + 66];
        uint64_t v80 = AAHeaderClear(v10);
        v81.uint64_t ikey = 5265748;
        int v82 = AAHeaderSetFieldUInt(v10, 0xFFFFFFFF, v81, valuea);
        int v83 = strlen(v34);
        v84.uint64_t ikey = 5521744;
        uint64_t v85 = AAHeaderSetFieldString(v10, 0xFFFFFFFF, v84, v34, v83);
        uint64_t v88 = (int)(aaHeaderAppendEntryAttributes(v10, (char *)v13 + 984 * v32 + 136, (char *)v13 + 984 * v32 + 208) | v82 | v80 | v85) >= 0;
        if ((_DWORD)valuea == 68)
        {
          uint64_t v10 = header;
        }

        else
        {
          if ((_DWORD)valuea != 70)
          {
            uint64_t v10 = header;
            goto LABEL_118;
          }

          uint32_t v89 = *((void *)v13 + 123 * v32 + 16);
          uint64_t v10 = header;
          if (v89 != -1LL)
          {
            v90.uint64_t ikey = 4410440;
            if (AAHeaderSetFieldUInt(header, 0xFFFFFFFF, v90, v89) < 0) {
              uint64_t v88 = 0;
            }
          }

          if ((v255 & 0x10) == 0)
          {
            v91.uint64_t ikey = 3295315;
          }
        }

        char v94 = *((void *)v13 + 123 * v32 + 10);
        if (v94)
        {
          v95.uint64_t ikey = 5521752;
          if (AAHeaderSetFieldBlob(v10, 0xFFFFFFFF, v95, v94) < 0) {
            uint64_t v88 = 0;
          }
        }

        AAFieldKey v96 = *((void *)v13 + 123 * v32 + 13);
        if (v96)
        {
          v97.uint64_t ikey = 4997953;
          if (AAHeaderSetFieldBlob(v10, 0xFFFFFFFF, v97, v96) < 0)
          {
LABEL_336:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateGenerateArchive",  1312,  27,  0,  "setup header",  v86,  v87,  v248);
            uint64_t v217 = 0LL;
            size_t v218 = 0LL;
            uint64_t v216 = 0LL;
            uint64_t v24 = 0LL;
            goto LABEL_337;
          }
        }

LABEL_62:
              if (v40 != v37)
              {
                uint64_t v44 = "writing tool output";
                __int16 v45 = 172;
                goto LABEL_82;
              }
            }

            uint64_t v44 = "reading from tool pipe";
            __int16 v45 = 170;
LABEL_82:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  v45,  144,  0,  v44,  v38,  v39,  (char)v59);
            AAByteStreamClose(v11);
            pclose(v36);
            goto LABEL_70;
          }

          int v53 = *__error();
          uint64_t v59 = v68;
          unint64_t v51 = "%s";
          __int16 v52 = 164;
        }

        else
        {
          unint64_t v51 = "temp stream open";
          __int16 v52 = 159;
          int v53 = 0;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  v52,  144,  v53,  v51,  v33,  v34,  (char)v59);
LABEL_69:
        AAByteStreamClose(v11);
LABEL_70:
        int v46 = 0;
        goto LABEL_71;
      }

      char v48 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  156,  144,  *v48,  "malloc",  v49,  v50,  (char)v59);
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  153,  144,  0,  "could not locate the apfs diskimage map tool",  v31,  v32,  (char)v59);
      unint64_t v12 = 0LL;
    }

    unint64_t v11 = 0LL;
    goto LABEL_69;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c",  (uint64_t)"apfs_scan_diskimage",  110,  144,  0,  "snprintf",  v7,  v8,  (char)v59);
  unint64_t v12 = 0LL;
  unint64_t v11 = 0LL;
LABEL_65:
  int v46 = 0;
LABEL_66:
  AAByteStreamClose(v11);
LABEL_71:
  free(v12);
  if (v46) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

      uint64_t v44 = *v43;
      __int16 v45 = realloc(*v43, __size);
      if (v45)
      {
        *(void *)(v29 + 1360) = v45;
        *(void *)(v29 + 1352) = __size;
        goto LABEL_64;
      }

      free(v44);
LABEL_88:
      *uint64_t v43 = 0LL;
      *(void *)(v29 + 1344) = 0LL;
      *(void *)(v29 + 1352) = 0LL;
LABEL_89:
      uint64_t v8 = "XAT blob allocation";
      uint64_t v9 = 290;
      goto LABEL_5;
    }
  }

      uint64_t v50 = (void *)a1[2];
      unint64_t v51 = realloc(v50, v47);
      if (v51)
      {
        a1[1] = v47;
        a1[2] = v51;
        goto LABEL_55;
      }

      free(v50);
LABEL_65:
      a1[1] = 0LL;
      a1[2] = 0LL;
      *a1 = 0LL;
      unint64_t v29 = v41;
      goto LABEL_66;
    }
  }

  else
  {
    *a1 = 0LL;
LABEL_55:
    unint64_t v29 = v41;
    if (!v41)
    {
      uint64_t v49 = a1[2];
      if (v49) {
        memset_s((void *)(v49 + *a1), v14, 0, v14);
      }
      goto LABEL_57;
    }
  }

  memcpy((void *)(a1[2] + *a1), v29, v14);
LABEL_57:
  size_t v30 = 0LL;
  *a1 += v14;
  unint64_t v29 = v41;
LABEL_67:
  unint64_t v6 = v54;
LABEL_30:
  free(v6);
  free(v29);
  if ((v10 & 0x80000000) == 0) {
    close(v10);
  }
  return v30;
}

uint64_t reStringAppend(uint64_t a1, const char *a2, uint64_t a3, char a4)
{
  uint64_t v8 = (void *)(a1 + 8);
  size_t v9 = a3 + *(void *)(a1 + 16) + 16;
  if (v9 <= *(void *)(a1 + 8)) {
    goto LABEL_5;
  }
  *(void *)(a1 + 8) = v9;
  if (v9 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_30:
    *(void *)a1 = 0LL;
    perror("malloc");
    *uint64_t v8 = 0LL;
    v8[1] = 0LL;
    return 0xFFFFFFFFLL;
  }

  uint64_t v10 = *(void **)a1;
  unint64_t v11 = realloc(*(void **)a1, v9);
  if (!v11)
  {
    free(v10);
    goto LABEL_30;
  }

  *(void *)a1 = v11;
LABEL_5:
  unint64_t v12 = "(^\\Q";
  if ((a4 & 4) == 0) {
    unint64_t v12 = "(^";
  }
  size_t v13 = "(\\Q";
  if ((a4 & 4) == 0) {
    size_t v13 = "(";
  }
  if ((a4 & 1) != 0) {
    uint64_t v14 = v12;
  }
  else {
    uint64_t v14 = v13;
  }
  uint64_t v15 = "\\E)";
  if ((a4 & 4) == 0) {
    uint64_t v15 = ")";
  }
  uint64_t v16 = "\\E/)";
  if ((a4 & 4) == 0) {
    uint64_t v16 = "/)";
  }
  if ((a4 & 8) != 0) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = v15;
  }
  if ((a4 & 4) != 0) {
    uint64_t v18 = "\\E$)";
  }
  else {
    uint64_t v18 = "$)";
  }
  uint64_t v19 = *(void *)(a1 + 16);
  unint64_t v20 = *(_BYTE **)a1;
  if ((a4 & 2) != 0) {
    uint64_t v21 = v18;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v19)
  {
    *(void *)(a1 + 16) = v19 + 1;
    v20[v19] = 124;
    unint64_t v20 = *(_BYTE **)a1;
    uint64_t v19 = *(void *)(a1 + 16);
  }

  strlcpy(&v20[v19], v14, *(void *)(a1 + 8) - v19);
  size_t v22 = strlen(v14);
  uint64_t v23 = *(void *)(a1 + 8);
  size_t v24 = *(void *)(a1 + 16) + v22;
  *(void *)(a1 + 16) = v24;
  strlcpy((char *)(*(void *)a1 + v24), a2, v23 - v24);
  uint64_t v25 = *(void *)(a1 + 8);
  uint64_t v26 = *(void *)(a1 + 16) + a3;
  *(void *)(a1 + 16) = v26;
  strlcpy((char *)(*(void *)a1 + v26), v21, v25 - v26);
  size_t v27 = strlen(v21);
  uint64_t result = 0LL;
  size_t v29 = *(void *)(a1 + 16) + v27;
  *(void *)(a1 + 16) = v29;
  *(_BYTE *)(*(void *)a1 + v29) = 0;
  return result;
}

void *AAPathFilterCreate()
{
  v0 = malloc(0xA8uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0xA8uLL, 0, 0xA8uLL);
    v1[3] = StringTableCreate();
    v1[12] = StringTableCreate();
    v1[1] = StringTableCreate();
    uint64_t v2 = StringTableCreate();
    v1[2] = v2;
    if (!v1[3] || !v1[12] || !v1[1] || !v2)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterCreate",  192,  130,  0,  "StringTableCreate",  v3,  v4,  v9);
      AAPathFilterDestroy((uint64_t)v1);
      return 0LL;
    }
  }

  else
  {
    uint64_t v5 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterCreate",  183,  130,  *v5,  "malloc",  v6,  v7,  v9);
  }

  return v1;
}

void AAPathFilterDestroy(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 56)) {
      MEMORY[0x186E368C8](a1 + 64);
    }
    if (*(_DWORD *)(a1 + 128)) {
      MEMORY[0x186E368C8](a1 + 64);
    }
    StringTableDestroy(*(void ***)(a1 + 24));
    StringTableDestroy(*(void ***)(a1 + 96));
    StringTableDestroy(*(void ***)(a1 + 8));
    StringTableDestroy(*(void ***)(a1 + 16));
    free(*(void **)(a1 + 32));
    *(void *)(a1 + 40) = 0LL;
    *(void *)(a1 + 48) = 0LL;
    free(*(void **)(a1 + 104));
    free((void *)a1);
  }

uint64_t AAPathFilterAddRule( uint64_t a1, unsigned int a2, unsigned int a3, char *__s, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)a1)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      MEMORY[0x186E368C8](a1 + 64);
      *(_DWORD *)(a1 + 56) = 0;
    }

    if (*(_DWORD *)(a1 + 128))
    {
      MEMORY[0x186E368C8](a1 + 64);
      *(_DWORD *)(a1 + 128) = 0;
    }

    *(_DWORD *)a1 = 0;
  }

  if (a2 >= 3)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  235,  130,  0,  "invalid rule type: %u",  a7,  a8,  a2);
  }

  else if (a3 >= 3)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  243,  130,  0,  "invalid match type: %u",  a7,  a8,  a3);
  }

  else
  {
    if (a2 == 2 && a3)
    {
      size_t v13 = "expected match type PREFIX for MAPTO rule";
      __int16 v14 = 246;
LABEL_58:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  v14,  130,  0,  v13,  a7,  a8,  v28);
      return 0xFFFFFFFFLL;
    }

    if (a2 == 2 && !a5)
    {
      size_t v13 = "mapto string is required for MAPTO rule";
      __int16 v14 = 248;
      goto LABEL_58;
    }

    if (a2 != 2 && a5)
    {
      size_t v13 = "mapto string is not allowed for non MAPTO rules";
      __int16 v14 = 250;
      goto LABEL_58;
    }

    if (!__s)
    {
      size_t v13 = "match string is required for all rules";
      __int16 v14 = 252;
      goto LABEL_58;
    }

    size_t v19 = strlen(__s);
    if (a3 != 1 && !pathIsValid(__s, v19))
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  256,  130,  0,  "invalid match path: %s",  v17,  v18,  (char)__s);
      return 0xFFFFFFFFLL;
    }

    if (a5)
    {
      size_t v20 = strlen(a5);
      if (!pathIsValid(a5, v20))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  260,  130,  0,  "invalid mapto path: %s",  v17,  v18,  (char)a5);
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      size_t v20 = 0LL;
    }

    if (a3 != 2 || v19 && !strchr(__s, 47))
    {
      if (a2 == 2)
      {
        if ((StringTableAppend(*(unsigned int **)(a1 + 8), __s, v19, 0LL, v15, v16, v17, v18) & 0x80000000) != 0)
        {
          size_t v13 = "StringTableAppend";
          __int16 v14 = 270;
          goto LABEL_58;
        }

        if ((StringTableAppend(*(unsigned int **)(a1 + 16), a5, v20, 0LL, v21, v22, a7, a8) & 0x80000000) != 0)
        {
          size_t v13 = "StringTableAppend";
          __int16 v14 = 271;
          goto LABEL_58;
        }
      }

      else
      {
        if (a2) {
          uint64_t v23 = a1 + 104;
        }
        else {
          uint64_t v23 = a1 + 32;
        }
        if (a3)
        {
          if (a3 != 2)
          {
            int v24 = reStringAppend(v23, __s, v19, 0);
            uint64_t result = 0LL;
            if ((v24 & 0x80000000) == 0) {
              return result;
            }
            size_t v13 = "error building regex";
            __int16 v14 = 283;
            goto LABEL_58;
          }

          v29[0] = 47;
          __memcpy_chk();
          size_t v27 = v19 + 1;
          v29[v19 + 1] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 6) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 299;
            goto LABEL_58;
          }

          v29[v27] = 47;
          v29[v19 + 2] = 0;
          if ((reStringAppend(v23, v29, v19 + 2, 4) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 303;
            goto LABEL_58;
          }

          __memcpy_chk();
          v29[v19] = 47;
          v29[v27] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 5) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 307;
            goto LABEL_58;
          }

          if ((reStringAppend(v23, __s, v19, 7) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 310;
            goto LABEL_58;
          }
        }

        else
        {
          uint64_t v26 = 96LL;
          if (!a2) {
            uint64_t v26 = 24LL;
          }
          if ((StringTableAppend(*(unsigned int **)(a1 + v26), __s, v19, 0LL, v15, v16, v17, v18) & 0x80000000) != 0)
          {
            size_t v13 = "StringTableAppend";
            __int16 v14 = 289;
            goto LABEL_58;
          }
        }
      }

      return 0LL;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"AAPathFilterAddRule",  264,  130,  0,  "invalid path for name match: %s",  v17,  v18,  (char)__s);
  }

  return 0xFFFFFFFFLL;
}

uint64_t AAPathFilterApply(uint64_t a1, char *__s, size_t a3, char *a4)
{
  if (!*(_DWORD *)a1)
  {
    if (*(void *)(a1 + 48) && !*(_DWORD *)(a1 + 56))
    {
      int v13 = regcomp((regex_t *)(a1 + 64), *(const char **)(a1 + 32), 257);
      if (v13)
      {
        AAPathFilterApply_cold_2(v13, (const regex_t *)(a1 + 64));
        goto LABEL_34;
      }

      *(_DWORD *)(a1 + 56) = 1;
    }

    if (*(void *)(a1 + 120) && !*(_DWORD *)(a1 + 128))
    {
      int v14 = regcomp((regex_t *)(a1 + 136), *(const char **)(a1 + 104), 257);
      if (v14)
      {
        AAPathFilterApply_cold_1(v14, (const regex_t *)(a1 + 136));
        goto LABEL_34;
      }

      *(_DWORD *)(a1 + 128) = 1;
    }

    if ((StringTableSort(*(unsigned int **)(a1 + 24), 0LL) & 0x80000000) != 0)
    {
      __int16 v21 = 134;
    }

    else
    {
      if ((StringTableSort(*(unsigned int **)(a1 + 96), 0LL) & 0x80000000) == 0)
      {
        *(_DWORD *)a1 = 1;
        goto LABEL_2;
      }

      __int16 v21 = 135;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c",  (uint64_t)"prepareFilter",  v21,  130,  0,  "string table sort",  v15,  v16,  v41);
LABEL_34:
    uint64_t v17 = "filter prepare";
    __int16 v18 = 325;
    goto LABEL_35;
  }

LABEL_2:
  size_t v8 = strlen(__s);
  if (!pathIsValid(__s, v8))
  {
    uint64_t v17 = "invalid input path";
    __int16 v18 = 327;
    goto LABEL_35;
  }

  if (StringTableSize(*(unsigned int **)(a1 + 24)))
  {
    int v11 = StringTableMatchesPrefixSorted(*(void *)(a1 + 24), __s);
    BOOL v12 = v11 > 0;
    if (!*(_DWORD *)(a1 + 56))
    {
      if (v11 < 1) {
        return 2LL;
      }
      goto LABEL_25;
    }
  }

  else
  {
    if (!*(_DWORD *)(a1 + 56)) {
      return 2LL;
    }
    BOOL v12 = 0;
  }

  if (regexec((const regex_t *)(a1 + 64), __s, 0LL, 0LL, 0) && !v12) {
    return 2LL;
  }
LABEL_25:
  if (StringTableSize(*(unsigned int **)(a1 + 96)))
  {
    int v19 = StringTableMatchesPrefixSorted(*(void *)(a1 + 96), __s);
    BOOL v20 = v19 > 0;
    if (!*(_DWORD *)(a1 + 128))
    {
      if (v19 <= 0) {
        goto LABEL_40;
      }
      return 2LL;
    }
  }

  else
  {
    if (!*(_DWORD *)(a1 + 128)) {
      goto LABEL_40;
    }
    BOOL v20 = 0;
  }

  int v23 = regexec((const regex_t *)(a1 + 136), __s, 0LL, 0LL, 0);
  uint64_t result = 2LL;
  if (v23)
  {
    if (!v20)
    {
LABEL_40:
      uint64_t result = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!(_DWORD)result) {
        return result;
      }
      unsigned int v24 = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!v24) {
        return 2LL;
      }
      size_t v41 = a3;
      __dst = a4;
      uint64_t v25 = 0LL;
      size_t v26 = 0LL;
      uint64_t v27 = *(void *)(a1 + 8);
      uint64_t v28 = *(void *)(v27 + 32);
      uint64_t v29 = v24;
      uint64_t v30 = (unsigned int *)(*(void *)(v27 + 8) + 8LL);
      unsigned int v31 = -1;
      do
      {
        size_t v32 = *v30;
        if ((!(_DWORD)v32
           || v8 >= v32
           && !memcmp((const void *)(v28 + *((void *)v30 - 1)), __s, *v30)
           && (v8 == v32 || __s[v32] == 47))
          && (v31 == -1 || v26 < v32))
        {
          size_t v26 = v32;
          unsigned int v31 = v25;
        }

        v30 += 4;
        ++v25;
      }

      while (v29 != v25);
      if (v31 == -1) {
        return 2LL;
      }
      if (!__dst) {
        return 0LL;
      }
      uint64_t v35 = *(void *)(a1 + 16);
      uint64_t v36 = *(void *)(v35 + 8);
      size_t v37 = *(unsigned int *)(v36 + 16LL * v31 + 8);
      if (v37 >= v41)
      {
        uint64_t v17 = "insufficient out_capacity";
        __int16 v18 = 373;
      }

      else
      {
        size_t v38 = *(unsigned int *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 16LL * v31 + 8);
        memcpy(__dst, (const void *)(*(void *)(v35 + 32) + *(void *)(v36 + 16LL * v31)), v37);
        if (v8 <= v38)
        {
LABEL_63:
          __dst[v37] = 0;
          return 1LL;
        }

        size_t v39 = v8 - v38 - ((_DWORD)v37 == 0);
        size_t v40 = v39 + v37;
        if (v39 + v37 < v41)
        {
          memcpy(&__dst[v37], &__s[v8 - v39], v39);
          size_t v37 = v40;
          goto LABEL_63;
        }

        uint64_t v17 = "insufficient out_capacity";
        __int16 v18 = 379;
      }

size_t OUTLINED_FUNCTION_0@<X0>( int a1@<W0>, const regex_t *a2@<X1>, uint64_t a3@<X8>, uint64_t a4, uint64_t a5, __int128 a6, __int128 a7, __int128 a8, __int128 a9, __int128 a10, __int128 a11, int a12)
{
  *(void *)(v12 - 24) = a3;
  a12 = 0;
  a10 = 0u;
  a11 = 0u;
  a8 = 0u;
  a9 = 0u;
  a6 = 0u;
  a7 = 0u;
  return regerror(a1, a2, (char *)&a6, 0x64uLL);
}

  ;
}

size_t OUTLINED_FUNCTION_2( uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  return pc_log_error(a1, a2, a3, 130, 0, a6, a7, a8, a9);
}

size_t PCompressLZ4Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZ4);
  if (!result) {
    return -1LL;
  }
  return result;
}

size_t PCompressLZ4Decode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZ4);
  if (!result) {
    return -1LL;
  }
  return result;
}

BOOL aeaProfileIsValid(unsigned int a1)
{
  return a1 < 6;
}

uint64_t aeaContainerParamsInitWithProfile( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 6)
  {
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 48) = 32;
    *(void *)(a1 + 56) = 1LL;
    *(_OWORD *)(a1 + 12) = xmmword_1862D7840;
    if (a2)
    {
      uint64_t v8 = 0LL;
      if (a2 == 5) {
        *(_DWORD *)(a1 + 8) = 0;
      }
    }

    else
    {
      uint64_t v8 = 0LL;
      *(void *)(a1 + 56) = 0LL;
    }
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithProfile",  31,  79,  0,  "Invalid profile: %u",  a7,  a8,  a2);
    return 0xFFFFFFFFLL;
  }

  return v8;
}

uint64_t aeaChecksumSize(int a1)
{
  if (a1 == 2) {
    return 32LL;
  }
  else {
    return 8 * (a1 == 1);
  }
}

uint64_t aeaContainerParamsInitWithMagic( int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 826361153)
  {
    unsigned int v10 = a2[2];
    if (v10 < 0x4000001)
    {
      unsigned int v11 = a2[1];
      if ((v11 & 0xFFFFFF) < 6)
      {
        uint64_t v12 = 0LL;
        *a1 = v11 & 0xFFFFFF;
        a1[1] = v10;
        a1[2] = HIBYTE(v11);
        return v12;
      }

      char v14 = a2[1];
      uint64_t v8 = "Invalid profile: %u";
      __int16 v9 = 57;
    }

    else
    {
      uint64_t v8 = "Invalid AEA container (auth_data_size)";
      __int16 v9 = 55;
    }
  }

  else
  {
    uint64_t v8 = "Invalid magic bytes";
    __int16 v9 = 54;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithMagic",  v9,  79,  0,  v8,  a7,  a8,  v14);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerParamsInitWithRootHeader( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(unsigned __int8 *)(a2 + 25);
  if (v8 > 2)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithRootHeader",  74,  79,  0,  "Invalid checksum in root header: %u",  a7,  a8,  *(_BYTE *)(a2 + 25));
    return 0xFFFFFFFFLL;
  }

  *(_DWORD *)(a1 + 12) = v8;
  if (v8 == 2) {
    int v9 = 32;
  }
  else {
    int v9 = 8 * (v8 == 1);
  }
  *(_DWORD *)(a1 + 48) = v9;
  int v10 = *(char *)(a2 + 24);
  if (v10 <= 100)
  {
    switch(v10)
    {
      case '-':
        int v11 = 0;
        break;
      case '4':
        int v11 = 256;
        break;
      case 'b':
        int v11 = 1794;
        break;
      default:
        goto LABEL_21;
    }
  }

  else if (v10 > 119)
  {
    if (v10 == 120)
    {
      int v11 = 774;
    }

    else
    {
      if (v10 != 122) {
        goto LABEL_21;
      }
      int v11 = 1285;
    }
  }

  else
  {
    if (v10 != 101)
    {
      if (v10 == 102)
      {
        int v11 = 2304;
        goto LABEL_23;
      }

LABEL_21:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithRootHeader",  81,  79,  0,  "Invalid compression algorithm key in root header: %u",  a7,  a8,  v10);
      return 0xFFFFFFFFLL;
    }

    int v11 = 2049;
  }

      unsigned int v8 = 0LL;
    }

    else
    {
      int v12 = 0LL;
      unsigned int v8 = 0LL;
      *__error() = 12;
    }

          if (*(_DWORD *)(a1 + 2080) >= 2u) {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "Decrypted file: %s\n", (const char *)(a1 + 32));
          }
          uint64_t v4 = 0LL;
        }

LABEL_23:
  *(_DWORD *)(a1 + 24) = v11;
  int v12 = *(_DWORD *)(a2 + 16);
  if ((v12 - 268435457) > 0xF0003FFE)
  {
    *(_DWORD *)(a1 + 16) = v12;
    int v13 = *(_DWORD *)(a2 + 20);
    if ((v13 - 262145) > 0xFFFC001E)
    {
      uint64_t v14 = 0LL;
      *(_DWORD *)(a1 + 20) = v13;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
      return v14;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithRootHeader",  89,  79,  0,  "Invalid segments per cluster count in root header: %u",  a7,  a8,  *(_DWORD *)(a2 + 20));
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaContainerParamsInitWithRootHeader",  85,  79,  0,  "Invalid segment size in root header: %u",  a7,  a8,  *(_DWORD *)(a2 + 16));
  }

  return 0xFFFFFFFFLL;
}

        if ((*a2 & 4) != 0)
        {
          *((void *)a2 + 2) = getFileAPFSInternalFlagsFD();
          mode_t st_mode = v23.st_mode;
        }

        goto LABEL_25;
      }

                      unsigned int v24 = 0;
                      goto LABEL_24;
                    }
                  }

                  else
                  {
                    *__error() = 12;
                    *(void *)(v19 + 128) = 0LL;
                  }

                  unsigned int v24 = *__error();
                  uint64_t v22 = "malloc";
                  int v23 = 713;
                  goto LABEL_24;
                }
              }

              else
              {
                *__error() = 12;
                *(void *)(v19 + 64) = 0LL;
              }

              unsigned int v24 = *__error();
              uint64_t v22 = "malloc";
              int v23 = 688;
              goto LABEL_24;
            }

            goto LABEL_12;
          }
        }
      }

      unsigned int v31 = "SharedArrayInit: malloc failed\n";
      size_t v32 = 55;
      goto LABEL_22;
    }
  }

  unsigned int v24 = *__error();
  uint64_t v22 = "malloc";
  int v23 = 650;
LABEL_24:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAGenericRandomAccessInputStream.c",  (uint64_t)"AAGenericRandomAccessInputStreamOpen",  v23,  33,  v24,  v22,  v20,  v21,  v65);
  free(v17);
  graisClose(v19);
  return 0LL;
}

uint64_t aeaMagicInit(_DWORD *a1, _DWORD *a2)
{
  *a1 = 826361153;
  int v2 = a2[1];
  a1[1] = *a2 & 0xFFFFFF | (a2[2] << 24);
  a1[2] = v2;
  return 0LL;
}

uint64_t aeaRootHeaderInit( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a2 + 24);
  if (v8 <= 1284)
  {
    switch(v8)
    {
      case 0:
        char v9 = 45;
        goto LABEL_18;
      case 256:
        char v9 = 52;
        goto LABEL_18;
      case 774:
        char v9 = 120;
        goto LABEL_18;
    }
  }

  else if (v8 > 2048)
  {
    if (v8 == 2049)
    {
      char v9 = 101;
      goto LABEL_18;
    }

    if (v8 == 2304)
    {
      char v9 = 102;
      goto LABEL_18;
    }
  }

  else
  {
    if (v8 == 1285)
    {
      char v9 = 122;
      goto LABEL_18;
    }

    if (v8 == 1794)
    {
      char v9 = 98;
LABEL_18:
      uint64_t v10 = 0LL;
      *(_BYTE *)(a1 + 25) = *(_DWORD *)(a2 + 12);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(_BYTE *)(a1 + 24) = v9;
      *(_OWORD *)a1 = *(_OWORD *)(a2 + 32);
      return v10;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaRootHeaderInit",  117,  79,  0,  "Invalid compression algorithm in context",  a7,  a8,  vars0);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerOffsetsInit(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3 = a2[5];
  *(_OWORD *)a1 = xmmword_1862D7850;
  uint64_t v4 = a2[1] + 12LL;
  uint64_t v5 = a3[12];
  uint64_t v6 = v4 + a3[11];
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v6;
  uint64_t v7 = v6 + v5;
  uint64_t v8 = a3[3];
  uint64_t v9 = v7 + a3[2];
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v9;
  uint64_t v10 = v9 + v8;
  uint64_t v11 = v9 + v8 + 48;
  *(void *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = v11;
  *(void *)(a1 + 64) = v11 + v8;
  *(void *)(a1 + 72) = 0LL;
  uint64_t v12 = (a2[12] + 8LL) * v3;
  *(void *)(a1 + 80) = v12;
  *(void *)(a1 + 88) = v12 + v8;
  *(void *)(a1 + 96) = v12 + v8 + v8 * (unint64_t)v3;
  return 0LL;
}

uint64_t aeaChecksum( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t result = 0LL;
    *(_DWORD *)a1 = 0;
    return result;
  }

  CC_LONG v9 = a4;
  uint64_t v10 = a3;
  if (a2 == 2)
  {
    CC_SHA256_Init(&c);
    CC_SHA256_Update(&c, v10, v9);
    CC_SHA256_Final((unsigned __int8 *)(a1 + 4), &c);
    *(_DWORD *)a1 = 32;
    uint64_t v16 = (void *)(a1 + 36);
    rsize_t v17 = 224LL;
    rsize_t v18 = 224LL;
LABEL_15:
    memset_s(v16, v17, 0, v18);
    return 0LL;
  }

  if (a2 == 1)
  {
    unint64_t v11 = (0xC6A4A7935BD1E995LL * a4) ^ 0xE2236FDC26A5F6D2LL;
    unint64_t v12 = (unint64_t)a3 + a4;
    if (a4 >= 16)
    {
      do
      {
        unint64_t v11 = 0xC6A4A7935BD1E995LL
            * ((0xC6A4A7935BD1E995LL
              * ((0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * *v10) ^ ((0xC6A4A7935BD1E995LL * *v10) >> 47))) ^ v11)) ^ (0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * v10[1]) ^ ((0xC6A4A7935BD1E995LL * v10[1]) >> 47))));
        int v13 = v10 + 2;
        uint64_t v14 = v10 + 4;
        v10 += 2;
      }

      while ((unint64_t)v14 <= v12);
    }

    else
    {
      int v13 = a3;
    }

    if ((unint64_t)(v13 + 1) <= v12)
    {
      do
      {
        unint64_t v11 = 0xC6A4A7935BD1E995LL
            * ((0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * *v13) ^ ((0xC6A4A7935BD1E995LL * *v13) >> 47))) ^ v11);
        BOOL v15 = (unint64_t)(v13 + 2) > v12;
        ++v13;
      }

      while (!v15);
    }

    if ((a4 & 7) != 0)
    {
      *(void *)c.count = 0LL;
      __memcpy_chk();
      v11 *= 0xC6A4A7935BD1E995LL;
    }

    *(void *)(a1 + 4) = (0xC6A4A7935BD1E995LL * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995LL * (v11 ^ (v11 >> 47))) >> 47);
    *(_DWORD *)a1 = 8;
    uint64_t v16 = (void *)(a1 + 12);
    rsize_t v17 = 248LL;
    rsize_t v18 = 248LL;
    goto LABEL_15;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaChecksum",  228,  79,  0,  "Invalid checksum mode",  a7,  a8,  v20);
  return 0xFFFFFFFFLL;
}

uint64_t aeaEffectiveCompressionAlgorithm(uint64_t result)
{
  if ((_DWORD)result == 256) {
    return 257LL;
  }
  else {
    return result;
  }
}

uint64_t aeaDeriveMainKeyExisting( unsigned int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, _DWORD *a9, _DWORD *a10, uint64_t (*a11)(uint64_t, void, char *, __int128 *, unsigned int *, void), uint64_t a12)
{
  uint64_t v134 = *MEMORY[0x1895F89C0];
  int v63 = 0;
  memset(v62, 0, sizeof(v62));
  int v16 = *a2 & 0xFFFFFF | (a2[2] << 24);
  switch(*a2)
  {
    case 0:
      memset(v133, 0, sizeof(v133));
      __int128 v132 = 0uLL;
      __int128 v131 = 0uLL;
      __int128 v130 = 0uLL;
      __int128 v129 = 0uLL;
      __int128 v128 = 0uLL;
      __int128 v127 = 0uLL;
      __int128 v126 = 0uLL;
      __int128 v125 = 0uLL;
      __int128 v124 = 0uLL;
      __int128 v123 = 0uLL;
      __int128 v122 = 0uLL;
      __int128 v121 = 0uLL;
      __int128 v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a6 != *a1) {
        goto LABEL_60;
      }
      if (*a10 != a1[2]) {
        goto LABEL_67;
      }
      if (a1[5]) {
        goto LABEL_59;
      }
      if (*a7 != a1[8]) {
        goto LABEL_112;
      }
      *(_DWORD *)&__s[7] = 1263354207;
      *(void *)size_t __s = 0x5F41454100000007LL;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)size_t __s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256LL - *(unsigned int *)__s, 0, 256LL - *(unsigned int *)__s);
      uint64_t result = memset_s(&__s[*(unsigned int *)__s + 4], 256LL - *(unsigned int *)__s, 0, 256LL - *(unsigned int *)__s);
      size_t v59 = *a7;
      unint64_t v60 = *(unsigned int *)__s + v59;
      if (v60 >= 0x101) {
        goto LABEL_135;
      }
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v59);
      *(_DWORD *)size_t __s = v60;
      memset_s(&__s[v60 + 4], 256 - v60, 0, 256 - v60);
      __int16 v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((void *)a1 + 9);
      if (!v21 || !*a6) {
        goto LABEL_113;
      }
      uint64_t v22 = *a1;
      int v23 = a3;
      unsigned int v24 = a6;
      goto LABEL_111;
    case 1:
    case 2:
      memset(v133, 0, sizeof(v133));
      __int128 v132 = 0uLL;
      __int128 v131 = 0uLL;
      __int128 v130 = 0uLL;
      __int128 v129 = 0uLL;
      __int128 v128 = 0uLL;
      __int128 v127 = 0uLL;
      __int128 v126 = 0uLL;
      __int128 v125 = 0uLL;
      __int128 v124 = 0uLL;
      __int128 v123 = 0uLL;
      __int128 v122 = 0uLL;
      __int128 v121 = 0uLL;
      __int128 v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a4 != *a1) {
        goto LABEL_60;
      }
      if (*a10 != a1[2]) {
        goto LABEL_67;
      }
      if (a1[5]) {
        goto LABEL_59;
      }
      if (*a7 != a1[8]) {
        goto LABEL_112;
      }
      *(_DWORD *)&__s[7] = 1263354207;
      *(void *)size_t __s = 0x5F41454100000007LL;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)size_t __s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256LL - *(unsigned int *)__s, 0, 256LL - *(unsigned int *)__s);
      uint64_t result = memset_s(&__s[*(unsigned int *)__s + 4], 256LL - *(unsigned int *)__s, 0, 256LL - *(unsigned int *)__s);
      size_t v19 = *a7;
      unint64_t v20 = *(unsigned int *)__s + v19;
      if (v20 >= 0x101) {
        goto LABEL_135;
      }
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v19);
      *(_DWORD *)size_t __s = v20;
      memset_s(&__s[v20 + 4], 256 - v20, 0, 256 - v20);
      __int16 v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((void *)a1 + 9);
      if (v21 && *a4)
      {
        uint64_t v22 = *a1;
        int v23 = a3;
        unsigned int v24 = a4;
        goto LABEL_111;
      }

LABEL_113:
      int v34 = -1;
      goto LABEL_114;
    case 3:
    case 4:
      if (!a11 || !*a8)
      {
        int v118 = 0;
        __int128 v117 = 0uLL;
        __int128 v116 = 0uLL;
        __int128 v115 = 0uLL;
        __int128 v114 = 0uLL;
        __int128 v113 = 0uLL;
        __int128 v112 = 0uLL;
        __int128 v111 = 0uLL;
        __int128 v110 = 0uLL;
        __int128 v109 = 0uLL;
        __int128 v108 = 0uLL;
        __int128 v107 = 0uLL;
        __int128 v106 = 0uLL;
        __int128 v105 = 0uLL;
        __int128 v104 = 0uLL;
        __int128 v103 = 0uLL;
        __int128 v102 = 0uLL;
        int v101 = 0;
        __int128 v100 = 0uLL;
        __int128 v99 = 0uLL;
        __int128 v98 = 0uLL;
        __int128 v97 = 0uLL;
        __int128 v96 = 0uLL;
        __int128 v95 = 0uLL;
        __int128 v94 = 0uLL;
        __int128 v93 = 0uLL;
        __int128 v92 = 0uLL;
        __int128 v91 = 0uLL;
        __int128 v90 = 0uLL;
        __int128 v89 = 0uLL;
        __int128 v88 = 0uLL;
        __int128 v87 = 0uLL;
        __int128 v86 = 0uLL;
        *(_OWORD *)__n = 0uLL;
        if (*((void *)a1 + 9)
          && (uint64_t v35 = (uint64_t (*)(__int128 *, unsigned int *, _DWORD *))*((void *)a1 + 14)) != 0LL
          && *((void *)a1 + 20))
        {
          if (*a6 == a1[5])
          {
            if (*a9 == a1[4])
            {
              if ((v35(&v102, a6, a9) & 0x80000000) != 0)
              {
                int v44 = -4;
              }

              else if ((_DWORD)v102 == a1[6])
              {
                if (((*((uint64_t (**)(size_t *, _DWORD *))a1 + 20))(__n, a9) & 0x80000000) != 0)
                {
                  int v44 = -6;
                }

                else
                {
                  memset(v133, 0, sizeof(v133));
                  __int128 v132 = 0u;
                  __int128 v131 = 0u;
                  __int128 v130 = 0u;
                  __int128 v129 = 0u;
                  __int128 v128 = 0u;
                  __int128 v127 = 0u;
                  __int128 v126 = 0u;
                  __int128 v125 = 0u;
                  __int128 v124 = 0u;
                  __int128 v123 = 0u;
                  __int128 v122 = 0u;
                  __int128 v121 = 0u;
                  __int128 v120 = 0u;
                  *(_OWORD *)&__s[8] = 0u;
                  if ((_DWORD)v102 == *a1)
                  {
                    if (*a10 == a1[2])
                    {
                      if (*a6 == a1[5])
                      {
                        if (LODWORD(__n[0]) == *a6)
                        {
                          if (*a7 == a1[8])
                          {
                            *(_DWORD *)&__s[7] = 1263354207;
                            *(void *)size_t __s = 0x5F41454100000007LL;
                            uint64_t result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                            uint64_t v36 = *(unsigned int *)__s;
                            if (*(_DWORD *)__s >= 0xFDu) {
                              goto LABEL_135;
                            }
                            *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                            *(_DWORD *)size_t __s = v36 + 4;
                            uint64_t result = memset_s(&__s[v36 + 8], 252 - v36, 0, 252 - v36);
                            size_t v37 = *a6;
                            unint64_t v38 = *(unsigned int *)__s + v37;
                            if (v38 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], a6 + 1, v37);
                            *(_DWORD *)size_t __s = v38;
                            uint64_t result = memset_s(&__s[v38 + 4], 256 - v38, 0, 256 - v38);
                            unint64_t v39 = *(unsigned int *)__s + (unint64_t)LODWORD(__n[0]);
                            if (v39 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], (char *)__n + 4, LODWORD(__n[0]));
                            *(_DWORD *)size_t __s = v39;
                            uint64_t result = memset_s(&__s[v39 + 4], 256 - v39, 0, 256 - v39);
                            size_t v40 = *a7;
                            unint64_t v41 = *(unsigned int *)__s + v40;
                            if (v41 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v40);
                            *(_DWORD *)size_t __s = v41;
                            memset_s(&__s[v41 + 4], 256 - v41, 0, 256 - v41);
                            size_t v42 = (uint64_t (*)(_DWORD *, void, __int128 *, _BYTE *, _DWORD *))*((void *)a1 + 9);
                            int v43 = -1;
                            if (v42 && (_DWORD)v102) {
                              int v43 = v42(a3, *a1, &v102, __s, a10);
                            }
                            if (*a3 == *a1) {
                              int v44 = v43;
                            }
                            else {
                              int v44 = -1006;
                            }
                            memset_s(__s, 0x104uLL, 0, 0x104uLL);
                            if (v44) {
                              memset_s(a3, 0x104uLL, 0, 0x104uLL);
                            }
                          }

                          else
                          {
                            int v44 = -1005;
                          }
                        }

                        else
                        {
                          int v44 = -1004;
                        }
                      }

                      else
                      {
                        int v44 = -1003;
                      }
                    }

                    else
                    {
                      int v44 = -1002;
                    }
                  }

                  else
                  {
                    int v44 = -1001;
                  }
                }
              }

              else
              {
                int v44 = -5;
              }
            }

            else
            {
              int v44 = -3;
            }
          }

          else
          {
            int v44 = -2;
          }
        }

        else
        {
          int v44 = -1;
        }

        memset_s(&v102, 0x104uLL, 0, 0x104uLL);
        char v48 = __n;
        goto LABEL_70;
      }

      *(void *)&__int128 v102 = 0LL;
      size_t v26 = a6 + 1;
      uint64_t result = a11(a12, a1[6], (char *)v62 + 4, &v102, a6 + 1, *a6);
      if ((result & 0x80000000) != 0)
      {
        __int16 v45 = "DH callback";
        __int16 v46 = 321;
        goto LABEL_74;
      }

      if ((void)v102 != a1[6])
      {
        __int16 v45 = "DH callback returning invalid shared secret size";
        __int16 v46 = 322;
        goto LABEL_74;
      }

      LODWORD(v62[0]) = v102;
      memset_s((char *)v62 + v102 + 4, 256 - v102, 0, 256 - v102);
      memset(v133, 0, sizeof(v133));
      __int128 v132 = 0u;
      __int128 v131 = 0u;
      __int128 v130 = 0u;
      __int128 v129 = 0u;
      __int128 v128 = 0u;
      __int128 v127 = 0u;
      __int128 v126 = 0u;
      __int128 v125 = 0u;
      __int128 v124 = 0u;
      __int128 v123 = 0u;
      __int128 v122 = 0u;
      __int128 v121 = 0u;
      __int128 v120 = 0u;
      *(_OWORD *)&__s[8] = 0u;
      if (LODWORD(v62[0]) != *a1)
      {
LABEL_60:
        int v44 = -1001;
        goto LABEL_71;
      }

      if (*a10 != a1[2])
      {
LABEL_67:
        int v44 = -1002;
LABEL_71:
        if ((v44 & 0x80000000) == 0)
        {
          uint64_t v49 = 0LL;
LABEL_77:
          memset_s(v62, 0x104uLL, 0, 0x104uLL);
          return v49;
        }

        char v61 = v44;
        __int16 v45 = "Main key derivation failed (%d)";
        __int16 v46 = 353;
LABEL_74:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaDeriveMainKeyExisting",  v46,  79,  0,  v45,  (uint64_t)a7,  (uint64_t)a8,  v61);
        if (a3) {
          memset_s(a3, 0x104uLL, 0, 0x104uLL);
        }
        uint64_t v49 = 0xFFFFFFFFLL;
        goto LABEL_77;
      }

      if (*a6 != a1[5])
      {
LABEL_59:
        int v44 = -1003;
        goto LABEL_71;
      }

      if (*a8 != *a6)
      {
        int v44 = -1004;
        goto LABEL_71;
      }

      if (*a7 != a1[8])
      {
LABEL_112:
        int v44 = -1005;
        goto LABEL_71;
      }

      *(_DWORD *)&__s[7] = 1263354207;
      *(void *)size_t __s = 0x5F41454100000007LL;
      uint64_t result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      uint64_t v27 = *(unsigned int *)__s;
      if (*(_DWORD *)__s < 0xFDu)
      {
        *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
        *(_DWORD *)size_t __s = v27 + 4;
        uint64_t result = memset_s(&__s[v27 + 8], 252 - v27, 0, 252 - v27);
        size_t v28 = *a6;
        unint64_t v29 = *(unsigned int *)__s + v28;
        if (v29 < 0x101)
        {
          memcpy(&__s[*(unsigned int *)__s + 4], v26, v28);
          *(_DWORD *)size_t __s = v29;
          uint64_t result = memset_s(&__s[v29 + 4], 256 - v29, 0, 256 - v29);
          size_t v30 = *a8;
          unint64_t v31 = *(unsigned int *)__s + v30;
          if (v31 < 0x101)
          {
            memcpy(&__s[*(unsigned int *)__s + 4], a8 + 1, v30);
            *(_DWORD *)size_t __s = v31;
            uint64_t result = memset_s(&__s[v31 + 4], 256 - v31, 0, 256 - v31);
            size_t v32 = *a7;
            unint64_t v33 = *(unsigned int *)__s + v32;
            if (v33 < 0x101)
            {
              memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v32);
              *(_DWORD *)size_t __s = v33;
              memset_s(&__s[v33 + 4], 256 - v33, 0, 256 - v33);
              __int16 v21 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, _BYTE *, _DWORD *))*((void *)a1 + 9);
              int v34 = -1;
              if (v21 && LODWORD(v62[0]))
              {
                uint64_t v22 = *a1;
                unsigned int v24 = v62;
                int v23 = a3;
LABEL_111:
                int v34 = v21(v23, v22, v24, __s, a10);
              }

LABEL_114:
              if (*a3 == *a1) {
                int v44 = v34;
              }
              else {
                int v44 = -1006;
              }
              memset_s(__s, 0x104uLL, 0, 0x104uLL);
              if (v44)
              {
                char v48 = (size_t *)a3;
LABEL_70:
                memset_s(v48, 0x104uLL, 0, 0x104uLL);
              }

              goto LABEL_71;
            }
          }
        }
      }

                if (!mkdir(v131, 0x1EDu))
                {
                  if ((*(_BYTE *)(v56 + 2056) & 3) != 0)
                  {
                    if ((*(_BYTE *)(v56 + 2056) & 1) != 0) {
                      int v101 = *(_DWORD *)(v56 + 2060);
                    }
                    else {
                      int v101 = -1;
                    }
                    if ((*(_BYTE *)(v56 + 2056) & 2) != 0) {
                      __int128 v113 = *(_DWORD *)(v56 + 2064);
                    }
                    else {
                      __int128 v113 = -1;
                    }
                    chown(v131, v101, v113);
                  }

                  goto LABEL_190;
                }

                if (!lstat(v131, &v127) && (v127.st_mode & 0xF000) == 0x4000) {
                  goto LABEL_190;
                }
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"createFilesystemObject",  305,  72,  0,  "mkdir failed: %s",  v82,  v83,  v56);
LABEL_131:
                int v118 = v56;
                int v84 = 829;
                uint64_t v85 = "creating fs object: %s";
                goto LABEL_132;
              }

              if (*(_DWORD *)(v9 + 1056))
              {
                removeFile(v131);
                __int128 v81 = *(void *)(v56 + 2048);
              }

              switch(v81)
              {
                case 'H':
                  __int128 v102 = *__error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"createFilesystemObject",  320,  72,  v102,  "link %s",  v103,  v104,  v56);
                  goto LABEL_131;
                case 'P':
                  if (!mkfifo(v131, 0x1A4u)) {
                    goto LABEL_190;
                  }
                  __int128 v105 = *__error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"createFilesystemObject",  325,  72,  v105,  "mkfifo %s",  v106,  v107,  v56);
                  goto LABEL_131;
                case 'L':
                  __int128 v89 = *__error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"createFilesystemObject",  315,  72,  v89,  "symlink %s",  v90,  v91,  v56);
                  goto LABEL_131;
              }

              __int128 v87 = 330;
              __int128 v88 = "not implemented yet";
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"createFilesystemObject",  v87,  72,  0,  v88,  v79,  v80,  v118);
            goto LABEL_131;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  811,  72,  0,  "opening output file: %s",  v33,  v34,  (char)v130);
        }

        uint64_t v14 = 0;
        int v65 = 1;
LABEL_183:
        int v16 = (pthread_mutex_t *)(v8 + 56);
        rsize_t v17 = (pthread_cond_t *)(v8 + 120);
LABEL_86:
        __int128 v69 = *(size_t *)((char *)buf + 4);
        if (*(size_t *)((char *)buf + 4))
        {
          while (1)
          {
            __int128 v70 = v69 >= 0x40000 ? 0x40000LL : v69;
            __int128 v71 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v70);
            if (v71 < 0) {
              break;
            }
            __int128 v69 = *(size_t *)((char *)buf + 4) - v71;
            *(size_t *)((char *)buf + 4) -= v71;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  953,  72,  0,  "reading payload",  v72,  v73,  v118);
        }

        else
        {
LABEL_92:
          if (!v65) {
            continue;
          }
        }

        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0) {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  959,  72,  0,  "retire failed entry",  v74,  v75,  v118);
        }
        break;
      case 'F':
        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  792,  72,  0,  "retire failed entry",  v63,  v64,  v118);
          uint64_t v14 = 0;
          int v65 = 1;
        }

        else
        {
          int v65 = 0;
          uint64_t v14 = 0;
        }

        goto LABEL_86;
      default:
        if ((LODWORD(buf[0]) - 88) >= 2)
        {
          if (LODWORD(buf[0]) == 42) {
            goto LABEL_199;
          }
LABEL_67:
          uint64_t v35 = 942;
          uint64_t v36 = "Invalid thread command";
        }

        else
        {
LABEL_25:
          size_t v37 = *(unint64_t **)(v8 + 168);
          if (!v37) {
            goto LABEL_74;
          }
          unint64_t v38 = v37 + 281;
          unint64_t v39 = v37 + 275;
          size_t v40 = v37 + 278;
          if (LODWORD(buf[0]) != 65) {
            size_t v40 = 0LL;
          }
          if (LODWORD(buf[0]) == 88) {
            size_t v40 = v39;
          }
          if (LODWORD(buf[0]) == 89) {
            unint64_t v41 = v38;
          }
          else {
            unint64_t v41 = v40;
          }
          if (*v41 + *(size_t *)((char *)buf + 4) <= v41[1])
          {
            __int128 v66 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), (void *)(v41[2] + *v41), *(size_t *)((char *)buf + 4));
            if (v66 < 0)
            {
              uint64_t v35 = 933;
LABEL_80:
              uint64_t v36 = "reading payload";
            }

            else
            {
              int v67 = *(size_t *)((char *)buf + 4);
              *(size_t *)((char *)buf + 4) -= v66;
              if (v66)
              {
                uint64_t v68 = *v41 + v66;
                if (!__CFADD__(*v41, v66) && v68 <= v41[1]) {
                  char *v41 = v68;
                }
              }

              if (v67 == v66)
              {
LABEL_74:
                int v65 = 0;
                goto LABEL_85;
              }

              uint64_t v35 = 936;
              uint64_t v36 = "truncated read";
            }
          }

          else
          {
            uint64_t v35 = 931;
            uint64_t v36 = "too many blob bytes received";
          }
        }

LABEL_135:
      __break(1u);
      return result;
    case 5:
      int v118 = 0;
      __int128 v117 = 0uLL;
      __int128 v116 = 0uLL;
      __int128 v115 = 0uLL;
      __int128 v114 = 0uLL;
      __int128 v113 = 0uLL;
      __int128 v112 = 0uLL;
      __int128 v111 = 0uLL;
      __int128 v110 = 0uLL;
      __int128 v109 = 0uLL;
      __int128 v108 = 0uLL;
      __int128 v107 = 0uLL;
      __int128 v106 = 0uLL;
      __int128 v105 = 0uLL;
      __int128 v104 = 0uLL;
      __int128 v103 = 0uLL;
      __int128 v102 = 0uLL;
      int v101 = 0;
      __int128 v100 = 0uLL;
      __int128 v99 = 0uLL;
      __int128 v98 = 0uLL;
      __int128 v97 = 0uLL;
      __int128 v96 = 0uLL;
      __int128 v95 = 0uLL;
      __int128 v94 = 0uLL;
      __int128 v93 = 0uLL;
      __int128 v92 = 0uLL;
      __int128 v91 = 0uLL;
      __int128 v90 = 0uLL;
      __int128 v89 = 0uLL;
      __int128 v88 = 0uLL;
      __int128 v87 = 0uLL;
      __int128 v86 = 0uLL;
      *(_OWORD *)__n = 0uLL;
      int v84 = 0;
      __int128 v83 = 0uLL;
      __int128 v82 = 0uLL;
      __int128 v81 = 0uLL;
      __int128 v79 = 0uLL;
      __int128 v80 = 0uLL;
      __int128 v77 = 0uLL;
      __int128 v78 = 0uLL;
      __int128 v75 = 0uLL;
      __int128 v76 = 0uLL;
      __int128 v73 = 0uLL;
      __int128 v74 = 0uLL;
      __int128 v71 = 0uLL;
      __int128 v72 = 0uLL;
      __int128 v69 = 0uLL;
      __int128 v70 = 0uLL;
      *(_OWORD *)uint64_t v68 = 0uLL;
      int v67 = 0;
      memset(v66, 0, sizeof(v66));
      int v65 = 0;
      memset(v64, 0, sizeof(v64));
      if (*((void *)a1 + 10) && *((void *)a1 + 9))
      {
        if (*a5 >= 0x14u)
        {
          if (*a10 == a1[2])
          {
            WORD2(__n[1]) = 21584;
            *(size_t *)((char *)__n + 4) = *(void *)"AEA_SCRYPT";
            LODWORD(__n[0]) = 10;
            memset_s((void *)((unint64_t)__n | 0xE), 0xF6uLL, 0, 0xF6uLL);
            uint64_t result = (*((uint64_t (**)(__int128 *, void, _DWORD *, size_t *, size_t *))a1 + 9))( &v102,  2 * a1[2],  a10,  __n,  v68);
            if ((result & 0x80000000) != 0)
            {
              int v44 = -4;
            }

            else
            {
              uint64_t v50 = a1[2];
              __memcpy_chk();
              LODWORD(v66[0]) = v50;
              uint64_t result = memset_s((char *)v66 + v50 + 4, 256 - v50, 0, 256 - v50);
              uint64_t v51 = a1[2];
              __memcpy_chk();
              LODWORD(v64[0]) = v51;
              memset_s((char *)v64 + v51 + 4, 256 - v51, 0, 256 - v51);
              memset_s(&v102, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(__int128 *, _DWORD *, void, void, _OWORD *))a1 + 10))( &v102,  a5 + 1,  *a5,  a1[14],  v66) & 0x80000000) != 0)
              {
                int v44 = -5;
              }

              else
              {
                memset(v133, 0, sizeof(v133));
                __int128 v132 = 0u;
                __int128 v131 = 0u;
                __int128 v130 = 0u;
                __int128 v129 = 0u;
                __int128 v128 = 0u;
                __int128 v127 = 0u;
                __int128 v126 = 0u;
                __int128 v125 = 0u;
                __int128 v124 = 0u;
                __int128 v123 = 0u;
                __int128 v122 = 0u;
                __int128 v121 = 0u;
                __int128 v120 = 0u;
                *(_OWORD *)&__s[8] = 0u;
                if ((_DWORD)v102 == *a1)
                {
                  if (LODWORD(v64[0]) == a1[2])
                  {
                    if (LODWORD(v68[0]) == a1[5])
                    {
                      if (*a7 == a1[8])
                      {
                        *(_DWORD *)&__s[7] = 1263354207;
                        *(void *)size_t __s = 0x5F41454100000007LL;
                        uint64_t result = memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                        uint64_t v52 = *(unsigned int *)__s;
                        if (*(_DWORD *)__s >= 0xFDu) {
                          goto LABEL_135;
                        }
                        *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                        *(_DWORD *)size_t __s = v52 + 4;
                        uint64_t result = memset_s(&__s[v52 + 8], 252 - v52, 0, 252 - v52);
                        unint64_t v53 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v53 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)size_t __s = v53;
                        uint64_t result = memset_s(&__s[v53 + 4], 256 - v53, 0, 256 - v53);
                        unint64_t v54 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v54 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)size_t __s = v54;
                        uint64_t result = memset_s(&__s[v54 + 4], 256 - v54, 0, 256 - v54);
                        size_t v55 = *a7;
                        unint64_t v56 = *(unsigned int *)__s + v55;
                        if (v56 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v55);
                        *(_DWORD *)size_t __s = v56;
                        memset_s(&__s[v56 + 4], 256 - v56, 0, 256 - v56);
                        uint64_t v57 = (uint64_t (*)(_DWORD *, void, __int128 *, _BYTE *, _OWORD *))*((void *)a1 + 9);
                        int v58 = -1;
                        if (v57 && (_DWORD)v102) {
                          int v58 = v57(a3, *a1, &v102, __s, v64);
                        }
                        if (*a3 == *a1) {
                          int v44 = v58;
                        }
                        else {
                          int v44 = -1006;
                        }
                        memset_s(__s, 0x104uLL, 0, 0x104uLL);
                        if (v44) {
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                        }
                      }

                      else
                      {
                        int v44 = -1005;
                      }
                    }

                    else
                    {
                      int v44 = -1003;
                    }
                  }

                  else
                  {
                    int v44 = -1002;
                  }
                }

                else
                {
                  int v44 = -1001;
                }
              }
            }
          }

          else
          {
            int v44 = -3;
          }
        }

        else
        {
          int v44 = -2;
        }
      }

      else
      {
        int v44 = -1;
      }

      memset_s(&v102, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v66, 0x104uLL, 0, 0x104uLL);
      char v48 = (size_t *)v64;
      goto LABEL_70;
    default:
      __int16 v45 = "Unsupported profile";
      __int16 v46 = 351;
      goto LABEL_74;
  }

  __int128 v105 = *(void *)(v11 + 1584);
  if (!v105)
  {
    *(void *)(v11 + 1584) = 0LL;
    unint64_t v119 = v11 + 1312;
    goto LABEL_147;
  }

  __int128 v106 = v105 - 1;
  __int128 v107 = 1;
  while (2)
  {
    __int128 v108 = *(const char **)(*(void *)(v11 + 1592) + 8 * v106);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, v108) & 0x80000000) != 0)
    {
      __int128 v117 = 983;
      int v118 = "invalid 'D' PAT";
    }

    else
    {
      if ((applyEntryAttributes(v11, (uint64_t)v108) & 0x80000000) == 0)
      {
        __int128 v116 = 1;
        goto LABEL_143;
      }

      __int128 v117 = 984;
      int v118 = "applyEntryAttributes failed";
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamProcessDirs",  v117,  72,  0,  v118,  v109,  v110,  v139);
    __int128 v116 = 0;
LABEL_143:
    entryRelease((uint64_t)v108, v111, v112, v113, v114, v115, v109, v110);
    *(void *)(*(void *)(v11 + 1592) + 8 * v106) = 0LL;
    v107 &= v116;
    if (--v106 != -1) {
      continue;
    }
    break;
  }

  *(void *)(v11 + 1584) = 0LL;
  unint64_t v119 = v11 + 1312;
  if (!v107)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamClose",  1553,  72,  0,  "process dirs",  v45,  v46,  v139);
    uint64_t v142 = 0;
  }

uint64_t aeaDeriveMainKeyNew( unsigned int *a1, int *a2, __int128 *a3, int *a4, char *__s, int *a6, _DWORD *a7, unsigned int *a8, unsigned int *a9)
{
  uint64_t v117 = *MEMORY[0x1895F89C0];
  int v16 = *a2;
  int v17 = a2[2];
  uint64_t v18 = a1[2];
  if (__s) {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  if (v18 > 0x100
    || (size_t v19 = (uint64_t (*)(char *, uint64_t))*((void *)a1 + 8)) == 0LL
    || (v19(__s + 4, v18) & 0x80000000) != 0)
  {
    uint64_t v22 = "generating random salt";
    __int16 v23 = 380;
LABEL_12:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaDeriveMainKeyNew",  v23,  79,  0,  v22,  (uint64_t)a7,  (uint64_t)a8,  v60);
    return 0xFFFFFFFFLL;
  }

  *(_DWORD *)size_t __s = v18;
  int v20 = v16 & 0xFFFFFF | (v17 << 24);
  switch(*a2)
  {
    case 0:
      uint64_t v37 = a1[12];
      if (a4) {
        memset_s(a4, 0x104uLL, 0, 0x104uLL);
      }
      if (v37 > 0x100
        || (unint64_t v38 = (uint64_t (*)(int *, uint64_t))*((void *)a1 + 8)) == 0LL
        || (v38(a4 + 1, v37) & 0x80000000) != 0)
      {
        uint64_t v22 = "generating random encryption key";
        __int16 v23 = 390;
        goto LABEL_12;
      }

      *a4 = v37;
      memset(v116, 0, sizeof(v116));
      __int128 v115 = 0u;
      __int128 v114 = 0u;
      __int128 v113 = 0u;
      __int128 v112 = 0u;
      __int128 v111 = 0u;
      __int128 v110 = 0u;
      __int128 v109 = 0u;
      __int128 v108 = 0u;
      __int128 v107 = 0u;
      __int128 v106 = 0u;
      __int128 v105 = 0u;
      __int128 v104 = 0u;
      __int128 v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if ((_DWORD)v37 != *a1)
      {
LABEL_50:
        int v21 = -1001;
        goto LABEL_115;
      }

      if (*(_DWORD *)__s != a1[2])
      {
LABEL_58:
        int v21 = -1002;
        goto LABEL_115;
      }

      if (a1[5])
      {
LABEL_10:
        int v21 = -1003;
        goto LABEL_115;
      }

      if (*a8 != a1[8])
      {
LABEL_87:
        int v21 = -1005;
        goto LABEL_115;
      }

      *(_DWORD *)&v102[7] = 1263354207;
      *(void *)__int128 v102 = 0x5F41454100000007LL;
      memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
      *(_DWORD *)__int128 v102 = 11;
      memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256LL - *(unsigned int *)v102, 0, 256LL - *(unsigned int *)v102);
      uint64_t result = memset_s( &v102[*(unsigned int *)v102 + 4],  256LL - *(unsigned int *)v102,  0,  256LL - *(unsigned int *)v102);
      size_t v39 = *a8;
      unint64_t v40 = *(unsigned int *)v102 + v39;
      if (v40 >= 0x101) {
        goto LABEL_124;
      }
      memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v39);
      *(_DWORD *)__int128 v102 = v40;
      memset_s(&v102[v40 + 4], 256 - v40, 0, 256 - v40);
      unint64_t v41 = (uint64_t (*)(__int128 *, uint64_t, int *, _BYTE *, char *))*((void *)a1 + 9);
      if (v41)
      {
        size_t v42 = a3;
        if (*a4)
        {
          uint64_t v43 = *a1;
          int v44 = a3;
          __int16 v45 = a4;
LABEL_84:
          int v59 = v41(v44, v43, v45, v102, __s);
        }

        else
        {
LABEL_93:
          int v59 = -1;
        }
      }

      else
      {
LABEL_90:
        int v59 = -1;
        size_t v42 = a3;
      }

      if (*(_DWORD *)v42 == *a1) {
        int v21 = v59;
      }
      else {
        int v21 = -1006;
      }
      memset_s(v102, 0x104uLL, 0, 0x104uLL);
      if (!v21) {
        goto LABEL_115;
      }
      p_sa = v42;
      goto LABEL_114;
    case 1:
    case 2:
      memset(v116, 0, sizeof(v116));
      __int128 v115 = 0u;
      __int128 v114 = 0u;
      __int128 v113 = 0u;
      __int128 v112 = 0u;
      __int128 v111 = 0u;
      __int128 v110 = 0u;
      __int128 v109 = 0u;
      __int128 v108 = 0u;
      __int128 v107 = 0u;
      __int128 v106 = 0u;
      __int128 v105 = 0u;
      __int128 v104 = 0u;
      __int128 v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if (*a6 != *a1) {
        goto LABEL_50;
      }
      if ((_DWORD)v18 != a1[2]) {
        goto LABEL_58;
      }
      if (a1[5]) {
        goto LABEL_10;
      }
      if (*a8 != a1[8]) {
        goto LABEL_87;
      }
      *(_DWORD *)&v102[7] = 1263354207;
      *(void *)__int128 v102 = 0x5F41454100000007LL;
      memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
      *(_DWORD *)__int128 v102 = 11;
      memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256LL - *(unsigned int *)v102, 0, 256LL - *(unsigned int *)v102);
      uint64_t result = memset_s( &v102[*(unsigned int *)v102 + 4],  256LL - *(unsigned int *)v102,  0,  256LL - *(unsigned int *)v102);
      size_t v57 = *a8;
      unint64_t v58 = *(unsigned int *)v102 + v57;
      if (v58 >= 0x101) {
        goto LABEL_124;
      }
      memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v57);
      *(_DWORD *)__int128 v102 = v58;
      memset_s(&v102[v58 + 4], 256 - v58, 0, 256 - v58);
      unint64_t v41 = (uint64_t (*)(__int128 *, uint64_t, int *, _BYTE *, char *))*((void *)a1 + 9);
      if (!v41) {
        goto LABEL_90;
      }
      size_t v42 = a3;
      if (!*a6) {
        goto LABEL_93;
      }
      uint64_t v43 = *a1;
      int v44 = a3;
      __int16 v45 = a6;
      goto LABEL_84;
    case 3:
    case 4:
      int v101 = 0;
      __int128 v100 = 0u;
      __int128 v99 = 0u;
      __int128 v98 = 0u;
      __int128 v97 = 0u;
      __int128 v96 = 0u;
      __int128 v95 = 0u;
      __int128 v94 = 0u;
      __int128 v93 = 0u;
      __int128 v92 = 0u;
      __int128 v91 = 0u;
      __int128 v90 = 0u;
      __int128 v89 = 0u;
      __int128 v88 = 0u;
      __int128 v87 = 0u;
      __int128 v86 = 0u;
      __int128 __sa = 0u;
      if (!*((void *)a1 + 9)
        || (uint64_t v25 = (uint64_t (*)(__int128 *, int *, unsigned int *))*((void *)a1 + 13)) == 0LL)
      {
        int v21 = -1;
LABEL_113:
        p_sa = &__sa;
        goto LABEL_114;
      }

      if (*a9 != a1[5])
      {
        int v21 = -2;
        goto LABEL_113;
      }

      if ((v25(&__sa, a4, a9) & 0x80000000) != 0)
      {
        int v21 = -3;
        goto LABEL_113;
      }

      int v26 = *a4;
      if (*a4 != a1[5])
      {
        int v21 = -4;
        goto LABEL_113;
      }

      if ((_DWORD)__sa != a1[6])
      {
        int v21 = -5;
        goto LABEL_113;
      }

      memset(v116, 0, sizeof(v116));
      __int128 v115 = 0u;
      __int128 v114 = 0u;
      __int128 v113 = 0u;
      __int128 v112 = 0u;
      __int128 v111 = 0u;
      __int128 v110 = 0u;
      __int128 v109 = 0u;
      __int128 v108 = 0u;
      __int128 v107 = 0u;
      __int128 v106 = 0u;
      __int128 v105 = 0u;
      __int128 v104 = 0u;
      __int128 v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if ((_DWORD)__sa != *a1)
      {
        int v21 = -1001;
        goto LABEL_113;
      }

      if (*(_DWORD *)__s != a1[2])
      {
        int v21 = -1002;
        goto LABEL_113;
      }

      if (*a9 != v26)
      {
        int v21 = -1004;
        goto LABEL_113;
      }

      if (*a8 != a1[8])
      {
        int v21 = -1005;
        goto LABEL_113;
      }

      *(_DWORD *)&v102[7] = 1263354207;
      *(void *)__int128 v102 = 0x5F41454100000007LL;
      uint64_t result = memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      uint64_t v27 = *(unsigned int *)v102;
      if (*(_DWORD *)v102 < 0xFDu)
      {
        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
        *(_DWORD *)__int128 v102 = v27 + 4;
        uint64_t result = memset_s(&v102[v27 + 8], 252 - v27, 0, 252 - v27);
        size_t v28 = *a4;
        unint64_t v29 = *(unsigned int *)v102 + v28;
        if (v29 < 0x101)
        {
          memcpy(&v102[*(unsigned int *)v102 + 4], a4 + 1, v28);
          *(_DWORD *)__int128 v102 = v29;
          uint64_t result = memset_s(&v102[v29 + 4], 256 - v29, 0, 256 - v29);
          size_t v30 = *a9;
          unint64_t v31 = *(unsigned int *)v102 + v30;
          if (v31 < 0x101)
          {
            memcpy(&v102[*(unsigned int *)v102 + 4], a9 + 1, v30);
            *(_DWORD *)__int128 v102 = v31;
            uint64_t result = memset_s(&v102[v31 + 4], 256 - v31, 0, 256 - v31);
            size_t v32 = *a8;
            unint64_t v33 = *(unsigned int *)v102 + v32;
            if (v33 < 0x101)
            {
              memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v32);
              *(_DWORD *)__int128 v102 = v33;
              memset_s(&v102[v33 + 4], 256 - v33, 0, 256 - v33);
              int v34 = (uint64_t (*)(__int128 *, void, __int128 *, _BYTE *, char *))*((void *)a1 + 9);
              int v35 = -1;
              if (v34)
              {
                uint64_t v36 = a3;
                if ((_DWORD)__sa) {
                  int v35 = v34(a3, *a1, &__sa, v102, __s);
                }
              }

              else
              {
                uint64_t v36 = a3;
              }

              if (*(_DWORD *)v36 == *a1) {
                int v21 = v35;
              }
              else {
                int v21 = -1006;
              }
              memset_s(v102, 0x104uLL, 0, 0x104uLL);
              if (v21) {
                memset_s(v36, 0x104uLL, 0, 0x104uLL);
              }
              goto LABEL_113;
            }
          }
        }
      }

LABEL_124:
      __break(1u);
      return result;
    case 5:
      int v101 = 0;
      __int128 v100 = 0u;
      __int128 v99 = 0u;
      __int128 v98 = 0u;
      __int128 v97 = 0u;
      __int128 v96 = 0u;
      __int128 v95 = 0u;
      __int128 v94 = 0u;
      __int128 v93 = 0u;
      __int128 v92 = 0u;
      __int128 v91 = 0u;
      __int128 v90 = 0u;
      __int128 v89 = 0u;
      __int128 v88 = 0u;
      __int128 v87 = 0u;
      __int128 v86 = 0u;
      __int128 __sa = 0u;
      int v84 = 0;
      memset(v83, 0, sizeof(v83));
      int v82 = 0;
      __int128 v80 = 0u;
      __int128 v81 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      __int128 v76 = 0u;
      __int128 v77 = 0u;
      __int128 v74 = 0u;
      __int128 v75 = 0u;
      __int128 v72 = 0u;
      __int128 v73 = 0u;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      *(_OWORD *)__n = 0u;
      __int128 v67 = 0u;
      int v65 = 0;
      memset(v64, 0, sizeof(v64));
      int v63 = 0;
      memset(v62, 0, sizeof(v62));
      if (*((void *)a1 + 10) && *((void *)a1 + 9))
      {
        if (*a7 >= 0x14u)
        {
          if ((_DWORD)v18 == a1[2])
          {
            WORD6(v83[0]) = 21584;
            *(void *)((char *)v83 + 4) = *(void *)"AEA_SCRYPT";
            LODWORD(v83[0]) = 10;
            memset_s((void *)((unint64_t)v83 | 0xE), 0xF6uLL, 0, 0xF6uLL);
            uint64_t result = (*((uint64_t (**)(__int128 *, void, char *, _OWORD *, size_t *))a1 + 9))( &__sa,  2 * a1[2],  __s,  v83,  __n);
            if ((result & 0x80000000) != 0)
            {
              int v21 = -4;
            }

            else
            {
              uint64_t v47 = a1[2];
              __memcpy_chk();
              LODWORD(v64[0]) = v47;
              uint64_t result = memset_s((char *)v64 + v47 + 4, 256 - v47, 0, 256 - v47);
              uint64_t v48 = a1[2];
              __memcpy_chk();
              LODWORD(v62[0]) = v48;
              memset_s((char *)v62 + v48 + 4, 256 - v48, 0, 256 - v48);
              memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(__int128 *, _DWORD *, void, void, _OWORD *))a1 + 10))( &__sa,  a7 + 1,  *a7,  a1[14],  v64) & 0x80000000) != 0)
              {
                int v21 = -5;
              }

              else
              {
                memset(v116, 0, sizeof(v116));
                __int128 v115 = 0u;
                __int128 v114 = 0u;
                __int128 v113 = 0u;
                __int128 v112 = 0u;
                __int128 v111 = 0u;
                __int128 v110 = 0u;
                __int128 v109 = 0u;
                __int128 v108 = 0u;
                __int128 v107 = 0u;
                __int128 v106 = 0u;
                __int128 v105 = 0u;
                __int128 v104 = 0u;
                __int128 v103 = 0u;
                *(_OWORD *)&v102[8] = 0u;
                if ((_DWORD)__sa == *a1)
                {
                  if (LODWORD(v62[0]) == a1[2])
                  {
                    if (LODWORD(__n[0]) == a1[5])
                    {
                      if (*a8 == a1[8])
                      {
                        *(_DWORD *)&v102[7] = 1263354207;
                        *(void *)__int128 v102 = 0x5F41454100000007LL;
                        uint64_t result = memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
                        uint64_t v49 = *(unsigned int *)v102;
                        if (*(_DWORD *)v102 >= 0xFDu) {
                          goto LABEL_124;
                        }
                        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
                        *(_DWORD *)__int128 v102 = v49 + 4;
                        uint64_t result = memset_s(&v102[v49 + 8], 252 - v49, 0, 252 - v49);
                        unint64_t v50 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v50 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)__int128 v102 = v50;
                        uint64_t result = memset_s(&v102[v50 + 4], 256 - v50, 0, 256 - v50);
                        unint64_t v51 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v51 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)__int128 v102 = v51;
                        uint64_t result = memset_s(&v102[v51 + 4], 256 - v51, 0, 256 - v51);
                        size_t v52 = *a8;
                        unint64_t v53 = *(unsigned int *)v102 + v52;
                        if (v53 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v52);
                        *(_DWORD *)__int128 v102 = v53;
                        memset_s(&v102[v53 + 4], 256 - v53, 0, 256 - v53);
                        unint64_t v54 = (uint64_t (*)(__int128 *, void, __int128 *, _BYTE *, _OWORD *))*((void *)a1 + 9);
                        int v55 = -1;
                        if (v54)
                        {
                          unint64_t v56 = a3;
                          if ((_DWORD)__sa) {
                            int v55 = v54(a3, *a1, &__sa, v102, v62);
                          }
                        }

                        else
                        {
                          unint64_t v56 = a3;
                        }

                        if (*(_DWORD *)v56 == *a1) {
                          int v21 = v55;
                        }
                        else {
                          int v21 = -1006;
                        }
                        memset_s(v102, 0x104uLL, 0, 0x104uLL);
                        if (v21) {
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                        }
                      }

                      else
                      {
                        int v21 = -1005;
                      }
                    }

                    else
                    {
                      int v21 = -1003;
                    }
                  }

                  else
                  {
                    int v21 = -1002;
                  }
                }

                else
                {
                  int v21 = -1001;
                }
              }
            }
          }

          else
          {
            int v21 = -3;
          }
        }

        else
        {
          int v21 = -2;
        }
      }

      else
      {
        int v21 = -1;
      }

      memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
      memset_s(v83, 0x104uLL, 0, 0x104uLL);
      memset_s(v64, 0x104uLL, 0, 0x104uLL);
      p_sa = v62;
LABEL_114:
      memset_s(p_sa, 0x104uLL, 0, 0x104uLL);
LABEL_115:
      if ((v21 & 0x80000000) == 0) {
        return 0LL;
      }
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"aeaDeriveMainKeyNew",  437,  79,  0,  "Main key derivation failed (%d)",  (uint64_t)a7,  (uint64_t)a8,  v21);
      return 0xFFFFFFFFLL;
    default:
      uint64_t v22 = "Unsupported profile";
      __int16 v23 = 435;
      goto LABEL_12;
  }

int AEAStreamSign(AAByteStream encrypted_stream, AEAContext context)
{
  uint64_t v86 = *MEMORY[0x1895F89C0];
  int v62 = 0;
  memset(__s, 0, sizeof(__s));
  int v60 = 0;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  *(_OWORD *)int v44 = 0u;
  __int128 v45 = 0u;
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  if (*(_DWORD *)context <= 5u && ((1 << *(_DWORD *)context) & 0x2A) != 0)
  {
    int v4 = 0;
    __int128 v40 = 0uLL;
    __int128 v41 = 0uLL;
    __int128 v38 = 0uLL;
    __int128 v39 = 0uLL;
    __int128 v36 = 0uLL;
    __int128 v37 = 0uLL;
    __int128 v34 = 0uLL;
    __int128 v35 = 0uLL;
    __int128 v32 = 0uLL;
    __int128 v33 = 0uLL;
    __int128 v30 = 0uLL;
    __int128 v31 = 0uLL;
    __int128 v29 = 0uLL;
    unint64_t v28 = 0LL;
    __int128 v26 = 0uLL;
    __int128 v27 = 0uLL;
    __int128 v24 = 0uLL;
    __int128 v25 = 0uLL;
    __int128 v22 = 0uLL;
    __int128 v23 = 0uLL;
LABEL_15:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v44, 0x104uLL, 0, 0x104uLL);
    memset_s(v42, 0x104uLL, 0, 0x104uLL);
    memset_s(&v22, 0x68uLL, 0, 0x68uLL);
    memset_s(&v29, 0xD0uLL, 0, 0xD0uLL);
    return v4;
  }

  uint64_t v5 = (char *)*((void *)context + 340);
  size_t v6 = *((void *)context + 341);
  __int128 v40 = 0uLL;
  __int128 v41 = 0uLL;
  __int128 v38 = 0uLL;
  __int128 v39 = 0uLL;
  __int128 v36 = 0uLL;
  __int128 v37 = 0uLL;
  __int128 v34 = 0uLL;
  __int128 v35 = 0uLL;
  __int128 v32 = 0uLL;
  __int128 v33 = 0uLL;
  __int128 v30 = 0uLL;
  __int128 v31 = 0uLL;
  __int128 v29 = 0uLL;
  unint64_t v28 = 0LL;
  __int128 v26 = 0uLL;
  __int128 v27 = 0uLL;
  __int128 v24 = 0uLL;
  __int128 v25 = 0uLL;
  __int128 v22 = 0uLL;
  __int128 v23 = 0uLL;
  if ((aeaCryptoInit((char *)&v29, (unsigned int *)context) & 0x80000000) != 0)
  {
    uint64_t v14 = "initializing crypto params";
    __int16 v15 = 467;
    goto LABEL_14;
  }

  uint64_t v9 = *((unsigned int *)context + 5);
  __int128 v22 = xmmword_1862D7850;
  *(void *)&__int128 v23 = *((unsigned int *)context + 1) + 12LL;
  *((void *)&v23 + 1) = v23 + HIDWORD(v31);
  *(void *)&__int128 v24 = *((void *)&v23 + 1) + v32;
  *((void *)&v24 + 1) = v24 + DWORD2(v29);
  *(void *)&__int128 v25 = *((void *)&v24 + 1) + HIDWORD(v29);
  *((void *)&v25 + 1) = v25 + 48;
  __int128 v26 = (void)v25 + 48LL + (unint64_t)HIDWORD(v29);
  uint64_t v10 = (*((unsigned int *)context + 12) + 8LL) * v9 + HIDWORD(v29);
  *(void *)&__int128 v27 = (*((unsigned int *)context + 12) + 8LL) * v9;
  *((void *)&v27 + 1) = v10;
  unint64_t v28 = v10 + HIDWORD(v29) * (unint64_t)v9;
  memset_s(&v5[v23], HIDWORD(v31), 0, HIDWORD(v31));
  if (!*((void *)&v36 + 1)
    || (int v11 = (*((uint64_t (**)(_OWORD *, char *, size_t))&v36 + 1))(v42, v5, v6),
        LODWORD(v42[0]) != DWORD1(v31))
    || v11 < 0)
  {
    uint64_t v14 = "digesting prologue";
    __int16 v15 = 474;
    goto LABEL_14;
  }

  unint64_t v12 = (uint64_t (*)(void, uint64_t, char *, _OWORD *, char *))*((void *)context + 302);
  if (v12)
  {
    *(void *)&v84[0] = 0LL;
    int result = v12(*((void *)context + 303), 256LL, (char *)__s + 4, v84, (char *)v42 + 4);
    if (result < 0)
    {
      uint64_t v14 = "signing prologue digest";
      __int16 v15 = 484;
      goto LABEL_14;
    }

    if (*(void *)&v84[0] > (unint64_t)DWORD2(v31))
    {
      uint64_t v14 = "invalid signature size";
      __int16 v15 = 485;
LABEL_14:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c",  (uint64_t)"AEAStreamSign",  v15,  79,  0,  v14,  v7,  v8,  v22);
      int v4 = -1;
      goto LABEL_15;
    }

    if (DWORD2(v31) >= 0x101) {
      goto LABEL_46;
    }
    LODWORD(__s[0]) = DWORD2(v31);
    int result = memset_s((char *)__s + DWORD2(v31) + 4, 256LL - DWORD2(v31), 0, 256LL - DWORD2(v31));
  }

  else if (!(void)v37 {
         || (int result = ((uint64_t (*)(_OWORD *, char *, _OWORD *))v37)(__s, (char *)context + 592, v42),
  }
             LODWORD(__s[0]) != DWORD2(v31))
         || result < 0)
  {
    uint64_t v14 = "signing prologue";
    __int16 v15 = 490;
    goto LABEL_14;
  }

  if (*(_DWORD *)context)
  {
    if (!(void)v38) {
      goto LABEL_36;
    }
    int v83 = 0;
    memset(v82, 0, sizeof(v82));
    int v81 = 0;
    memset(v80, 0, sizeof(v80));
    int v79 = 0;
    __int128 v78 = 0u;
    __int128 v77 = 0u;
    __int128 v76 = 0u;
    __int128 v75 = 0u;
    __int128 v74 = 0u;
    __int128 v73 = 0u;
    __int128 v72 = 0u;
    __int128 v71 = 0u;
    __int128 v70 = 0u;
    __int128 v69 = 0u;
    __int128 v68 = 0u;
    __int128 v67 = 0u;
    __int128 v66 = 0u;
    __int128 v65 = 0u;
    __int128 v64 = 0u;
    *(_OWORD *)__n = 0u;
    if (LODWORD(__s[0]) != DWORD2(v31)) {
      goto LABEL_35;
    }
    if (*((_DWORD *)context + 408) != (_DWORD)v29) {
      goto LABEL_35;
    }
    *(void *)((char *)v80 + 4) = 0x324B45535F414541LL;
    LODWORD(v80[0]) = 8;
    memset_s((void *)((unint64_t)v80 | 0xC), 0xF8uLL, 0, 0xF8uLL);
    int v85 = 0;
    memset(v84, 0, sizeof(v84));
    if (!*((void *)&v33 + 1)) {
      goto LABEL_35;
    }
    if (!*((_DWORD *)context + 408)) {
      goto LABEL_35;
    }
    int result = (*((uint64_t (**)(_OWORD *, void, char *, _OWORD *, _OWORD *))&v33 + 1))( v82,  DWORD1(v29),  (char *)context + 1632,  v80,  v84);
    if (result < 0) {
      goto LABEL_35;
    }
    uint64_t v16 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0x101) {
      goto LABEL_46;
    }
    __memcpy_chk();
    LODWORD(v44[0]) = v16;
    memset_s((char *)v44 + v16 + 4, 256 - v16, 0, 256 - v16);
    int result = ((uint64_t (*)(char *, void, size_t *, _OWORD *, void, void))v38)( (char *)v44 + 4,  LODWORD(__s[0]),  __n,  v82,  0LL,  0LL);
    if (result < 0)
    {
LABEL_35:
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      goto LABEL_36;
    }

    unint64_t v17 = LODWORD(v44[0]) + (unint64_t)LODWORD(__n[0]);
    if (v17 < 0x101)
    {
      memcpy((char *)v44 + LODWORD(v44[0]) + 4, (char *)__n + 4, LODWORD(__n[0]));
      LODWORD(v44[0]) = v17;
      memset_s((char *)v44 + v17 + 4, 256 - v17, 0, 256 - v17);
      int v18 = v44[0];
      int v19 = HIDWORD(v31);
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      if (v18 == v19)
      {
LABEL_39:
        memcpy(&v5[v23], (char *)v44 + 4, LODWORD(v44[0]));
        if (AAByteStreamPWrite(encrypted_stream, v5, v6, 0LL) == v6)
        {
          if (*((void *)&v41 + 1))
          {
            int v21 = (*((uint64_t (**)(char *, char *, size_t))&v41 + 1))((char *)context + 1892, v5, v6);
            if (*((_DWORD *)context + 473) == DWORD1(v32) && (v21 & 0x80000000) == 0)
            {
              int v4 = 0;
              goto LABEL_15;
            }
          }

          uint64_t v14 = "digesting prologue";
          __int16 v15 = 505;
        }

        else
        {
          uint64_t v14 = "writing updated prologue";
          __int16 v15 = 502;
        }

        goto LABEL_14;
      }

LABEL_46:
  __break(1u);
  return result;
}

    int v21 = "invalid compression algo";
    __int128 v22 = 342;
    goto LABEL_15;
  }

  if (v14 > 2048)
  {
    if (v14 == 2049)
    {
      uint64_t v20 = PCompressLZFSEDecode;
      goto LABEL_31;
    }

    if (v14 == 2304)
    {
      uint64_t v20 = PCompressLZVNDecode;
      goto LABEL_31;
    }

    goto LABEL_46;
  }

  if (v14 == 1285)
  {
    uint64_t v20 = PCompressZLIBDecode;
    goto LABEL_31;
  }

  if (v14 != 1794) {
    goto LABEL_46;
  }
  uint64_t v20 = PCompressLZBITMAPDecode;
LABEL_31:
  *((void *)v9 + 2) = v20;
  if (v17 > v16 || v18 > v16 || (unint64_t)v60 > v17 || v17 > v18 || *((void *)&v60 + 1) > v18)
  {
    int v21 = "invalid sizes";
    __int128 v22 = 352;
    goto LABEL_15;
  }

  if ((v16 & 0x8000000000000000LL) != 0) {
    goto LABEL_122;
  }
  __int128 v24 = (unint64_t *)((char *)v9 + 56);
  __int128 v25 = *((void *)v9 + 8);
  if (v25 < v16)
  {
    do
    {
      while (!v25)
      {
        __int128 v25 = 0x4000LL;
        if (v16 <= 0x4000)
        {
          __int128 v27 = (void **)((char *)v9 + 72);
          __int128 v25 = 0x4000LL;
          goto LABEL_49;
        }
      }

      __int128 v26 = v25 >> 1;
      if ((v25 & (v25 >> 1)) != 0) {
        __int128 v26 = v25 & (v25 >> 1);
      }
      v25 += v26;
    }

    while (v25 < v16);
    __int128 v27 = (void **)((char *)v9 + 72);
    if (v25 >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_118:
      *__int128 v27 = 0LL;
      *__int128 v24 = 0LL;
      *((void *)v9 + 8) = 0LL;
      goto LABEL_122;
    }

      setThreadErrorContext(0LL, v8, v9, v10, v11, v12, v13, v14, v49);
      free(v15);
      return v17;
    }
  }

  return 0LL;
}

        __int128 v37 = -1640531535 * (v37 + v11[v43]) - v42 * v11[v38];
        int v43 = v38 + 17;
        __int128 v23 = v38++ == v18;
      }

      while (!v23);
      if (!v41)
      {
        uint64_t v16 = v74;
        goto LABEL_6;
      }

      __int128 v73 = (uint64_t)v11;
      qsort(__base, v41, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_rating);
      if (v41 >= 0x10) {
        __int128 v55 = 16LL;
      }
      else {
        __int128 v55 = v41;
      }
      __int128 v78 = v55;
      qsort(__base, v55, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_position);
      __int128 v58 = 0LL;
      LODWORD(v17) = 0;
      do
      {
        __int128 v59 = *(void *)&v13[16 * v58];
        else {
          int v60 = *(void *)(v14 + 48) - v59;
        }
        char v61 = *(void **)(v14 + 16);
        if (!v61[4]) {
          goto LABEL_85;
        }
        if (v60)
        {
          int v62 = 0LL;
          int v63 = v77 + v17;
          __int128 v64 = v60;
          while (1)
          {
            __int128 v65 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v61[4])(*v61, v63, v64, v59);
            if (v65 < 0) {
              break;
            }
            if (v65)
            {
              v63 += v65;
              v62 += v65;
              v59 += v65;
              v64 -= v65;
              if (v64) {
                continue;
              }
            }

            goto LABEL_64;
          }

          int v62 = v65;
LABEL_64:
          __int128 v23 = v60 == v62;
          int v13 = __base;
          if (!v23)
          {
LABEL_85:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_output_block",  546,  112,  0,  "aaByteStreamPReadExpected",  v56,  v57,  v72);
            int v21 = 0;
            unint64_t v12 = (void *)v77;
            int v11 = (unsigned __int8 *)v73;
            goto LABEL_73;
          }
        }

        unint64_t v17 = (v17 + v60);
        ++v58;
      }

      while (v58 != v78);
      unint64_t v12 = (void *)v77;
      int v11 = (unsigned __int8 *)v73;
      uint64_t v16 = v74;
      if ((getBXDiffControls(v77, v17, v73, v76, (int8x16_t **)&v80, (uint64_t)v74, (int *)v14, v57) & 0x80000000) != 0)
      {
        __int128 v34 = "generic controls";
        __int128 v35 = 550;
      }

      else
      {
        __int128 v80 = convert_block_controls(v74, v80, *v74, (uint64_t)v13, v66, v67, v24, v25);
        if (v80)
        {
          LODWORD(v15) = v75;
          goto LABEL_8;
        }

        __int128 v34 = "convert_block_controls";
        __int128 v35 = 552;
      }
    }

    else
    {
LABEL_70:
      __int128 v34 = "aaByteStreamPReadExpected";
      __int128 v35 = 501;
    }

    __int128 v33 = 0;
    goto LABEL_72;
  }

  size_t v42 = v79.st_mode & 0xF000;
  if (v42 == 0x8000 || v42 == 0x4000)
  {
    v43.uint64_t ikey = 4803654;
    if (AAFieldKeySetContainsKey(a2, v43) >= 1)
    {
      FileAPFSInternalFlagsFD = getFileAPFSInternalFlagsFD();
      if (FileAPFSInternalFlagsFD)
      {
        v45.uint64_t ikey = 4803654;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v45, FileAPFSInternalFlagsFD) < 0)
        {
          __int128 v76 = v83;
          int v11 = "inserting FLI: %s";
          unint64_t v12 = 322;
          goto LABEL_7;
        }
      }
    }
  }

  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    v46.uint64_t ikey = 4411984;
    if (AAFieldKeySetContainsKey(a2, v46) >= 1)
    {
      __int128 v47 = getFileProtectionClass(v83) - 1;
      if (v47 <= 5)
      {
        v48.uint64_t ikey = 4411984;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v48, v47 + 65) < 0)
        {
          __int128 v76 = v83;
          int v11 = "inserting PRC: %s";
          unint64_t v12 = 342;
          goto LABEL_7;
        }
      }
    }
  }

  v49.uint64_t ikey = 5197385;
  if (AAFieldKeySetContainsKey(a2, v49))
  {
    v50.uint64_t ikey = 5197385;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v50, v79.st_ino) < 0)
    {
      __int128 v76 = v83;
      int v11 = "inserting INO: %s";
      unint64_t v12 = 359;
      goto LABEL_7;
    }
  }

  v51.uint64_t ikey = 4934734;
  if (AAFieldKeySetContainsKey(a2, v51))
  {
    v52.uint64_t ikey = 4934734;
    if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v52, v79.st_nlink) < 0)
    {
      __int128 v76 = v83;
      int v11 = "inserting LNK: %s";
      unint64_t v12 = 365;
      goto LABEL_7;
    }
  }

  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    v53.uint64_t ikey = 5917011;
    if (AAFieldKeySetContainsKey(a2, v53))
    {
      v54.uint64_t ikey = 5917011;
      if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v54, v79.st_size) < 0)
      {
        __int128 v76 = v83;
        int v11 = "inserting SIZ: %s";
        unint64_t v12 = 371;
        goto LABEL_7;
      }
    }
  }

  __int128 v55 = v79.st_mode & 0xF000;
  if (v55 == 0x4000 || v55 == 40960 || v55 == 0x8000)
  {
    v56.uint64_t ikey = 5920068;
    if (AAFieldKeySetContainsKey(a2, v56))
    {
      FilesystemBlockSize = getFilesystemBlockSize(a3);
      FileDiskUsageBlocks2 = getFileDiskUsageBlocks2(a3, a4, FilesystemBlockSize);
      if ((FileDiskUsageBlocks2 & 0x8000000000000000LL) == 0)
      {
        v59.uint64_t ikey = 5920068;
        if (AAHeaderSetFieldUInt(a1, 0xFFFFFFFF, v59, FileDiskUsageBlocks2) < 0)
        {
          __int128 v76 = v83;
          int v11 = "inserting DUZ: %s";
          unint64_t v12 = 381;
          goto LABEL_7;
        }
      }
    }
  }

  v60.uint64_t ikey = 5458755;
  char v61 = AAFieldKeySetContainsKey(a2, v60);
  v62.uint64_t ikey = 3229779;
  int v63 = AAFieldKeySetContainsKey(a2, v62);
  v64.uint64_t ikey = 3295315;
  __int128 v65 = AAFieldKeySetContainsKey(a2, v64);
  v66.uint64_t ikey = 3360851;
  __int128 v67 = AAFieldKeySetContainsKey(a2, v66);
  v68.uint64_t ikey = 3491923;
  __int128 v69 = AAFieldKeySetContainsKey(a2, v68);
  int result = 0LL;
  if ((v79.st_mode & 0xF000) == 0x8000)
  {
    __int128 v70 = ((v61 & 1) << 11) & 0xFFF | ((v63 & 1) << 12) & 0x1FFF | ((v65 & 1) << 13) & 0x3FFF | ((v67 & 1) << 14) & 0x7FFF | ((v69 & 1) << 15);
    if (v70)
    {
      if ((aaEntryHashesInitWithPath(value, v70, a3, a4) & 0x80000000) != 0)
      {
        __int128 v76 = v83;
        int v11 = "computing file hashes: %s";
        unint64_t v12 = 395;
      }

      else if ((v61 & 1) != 0 {
             && (v71.uint64_t ikey = 5458755, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v71, 1u, (const uint8_t *)&value[4]) < 0))
      }
      {
        __int128 v76 = v83;
        int v11 = "inserting CKS: %s";
        unint64_t v12 = 397;
      }

      else if ((v63 & 1) != 0 {
             && (v72.uint64_t ikey = 3229779, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v72, 2u, (const uint8_t *)&value[8]) < 0))
      }
      {
        __int128 v76 = v83;
        int v11 = "inserting SH1: %s";
        unint64_t v12 = 399;
      }

      else if ((v65 & 1) != 0 {
             && (v73.uint64_t ikey = 3295315, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v73, 3u, (const uint8_t *)&value[28]) < 0))
      }
      {
        __int128 v76 = v83;
        int v11 = "inserting SH2: %s";
        unint64_t v12 = 401;
      }

      else if ((v67 & 1) != 0 {
             && (v74.uint64_t ikey = 3360851, AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v74, 4u, (const uint8_t *)&v81 + 12) < 0))
      }
      {
        __int128 v76 = v83;
        int v11 = "inserting SH3: %s";
        unint64_t v12 = 403;
      }

      else
      {
        if ((v69 & 1) == 0) {
          return 0LL;
        }
        v75.uint64_t ikey = 3491923;
        if ((AAHeaderSetFieldHash(a1, 0xFFFFFFFF, v75, 5u, v82) & 0x80000000) == 0) {
          return 0LL;
        }
        __int128 v76 = v83;
        int v11 = "inserting SH5: %s";
        unint64_t v12 = 405;
      }

      goto LABEL_7;
    }
  }

  return result;
}

size_t PCompressLZFSEEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZFSE);
  if (!result) {
    return -1LL;
  }
  return result;
}

size_t PCompressLZFSEDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZFSE);
  if (!result) {
    return -1LL;
  }
  return result;
}

uint64_t *AAVerifyDirectoryArchiveOutputStreamOpen( const char *a1, AAFieldKeySet_impl *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  int DefaultNThreads = a6;
  if (!a6) {
    int DefaultNThreads = getDefaultNThreads();
  }
  unint64_t v12 = (uint64_t *)malloc(0x38uLL);
  int v13 = v12;
  if (v12) {
    memset_s(v12, 0x38uLL, 0, 0x38uLL);
  }
  uint64_t v14 = malloc(0x4B8uLL);
  uint64_t v15 = (uint64_t)v14;
  if (v14 && (memset_s(v14, 0x4B8uLL, 0, 0x4B8uLL), v13))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v15))
    {
      if (stat((const char *)v15, &v73) || (v73.st_mode & 0xF000) != 0x4000)
      {
        char v72 = (char)a1;
        int v44 = "Invalid directory: %s";
        __int16 v45 = 450;
        goto LABEL_64;
      }

      *(void *)(v15 + 1024) = a5;
      *(void *)(v15 + 1032) = a3;
      *(void *)(v15 + 1040) = a4;
      *(_DWORD *)(v15 + 1064) = DefaultNThreads;
      *(_DWORD *)(v15 + 1048) = a5 >> 62;
      *(void *)(v15 + 1088) = 0xFFFFFFFFLL;
      if (a2)
      {
        v18.uint64_t ikey = 4475221;
        if (AAFieldKeySetContainsKey(a2, v18)) {
          *(_DWORD *)(v15 + 1088) &= ~1u;
        }
        v19.uint64_t ikey = 4475207;
        if (AAFieldKeySetContainsKey(a2, v19)) {
          *(_DWORD *)(v15 + 1088) &= ~2u;
        }
        v20.uint64_t ikey = 4672582;
        if (AAFieldKeySetContainsKey(a2, v20)) {
          *(_DWORD *)(v15 + 1088) &= ~4u;
        }
        v21.uint64_t ikey = 4476749;
        if (AAFieldKeySetContainsKey(a2, v21)) {
          *(_DWORD *)(v15 + 1088) &= ~8u;
        }
        v22.uint64_t ikey = 5067842;
        if (AAFieldKeySetContainsKey(a2, v22)) {
          *(_DWORD *)(v15 + 1088) &= ~0x10u;
        }
        v23.uint64_t ikey = 5067843;
        if (AAFieldKeySetContainsKey(a2, v23)) {
          *(_DWORD *)(v15 + 1088) &= ~0x20u;
        }
        v24.uint64_t ikey = 5067853;
        if (AAFieldKeySetContainsKey(a2, v24)) {
          *(_DWORD *)(v15 + 1088) &= ~0x40u;
        }
        v25.uint64_t ikey = 5523009;
        if (AAFieldKeySetContainsKey(a2, v25)) {
          *(_DWORD *)(v15 + 1088) &= ~0x80u;
        }
        v26.uint64_t ikey = 5391937;
        if (AAFieldKeySetContainsKey(a2, v26)) {
          *(_DWORD *)(v15 + 1088) &= ~0x100u;
        }
        v27.uint64_t ikey = 4803654;
        if (AAFieldKeySetContainsKey(a2, v27)) {
          *(_DWORD *)(v15 + 1088) &= ~0x200u;
        }
        v28.uint64_t ikey = 4411984;
        if (AAFieldKeySetContainsKey(a2, v28)) {
          *(_DWORD *)(v15 + 1088) &= ~0x400u;
        }
        v29.uint64_t ikey = 5458755;
        if (AAFieldKeySetContainsKey(a2, v29)) {
          *(_DWORD *)(v15 + 1088) &= ~0x800u;
        }
        v30.uint64_t ikey = 3229779;
        if (AAFieldKeySetContainsKey(a2, v30)) {
          *(_DWORD *)(v15 + 1088) &= ~0x1000u;
        }
        v31.uint64_t ikey = 3295315;
        if (AAFieldKeySetContainsKey(a2, v31)) {
          *(_DWORD *)(v15 + 1088) &= ~0x2000u;
        }
        v32.uint64_t ikey = 3360851;
        if (AAFieldKeySetContainsKey(a2, v32)) {
          *(_DWORD *)(v15 + 1088) &= ~0x4000u;
        }
        v33.uint64_t ikey = 3491923;
        if (AAFieldKeySetContainsKey(a2, v33)) {
          *(_DWORD *)(v15 + 1088) &= ~0x8000u;
        }
        v34.uint64_t ikey = 5521732;
        if (AAFieldKeySetContainsKey(a2, v34)) {
          *(_DWORD *)(v15 + 1088) &= ~0x80000u;
        }
        v35.uint64_t ikey = 4408665;
        if (AAFieldKeySetContainsKey(a2, v35)) {
          *(_DWORD *)(v15 + 1088) &= ~0x10000u;
        }
        v36.uint64_t ikey = 5521752;
        if (AAFieldKeySetContainsKey(a2, v36)) {
          *(_DWORD *)(v15 + 1088) &= ~0x20000u;
        }
        v37.uint64_t ikey = 4997953;
        if (AAFieldKeySetContainsKey(a2, v37)) {
          *(_DWORD *)(v15 + 1088) &= ~0x40000u;
        }
      }

      if ((a5 & 0x80000000000000LL) == 0)
      {
        if (a5 >> 62) {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "Scanning target directory: %s\n", a1);
        }
        __int128 v38 = AAPathListCreateWithDirectoryContents( a1,  0LL,  *(void **)(v15 + 1032),  *(AAEntryMessageProc *)(v15 + 1040),  0LL,  DefaultNThreads);
        *(void *)(v15 + 1056) = v38;
        if (!v38)
        {
          char v72 = (char)a1;
          int v44 = "Scanning target directory failed: %s";
          __int16 v45 = 488;
          goto LABEL_64;
        }

        uint64_t v39 = AAPathListNodeFirst(v38);
        if (v39 == -1LL)
        {
          *(void *)(v15 + 1120) = 64LL;
          size_t v42 = 8LL;
        }

        else
        {
          uint64_t v40 = v39;
          uint64_t v41 = 0LL;
          do
          {
            ++*(void *)(v15 + 1152);
            if (v40 > v41) {
              uint64_t v41 = v40;
            }
            uint64_t v40 = AAPathListNodeNext(*(AAPathList *)(v15 + 1056), v40);
          }

          while (v40 != -1LL);
          *(void *)(v15 + 1120) = (v41 + 64) & 0xFFFFFFFFFFFFFFC0LL;
          size_t v42 = ((v41 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8LL;
          if (v42 >= 0x2000000001LL)
          {
            *__error() = 12;
LABEL_87:
            *(void *)(v15 + 1128) = 0LL;
            int v43 = *__error();
            int v44 = "malloc";
            __int16 v45 = 499;
            goto LABEL_65;
          }
        }

        __int128 v54 = malloc(v42);
        if (!v54) {
          goto LABEL_87;
        }
        __int128 v55 = v54;
        memset_s(v54, v42, 0, v42);
        *(void *)(v15 + 1128) = v55;
      }

      __int128 v56 = calloc(*(unsigned int *)(v15 + 1064), 8uLL);
      *(void *)(v15 + 1072) = v56;
      if (v56)
      {
        if (*(_DWORD *)(v15 + 1064))
        {
          unint64_t v57 = 0LL;
          while (1)
          {
            __int128 v58 = (uint64_t *)malloc(0x5A8uLL);
            __int128 v59 = v58;
            if (!v58)
            {
              char v61 = __error();
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"workerDataAlloc",  80,  119,  *v61,  "malloc",  v62,  v63,  v72);
              goto LABEL_83;
            }

            memset_s(v58, 0x5A8uLL, 0, 0x5A8uLL);
            *__int128 v59 = v15;
            unint64_t v60 = *(void *)(v15 + 1120);
            if (!v60) {
              goto LABEL_83;
            }
            if (v60 < 0x10000000008LL)
            {
              rsize_t v64 = v60 >> 3;
              __int128 v65 = malloc(v60 >> 3);
              if (v65)
              {
                uint64_t v66 = (uint64_t)v65;
                memset_s(v65, v64, 0, v64);
                v59[180] = v66;
                goto LABEL_83;
              }
            }

            else
            {
              *__error() = 12;
            }

            v59[180] = 0LL;
            __int128 v67 = __error();
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"workerDataAlloc",  85,  119,  *v67,  "malloc",  v68,  v69,  v72);
            workerDataFree((void **)v59);
            __int128 v59 = 0LL;
LABEL_83:
            *(void *)(*(void *)(v15 + 1072) + 8 * v57) = v59;
            uint64_t v70 = *(void *)(v15 + 1072);
            if (!*(void *)(v70 + 8 * v57))
            {
              int v44 = "allocation";
              __int16 v45 = 508;
              goto LABEL_64;
            }

            ++v57;
            __int128 v56 = (void *)*(unsigned int *)(v15 + 1064);
          }
        }

        uint64_t v70 = (uint64_t)v56;
        LODWORD(v56) = 0;
LABEL_89:
        __int128 v71 = ThreadPoolCreate(v56, v70, (uint64_t)workerProc_0);
        *(void *)(v15 + 1080) = v71;
        if (v71)
        {
          v13[3] = (uint64_t)verifyDirectoryStreamWriteHeader;
          v13[4] = (uint64_t)verifyDirectoryStreamWriteBlob;
          *int v13 = v15;
          v13[1] = (uint64_t)verifyDirectoryStreamClose;
          v13[2] = (uint64_t)verifyDirectoryStreamCancel;
          return v13;
        }

        int v44 = "ThreadPoolCreate";
        __int16 v45 = 511;
LABEL_64:
        int v43 = 0;
      }

      else
      {
        int v43 = *__error();
        int v44 = "malloc";
        __int16 v45 = 504;
      }
    }

    else
    {
      int v43 = *__error();
      char v72 = (char)a1;
      int v44 = "%s";
      __int16 v45 = 449;
    }
  }

  else
  {
    int v43 = *__error();
    int v44 = "malloc";
    __int16 v45 = 448;
  }

LABEL_65:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"AAVerifyDirectoryArchiveOutputStreamOpen",  v45,  119,  v43,  v44,  v16,  v17,  v72);
  free(v13);
  verifyDirectoryStreamClose(v15, v46, v47, v48, v49, v50, v51, v52);
  return 0LL;
}

        if ((v15[3] & 2) != 0)
        {
          v46 += 2LL;
          if (v46 > DataSize)
          {
            AAFieldKey v19 = "parsing gzip header";
            AAFieldKey v20 = 551;
            goto LABEL_26;
          }
        }

        MemBufferDecreaseSize(*(void *)(v9 + 56), v46, v29, v30, v31, v32, v12, v13);
        if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
        {
          AAFieldKey v19 = "compression_stream_init";
          AAFieldKey v20 = 557;
          goto LABEL_26;
        }

        int v44 = 2;
        goto LABEL_54;
      }

      AAFieldKey v19 = "Could not identify compressed stream format";
      AAFieldKey v20 = 579;
      goto LABEL_26;
    }
  }

  else
  {
    AAFieldKey v21 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamCreate",  452,  39,  *v21,  "malloc",  v22,  v23,  v47);
  }

  return v9;
}

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkWriteData",  163,  59,  0,  "Invalid data write, no matching hole",  v20,  v21,  v97);
          a2 = __src;
        }

        __int128 v58 = 313;
        __int128 v59 = "Hole fill";
        goto LABEL_67;
      }

      AAFieldKey v27 = *(void *)(a1 + 8);
      if (v26)
      {
        AAFieldKey v28 = *(void *)(*(void *)(a1 + 256) + 8 * v26 - 8);
        AAFieldKey v29 = *(void *)(v28 + 16);
        if (v27 > v29)
        {
          if ((chunkAppendHole(v28, v27 - v29, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            __int128 v56 = 284;
            unint64_t v57 = "Hole creation";
            goto LABEL_51;
          }

          AAFieldKey v27 = *(void *)(a1 + 8);
        }
      }

      AAFieldKey v32 = (void **)malloc(0x38uLL);
      AAFieldKey v33 = v32;
      if (!v32)
      {
        uint64_t v52 = 89;
        goto LABEL_50;
      }

      memset_s(v32, 0x38uLL, 0, 0x38uLL);
      if (v27 >= 0x2000000001LL) {
        break;
      }
      AAFieldKey v34 = malloc(v27);
      if (!v34) {
        goto LABEL_49;
      }
      AAFieldKey v35 = v34;
      memset_s(v34, v27, 0, v27);
      *AAFieldKey v33 = v35;
      v33[1] = (void *)v27;
      v33[2] = 0LL;
      AAFieldKey v37 = *(void *)(a1 + 248);
      AAFieldKey v36 = *(void *)(a1 + 256);
      AAFieldKey v26 = v37 + 1;
      *(void *)(a1 + 248) = v37 + 1;
      *(void *)(v36 + 8 * v37) = v33;
    }

    *__error() = 12;
LABEL_49:
    *AAFieldKey v33 = 0LL;
    uint64_t v52 = 91;
LABEL_50:
    __int128 v53 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkCreate",  v52,  59,  *v53,  "malloc",  v54,  v55,  v97);
    chunkDestroy(v33);
    __int128 v56 = 289;
    unint64_t v57 = "Chunk creation";
LABEL_51:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamWriteChunkData",  v56,  59,  0,  v57,  v30,  v31,  v97);
    uint64_t v47 = 0;
    a2 = __src;
    int v43 = v15 - v14;
LABEL_68:
    if (pthread_mutex_unlock(v105) < 0)
    {
      __int128 v88 = *__error();
      __int128 v91 = "pthread_mutex_unlock";
      __int128 v92 = 316;
LABEL_103:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamWriteChunkData",  v92,  59,  v88,  v91,  v89,  v90,  v97);
LABEL_104:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamPWrite",  393,  59,  0,  "Writing chunk data failed",  v69,  v70,  v97);
      while (!__ldaxr(v98))
      {
        if (!__stlxr(1u, v98))
        {
          AAByteStreamCancel(*(AAByteStream *)a1);
          return -1LL;
        }
      }

      __clrex();
      return -1LL;
    }

    if ((v47 & 1) == 0) {
      goto LABEL_104;
    }
    if (v12 < v11) {
      int v11 = v7 / v101;
    }
    v7 += v43;
    a2 += v43;
    uint64_t v9 = v100;
  }

  while (v7 < v100);
LABEL_86:
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) < 0)
  {
    int v83 = *__error();
    uint64_t v86 = "pthread_mutex_lock";
    __int128 v87 = 239;
LABEL_99:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamCheckAndWriteChunksToStream",  v87,  59,  v83,  v86,  v84,  v85,  v97);
LABEL_100:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamPWrite",  404,  59,  0,  "flushing chunks to stream",  v95,  v96,  v97);
    return -1LL;
  }

  __int128 v74 = v11 + 1;
  if (v11 + 1 < *(void *)(a1 + 248))
  {
    while (1)
    {
      __int128 v75 = v11;
      int v11 = v74;
      __int128 v76 = *(void *)(*(void *)(a1 + 256) + 8 * v75);
      if (!*(void *)(v76 + 40)) {
        break;
      }
LABEL_95:
      __int128 v74 = v11 + 1;
      if (v11 + 1 >= *(void *)(a1 + 248)) {
        goto LABEL_96;
      }
    }

    __int128 v77 = *(void *)(a1 + 8) * v75;
    __int128 v78 = (unsigned int *)(v76 + 48);
    do
    {
      if (__ldaxr(v78))
      {
        __clrex();
        goto LABEL_95;
      }
    }

    while (__stlxr(1u, v78));
    if ((streamEnqueueWriteChunkToStream(a1, v76, v77) & 0x80000000) == 0) {
      goto LABEL_95;
    }
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamCheckAndWriteChunksToStream",  249,  59,  0,  "enqueue chunk write",  v80,  v81,  v97);
    __int128 v94 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
    if (v94 < 0)
    {
LABEL_97:
      int v83 = *__error();
      uint64_t v86 = "pthread_mutex_unlock";
      __int128 v87 = 254;
      goto LABEL_99;
    }

    goto LABEL_100;
  }

  AAFieldKey v32 = value;
LABEL_66:
  if (v32 == 76)
  {
    v57.uint64_t ikey = 4935244;
    __int128 v58 = AAHeaderGetKeyIndex(header, v57);
    if ((v58 & 0x80000000) != 0
      || ((__int128 v59 = AAHeaderGetFieldString(header, v58, 0x400uLL, (char *)size, 0LL), v59 <= 1) ? (v60 = 1) : (v60 = v59),
          v60 <= 0))
    {
      uint64_t v16 = "no LNK";
      uint64_t v17 = 283;
      goto LABEL_9;
    }
  }

  char v61 = *(void *)(v4 + 64);
  if (*(void *)(v4 + 72) >= v61)
  {
    uint64_t v62 = 2 * v61;
    uint64_t v63 = v61 == 0;
    rsize_t v64 = 32LL;
    if (!v63) {
      rsize_t v64 = v62;
    }
    *(void *)(v4 + 64) = v64;
    if ((unint64_t)(984 * v64) >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_103:
      *(void *)(v4 + 80) = 0LL;
      AAFieldKey v18 = *__error();
      uint64_t v16 = "malloc";
      uint64_t v17 = 291;
      goto LABEL_10;
    }

    __int128 v65 = *(void **)(v4 + 80);
    uint64_t v66 = realloc(v65, 984 * v64);
    if (!v66)
    {
      free(v65);
      goto LABEL_103;
    }

    *(void *)(v4 + 80) = v66;
  }

  LODWORD(offset) = -1;
  __int128 v67 = strlen(__s);
  if ((StringTableAppend(*(unsigned int **)(v4 + 32), __s, v67, &offset, v68, v69, v70, v71) & 0x80000000) != 0)
  {
    uint64_t v16 = "string table append";
    uint64_t v17 = 294;
    goto LABEL_9;
  }

  stat v73 = *(void *)(v4 + 72);
  char v72 = *(void *)(v4 + 80);
  *(void *)(v4 + 72) = v73 + 1;
  if (v72) {
    memset_s((void *)(v72 + 984 * v73), 0x3D8uLL, 0, 0x3D8uLL);
  }
  *(_DWORD *)(v72 + 984 * v73) = offset;
  __int128 v74 = v72 + 984 * v73;
  *(void *)(v74 + 128) = -1LL;
  __int128 v75 = (uint64_t *)(v74 + 128);
  __int128 v76 = a1[1];
  __int128 v77 = v72 + 984 * v73 + 72 * v76;
  *(_DWORD *)(v77 + 264) = value;
  *(void *)(v77 + 280) = v131;
  *(void *)(v77 + 288) = v129;
  *(void *)(v77 + 296) = v128;
  if (hash_function)
  {
    __int128 v78 = v134;
    int v79 = v72 + 984 * v73 + 72 * v76;
    *(_OWORD *)(v79 + 304) = *(_OWORD *)v133;
    *(_OWORD *)(v79 + 320) = v78;
  }

  if (v7 != v31) {
    return 0LL;
  }
  __int128 v80 = *v6;
  if (*v6)
  {
    if ((v80 & 0x8000000000000000LL) != 0)
    {
LABEL_152:
      uint64_t v16 = "YEC blob";
      uint64_t v17 = 314;
      goto LABEL_9;
    }

    int v81 = (void *)(v72 + 984 * v73 + 32);
    int v82 = v72 + 984 * v73;
    int v85 = *(void *)(v82 + 40);
    int v84 = (size_t *)(v82 + 40);
    int v83 = v85;
    if (v85 < v80)
    {
      do
      {
        while (!v83)
        {
          int v83 = 0x4000LL;
          if (v80 <= 0x4000)
          {
            __int128 v87 = (void **)(v72 + 984 * v73 + 48);
            int v83 = 0x4000LL;
            goto LABEL_106;
          }
        }

        uint64_t v86 = v83 >> 1;
        if ((v83 & (v83 >> 1)) != 0) {
          uint64_t v86 = v83 & (v83 >> 1);
        }
        v83 += v86;
      }

      while (v83 < v80);
      __int128 v87 = (void **)(v72 + 984 * v73 + 48);
      if (v83 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_151;
      }

uint64_t workerProc_0(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (char *)(a1 + 12);
  uint64_t v2 = *(void *)a1;
  uint64_t v52 = 0LL;
  uint64_t v51 = 0LL;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v48 = 0u;
  if ((concatPath(v54, 0x800uLL, (char *)v2, (const char *)(a1 + 12)) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"workerProc",  153,  119,  0,  "invalid path: %s",  v4,  v5,  (char)v3);
LABEL_23:
    uint64_t v16 = 0LL;
    goto LABEL_24;
  }

  uint64_t v6 = *(void *)(v2 + 1056);
  if (!v6)
  {
    if ((lstat(v54, &v53) & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_19:
    uint64_t v19 = v2;
    uint64_t v20 = 71LL;
    goto LABEL_28;
  }

  unint64_t Node = AAPathListGetNode(v6, v3);
  if (Node == -1LL) {
    goto LABEL_19;
  }
  if (Node >= *(void *)(v2 + 1120))
  {
    AAFieldKey v21 = "invalid node index";
    __int16 v22 = 166;
LABEL_22:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"workerProc",  v22,  119,  0,  v21,  v8,  v9,  v46);
    goto LABEL_23;
  }

  *(void *)(*(void *)(a1 + 1440) + ((Node >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << Node;
LABEL_8:
  uint64_t v10 = *(void *)(a1 + 1392);
  if (v10)
  {
    LOBYTE(v48) = v48 | 1;
    *((void *)&v48 + 1) = *(void *)(a1 + 1408);
    *(void *)&__int128 v49 = v10;
  }

  uint64_t v11 = *(void *)(a1 + 1344);
  if (v11)
  {
    LOBYTE(v48) = v48 | 2;
    *((void *)&v49 + 1) = *(void *)(a1 + 1360);
    *(void *)&__int128 v50 = v11;
  }

  uint64_t v12 = *(void *)(a1 + 1368);
  if (v12)
  {
    LOBYTE(v48) = v48 | 4;
    *((void *)&v50 + 1) = *(void *)(a1 + 1384);
    uint64_t v51 = v12;
  }

  if ((aaCheckAndFixWithPath( (char *)(a1 + 1040),  (unsigned __int8 *)(a1 + 1112),  (unsigned __int8 *)(a1 + 1168),  (unsigned __int8 *)&v48,  *(void *)(v2 + 1088),  (unsigned int *)&v52,  (char *)v2,  v3,  *(void *)(v2 + 1024)) & 0x80000000) != 0)
  {
    char v46 = (char)v3;
    AAFieldKey v21 = "CheckAndFix: %s";
    __int16 v22 = 190;
    goto LABEL_22;
  }

  if (!v52)
  {
    uint64_t v19 = v2;
    uint64_t v20 = 73LL;
LABEL_28:
    uint64_t v16 = 0LL;
LABEL_29:
    uint64_t v25 = 0LL;
    goto LABEL_30;
  }

  int v13 = AAFieldKeySetCreate();
  uint64_t v16 = v13;
  if (!v13)
  {
    AAFieldKey v27 = "AAFieldKeySetCreate";
    __int16 v28 = 200;
LABEL_99:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"workerProc",  v28,  119,  0,  v27,  v14,  v15,  v47);
LABEL_24:
    AAFieldKey v23 = (unint64_t *)(v2 + 1160);
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    goto LABEL_29;
  }

  int v17 = v52;
  if ((v52 & 1) != 0)
  {
    v29.uint64_t ikey = 4475221;
    BOOL v18 = AAFieldKeySetInsertKey(v13, v29) >= 0;
    int v17 = v52;
  }

  else
  {
    BOOL v18 = 1;
  }

  if ((v17 & 2) != 0)
  {
    v30.uint64_t ikey = 4475207;
    if (AAFieldKeySetInsertKey(v16, v30) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
  }

  if ((v17 & 8) != 0)
  {
    v31.uint64_t ikey = 4476749;
    if (AAFieldKeySetInsertKey(v16, v31) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
  }

  if ((v17 & 4) != 0)
  {
    v32.uint64_t ikey = 4672582;
    if (AAFieldKeySetInsertKey(v16, v32) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
  }

  if ((v17 & 0x40) != 0)
  {
    v35.uint64_t ikey = 5067853;
    if (AAFieldKeySetInsertKey(v16, v35) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
    if ((v52 & 0x10) == 0)
    {
LABEL_47:
      if ((v17 & 0x20) == 0) {
        goto LABEL_51;
      }
      goto LABEL_48;
    }
  }

  else if ((v17 & 0x10) == 0)
  {
    goto LABEL_47;
  }

  v36.uint64_t ikey = 5067842;
  if (AAFieldKeySetInsertKey(v16, v36) < 0) {
    BOOL v18 = 0;
  }
  int v17 = v52;
  if ((v52 & 0x20) != 0)
  {
LABEL_48:
    v33.uint64_t ikey = 5067843;
    if (AAFieldKeySetInsertKey(v16, v33) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
  }

LABEL_51:
  if ((v17 & 0x80) != 0)
  {
    v37.uint64_t ikey = 5523009;
    if (AAFieldKeySetInsertKey(v16, v37) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
    if ((v52 & 0x100) == 0)
    {
LABEL_53:
      if ((v17 & 0x200) == 0) {
        goto LABEL_57;
      }
      goto LABEL_54;
    }
  }

  else if ((v17 & 0x100) == 0)
  {
    goto LABEL_53;
  }

  v38.uint64_t ikey = 5391937;
  if (AAFieldKeySetInsertKey(v16, v38) < 0) {
    BOOL v18 = 0;
  }
  int v17 = v52;
  if ((v52 & 0x200) != 0)
  {
LABEL_54:
    v34.uint64_t ikey = 4803654;
    if (AAFieldKeySetInsertKey(v16, v34) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
  }

        const char *v22 = v19;
        break;
    }

    goto LABEL_52;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"parseProfile",  508,  92,  0,  "Invalid profile value: %s",  v20,  v21,  v10 + v12 + 1);
LABEL_56:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"getProfile",  560,  92,  0,  "parsing profile: %s",  v23,  v24,  v10);
  return 0xFFFFFFFFLL;
}

            AAFieldKey v37 = a1[9];
            AAFieldKey v38 = realloc(v37, v24);
            if (!v38)
            {
              free(v37);
              goto LABEL_118;
            }

            a1[8] = (void *)v24;
            a1[9] = v38;
          }

          AAFieldKey v39 = a1[9];
          if (__src)
          {
            memcpy((char *)v39 + *v15, __src, v20);
          }

          else if (v39)
          {
            memset_s((char *)v39 + *v15, v20, 0, v20);
          }

          uint64_t v14 = *v15 + v20;
          *uint64_t v15 = v14;
          if ((v20 & 0x8000000000000000LL) != 0) {
            goto LABEL_119;
          }
          a3 -= v20;
          __src += v20;
          v10 += v20;
          a1[13] = (void *)((char *)a1[13] + v20);
        }
      }

      if (v17 == 1) {
        break;
      }
      if (v17)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c",  (uint64_t)"writeProc",  199,  132,  0,  "invalid state %d",  a7,  a8,  *((_DWORD *)a1 + 6));
        goto LABEL_127;
      }

      if (!(a3 | v14)) {
        goto LABEL_106;
      }
      if (v14 <= 0xB)
      {
        __int128 v56 = 12LL;
        goto LABEL_105;
      }

      uint64_t v25 = a1[9];
      *(void *)uint64_t v63 = *(void *)v25;
      *(_DWORD *)&v63[8] = v25[2];
      if ((unsigned __int16)*(void *)v25 != 25200 || BYTE2(*(void *)v25) != 122)
      {
LABEL_111:
        unint64_t v57 = "invalid compressed stream";
        __int128 v58 = 106;
        goto LABEL_126;
      }

      if (v63[3] <= 100)
      {
        switch(v63[3])
        {
          case '-':
            AAFieldKey v27 = 0;
            __int16 v28 = 0LL;
            break;
          case '4':
            AAFieldKey v27 = 256;
            __int16 v28 = PCompressLZ4Decode;
            break;
          case 'b':
            AAFieldKey v27 = 1794;
            __int16 v28 = PCompressLZBITMAPDecode;
            break;
          default:
            goto LABEL_111;
        }
      }

      else if (v63[3] > 119)
      {
        if (v63[3] == 120)
        {
          AAFieldKey v27 = 774;
          __int16 v28 = PCompressLZMADecode;
        }

        else
        {
          if (v63[3] != 122) {
            goto LABEL_111;
          }
          AAFieldKey v27 = 1285;
          __int16 v28 = PCompressZLIBDecode;
        }
      }

      else if (v63[3] == 101)
      {
        AAFieldKey v27 = 2049;
        __int16 v28 = PCompressLZFSEDecode;
      }

      else
      {
        if (v63[3] != 102) {
          goto LABEL_111;
        }
        AAFieldKey v27 = 2304;
        __int16 v28 = PCompressLZVNDecode;
      }

      *((_DWORD *)a1 + 7) = v27;
      char v46 = bswap64(*(unint64_t *)&v63[4]);
      a1[4] = (void *)v46;
      a1[2] = v28;
      if ((v46 & 0x8000000000000000LL) != 0) {
        goto LABEL_125;
      }
      char v47 = (unint64_t)a1[8];
      if (v47 < v46)
      {
        do
        {
          while (!v47)
          {
            char v47 = 0x4000LL;
            __int128 v49 = 0x4000LL;
            if (v46 <= 0x4000) {
              goto LABEL_89;
            }
          }

          __int128 v48 = v47 >> 1;
          if ((v47 & (v47 >> 1)) != 0) {
            __int128 v48 = v47 & (v47 >> 1);
          }
          v47 += v48;
        }

        while (v47 < v46);
        __int128 v49 = v47;
        if (v47 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_124;
        }

    size_t result = 0LL;
    *(void *)a1 = a2;
    return result;
  }

  uint64_t v16 = AATempFileStreamOpenWithDirectory(*(const char **)(a1 + 104));
  *(void *)(a1 + 112) = v16;
  if (!v16)
  {
    AAFieldKey v40 = "AATempFileStreamOpen";
    AAFieldKey v41 = 36;
LABEL_57:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"offloadToFile",  v41,  50,  0,  v40,  v17,  v18,  v42);
    uint64_t v8 = "offload to file";
    uint64_t v9 = 76;
    goto LABEL_3;
  }

  uint64_t v19 = (void *)(a1 + 24);
  if (*(void *)(a1 + 24))
  {
    uint64_t v20 = 0LL;
    AAFieldKey v21 = 0LL;
    while (*(void *)a1 > v21)
    {
      if (*(void *)(a1 + 8) >= *(void *)a1 - v21) {
        __int16 v22 = *(void *)a1 - v21;
      }
      else {
        __int16 v22 = *(void *)(a1 + 8);
      }
      AAFieldKey v23 = *(void *)(a1 + 112);
      if (*(void *)(v23 + 24))
      {
        unint64_t v24 = 0LL;
        if (v22)
        {
          uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8 * v20);
          AAFieldKey v26 = v22;
          while (1)
          {
            AAFieldKey v27 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v23 + 24))(*(void *)v23, v25, v26);
            if (v27 < 1) {
              break;
            }
            v25 += v27;
            v24 += v27;
            v26 -= v27;
            if (!v26) {
              goto LABEL_26;
            }
          }

          unint64_t v24 = v27;
        }
      }

      else
      {
        unint64_t v24 = -1LL;
      }

      unint64_t v24 = 0;
    }
  }

  if (!v24)
  {
LABEL_53:
    if (!mbr_uuid_to_sid(v23, &sid) && !mbr_sid_to_string(&sid, (char *)v11) && strlen((const char *)v11) <= 0xFF)
    {
      ace.qualifier_type = 83;
      __strlcpy_chk();
      goto LABEL_58;
    }

  AAFieldKey v31 = v11[2];
  if (__src)
  {
    memcpy((void *)(v31 + *v11), __src, __smax);
  }

  else if (v31)
  {
    memset_s((void *)(v31 + *v11), __smax, 0, __smax);
  }

  *v11 += __smax;
  if ((__smax & 0x8000000000000000LL) != 0)
  {
LABEL_69:
    BOOL v18 = "blob append";
    uint64_t v19 = 345;
    goto LABEL_86;
  }

  a1[2] -= __smax;
LABEL_5:
  uint64_t v14 = (void *)a1[5];
  if (v14) {
    uint64_t v15 = v12 == 5521752;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15)
  {
    if (a1[4] >= __smax)
    {
      AAFieldKey v23 = *v14 + __smax;
      if (!__CFADD__(*v14, __smax) && (v23 & 0x8000000000000000LL) == 0)
      {
        unint64_t v24 = v14[1];
        if (v24 >= v23)
        {
LABEL_61:
          AAFieldKey v34 = v14[2];
          if (__src)
          {
            memcpy((void *)(v34 + *v14), __src, __smax);
          }

          else if (v34)
          {
            memset_s((void *)(v34 + *v14), __smax, 0, __smax);
          }

          *v14 += __smax;
          if ((__smax & 0x8000000000000000LL) == 0)
          {
            a1[4] -= __smax;
            goto LABEL_9;
          }
        }

        else
        {
          do
          {
            while (!v24)
            {
              unint64_t v24 = 0x4000LL;
              if (v23 <= 0x4000)
              {
                unint64_t v24 = 0x4000LL;
                goto LABEL_59;
              }
            }

            uint64_t v25 = v24 >> 1;
            if ((v24 & (v24 >> 1)) != 0) {
              uint64_t v25 = v24 & (v24 >> 1);
            }
            v24 += v25;
          }

          while (v24 < v23);
          if (v24 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_81;
          }

  if (pthread_mutex_unlock((pthread_mutex_t *)v9) < 0)
  {
    AAFieldKey v31 = *__error();
    AAFieldKey v34 = "mutex unlock";
    AAFieldKey v35 = 108;
    goto LABEL_53;
  }

  return v8;
}

LABEL_57:
  if ((v17 & 0x400) != 0)
  {
    v39.uint64_t ikey = 4411984;
    if (AAFieldKeySetInsertKey(v16, v39) < 0) {
      BOOL v18 = 0;
    }
    int v17 = v52;
    if ((v52 & 0x80000) == 0)
    {
LABEL_59:
      if ((v17 & 0x10000) == 0) {
        goto LABEL_60;
      }
      goto LABEL_83;
    }
  }

  else if ((v17 & 0x80000) == 0)
  {
    goto LABEL_59;
  }

  v40.uint64_t ikey = 5521732;
  if (AAFieldKeySetInsertKey(v16, v40) < 0) {
    BOOL v18 = 0;
  }
  int v17 = v52;
  if ((v52 & 0x10000) == 0)
  {
LABEL_60:
    if ((v17 & 0x20000) == 0) {
      goto LABEL_61;
    }
LABEL_86:
    v42.uint64_t ikey = 5521752;
    if (AAFieldKeySetInsertKey(v16, v42) < 0) {
      BOOL v18 = 0;
    }
    if ((v52 & 0x40000) == 0) {
      goto LABEL_90;
    }
    goto LABEL_89;
  }

            uint64_t v25 = "derivating cluster key";
            AAFieldKey v26 = 90;
            goto LABEL_58;
          }
        }

        else
        {
          memset_s(v49, 0x104uLL, 0, 0x104uLL);
        }

        memset_s(v47, 0x104uLL, 0, 0x104uLL);
        goto LABEL_57;
      }
    }

    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }

    unint64_t v24 = 1;
    goto LABEL_28;
  }

        v57 += v62;
        ++v58;
        __int16 v45 = *v170;
      }

      while (v58 < *v170);
      uint64_t v55 = *v170;
LABEL_59:
      ++v54;
    }

    while (v54 != 3);
    uint64_t v68 = *(_DWORD *)(v169 + 28);
    if (v153 >= 3)
    {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ForceInPlace %d: excess_pages=%d/%d, converted bytes=%llu, %zu controls\n",  v151,  v68,  *(_DWORD *)(v169 + 32),  v154,  v45);
      uint64_t v68 = *(_DWORD *)(v169 + 28);
    }

    uint64_t v69 = *(_DWORD *)(v169 + 32);
    uint64_t v70 = __OFSUB__(v68, v69);
    __int128 v71 = v68 - v69;
    if (!((v71 < 0) ^ v70 | (v71 == 0)))
    {
      char v72 = v71 + 1;
      stat v73 = (uint64_t)(v72 >> 1) << 14;
      if (v72 < 2)
      {
        __int128 v74 = 0;
        a2 = v170;
        a1 = v171;
        __int128 v75 = v154;
        goto LABEL_112;
      }

      uint64_t v149 = 0LL;
      AAFieldKey v146 = -1LL;
      __int128 v76 = 1LL;
      a2 = v170;
      a1 = v171;
      __int128 v75 = v154;
      __int128 v77 = v152;
      while (2)
      {
        __int128 v78 = *(void *)(a4 + 2080);
        int v79 = *a2;
        if (*a2)
        {
          __int128 v74 = 0;
          AAFieldKey v147 = v76 - 1;
          size_t v148 = v76;
          __int128 v80 = 24 * v79;
          while (1)
          {
            int v81 = *a1 + v80;
            int v82 = (int8x16_t *)(v81 - 24);
            int v83 = *(int64x2_t *)(v81 - 24);
            int v84 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v83), (int8x16_t)vsubq_s64(v77, v83), (int8x16_t)v83);
            int v85 = *(void *)(v81 - 8);
            uint64_t v86 = 0x8000000000000000LL - v85;
            if (v85 >= 0) {
              uint64_t v86 = *(void *)(v81 - 8);
            }
            v78 -= vaddvq_s64(v84);
            if (!v73) {
              goto LABEL_94;
            }
            __int128 v87 = v84.i64[0];
            if (!v84.i64[0]) {
              goto LABEL_94;
            }
            if ((_DWORD)v76 == 1) {
              break;
            }
            if ((_DWORD)v76 != 2)
            {
              if ((_DWORD)v76 != 3) {
                goto LABEL_94;
              }
              __int128 v88 = *(void *)(a4 + 2056);
              goto LABEL_78;
            }

            if (v78 >= *(void *)(a4 + 2072))
            {
              if (v84.i64[0] > v73)
              {
                __int128 v89 = v146;
                __int128 v90 = v149;
                if (v146 > v84.i64[0]) {
                  __int128 v90 = v81 - 24;
                }
                uint64_t v149 = v90;
                if (v146 >= v84.i64[0]) {
                  __int128 v89 = v84.i64[0];
                }
                AAFieldKey v146 = v89;
                goto LABEL_94;
              }

              goto LABEL_89;
            }

      AAFieldKey v35 = v13 - v15;
      if (v13 - v15 > (unint64_t)a1[22])
      {
        a1[22] = (void *)v35;
        if (v35 >= 0x2000000001LL)
        {
          *__error() = 12;
        }

        else
        {
          uint64_t v173 = a1[23];
          AAFieldKey v36 = realloc(v173, v13 - v15);
          if (v36)
          {
            a1[23] = v36;
            goto LABEL_61;
          }

          free(v173);
        }

        a1[23] = 0LL;
        BOOL v151 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateRetireRanges",  314,  143,  *v151,  "malloc",  v152,  v153,  v168);
        a1[22] = 0LL;
LABEL_122:
        __int128 v48 = 1;
        goto LABEL_79;
      }

        uint64_t v25 = v27;
LABEL_69:
        if (v25 == __smax) {
          goto LABEL_89;
        }
        int v13 = "store blob";
        uint64_t v14 = 688;
LABEL_93:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"writeBlobProc",  v14,  133,  0,  v13,  a7,  a8,  v52);
        while (!__ldaxr(v8))
        {
          if (!__stlxr(1u, v8)) {
            return 0xFFFFFFFFLL;
          }
        }

        __clrex();
        return 0xFFFFFFFFLL;
      }

      AAFieldKey v36 = *(void *)(a1 + 4864);
      if (!v36)
      {
        AAFieldKey v38 = *(void *)(a1 + 4872);
        BOOL v18 = __CFADD__(v38, __smax);
        AAFieldKey v39 = v38 + __smax;
        if (!v18 && (v39 & 0x8000000000000000LL) == 0)
        {
          uint64_t v20 = (void *)(a1 + 4872);
          a2 = *(void *)(a1 + 4880);
          if (a2 < v39)
          {
            do
            {
              while (!a2)
              {
                a2 = 0x4000LL;
                if (v39 <= 0x4000)
                {
                  AAFieldKey v23 = (void **)(a1 + 4888);
                  a2 = 0x4000LL;
                  goto LABEL_102;
                }
              }

              AAFieldKey v40 = a2 >> 1;
              if ((a2 & (a2 >> 1)) != 0) {
                AAFieldKey v40 = a2 & (a2 >> 1);
              }
              a2 += v40;
            }

            while (a2 < v39);
            AAFieldKey v23 = (void **)(a1 + 4888);
            if (a2 >= 0x2000000001LL) {
              goto LABEL_83;
            }
LABEL_102:
            __int128 v49 = *v23;
            __int128 v50 = a2;
            uint64_t v51 = realloc(*v23, a2);
            if (!v51)
            {
              __int128 v48 = v49;
LABEL_99:
              free(v48);
LABEL_100:
              *AAFieldKey v23 = 0LL;
              uint64_t v25 = -1LL;
              *uint64_t v20 = 0LL;
              v20[1] = 0LL;
              goto LABEL_69;
            }

            *(void *)(a1 + 4888) = v51;
            *(void *)(a1 + 4880) = v50;
          }

          AAFieldKey v43 = *(void *)(a1 + 4888);
          if (!v15)
          {
LABEL_80:
            if (v43) {
              memset_s((void *)(v43 + *v20), __smax, 0, __smax);
            }
            goto LABEL_88;
          }

    a4 += v15;
    v7 += v15;
    if (v7 >= v5) {
      return v7;
    }
  }

  __int16 v28 = 0LL;
  AAFieldKey v29 = 0LL;
  AAFieldKey v30 = v73;
  while (*(v30 - 1) != v18)
  {
    AAFieldKey v31 = *v30;
    v30 += 3;
    if (++v28 == 128) {
      goto LABEL_25;
    }
  }

  AAFieldKey v29 = v28;
LABEL_25:
  AAFieldKey v32 = (void *)v20[2];
  AAFieldKey v33 = *(_OWORD *)v20;
  AAFieldKey v34 = &v9[3 * v29];
  AAFieldKey v35 = v34[2];
  *(_OWORD *)uint64_t v20 = *(_OWORD *)v34;
  v20[2] = v35;
  *(_OWORD *)AAFieldKey v34 = v33;
  v34[2] = v32;
  AAFieldKey v36 = v20[1];
  AAFieldKey v37 = *(void *)(v13 + 16);
  AAFieldKey v38 = (uint64_t)a1[394] + 1;
  a1[394] = (void *)v38;
  AAFieldKey v39 = &v9[3 * v19];
  v39[2] = (void *)v38;
  AAFieldKey v40 = (uint64_t *)(v39 + 2);
  if (v36 == v37) {
    goto LABEL_26;
  }
  uint64_t v70 = v40;
  __int128 v71 = v20 + 1;
  char v72 = (void **)v20;
  if (pthread_mutex_unlock(v8))
  {
    unint64_t v60 = "MutexUnlock";
    char v61 = 175;
    goto LABEL_62;
  }

  AAFieldKey v42 = *(unsigned int *)(v13 + 24);
  AAFieldKey v43 = *(void *)(v13 + 8) + v42;
  if (v43 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_67:
    uint64_t v62 = *__error();
    unint64_t v60 = "aaMalloc";
    char v61 = 179;
LABEL_68:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"segment_decode_to_buffer",  v61,  137,  v62,  v60,  v16,  v17,  v68);
    AAFieldKey v41 = 0LL;
    goto LABEL_73;
  }

  src_buffer = (uint8_t *)malloc(v43);
  if (!src_buffer) {
    goto LABEL_67;
  }
  char v46 = (uint64_t)*a1;
  if ((*a1)[4])
  {
    __na = v15;
    __int128 v80 = v14;
    uint64_t v69 = v42;
    char v47 = 0LL;
    if ((_DWORD)v42)
    {
      __int128 v48 = *(void *)(v13 + 16);
      __int128 v49 = src_buffer;
      while (1)
      {
        __int128 v50 = (*(uint64_t (**)(void, uint8_t *, uint64_t, uint64_t))(v46 + 32))(*(void *)v46, v49, v42, v48);
        if (v50 < 0) {
          break;
        }
        if (v50)
        {
          v49 += v50;
          v47 += v50;
          v48 += v50;
          v42 -= v50;
          if (v42) {
            continue;
          }
        }

        goto LABEL_45;
      }

      char v47 = v50;
    }

    ace.qualifier_type = 73;
    uuid_unparse_upper(v23, (char *)out);
  }

LABEL_83:
  v41.uint64_t ikey = 4408665;
  if (AAFieldKeySetInsertKey(v16, v41) < 0) {
    BOOL v18 = 0;
  }
  int v17 = v52;
  if ((v52 & 0x20000) != 0) {
    goto LABEL_86;
  }
LABEL_61:
  if ((v17 & 0x40000) == 0) {
    goto LABEL_90;
  }
LABEL_89:
  v43.uint64_t ikey = 4997953;
  if (AAFieldKeySetInsertKey(v16, v43) < 0)
  {
LABEL_98:
    AAFieldKey v27 = "AAFieldKeySetInsertKey";
    __int16 v28 = 216;
    goto LABEL_99;
  }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  v35,  72,  0,  v36,  v33,  v34,  v118);
        goto LABEL_84;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  775,  72,  0,  "reading thread command, %zd",  v33,  v34,  v27);
LABEL_199:
  free(v13);
  if ((v122 & 0x80000000) == 0) {
    close(v122);
  }
  return v8;
}

  v52.uint64_t ikey = 4408665;
  stat v53 = AAHeaderGetKeyIndex(header, v52);
  if ((v53 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v53, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000LL) != 0)
    {
LABEL_172:
      uint64_t v10 = "YEC blob allocation";
      uint64_t v11 = 1339;
      goto LABEL_4;
    }

    __int128 v54 = *((void *)v35 + 282);
    if (v54 < size)
    {
      do
      {
        while (!v54)
        {
          __int128 v54 = 0x4000LL;
          if (size <= 0x4000)
          {
            __int128 v56 = (void **)(v35 + 2264);
            __int128 v54 = 0x4000LL;
            goto LABEL_97;
          }
        }

        uint64_t v55 = v54 >> 1;
        if ((v54 & (v54 >> 1)) != 0) {
          uint64_t v55 = v54 & (v54 >> 1);
        }
        v54 += v55;
      }

      while (v54 < size);
      __int128 v56 = (void **)(v35 + 2264);
      if (v54 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_171;
      }

LABEL_90:
  if (!v18) {
    goto LABEL_98;
  }
LABEL_92:
  int v44 = (unsigned int *)(v2 + 1136);
  while (!__ldaxr(v44))
  {
    if (!__stlxr(1u, v44)) {
      goto LABEL_97;
    }
  }

  __clrex();
LABEL_97:
  uint64_t v25 = 0xFFFFFFFFLL;
LABEL_30:
  AAFieldKeySetDestroy(v16);
  return v25;
}

uint64_t verifyDirectoryStreamClose( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(result + 1096);
    if (v9)
    {
      uint64_t v10 = *(void *)(result + 1080);
      if (v10)
      {
        *(_DWORD *)(v9 + 8) = 0;
        ThreadPoolRunWorker(v10, v9, a3, a4, a5, a6, a7, a8);
        *(void *)(v8 + 1096) = 0LL;
      }
    }

    ThreadPoolDestroy(*(void *)(v8 + 1080));
    unsigned int v11 = atomic_load((unsigned int *)(v8 + 1136));
    if (v11 || (unint64_t v12 = atomic_load((unint64_t *)(v8 + 1160))) != 0)
    {
LABEL_7:
      int v13 = 0;
      char v14 = 1;
    }

    else
    {
      uint64_t v36 = *(void *)(v8 + 1072);
      if (v36)
      {
        unint64_t v37 = *(void *)(v8 + 1120);
        if (v37)
        {
          uint64_t v38 = *(unsigned int *)(v8 + 1064);
          if ((_DWORD)v38)
          {
            for (uint64_t i = 0LL; i != v38; ++i)
            {
              uint64_t v40 = *(void *)(v36 + 8 * i);
              if (v40)
              {
                unint64_t v41 = 0LL;
                AAFieldKey v42 = *(uint64_t **)(v40 + 1440);
                AAFieldKey v43 = *(void **)(v8 + 1128);
                do
                {
                  uint64_t v44 = *v42++;
                  *v43++ |= v44;
                  v41 += 64LL;
                }

                while (v41 < v37);
              }
            }
          }
        }
      }

      __int16 v45 = *(AAPathList_impl **)(v8 + 1056);
      if (v45)
      {
        uint64_t v46 = AAPathListNodeFirst(v45);
        if (v46 != -1LL)
        {
          for (uint64_t j = v46; j != -1LL; uint64_t j = AAPathListNodeNext(*(AAPathList *)(v8 + 1056), j))
          {
            if (((*(void *)(*(void *)(v8 + 1128) + ((j >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> j) & 1) == 0)
            {
              if (AAPathListNodeGetPath(*(AAPathList *)(v8 + 1056), j, 0x400uLL, path, 0LL) < 0)
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchi veOutputStream.c",  (uint64_t)"verifyDirectoryStreamClose",  385,  119,  0,  "path too long",  v48,  v49,  v50);
                goto LABEL_7;
              }
            }
          }
        }
      }

      char v14 = 0;
      int v13 = 1;
    }

    AAPathListDestroy(*(AAPathList *)(v8 + 1056));
    uint64_t v15 = *(void **)(v8 + 1072);
    if (v15)
    {
      if (*(_DWORD *)(v8 + 1064))
      {
        unint64_t v16 = 0LL;
        do
          workerDataFree(*(void ***)(*(void *)(v8 + 1072) + 8 * v16++));
        while (v16 < *(unsigned int *)(v8 + 1064));
        uint64_t v15 = *(void **)(v8 + 1072);
      }

      free(v15);
    }

    if ((v14 & 1) == 0 && *(_DWORD *)(v8 + 1048))
    {
      int v17 = (FILE **)MEMORY[0x1895F89D0];
      BOOL v18 = (FILE *)*MEMORY[0x1895F89D0];
      if (*(void *)(v8 + 1144) == *(void *)(v8 + 1152))
      {
        fprintf(v18, "%12llu entries\n");
      }

      else
      {
        fprintf(v18, "%12llu entries in archive\n", *(void *)(v8 + 1144));
        fprintf(*v17, "%12llu entries in directory\n");
      }

      uint64_t v19 = *v17;
      unint64_t v20 = atomic_load((unint64_t *)(v8 + 1176));
      fprintf(v19, "%12llu common, OK\n", v20);
      AAFieldKey v21 = *v17;
      unint64_t v22 = atomic_load((unint64_t *)(v8 + 1184));
      fprintf(v21, "%12llu common, not matching\n", v22);
      AAFieldKey v23 = *v17;
      unint64_t v24 = atomic_load((unint64_t *)(v8 + 1192));
      fprintf(v23, "%12llu added\n", v24);
      uint64_t v25 = *v17;
      unint64_t v26 = atomic_load((unint64_t *)(v8 + 1200));
      fprintf(v25, "%12llu removed\n", v26);
      if (atomic_load((unint64_t *)(v8 + 1168)))
      {
        __int16 v28 = *v17;
        unint64_t v29 = atomic_load((unint64_t *)(v8 + 1168));
        fprintf(v28, "%12llu differences ignored\n", v29);
      }

      if (atomic_load((unint64_t *)(v8 + 1160)))
      {
        AAFieldKey v31 = *v17;
        unint64_t v32 = atomic_load((unint64_t *)(v8 + 1160));
        fprintf(v31, "%12llu errors reported\n", v32);
      }
    }

    unint64_t v33 = atomic_load((unint64_t *)(v8 + 1184));
    if (v33
      || (unint64_t v34 = atomic_load((unint64_t *)(v8 + 1192))) != 0
      || (unint64_t v35 = atomic_load((unint64_t *)(v8 + 1200))) != 0)
    {
      int v13 = 0;
    }

    free(*(void **)(v8 + 1128));
    free((void *)v8);
    if (v13) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t verifyDirectoryStreamWriteHeader(uint64_t a1, AAHeader_impl *a2)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (unsigned int *)(a1 + 1136);
  uint64_t value = 0LL;
  bzero(v63, 0x400uLL);
  size_t length = 0LL;
  if (*(void *)(a1 + 1096) || *(void *)(a1 + 1112))
  {
    uint64_t v8 = "invalid state";
    __int16 v9 = 247;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"verifyDirectoryStreamWriteHeader",  v9,  119,  0,  v8,  v6,  v7,  __size);
    goto LABEL_6;
  }

  *(_DWORD *)(a1 + 1104) = 0;
  ++*(void *)(a1 + 1144);
  v12.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(a2, v12);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(a2, KeyIndex, &value), FieldUInt <= 1) ? (int v16 = 1) : (int v16 = FieldUInt),
        v16 <= 0))
  {
    __int16 v17 = 252;
    goto LABEL_19;
  }

  if (value == 77)
  {
LABEL_17:
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 1104) = 1;
    return result;
  }

  v18.uint64_t ikey = 5521744;
  uint32_t v19 = AAHeaderGetKeyIndex(a2, v18);
  if ((v19 & 0x80000000) != 0
    || ((unsigned int FieldString = AAHeaderGetFieldString(a2, v19, 0x400uLL, v63, &length), FieldString <= 1)
      ? (int v25 = 1)
      : (int v25 = FieldString),
        v25 <= 0))
  {
    __int16 v17 = 254;
LABEL_19:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"verifyDirectoryStreamWriteHeader",  v17,  119,  "invalid archive",  v14,  v6,  v7,  __size);
LABEL_6:
    while (!__ldaxr(v2))
    {
      if (!__stlxr(1u, v2)) {
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  unint64_t v26 = *(uint64_t (**)(void, uint64_t, char *, AAHeader_impl *))(a1 + 1040);
  if (v26)
  {
    int v27 = v26(*(void *)(a1 + 1032), 70LL, v63, a2);
    if (v27 < 0)
    {
      uint64_t v8 = "user cancelled";
      __int16 v9 = 260;
      goto LABEL_5;
    }

    if (v27) {
      goto LABEL_17;
    }
  }

  uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1080), v21, v22, v23, v24, v14, v6, v7);
  if (!Worker)
  {
    uint64_t v8 = "ThreadPoolGetWorker";
    __int16 v9 = 266;
    goto LABEL_5;
  }

  uint64_t v29 = Worker;
  *(void *)(a1 + 1112) = AAHeaderGetPayloadSize(a2);
  *(_DWORD *)(v29 + 8) = value;
  __strlcpy_chk();
  *(void *)(v29 + 1344) = 0LL;
  *(void *)(v29 + 1368) = 0LL;
  *(void *)(v29 + 1392) = 0LL;
  *(void *)(v29 + 1416) = 0LL;
  *(void *)(v29 + 1432) = 0LL;
  *(void *)(v29 + 1424) = 0LL;
  if ((aaEntryAttributesInitWithHeader((char *)(v29 + 1040), (char *)(v29 + 1112), (char *)(v29 + 1168), a2) & 0x80000000) != 0)
  {
    uint64_t v8 = "invalid header";
    __int16 v9 = 277;
    goto LABEL_5;
  }

  v30.uint64_t ikey = 4997953;
  uint32_t v31 = AAHeaderGetKeyIndex(a2, v30);
  if ((v31 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v31, &size, &offset) <= 1)
  {
    uint64_t v32 = size;
    *(void *)(v29 + 1424) = size;
    if ((v32 & 0x8000000000000000LL) != 0) {
      goto LABEL_86;
    }
    unint64_t v33 = *(void *)(v29 + 1376);
    if (v33 < v32)
    {
      do
      {
        while (!v33)
        {
          unint64_t v33 = 0x4000LL;
          if (v32 <= 0x4000)
          {
            unint64_t v35 = (void **)(v29 + 1384);
            __uint64_t size = 0x4000LL;
            goto LABEL_47;
          }
        }

        unint64_t v34 = v33 >> 1;
        if ((v33 & (v33 >> 1)) != 0) {
          unint64_t v34 = v33 & (v33 >> 1);
        }
        v33 += v34;
      }

      while (v33 < v32);
      unint64_t v35 = (void **)(v29 + 1384);
      __uint64_t size = v33;
      if (v33 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_85;
      }

LABEL_47:
      uint64_t v36 = *v35;
      unint64_t v37 = realloc(*v35, __size);
      if (v37)
      {
        *(void *)(v29 + 1384) = v37;
        *(void *)(v29 + 1376) = __size;
        goto LABEL_49;
      }

      free(v36);
LABEL_85:
      *unint64_t v35 = 0LL;
      *(void *)(v29 + 1368) = 0LL;
      *(void *)(v29 + 1376) = 0LL;
LABEL_86:
      uint64_t v8 = "ACL blob allocation";
      __int16 v9 = 284;
      goto LABEL_5;
    }
  }

  AAFieldKey v38 = (pthread_t *)calloc(1uLL, 0x10uLL);
  *(void *)(a1 + 320) = v38;
  if (!v38)
  {
    AAFieldKey v18 = *__error();
    int v16 = "malloc";
    __int16 v17 = 345;
    goto LABEL_12;
  }

  v38[1] = (pthread_t)a1;
  if ((createThread(v38, (uint64_t)aeaOutputStreamWriterThreadProc, (uint64_t)v38, 0LL) & 0x80000000) != 0)
  {
    int v16 = "Thread creation";
    __int16 v17 = 347;
    goto LABEL_11;
  }

  return 0LL;
}

    uint64_t v10 = 0LL;
    uint64_t v14 = *(void *)(a1 + 24);
    goto LABEL_50;
  }

  if (!v16[3])
  {
    uint64_t v10 = -1LL;
    goto LABEL_50;
  }

  if (!a3) {
    goto LABEL_47;
  }
  uint64_t v10 = 0LL;
  while (1)
  {
    __int16 v17 = ((uint64_t (*)(void, char *, unint64_t))v16[3])(*v16, v15, v12);
    if (v17 < 1) {
      break;
    }
    v15 += v17;
    v10 += v17;
    v12 -= v17;
    if (!v12) {
      goto LABEL_45;
    }
  }

  uint64_t v14 = *(void *)(a1 + 24);
  uint64_t v10 = v17;
LABEL_50:
  if (v14 == *(void *)(a1 + 16) && (flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    AAFieldKey v18 = "flush buf";
    uint32_t v19 = 298;
    goto LABEL_14;
  }

  if (v10 < 0)
  {
LABEL_15:
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8)) {
        return v10;
      }
    }

    __clrex();
  }

  return v10;
}

        LODWORD(v11) = v45;
        uint64_t v8 = v42;
LABEL_48:
        unint64_t v41 = v28 - v42;
      }

      while ((unint64_t)(v28 - v42) > 1);
    }

    else {
      uint64_t v51 = v42;
    }
    else {
      uint64_t result = v11;
    }
    uint32_t v19 = *(_DWORD *)(a2 + 4 * v51);
  }

  *a6 = v19;
  return result;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  v25,  60,  v26,  v24,  v22,  v23,  v107);
    int v27 = 0LL;
LABEL_48:
    uint64_t v48 = 0LL;
    uint64_t v49 = 0LL;
    uint32_t v47 = 0LL;
    AAFieldKey v46 = 0LL;
LABEL_49:
    uint64_t v50 = 0;
    goto LABEL_50;
  }

          unint64_t v42 = *(unsigned __int8 *)v38;
          if (*v38)
          {
            switch(v39)
            {
              case 1:
                AAFieldKey v43 = v41;
                uint64_t v44 = strtoll(v38, &__endptr, 10);
                if (__endptr != v34)
                {
                  int v16 = "xhdr value parsing";
                  __int16 v17 = 295;
                  goto LABEL_242;
                }

                __int16 v45 = v44;
                AAFieldKey v46 = *(AAHeader_impl **)(a1 + 88);
                uint32_t v47 = v43;
                uint32_t KeyIndex = AAHeaderGetKeyIndex(v46, v47);
                if (KeyIndex < 0) {
                  uint64_t v49 = -1;
                }
                else {
                  uint64_t v49 = KeyIndex;
                }
                uint64_t v50 = v43;
                if (AAHeaderSetFieldUInt(v46, v49, v50, v45) < 0)
                {
                  int v16 = "creating header";
                  __int16 v17 = 296;
                  goto LABEL_242;
                }

                break;
              case 2:
                size_t v53 = v41;
                size_t v54 = v40;
                uint64_t v55 = strlen(&v35[v37 + 1]);
                if ((v54 & 1) != 0)
                {
                  __int128 v56 = v55;
                  unint64_t v57 = v53;
                  goto LABEL_92;
                }

                if (v55 == 1)
                {
                  unint64_t v57 = v53;
                  if (v42 == 46) {
                    goto LABEL_83;
                  }
                  uint64_t v55 = 1LL;
                }

                else
                {
                  unint64_t v57 = v53;
                  if (!v55)
                  {
                    __int128 v56 = 0LL;
                    goto LABEL_92;
                  }

                  if (v42 == 46 && v35[v37 + 2] == 47)
                  {
                    AAFieldKey v38 = &v35[v37 + 3];
                    v55 -= 2LL;
                    if (!v55)
                    {
LABEL_83:
                      __int128 v56 = 0LL;
                      goto LABEL_92;
                    }
                  }
                }

                if (v38[v55 - 1] == 47) {
                  __int128 v56 = v55 - 1;
                }
                else {
                  __int128 v56 = v55;
                }
LABEL_92:
                __int128 v76 = *(AAHeader_impl **)(a1 + 88);
                __int128 v77 = v57;
                __int128 v78 = v57;
                int v79 = AAHeaderGetKeyIndex(v76, v78);
                if (v79 < 0) {
                  __int128 v80 = -1;
                }
                else {
                  __int128 v80 = v79;
                }
                int v81 = v77;
                if (AAHeaderSetFieldString(v76, v80, v81, v38, v56) < 0)
                {
                  int v16 = "creating header";
                  __int16 v17 = 309;
                  goto LABEL_242;
                }

                unint64_t v26 = v146;
                break;
              case 4:
                __int128 v58 = v41;
                value.tv_seCC_SHA256_CTX c = 0LL;
                value.tv_nseCC_SHA256_CTX c = 0LL;
                value.tv_seCC_SHA256_CTX c = strtoll(v38, &__endptr, 10);
                __int128 v59 = __endptr;
                if (__endptr)
                {
                  unint64_t v60 = v58;
                  if (*__endptr == 46)
                  {
                    char v61 = strtoll(__endptr + 1, &__endptr, 10);
                    unint64_t v60 = v58;
                    value.tv_nseCC_SHA256_CTX c = v61;
                    __int128 v59 = __endptr;
                  }
                }

                else
                {
                  unint64_t v60 = v58;
                }

                if (v59 != v34)
                {
                  int v16 = "xhdr value parsing";
                  __int16 v17 = 317;
                  goto LABEL_242;
                }

                uint64_t v70 = *(AAHeader_impl **)(a1 + 88);
                __int128 v71 = v60;
                char v72 = v60;
                stat v73 = AAHeaderGetKeyIndex(v70, v72);
                if (v73 < 0) {
                  __int128 v74 = -1;
                }
                else {
                  __int128 v74 = v73;
                }
                __int128 v75 = v71;
                if (AAHeaderSetFieldTimespec(v70, v74, v75, &value) < 0)
                {
                  int v16 = "creating header";
                  __int16 v17 = 318;
                  goto LABEL_242;
                }

                break;
              case 5:
                uint64_t v62 = v41;
                uint64_t v63 = strtoll(v38, &__endptr, 10);
                if (__endptr != v34)
                {
                  int v16 = "xhdr value parsing";
                  __int16 v17 = 288;
                  goto LABEL_242;
                }

                uint64_t v64 = v63;
                __int128 v65 = *(AAHeader_impl **)(a1 + 88);
                uint64_t v66 = v62;
                __int128 v67 = AAHeaderGetKeyIndex(v65, v66);
                if (v67 < 0) {
                  uint64_t v68 = -1;
                }
                else {
                  uint64_t v68 = v67;
                }
                uint64_t v69 = v62;
                if (AAHeaderSetFieldBlob(v65, v68, v69, v64) < 0)
                {
                  int v16 = "creating header";
                  __int16 v17 = 289;
                  goto LABEL_242;
                }

                break;
              default:
                break;
            }
          }

          else
          {
            uint64_t v51 = *(AAHeader_impl **)(a1 + 88);
            uint64_t v52 = AAHeaderGetKeyIndex(v51, v41);
            if ((v52 & 0x80000000) == 0 && AAHeaderRemoveField(v51, v52) < 0)
            {
              int v16 = "removing header field";
              __int16 v17 = 278;
              goto LABEL_242;
            }
          }

  if (flags >> 62)
  {
    AAFieldKey v30 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%12llu B block size\n", v26);
    fprintf(*v30, "%12llu B file size\n", v13);
    fprintf(*v30, "%12llu B data size\n", v29);
    fprintf(*v30, "%12.2f x compression ratio (%s)\n", (double)(unint64_t)v29 / (double)v13, v20);
    fprintf(*v30, "%12llu blocks\n", *(void *)(v8 + 24));
    LODWORD(v30) = *(_DWORD *)(v8 + 40);
  }

  return (AAByteStream)AAGenericRandomAccessInputStreamOpen( v29,  v26,  v30,  2 * (int)v30,  v8,  (uint64_t)RandomAccessDecompressStreamGetBlock,  (uint64_t)RandomAccessDecompressStreamAbort,  (uint64_t)RandomAccessDecompressStreamDestroy,  flags);
}

LABEL_49:
  v38.uint64_t ikey = 5521752;
  uint32_t v39 = AAHeaderGetKeyIndex(a2, v38);
  if ((v39 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v39, &size, &offset) <= 1)
  {
    uint64_t v40 = size;
    *(void *)(v29 + 1416) = size;
    if ((v40 & 0x8000000000000000LL) != 0) {
      goto LABEL_89;
    }
    unint64_t v41 = *(void *)(v29 + 1352);
    if (v41 < v40)
    {
      do
      {
        while (!v41)
        {
          unint64_t v41 = 0x4000LL;
          if (v40 <= 0x4000)
          {
            AAFieldKey v43 = (void **)(v29 + 1360);
            __uint64_t size = 0x4000LL;
            goto LABEL_62;
          }
        }

        unint64_t v42 = v41 >> 1;
        if ((v41 & (v41 >> 1)) != 0) {
          unint64_t v42 = v41 & (v41 >> 1);
        }
        v41 += v42;
      }

      while (v41 < v40);
      AAFieldKey v43 = (void **)(v29 + 1360);
      __uint64_t size = v41;
      if (v41 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_88;
      }

    __int16 v28 = *v27;
    uint64_t v29 = realloc(*v27, v25);
    if (!v29)
    {
      free(v28);
      goto LABEL_118;
    }

    *((void *)v9 + 8) = v25;
    *((void *)v9 + 9) = v29;
    int v16 = *((void *)v9 + 4);
    if ((v16 & 0x8000000000000000LL) != 0) {
      goto LABEL_122;
    }
  }

  uint32_t v31 = (unint64_t *)((char *)v9 + 88);
  AAFieldKey v30 = *((void *)v9 + 11);
  if (v30 < v16)
  {
    do
    {
      while (!v30)
      {
        AAFieldKey v30 = 0x4000LL;
        if (v16 <= 0x4000)
        {
          AAFieldKey v30 = 0x4000LL;
          goto LABEL_61;
        }
      }

      uint64_t v32 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0) {
        uint64_t v32 = v30 & (v30 >> 1);
      }
      v30 += v32;
    }

    while (v30 < v16);
    if (v30 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_120;
    }

        AAFieldKey v38 = (uint8_t *)realloc(v31, v37);
        if (!v38)
        {
          free(v31);
LABEL_187:
          p_data_uint64_t size = &data_size;
          goto LABEL_223;
        }

        __int128 v122 = v37;
        data = v38;
        uint32_t v31 = v38;
      }

      else
      {
LABEL_47:
        unint64_t v37 = v32;
      }

      if (v37 - v33 >= v30) {
        uint32_t v39 = v30;
      }
      else {
        uint32_t v39 = v37 - v33;
      }
      uint64_t v40 = AAByteStreamRead(a2, &v31[v33], v39);
      if (v40 < 0) {
        goto LABEL_224;
      }
      if (!v40) {
        break;
      }
      unint64_t v33 = data_size + v40;
      if (__CFADD__(data_size, v40)) {
        goto LABEL_224;
      }
      uint64_t v32 = v122;
      if (v33 > v122) {
        goto LABEL_224;
      }
      data_size += v40;
      v34 += v40;
      v30 -= v40;
    }

    while (v30);
    if (v34 < 0) {
      goto LABEL_224;
    }
  }

  unint64_t v41 = *((void *)&v118 + 1);
  if (!*((void *)&v118 + 1)) {
    goto LABEL_86;
  }
  unint64_t v42 = 0LL;
  p_data_uint64_t size = (size_t *)(v9 + 4784);
  uint64_t v44 = *(void *)(v9 + 4784);
  __int16 v45 = *(void *)(v9 + 4792);
  do
  {
    if (v44 != v45) {
      goto LABEL_73;
    }
    AAFieldKey v46 = v45 + 0x40000;
    if (v45 > 0xFFFFFFFFFFFBFFFFLL)
    {
      uint64_t v44 = v45;
LABEL_73:
      uint64_t v48 = v45;
      goto LABEL_77;
    }

    do
    {
      while (!v45)
      {
        __int16 v45 = 0x4000LL;
        uint64_t v48 = 0x4000LL;
        if (v46 <= 0x4000) {
          goto LABEL_75;
        }
      }

      uint32_t v47 = v45 >> 1;
      if ((v45 & (v45 >> 1)) != 0) {
        uint32_t v47 = v45 & (v45 >> 1);
      }
      v45 += v47;
    }

    while (v45 < v46);
    uint64_t v48 = v45;
    if (v45 >= 0x2000000001LL)
    {
LABEL_222:
      *__error() = 12;
      goto LABEL_223;
    }

    uint64_t v29 = (void *)v11[2];
    AAFieldKey v30 = realloc(v29, v21);
    if (v30)
    {
      v11[1] = v21;
      v11[2] = v30;
      goto LABEL_51;
    }

    free(v29);
LABEL_68:
    v11[1] = 0LL;
    v11[2] = 0LL;
    void *v11 = 0LL;
    goto LABEL_69;
  }

LABEL_64:
  v46.uint64_t ikey = 4408665;
  uint32_t v47 = AAHeaderGetKeyIndex(a2, v46);
  if ((v47 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v47, &size, &offset) <= 1)
  {
    uint64_t v52 = size;
    *(void *)(v29 + 1432) = size;
    if ((v52 & 0x8000000000000000LL) == 0)
    {
      size_t v53 = *(void *)(v29 + 1400);
      if (v53 >= v52) {
        goto LABEL_79;
      }
      do
      {
        while (!v53)
        {
          size_t v53 = 0x4000LL;
          if (v52 <= 0x4000)
          {
            uint64_t v55 = (void **)(v29 + 1408);
            size_t v53 = 0x4000LL;
            goto LABEL_77;
          }
        }

        size_t v54 = v53 >> 1;
        if ((v53 & (v53 >> 1)) != 0) {
          size_t v54 = v53 & (v53 >> 1);
        }
        v53 += v54;
      }

      while (v53 < v52);
      uint64_t v55 = (void **)(v29 + 1408);
      if (v53 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_91;
      }

  uint64_t v44 = *(void *)(a1 + 64);
  __int16 v45 = v44 - v8;
  if (v44 < v8) {
    return 0LL;
  }
  if (v44 != v8) {
    memmove(*(void **)(a1 + 80), (const void *)(*(void *)(a1 + 80) + v8), v44 - v8);
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 64) = v45;
  return result;
}

        if (++v39 >= *(void *)(v9 + 24)) {
          goto LABEL_116;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateClusters",  704,  120,  0,  "invalid path",  v53,  v54,  v340);
      goto LABEL_49;
    case 3:
      __int128 v104 = *(void *)(v8 + 8);
      bzero(__s, 0x800uLL);
      data_size[0] = 0LL;
      uint64_t offset = 0LL;
      size[0] = 0LL;
      size_t length = 0LL;
      memset(&v379, 0, 72);
      *(void *)&v373 = 0LL;
      v372 = 0u;
      v370 = 0u;
      v371 = 0u;
      unint64_t v33 = AAHeaderCreate();
      if (!v33)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  398,  120,  0,  "AAHeaderCreate",  v107,  v108,  v340);
LABEL_115:
        unint64_t v33 = 0LL;
        int v25 = 0xFFFFFFFFLL;
        goto LABEL_120;
      }

      __int128 v109 = *(void *)(v9 + 16);
      if (v109 >= *(void *)(v9 + 24))
      {
        int v25 = 0LL;
        goto LABEL_120;
      }

      v359 = v33;
      __int128 v110 = (unint64_t *)(v104 + 1296);
      break;
    default:
      return 0xFFFFFFFFLL;
  }

  while (1)
  {
    __int128 v111 = *(void *)(v104 + 1144);
    __int128 v112 = v111 + 72 * v109;
    data_size[0] = 0LL;
    uint64_t offset = 0LL;
    if (*(_DWORD *)(v112 + 60) != 68) {
      goto LABEL_144;
    }
    __int128 v113 = *(_DWORD *)(v9 + 2108);
    __int128 v114 = (const char *)(*(void *)(*(void *)(v104 + 1096) + 32LL)
                        + *(void *)(*(void *)(*(void *)(v104 + 1096) + 8LL)
                                    + 16LL * *(unsigned int *)(v111 + 72 * v109 + 64)));
    if ((stateConcatPath(v104, __s, v114) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  413,  120,  0,  "invalid path",  v115,  v116,  v340);
      goto LABEL_142;
    }

    uint64_t v117 = strrchr(__s, 47);
    if (!v117) {
      break;
    }
    __int128 v120 = v117;
    int *v117 = 0;
    __int128 v121 = v117 + 1;
    if ((workerUpdateDir(v9, __s) & 0x80000000) != 0)
    {
      v136 = 420;
      uint64_t v137 = "opening parent directory";
      goto LABEL_137;
    }

    void *v120 = 47;
    __int128 v126 = (unsigned __int16 *)stateGetEntryData(v104, v112, v122, v123, v124, v125, v118, v119);
    if (!v126)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  426,  120,  0,  "invalid entry data",  v127,  v128,  v340);
LABEL_424:
      int v25 = 0LL;
      unint64_t v33 = v359;
      goto LABEL_120;
    }

    __int128 v129 = v111 + 72 * v109;
    __int128 v132 = *(void *)(v129 + 48);
    __int128 v131 = (uint64_t *)(v129 + 48);
    __int128 v130 = v132;
    if (v132 <= 5)
    {
      uint64_t v133 = 428;
      goto LABEL_140;
    }

    uint64_t v138 = v126;
    unint64_t v139 = v126[2];
    if (v130 < v139)
    {
      uint64_t v133 = 430;
LABEL_140:
      uint64_t v140 = "invalid entry";
LABEL_141:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  v133,  120,  0,  v140,  v127,  v128,  v340);
      __int16 v9 = v360;
      goto LABEL_142;
    }

    if ((aaHeaderInitWithEncodedData((uint64_t)v359, v126, v139) & 0x80000000) != 0)
    {
      uint64_t v133 = 431;
      uint64_t v140 = "invalid header";
      goto LABEL_141;
    }

    v142.uint64_t ikey = 5521752;
    uint64_t v143 = AAHeaderGetKeyIndex(v359, v142);
    if ((v143 & 0x80000000) != 0
      || ((AAFieldKey v144 = AAHeaderGetFieldBlob(v359, v143, data_size, size), v144 <= 1) ? (v145 = 1) : (v145 = v144), v145 <= 0))
    {
      data_size[0] = 0LL;
    }

    v146.uint64_t ikey = 4997953;
    AAFieldKey v147 = AAHeaderGetKeyIndex(v359, v146);
    if ((v147 & 0x80000000) != 0
      || ((v148 = AAHeaderGetFieldBlob(v359, v147, &offset, &length), v148 <= 1) ? (uint64_t v149 = 1) : (uint64_t v149 = v148), v149 <= 0))
    {
      uint64_t offset = 0LL;
    }

    size_t v150 = size[0] + v139;
    size[0] += v139;
    BOOL v151 = length + v139;
    length += v139;
    if (data_size[0])
    {
      unint64_t v152 = __CFADD__(v150, data_size[0]);
      unint64_t v153 = v150 + data_size[0];
      if (v152 || v153 > *v131)
      {
        uint64_t v133 = 438;
        uint64_t v140 = "invalid XAT blob size";
        goto LABEL_141;
      }
    }

    if (offset)
    {
      unint64_t v152 = __CFADD__(v151, offset);
      uint64_t v154 = v151 + offset;
      if (v152 || v154 > *v131)
      {
        uint64_t v133 = 441;
        uint64_t v140 = "invalid ACL blob size";
        goto LABEL_141;
      }
    }

    if ((aaEntryAttributesInitWithHeader((char *)&v379, (char *)&v370, 0LL, v359) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  442,  120,  0,  "setting attributes from header",  v155,  v156,  v340);
      __int16 v9 = v360;
      goto LABEL_142;
    }

    v157 = openat(*(_DWORD *)(v360 + 2104), v121, 0);
    if ((v157 & 0x80000000) != 0)
    {
      size_t v161 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  446,  120,  *v161,  "open",  v162,  v163,  v340);
      __int16 v9 = v360;
      goto LABEL_142;
    }

    size_t v158 = v157;
    if ((workerApplyAttr(v360, v112, v157, (char *)&v379) & 0x80000000) != 0)
    {
      uint64_t v164 = 447;
      size_t v165 = "setting attributes";
      goto LABEL_181;
    }

    if (data_size[0]
      && (workerDecodeAndApplyXAT(v360, v112, v158, (uint8_t *)v138 + size[0], data_size[0]) & 0x80000000) != 0)
    {
      uint64_t v164 = 449;
      size_t v165 = "loading and applying XAT";
      goto LABEL_181;
    }

    if (offset && (workerDecodeAndApplyACL(v360, v112, v158, (uint8_t *)v138 + length, offset) & 0x80000000) != 0)
    {
      uint64_t v164 = 450;
      size_t v165 = "loading and applying ACL";
LABEL_181:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  v164,  120,  0,  v165,  v159,  v160,  v340);
      close(v158);
      __int16 v9 = v360;
LABEL_142:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  454,  120,  0,  "set dir attributes failed: %s",  v134,  v135,  (char)v114);
      do
        unint64_t v141 = __ldxr(v110);
      while (__stxr(v141 + 1, v110));
      goto LABEL_144;
    }

    close(v158);
    __int16 v9 = v360;
LABEL_144:
    if (++v109 >= *(void *)(v9 + 24)) {
      goto LABEL_424;
    }
  }

  v136 = 417;
  uint64_t v137 = "invalid path";
LABEL_137:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerSetDirAttributes",  v136,  120,  0,  v137,  v118,  v119,  v340);
  goto LABEL_142;
}

LABEL_77:
      __int128 v56 = *v55;
      unint64_t v57 = realloc(*v55, v53);
      if (v57)
      {
        *(void *)(v29 + 1408) = v57;
        *(void *)(v29 + 1400) = v53;
        goto LABEL_79;
      }

      free(v56);
LABEL_91:
      *uint64_t v55 = 0LL;
      *(void *)(v29 + 1392) = 0LL;
      *(void *)(v29 + 1400) = 0LL;
    }

    uint64_t v8 = "YEC blob allocation";
    __int16 v9 = 296;
    goto LABEL_5;
  }

                  if (fchflags(v20, 0x20u) < 0)
                  {
                    uint64_t v48 = "set UF_COMPRESSED";
                    uint64_t v49 = 1000;
                    goto LABEL_46;
                  }
                }

                else
                {
                  st_uint64_t size = v63.st_size;
                  if (v63.st_size >= 1)
                  {
                    while (1)
                    {
                      else {
                        uint64_t v52 = st_size;
                      }
                      size_t v53 = read(v7, v21, v52);
                      if (v53 < 0)
                      {
                        uint64_t v50 = *__error();
                        uint64_t v48 = "read";
                        uint64_t v49 = 1026;
                        goto LABEL_47;
                      }

                      if (v53 != v52)
                      {
                        uint64_t v48 = "truncated read";
                        uint64_t v49 = 1027;
                        goto LABEL_46;
                      }

                      size_t v54 = write(v20, v21, v52);
                      if (v54 < 0)
                      {
                        uint64_t v50 = *__error();
                        uint64_t v48 = "write";
                        uint64_t v49 = 1029;
                        goto LABEL_47;
                      }

                      if (v54 != v52) {
                        break;
                      }
                      st_size -= v52;
                      if (st_size < 1) {
                        goto LABEL_38;
                      }
                    }

                    uint64_t v48 = "truncated write";
                    uint64_t v49 = 1030;
                    goto LABEL_46;
                  }
                }

LABEL_79:
  if (*(void *)(a1 + 1112))
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 1096) = v29;
  }

  else
  {
    if ((ThreadPoolRunWorker(*(void *)(a1 + 1080), v29, v48, v49, v50, v51, v6, v7) & 0x80000000) != 0)
    {
      uint64_t v8 = "ThreadPoolRunWorker";
      __int16 v9 = 302;
      goto LABEL_5;
    }

    return 0LL;
  }

  return result;
}

uint64_t verifyDirectoryStreamWriteBlob( uint64_t a1, int a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 1136);
  if (*(_DWORD *)(a1 + 1104)) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(a1 + 1096);
  if (!v12)
  {
    AAFieldKey v18 = "invalid state";
    __int16 v19 = 318;
    goto LABEL_41;
  }

  uint64_t v15 = *(void *)&a2 & 0xFFFFFFLL;
  if ((*(void *)&a2 & 0xFFFFFFLL) == 0x434559)
  {
    int v16 = (void *)(v12 + 1392);
    __int16 v17 = (rsize_t *)(v12 + 1432);
  }

  else if (v15 == 4997953)
  {
    int v16 = (void *)(v12 + 1368);
    __int16 v17 = (rsize_t *)(v12 + 1424);
  }

  else
  {
    if (v15 != 5521752) {
      goto LABEL_34;
    }
    int v16 = (void *)(v12 + 1344);
    __int16 v17 = (rsize_t *)(v12 + 1416);
  }

  unint64_t v20 = *v16 + __smax;
  if (__CFADD__(*v16, __smax) || (v20 & 0x8000000000000000LL) != 0) {
    goto LABEL_40;
  }
  rsize_t v21 = *v17;
  size_t v22 = v16[1];
  if (v22 < v20)
  {
    do
    {
      while (!v22)
      {
        size_t v22 = 0x4000LL;
        if (v20 <= 0x4000)
        {
          size_t v22 = 0x4000LL;
          goto LABEL_25;
        }
      }

      size_t v23 = v22 >> 1;
      if ((v22 & (v22 >> 1)) != 0) {
        size_t v23 = v22 & (v22 >> 1);
      }
      v22 += v23;
    }

    while (v22 < v20);
    if (v22 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_39;
    }

LABEL_25:
    uint64_t v24 = (void *)v16[2];
    int v25 = realloc(v24, v22);
    if (v25)
    {
      v16[1] = v22;
      v16[2] = v25;
      goto LABEL_27;
    }

    free(v24);
LABEL_39:
    v16[1] = 0LL;
    v16[2] = 0LL;
    *int v16 = 0LL;
    goto LABEL_40;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamDecryptSegment",  v27,  30,  0,  v26,  v16,  v17,  v31);
  rsize_t v28 = 0xFFFFFFFFLL;
LABEL_26:
  memset_s(v35, 0x104uLL, 0, 0x104uLL);
  memset_s(v33, 0x104uLL, 0, 0x104uLL);
  return v28;
}

    uint64_t v4 = 0LL;
    goto LABEL_26;
  }

  uint64_t v15 = 0;
  while (1)
  {
    int v16 = (_WORD *)((char *)v8 + v15 + 100);
    uint64_t v4 = (unsigned __int16)*v16;
    if (!*v16) {
      break;
    }
    __int16 v17 = v15 + v4;
    AAFieldKey v18 = *((unsigned __int16 *)v11 + 36);
    if ((int)v18 + (int)v4 <= *((unsigned __int16 *)v11 + 37))
    {
      memcpy((char *)v11 + v18 + 76, v16, (unsigned __int16)*v16);
      *((_WORD *)v11 + 36) += v4;
      uint64_t v15 = v17;
      uint64_t v14 = *((unsigned __int16 *)v8 + 48);
      if (v14 > v17) {
        continue;
      }
    }

    uint64_t v12 = *v11;
    goto LABEL_15;
  }

    if (!a2[3]) {
      goto LABEL_51;
    }
    unint64_t v33 = *v17;
    if (*v17)
    {
      unint64_t v34 = 0LL;
      unint64_t v35 = *(void *)(v5 + 1216);
      while (1)
      {
        uint64_t v36 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v35, v33);
        if (v36 < 1) {
          break;
        }
        v35 += v36;
        v34 += v36;
        v33 -= v36;
        if (!v33) {
          goto LABEL_32;
        }
      }

      unint64_t v34 = v36;
LABEL_32:
      if (v34 < 0 || !a2[3]) {
        goto LABEL_51;
      }
    }

    unint64_t v37 = *v18;
    if (*v18)
    {
      AAFieldKey v38 = 0LL;
      uint32_t v39 = *(void *)(v5 + 1240);
      while (1)
      {
        uint64_t v40 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v39, v37);
        if (v40 < 1) {
          break;
        }
        v39 += v40;
        v38 += v40;
        v37 -= v40;
        if (!v37) {
          goto LABEL_40;
        }
      }

      AAFieldKey v38 = v40;
LABEL_40:
      if (v38 < 0) {
        goto LABEL_51;
      }
    }

    if (!a2[3]) {
      goto LABEL_51;
    }
    unint64_t v41 = *v20;
    if (!*v20) {
      goto LABEL_49;
    }
    unint64_t v42 = 0LL;
    AAFieldKey v43 = *(void *)(v5 + 1264);
    while (1)
    {
      uint64_t v44 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v43, v41);
      if (v44 < 1) {
        break;
      }
      v43 += v44;
      v42 += v44;
      v41 -= v44;
      if (!v41) {
        goto LABEL_48;
      }
    }

    unint64_t v42 = v44;
LABEL_48:
    if (v42 < 0)
    {
LABEL_51:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"closeWithStateProc",  411,  108,  0,  "write state",  v15,  v16,  v45[0]);
      uint64_t v7 = 0;
    }

    else
    {
LABEL_49:
      if (a3) {
        *a3 = *(void *)(v5 + 1296);
      }
    }

    free(*(void **)(v5 + 1216));
    memset_s((void *)(v5 + 1200), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1240));
    memset_s((void *)(v5 + 1224), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1264));
    memset_s((void *)(v5 + 1248), 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v5, 0x518uLL, 0, 0x518uLL);
    free((void *)v5);
    return (v7 - 1);
  }

  return result;
}

    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 1608) = 1;
    return result;
  }

    if (v11 != v18)
    {
      uint64_t v32 = (char *)(*(void *)(a1 + 32) + v18);
      unint64_t v33 = v24;
      memmove(&v32[v24], v32, v19);
      uint64_t v24 = v33;
    }

    unsigned int v11 = *v12 + v24;
  }

  uint64_t *v12 = v11;
LABEL_29:
  unint64_t v34 = v13 + 48LL * v9;
  uint64_t v36 = *(void *)(v34 + 32);
  unint64_t v35 = (void *)(v34 + 32);
  *(void *)(a1 + 40) = *(void *)(a1 + 40) + a4 - v36;
  if (v11 <= 5)
  {
    unint64_t v20 = "copy header size";
    rsize_t v21 = 85;
    goto LABEL_5;
  }

  *(_WORD *)(*(void *)(a1 + 32) + 4LL) = v11;
  *int v16 = a3;
  *unint64_t v35 = a4;
  if (v9 + 1 < *(_DWORD *)a1)
  {
    unint64_t v37 = *(void *)(a1 + 8);
    AAFieldKey v38 = v37 + 48LL * (v9 + 1) + 12;
    uint32_t v39 = *(_DWORD *)a1 - 1;
    do
    {
      uint64_t v40 = v37 + 48LL * v9;
      *(_DWORD *)AAFieldKey v38 = *(_DWORD *)(v40 + 16) + *(_DWORD *)(v40 + 12);
      *(void *)(v38 + 12) = *(void *)(v40 + 32) + *(void *)(v40 + 24);
      ++v9;
      v38 += 48LL;
    }

    while (v39 != v9);
  }

  return 0LL;
}

          if (v37 != v35) {
            break;
          }
          v33 += v35;
          uint64_t v32 = *(void *)&size.st_dev;
          if (v33 >= *(void *)&size.st_dev) {
            goto LABEL_27;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateLoadEntryBlob",  740,  27,  0,  "loading entry blob",  v30,  v31,  v84);
        size_t v22 = header;
        goto LABEL_52;
      }

        if (v23 == v22)
        {
          rsize_t v27 = AAHeaderCreateWithEncodedData(v22, v9);
          if (v27)
          {
            __int16 v19 = v27;
            free(v9);
            return v19;
          }

          int v16 = "invalid header";
          __int16 v17 = 709;
        }

        else
        {
LABEL_28:
          int v16 = "reading header";
          __int16 v17 = 706;
        }

        goto LABEL_12;
      }
    }

    int v16 = "reading header magic";
    __int16 v17 = 703;
LABEL_12:
    AAFieldKey v18 = 0;
  }

  else
  {
    AAFieldKey v18 = *__error();
    int v16 = "malloc";
    __int16 v17 = 700;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateLoadEntryHeader",  v17,  27,  v18,  v16,  v7,  v8,  v28);
  free(v9);
  AAHeaderDestroy(0LL);
  return 0LL;
}

LABEL_27:
  uint64_t v26 = v16[2];
  if (__src)
  {
    memcpy((void *)(v26 + *v16), __src, __smax);
  }

  else if (v26)
  {
    memset_s((void *)(v26 + *v16), __smax, 0, __smax);
  }

  rsize_t v27 = *v16 + __smax;
  *int v16 = v27;
  if ((__smax & 0x8000000000000000LL) != 0)
  {
LABEL_40:
    AAFieldKey v18 = "blob append";
    __int16 v19 = 328;
LABEL_41:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c",  (uint64_t)"verifyDirectoryStreamWriteBlob",  v19,  119,  0,  v18,  a7,  a8,  v30);
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8)) {
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  if (v27 > v21)
  {
    AAFieldKey v18 = "blob size mismatch";
    __int16 v19 = 329;
    goto LABEL_41;
  }

  CC_SHA1_Deprecated_Final(md, &c);
  free(v28);
  if (v29 != a3)
  {
LABEL_47:
    uint64_t v8 = "Input digest failed";
    __int16 v9 = 285;
    goto LABEL_48;
  }

  if (!v149)
  {
    uint64_t v36 = a4 + 40;
    if (*(void *)md != *(void *)(a4 + 40)
      || v155 != *(void *)(a4 + 48)
      || v156 != (unint64_t)*(unsigned int *)(a4 + 56))
    {
      goto LABEL_56;
    }

  if (!a2)
  {
LABEL_30:
    if (AAByteStreamClose(v6) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  649,  135,  0,  "AAByteStreamClose",  v32,  v33,  v250);
      rsize_t v27 = 0;
    }
  }

  free(v31);
  free(v30);
  free(v29);
  free(v28);
  if (v27) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

      SharedBufferAbort(a1, v24, v25, v26, v27, v18, v19, v20, v45);
    }
  }

  return -1LL;
}

        a3 = v41;
        if (v17 != v20)
        {
          uint64_t v32 = "aaByteStreamPWriteExpected";
          unint64_t v33 = 353;
          goto LABEL_48;
        }

    size_t v23 = "SemAcquire";
    uint64_t v24 = 88;
    goto LABEL_29;
  }

  rsize_t v27 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  rsize_t v28 = 122;
LABEL_37:
  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPush",  v28,  0,  v27,  v9,  v10,  v11,  (char)v29);
  size_t v23 = "SharedArrayPush";
  uint64_t v24 = 69;
LABEL_29:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"threadPipelineWorkerThreadProc",  v24,  87,  0,  v23,  v15,  v16,  (char)v29);
  do
    int v25 = __ldxr(v5);
  while (__stxr(v25 + 1, v5));
  return a1;
}

    CC_SHA512_Update((CC_SHA512_CTX *)(a1 + 568), __src, __smax);
    AAFieldKey v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 1) == 0)
    {
LABEL_22:
      if ((v18 & 0x20) == 0) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboControls",  v34,  54,  0,  v33,  v23,  v24,  v37);
LABEL_28:
      uint64_t v29 = 0;
LABEL_29:
      if (v8 <= 1) {
        unint64_t v35 = 1LL;
      }
      else {
        unint64_t v35 = v8;
      }
      uint64_t v36 = (uint64_t)v16;
      do
      {
        BlobBufferFree(v36);
        v36 += 24LL;
        --v35;
      }

      while (v35);
      free(v16);
    }

    else
    {
      char v30 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboControls",  300,  54,  *v30,  "malloc",  v31,  v32,  v37);
      uint64_t v29 = 0;
    }

    if (v29) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboControls",  289,  54,  0,  "creating combo controls requires 2 or more unique inputs",  a7,  a8,  v37);
    return 0xFFFFFFFFLL;
  }

      AAHeaderDestroy(header);
      *((void *)v104 + v17) = v27;
      unint64_t v42 = *(void *)&size.st_dev;
      *((void *)v105 + v17) = *(void *)&size.st_dev;
      if (v42 != *(void *)(v87 + 72 * v17 + 280))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"computePatchesWorkerProc",  516,  27,  0,  "size mismatch: %s",  v13,  v14,  (char)__s);
        goto LABEL_54;
      }

      ++v17;
      uint64_t v15 = v85;
      uint64_t v8 = v86;
      int v16 = v89;
      if (v17 >= *(void *)(v9 + 56)) {
        goto LABEL_29;
      }
    }

    uint64_t v52 = "blob too large";
    size_t v53 = 728;
LABEL_51:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateLoadEntryBlob",  v53,  27,  0,  v52,  v20,  v21,  v84);
    rsize_t v27 = 0LL;
LABEL_52:
    AAHeaderDestroy(v22);
    free(v27);
    *((void *)v104 + v17) = 0LL;
    *((void *)v105 + v17) = 0LL;
    int v84 = (char)__s;
    uint64_t v50 = "loading file contents: %s";
    uint64_t v51 = 515;
    goto LABEL_53;
  }

LABEL_34:
  rsize_t v28 = *(void *)(a1 + 1112) - __smax;
  *(void *)(a1 + 1112) = v28;
  if (v28) {
    return 0LL;
  }
  if ((ThreadPoolRunWorker(*(void *)(a1 + 1080), v12, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    AAFieldKey v18 = "ThreadPoolRunWorker";
    __int16 v19 = 337;
    goto LABEL_41;
  }

  uint64_t result = 0LL;
  *(void *)(a1 + 1096) = 0LL;
  return result;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"remap_page",  v25,  140,  0,  v24,  v12,  v13,  v42);
    uint64_t v10 = 0xFFFFFFFFLL;
LABEL_35:
    free(v14);
    return v10;
  }

  return 0LL;
}

      if (a3)
      {
        uint64_t v14 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) <= 0x334852)
        {
          if (v14 == 3229779)
          {
            if ((AAHeaderGetFieldHash(header, i, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 2)
            {
              *a3 |= 2u;
              *(_OWORD *)(a3 + 8) = *(_OWORD *)v25;
              *((_DWORD *)a3 + 6) = v26;
            }
          }

          else if (v14 == 3295315 {
                 && (AAHeaderGetFieldHash(header, i, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
          }
                 && hash_function == 3)
          {
            *a3 |= 4u;
            uint64_t v15 = v26;
            *(_OWORD *)(a3 + 28) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 44) = v15;
          }
        }

        else if (v14 == 3360851)
        {
          if ((AAHeaderGetFieldHash(header, i, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 4)
          {
            *a3 |= 8u;
            int v16 = v26;
            *(_OWORD *)(a3 + 60) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 76) = v16;
            *(_OWORD *)(a3 + 92) = v27;
          }
        }

        else if (v14 == 3491923)
        {
          if ((AAHeaderGetFieldHash(header, i, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 5)
          {
            *a3 |= 0x10u;
            __int16 v17 = v26;
            *(_OWORD *)(a3 + 108) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 124) = v17;
            AAFieldKey v18 = v28;
            *(_OWORD *)(a3 + 140) = v27;
            *(_OWORD *)(a3 + 156) = v18;
          }
        }

        else if (v14 == 5458755 {
               && (AAHeaderGetFieldHash(header, i, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
        }
               && hash_function == 1)
        {
          *a3 |= 1u;
          *((_DWORD *)a3 + 1) = *(_DWORD *)v25;
        }
      }

      if (a2)
      {
        __int16 v19 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) > 0x524640)
        {
          if (v19 == 5391937)
          {
            if ((AAHeaderGetFieldUInt(header, i, &v24) & 0x80000000) == 0)
            {
              *a2 |= 2u;
              *((_DWORD *)a2 + 3) = v24;
            }
          }

          else if (v19 == 5523009 && (AAHeaderGetFieldUInt(header, i, &v24) & 0x80000000) == 0)
          {
            *a2 |= 1u;
            *((_DWORD *)a2 + 2) = v24;
          }
        }

        else if (v19 == 4411984)
        {
          if ((AAHeaderGetFieldUInt(header, i, &v24) & 0x80000000) == 0)
          {
            unint64_t v20 = *a2;
            *a2 |= 8u;
            switch(v24)
            {
              case 'A':
                rsize_t v21 = 1;
                goto LABEL_77;
              case 'B':
                rsize_t v21 = 2;
                goto LABEL_77;
              case 'C':
                rsize_t v21 = 3;
                goto LABEL_77;
              case 'D':
                rsize_t v21 = 4;
                goto LABEL_77;
              case 'E':
                rsize_t v21 = 5;
                goto LABEL_77;
              case 'F':
                rsize_t v21 = 6;
LABEL_77:
                *((_DWORD *)a2 + 1) = v21;
                break;
              default:
                *a2 = v20 & 0xF7;
                break;
            }
          }
        }

        else if (v19 == 4803654 && (AAHeaderGetFieldUInt(header, i, &v24) & 0x80000000) == 0)
        {
          *a2 |= 4u;
          *((void *)a2 + 2) = v24;
        }
      }
    }
  }

  return 0LL;
}

      char v30 = (void *)a1[5];
      uint32_t v31 = realloc(v30, v29);
      if (v31)
      {
        a1[4] = v29;
        a1[5] = (unint64_t)v31;
        goto LABEL_36;
      }

      free(v30);
LABEL_71:
      *uint64_t v8 = 0LL;
      v8[1] = 0LL;
      v8[2] = 0LL;
      goto LABEL_77;
    }

      char v30 = (void *)a1[5];
      uint32_t v31 = realloc(v30, v29);
      if (v31)
      {
        a1[4] = v29;
        a1[5] = v31;
        goto LABEL_36;
      }

      free(v30);
LABEL_74:
      *uint64_t v8 = 0LL;
      v8[1] = 0LL;
      v8[2] = 0LL;
      goto LABEL_81;
    }

              unint64_t v37 = a1[2];
              if (v26)
              {
                memcpy((void *)(v37 + *a1), v26, DataSize);
              }

              else if (v37)
              {
                memset_s((void *)(v37 + *a1), DataSize, 0, DataSize);
              }

              uint32_t v31 = 0LL;
              *a1 += DataSize;
LABEL_22:
              IFileStreamDestroy(v15);
              OECCStreamDestroy(v18);
              MemBufferDestroy(v22);
              return v31;
            }

            unint64_t v33 = "reading file data for ECC";
            unint64_t v34 = 84;
          }

          else
          {
            unint64_t v33 = "allocating mem buffer";
            unint64_t v34 = 80;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYEC.c",  (uint64_t)"aaEntryYECBlobInitWithFD",  v34,  105,  0,  v33,  v20,  v21,  v38);
LABEL_21:
          uint32_t v31 = 0xFFFFFFFFLL;
          goto LABEL_22;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYEC.c",  (uint64_t)"aaEntryYECBlobInitWithFD",  78,  105,  0,  "creating the ECC stream",  v16,  v17,  v38);
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYEC.c",  (uint64_t)"aaEntryYECBlobInitWithFD",  76,  105,  0,  "opening file",  v13,  v14,  v38);
        AAFieldKey v18 = 0LL;
      }

      size_t v22 = 0LL;
      goto LABEL_21;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYEC.c",  (uint64_t)"aaEntryYECBlobInitWithFD",  71,  105,  0,  "entry not found, or not a regular file",  v10,  v11,  v38);
    AAFieldKey v18 = 0LL;
    size_t v22 = 0LL;
    uint64_t v15 = 0LL;
    goto LABEL_21;
  }

  AAFieldKey v38 = a2;
  uint64_t v29 = "invalid YEC variant: %u";
  char v30 = 57;
LABEL_19:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYEC.c",  (uint64_t)"aaEntryYECBlobInitWithFD",  v30,  105,  0,  v29,  a7,  a8,  v38);
  return 0xFFFFFFFFLL;
}

      unint64_t v20 = "Invalid compression algorithm";
      rsize_t v21 = 274;
      goto LABEL_35;
    }

    if (compression_algorithm == 2049)
    {
      size_t v23 = 101;
    }

    else
    {
      if (compression_algorithm != 2304) {
        goto LABEL_34;
      }
      size_t v23 = 102;
    }
  }

                  uint32_t v47 = calloc(*(unsigned int *)(v19 + 72), 8uLL);
                  *(void *)(v19 + 80) = v47;
                  if (!v47)
                  {
                    uint64_t v24 = *__error();
                    size_t v22 = "malloc";
                    size_t v23 = 705;
                    goto LABEL_24;
                  }

                  if (*(_DWORD *)(v19 + 72))
                  {
                    uint64_t v48 = 0;
                    while ((SharedArrayPush_0((unsigned int *)(v19 + 192), v48) & 0x80000000) == 0)
                    {
                    }

                    size_t v22 = "SharedArrayPush";
                    size_t v23 = 708;
                    goto LABEL_23;
                  }

uint64_t verifyDirectoryStreamCancel(uint64_t result)
{
  uint64_t v1 = (unsigned int *)(result + 1136);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

void workerDataFree(void **a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 168;
    free(a1[170]);
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(a1[173]);
    memset_s(a1 + 171, 0x18uLL, 0, 0x18uLL);
    free(a1[176]);
    memset_s(a1 + 174, 0x18uLL, 0, 0x18uLL);
    free(a1[180]);
    free(a1);
  }

uint64_t sendMessage(uint64_t a1, uint64_t a2, uint64_t a3, AAFieldKeySet key_set)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  unsigned int v8 = *(_DWORD *)(a1 + 1048);
  if (v8)
  {
    switch((int)a2)
    {
      case 'G':
        fprintf((FILE *)*MEMORY[0x1895F89D0], "REMOVED %s\n");
        break;
      case 'H':
        fprintf((FILE *)*MEMORY[0x1895F89D0], "ADDED   %s\n");
        break;
      case 'I':
        if (v8 >= 2) {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "OK      %s\n");
        }
        break;
      case 'J':
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        __int128 v17 = 0u;
        __int128 v18 = 0u;
        __int128 v15 = 0u;
        __int128 v16 = 0u;
        *(_OWORD *)s = 0u;
        __int128 v14 = 0u;
        if (key_set) {
          AAFieldKeySetSerialize(key_set, 0x80uLL, s);
        }
        fprintf((FILE *)*MEMORY[0x1895F89D0], "DIFFER  %s (%s)\n");
        break;
      default:
        break;
    }
  }

  __int16 v9 = *(uint64_t (**)(void, uint64_t, uint64_t, AAFieldKeySet))(a1 + 1040);
  if (v9)
  {
    uint64_t result = v9(*(void *)(a1 + 1032), a2, a3, key_set);
    if ((result & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    if ((_DWORD)a2 == 73)
    {
LABEL_17:
      unsigned int v11 = (unint64_t *)(a1 + 1176);
    }

    else if ((_DWORD)result)
    {
      unsigned int v11 = (unint64_t *)(a1 + 1168);
    }

    else
    {
      switch((_DWORD)a2)
      {
        case 'G':
LABEL_16:
          uint64_t result = 0LL;
          unsigned int v11 = (unint64_t *)(a1 + 1200);
          break;
        case 'J':
LABEL_23:
          uint64_t result = 0LL;
          unsigned int v11 = (unint64_t *)(a1 + 1184);
          break;
        case 'H':
LABEL_22:
          uint64_t result = 0LL;
          unsigned int v11 = (unint64_t *)(a1 + 1192);
          break;
        default:
          return 0LL;
      }
    }

    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  else
  {
    uint64_t result = 0LL;
    switch((int)a2)
    {
      case 'G':
        goto LABEL_16;
      case 'H':
        goto LABEL_22;
      case 'I':
        goto LABEL_17;
      case 'J':
        goto LABEL_23;
      default:
        return result;
    }
  }

  return result;
}

size_t PCompressLZMA6Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZMA);
  if (!result) {
    return -1LL;
  }
  return result;
}

size_t PCompressLZMADecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0LL, COMPRESSION_LZMA);
  if (!result) {
    return -1LL;
  }
  return result;
}

uint64_t aeaCryptoInit(char *__s, unsigned int *a2)
{
  if (__s) {
    memset_s(__s, 0xD0uLL, 0, 0xD0uLL);
  }
  if (aeaProfileIsValid(*a2))
  {
    int v6 = 0;
    int v7 = 0;
    switch(*a2)
    {
      case 0u:
        *((void *)__s + 8) = RNG;
        *((void *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        *(void *)&__int128 v8 = 0x2000000020LL;
        *((void *)&v8 + 1) = 0x2000000020LL;
        *((void *)__s + 11) = AEADEncrypt_None_MAC256_KEY256;
        *((void *)__s + 12) = AEADDecrypt_None_MAC256_KEY256;
        *(_OWORD *)size_t __s = v8;
        *((void *)__s + 15) = Digest_SHA256;
        *((void *)__s + 16) = DSASign_ECDSA_P256;
        *((void *)__s + 17) = DSAVerify_ECDSA_P256;
        *(_OWORD *)(__s + 28) = xmmword_1862D7890;
        *(void *)(__s + 44) = 0x2000000080LL;
        goto LABEL_13;
      case 1u:
        goto LABEL_8;
      case 2u:
        int v6 = 1;
LABEL_8:
        *((void *)__s + 8) = RNG;
        *((void *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        *(_OWORD *)size_t __s = xmmword_1862D7880;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        if (!v6) {
          break;
        }
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        int v7 = 1;
LABEL_11:
        *((void *)__s + 8) = RNG;
        *((void *)__s + 9) = HKDFDerive;
        *(_OWORD *)size_t __s = xmmword_1862D7880;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 6) = 0x2000000041LL;
        *((void *)__s + 13) = DHESender_ECDHE_P256;
        *((void *)__s + 14) = DHERecipient_ECDHE_P256;
        *((void *)__s + 2) = 0x4100000061LL;
        *((_DWORD *)__s + 6) = 32;
        *((void *)__s + 20) = DerivePublicFromPrivate_ECP256;
        if (v7)
        {
LABEL_12:
          *((void *)__s + 15) = Digest_SHA256;
          *((void *)__s + 16) = DSASign_ECDSA_P256;
          *(_OWORD *)(__s + 28) = xmmword_1862D7890;
          *((_DWORD *)__s + 11) = 160;
          *((void *)__s + 17) = DSAVerify_ECDSA_P256;
          *((void *)__s + 18) = AEADEncrypt_AESCTR_MAC256_KEY640;
          *((void *)__s + 19) = AEADDecrypt_AESCTR_MAC256_KEY640;
LABEL_13:
          *((void *)__s + 21) = DerivePublicFromPrivate_ECP256;
        }

        break;
      case 5u:
        *((void *)__s + 8) = RNG;
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 10) = ScryptDerive_KEY256;
        *(_OWORD *)size_t __s = xmmword_1862D7880;
        unsigned int v10 = a2[2];
        *((_DWORD *)__s + 13) = 32;
        *((_DWORD *)__s + 14) = v10;
        break;
      default:
        *(_DWORD *)size_t __s = 32;
        *((void *)__s + 1) = 0x2000000020LL;
        *((void *)__s + 8) = RNG;
        *((void *)__s + 9) = HKDFDerive;
        *((_DWORD *)__s + 13) = 32;
        break;
    }

    uint64_t result = 0LL;
    *((void *)__s + 22) = HMACInit_SHA256;
    *((void *)__s + 23) = HMACUpdate_SHA256;
    *((void *)__s + 24) = HMACFinal_SHA256;
    *((void *)__s + 25) = Digest_SHA256;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"aeaCryptoInit",  1400,  94,  0,  "Invalid profile",  v4,  v5,  v11);
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t HKDFDerive( _DWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unint64_t)(a2 - 257) < 0xFFFFFFFFFFFFFF00LL || *a3 == 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"HKDFDerive",  518,  94,  0,  "Invalid KDF parameters",  a7,  a8,  v20);
    return 0xFFFFFFFFLL;
  }

  else
  {
    ccsha256_di();
    unint64_t v12 = a1 + 1;
    int v13 = cchkdf();
    int v16 = v13;
    if (v13)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"HKDFDerive",  547,  94,  0,  "HKDF",  v14,  v15,  (_BYTE)a1 + 4);
      *a1 = a2;
      memset_s((char *)v12 + a2, 256 - a2, 0, 256 - a2);
      __int128 v17 = (char *)a1;
      rsize_t v18 = 260LL;
      rsize_t v19 = 260LL;
    }

    else
    {
      *a1 = a2;
      __int128 v17 = (char *)v12 + a2;
      rsize_t v18 = 256 - a2;
      rsize_t v19 = 256 - a2;
    }

    memset_s(v17, v18, 0, v19);
    if (v16) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

uint64_t RNG()
{
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_None_MAC256_KEY256( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a4 == 32)
  {
    if ((HMACDerive_SHA256(a3, a4) & 0x80000000) == 0) {
      return 0LL;
    }
    unsigned int v10 = "HMAC derivation";
    __int16 v11 = 904;
  }

  else
  {
    unsigned int v10 = "AEAD invalid sizes";
    __int16 v11 = 901;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADEncrypt_None_MAC256_KEY256",  v11,  94,  0,  v10,  a7,  a8,  v12);
  if (a3) {
    memset_s(a3, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t AEADDecrypt_None_MAC256_KEY256( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a4 == 32 && *a3 == 32)
  {
    __int16 v9 = "HMAC verification";
    __int16 v10 = 924;
  }

  else
  {
    __int16 v9 = "AEAD invalid sizes";
    __int16 v10 = 921;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADDecrypt_None_MAC256_KEY256",  v10,  94,  0,  v9,  a7,  a8,  vars0);
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_AESCTR_MAC256_KEY640( uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  memset(v36, 0, sizeof(v36));
  memset(v33, 0, sizeof(v33));
  memset(v29, 0, sizeof(v29));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640",  946,  94,  0,  "AEAD invalid sizes",  a7,  a8,  v26);
    return 0xFFFFFFFFLL;
  }

  __int128 v31 = *(_OWORD *)(a4 + 4);
  __int128 v32 = *(_OWORD *)(a4 + 20);
  int v30 = 32;
  memset_s(v33, 0xE0uLL, 0, 0xE0uLL);
  v35[0] = *(_OWORD *)(a4 + 36);
  v35[1] = *(_OWORD *)(a4 + 52);
  unsigned int __s = 32;
  memset_s(v36, 0xE0uLL, 0, 0xE0uLL);
  __int128 v28 = *(_OWORD *)(a4 + 68);
  int v27 = 16;
  memset_s(v29, 0xF0uLL, 0, 0xF0uLL);
  char v12 = (size_t *)ccaes_ctr_crypt_mode();
  rsize_t v13 = *v12;
  if (*v12 < 0x2000000001LL)
  {
    uint64_t v15 = v12;
    int v16 = malloc(*v12);
    if (!v16) {
      goto LABEL_8;
    }
    __int128 v17 = v16;
    if (((unsigned int (*)(size_t *, void *, void, _OWORD *, __int128 *))v15[3])(v15, v16, __s, v35, &v28))
    {
      char v20 = "init";
      __int16 v21 = 991;
    }

    else if (((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v15[5])(v17, a2, a1, a1))
    {
      char v20 = "encryption";
      __int16 v21 = 992;
    }

    else
    {
      if ((HMACDerive_SHA256(a3, &v30) & 0x80000000) == 0)
      {
        int v25 = 0;
        goto LABEL_12;
      }

      char v20 = "HMAC";
      __int16 v21 = 995;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640",  v21,  94,  0,  v20,  v18,  v19,  v26);
    int v25 = 1;
LABEL_12:
    memset_s(v17, v13, 0, v13);
    goto LABEL_13;
  }

  *__error() = 12;
LABEL_8:
  size_t v22 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640",  990,  94,  *v22,  "malloc",  v23,  v24,  v26);
  __int128 v17 = 0LL;
  int v25 = 1;
LABEL_13:
  free(v17);
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v30, 0x104uLL, 0, 0x104uLL);
  memset_s(&v27, 0x104uLL, 0, 0x104uLL);
  if (a3)
  {
    if (v25) {
      memset_s(a3, 0x104uLL, 0, 0x104uLL);
    }
  }

  return (v25 << 31 >> 31);
}

uint64_t AEADDecrypt_AESCTR_MAC256_KEY640( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  memset(v38, 0, sizeof(v38));
  memset(v35, 0, sizeof(v35));
  memset(v31, 0, sizeof(v31));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640",  1049,  94,  0,  "AEAD invalid sizes",  a7,  a8,  v28);
    return 0xFFFFFFFFLL;
  }

  __int128 v33 = *(_OWORD *)(a4 + 4);
  __int128 v34 = *(_OWORD *)(a4 + 20);
  int v32 = 32;
  memset_s(v35, 0xE0uLL, 0, 0xE0uLL);
  v37[0] = *(_OWORD *)(a4 + 36);
  v37[1] = *(_OWORD *)(a4 + 52);
  unsigned int __s = 32;
  memset_s(v38, 0xE0uLL, 0, 0xE0uLL);
  __int128 v30 = *(_OWORD *)(a4 + 68);
  int v29 = 16;
  memset_s(v31, 0xF0uLL, 0, 0xF0uLL);
  if ((HMACVerify_SHA256(a3, &v32) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640",  1057,  94,  0,  "HMAC",  v12,  v13,  v28);
    int v17 = 0;
    goto LABEL_16;
  }

  uint64_t v14 = (size_t *)ccaes_ctr_crypt_mode();
  rsize_t v15 = *v14;
  if (*v14 < 0x2000000001LL)
  {
    uint64_t v18 = v14;
    uint64_t v19 = malloc(*v14);
    if (!v19) {
      goto LABEL_10;
    }
    char v20 = v19;
    if (((unsigned int (*)(size_t *, void *, void, _OWORD *, __int128 *))v18[3])(v18, v19, __s, v37, &v30))
    {
      uint64_t v23 = "init";
      __int16 v24 = 1094;
    }

    else
    {
      if (!((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v18[5])(v20, a2, a1, a1))
      {
        int v17 = 1;
        goto LABEL_14;
      }

      uint64_t v23 = "encryption";
      __int16 v24 = 1095;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640",  v24,  94,  0,  v23,  v21,  v22,  v28);
    int v17 = 0;
LABEL_14:
    memset_s(v20, v15, 0, v15);
    goto LABEL_15;
  }

  *__error() = 12;
LABEL_10:
  int v25 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640",  1093,  94,  *v25,  "malloc",  v26,  v27,  v28);
  int v17 = 0;
  char v20 = 0LL;
LABEL_15:
  free(v20);
LABEL_16:
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v32, 0x104uLL, 0, 0x104uLL);
  memset_s(&v29, 0x104uLL, 0, 0x104uLL);
  if (v17) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ScryptDerive_KEY256( _DWORD *a1, uint64_t a2, unint64_t a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0x14 || !*a5)
  {
    uint64_t v12 = "Invalid password/salt";
    __int16 v13 = 823;
LABEL_8:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"ScryptDerive_KEY256",  v13,  94,  0,  v12,  a7,  a8,  v22);
    return 0xFFFFFFFFLL;
  }

  if (a4 >= 4)
  {
    uint64_t v12 = "Invalid hardness parameter";
    __int16 v13 = 832;
    goto LABEL_8;
  }

  size_t v9 = ccscrypt_storage_size();
  if ((v9 & 0x8000000000000000LL) != 0)
  {
    rsize_t v15 = "Invalid scrypt parameters";
    __int16 v16 = 842;
    int v17 = 0;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"ScryptDerive_KEY256",  v16,  94,  v17,  v15,  v10,  v11,  v22);
    uint64_t v19 = 0LL;
LABEL_17:
    free(v19);
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
    return 0xFFFFFFFFLL;
  }

  if (v9 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_15:
    int v17 = *__error();
    rsize_t v15 = "malloc";
    __int16 v16 = 844;
    goto LABEL_16;
  }

  uint64_t v18 = malloc(v9);
  if (!v18) {
    goto LABEL_15;
  }
  uint64_t v19 = v18;
  if (ccscrypt())
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"ScryptDerive_KEY256",  846,  94,  0,  "scrypt",  v20,  v21,  32);
    goto LABEL_17;
  }

  *a1 = 32;
  memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
  free(v19);
  return 0LL;
}

uint64_t DHESender_ECDHE_P256( void *a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 != 65)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHESender_ECDHE_P256",  581,  94,  0,  "ECDHE_P256_Sender invalid sizes",  a7,  a8,  v28);
    return 0xFFFFFFFFLL;
  }

  uint64_t v10 = (void *)MEMORY[0x186E3622C]();
  size_t v11 = (32LL * *v10) | 0x10;
  size_t v12 = 24LL * *v10 + 16;
  if (v11 < 0x2000000001LL)
  {
    __int16 v13 = malloc(v11);
  }

  else
  {
    __int16 v13 = 0LL;
    *__error() = 12;
  }

  if (v12 < 0x2000000001LL)
  {
    int v17 = malloc(v12);
    uint64_t v14 = v17;
    BOOL v15 = v13 == 0LL;
    BOOL v16 = v17 == 0LL;
    if (v13) {
      BOOL v18 = v17 == 0LL;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      if (ccec_x963_import_pub())
      {
        int v25 = "importing public key";
        __int16 v26 = 602;
      }

      else
      {
        ccrng();
        int v25 = "RNG lookup";
        __int16 v26 = 606;
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHESender_ECDHE_P256",  v26,  94,  0,  v25,  v23,  v24,  32);
      BOOL v16 = 0;
LABEL_21:
      memset_s(v13, v11, 0, v11);
      free(v13);
      if (!v16) {
        memset_s(v14, v12, 0, v12);
      }
      goto LABEL_16;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    *__error() = 12;
    BOOL v15 = v13 == 0LL;
    BOOL v16 = 1;
  }

  uint64_t v19 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHESender_ECDHE_P256",  599,  94,  *v19,  "malloc",  v20,  v21,  32);
  if (!v15) {
    goto LABEL_21;
  }
  free(v13);
  if (!v16) {
    memset_s(v14, v12, 0, v12);
  }
LABEL_16:
  free(v14);
  if (a1) {
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  }
  if (a2) {
    memset_s(a2, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t DHERecipient_ECDHE_P256( void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 != 97 || *a2 != 65)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHERecipient_ECDHE_P256",  704,  94,  0,  "ECDHE_P256_Recipient invalid sizes",  a7,  a8,  v27);
    return 0xFFFFFFFFLL;
  }

  size_t v9 = (void *)MEMORY[0x186E3622C]();
  size_t v10 = 24LL * *v9 + 16;
  size_t v11 = (32LL * *v9) | 0x10;
  if (v10 < 0x2000000001LL)
  {
    size_t v12 = malloc(v10);
  }

  else
  {
    size_t v12 = 0LL;
    *__error() = 12;
  }

  if (v11 < 0x2000000001LL)
  {
    int v17 = malloc(v11);
    uint64_t v14 = v17;
    BOOL v15 = v12 == 0LL;
    BOOL v16 = v17 == 0LL;
    if (v12) {
      BOOL v18 = v17 == 0LL;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      if (ccec_x963_import_priv())
      {
        int v25 = "importing full key";
        __int16 v26 = 725;
      }

      else if (ccec_x963_import_pub())
      {
        int v25 = "importing pub key";
        __int16 v26 = 728;
      }

      else
      {
        ccrng();
        int v25 = "RNG lookup";
        __int16 v26 = 732;
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHERecipient_ECDHE_P256",  v26,  94,  0,  v25,  v23,  v24,  32);
      BOOL v16 = 0;
LABEL_25:
      memset_s(v12, v10, 0, v10);
      free(v12);
      if (!v16) {
        memset_s(v14, v11, 0, v11);
      }
      goto LABEL_18;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    *__error() = 12;
    BOOL v15 = v12 == 0LL;
    BOOL v16 = 1;
  }

  uint64_t v19 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DHERecipient_ECDHE_P256",  722,  94,  *v19,  "malloc",  v20,  v21,  32);
  if (!v15) {
    goto LABEL_25;
  }
  free(v12);
  if (!v16) {
    memset_s(v14, v11, 0, v11);
  }
LABEL_18:
  free(v14);
  if (a1) {
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t DerivePublicFromPrivate_ECP256( _DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 != 97)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DerivePublicFromPrivate_ECP256",  1346,  94,  0,  "invalid private key size",  a7,  a8,  v19);
    return 0xFFFFFFFFLL;
  }

  size_t v9 = (void *)MEMORY[0x186E3622C]();
  rsize_t v10 = (32LL * *v9) | 0x10;
  if (v10 >= 0x2000000001LL)
  {
    *__error() = 12;
    goto LABEL_9;
  }

  size_t v11 = malloc((32LL * *v9) | 0x10);
  if (!v11)
  {
LABEL_9:
    BOOL v15 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DerivePublicFromPrivate_ECP256",  1356,  94,  *v15,  "malloc",  v16,  v17,  v19);
    if (a1) {
LABEL_10:
    }
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    return 0xFFFFFFFFLL;
  }

  size_t v12 = v11;
  if (ccec_x963_import_priv())
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DerivePublicFromPrivate_ECP256",  1359,  94,  0,  "importing private key",  v13,  v14,  v19);
    memset_s(v12, v10, 0, v10);
    free(v12);
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_10;
  }

  ccec_x963_export();
  *a1 = 65;
  memset_s((char *)a1 + 69, 0xBFuLL, 0, 0xBFuLL);
  memset_s(v12, v10, 0, v10);
  free(v12);
  return 0LL;
}

uint64_t Digest_SHA256(uint64_t a1, const void *a2, CC_LONG a3)
{
  *(_DWORD *)a1 = 32;
  return 0LL;
}

uint64_t DSASign_ECDSA_P256( void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 != 97)
  {
    rsize_t v10 = "invalid private key size";
    __int16 v11 = 1154;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSASign_ECDSA_P256",  v11,  94,  0,  v10,  a7,  a8,  v22);
    return 0xFFFFFFFFLL;
  }

  if (*a3 != 32)
  {
    rsize_t v10 = "invalid digest size";
    __int16 v11 = 1155;
    goto LABEL_7;
  }

  size_t v9 = (32LL * *(void *)MEMORY[0x186E3622C]()) | 0x10;
  if (v9 >= 0x2000000001LL)
  {
    *__error() = 12;
    goto LABEL_12;
  }

  uint64_t v13 = malloc(v9);
  if (!v13)
  {
LABEL_12:
    char v19 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSASign_ECDSA_P256",  1167,  94,  *v19,  "malloc",  v20,  v21,  v22);
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_18;
  }

  uint64_t v14 = v13;
  if (ccec_x963_import_priv())
  {
    uint64_t v17 = "importing private key";
    __int16 v18 = 1170;
  }

  else
  {
    char v22 = 0x80;
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
    ccrng();
    uint64_t v17 = "RNG lookup";
    __int16 v18 = 1176;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSASign_ECDSA_P256",  v18,  94,  0,  v17,  v15,  v16,  v22);
  memset_s(v14, v9, 0, v9);
  free(v14);
  if (a1) {
LABEL_18:
  }
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t DSAVerify_ECDSA_P256( unsigned int *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1 == 128)
  {
    if (*a2 == 65)
    {
      if (*a3 == 32)
      {
        size_t v9 = 24LL * *(void *)MEMORY[0x186E3622C]() + 16;
        if (v9 < 0x2000000001LL)
        {
          uint64_t v13 = malloc(v9);
          if (v13)
          {
            uint64_t v14 = v13;
            if (ccec_x963_import_pub())
            {
              uint64_t v17 = "importing public key";
              __int16 v18 = 1267;
            }

            else
            {
              unint64_t v22 = *a1;
              if (v22 >= 2 && *((_BYTE *)a1 + 4) == 48)
              {
                if ((unint64_t)*((unsigned __int8 *)a1 + 5) + 2 <= v22)
                {
                  ccec_verify();
                  uint64_t v17 = "Signature verification";
                  __int16 v18 = 1275;
                }

                else
                {
                  uint64_t v17 = "Invalid signature";
                  __int16 v18 = 1272;
                }
              }

              else
              {
                uint64_t v17 = "Invalid signature";
                __int16 v18 = 1270;
              }
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSAVerify_ECDSA_P256",  v18,  94,  0,  v17,  v15,  v16,  v23);
            memset_s(v14, v9, 0, v9);
            goto LABEL_21;
          }
        }

        else
        {
          *__error() = 12;
        }

        char v19 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSAVerify_ECDSA_P256",  1264,  94,  *v19,  "malloc",  v20,  v21,  v23);
        uint64_t v14 = 0LL;
LABEL_21:
        free(v14);
        return 0xFFFFFFFFLL;
      }

      rsize_t v10 = "invalid digest size";
      __int16 v11 = 1253;
    }

    else
    {
      rsize_t v10 = "Invalid public key size";
      __int16 v11 = 1252;
    }
  }

  else
  {
    rsize_t v10 = "Invalid signature size";
    __int16 v11 = 1251;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"DSAVerify_ECDSA_P256",  v11,  94,  0,  v10,  a7,  a8,  v23);
  return 0xFFFFFFFFLL;
}

void *HMACInit_SHA256(_DWORD *a1)
{
  if (*a1 != 32) {
    return 0LL;
  }
  ccsha256_di();
  uint64_t v1 = malloc(0x1F8uLL);
  if (v1)
  {
    cchmac_init();
  }

  else
  {
    uint64_t v2 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"HMACInit_SHA256",  388,  94,  *v2,  "malloc",  v3,  v4,  v6);
  }

  return v1;
}

uint64_t HMACUpdate_SHA256(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  cchmac_update();
  return 0LL;
}

uint64_t HMACFinal_SHA256(void *a1, _DWORD *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  cchmac_final();
  *a2 = 32;
  memset_s(a2 + 9, 0xE0uLL, 0, 0xE0uLL);
  memset_s(a1, 0x1F8uLL, 0, 0x1F8uLL);
  free(a1);
  return 0LL;
}

uint64_t HMACDerive_SHA256(_DWORD *a1, _DWORD *a2)
{
  if (*a2 != 32) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  uint64_t v3 = malloc(0x1F8uLL);
  if (v3)
  {
    cchmac_init();
    cchmac_update();
    cchmac_update();
    cchmac_update();
    cchmac_final();
    *a1 = 32;
    memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
    memset_s(v3, 0x1F8uLL, 0, 0x1F8uLL);
    free(v3);
  }

  else
  {
    uint64_t v5 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"HMACDerive_SHA256",  271,  94,  *v5,  "malloc",  v6,  v7,  v8);
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
  }

  if (v3) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t HMACVerify_SHA256(uint64_t a1, _DWORD *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  BOOL v3 = *(_DWORD *)a1 != 32 || *a2 != 32;
  int v4 = HMACDerive_SHA256(&__s, a2);
  int64x2_t v10 = v14;
  int64x2_t v11 = v13;
  int64x2_t v8 = *(int64x2_t *)(a1 + 20);
  int64x2_t v9 = *(int64x2_t *)(a1 + 4);
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  int v5 = v4 < 0 || v3;
  uint16x4_t v6 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32( (int32x4_t)vceqq_s64(v11, v9),  (int32x4_t)vceqq_s64(v10, v8))));
  v6.i16[0] = vmaxv_u16(v6);
  return ((v6.i32[0] | v5) << 31 >> 31);
}

AAByteStream AEADecryptionInputStreamOpen( AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads = n_threads;
  if (n_threads <= 0) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((_DWORD *)context + 684) || !*((void *)context + 341))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"AEADecryptionInputStreamOpen",  461,  30,  0,  "Invalid context",  v4,  v5,  v52);
    int64x2_t v10 = 0LL;
    uint64_t v12 = 0LL;
LABEL_22:
    free(v10);
    aeaInputStreamClose(v12);
    return 0LL;
  }

  int64x2_t v10 = calloc(1uLL, 0x68uLL);
  int64x2_t v11 = malloc(0x428uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x428uLL, 0, 0x428uLL), !v10))
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 466;
LABEL_21:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"AEADecryptionInputStreamOpen",  v17,  30,  v18,  v16,  v13,  v14,  v52);
    goto LABEL_22;
  }

  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  if ((aeaContextUnlock((uint64_t)context, v12 + 144, (_DWORD *)(v12 + 788), 0LL, 1, 0) & 0x80000000) != 0)
  {
    uint64_t v16 = "unlock container";
    __int16 v17 = 473;
    goto LABEL_20;
  }

  unint64_t v15 = (*(void *)(v12 + 176) + (unint64_t)*(unsigned int *)(v12 + 160) - 1) / *(unsigned int *)(v12 + 160);
  if (v15 >= 0xFFFFFFFF)
  {
    uint64_t v16 = "Invalid data size";
    __int16 v17 = 477;
LABEL_20:
    int v18 = 0;
    goto LABEL_21;
  }

  *(_DWORD *)(v12 + 52) = v15;
  *(_DWORD *)(v12 + 44) = (v15 + *(_DWORD *)(v12 + 164) - 1) / *(_DWORD *)(v12 + 164);
  atomic_store(*((void *)context + 341), (unint64_t *)(v12 + 32));
  if ((aeaCryptoInit((char *)(v12 + 216), (unsigned int *)(v12 + 144)) & 0x80000000) != 0)
  {
    uint64_t v16 = "Invalid container";
    __int16 v17 = 486;
    goto LABEL_20;
  }

  AAByteStream result = (AAByteStream)aeaContainerOffsetsInit(v12 + 424, (unsigned int *)(v12 + 144), (unsigned int *)(v12 + 216));
  if ((result & 0x80000000) != 0)
  {
    uint64_t v16 = "deriving container offsets";
    __int16 v17 = 487;
    goto LABEL_20;
  }

  uint64_t v20 = *(unsigned int *)(v12 + 228);
  if (v20 < 0x101)
  {
    __memcpy_chk();
    *(_DWORD *)(v12 + 528) = v20;
    memset_s((void *)(v12 + 532 + v20), 256 - v20, 0, 256 - v20);
    size_t v21 = *(void *)(v12 + 520);
    *(void *)(v12 + 1056) = v21;
    if (v21 < 0x2000000001LL)
    {
      char v23 = malloc(v21);
    }

    else
    {
      unint64_t v22 = __error();
      char v23 = 0LL;
      int *v22 = 12;
    }

    *(void *)(v12 + 1048) = v23;
    if (*(void *)(v12 + 176) < 0x10000uLL || DefaultNThreads == 1)
    {
      *(void *)(v12 + 96) = 0LL;
      uint64_t v41 = *(unsigned int *)(v12 + 168);
      if ((_DWORD)v41)
      {
        compression_algorithm v42 = aeaEffectiveCompressionAlgorithm(v41);
        size_t v43 = compression_decode_scratch_buffer_size(v42);
        *(void *)(v12 + 96) = v43;
      }

      else
      {
        size_t v43 = 0LL;
      }

      size_t v44 = *(unsigned int *)(v12 + 160);
      __int16 v45 = malloc(v44);
      *(void *)(v12 + 72) = v45;
      *(void *)(v12 + 80) = malloc(v44);
      if (v43)
      {
        if (v43 < 0x2000000001LL)
        {
          uint32_t v47 = malloc(v43);
        }

        else
        {
          AAFieldKey v46 = __error();
          uint32_t v47 = 0LL;
          *AAFieldKey v46 = 12;
          __int16 v45 = *(void **)(v12 + 72);
        }

        *(void *)(v12 + 88) = v47;
      }

      if (!v45 || !*(void *)(v12 + 80) || !*(void *)(v12 + 1048) || *(void *)(v12 + 96) && !*(void *)(v12 + 88))
      {
        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 513;
        goto LABEL_21;
      }
    }

    else
    {
      *(_DWORD *)(v12 + 112) = DefaultNThreads;
      uint64_t v24 = calloc(DefaultNThreads, 8uLL);
      *(void *)(v12 + 120) = v24;
      if (!v24)
      {
        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 520;
        goto LABEL_21;
      }

      uint64_t v32 = *(unsigned int *)(v12 + 112);
      if ((_DWORD)v32)
      {
        uint64_t v33 = 0LL;
        uint64_t v34 = 8 * v32;
        while (1)
        {
          unint64_t v35 = malloc(0x240uLL);
          if (!v35)
          {
            int v18 = *__error();
            uint64_t v16 = "malloc";
            __int16 v17 = 524;
            goto LABEL_21;
          }

          uint64_t v36 = v35;
          *(void *)(*(void *)(v12 + 120) + v33) = v35;
          *unint64_t v35 = v12;
          size_t v37 = *(unsigned int *)(v12 + 160);
          AAFieldKey v38 = malloc(v37);
          v36[69] = v38;
          uint64_t v39 = malloc(v37);
          v36[70] = v39;
          if (!v38 || v39 == 0LL) {
            break;
          }
          v33 += 8LL;
          if (v34 == v33) {
            goto LABEL_53;
          }
        }

        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 529;
        goto LABEL_21;
      }

      LODWORD(v37) = *(_DWORD *)(v12 + 160);
LABEL_53:
      uint64_t v48 = SharedBufferCreate((2 * v37), v25, v26, v27, v28, v29, v30, v31);
      *(void *)(v12 + 104) = v48;
      if (!v48)
      {
        uint64_t v16 = "creating shared buffer";
        __int16 v17 = 532;
        goto LABEL_20;
      }

      uint64_t v49 = ThreadPipelineCreate( *(_DWORD *)(v12 + 112),  *(void *)(v12 + 120),  (uint64_t)streamWorkerProc,  v12,  (uint64_t)streamConsumerProc,  0LL);
      *(void *)(v12 + 128) = v49;
      if (!v49)
      {
        uint64_t v16 = "creating pipeline";
        __int16 v17 = 534;
        goto LABEL_20;
      }

      if ((createThread((pthread_t *)(v12 + 136), (uint64_t)streamThreadProc, v12, 0LL) & 0x80000000) != 0)
      {
        uint64_t v16 = "Stream thread creation";
        __int16 v17 = 535;
        goto LABEL_20;
      }
    }

    __int128 v50 = *(_OWORD *)(v12 + 192);
    *((_OWORD *)context + 2) = *(_OWORD *)(v12 + 176);
    *((_OWORD *)context + 3) = v50;
    *((void *)context + 8) = *(void *)(v12 + 208);
    __int128 v51 = *(_OWORD *)(v12 + 160);
    *(_OWORD *)context = *(_OWORD *)(v12 + 144);
    *((_OWORD *)context + 1) = v51;
    v10[7] = aeaInputStreamCancel;
    void *v10 = v12;
    v10[1] = aeaInputStreamClose;
    v10[2] = aeaInputStreamRead;
    return (AAByteStream)v10;
  }

  __break(1u);
  return result;
}

uint64_t streamWorkerProc(uint64_t a1)
{
  uint64_t v1 = *(AAByteStream **)a1;
  if (!*(_DWORD *)(a1 + 568))
  {
    uint64_t v4 = (_DWORD *)(a1 + 8);
    if ((aeaInputStreamDecryptSegment( *(void *)a1,  (unsigned int *)(a1 + 8),  *(const uint8_t **)(a1 + 552),  *(uint8_t **)(a1 + 560)) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"streamWorkerProc",  298,  30,  0,  "decrypting segment %u",  v5,  v6,  *v4);
      aeaInputStreamCancel(v1, v7, v8, v9, v10, v11, v12, v13, v14);
      return 0xFFFFFFFFLL;
    }
  }

  return 0LL;
}

uint64_t streamConsumerProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (unsigned int *)(a1 + 24);
  if (*(_DWORD *)(a2 + 568))
  {
    while (!__ldaxr(v11))
    {
      if (!__stlxr(1u, v11))
      {
        SharedBufferWrite(*(unsigned int **)(a1 + 104), 0LL, 0LL, a4, a5, a6, a7, a8);
        return 0LL;
      }
    }

    uint64_t result = 0LL;
    __clrex();
  }

  else if (SharedBufferWrite( *(unsigned int **)(a1 + 104),  *(void *)(a2 + 560),  *(unsigned int *)(a2 + 12),  a4,  a5,  a6,  a7,  a8) == *(_DWORD *)(a2 + 12))
  {
    return 0LL;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"streamConsumerProc",  321,  30,  0,  "SharedBufferWrite",  v14,  v15,  v23);
    aeaInputStreamCancel((AAByteStream *)a1, v16, v17, v18, v19, v20, v21, v22, v24);
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t streamThreadProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 52))
  {
    int v9 = 0;
    int v10 = 1;
    while (1)
    {
      unsigned int v11 = atomic_load((unsigned int *)(a1 + 16));
      if (v11 || (unsigned int v12 = atomic_load((unsigned int *)(a1 + 20))) != 0)
      {
LABEL_13:
        if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52)) {
          goto LABEL_16;
        }
        goto LABEL_17;
      }

      uint64_t Worker = ThreadPipelineGetWorker(*(void *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
      if (!Worker)
      {
        uint64_t v40 = "getting worker from pipeline";
        __int16 v41 = 263;
        goto LABEL_26;
      }

      uint64_t v14 = Worker;
      *(_DWORD *)(Worker + 568) = 0;
      uint64_t v15 = (_DWORD *)(Worker + 8);
      memset_s((void *)(Worker + 8), 0x220uLL, 0, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, v15, *(void *)(v14 + 552), v16, v17, v18, v19, v20) & 0x80000000) != 0) {
        break;
      }
      if (!v10) {
        goto LABEL_10;
      }
LABEL_11:
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 68);
      if ((ThreadPipelineRunWorker(*(void *)(a1 + 128), v14, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0)
      {
        uint64_t v40 = "running worker";
        __int16 v41 = 269;
        goto LABEL_26;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"streamThreadProc",  266,  30,  0,  "loading segment",  v25,  v26,  v43);
LABEL_10:
    memset_s(v15, 0x220uLL, 0, 0x220uLL);
    int v10 = 0;
    goto LABEL_11;
  }

  int v10 = 1;
LABEL_16:
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    uint64_t v40 = "authenticating padding";
    __int16 v41 = 275;
LABEL_26:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"streamThreadProc",  v41,  30,  0,  v40,  a7,  a8,  v43);
LABEL_27:
    aeaInputStreamCancel((AAByteStream *)a1, v35, v36, v37, v38, v39, a7, a8, v43);
    return a1;
  }

uint64_t aeaInputStreamRead( uint64_t a1, uint64_t __dst, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  size_t v11 = a3;
  if (!a3) {
    return 0LL;
  }
  unsigned int v12 = (char *)__dst;
  size_t v14 = *(void *)(a1 + 104);
  if (v14)
  {
    uint64_t v9 = SharedBufferRead(v14, __dst, a3);
    if ((v9 & 0x8000000000000000LL) == 0) {
      return v9;
    }
    uint64_t v17 = "Multi-thread read";
    __int16 v18 = 353;
    goto LABEL_8;
  }

  uint64_t v9 = 0LL;
  unsigned int v26 = *(_DWORD *)(a1 + 64);
  do
  {
    unsigned int v27 = *(_DWORD *)(a1 + 68);
    if (v26 >= v27)
    {
      if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52)) {
        break;
      }
      bzero(__s, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, __s, *(void *)(a1 + 72), v28, v29, v30, v31, v32) & 0x80000000) != 0)
      {
        uint64_t v17 = "Segment load";
        __int16 v18 = 365;
        goto LABEL_8;
      }

      if ((aeaInputStreamDecryptSegment(a1, __s, *(const uint8_t **)(a1 + 72), *(uint8_t **)(a1 + 80)) & 0x80000000) != 0)
      {
        uint64_t v17 = "Segment decrypt";
        __int16 v18 = 366;
        goto LABEL_8;
      }

      memset_s(__s, 0x220uLL, 0, 0x220uLL);
      unsigned int v26 = *(_DWORD *)(a1 + 64);
      unsigned int v27 = *(_DWORD *)(a1 + 68);
    }

    size_t v33 = v27 - v26;
    if (v33 >= v11) {
      size_t v34 = v11;
    }
    else {
      size_t v34 = v33;
    }
    if (!v34) {
      break;
    }
    memcpy(v12, (const void *)(*(void *)(a1 + 80) + v26), v34);
    v9 += v34;
    v12 += v34;
    unsigned int v26 = *(_DWORD *)(a1 + 64) + v34;
    *(_DWORD *)(a1 + 64) = v26;
    v11 -= v34;
  }

  while (v11);
  if (v9) {
    return v9;
  }
  uint64_t v35 = (unsigned int *)(a1 + 28);
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, __dst, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    uint64_t v17 = "Padding authentication";
    __int16 v18 = 385;
LABEL_8:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamRead",  v18,  30,  0,  v17,  v15,  v16,  v38);
    aeaInputStreamCancel((AAByteStream *)a1, v19, v20, v21, v22, v23, v24, v25, v39);
    return -1LL;
  }

  uint64_t v9 = 0LL;
  while (!__ldaxr(v35))
  {
    if (!__stlxr(1u, v35)) {
      return v9;
    }
  }

  uint64_t v9 = 0LL;
  __clrex();
  return v9;
}

AAByteStream *aeaInputStreamCancel( AAByteStream *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = result;
  int v10 = (unsigned int *)(result + 2);
  do
  {
    if (__ldaxr(v10))
    {
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v10));
  AAByteStreamCancel(*result);
  uint64_t result = (AAByteStream *)v9[13];
  if (result) {
    return (AAByteStream *)SharedBufferAbort((size_t)result, v12, v13, v14, v15, v16, v17, v18, a9);
  }
  return result;
}

uint64_t aeaInputStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 136))
    {
      uint64_t v2 = (unsigned int *)(result + 20);
      while (!__ldaxr(v2))
      {
        if (!__stlxr(1u, v2)) {
          goto LABEL_8;
        }
      }

      __clrex();
LABEL_8:
      while (SharedBufferFlushToStream( *(void *)(v1 + 104),  0xFFFFFFFFFFFFFFFFLL,  (uint64_t (*)(uint64_t, uint64_t, unint64_t))sharedBufferWriteToDrain,  0LL) > 0)
        ;
      joinThread(*(_opaque_pthread_t **)(v1 + 136));
    }

    ThreadPipelineDestroy(*(void *)(v1 + 128));
    SharedBufferDestroy(*(void *)(v1 + 104));
    uint64_t v6 = *(void **)(v1 + 120);
    if (v6)
    {
      unint64_t v7 = *(unsigned int *)(v1 + 112);
      if ((_DWORD)v7)
      {
        for (unint64_t i = 0LL; i < v7; ++i)
        {
          uint64_t v9 = *(void ***)(*(void *)(v1 + 120) + 8 * i);
          if (v9)
          {
            free(v9[69]);
            free(v9[70]);
            free(v9);
            unint64_t v7 = *(unsigned int *)(v1 + 112);
          }
        }

        uint64_t v6 = *(void **)(v1 + 120);
      }

      free(v6);
    }

    unsigned int v10 = atomic_load((unsigned int *)(v1 + 16));
    if (v10) {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamClose",  438,  30,  0,  "Stream processing cancelled",  v4,  v5,  v15);
    }
    size_t v11 = *(void **)(v1 + 1048);
    if (v11) {
      memset_s(*(void **)(v1 + 1048), *(void *)(v1 + 1056), 0, *(void *)(v1 + 1056));
    }
    free(v11);
    uint64_t v12 = *(void **)(v1 + 72);
    if (v12) {
      memset_s(*(void **)(v1 + 72), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    }
    free(v12);
    uint64_t v13 = *(void **)(v1 + 80);
    if (v13) {
      memset_s(*(void **)(v1 + 80), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    }
    free(v13);
    uint64_t v14 = *(void **)(v1 + 88);
    if (v14) {
      memset_s(*(void **)(v1 + 88), *(void *)(v1 + 96), 0, *(void *)(v1 + 96));
    }
    free(v14);
    memset_s((void *)v1, 0x428uLL, 0, 0x428uLL);
    free((void *)v1);
    if (v10) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t aeaInputStreamDecryptSegment(uint64_t a1, unsigned int *a2, const uint8_t *a3, uint8_t *a4)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  int v36 = 0;
  memset(v35, 0, sizeof(v35));
  int v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v7 = a2[2];
  unsigned int v8 = *a2;
  unsigned int v9 = *(_DWORD *)(a1 + 164);
  int v38 = 0;
  memset(v37, 0, sizeof(v37));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(void *)int __s = 0x5F41454100000006LL;
  memset(v39, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v8 / v9;
  *(_DWORD *)int __s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  unsigned int v10 = *(uint64_t (**)(_OWORD *, void))(a1 + 288);
  if (v10 && *(_DWORD *)(a1 + 788))
  {
    int v11 = v10(v37, *(unsigned int *)(a1 + 216));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    int v12 = 0;
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_8;
    }
  }

  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }

  int v12 = 1;
LABEL_8:
  memset((char *)v39 + 8, 0, 224);
  memset((char *)&v39[14] + 8, 0, 28);
  WORD4(v39[0]) = 19283;
  *(void *)&v39[0] = 0x5F41454100000006LL;
  memset_s((char *)v39 + 10, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v13 = LODWORD(v39[0]);
  if (LODWORD(v39[0]) >= 0xFD) {
    __break(1u);
  }
  *(_DWORD *)((char *)v39 + LODWORD(v39[0]) + 4) = v8 % v9;
  LODWORD(v39[0]) = v13 + 4;
  memset_s((char *)v39 + v13 + 8, 252 - v13, 0, 252 - v13);
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _BYTE *))(a1 + 288);
  if (!v14 || !LODWORD(v37[0]))
  {
    memset_s(v39, 0x104uLL, 0, 0x104uLL);
    goto LABEL_23;
  }

  int v15 = v14(v35, *(unsigned int *)(a1 + 220), v37, v39, __s);
  memset_s(v39, 0x104uLL, 0, 0x104uLL);
  if (v15 < 0)
  {
LABEL_23:
    memset_s(v37, 0x104uLL, 0, 0x104uLL);
    goto LABEL_24;
  }

  memset_s(v37, 0x104uLL, 0, 0x104uLL);
  if (v12)
  {
LABEL_24:
    unsigned int v26 = "derivating segment key";
    __int16 v27 = 122;
    goto LABEL_25;
  }

  uint64_t v18 = *(uint64_t (**)(const uint8_t *, uint64_t))(a1 + 312);
  if (v18 && a2[71] == *(_DWORD *)(a1 + 228) && (v18(a3, v7) & 0x80000000) == 0)
  {
    uint64_t v19 = *(unsigned int *)(a1 + 168);
    size_t v20 = a2[1];
    if ((_DWORD)v19 && (size_t v21 = a2[2], v20 > v21))
    {
      if ((_DWORD)v19 == 774)
      {
        int64_t v22 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 160), a3, v21);
        if (v22 >= 0) {
          size_t v25 = v22;
        }
        else {
          size_t v25 = 0LL;
        }
      }

      else
      {
        compression_algorithm v30 = aeaEffectiveCompressionAlgorithm(v19);
        size_t v25 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 160), a3, a2[2], *(void **)(a1 + 88), v30);
      }
    }

    else
    {
      memcpy(a4, a3, v20);
      size_t v25 = a2[1];
    }

    if (v25 == a2[1])
    {
      if ((aeaChecksum((uint64_t)v33, *(_DWORD *)(a1 + 156), a4, v25, v23, v24, v16, v17) & 0x80000000) == 0)
      {
        uint64_t v28 = 0LL;
        goto LABEL_26;
      }

      unsigned int v26 = "computing segment checksum";
      __int16 v27 = 151;
    }

    else
    {
      unsigned int v26 = "Segment decompression";
      __int16 v27 = 148;
    }
  }

  else
  {
    unsigned int v26 = "decrypting segment";
    __int16 v27 = 125;
  }

uint64_t aeaInputStreamLoadSegment( uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(result + 64) < *(_DWORD *)(result + 68))
  {
    unsigned int v8 = "Truncated segment";
    __int16 v9 = 168;
LABEL_3:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamLoadSegment",  v9,  30,  0,  v8,  a7,  a8,  v45[0]);
    return 0xFFFFFFFFLL;
  }

  uint64_t v10 = result;
  if (*(_DWORD *)(result + 48) >= *(_DWORD *)(result + 52)) {
    return 0LL;
  }
  unsigned int v13 = *(_DWORD *)(result + 60);
  if (*(_DWORD *)(result + 56) >= v13)
  {
    int v46 = 0;
    memset(v45, 0, sizeof(v45));
    if (*(_DWORD *)(result + 40) >= *(_DWORD *)(result + 44))
    {
LABEL_39:
      if (!v13)
      {
LABEL_41:
        unsigned int v8 = "Invalid state";
        __int16 v9 = 177;
        goto LABEL_3;
      }

      goto LABEL_40;
    }

    uint64_t v14 = *(void *)result;
    uint64_t v15 = *(void *)(result + 520);
    if (*(void *)(*(void *)result + 16LL))
    {
      if (!v15) {
        goto LABEL_19;
      }
      uint64_t v16 = 0LL;
      uint64_t v17 = *(void *)(result + 1048);
      while (1)
      {
        uint64_t v18 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v14 + 16))(*(void *)v14, v17, v15);
        if (v18 < 0) {
          break;
        }
        if (v18)
        {
          v17 += v18;
          v16 += v18;
          v15 -= v18;
          if (v15) {
            continue;
          }
        }

        goto LABEL_17;
      }

      uint64_t v16 = v18;
LABEL_17:
      uint64_t v15 = *(void *)(v10 + 520);
    }

    else
    {
      uint64_t v16 = -1LL;
    }

    if (v16 != v15)
    {
      size_t v25 = "loading cluster header";
      __int16 v26 = 86;
      goto LABEL_58;
    }

uint64_t aeaInputStreamAuthenticatePadding( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  if (*((_DWORD *)a1 + 12) < *((_DWORD *)a1 + 13))
  {
    unsigned int v8 = "Invalid state";
    __int16 v9 = 220;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamAuthenticatePadding",  v9,  30,  0,  v8,  a7,  a8,  v39);
    int v14 = 0;
    uint64_t v15 = 0LL;
    goto LABEL_6;
  }

  int v11 = (unint64_t *)(a1 + 4);
  unint64_t v12 = atomic_load((unint64_t *)a1 + 4);
  unint64_t v13 = a1[23];
  if (v12 > v13)
  {
    unsigned int v8 = "Invalid container offset";
    __int16 v9 = 221;
    goto LABEL_5;
  }

  unint64_t v17 = atomic_load(v11);
  unint64_t v18 = v13 - v17;
  if (v13 == v17)
  {
    uint64_t v15 = 0LL;
    int v14 = 1;
    goto LABEL_6;
  }

  uint64_t v15 = (char *)malloc(0x100000uLL);
  if (!v15)
  {
    unsigned int v31 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamAuthenticatePadding",  227,  30,  *v31,  "malloc",  v32,  v33,  v39);
    int v14 = 0;
    goto LABEL_6;
  }

  int v59 = 0;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 __s = 0u;
  __int128 v44 = 0u;
  int v42 = 0;
  memset(v41, 0, sizeof(v41));
  if (a1[49]
    && (*(_DWORD *)((char *)v41 + 7) = 1262571615,
        *(void *)&v41[0] = 0x5F41454100000007LL,
        memset_s((void *)((unint64_t)v41 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (uint64_t v19 = (uint64_t (*)(__int128 *, void))a1[36]) != 0LL)
    && *((_DWORD *)a1 + 197)
    && (v19(&__s, *((unsigned int *)a1 + 54)) & 0x80000000) == 0)
  {
    uint64_t v20 = ((uint64_t (*)(__int128 *))a1[49])(&__s);
  }

  else
  {
    uint64_t v20 = 0LL;
  }

  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v41, 0x104uLL, 0, 0x104uLL);
  if (v20)
  {
    uint64_t v40 = v20;
    int v14 = 1;
    while (1)
    {
      uint64_t v23 = v18 >= 0x100000 ? 0x100000LL : v18;
      uint64_t v24 = *a1;
      if (!*(void *)(*a1 + 16)) {
        break;
      }
      uint64_t v25 = 0LL;
      __int16 v26 = v15;
      uint64_t v27 = v23;
      while (1)
      {
        uint64_t v28 = (*(uint64_t (**)(void, char *, uint64_t))(v24 + 16))(*(void *)v24, v26, v27);
        if (v28 < 0) {
          break;
        }
        if (v28)
        {
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (v27) {
            continue;
          }
        }

        goto LABEL_30;
      }

      uint64_t v25 = v28;
LABEL_30:
      if (v25 != v23) {
        break;
      }
      uint64_t v29 = (uint64_t (*)(uint64_t, char *, uint64_t))a1[50];
      if (!v29 || (v29(v40, v15, v23) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamAuthenticatePadding",  240,  30,  0,  "authenticating padding",  v21,  v22,  v39);
        int v14 = 0;
      }

      do
        unint64_t v30 = __ldaxr(v11);
      while (__stlxr(v30 + v23, v11));
      v18 -= v23;
      if (!v18) {
        goto LABEL_39;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamAuthenticatePadding",  239,  30,  0,  "reading padding",  v21,  v22,  v39);
    int v14 = 0;
LABEL_39:
    int v59 = 0;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 __s = 0u;
    __int128 v44 = 0u;
    uint64_t v34 = (uint64_t (*)(uint64_t, __int128 *))a1[51];
    if (v34)
    {
      if (*((_DWORD *)a1 + 132) == *((_DWORD *)a1 + 57)
        && (v34(v40, &__s) & 0x80000000) == 0
        && (_DWORD)__s == *((_DWORD *)a1 + 57))
      {
        uint64_t v35 = 0LL;
        uint64_t v36 = 0LL;
        do
        {
          v36 |= *(void *)((char *)&__s + v35 * 8 + 4) ^ *(uint64_t *)((char *)&a1[v35 + 66] + 4);
          unint64_t v37 = v35 * 8 + 16;
          ++v35;
        }

        while (v37 <= __s);
        if (!v36)
        {
LABEL_51:
          memset_s(&__s, 0x104uLL, 0, 0x104uLL);
          goto LABEL_50;
        }
      }
    }

    memset_s(&__s, 0x104uLL, 0, 0x104uLL);
    __int16 v38 = 245;
  }

  else
  {
    __int16 v38 = 230;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c",  (uint64_t)"aeaInputStreamAuthenticatePadding",  v38,  30,  0,  "authenticating padding",  v21,  v22,  v39);
  int v14 = 0;
LABEL_50:
  memset_s(v15, 0x100000uLL, 0, 0x100000uLL);
LABEL_6:
  free(v15);
  if (v14) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sharedBufferWriteToDrain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *aaCacheStreamOpen(AAByteStream_impl *a1, unint64_t a2, int a3, int a4, unint64_t a5)
{
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  int v11 = calloc(1uLL, 0x70uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v11 || !v10)
  {
    int v18 = *__error();
    uint64_t v16 = "aaCalloc";
    __int16 v17 = 472;
LABEL_18:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamOpen",  v17,  146,  v18,  v16,  v12,  v13,  v35);
    free(v10);
    aaCacheStreamClose(v14, v27, v28, v29, v30, v31, v32, v33);
    return 0LL;
  }

  *(void *)int v11 = a1;
  v11[26] = a4;
  v11[27] = a5 >> 62;
  uint64_t v15 = ((1 << a3) - 1);
  v11[23] = 1 << a3;
  v11[24] = v15;
  v11[21] = (v15 | a2) >> a3;
  v11[22] = a3;
  if (a2 - 1073741825 <= 0xFFFFFFFFBFFFFFFFLL)
  {
    uint64_t v16 = "cache too big";
    __int16 v17 = 484;
LABEL_17:
    int v18 = 0;
    goto LABEL_18;
  }

  off_t v19 = AAByteStreamSeek(a1, 0LL, 2);
  *(void *)(v14 + 24) = v19;
  *(void *)(v14 + 32) = v19;
  if (v19 < 0)
  {
    uint64_t v16 = "AAByteStreamSeek";
    __int16 v17 = 488;
    goto LABEL_17;
  }

  size_t v20 = *(unsigned int *)(v14 + 84);
  if (v20 >= 0xCCCCCCCD)
  {
    *__error() = 12;
    *(void *)(v14 + 72) = 0LL;
LABEL_16:
    uint64_t v16 = "aaCalloc";
    __int16 v17 = 492;
    goto LABEL_17;
  }

  uint64_t v21 = calloc(v20, 0x28uLL);
  *(void *)(v14 + 72) = v21;
  if (!v21) {
    goto LABEL_16;
  }
  if (*(_DWORD *)(v14 + 84))
  {
    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    size_t v24 = *(unsigned int *)(v14 + 92);
    while (1)
    {
      uint64_t v25 = calloc(1uLL, v24);
      uint64_t v26 = *(void *)(v14 + 72) + v22;
      *(void *)(v26 + 16) = v25;
      if (!v25) {
        break;
      }
      bzero(v25, *(unsigned int *)(v14 + 92));
      *(void *)uint64_t v26 = -1LL;
      size_t v24 = *(unsigned int *)(v14 + 92);
      *(_DWORD *)(v26 + 28) = 0;
      *(_DWORD *)(v26 + 32) = 0;
      *(_DWORD *)(v26 + 24) = v24;
      ++v23;
      v22 += 40LL;
    }

    uint64_t v16 = "aaCalloc";
    __int16 v17 = 498;
    goto LABEL_17;
  }

LABEL_15:
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetSeekProc((AAByteStream)v10, (AAByteStreamSeekProc)aaCacheStreamSeek);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)aaCacheStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)aaCacheStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v10, (AAByteStreamReadProc)aaCacheStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v10, (AAByteStreamWriteProc)aaCacheStreamWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)aaCacheStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)aaCacheStreamClose);
  v10[8] = aaCacheStreamTruncate;
  return v10;
}

  void *v10 = 47;
  if (fstatat(*(_DWORD *)(a1 + 2064), v11, &v39, 32) < 0)
  {
    if (*__error() == 2) {
      goto LABEL_19;
    }
    off_t v19 = *__error();
    __int16 v17 = __s;
    int v18 = 128;
LABEL_12:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"processEntry",  v18,  123,  v19,  v17,  v7,  v8,  v38);
LABEL_13:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"processEntry",  167,  123,  0,  "Entry failed: %s",  v20,  v21,  (char)v6);
    return 0xFFFFFFFFLL;
  }

  size_t v24 = aaEntryTypeFromMode(v39.st_mode);
  uint64_t v25 = *((unsigned __int16 *)a2 + 2);
  if (v24 == v25)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 1;
  }

  else
  {
    uint64_t v30 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (!v30) {
      goto LABEL_28;
    }
    uint64_t v31 = v30(*((void *)v5 + 129), 83LL, v6, 0LL);
    uint64_t v26 = v31 == 0;
    uint64_t v27 = v31 >= 0;
    if (v31 < 1) {
      goto LABEL_26;
    }
    uint64_t v25 = *((unsigned __int16 *)a2 + 2);
  }

  if (unlinkat(*(_DWORD *)(a1 + 2064), v11, (v25 == 68) << 7) < 0)
  {
    uint64_t v36 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (v36)
    {
      unint64_t v37 = v36(*((void *)v5 + 129), 84LL, v6, 0LL);
      if (!v37) {
        uint64_t v26 = 1;
      }
      if (v37 < 0) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v26 = 1;
    }
  }

  if (v16 != v19)
  {
LABEL_20:
    uint64_t v21 = "loading segment";
    uint64_t v22 = 471;
    goto LABEL_41;
  }

  uint64_t v40 = v18;
  uint64_t v41 = v19;
  unint64_t v23 = *(_DWORD *)(a1 + 20);
  memset(v49, 0, 260);
  memset(&__s[2], 0, 252);
  memset(v50, 0, 260);
  qmemcpy(&__s[1], "AEA_CK", 6);
  memset_s((char *)&__s[2] + 2, 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)((char *)&__s[2] + 2) = a3 / v23;
  __s[0] = 10;
  memset_s((char *)&__s[3] + 2, 0xF6uLL, 0, 0xF6uLL);
  size_t v24 = *(uint64_t (**)(_DWORD *, void))(a1 + 144);
  if (v24 && *(_DWORD *)(a1 + 668))
  {
    uint64_t v25 = v24(v49, *(unsigned int *)(a1 + 72));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    uint64_t v26 = 0;
    if ((v25 & 0x80000000) == 0) {
      goto LABEL_23;
    }
  }

  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }

  uint64_t v26 = 1;
LABEL_23:
  memset(&v50[2], 0, 252);
  qmemcpy(&v50[1], "AEA_SK", 6);
  v50[0] = 6;
  uint64_t result = memset_s((char *)&v50[2] + 2, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v28 = v50[0];
  if (v50[0] < 0xFDu)
  {
    *(_DWORD *)((char *)&v50[1] + v50[0]) = a3 % v23;
    v50[0] = v28 + 4;
    memset_s((char *)&v50[2] + v28, 252 - v28, 0, 252 - v28);
    memset(__s, 0, 260);
    uint64_t v29 = *(uint64_t (**)(_BYTE *, void, _DWORD *, _DWORD *, _DWORD *))(a1 + 144);
    if (v29 && v49[0])
    {
      uint64_t v30 = v29(v48, *(unsigned int *)(a1 + 76), v49, v50, __s);
      memset_s(v50, 0x104uLL, 0, 0x104uLL);
      if ((v30 & 0x80000000) == 0)
      {
        memset_s(v49, 0x104uLL, 0, 0x104uLL);
        if (!v26)
        {
          uint64_t v31 = *(uint64_t (**)(char *, size_t))(a1 + 168);
          if (v31 && *(_DWORD *)(v44 + 544LL * a3 + 284) == *(_DWORD *)(a1 + 84) && (v31(v40, v41) & 0x80000000) == 0)
          {
            uint64_t v34 = __n;
            if (v8)
            {
              char v35 = *(unsigned int *)(a1 + 24);
              if ((_DWORD)v35 && __n > v41)
              {
                if ((_DWORD)v35 == 774)
                {
                  uint64_t v36 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 16), a5, v41);
                  if (v36 >= 0) {
                    uint64_t v36 = v36;
                  }
                  else {
                    uint64_t v36 = 0LL;
                  }
                }

                else
                {
                  unint64_t v37 = aeaEffectiveCompressionAlgorithm(v35);
                  uint64_t v36 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 16), a5, v41, a6, v37);
                }

                if (v36 != __n)
                {
                  uint64_t v21 = "Segment decompression";
                  uint64_t v22 = 511;
                  goto LABEL_41;
                }
              }

              else
              {
                memcpy(a4, a5, __n);
              }
            }

            if ((aeaChecksum((uint64_t)v50, *(_DWORD *)(a1 + 12), a4, __n, v32, v33, a7, a8) & 0x80000000) != 0)
            {
              uint64_t v21 = "computing segment checksum";
              uint64_t v22 = 515;
            }

            else
            {
              __int16 v38 = *(unsigned int *)(a1 + 48);
              uint64_t v21 = "Checksum verification failed, data corrupted";
              uint64_t v22 = 519;
            }
          }

          else
          {
            uint64_t v21 = "decrypting segment data";
            uint64_t v22 = 485;
          }

  if (a1[1])
  {
    uint64_t v27 = 0;
    if (fcntl(*a1, 51) == -1)
    {
      size_t v20 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamDestroyEx",  883,  29,  *v20,  "Final FULLSYNC",  v21,  v22,  0);
    }
  }

  off_t v19 = *a1;
  if (!v10)
  {
    if (close(*a1))
    {
      size_t v24 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamDestroyEx",  890,  29,  *v24,  "close",  v25,  v26,  v27);
    }

    off_t v19 = 0xFFFFFFFFLL;
    *a1 = -1;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (a3) {
LABEL_20:
  }
    *a3 = *((void *)a1 + 4) - v13;
LABEL_21:
  if (a4) {
    *a4 = v13;
  }
  free(*((void **)a1 + 8));
  free(a1);
  return v19;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineCreate",  v27,  87,  v23,  v26,  v24,  v25,  v42);
  ThreadPipelineDestroy((uint64_t)v13);
  return 0LL;
}

    uint64_t v16 = *v15;
    __int16 v17 = realloc(*v15, v13);
    if (v17)
    {
      *(void *)(a1 + 120) = v13;
      *(void *)(a1 + 128) = v17;
      uint64_t v10 = *(void *)(a1 + 112);
      goto LABEL_17;
    }

    free(v16);
LABEL_28:
    *uint64_t v15 = 0LL;
    _DWORD *v11 = 0LL;
    *(void *)(a1 + 120) = 0LL;
LABEL_29:
    uint64_t v21 = "allocating blob buffer";
    uint64_t v22 = 87;
    goto LABEL_39;
  }

      __break(1u);
      return result;
    }

    unsigned int v8 = "generate random field";
    __int16 v9 = 520;
  }

  else
  {
    unsigned int v8 = "Invalid field";
    __int16 v9 = 532;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextGenerateFieldBlob",  v9,  57,  0,  v8,  v2,  v3,  v10);
  return -1;
}

  uint64_t v15 = 0;
LABEL_16:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadRemainingRange",  v14,  115,  v15,  v13,  v6,  v7,  v17);
  close(v5);
LABEL_17:
  AAByteRangeDestroy(v8);
  return 0LL;
}

      uint64_t v22 = 0;
      goto LABEL_16;
    }
  }

  uint64_t v22 = *__error();
  unint64_t v23 = "malloc";
  size_t v24 = 1610;
LABEL_16:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"AAExtractArchiveOutputStreamOpen",  v24,  72,  v22,  v23,  v14,  v15,  v47);
  free(v11);
  extractStreamClose(v13, v25, v26, v27, v28, v29, v30, v31);
  return 0LL;
}

    if (!pthread_mutex_lock(v16))
    {
      while (1)
      {
        uint64_t v26 = *(_DWORD *)(v8 + 48);
        if (v26 > 0) {
          break;
        }
        if (pthread_cond_wait(v17, v16)) {
          goto LABEL_20;
        }
      }

      *(_DWORD *)(v8 + 48) = v26 - 1;
      pthread_mutex_unlock(v16);
    }

  if (v17 != EncodedSize)
  {
    size_t v20 = "write header";
    uint64_t v21 = 477;
    goto LABEL_18;
  }

  uint64_t v22 = 0LL;
LABEL_19:
  AAHeaderDestroy(v9);
  return v22;
}

      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v11,  0,  v12,  v8,  v9,  v10,  v24);
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c",  (uint64_t)"ThreadPoolSync",  231,  90,  0,  "SharedArrayPop",  v14,  v15,  v25);
      uint64_t v7 = 0;
LABEL_16:
      if (++v6 == v3)
      {
        if (!*a1) {
          goto LABEL_30;
        }
        goto LABEL_21;
      }
    }
  }

  uint64_t v7 = 1;
LABEL_21:
  uint64_t v16 = 0LL;
  __int16 v17 = 0LL;
  do
  {
    int v18 = *((void *)a1 + 1);
    if (*(void *)(v18 + v16))
    {
      if ((off_t v19 = v18 + v16, *(void *)(v18 + v16 + 160) = -2LL,
                             pthread_mutex_lock((pthread_mutex_t *)(v18 + v16 + 48)))
        || (uint64_t v22 = *(_DWORD *)(v19 + 40), *(_DWORD *)(v19 + 40) = v22 + 1, !v22)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + v16 + 112))
        || pthread_mutex_unlock((pthread_mutex_t *)(v18 + v16 + 48)))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c",  (uint64_t)"ThreadPoolSync",  240,  90,  0,  "SemRelease",  v20,  v21,  v24);
        uint64_t v7 = 0;
      }
    }

    ++v17;
    v16 += 168LL;
  }

  while (v17 < *a1);
LABEL_30:
  if (v7) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  size_t v24 = 0;
LABEL_16:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"AEADecryptToStreamChunk",  v23,  128,  v24,  v22,  v20,  v21,  v71);
  uint64_t v25 = 0;
LABEL_17:
  if (DefaultNThreads >= 1)
  {
    do
    {
      if (!pthread_mutex_lock((pthread_mutex_t *)&v86[72]))
      {
        uint64_t v26 = (*(_DWORD *)&v86[64])++;
        if (v26 || !pthread_cond_broadcast((pthread_cond_t *)&v86[136])) {
          pthread_mutex_unlock((pthread_mutex_t *)&v86[72]);
        }
      }

      --DefaultNThreads;
    }

    while (DefaultNThreads);
  }

  if ((ThreadPoolDestroy((uint64_t)v85[1]) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"AEADecryptToStreamChunk",  373,  128,  0,  "Readers reported errors",  v27,  v28,  v71);
    uint64_t v25 = 0;
  }

  if ((AAAsyncByteStreamClose(*((uint64_t (***)(void))&v77 + 1)) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"AEADecryptToStreamChunk",  374,  128,  0,  "Async stream reported errors",  v29,  v30,  v71);
    uint64_t v25 = 0;
  }

  if ((AAAsyncByteStreamClose((uint64_t (**)(void))v77) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"AEADecryptToStreamChunk",  375,  128,  0,  "Async stream reported errors",  v31,  v32,  v71);
    uint64_t v25 = 0;
  }

  pthread_mutex_destroy((pthread_mutex_t *)v86);
  if (!pthread_mutex_destroy((pthread_mutex_t *)&v86[72])) {
    pthread_cond_destroy((pthread_cond_t *)&v86[136]);
  }
  uint64_t v33 = (void *)*((void *)&v87 + 1);
  if (*((void *)&v87 + 1))
  {
    if ((void)__count)
    {
      uint64_t v34 = 0LL;
      char v35 = 0LL;
      do
      {
        free(*(void **)(*((void *)&v87 + 1) + v34));
        ++v35;
        v34 += 24LL;
      }

      while (v35 < (unint64_t)__count);
      uint64_t v33 = (void *)*((void *)&v87 + 1);
    }

    free(v33);
  }

  free(v84[1]);
  free(v85[0]);
  if (v25) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

    off_t v19 = v15 >= v14;
    size_t v20 = v15 - v14;
    if (!v19 || v15 >= *(_DWORD *)(a1 + 32))
    {
      uint64_t v31 = "could not move input page in cache";
      uint64_t v32 = 273;
      goto LABEL_27;
    }

    uint64_t v21 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v21 + 1;
    *(_DWORD *)(*(void *)(a1 + 96) + 4LL * v20) = v21;
    uint64_t v22 = cacheData(a1, v15, v18, a4, a5, a6, a7, a8);
    if (!v22) {
      goto LABEL_28;
    }
    memcpy(v8, (const void *)(v22 + (a2 & 0xFFF)), v13);
    PagedFileReleaseIn(a1, a2, v13, v25, v26, v27, v28, v29);
    a2 += v13;
    v8 += v13;
    v9 -= v13;
    if (!v9) {
      return 0LL;
    }
  }

  if (!movePage(a1, v15, v18, a4, a5, a6, a7, a8))
  {
    LODWORD(v15) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v16);
    uint64_t v14 = *(_DWORD *)(a1 + 24);
    goto LABEL_15;
  }

  uint64_t v31 = "moving page from disk to cache";
  uint64_t v32 = 268;
LABEL_27:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c",  (uint64_t)"inputPageData",  v32,  21,  0,  v31,  a7,  a8,  v33);
LABEL_28:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c",  (uint64_t)"PagedFileReadAndReleaseIn",  615,  21,  0,  "unable to load input page",  v23,  v24,  v33);
  return 0xFFFFFFFFLL;
}

uint64_t aaCacheStreamSeek( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1LL;
  }
  if (a3)
  {
    if (a3 == 2)
    {
      unsigned int v8 = (void *)(a1 + 24);
    }

    else
    {
      if (a3 != 1)
      {
LABEL_10:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamSeek",  392,  146,  0,  "bad seek",  a7,  a8,  vars0);
        return -1LL;
      }

      unsigned int v8 = (void *)(a1 + 16);
    }

    a2 += *v8;
  }

  if (a2 < 0) {
    goto LABEL_10;
  }
  *(void *)(a1 + 16) = a2;
  return a2;
}

uint64_t aaCacheStreamPRead( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1LL;
  }
  uint64_t v9 = a4;
  uint64_t v11 = *(void *)(a1 + 24);
  BOOL v12 = v11 <= a4;
  int64_t v13 = v11 - a4;
  if (v12) {
    return 0LL;
  }
  if (v13 >= a3) {
    unint64_t v14 = a3;
  }
  else {
    unint64_t v14 = v13;
  }
  if (v14)
  {
    uint64_t v8 = 0LL;
    while (1)
    {
      unint64_t v16 = *(unsigned int *)(a1 + 96);
      else {
        size_t v17 = *(unsigned int *)(a1 + 92) - (v9 & v16);
      }
      int v18 = cachePageGet(a1, v9 & ~v16, a3, a4, a5, a6, a7, a8);
      if (!v18)
      {
        uint64_t v29 = "cachePageGet";
        __int16 v30 = 224;
        goto LABEL_25;
      }

      uint64_t v25 = v18;
      uint64_t v26 = v16 & v9;
      if ((v26 < *((_DWORD *)v18 + 6) || (v26 + v17) > *((_DWORD *)v18 + 7))
        && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v18, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        break;
      }

      memcpy(a2, (const void *)(*((void *)v25 + 2) + v26), v17);
      ++*(void *)(a1 + 40);
      uint64_t v27 = *(void *)(a1 + 8) + 1LL;
      *(void *)(a1 + 8) = v27;
      *((void *)v25 + 1) = v27;
      if ((v17 & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
      v8 += v17;
      a2 += v17;
      v9 += v17;
      v14 -= v17;
      if (!v14) {
        goto LABEL_21;
      }
    }

    uint64_t v29 = "cachePageReadFromDisk";
    __int16 v30 = 229;
LABEL_25:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cacheRead",  v30,  146,  0,  v29,  v23,  v24,  v31);
LABEL_26:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamPRead",  313,  146,  0,  "cacheRead",  a7,  a8,  v31);
    return -1LL;
  }

  uint64_t v8 = 0LL;
LABEL_21:
  *(void *)(a1 + 16) = v9;
  return v8;
}

uint64_t aaCacheStreamPWrite( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1LL;
  }
  uint64_t v8 = a4;
  unint64_t v9 = a3;
  if (a3)
  {
    uint64_t v12 = 0LL;
    while (1)
    {
      unint64_t v13 = *(unsigned int *)(a1 + 96);
      else {
        size_t v14 = *(unsigned int *)(a1 + 92) - (v8 & v13);
      }
      uint64_t v15 = cachePageGet(a1, v8 & ~v13, a3, a4, a5, a6, a7, a8);
      if (!v15)
      {
        __int16 v30 = "cachePageGet";
        __int16 v31 = 254;
        goto LABEL_28;
      }

      uint64_t v22 = v15;
      uint64_t v23 = v13 & v8;
      unsigned int v24 = v23 + v14;
      unsigned int v25 = *((_DWORD *)v15 + 6);
      unsigned int v26 = *((_DWORD *)v15 + 7);
      if (v25 < v26)
      {
        BOOL v27 = v24 < v25 || v23 > v26;
        if (v27
          && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
        {
          break;
        }
      }

      memcpy((void *)(*((void *)v22 + 2) + v23), a2, v14);
      ++*(void *)(a1 + 48);
      if (v24 > *((_DWORD *)v22 + 7)) {
        *((_DWORD *)v22 + 7) = v24;
      }
      uint64_t v28 = *(void *)(a1 + 8) + 1LL;
      *(void *)(a1 + 8) = v28;
      *((void *)v22 + 1) = v28;
      *((_DWORD *)v22 + 8) = 1;
      uint64_t v29 = v8 + (int)v14;
      if (*(void *)(a1 + 24) < v29) {
        *(void *)(a1 + 24) = v29;
      }
      if ((v14 & 0x8000000000000000LL) != 0) {
        goto LABEL_29;
      }
      v12 += v14;
      a2 += v14;
      v8 += v14;
      v9 -= v14;
      if (!v9) {
        goto LABEL_25;
      }
    }

    __int16 v30 = "cachePageReadFromDisk";
    __int16 v31 = 262;
LABEL_28:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cacheWrite",  v31,  146,  0,  v30,  v20,  v21,  v33);
LABEL_29:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamPWrite",  346,  146,  0,  "cacheWrite",  a7,  a8,  v33);
    return -1LL;
  }

  uint64_t v12 = 0LL;
LABEL_25:
  *(void *)(a1 + 16) = v8;
  return v12;
}

uint64_t aaCacheStreamRead( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPRead(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamWrite( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPWrite(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamCancel(uint64_t result)
{
  *(_DWORD *)(result + 100) = 1;
  return result;
}

uint64_t aaCacheStreamClose( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if (*(void *)(result + 72))
    {
      if ((cacheFlush(result, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamClose",  440,  146,  0,  "cacheFlush",  v9,  v10,  v16);
        int v11 = 0;
      }

      else
      {
        int v11 = 1;
      }

      if (*(_DWORD *)(v8 + 84))
      {
        unint64_t v12 = 0LL;
        uint64_t v13 = 16LL;
        do
        {
          free(*(void **)(*(void *)(v8 + 72) + v13));
          ++v12;
          v13 += 40LL;
        }

        while (v12 < *(unsigned int *)(v8 + 84));
      }

      free(*(void **)(v8 + 72));
    }

    else
    {
      int v11 = 1;
    }

    if (*(_DWORD *)(v8 + 104) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamClose",  446,  146,  0,  "AAByteStreamClose",  v14,  v15,  v16);
      int v11 = 0;
    }

    if (*(int *)(v8 + 108) >= 1) {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "CacheStream: read ops %zu/%zu, write ops %zu/%zu\n",  *(void *)(v8 + 56),  *(void *)(v8 + 40),  *(void *)(v8 + 64),  *(void *)(v8 + 48));
    }
    free((void *)v8);
    if (v11) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t aaCacheStreamTruncate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 100))
  {
    if ((cacheFlush(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v13 = "cacheFlush";
      __int16 v14 = 411;
    }

    else
    {
      if ((AAByteStreamTruncate(*(void **)a1) & 0x80000000) == 0)
      {
        uint64_t result = 0LL;
        *(void *)(a1 + 24) = a2;
        *(void *)(a1 + 32) = a2;
        return result;
      }

      uint64_t v13 = "AAByteStreamTruncate";
      __int16 v14 = 412;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"aaCacheStreamTruncate",  v14,  146,  0,  v13,  v10,  v11,  v15);
  }

  return 0xFFFFFFFFLL;
}

__int128 *cachePageGet( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 72);
  unsigned int v9 = *(_DWORD *)(a1 + 84) - 1;
  unsigned int v10 = v9 & ((unint64_t)(0x16069317E428CA9LL * a2) >> 32);
  uint64_t v11 = (__int128 *)(v8 + 40LL * v10);
  if (*(void *)v11 != a2)
  {
    unsigned int v14 = v10 & 0xFFFFFC00;
    unsigned int v15 = v10 | 0x3FF;
    if ((v10 | 0x3FF) >= v9) {
      unsigned int v15 = *(_DWORD *)(a1 + 84) - 1;
    }
    if (v14 <= v15)
    {
      unsigned int v16 = v10 & 0xFFFFFC00;
      while (*(void *)(v8 + 40LL * v14) != a2)
      {
        if (*(void *)(v8 + 40LL * v14 + 8) < *(void *)(v8 + 40LL * v16 + 8)) {
          unsigned int v16 = v14;
        }
        if (++v14 > v15) {
          goto LABEL_11;
        }
      }
    }

    unsigned int v16 = v14;
LABEL_11:
    uint64_t v17 = *((void *)v11 + 4);
    __int128 v19 = *v11;
    __int128 v18 = v11[1];
    uint64_t v20 = (__int128 *)(v8 + 40LL * v16);
    uint64_t v21 = *((void *)v20 + 4);
    __int128 v22 = v20[1];
    __int128 *v11 = *v20;
    v11[1] = v22;
    *((void *)v11 + 4) = v21;
    uint64_t v23 = *(void *)(a1 + 72) + 40LL * v16;
    *(_OWORD *)uint64_t v23 = v19;
    *(_OWORD *)(v23 + 16) = v18;
    *(void *)(v23 + 32) = v17;
    if (*(void *)v11 != a2)
    {
      if ((cachePageEvict((uint64_t *)a1, v8 + 40LL * v10, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cachePageGet",  162,  146,  0,  "cachePageEvict",  v24,  v25,  v29);
        return 0LL;
      }

      else
      {
        uint64_t v26 = v8 + 40LL * v10;
        bzero(*(void **)(v26 + 16), *(unsigned int *)(a1 + 92));
        int v27 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(v26 + 28) = 0;
        *(_DWORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 24) = v27;
        *(void *)uint64_t v11 = a2;
      }
    }
  }

  return v11;
}

uint64_t cachePageReadFromDisk( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *((unsigned int *)a2 + 6);
  unsigned int v10 = *((_DWORD *)a2 + 7);
  else {
    size_t v12 = 0LL;
  }
  int v13 = *((_DWORD *)a2 + 8);
  if (v10 <= v11 || v13 == 0)
  {
    unsigned int v15 = 0LL;
  }

  else
  {
    unsigned int v16 = malloc(v12);
    unsigned int v15 = v16;
    if (!v16)
    {
      uint64_t v24 = "aaMalloc";
      __int16 v25 = 184;
LABEL_33:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cachePageReadFromDisk",  v25,  146,  0,  v24,  a7,  a8,  v30);
      uint64_t v27 = 0xFFFFFFFFLL;
      goto LABEL_34;
    }

    memcpy(v16, (const void *)(a2[2] + v11), v12);
  }

  uint64_t v17 = *a2;
  else {
    uint64_t v18 = a1[4] - *a2;
  }
  if (v18 < 1) {
    goto LABEL_26;
  }
  uint64_t v19 = *a1;
  if (!*(void *)(*a1 + 32)) {
    goto LABEL_32;
  }
  unsigned int v31 = v10;
  size_t v32 = v12;
  uint64_t v20 = 0LL;
  uint64_t v21 = a2[2];
  uint64_t v22 = v18;
  while (1)
  {
    uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v19 + 32))(*(void *)v19, v21, v22, v17);
    if (v23 < 0) {
      break;
    }
    if (v23)
    {
      v21 += v23;
      v20 += v23;
      v17 += v23;
      v22 -= v23;
      if (v22) {
        continue;
      }
    }

    goto LABEL_24;
  }

  uint64_t v20 = v23;
LABEL_24:
  size_t v12 = v32;
  unsigned int v10 = v31;
  if (v18 != v20)
  {
LABEL_32:
    uint64_t v24 = "AAByteStreamPRead";
    __int16 v25 = 193;
    goto LABEL_33;
  }

  ++a1[7];
  int v13 = *((_DWORD *)a2 + 8);
LABEL_26:
  uint64_t v27 = 0LL;
  int v28 = *((_DWORD *)a1 + 23);
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v28;
LABEL_34:
  free(v15);
  return v27;
}

uint64_t cachePageEvict( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 25)) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a2 + 32)) {
    return 0LL;
  }
  uint64_t v9 = *(unsigned int *)(a2 + 24);
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  uint64_t v12 = *(void *)a2 + v9;
  uint64_t v13 = v10 - v9;
  if (v13 >= a1[3] - v12) {
    uint64_t v14 = a1[3] - v12;
  }
  else {
    uint64_t v14 = v13;
  }
  if (v14 <= 0)
  {
    uint64_t v21 = "bad page";
    __int16 v22 = 87;
LABEL_21:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cachePageEvict",  v22,  146,  0,  v21,  a7,  a8,  v23);
    return 0xFFFFFFFFLL;
  }

  uint64_t v15 = *a1;
  if (!*(void *)(*a1 + 40)) {
    goto LABEL_20;
  }
  uint64_t v16 = 0LL;
  uint64_t v17 = *(void *)(a2 + 16) + v9;
  uint64_t v18 = *(void *)a2 + v9;
  uint64_t v19 = v14;
  while (1)
  {
    uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(void *)v15, v17, v19, v18);
    if (v20 < 1) {
      break;
    }
    v17 += v20;
    v16 += v20;
    v18 += v20;
    v19 -= v20;
    if (!v19) {
      goto LABEL_16;
    }
  }

  uint64_t v16 = v20;
LABEL_16:
  if (v14 != v16)
  {
LABEL_20:
    uint64_t v21 = "aaByteStreamPWriteExpected";
    __int16 v22 = 90;
    goto LABEL_21;
  }

  ++a1[8];
  if (a1[4] < v14 + v12)
  {
    uint64_t result = 0LL;
    a1[4] = v14 + v12;
    return result;
  }

  return 0LL;
}

uint64_t cacheFlush( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 84))
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    while ((cachePageEvict((uint64_t *)a1, *(void *)(a1 + 72) + v10, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 72) + v10;
      bzero(*(void **)(v14 + 16), *(unsigned int *)(a1 + 92));
      *(void *)uint64_t v14 = -1LL;
      int v15 = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(v14 + 28) = 0;
      *(_DWORD *)(v14 + 32) = 0;
      *(_DWORD *)(v14 + 24) = v15;
      ++v11;
      v10 += 40LL;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c",  (uint64_t)"cacheFlush",  115,  146,  0,  "cachePageEvict",  v12,  v13,  v16);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

uint64_t aeaOutputStreamRunThreads(uint64_t a1)
{
  size_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(v3 + 24);
  size_t v5 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    compression_algorithm v6 = aeaEffectiveCompressionAlgorithm(v4);
    size_t v7 = compression_encode_scratch_buffer_size(v6);
  }

  else
  {
    size_t v7 = 0LL;
  }

  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = v2;
  uint64_t v8 = calloc(v2, 4uLL);
  *(void *)(a1 + 72) = v8;
  if (!v8)
  {
    uint64_t v12 = "SharedArrayInit: malloc failed\n";
    __int16 v13 = 55;
    goto LABEL_10;
  }

  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0LL))
  {
    uint64_t v12 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v13 = 56;
LABEL_10:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v13,  0,  v12,  v9,  v10,  v11,  v39);
    char v16 = "SharedArrayInit";
    __int16 v17 = 323;
LABEL_11:
    int v18 = 0;
LABEL_12:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamRunThreads",  v17,  41,  v18,  v16,  v14,  v15,  v39);
    return 0xFFFFFFFFLL;
  }

  if (pthread_cond_init((pthread_cond_t *)(a1 + 144), 0LL))
  {
    uint64_t v12 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v13 = 57;
    goto LABEL_10;
  }

  size_t v20 = (v2 + 1);
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = v20;
  uint64_t v21 = calloc(v20, 4uLL);
  *(void *)(a1 + 200) = v21;
  if (!v21)
  {
    __int16 v25 = "SharedArrayInit: malloc failed\n";
    __int16 v26 = 55;
    goto LABEL_19;
  }

  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 208), 0LL))
  {
    __int16 v25 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v26 = 56;
LABEL_19:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v26,  0,  v25,  v22,  v23,  v24,  v39);
    char v16 = "SharedArrayInit";
    __int16 v17 = 324;
    goto LABEL_11;
  }

  if (pthread_cond_init((pthread_cond_t *)(a1 + 272), 0LL))
  {
    __int16 v25 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v26 = 57;
    goto LABEL_19;
  }

  *(_DWORD *)(a1 + 56) = -1;
  if (v2 >= 0x89AE409)
  {
    *__error() = 12;
    *(void *)(a1 + 48) = 0LL;
LABEL_50:
    int v18 = *__error();
    char v16 = "malloc";
    __int16 v17 = 329;
    goto LABEL_12;
  }

  uint64_t v27 = calloc(v2, 0x3B8uLL);
  *(void *)(a1 + 48) = v27;
  if (!v27) {
    goto LABEL_50;
  }
  if ((_DWORD)v2)
  {
    uint64_t v28 = 0LL;
    int v29 = 0;
    while (1)
    {
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v31 = v30 + v28;
      *(_DWORD *)(v30 + v28 + 592) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 600), 0LL)
        || pthread_cond_init((pthread_cond_t *)(v31 + 664), 0LL)
        || (*(_DWORD *)(v30 + v28 + 712) = 0, pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 720), 0LL))
        || pthread_cond_init((pthread_cond_t *)(v30 + v28 + 784), 0LL)
        || (*(_DWORD *)(v30 + v28 + 832) = 0, pthread_mutex_init((pthread_mutex_t *)(v30 + v28 + 840), 0LL))
        || pthread_cond_init((pthread_cond_t *)(v30 + v28 + 904), 0LL))
      {
        char v16 = "SemInit";
        __int16 v17 = 333;
        goto LABEL_11;
      }

      uint64_t v32 = v30 + v28;
      *(_DWORD *)(v32 + 8) = v29;
      *(void *)(v32 + 16) = a1;
      char v33 = malloc(v5);
      *(void *)(v32 + 32) = v33;
      *(void *)(v32 + 40) = malloc(v5);
      if (v7)
      {
        if (v7 < 0x2000000001LL)
        {
          char v35 = malloc(v7);
        }

        else
        {
          uint64_t v34 = __error();
          char v35 = 0LL;
          *uint64_t v34 = 12;
          char v33 = *(void **)(v32 + 32);
        }
      }

      else
      {
        char v35 = 0LL;
      }

      *(void *)(v32 + 24) = v35;
      if (!v33 || (v7 ? (BOOL v36 = v35 == 0LL) : (BOOL v36 = 0), !v36 ? (v37 = 0) : (v37 = 1), !*(void *)(v32 + 40) || v37))
      {
        int v18 = *__error();
        char v16 = "malloc";
        __int16 v17 = 339;
        goto LABEL_12;
      }

      ++v29;
      v28 += 952LL;
    }

    char v16 = "Thread creation";
    __int16 v17 = 340;
    goto LABEL_11;
  }

uint64_t aeaOutputStreamWorkerThreadProc(uint64_t a1)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(v2 + 24);
  dst_uint64_t size = *(unsigned int *)(v3 + 16);
  unsigned int v58 = *(_DWORD *)(v3 + 24);
  int v63 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = (pthread_mutex_t *)(a1 + 600);
  int v67 = 0;
  size_t v5 = (pthread_cond_t *)(a1 + 664);
  uint64_t v64 = (unsigned int *)(a1 + 48);
  __int128 v65 = (pthread_mutex_t *)(v2 + 80);
  __int128 v57 = (_DWORD *)(v3 + 668);
  uint64_t v55 = a1 + 332;
  uint64_t v60 = (pthread_mutex_t *)(a1 + 720);
  uint64_t v61 = a1 + 72;
  __int128 v56 = (pthread_cond_t *)(a1 + 784);
  compression_algorithm v6 = (pthread_mutex_t *)(a1 + 840);
  size_t v7 = (pthread_cond_t *)(a1 + 904);
  uint64_t v8 = (char *)v70 + 8;
  int v62 = 1;
  memset(v66, 0, sizeof(v66));
  while (1)
  {
    if (pthread_mutex_lock(v65))
    {
      __int128 v48 = "SharedArrayPush: pthread_mutex_lock failed\n";
      __int16 v49 = 117;
      goto LABEL_73;
    }

    uint64_t v12 = *(unsigned int *)(v2 + 64);
    unsigned int v13 = *(_DWORD *)(v2 + 68);
    int v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(void *)(v2 + 72) + 4 * v12) = v63;
      int v14 = *(_DWORD *)(v2 + 64);
    }

    *(_DWORD *)(v2 + 64) = v14 + 1;
    if (!v14 && pthread_cond_broadcast((pthread_cond_t *)(v2 + 144)))
    {
      __int128 v48 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v49 = 122;
      goto LABEL_73;
    }

    if (pthread_mutex_unlock(v65))
    {
      __int128 v48 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      __int16 v49 = 124;
LABEL_73:
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Comm on/SharedArray.h",  (uint64_t)"SharedArrayPush",  v49,  0,  v48,  v9,  v10,  v11,  v50);
      __int128 v44 = "SharedArrayPush";
      __int16 v45 = 76;
LABEL_62:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamWorkerThreadProc",  v45,  41,  0,  v44,  v15,  v16,  v50);
LABEL_63:
      __int128 v46 = (unsigned int *)(v2 + 40);
      do
        unsigned int v47 = __ldaxr(v46);
      while (__stlxr(v47 + 1, v46));
      return a1;
    }

    if (v12 >= v13)
    {
      __int128 v48 = "SharedArrayPush: stack is full\n";
      __int16 v49 = 125;
      goto LABEL_73;
    }

    if (pthread_mutex_lock(v4)) {
      goto LABEL_61;
    }
    while (1)
    {
      int v17 = *(_DWORD *)(a1 + 592);
      if (v17 > 0) {
        break;
      }
      if (pthread_cond_wait(v5, v4)) {
        goto LABEL_61;
      }
    }

    *(_DWORD *)(a1 + 592) = v17 - 1;
    if (pthread_mutex_unlock(v4))
    {
LABEL_61:
      __int128 v44 = "SemAcquire";
      __int16 v45 = 77;
      goto LABEL_62;
    }

    if (*v64 == -1)
    {
      if (!v62) {
        goto LABEL_63;
      }
      return a1;
    }

    if ((aeaChecksum(v61, *(_DWORD *)(v3 + 12), *(void **)(a1 + 32), *(unsigned int *)(a1 + 52), v18, v19, v15, v16) & 0x80000000) != 0)
    {
      __int16 v23 = 83;
      uint64_t v24 = "Segment checksum failed";
      goto LABEL_50;
    }

    *(_DWORD *)(a1 + 56) = 0;
    if (v58 != 774)
    {
      if (!v58)
      {
        size_t v22 = *(unsigned int *)(a1 + 52);
LABEL_26:
        memcpy(*(void **)(a1 + 40), *(const void **)(a1 + 32), v22);
        size_t v26 = *(unsigned int *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v26;
        goto LABEL_27;
      }

      compression_algorithm v27 = aeaEffectiveCompressionAlgorithm(v58);
      LODWORD(v25) = compression_encode_buffer( *(uint8_t **)(a1 + 40),  dst_size,  *(const uint8_t **)(a1 + 32),  *(unsigned int *)(a1 + 52),  *(void **)(a1 + 24),  v27);
LABEL_23:
      size_t v26 = v25;
      *(_DWORD *)(a1 + 56) = v25;
      goto LABEL_24;
    }

    int64_t v25 = PCompressLZMA6Encode( *(uint8_t **)(a1 + 40),  dst_size,  *(const uint8_t **)(a1 + 32),  *(unsigned int *)(a1 + 52));
    if (v25 >= 1) {
      goto LABEL_23;
    }
    size_t v26 = *(unsigned int *)(a1 + 56);
LABEL_24:
    size_t v22 = *(unsigned int *)(a1 + 52);
    if (!v26 || v26 >= v22) {
      goto LABEL_26;
    }
LABEL_27:
    uint64_t v28 = *(void **)(a1 + 32);
    if (v28)
    {
      memset_s(v28, dst_size, 0, dst_size);
      size_t v26 = *(unsigned int *)(a1 + 56);
    }

    if (!v26)
    {
      __int16 v23 = 107;
      uint64_t v24 = "Segment compression failed";
      goto LABEL_50;
    }

    __int128 v54 = v8;
    size_t v51 = v26;
    unsigned int v29 = *v64;
    unsigned int v30 = *(_DWORD *)(v3 + 20);
    int v69 = 0;
    memset(v68, 0, sizeof(v68));
    memset((char *)__s + 8, 0, 252);
    int v71 = 0;
    memset(v70, 0, sizeof(v70));
    WORD4(__s[0]) = 19267;
    *(void *)&__s[0] = 0x5F41454100000006LL;
    uint64_t result = memset_s((char *)__s + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v32 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0xFD) {
      break;
    }
    int v52 = v29 / v30;
    unsigned int v53 = v29;
    *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v29 / v30;
    LODWORD(__s[0]) = v32 + 4;
    memset_s((char *)__s + v32 + 8, 252 - v32, 0, 252 - v32);
    char v33 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (v33 && *v57)
    {
      int v34 = v33(v68, *(unsigned int *)(v3 + 72), v57, __s, v70);
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      int v35 = 0;
      if ((v34 & 0x80000000) == 0) {
        goto LABEL_37;
      }
    }

    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }

    int v35 = 1;
LABEL_37:
    *(_OWORD *)((char *)v54 + 236) = 0u;
    v54[13] = 0u;
    v54[14] = 0u;
    v54[11] = 0u;
    v54[12] = 0u;
    v54[9] = 0u;
    v54[10] = 0u;
    v54[7] = 0u;
    v54[8] = 0u;
    v54[5] = 0u;
    v54[6] = 0u;
    v54[3] = 0u;
    v54[4] = 0u;
    v54[1] = 0u;
    v54[2] = 0u;
    *__int128 v54 = 0u;
    WORD4(v70[0]) = 19283;
    *(void *)&v70[0] = 0x5F41454100000006LL;
    uint64_t result = memset_s((char *)v70 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v36 = LODWORD(v70[0]);
    if (LODWORD(v70[0]) >= 0xFD) {
      break;
    }
    *(_DWORD *)((char *)v70 + LODWORD(v70[0]) + 4) = v53 - v52 * v30;
    LODWORD(v70[0]) = v36 + 4;
    memset_s((char *)v70 + v36 + 8, 252 - v36, 0, 252 - v36);
    memset(__s, 0, 260);
    int v37 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (!v37 || !LODWORD(v68[0]))
    {
      memset_s(v70, 0x104uLL, 0, 0x104uLL);
      uint64_t v8 = (char *)v54;
LABEL_48:
      memset_s(v68, 0x104uLL, 0, 0x104uLL);
LABEL_49:
      __int16 v23 = 119;
      uint64_t v24 = "Segment key derivation failed";
      goto LABEL_50;
    }

    int v38 = v35;
    int v39 = v37(v66, *(unsigned int *)(v3 + 76), v68, v70, __s);
    memset_s(v70, 0x104uLL, 0, 0x104uLL);
    uint64_t v8 = (char *)v54;
    if (v39 < 0) {
      goto LABEL_48;
    }
    memset_s(v68, 0x104uLL, 0, 0x104uLL);
    if (v38) {
      goto LABEL_49;
    }
    uint64_t v40 = *(uint64_t (**)(void, size_t, uint64_t, _OWORD *, void, void))(v3 + 160);
    if (v40)
    {
      int v41 = v40(*(void *)(a1 + 40), v51, v55, v66, 0LL, 0LL);
      if (*(_DWORD *)(a1 + 332) == *(_DWORD *)(v3 + 84) && (v41 & 0x80000000) == 0) {
        goto LABEL_51;
      }
    }

    __int16 v23 = 120;
    uint64_t v24 = "Segment encryption failed";
LABEL_50:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamWorkerThreadProc",  v23,  41,  0,  v24,  v20,  v21,  v50);
    memset_s(v64, 0x220uLL, 0, 0x220uLL);
    int v62 = 0;
    unsigned int *v64 = -1;
LABEL_51:
    memset_s(v66, 0x104uLL, 0, 0x104uLL);
    if (pthread_mutex_lock(v60)
      || (int v42 = *(_DWORD *)(a1 + 712), *(_DWORD *)(a1 + 712) = v42 + 1, !v42) && pthread_cond_broadcast(v56)
      || pthread_mutex_unlock(v60))
    {
      __int128 v44 = "SemRelease";
      __int16 v45 = 133;
      goto LABEL_62;
    }

    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        int v43 = *(_DWORD *)(a1 + 832);
        if (v43 > 0) {
          break;
        }
        if (pthread_cond_wait(v7, v6)) {
          goto LABEL_60;
        }
      }

      *(_DWORD *)(a1 + 832) = v43 - 1;
      if (!pthread_mutex_unlock(v6)) {
        continue;
      }
    }

uint64_t aeaOutputStreamWriterThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  rsize_t v3 = *(unsigned int *)(*(void *)(v2 + 24) + 16LL);
  int v4 = 1;
  while (1)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 208)))
    {
      compression_algorithm v27 = "SharedArrayPop: pthread_mutex_lock failed\n";
      __int16 v28 = 91;
      goto LABEL_24;
    }

    while (1)
    {
      int v8 = *(_DWORD *)(v2 + 192);
      if (v8) {
        break;
      }
      if (pthread_cond_wait((pthread_cond_t *)(v2 + 272), (pthread_mutex_t *)(v2 + 208)))
      {
        compression_algorithm v27 = "SharedArrayPop: pthread_cond_wait failed\n";
        __int16 v28 = 94;
        goto LABEL_24;
      }
    }

    unsigned int v9 = v8 - 1;
    *(_DWORD *)(v2 + 192) = v9;
    unsigned int v10 = *(_DWORD *)(*(void *)(v2 + 200) + 4LL * v9);
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 208)))
    {
      compression_algorithm v27 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      __int16 v28 = 98;
LABEL_24:
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Comm on/SharedArray.h",  (uint64_t)"SharedArrayPop",  v28,  0,  v27,  v5,  v6,  v7,  v32);
      int64_t v25 = "SharedArrayDequeue";
      __int16 v26 = 151;
LABEL_26:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamWriterThreadProc",  v26,  41,  0,  v25,  v6,  v7,  v32);
      goto LABEL_27;
    }

    if (v10 == -1) {
      break;
    }
    if (v10 >= *(_DWORD *)(v2 + 16))
    {
      int64_t v25 = "Invalid worker id";
      __int16 v26 = 155;
      goto LABEL_26;
    }

    int v33 = v4;
    rsize_t v11 = v3;
    uint64_t v12 = *(void *)(v2 + 48);
    uint64_t v13 = v12 + 952LL * v10;
    int v14 = (pthread_mutex_t *)(v13 + 720);
    if (pthread_mutex_lock((pthread_mutex_t *)(v13 + 720))) {
      goto LABEL_25;
    }
    uint64_t v15 = (int *)(v13 + 712);
    while (*v15 <= 0)
    {
      if (pthread_cond_wait((pthread_cond_t *)(v12 + 952LL * v10 + 784), v14)) {
        goto LABEL_25;
      }
    }

    --*v15;
    if (pthread_mutex_unlock(v14))
    {
LABEL_25:
      int64_t v25 = "SemAcquire";
      __int16 v26 = 159;
      goto LABEL_26;
    }

    uint64_t v18 = v12 + 952LL * v10;
    uint64_t v20 = *(void *)(v18 + 40);
    uint64_t v19 = v18 + 40;
    if ((aeaContainerAppendSegment(*(void *)(v2 + 24), *(void *)v2, (void *)(v19 + 8), v20, v16, v17, v6, v7) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamWriterThreadProc",  164,  41,  0,  "Segment insertion",  v21,  v22,  v32);
      int v33 = 0;
    }

    rsize_t v3 = v11;
    if (*(void *)v19) {
      memset_s(*(void **)v19, v11, 0, v11);
    }
    memset_s((void *)(v19 + 8), 0x220uLL, 0, 0x220uLL);
    int v4 = v33;
    if (pthread_mutex_lock((pthread_mutex_t *)(v12 + 952LL * v10 + 840))
      || (uint64_t v23 = v12 + 952LL * v10, v24 = *(_DWORD *)(v23 + 832), *(_DWORD *)(v23 + 832) = v24 + 1, !v24)
      && pthread_cond_broadcast((pthread_cond_t *)(v12 + 952LL * v10 + 904))
      || pthread_mutex_unlock((pthread_mutex_t *)(v12 + 952LL * v10 + 840)))
    {
      int64_t v25 = "SemRelease";
      __int16 v26 = 175;
      goto LABEL_26;
    }
  }

  if (v4) {
    return a1;
  }
LABEL_27:
  unsigned int v29 = (unsigned int *)(v2 + 40);
  do
    unsigned int v30 = __ldaxr(v29);
  while (__stlxr(v30 + 1, v29));
  return a1;
}

AAByteStream AEAEncryptionOutputStreamOpen( AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  int DefaultNThreads = n_threads;
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (n_threads <= 0) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((void *)encrypted_stream + 5))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpen",  367,  41,  0,  "Invalid encrypted stream",  v4,  v5,  v25);
    uint64_t v12 = 0LL;
    unsigned int v10 = 0LL;
LABEL_23:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0LL);
    return 0LL;
  }

  unsigned int v10 = calloc(1uLL, 0x68uLL);
  rsize_t v11 = malloc(0x148uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    int v22 = *__error();
    uint64_t v23 = "malloc";
    __int16 v24 = 372;
LABEL_22:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpen",  v24,  41,  v22,  v23,  v14,  v15,  v25);
    goto LABEL_23;
  }

  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  uint64_t New = aeaContainerCreateNew((uint64_t)context);
  *(void *)(v12 + 24) = New;
  if (!New)
  {
    uint64_t v23 = "Invalid encryption parameters";
    __int16 v24 = 379;
LABEL_21:
    int v22 = 0;
    goto LABEL_22;
  }

  AAByteStream result = (AAByteStream)aeaOutputStreamRunThreads(v12);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v23 = "Running stream threads";
    __int16 v24 = 380;
    goto LABEL_21;
  }

  v10[3] = aeaOutputStreamWrite;
  v10[7] = aeaOutputStreamAbort;
  void *v10 = v12;
  v10[1] = aeaOutputStreamClose;
  uint64_t v17 = *(void *)(v12 + 24);
  uint64_t v18 = *(unsigned int *)(v17 + 668);
  if (v18 < 0x101)
  {
    memcpy((char *)context + 1376, (const void *)(v17 + 672), *(unsigned int *)(v17 + 668));
    *((_DWORD *)context + 343) = v18;
    memset_s((char *)context + v18 + 1376, 256 - v18, 0, 256 - v18);
    uint64_t v19 = *(void *)(v12 + 24);
    if (*(_DWORD *)v19 <= 5u && ((1 << *(_DWORD *)v19) & 0x2B) != 0) {
      return (AAByteStream)v10;
    }
    memset(v40, 0, sizeof(v40));
    __int128 v39 = 0u;
    __int128 v38 = 0u;
    __int128 v37 = 0u;
    __int128 v36 = 0u;
    __int128 v35 = 0u;
    __int128 v34 = 0u;
    __int128 v33 = 0u;
    __int128 v32 = 0u;
    __int128 v31 = 0u;
    __int128 v30 = 0u;
    __int128 v29 = 0u;
    __int128 v28 = 0u;
    __int128 v27 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007LL;
    char v25 = 0;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    uint64_t v20 = *(uint64_t (**)(char *, void))(v19 + 144);
    if (v20 && *(_DWORD *)(v19 + 668))
    {
      int v21 = v20((char *)context + 1632, *(unsigned int *)(v19 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v21 & 0x80000000) == 0) {
        return (AAByteStream)v10;
      }
    }

    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }

    uint64_t v23 = "deriving signature encryption key";
    __int16 v24 = 398;
    goto LABEL_21;
  }

  __break(1u);
  return result;
}

uint64_t aeaOutputStreamWrite(uint64_t a1, char *__src, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 36)) {
    return -1LL;
  }
  unint64_t v3 = a3;
  if (!a3) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  int v7 = *(_DWORD *)(*(void *)(a1 + 24) + 16LL);
  int v8 = (pthread_mutex_t *)(a1 + 80);
  unsigned int v9 = (pthread_cond_t *)(a1 + 144);
  while (1)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 56);
    if (v10 != -1)
    {
      uint64_t v11 = *(void *)(a1 + 48) + 952LL * v10;
      goto LABEL_13;
    }

    if (pthread_mutex_lock(v8))
    {
      int v22 = "SharedArrayPop: pthread_mutex_lock failed\n";
      __int16 v23 = 91;
LABEL_20:
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Comm on/SharedArray.h",  (uint64_t)"SharedArrayPop",  v23,  0,  v22,  v12,  v13,  v14,  v27);
      __int16 v24 = "SharedArrayPop failed";
      __int16 v25 = 282;
      goto LABEL_21;
    }

    while (1)
    {
      int v15 = *(_DWORD *)(a1 + 64);
      if (v15) {
        break;
      }
      if (pthread_cond_wait(v9, v8))
      {
        int v22 = "SharedArrayPop: pthread_cond_wait failed\n";
        __int16 v23 = 94;
        goto LABEL_20;
      }
    }

    unsigned int v16 = v15 - 1;
    *(_DWORD *)(a1 + 64) = v16;
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(void *)(a1 + 72) + 4LL * v16);
    if (pthread_mutex_unlock(v8))
    {
      int v22 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      __int16 v23 = 98;
      goto LABEL_20;
    }

    unsigned int v17 = *(_DWORD *)(a1 + 56);
    if (v17 >= *(_DWORD *)(a1 + 16)) {
      break;
    }
    uint64_t v11 = *(void *)(a1 + 48) + 952LL * v17;
    memset_s((void *)(v11 + 48), 0x220uLL, 0, 0x220uLL);
    int v18 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(_DWORD *)(v11 + 48) = v18;
LABEL_13:
    uint64_t v19 = *(unsigned int *)(v11 + 52);
    else {
      size_t v20 = (v7 - v19);
    }
    memcpy((void *)(*(void *)(v11 + 32) + v19), __src, v20);
    int v21 = *(_DWORD *)(v11 + 52) + v20;
    *(_DWORD *)(v11 + 52) = v21;
    if (v21 == v7 && (aeaOutputStreamRunCurrentWorker(a1) & 0x80000000) != 0)
    {
      __int16 v24 = "Sending task to worker failed";
      __int16 v25 = 305;
      goto LABEL_21;
    }

    __src += v20;
    v6 += v20;
    v3 -= v20;
    if (!v3) {
      return v6;
    }
  }

  __int16 v24 = "Invalid worker_id";
  __int16 v25 = 283;
LABEL_21:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamWrite",  v25,  41,  0,  v24,  v13,  v14,  v27);
  return -1LL;
}

void aeaOutputStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 36) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }

uint64_t aeaOutputStreamClose(uint64_t a1)
{
  return aeaOutputStreamCloseAndUpdateContext(a1, 0LL);
}

AAByteStream AEAEncryptionOutputStreamOpenExisting( AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  int DefaultNThreads = n_threads;
  uint64_t v72 = *MEMORY[0x1895F89C0];
  if (n_threads <= 0) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((void *)encrypted_stream + 5) || !*((void *)encrypted_stream + 4))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpenExisting",  430,  41,  0,  "Invalid encrypted stream",  v4,  v5,  v55);
    uint64_t v12 = 0LL;
    unsigned int v10 = 0LL;
LABEL_40:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0LL);
    return 0LL;
  }

  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = malloc(0x148uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    int v30 = *__error();
    __int128 v31 = "malloc";
    __int16 v32 = 435;
LABEL_39:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpenExisting",  v32,  41,  v30,  v31,  v14,  v15,  v55);
    goto LABEL_40;
  }

  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  AAByteStream result = (AAByteStream)aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 0, 1);
  *(void *)(v12 + 24) = result;
  if (!result)
  {
    __int128 v31 = "load container";
    __int16 v32 = 443;
    goto LABEL_38;
  }

  if ((flags & 0x4000000000000LL) == 0)
  {
    if ((aeaContainerReencrypt( (uint64_t)result,  encrypted_stream,  (int *)context + 18,  (_DWORD *)context + 538,  (unsigned int *)context + 83,  (unsigned int *)context + 213) & 0x80000000) != 0)
    {
      __int128 v31 = "re-encrypting container";
      __int16 v32 = 454;
      goto LABEL_38;
    }

    AAByteStream result = *(AAByteStream *)(v12 + 24);
  }

  size_t v16 = *((unsigned int *)result + 167);
  if (v16 < 0x101)
  {
    memcpy((char *)context + 1376, (char *)result + 672, v16);
    *((_DWORD *)context + 343) = v16;
    memset_s((char *)context + v16 + 1376, 256 - v16, 0, 256 - v16);
    uint64_t v17 = *(void *)(v12 + 24);
    if (*(_DWORD *)v17 <= 5u && ((1 << *(_DWORD *)v17) & 0x2B) != 0) {
      goto LABEL_14;
    }
    memset(v71, 0, sizeof(v71));
    __int128 v70 = 0u;
    __int128 v69 = 0u;
    __int128 v68 = 0u;
    __int128 v67 = 0u;
    __int128 v66 = 0u;
    __int128 v65 = 0u;
    __int128 v64 = 0u;
    __int128 v63 = 0u;
    __int128 v62 = 0u;
    __int128 v61 = 0u;
    __int128 v60 = 0u;
    __int128 v59 = 0u;
    __int128 v58 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007LL;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    __int128 v37 = *(uint64_t (**)(char *, void))(v17 + 144);
    if (v37 && *(_DWORD *)(v17 + 668))
    {
      int v38 = v37((char *)context + 1632, *(unsigned int *)(v17 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v38 & 0x80000000) == 0)
      {
        uint64_t v17 = *(void *)(v12 + 24);
LABEL_14:
        if ((aeaContainerRemovePadding(v17, encrypted_stream) & 0x80000000) == 0)
        {
          uint64_t v18 = *(void *)(v12 + 24);
          size_t v19 = *(unsigned int *)(v18 + 16);
          int v20 = *(_DWORD *)(v18 + 400);
          if (!v20 || *(_DWORD *)(*(void *)(v18 + 392) + 544LL * (v20 - 1) + 4) >= v19)
          {
            __int128 v29 = 0LL;
            rsize_t v28 = 0LL;
            int v22 = 0LL;
            __int16 v25 = 0LL;
            unint64_t v33 = 0LL;
LABEL_25:
            *(_DWORD *)(v12 + 32) = v20;
            if ((aeaOutputStreamRunThreads(v12) & 0x80000000) != 0)
            {
              __int128 v39 = "Running stream threads";
              __int16 v40 = 499;
            }

            else
            {
              v10[3] = aeaOutputStreamWrite;
              v10[7] = aeaOutputStreamAbort;
              void *v10 = v12;
              v10[1] = aeaOutputStreamClose;
              if (!v33 || aeaOutputStreamWrite(v12, v25, v33) == v33)
              {
                int v36 = 1;
                goto LABEL_59;
              }

              __int128 v39 = "writing back last segment data";
              __int16 v40 = 511;
            }

            int v41 = 0;
LABEL_58:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpenExisting",  v40,  41,  v41,  v39,  v34,  v35,  v55);
            int v36 = 0;
LABEL_59:
            if (!v22) {
              goto LABEL_61;
            }
            goto LABEL_60;
          }

          uint64_t v21 = *(unsigned int *)(v18 + 24);
          int v22 = (uint8_t *)malloc(*(unsigned int *)(v18 + 16));
          __int16 v25 = (char *)malloc(v19);
          if ((_DWORD)v21)
          {
            compression_algorithm v26 = aeaEffectiveCompressionAlgorithm(v21);
            size_t v27 = compression_decode_scratch_buffer_size(v26);
            rsize_t v28 = v27;
            if (v27)
            {
              if (v27 < 0x2000000001LL)
              {
                __int128 v29 = malloc(v27);
              }

              else
              {
                __int128 v29 = 0LL;
                *__error() = 12;
              }

              int v42 = 1;
LABEL_49:
              if (v29) {
                int v42 = 0;
              }
              if (!v22 || !v25 || v42)
              {
                int v41 = *__error();
                __int128 v39 = "malloc";
                __int16 v40 = 483;
                goto LABEL_58;
              }

              rsize_t v56 = v28;
              uint64_t v43 = *(void *)(v12 + 24);
              unsigned int v44 = *(_DWORD *)(v43 + 400) - 1;
              uint64_t v45 = *(void *)(v43 + 392);
              uint64_t Segment = aeaContainerLoadSegment(v43, encrypted_stream, v44, (uint8_t *)v25, v22, v29, v23, v24);
              if (Segment == *(_DWORD *)(v45 + 544LL * v44 + 4))
              {
                unint64_t v33 = Segment;
                rsize_t v28 = v56;
                if ((aeaContainerRemoveLastSegment( *(uint64x2_t **)(v12 + 24),  encrypted_stream,  v47,  v48,  v49,  v50,  v51,  v52) & 0x80000000) == 0)
                {
                  int v20 = *(_DWORD *)(*(void *)(v12 + 24) + 400LL);
                  goto LABEL_25;
                }

                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpenExisting",  493,  41,  0,  "removing last segment",  v53,  v54,  v55);
                int v36 = 0;
              }

              else
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamOpenExisting",  489,  41,  0,  "load and decrypt last segment",  v51,  v52,  v55);
                int v36 = 0;
                rsize_t v28 = v56;
              }

int AEAEncryptionOutputStreamCloseAndUpdateContext(AAByteStream stream, AEAContext context)
{
  if (stream)
  {
    AAByteStream v4 = stream;
    if (*((uint64_t (**)(uint64_t))stream + 1) == aeaOutputStreamClose)
    {
      uint64_t v5 = *(void *)stream;
      *(void *)AAByteStream v4 = 0LL;
      int updated = aeaOutputStreamCloseAndUpdateContext(v5, (uint64_t)context);
      free(v4);
      LODWORD(stream) = updated;
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"AEAEncryptionOutputStreamCloseAndUpdateContext",  534,  41,  0,  "Invalid stream type",  v2,  v3,  v8);
      LODWORD(stream) = -1;
    }
  }

  return (int)stream;
}

uint64_t aeaOutputStreamCloseAndUpdateContext(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t v3 = *(void **)(result + 48);
  uint64_t v43 = a2;
  if (v3 && (uint64_t v4 = *(unsigned int *)(result + 16), (_DWORD)v4))
  {
    int v5 = 0;
    do
    {
      if (*v3) {
        ++v5;
      }
      v3 += 119;
      --v4;
    }

    while (v4);
  }

  else
  {
    int v5 = 0;
  }

  if ((aeaOutputStreamRunCurrentWorker(result) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamCloseAndUpdateContext",  207,  41,  0,  "Sending task to worker",  v6,  v7,  v43);
    int v45 = 0;
  }

  else
  {
    int v45 = 1;
  }

  if (v5 >= 1)
  {
    for (int i = 0; i != v5; ++i)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 80)))
      {
        __int16 v12 = 91;
        uint64_t v13 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_20:
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Co mmon/SharedArray.h",  (uint64_t)"SharedArrayPop",  v12,  0,  v13,  v9,  v10,  v11,  v43);
        unsigned int v17 = -1;
      }

      else
      {
        while (1)
        {
          int v14 = *(_DWORD *)(v2 + 64);
          if (v14) {
            break;
          }
          if (pthread_cond_wait((pthread_cond_t *)(v2 + 144), (pthread_mutex_t *)(v2 + 80)))
          {
            __int16 v12 = 94;
            uint64_t v13 = "SharedArrayPop: pthread_cond_wait failed\n";
            goto LABEL_20;
          }
        }

        unsigned int v25 = v14 - 1;
        *(_DWORD *)(v2 + 64) = v25;
        unsigned int v17 = *(_DWORD *)(*(void *)(v2 + 72) + 4LL * v25);
        if (!pthread_mutex_unlock((pthread_mutex_t *)(v2 + 80))) {
          goto LABEL_22;
        }
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Co mmon/SharedArray.h",  (uint64_t)"SharedArrayPop",  98,  0,  "SharedArrayPop: pthread_mutex_unlock failed\n",  v26,  v27,  v28,  v43);
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamCloseAndUpdateContext",  213,  41,  0,  "SharedArrayPop",  v15,  v16,  v44);
      int v45 = 0;
LABEL_22:
      uint64_t v18 = *(void *)(v2 + 48);
      uint64_t v19 = v18 + 952LL * v17;
      memset_s((void *)(v19 + 48), 0x220uLL, 0, 0x220uLL);
      *(_DWORD *)(v19 + 48) = -1;
      int v20 = (pthread_mutex_t *)(v19 + 600);
      if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 600))
        || (uint64_t v23 = v18 + 952LL * v17, v24 = *(_DWORD *)(v23 + 592), *(_DWORD *)(v23 + 592) = v24 + 1, !v24)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + 952LL * v17 + 664))
        || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 600)))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamCloseAndUpdateContext",  217,  41,  0,  "SemRelease",  v21,  v22,  v43);
        int v45 = 0;
      }

      joinThread(*(_opaque_pthread_t **)v19);
      __int128 v29 = (void **)(v18 + 952LL * v17);
      free(v29[4]);
      free(v29[5]);
      free(v29[3]);
      if (!pthread_mutex_destroy(v20)) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952LL * v17 + 664));
      }
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952LL * v17 + 720))) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952LL * v17 + 784));
      }
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952LL * v17 + 840))) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952LL * v17 + 904));
      }
    }
  }

  int v30 = *(void **)(v2 + 320);
  if (v30)
  {
    uint64_t v31 = v43;
    int v32 = v45;
    if (*v30)
    {
      if ((SharedArrayEnqueue((unsigned int *)(v2 + 192), -1) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamCloseAndUpdateContext",  230,  41,  0,  "SharedArrayEnqueue",  v33,  v34,  v43);
        int v32 = 0;
      }

      joinThread(**(_opaque_pthread_t ***)(v2 + 320));
    }
  }

  else
  {
    uint64_t v31 = v43;
    int v32 = v45;
  }

  AAByteStream result = *(void *)(v2 + 24);
  if (result && (AAByteStream result = aeaContainerFinish(result, *(AAByteStream_impl **)v2), (result & 0x80000000) != 0))
  {
    AAByteStream result = pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamCloseAndUpdateContext",  235,  41,  0,  "finishing container",  v35,  v36,  v43);
    int v32 = 0;
    if (v31) {
      goto LABEL_46;
    }
  }

  else if (v31)
  {
LABEL_46:
    uint64_t v37 = *(void *)(v2 + 24);
    *(_OWORD *)uint64_t v31 = *(_OWORD *)v37;
    __int128 v38 = *(_OWORD *)(v37 + 16);
    __int128 v39 = *(_OWORD *)(v37 + 32);
    __int128 v40 = *(_OWORD *)(v37 + 48);
    *(void *)(v31 + 64) = *(void *)(v37 + 64);
    *(_OWORD *)(v31 + 32) = v39;
    *(_OWORD *)(v31 + 48) = v40;
    *(_OWORD *)(v31 + 16) = v38;
    uint64_t v41 = *(void *)(v2 + 24);
    uint64_t v42 = *(unsigned int *)(v41 + 1448);
    if (v42 >= 0x101)
    {
      __break(1u);
      return result;
    }

    memcpy((void *)(v31 + 1896), (const void *)(v41 + 1452), *(unsigned int *)(v41 + 1448));
    *(_DWORD *)(v31 + 1892) = v42;
    memset_s((void *)(v31 + 1896 + v42), 256 - v42, 0, 256 - v42);
  }

  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 80)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 144))) {
    free(*(void **)(v2 + 72));
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 208)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 272))) {
    free(*(void **)(v2 + 200));
  }
  free(*(void **)(v2 + 48));
  free(*(void **)(v2 + 320));
  aeaContainerDestroy(*(void *)(v2 + 24));
  memset_s((void *)v2, 0x148uLL, 0, 0x148uLL);
  free((void *)v2);
  if (v32) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aeaOutputStreamRunCurrentWorker(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 56);
  if (v1 == -1) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return 0LL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v3 + 952LL * v1 + 600))
    || (uint64_t v6 = v3 + 952LL * v1, v7 = *(_DWORD *)(v6 + 592), *(_DWORD *)(v6 + 592) = v7 + 1, !v7)
    && pthread_cond_broadcast((pthread_cond_t *)(v3 + 952LL * v1 + 664))
    || pthread_mutex_unlock((pthread_mutex_t *)(v3 + 952LL * v1 + 600)))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamRunCurrentWorker",  188,  41,  0,  "SemRelease",  v4,  v5,  v12);
    int v8 = 0;
  }

  else
  {
    int v8 = 1;
  }

  if ((SharedArrayEnqueue((unsigned int *)(a1 + 192), *(_DWORD *)(a1 + 56)) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c",  (uint64_t)"aeaOutputStreamRunCurrentWorker",  189,  41,  0,  "SharedArrayEnqueue",  v10,  v11,  v12);
    int v8 = 0;
  }

  *(_DWORD *)(a1 + 56) = -1;
  if (v8) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SharedArrayEnqueue(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    int v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 157;
  }

  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    if (v10 >= v11)
    {
      int v12 = *a1;
    }

    else
    {
      if ((_DWORD)v10) {
        memmove((void *)(*((void *)a1 + 1) + 4LL), *((const void **)a1 + 1), 4 * v10);
      }
      **((_DWORD **)a1 + 1) = a2;
      int v12 = *a1;
    }

    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        int v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 168;
      }

      else
      {
        int v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 169;
      }
    }

    else
    {
      int v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 166;
    }
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayEnqueue",  v9,  0,  v8,  v5,  v6,  v7,  v14);
  return 0xFFFFFFFFLL;
}

ssize_t AAArchiveStreamProcess( AAArchiveStream istream, AAArchiveStream ostream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v36 = 0LL;
  AAHeader header = 0LL;
  uint64_t __s = 0LL;
  uint64_t v10 = malloc(0x40000uLL);
  if (!v10)
  {
    int v32 = *__error();
    int v30 = "malloc";
    __int16 v31 = 24;
LABEL_34:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStreamProcess.c",  (uint64_t)"AAArchiveStreamProcess",  v31,  16,  v32,  v30,  v19,  v20,  (char)v34);
    ssize_t v12 = -1LL;
    goto LABEL_35;
  }

  int v11 = AAArchiveStreamReadHeader(istream, &header);
  if (v11 < 0)
  {
LABEL_29:
    AAArchiveStreamCancel(ostream);
    int v30 = "archive stream read error (header)";
    __int16 v31 = 32;
LABEL_33:
    int v32 = 0;
    goto LABEL_34;
  }

  ssize_t v12 = 0LL;
  while (v11)
  {
    if (!msg_proc) {
      goto LABEL_41;
    }
    uint64_t v13 = header;
    v14.uint64_t ikey = 5521744;
    uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v14);
    if ((KeyIndex & 0x80000000) != 0) {
      goto LABEL_41;
    }
    unsigned int FieldString = AAHeaderGetFieldString(v13, KeyIndex, 0x400uLL, value, 0LL);
    int v17 = FieldString <= 1 ? 1 : FieldString;
    if (v17 < 1) {
      goto LABEL_41;
    }
    int v18 = ((uint64_t (*)(void *, uint64_t, char *, AAHeader))msg_proc)(msg_data, 50LL, value, header);
    if (v18 < 0)
    {
      int v30 = "callback cancel";
      __int16 v31 = 45;
      goto LABEL_33;
    }

    if (!v18)
    {
LABEL_41:
      if ((aaHeaderBlobArrayInitWithHeader((uint64_t)&__s, header) & 0x80000000) != 0)
      {
        int v30 = "capturing non-empty blobs";
        __int16 v31 = 55;
        goto LABEL_33;
      }

      if (AAArchiveStreamWriteHeader(ostream, header) < 0)
      {
        AAArchiveStreamCancel(istream);
        int v30 = "archive stream write error (header)";
        __int16 v31 = 61;
        goto LABEL_33;
      }

      ++v12;
      unint64_t v21 = __s;
      if ((_DWORD)__s)
      {
        uint64_t v34 = msg_data;
        uint64_t v22 = 0LL;
        while (1)
        {
          uint64_t v23 = (char *)v36 + 24 * v22;
          unsigned int v25 = (unint64_t *)(v23 + 8);
          unint64_t v24 = *((void *)v23 + 1);
          if (v24) {
            break;
          }
LABEL_26:
          if (++v22 >= v21)
          {
            msg_data = v34;
            goto LABEL_28;
          }
        }

        while (1)
        {
          if (v24 >= 0x40000) {
            size_t v26 = 0x40000LL;
          }
          else {
            size_t v26 = v24;
          }
          AAFieldKey v27 = *(AAFieldKey *)v23;
          if (AAArchiveStreamReadBlob(istream, v27, v10, v26) < 0)
          {
            AAArchiveStreamCancel(ostream);
            int v30 = "archive stream read error (blob)";
            __int16 v31 = 75;
            goto LABEL_33;
          }

          AAFieldKey v28 = *(AAFieldKey *)v23;
          if (AAArchiveStreamWriteBlob(ostream, v28, v10, v26) < 0) {
            break;
          }
          unint64_t v24 = *v25 - v26;
          BOOL v29 = *v25 == v26;
          *unsigned int v25 = v24;
          if (v29)
          {
            unint64_t v21 = __s;
            goto LABEL_26;
          }
        }

        AAArchiveStreamCancel(istream);
        int v30 = "archive stream write error (blob)";
        __int16 v31 = 80;
        goto LABEL_33;
      }
    }

LABEL_28:
    int v11 = AAArchiveStreamReadHeader(istream, &header);
    if (v11 < 0) {
      goto LABEL_29;
    }
  }

  int v32 = (unint64_t *)(v5 + 1072);
  do
    uint64_t v33 = __ldxr(v32);
  while (__stxr(v33 + 1, v32));
  return 0LL;
}

        v8 += v17;
        v10 += v17;
        if (v10 >= a3) {
          return v10;
        }
      }
    }

    return v10;
  }

  unsigned int v25 = a1;
  size_t v26 = *(void *)(a1 + 131112);
  AAFieldKey v27 = *(void *)(a1 + 131128);
  AAFieldKey v28 = (void *)(v26 + 48 * v27);
  BOOL v29 = v28[2];
  if (v29 + v28[1] == a4) {
    return ForkOutputStreamWrite((_DWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
  __int16 v31 = (unsigned __int16)v28[2];
  if (*v28)
  {
    int v32 = "pending compressed fork";
    uint64_t v33 = 323;
    goto LABEL_48;
  }

  uint64_t v34 = *v9;
  if (*(void *)(*v9 + 40))
  {
    uint64_t v35 = a3;
    uint64_t v36 = 0LL;
    uint64_t v37 = (v29 & 0xFFFFFFFFFFFF0000LL) + *(void *)(v26 + 48 * v27 + 40);
    __int128 v38 = (unsigned __int16)v28[2];
    while (1)
    {
      uint64_t v39 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v34 + 40))( *(void *)v34,  v25,  v38,  v37);
      if (v39 < 1) {
        break;
      }
      v25 += v39;
      v36 += v39;
      v37 += v39;
      v38 -= v39;
      if (!v38) {
        goto LABEL_45;
      }
    }

    uint64_t v36 = v39;
LABEL_45:
    a3 = v35;
    if (v31 == v36)
    {
LABEL_46:
      *((_DWORD *)v9 + 16) = 1;
      goto LABEL_2;
    }
  }

  int v32 = "aaByteStreamPWriteExpected";
  uint64_t v33 = 325;
LABEL_48:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"ForkOutputStreamPWrite",  v33,  136,  0,  v32,  a7,  a8,  a2);
  return -1LL;
}

    uint64_t v41 = v28 - v8;
    if ((unint64_t)(v28 - v8) < 2)
    {
      uint64_t v42 = v8;
    }

    else
    {
      do
      {
        uint64_t v42 = v8 + (v41 >> 1);
        uint64_t v43 = *(unsigned int *)(a2 + 4 * v42);
        LODWORD(v44) = v9 - v43;
        else {
          char v44 = v10;
        }
        else {
          LODWORD(v45) = v11;
        }
        __int128 v46 = v12 + v43;
        while (1)
        {
          uint64_t v47 = v45 + 8;
          uint64_t v48 = *(void *)(v46 + v45);
          uint64_t v49 = *(void *)(v14 + v45);
          LODWORD(v45) = v45 + 8;
          uint64_t v50 = v49 ^ v48;
          if (v50)
          {
            LODWORD(v45) = v47 + (__clz(__rbit64(v50)) >> 3) - 8;
            goto LABEL_39;
          }
        }

        if (v45 >= v44)
        {
LABEL_46:
          LODWORD(v45) = v44;
          goto LABEL_47;
        }

        int v45 = v45;
        while (*(unsigned __int8 *)(v46 + v45) == *(unsigned __int8 *)(v14 + v45))
        {
          if (++v45 >= v44) {
            goto LABEL_46;
          }
        }

    CC_CKSUM_Update(a1 + 144, (unsigned __int8 *)__src, __smax);
    if ((*(_BYTE *)(a1 + 136) & 0x20) == 0)
    {
LABEL_30:
      if (*(_DWORD *)(a1 + 72))
      {
        if (*(_DWORD *)(a1 + 64))
        {
          uint64_t v19 = v17;
          if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v19, __src, __smax) < 0)
          {
            AAFieldKey v14 = "sending blob data";
            uint64_t v15 = 449;
            goto LABEL_9;
          }

          goto LABEL_33;
        }

        AAFieldKey v28 = (void *)(a1 + 112);
        AAFieldKey v27 = *(void *)(a1 + 112);
        BOOL v29 = __CFADD__(v27, __smax);
        int v30 = v27 + __smax;
        if (v29 || (v30 & 0x8000000000000000LL) != 0) {
          goto LABEL_66;
        }
        __int16 v31 = *(void *)(a1 + 120);
        if (v31 < v30)
        {
          do
          {
            while (!v31)
            {
              __int16 v31 = 0x4000LL;
              if (v30 <= 0x4000)
              {
                uint64_t v33 = (void **)(a1 + 128);
                __int16 v31 = 0x4000LL;
                goto LABEL_56;
              }
            }

            int v32 = v31 >> 1;
            if ((v31 & (v31 >> 1)) != 0) {
              int v32 = v31 & (v31 >> 1);
            }
            v31 += v32;
          }

          while (v31 < v30);
          uint64_t v33 = (void **)(a1 + 128);
          if (v31 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_65;
          }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaSegmentStreamOpen",  v38,  137,  0,  v37,  v10,  v11,  v40);
  }

  else
  {
    uint64_t v34 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaSegmentStreamOpen",  457,  137,  *v34,  "aaSegmentStreamOpen",  v35,  v36,  v40);
    ssize_t v12 = 0LL;
    uint64_t v5 = 0LL;
  }

  free(v12);
  free(v4);
  SegmentStreamClose((uint64_t)v5);
  return 0LL;
}

  __int128 v46 = v103;
  if ((void)v103)
  {
    uint64_t v47 = 0LL;
    uint64_t v48 = (int *)(*((void *)&v103 + 1) + 36LL);
    do
    {
      uint64_t v49 = *v48;
      v48 += 20;
      if (v49) {
        ++v47;
      }
      --v46;
    }

    while (v46);
    if (!v47) {
      *(_DWORD *)(*((void *)&v103 + 1) + 36LL) = 1;
    }
  }

  if (v16 >= 2) {
    bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x1895F89D0]);
  }
  if (v15)
  {
    uint64_t v50 = v103;
    __int128 v96 = a2;
    if ((void)v103)
    {
      uint64_t v34 = 0LL;
      uint64_t v51 = (int *)(*((void *)&v103 + 1) + 36LL);
      do
      {
        uint64_t v52 = *v51;
        v51 += 20;
        if (v52) {
          ++v34;
        }
        --v50;
      }

      while (v50);
      if (v34 == 1)
      {
        uint64_t v53 = 0LL;
        uint64_t v54 = (int *)(*((void *)&v103 + 1) + 36LL);
        while (1)
        {
          char v55 = *v54;
          v54 += 20;
          if (v55) {
            break;
          }
          if (v15 == ++v53)
          {
            int v32 = "could not find unique input";
            uint64_t v33 = 699;
            goto LABEL_17;
          }
        }

        __int128 v67 = v14;
        __int128 v98 = v16;
        __int128 v99 = 0;
        __int128 v97 = a3;
        __int128 v68 = 1;
        uint64_t v34 = 1LL;
LABEL_59:
        __int128 v69 = 0LL;
        __int128 v70 = v67 & 2;
        if (v15 <= 1) {
          int v71 = 1LL;
        }
        else {
          int v71 = v15;
        }
        uint64_t v72 = 36LL;
        do
        {
          if (*(_DWORD *)(*((void *)&v103 + 1) + v72))
          {
            if (bxdiff5CreateInControls((uint64_t)&v102, v69, v70, v27, v28, v29, v30, v31))
            {
              int v32 = "bxdiff5CreateInControls";
              uint64_t v33 = 710;
              goto LABEL_17;
            }

            uint64_t v73 = v53 == v69 ? v68 : 0;
            if ((v99 || v73) && bxdiff5CreateInPatch((uint64_t)&v102, v69))
            {
              int v32 = "bxdiff5CreateInPatch";
              uint64_t v33 = 718;
              goto LABEL_17;
            }
          }

          ++v69;
          v72 += 80LL;
        }

        while (v71 != v69);
        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x1895F89D0]);
        }
        if (v34 >= 2)
        {
          if (bxdiff5CreateComboControls((uint64_t)&v102, v25, v26, v27, v28, v29, v30, v31))
          {
            int v32 = "bxdiff5CreateComboControls";
            uint64_t v33 = 730;
            goto LABEL_17;
          }

          int v79 = 0LL;
          __int128 v80 = *((void *)&v103 + 1);
          int v81 = v71;
          do
          {
            free(*(void **)(v80 + v79 + 40));
            __int128 v80 = *((void *)&v103 + 1);
            __int128 v89 = *((void *)&v103 + 1) + v79;
            *(void *)(v89 + 40) = 0LL;
            *(void *)(v89 + 56) = 0LL;
            v79 += 80LL;
            --v81;
          }

          while (v81);
          if (v98 > 1) {
            bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x1895F89D0]);
          }
          if (bxdiff5CreateComboPatch((uint64_t)&v102, v82, v83, v84, v85, v86, v87, v88))
          {
            int v32 = "bxdiff5CreateComboPatch";
            uint64_t v33 = 747;
            goto LABEL_17;
          }
        }

        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x1895F89D0]);
        }
        if (v34 >= 2)
        {
          __int128 v90 = *((void *)&v108 + 1);
          void *v96 = (void *)v108;
          *__int128 v97 = v90;
          __int128 v108 = 0uLL;
          if (!v99) {
            goto LABEL_97;
          }
          __int128 v91 = (void *)(*((void *)&v103 + 1) + 64LL);
          do
          {
            *v10++ = *v91;
            *v9++ = v91[1];
            *__int128 v91 = 0LL;
            v91[1] = 0LL;
            v91 += 10;
            --v71;
          }

          while (v71);
        }

        if (v34 == 1)
        {
          __int128 v92 = *((void *)&v103 + 1) + 80 * v53;
          void *v96 = *(void **)(v92 + 64);
          *__int128 v97 = *(void *)(v92 + 72);
          *(void *)(v92 + 64) = 0LL;
          *(void *)(v92 + 72) = 0LL;
          goto LABEL_18;
        }

      int v30 = *__error();
      AAFieldKey v27 = "malloc";
      AAFieldKey v28 = 410;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"normalize",  v28,  60,  v30,  v27,  v4,  v5,  v32);
    int v17 = 0LL;
    size_t v26 = 0xFFFFFFFFLL;
    goto LABEL_32;
  }

  return 0LL;
}

      AAFieldKey v28 = *(void **)(a1 + 80);
      BOOL v29 = realloc(v28, v27);
      if (!v29)
      {
        free(v28);
LABEL_71:
        uint8_t *v22 = 0LL;
        v22[1] = 0LL;
        v22[2] = 0LL;
LABEL_72:
        uint64_t v16 = "append to ibuf";
        int v17 = 928;
LABEL_6:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"afscStreamWrite",  v17,  55,  0,  v16,  a7,  a8,  v46);
        uint64_t v10 = -1LL;
        goto LABEL_7;
      }

      *(void *)(a1 + 72) = v27;
      *(void *)(a1 + 80) = v29;
    }

    int v30 = *(void *)(a1 + 80);
    if (v20)
    {
      memcpy((void *)(v30 + *v22), v20, v23);
    }

    else if (v30)
    {
      memset_s((void *)(v30 + *v22), v23, 0, v23);
    }

    unint64_t v21 = *v22 + v23;
    uint8_t *v22 = v21;
    if ((v23 & 0x8000000000000000LL) != 0) {
      goto LABEL_72;
    }
    __int16 v31 = *(void *)(a1 + 24) + v23;
    *(void *)(a1 + 24) = v31;
    if (v21 == 0x10000 || v21 && v31 == *(void *)(a1 + 16))
    {
      int v32 = (v31 + 0xFFFFFFFFFFFFLL) >> 16;
      if (*(_DWORD *)(a1 + 44) <= v32)
      {
        char v44 = "invalid state";
        int v45 = 740;
        goto LABEL_75;
      }

      uint64_t v33 = *(void *)(a1 + 88);
      if ((unint64_t)(*(void *)(a1 + 96) - v33) <= 0x10000)
      {
        if ((flushOBuf_0(a1, (uint64_t)__src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
        {
          char v44 = "flushing obuf";
          int v45 = 744;
          goto LABEL_75;
        }

        unint64_t v21 = *(void *)(a1 + 64);
        uint64_t v33 = *(void *)(a1 + 88);
      }

      uint64_t v34 = *(const uint8_t **)(a1 + 80);
      uint64_t v35 = (uint8_t *)(*(void *)(a1 + 104) + v33);
      uint64_t v36 = *(_DWORD *)(a1 + 32);
      if (v36 != 10
        && v21 >= 0x78
        && ((v37 = v36 - 3, v37 > 0xB) ? (__int128 v38 = -1) : (__int128 v38 = dword_1862D8204[v37]),
            (uint64_t v39 = *(const uint8_t **)(a1 + 80),
             __int128 v40 = compression_encode_buffer(v35, 0x10000uLL, v39, v21, *(void **)(a1 + 56), v38),
             uint64_t v34 = v39,
             v40)
         && ((*(_BYTE *)(a1 + 8) & 1) != 0 ? (__srCC_SHA256_CTX c = (char *)((v40 >> 6) + 32)) : (__srCC_SHA256_CTX c = 0LL),
             (uint64_t v41 = &__src[v40]) != 0LL && (unint64_t)v41 < v21)))
      {
      }

      else
      {
        *uint64_t v35 = *(_BYTE *)(a1 + 36);
        memcpy(v35 + 1, v34, v21);
        uint64_t v41 = (char *)(v21 + 1);
      }

      *(_DWORD *)(*(void *)(a1 + 48) + 4LL * (v32 + 1)) = *(_DWORD *)(*(void *)(a1 + 48)
      if (v41)
      {
        uint64_t v42 = *(void *)(a1 + 88);
        AAFieldKey v14 = __CFADD__(v42, v41);
        uint64_t v43 = &v41[v42];
        if (v14 || (unint64_t)v43 > *(void *)(a1 + 96))
        {
          char v44 = "expand obuf";
          int v45 = 780;
LABEL_75:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"flushIBuf",  v45,  55,  0,  v44,  a7,  a8,  v46);
          uint64_t v16 = "flushing ibuf";
          int v17 = 938;
          goto LABEL_6;
        }

        *(void *)(a1 + 88) = v43;
      }

      if (*(void *)(a1 + 24) == *(void *)(a1 + 16)
        && (flushOBuf_0(a1, (uint64_t)__src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        char v44 = "flushing obuf";
        int v45 = 784;
        goto LABEL_75;
      }

      unint64_t v21 = 0LL;
      uint64_t v22 = v47;
      *uint64_t v47 = 0LL;
    }

    v20 += v23;
    v10 += v23;
    v11 -= v23;
  }

  while (v11);
  if (v10 < 0)
  {
LABEL_7:
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8)) {
        return v10;
      }
    }

    __clrex();
  }

  return v10;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"writerProc",  v30,  128,  0,  v29,  a7,  a8,  v52);
    AAFieldKey v27 = 0xFFFFFFFFLL;
LABEL_60:
    pthread_mutex_unlock(v12);
    return v27;
  }

  uint64_t v15 = *(void *)(a1 + 8);
  if (*(void *)(v15 + 40))
  {
    uint64_t v16 = 0LL;
    if (a2)
    {
      int v17 = a2;
      while (1)
      {
        int v18 = (*(uint64_t (**)(void, char *, size_t, uint64_t))(v15 + 40))(*(void *)v15, a4, v17, a3);
        if (v18 < 1) {
          break;
        }
        a4 += v18;
        v16 += v18;
        a3 += v18;
        v17 -= v18;
        if (!v17) {
          goto LABEL_16;
        }
      }

      uint64_t v16 = v18;
    }
  }

  else
  {
    uint64_t v16 = -1LL;
  }

uint64_t treeDeleteRangeWithPoint( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  if (*a2 < 0) {
    return 0LL;
  }
  char v9 = a3;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = (void *)(v12 + 56 * v8);
  if (*v13 > a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 24, a3) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeDeleteRangeWithPoint",  456,  107,  0,  "treeDelete: %zd",  v18,  v19,  v9);
      return 0xFFFFFFFFLL;
    }

    goto LABEL_30;
  }

  if (*(void *)(v12 + 56 * v8 + 8) <= a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 32, a3) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeDeleteRangeWithPoint",  463,  107,  0,  "treeDelete: %zd",  v18,  v19,  v9);
      return 0xFFFFFFFFLL;
    }

    goto LABEL_30;
  }

  uint64_t v20 = v12 + 56 * v8;
  uint64_t v23 = *(void *)(v20 + 24);
  uint64_t v21 = v20 + 24;
  uint64_t v22 = v23;
  uint64_t v24 = v21 + 8;
  uint64_t v25 = *(void *)(v21 + 8);
  if ((v23 & 0x8000000000000000LL) == 0)
  {
    if (v25 < 0) {
      int v26 = 0;
    }
    else {
      int v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    }
    int v27 = *(_DWORD *)(v12 + 56 * v22 + 48);
LABEL_15:
    if (v26 >= v27)
    {
      if ((v25 & 0x8000000000000000LL) == 0)
      {
        do
        {
          uint64_t v28 = v25;
          uint64_t v25 = *(void *)(v12 + 56 * v25 + 24);
        }

        while ((v25 & 0x8000000000000000LL) == 0);
        goto LABEL_29;
      }

      uint64_t v31 = v8;
      while (1)
      {
        uint64_t v28 = *(void *)(v12 + 56 * v31 + 16);
        if (v28 < 0) {
          break;
        }
        BOOL v30 = *(void *)(v12 + 56 * v28 + 32) == v31;
        uint64_t v31 = *(void *)(v12 + 56 * v31 + 16);
        if (!v30) {
          goto LABEL_29;
        }
      }
    }

    else
    {
      if ((v22 & 0x8000000000000000LL) == 0)
      {
        do
        {
          uint64_t v28 = v22;
          uint64_t v22 = *(void *)(v12 + 56 * v22 + 32);
        }

        while ((v22 & 0x8000000000000000LL) == 0);
LABEL_25:
        uint64_t v24 = v21;
LABEL_29:
        __int128 v32 = *(_OWORD *)(v12 + 56 * v28);
        *(_OWORD *)uint64_t v13 = v32;
        if ((treeDeleteRangeWithPoint(a1, v24, v32) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeDeleteRangeWithPoint",  493,  107,  0,  "treeDelete: %zd",  v18,  v19,  v9);
          return 0xFFFFFFFFLL;
        }

uint64_t treeRebalance( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v35 = v8;
  if (v8 < 0) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = *(void *)(v11 + 56 * v8 + 32);
  int v13 = v12 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v12 + 48);
  uint64_t v14 = *(void *)(v11 + 56 * v8 + 24);
  int v15 = v14 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v14 + 48);
  int v16 = v13 - v15;
  if (v16 == -2)
  {
    if ((v14 & 0x8000000000000000LL) == 0)
    {
      uint64_t v20 = *(void *)(v11 + 56 * v14 + 32);
      int v21 = v20 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v20 + 48);
      uint64_t v28 = *(void *)(v11 + 56 * v14 + 24);
      int v29 = v28 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v28 + 48);
      if (v21 > v29)
      {
        uint64_t v34 = v14;
        if ((treeRotateLeft(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeRebalance",  360,  107,  0,  "treeRotateLeft %zd",  v30,  v31,  v34);
          return 0xFFFFFFFFLL;
        }

        *(void *)(*(void *)(a1 + 8) + 56 * v8 + 24) = v34;
      }
    }

    if ((treeRotateRight(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeRebalance",  364,  107,  0,  "treeRotateRight %zd",  v32,  v33,  v35);
      return 0xFFFFFFFFLL;
    }

    goto LABEL_36;
  }

  if (v16 == 2)
  {
    if ((v12 & 0x8000000000000000LL) == 0)
    {
      uint64_t v18 = *(void *)(v11 + 56 * v12 + 32);
      int v19 = v18 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v18 + 48);
      uint64_t v22 = *(void *)(v11 + 56 * v12 + 24);
      int v23 = v22 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v22 + 48);
      if (v19 < v23)
      {
        uint64_t v34 = v12;
        if ((treeRotateRight(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeRebalance",  347,  107,  0,  "treeRotateRight %zd",  v24,  v25,  v34);
          return 0xFFFFFFFFLL;
        }

        *(void *)(*(void *)(a1 + 8) + 56 * v8 + 32) = v34;
      }
    }

    if ((treeRotateLeft(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeRebalance",  351,  107,  0,  "treeRotateRight %zd",  v26,  v27,  v35);
      return 0xFFFFFFFFLL;
    }

uint64_t treeSub( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = (uint64_t *)(a1 + 2);
  uint64_t v8 = a1[2];
  if (v8 < 0) {
    return 0LL;
  }
  while (2)
  {
    unint64_t v13 = a1[1];
    while (1)
    {
      uint64_t v14 = (uint64_t *)(v13 + 56 * v8);
      uint64_t v15 = *v14;
      if (*v14 >= a3)
      {
        uint64_t v20 = (uint64_t *)(v13 + 56 * v8 + 24);
        goto LABEL_7;
      }

      unint64_t v16 = v13 + 56 * v8;
      uint64_t v19 = *(void *)(v16 + 8);
      uint64_t v18 = (uint64_t *)(v16 + 8);
      uint64_t v17 = v19;
      if (v19 > a2) {
        break;
      }
      uint64_t v20 = (uint64_t *)(v13 + 56 * v8 + 32);
LABEL_7:
      uint64_t v8 = *v20;
      if (v8 < 0) {
        return 0LL;
      }
    }

    if (v15 < a2 || v17 > a3)
    {
      if (v15 >= a2)
      {
        *uint64_t v14 = a3;
      }

      else
      {
        *uint64_t v18 = a2;
        if (v17 > a3 && (treeAdd(a1, -1LL, v9, a3, v17, a6, a7, a8) & 0x80000000) != 0)
        {
          int v23 = "treeAdd";
          __int16 v24 = 538;
          goto LABEL_23;
        }
      }

LABEL_20:
      uint64_t result = 0LL;
      uint64_t v8 = *v9;
      if (*v9 < 0) {
        return result;
      }
      continue;
    }

    break;
  }

  int v23 = "treeDeleteRangeWithPoint";
  __int16 v24 = 525;
LABEL_23:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeSub",  v24,  107,  0,  v23,  a7,  a8,  v25);
  return 0xFFFFFFFFLL;
}

  uint64_t result = pthread_mutex_unlock(v10);
  if ((_DWORD)result)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"chunkAsyncProcess",  582,  143,  0,  "unlock",  v22,  v23,  v25);
    while (!__ldaxr(v4))
    {
      if (!__stlxr(1u, v4))
      {
        AAAsyncByteStreamCancel(*(void **)a1);
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  return result;
}

  char v25 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v79[0]) = v25;
  memset_s((char *)v79 + v25 + 4, 256 - v25, 0, 256 - v25);
  uint64_t v26 = *(void *)(a1 + 2720);
  uint64_t v28 = *(_OWORD *)(v26 + v61 + 16);
  uint64_t v27 = *(_OWORD *)(v26 + v61 + 32);
  __int128 v125 = *(_OWORD *)(v26 + v61);
  __int128 v126 = v28;
  __int128 v127 = v27;
  int v29 = HIDWORD(v65[0]);
  uint64_t v30 = *(unsigned int *)(a2 + 4);
  uint64_t v31 = (v30 + HIDWORD(v65[0]));
  uint64_t v32 = (char *)malloc(v31);
  uint64_t v33 = v32;
  if (!v32)
  {
    uint64_t v52 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"aeaContextUnlock",  113,  57,  *v52,  "malloc",  v53,  v54,  v58);
LABEL_75:
    uint64_t v43 = 0xFFFFFFFFLL;
    goto LABEL_76;
  }

  memcpy(v32, (const void *)(v26 + *((void *)&v61 + 1)), v29);
  memcpy(&v33[v29], (const void *)(v26 + *((void *)&v60[0] + 1)), v30);
  memset((char *)__s + 12, 0, 248);
  *(void *)((char *)__s + 4) = 0x4B4548525F414541LL;
  LODWORD(__s[0]) = 8;
  memset_s((char *)__s + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((void *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_58:
    uint64_t v43 = 0xFFFFFFFFLL;
    goto LABEL_59;
  }

  uint64_t v34 = (*((uint64_t (**)(_OWORD *, void, size_t *, _OWORD *, _BYTE *))&v68 + 1))( v77,  DWORD1(v65[0]),  __n,  __s,  v133);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v34 < 0
    || !(void)v70
    || LODWORD(v79[0]) != HIDWORD(v65[0])
    || (((uint64_t (*)(__int128 *, uint64_t, _OWORD *, _OWORD *, char *, size_t))v70)( &v125,  48LL,  v79,  v77,  v33,  v31) & 0x80000000) != 0)
  {
    goto LABEL_58;
  }

  if ((aeaContainerParamsInitWithRootHeader(a2, (uint64_t)&v125, v35, v36, v37, v38, v39, v40) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"aeaContextUnlock",  126,  57,  0,  "Invalid root header",  v41,  v42,  v58);
    goto LABEL_58;
  }

  uint64_t v43 = (uint64_t)v59;
  if (a3)
  {
    uint64_t v44 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101) {
      goto LABEL_78;
    }
    memcpy(a3 + 1, (char *)__n + 4, LODWORD(__n[0]));
    *a3 = v44;
    memset_s((char *)a3 + v44 + 4, 256 - v44, 0, 256 - v44);
  }

  if (v59)
  {
    uint64_t v45 = LODWORD(v108[0]);
    if (LODWORD(v108[0]) < 0x101)
    {
      memcpy(v59 + 1, (char *)v108 + 4, LODWORD(v108[0]));
      *__int128 v59 = v45;
      memset_s((char *)v59 + v45 + 4, 256 - v45, 0, 256 - v45);
      uint64_t v43 = 0LL;
      goto LABEL_59;
    }

    memset(buf, 0, 12);
    uint64_t v27 = AAByteStreamRead(*(AAByteStream *)(v8 + 24), buf, 0xCuLL);
    if (v27 != 12) {
      break;
    }
    switch(LODWORD(buf[0]))
    {
      case 'A':
        goto LABEL_25;
      case 'B':
        if (*(void *)(v8 + 168)) {
          goto LABEL_74;
        }
        uint64_t v35 = 786;
        unsigned int v36 = "no entry in thread";
        goto LABEL_83;
      case 'C':
        goto LABEL_67;
      case 'D':
        uint64_t v42 = *(void *)(v8 + 168);
        if (!v42) {
          goto LABEL_74;
        }
        uint64_t v43 = *(void *)(v42 + 2192);
        if (v43 == -1LL)
        {
          uint64_t v35 = 847;
          unsigned int v36 = "DAT size not received yet";
          goto LABEL_83;
        }

        if (*(void *)(v42 + 2288)) {
          goto LABEL_38;
        }
        if ((*(_BYTE *)(v42 + 2056) & 4) == 0)
        {
          __int128 v76 = 0LL;
          __int128 v77 = -1;
          goto LABEL_99;
        }

        __int128 v76 = 0LL;
        __int128 v77 = -1;
        if (!v43 || (*(_DWORD *)(v42 + 2068) & 0x20) == 0) {
          goto LABEL_99;
        }
        if ((*(_BYTE *)(v42 + 2128) & 1) != 0)
        {
          __int128 v77 = *(_DWORD *)(v42 + 2136);
          if ((*(_BYTE *)(v42 + 2128) & 0x10) == 0)
          {
LABEL_159:
            __int128 v76 = 0LL;
            goto LABEL_99;
          }
        }

        else
        {
          __int128 v77 = 0;
          if ((*(_BYTE *)(v42 + 2128) & 0x10) == 0) {
            goto LABEL_159;
          }
        }

        __int128 v76 = *(unsigned int *)(v42 + 2156);
        uint64_t v86 = *(unsigned int *)(v42 + 2152);
        if ((_DWORD)v86)
        {
          if (v43 <= v86)
          {
            __int128 v76 = v76 & 0xFFFFFFFC;
            __int128 v77 = 10;
          }

          else
          {
            v76 |= 3uLL;
          }
        }

  uint64_t v26 = value;
  if (strlen(__s) >= 0x400)
  {
    int v29 = "path too long";
    uint64_t v30 = 198;
    uint64_t v31 = 0;
LABEL_34:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"entryCreate",  v30,  72,  v31,  v29,  v27,  v28,  v95);
    *(void *)(a1 + 1632) = 0LL;
    uint64_t v10 = "entry creation";
    uint64_t v11 = 1295;
    goto LABEL_4;
  }

  uint64_t v34 = (char *)malloc(0x938uLL);
  if (!v34)
  {
    uint64_t v31 = *__error();
    int v29 = "malloc";
    uint64_t v30 = 200;
    goto LABEL_34;
  }

  uint64_t v35 = v34;
  memset_s(v34, 0x938uLL, 0, 0x938uLL);
  __memcpy_chk();
  *((void *)v35 + 256) = v26;
  *((_DWORD *)v35 + 574) = -1;
  *((void *)v35 + 289) = -1LL;
  *((void *)v35 + 290) = -1LL;
  *((void *)v35 + 291) = -1LL;
  *((void *)v35 + 273) = -1LL;
  *((void *)v35 + 274) = -1LL;
  atomic_store(1u, (unsigned int *)v35 + 576);
  *(void *)(a1 + 1632) = v35;
  ++*(_DWORD *)(a1 + 1664);
  switch(value)
  {
    case 'L':
      ++*(_DWORD *)(a1 + 1676);
      break;
    case 'F':
      ++*(_DWORD *)(a1 + 1668);
      break;
    case 'D':
      ++*(_DWORD *)(a1 + 1672);
      break;
  }

  if ((aaHeaderBlobArrayInitWithHeader(a1 + 1616, header) & 0x80000000) != 0)
  {
    uint64_t v10 = "Eerror getting blobs from header";
    uint64_t v11 = 1307;
    goto LABEL_4;
  }

  if ((aaEntryAttributesInitWithHeader(v35 + 2056, v35 + 2128, 0LL, header) & 0x80000000) != 0)
  {
    uint64_t v10 = "getting attributes from header";
    uint64_t v11 = 1310;
    goto LABEL_4;
  }

  unsigned int v36 = *(uint64_t (**)(void, uint64_t, char *, char *))(a1 + 1040);
  if (v36)
  {
    if ((v36(*(void *)(a1 + 1032), 23LL, v35, v35 + 2056) & 0x80000000) != 0)
    {
      uint64_t v10 = "message callback cancelled operations";
      uint64_t v11 = 1314;
      goto LABEL_4;
    }

    uint64_t v37 = *(uint64_t (**)(void, uint64_t, char *, char *))(a1 + 1040);
    if (v37
      && (*(_BYTE *)(a1 + 1030) & 0x10) != 0
      && (v37(*(void *)(a1 + 1032), 26LL, v35, v35 + 2128) & 0x80000000) != 0)
    {
      uint64_t v10 = "message callback cancelled operations";
      uint64_t v11 = 1320;
      goto LABEL_4;
    }
  }

  if ((v35[2056] & 4) != 0 && (v35[2068] & 0x20) != 0 && (v35[2128] & 1) != 0 && *((_DWORD *)v35 + 534) == -1)
  {
    uint64_t v10 = "disable AFSC by clearing UF_COMPRESSED";
    uint64_t v11 = 1325;
    goto LABEL_4;
  }

  v38.uint64_t ikey = 4997953;
  uint64_t v39 = AAHeaderGetKeyIndex(header, v38);
  if ((v39 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v39, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000LL) != 0)
    {
LABEL_166:
      uint64_t v10 = "ACL blob allocation";
      uint64_t v11 = 1331;
      goto LABEL_4;
    }

    uint64_t v40 = *((void *)v35 + 279);
    if (v40 < size)
    {
      do
      {
        while (!v40)
        {
          uint64_t v40 = 0x4000LL;
          if (size <= 0x4000)
          {
            uint64_t v42 = (void **)(v35 + 2240);
            uint64_t v40 = 0x4000LL;
            goto LABEL_66;
          }
        }

        uint64_t v41 = v40 >> 1;
        if ((v40 & (v40 >> 1)) != 0) {
          uint64_t v41 = v40 & (v40 >> 1);
        }
        v40 += v41;
      }

      while (v40 < size);
      uint64_t v42 = (void **)(v35 + 2240);
      if (v40 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_165;
      }

  unint64_t v16 = *v13;
  uint64_t v15 = (char *)realloc(*v13, v11);
  if (!v15)
  {
    free(v16);
LABEL_60:
    *unint64_t v13 = 0LL;
    void *v10 = 0LL;
    *(void *)(a1 + 24) = 0LL;
LABEL_61:
    uint64_t v8 = "realloc blob";
    char v9 = 121;
    goto LABEL_62;
  }

  *(void *)(a1 + 24) = v11;
  *(void *)(a1 + 32) = v15;
  uint64_t v14 = *(void *)(a1 + 16);
  if (a2) {
    goto LABEL_22;
  }
  memset_s(&v15[v14], a3, 0, a3);
LABEL_23:
  uint64_t v17 = *v10 + a3;
  void *v10 = v17;
  if (v17 < 4) {
    goto LABEL_61;
  }
  **(_DWORD **)(a1 + 32) = 825246017;
  if (a3 < 7) {
    return 0LL;
  }
  uint64_t v34 = 0LL;
  uint64_t v18 = 6LL;
  while (2)
  {
    if ((realloc_fields(a1, *(_DWORD *)a1 + 1) & 0x80000000) != 0)
    {
      uint64_t v8 = "realloc_fields";
      char v9 = 127;
      goto LABEL_62;
    }

    uint64_t v19 = *(void *)(a1 + 8);
    uint64_t v20 = (*(_DWORD *)a1)++;
    if (v18 + 4 > a3)
    {
      uint64_t v8 = "truncated header";
      char v9 = 130;
      goto LABEL_62;
    }

    int v21 = v19 + 48LL * v20;
    uint64_t v22 = (char *)a2 + v18;
    *(_DWORD *)int v21 = *(_DWORD *)((char *)a2 + v18);
    int v23 = *(char *)(v21 + 3);
    *(_DWORD *)(v21 + 8) = v23;
    *(_BYTE *)(v21 + 3) = 0;
    switch(v23)
    {
      case '1':
        __int16 v24 = 1;
        char v25 = 1LL;
        goto LABEL_50;
      case '2':
        __int16 v24 = 1;
        goto LABEL_36;
      case '3':
      case '5':
      case '6':
      case '7':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'D':
      case 'E':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'Q':
      case 'R':
        goto LABEL_68;
      case '4':
        __int16 v24 = 1;
        goto LABEL_40;
      case '8':
        __int16 v24 = 1;
        goto LABEL_48;
      case 'A':
        __int16 v24 = 5;
LABEL_36:
        char v25 = 2LL;
        goto LABEL_50;
      case 'B':
        __int16 v24 = 5;
        goto LABEL_40;
      case 'C':
        __int16 v24 = 5;
        goto LABEL_48;
      case 'F':
        __int16 v24 = 3;
LABEL_40:
        char v25 = 4LL;
        goto LABEL_50;
      case 'G':
        __int16 v24 = 3;
        char v25 = 20LL;
        goto LABEL_50;
      case 'H':
        __int16 v24 = 3;
        char v25 = 32LL;
        goto LABEL_50;
      case 'I':
        __int16 v24 = 3;
        char v25 = 48LL;
        goto LABEL_50;
      case 'J':
        __int16 v24 = 3;
        char v25 = 64LL;
        goto LABEL_50;
      case 'P':
        if (v18 + 6 <= a3)
        {
          uint64_t v34 = *((unsigned __int16 *)v22 + 2);
          char v25 = v34 + 2;
          __int16 v24 = 2;
LABEL_50:
          *(_DWORD *)(v19 + 48LL * v20 + 4) = v24;
          if (v18 + 4 + v25 > a3)
          {
            uint64_t v8 = "truncated header";
            char v9 = 161;
            goto LABEL_62;
          }

          uint64_t v26 = 0LL;
          uint64_t v27 = v19 + 48LL * v20;
          *(void *)(v27 + 24) = 0LL;
          uint64_t v28 = (void *)(v27 + 24);
          int v29 = v25 + 4;
          *((_DWORD *)v28 - 3) = v18;
          *((_DWORD *)v28 - 2) = v25 + 4;
          v28[2] = 0LL;
          uint64_t v30 = v28 + 2;
          v28[1] = 0LL;
          switch(v24)
          {
            case 1:
              memcpy(v30, v22 + 4, v25);
              uint64_t v26 = 0LL;
              break;
            case 2:
              uint64_t v26 = 0LL;
              *uint64_t v30 = v34;
              break;
            case 3:
              uint64_t v26 = 0LL;
              *uint64_t v30 = v25;
              break;
            case 5:
              uint64_t v31 = v19 + 48LL * v20;
              memcpy((void *)(v31 + 32), v22 + 4, v25);
              *uint64_t v28 = *(void *)(a1 + 40);
              uint64_t v26 = *(void *)(v31 + 32);
              break;
            default:
              break;
          }

          uint64_t result = 0LL;
          *(void *)(a1 + 40) += v26;
          v18 += v29;
          if (v18 >= a3) {
            return result;
          }
          continue;
        }

        uint64_t v8 = "truncated header";
        char v9 = 153;
LABEL_62:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"aaHeaderInitWithEncodedData",  v9,  101,  0,  v8,  v6,  v7,  v33);
LABEL_63:
        *(_DWORD *)a1 = 0;
        *(void *)(a1 + 16) = 0LL;
        uint64_t result = 0xFFFFFFFFLL;
        *(void *)(a1 + 40) = 0LL;
        return result;
      case 'S':
        __int16 v24 = 4;
LABEL_48:
        char v25 = 8LL;
        goto LABEL_50;
      case 'T':
        __int16 v24 = 4;
        char v25 = 12LL;
        goto LABEL_50;
      default:
        if (v23 != 42)
        {
LABEL_68:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"aaHeaderInitWithEncodedData",  159,  101,  0,  "invalid field subtype: %d",  v6,  v7,  v23);
          goto LABEL_63;
        }

        __int16 v24 = 0;
        char v25 = 0LL;
        goto LABEL_50;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"AAHeaderSetFieldFlag",  v19,  101,  0,  v18,  v5,  v6,  v21);
  return -1;
}

  if (v11 == a3 && v7 == a3) {
    return a3;
  }
  else {
    return -1LL;
  }
}

  if (v14 == a3 && v9 == a3) {
    return a3;
  }
  else {
    return -1LL;
  }
}

      if (!(_DWORD)v12)
      {
        int v21 = *(unsigned int *)(a1 + 44);
        uint64_t v22 = 8 * v21 + 264;
        int v23 = 4 * v21 + 4;
        if (*(_DWORD *)(a1 + 32) == 4) {
          uint64_t v12 = v22;
        }
        else {
          uint64_t v12 = v23;
        }
        uint64_t v14 = 0xFFFFFFFFLL;
        if (v12 >= 0xFFFFFFFF)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"resourceForkHeaderSize",  146,  55,  0,  "invalid file size",  a7,  a8,  v27);
          *unint64_t v13 = -1;
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"flushOBuf",  714,  55,  0,  "File too large for AFSC",  v24,  v25,  v28);
          return v14;
        }

        *unint64_t v13 = v12;
      }

      if ((fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 104), *(void *)(a1 + 88), v12, 0) & 0x80000000) == 0)
      {
        uint64_t v14 = 0LL;
        *(_DWORD *)(a1 + 40) += *(_DWORD *)(a1 + 88);
        *(void *)(a1 + 88) = 0LL;
        return v14;
      }

      uint64_t v20 = *__error();
      uint64_t v18 = "fsetxattr resource fork";
      uint64_t v19 = 723;
LABEL_31:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"flushOBuf",  v19,  55,  v20,  v18,  a7,  a8,  v27);
      return 0xFFFFFFFFLL;
    }
  }

  unint64_t v13 = (_DWORD *)(a1 + 40);
  LODWORD(v12) = *(_DWORD *)(a1 + 40);
  if (v12 | v9
    || *(_DWORD *)(a1 + 44) != 1
    || *(void *)(a1 + 24) != *(void *)(a1 + 16)
    || (unint64_t)(*(void *)(a1 + 88) + 16LL) >= 0xE01)
  {
    if (!v10) {
      goto LABEL_20;
    }
    goto LABEL_15;
  }

  return 0LL;
}

  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 29)))
  {
    uint64_t v20 = *((_DWORD *)v2 + 56);
    *((_DWORD *)v2 + 56) = v20 + 1;
    if (v20 || !pthread_cond_broadcast((pthread_cond_t *)(v2 + 37))) {
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 29));
    }
  }

  unint64_t v16 = 0xFFFFFFFFLL;
LABEL_25:
  free(v23);
  return v16;
}

uint64_t treeAdd( unint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a5 - a4;
  if (a5 <= a4) {
    return 0LL;
  }
  uint64_t v13 = *a3;
  uint64_t v55 = v13;
  if (v13 < 0)
  {
    uint64_t v13 = a1[3];
    if ((v13 & 0x8000000000000000LL) == 0)
    {
      uint64_t v15 = (char *)a1[1];
      goto LABEL_5;
    }

    if (*a1) {
      unint64_t v36 = 2 * *a1;
    }
    else {
      unint64_t v36 = 32LL;
    }
    if (56 * v36 < 0x2000000001LL)
    {
      __int128 v46 = (void *)a1[1];
      uint64_t v15 = (char *)realloc(v46, 56 * v36);
      if (v15)
      {
        a1[1] = (unint64_t)v15;
        uint64_t v47 = *a1;
        if (*a1 >= v36)
        {
          uint64_t v13 = -1LL;
        }

        else
        {
          uint64_t v48 = (uint64_t *)&v15[56 * v47 + 16];
          uint64_t v49 = -1LL;
          do
          {
            uint64_t *v48 = v49;
            v48 += 7;
            uint64_t v49 = v47++;
          }

          while (v36 != v47);
          uint64_t v13 = v47 - 1;
        }

        *a1 = v36;
LABEL_5:
        unint64_t v16 = &v15[56 * v13];
        a1[3] = *((void *)v16 + 2);
        *((void *)v16 + 2) = a2;
        *((void *)v16 + 3) = -1LL;
        *(void *)unint64_t v16 = a4;
        *((void *)v16 + 1) = a5;
        *((_DWORD *)v16 + 12) = 1;
        *((void *)v16 + 4) = -1LL;
        *((void *)v16 + 5) = v8;
        uint64_t v55 = v13;
        if ((v13 & 0x8000000000000000LL) == 0) {
          goto LABEL_6;
        }
LABEL_75:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeAdd",  391,  107,  0,  "nodeAlloc",  a7,  a8,  v53);
        return 0xFFFFFFFFLL;
      }

      free(v46);
    }

    else
    {
      *__error() = 12;
    }

    a1[1] = 0LL;
    uint64_t v50 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"nodeAlloc",  43,  107,  *v50,  "malloc",  v51,  v52,  v53);
    goto LABEL_75;
  }

LABEL_6:
  unint64_t v17 = a1[1];
  uint64_t v18 = (uint64_t *)(v17 + 56 * v13);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[3];
  if (v20 < 0)
  {
    int64_t v23 = 0x8000000000000000LL;
  }

  else
  {
    uint64_t v21 = v18[3];
    do
    {
      uint64_t v22 = v21;
      uint64_t v21 = *(void *)(v17 + 56 * v21 + 32);
    }

    while ((v21 & 0x8000000000000000LL) == 0);
    int64_t v23 = *(void *)(v17 + 56 * v22 + 8);
  }

  if (v19 > a4 && v19 <= a5 && v23 < v19)
  {
    if (a4 <= v23) {
      uint64_t v19 = v23;
    }
    else {
      uint64_t v19 = a4;
    }
    *uint64_t v18 = v19;
  }

  uint64_t v25 = *(void *)(v17 + 56 * v13 + 32);
  if (v25 < 0)
  {
    uint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
  }

  else
  {
    do
    {
      uint64_t v26 = v25;
      uint64_t v25 = *(void *)(v17 + 56 * v25 + 24);
    }

    while ((v25 & 0x8000000000000000LL) == 0);
    uint64_t v27 = *(void *)(v17 + 56 * v26);
  }

  uint64_t v30 = v18[1];
  uint64_t v28 = v18 + 1;
  uint64_t v29 = v30;
  if (v30 < a5 && v29 >= a4 && v27 > v29)
  {
    if (v27 >= a5) {
      uint64_t v29 = a5;
    }
    else {
      uint64_t v29 = v27;
    }
    *uint64_t v28 = v29;
  }

  if (v19 > a4)
  {
    if (v19 >= a5) {
      uint64_t v31 = a5;
    }
    else {
      uint64_t v31 = v19;
    }
    uint64_t v54 = v20;
    if ((treeAdd(a1, v13, &v54, a4, v31) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeAdd",  418,  107,  0,  "treeAdd: %zd",  a7,  a8,  v54);
      return 0xFFFFFFFFLL;
    }

    unint64_t v17 = a1[1];
    *(void *)(v17 + 56 * v13 + 24) = v54;
  }

  if (v29 < a5)
  {
    if (v29 <= a4) {
      uint64_t v32 = a4;
    }
    else {
      uint64_t v32 = v29;
    }
    uint64_t v54 = *(void *)(v17 + 56 * v13 + 32);
    if ((treeAdd(a1, v13, &v54, v32, a5) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeAdd",  428,  107,  0,  "treeAdd: %zd",  a7,  a8,  v54);
      return 0xFFFFFFFFLL;
    }

    unint64_t v17 = a1[1];
    *(void *)(v17 + 56 * v13 + 32) = v54;
  }

  if ((v13 & 0x8000000000000000LL) == 0)
  {
    uint64_t v33 = (void *)(v17 + 56 * v13);
    uint64_t v34 = v33[3];
    if (v34 < 0) {
      unsigned int v35 = 0;
    }
    else {
      unsigned int v35 = *(_DWORD *)(v17 + 56 * v34 + 48);
    }
    uint64_t v37 = *(void *)(v17 + 56 * v13 + 32);
    if (v37 < 0) {
      unsigned int v38 = 0;
    }
    else {
      unsigned int v38 = *(_DWORD *)(v17 + 56 * v37 + 48);
    }
    if (v38 > v35) {
      unsigned int v35 = v38;
    }
    unint64_t v39 = v17 + 56 * v13;
    *(_DWORD *)(v39 + 48) = v35 + 1;
    uint64_t v40 = *(void *)(v39 + 8) - *v33;
    if (v34 < 0) {
      uint64_t v41 = 0LL;
    }
    else {
      uint64_t v41 = *(void *)(v17 + 56 * v34 + 40);
    }
    uint64_t v42 = v40 + v41;
    if (v37 < 0) {
      uint64_t v43 = 0LL;
    }
    else {
      uint64_t v43 = *(void *)(v17 + 56 * v37 + 40);
    }
    *(void *)(v17 + 56 * v13 + 40) = v42 + v43;
  }

  if ((treeRebalance((uint64_t)a1, &v55, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
  {
    uint64_t result = 0LL;
    *a3 = v55;
    return result;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"treeAdd",  434,  107,  0,  "treeRebalance: %zd",  v44,  v45,  v55);
  return 0xFFFFFFFFLL;
}

  if (*(_DWORD *)v3 <= 5u && ((1 << *(_DWORD *)v3) & 0x2A) != 0) {
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 592))
  {
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 240);
    if (!v15) {
      goto LABEL_23;
    }
    unint64_t v16 = v15(a1 + 332, a1 + 592);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104) || v16 < 0) {
      goto LABEL_23;
    }
    unint64_t v17 = *(_DWORD *)(a1 + 592);
    if (v17 >= 0x101)
    {
      __break(1u);
LABEL_23:
      uint64_t v12 = "Invalid signing private key in context";
      uint64_t v13 = 45;
      goto LABEL_27;
    }
  }

  else
  {
    unint64_t v17 = 0;
  }

  __memcpy_chk();
  *(_DWORD *)(v3 + 1188) = v17;
  memset_s((void *)(v3 + 1192 + v17), 256LL - v17, 0, 256LL - v17);
  *(_OWORD *)(v3 + 1712) = *(_OWORD *)(a1 + 2416);
  if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104))
  {
    uint64_t v12 = "Invalid signing public key in context";
    uint64_t v13 = 55;
    goto LABEL_27;
  }

  pthread_attr_destroy(v11);
  free(v11);
  if (!(_DWORD)v13) {
    return v13;
  }
LABEL_10:
  uint64_t v26 = (const void *)v9[2];
  if (v26) {
    _Block_release(v26);
  }
  free(v9);
  return v13;
}

  uint64_t v19 = malloc(0x18uLL);
  __int128 v80 = v19;
  if (!v19)
  {
    uint64_t v33 = *__error();
    uint64_t v34 = "aaMalloc";
    unsigned int v35 = 534;
    goto LABEL_72;
  }

  uint64_t v20 = v17;
  LODWORD(v17) = 0;
  *uint64_t v19 = 0LL;
  v19[1] = v20;
  v19[2] = 0LL;
  *unint64_t v16 = 1LL;
LABEL_8:
  if (*(int *)(v14 + 4) >= 3) {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  " LargeFile: Block = %5u, %5u K cache, %6zu controls\n",  v15,  v17 >> 10,  *v16);
  }
  uint64_t v21 = 1;
LABEL_73:
  free(v12);
  free(v11);
  free(v13);
  if ((v21 & 1) == 0) {
    free(v80);
  }
  __int128 v68 = v80;
  if (!v21) {
    __int128 v68 = 0LL;
  }
  v10[1] = v68;
  if (v68) {
    return 0LL;
  }
  __int128 v70 = (unsigned int *)(*v10 + 104LL);
  while (!__ldaxr(v70))
  {
    if (!__stlxr(1u, v70)) {
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

void *AAByteRangeCreate()
{
  uint64_t v0 = malloc(0x20uLL);
  unsigned int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x20uLL, 0, 0x20uLL);
    v1[2] = -1LL;
    v1[3] = -1LL;
  }

  else
  {
    uint64_t v2 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"AAByteRangeCreate",  551,  107,  *v2,  "malloc",  v3,  v4,  v6);
    AAByteRangeDestroy(0LL);
  }

  return v1;
}

void AAByteRangeDestroy(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1);
  }

void *AAByteRangeClone(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __int16 v6 = 563;
    goto LABEL_10;
  }

  memset_s(v2, 0x20uLL, 0, 0x20uLL);
  v3[2] = -1LL;
  v3[3] = -1LL;
  if ((*(void *)(a1 + 16) & 0x8000000000000000LL) == 0)
  {
    size_t v4 = *(void *)a1;
    if (is_mul_ok(*(void *)a1, 0x38uLL) && 56 * v4 < 0x2000000001LL)
    {
      uint64_t v5 = calloc(v4, 0x38uLL);
      v3[1] = v5;
      if (v5)
      {
        memcpy(v5, *(const void **)(a1 + 8), 56LL * *(void *)a1);
        *uint64_t v3 = *(void *)a1;
        *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 16);
        return v3;
      }
    }

    else
    {
      *__error() = 12;
      v3[1] = 0LL;
    }

    __int16 v6 = 570;
LABEL_10:
    uint64_t v7 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"AAByteRangeClone",  v6,  107,  *v7,  "malloc",  v8,  v9,  v11);
    AAByteRangeDestroy((void **)v3);
    return 0LL;
  }

  return v3;
}

uint64_t AAByteRangeAdd( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == a3) {
    return 0LL;
  }
  if (a2 <= a3)
  {
    uint64_t v10 = "addSegment";
    __int16 v11 = 595;
  }

  else
  {
    uint64_t v10 = "Invalid segment bounds";
    __int16 v11 = 593;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"AAByteRangeAdd",  v11,  107,  0,  v10,  a7,  a8,  v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSub( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == a3) {
    return 0LL;
  }
  if (a2 <= a3)
  {
    if ((a1[2] & 0x8000000000000000LL) != 0 || (treeSub(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0) {
      return 0LL;
    }
    uint64_t v10 = "subSegment";
    __int16 v11 = 612;
  }

  else
  {
    uint64_t v10 = "Invalid segment bounds";
    __int16 v11 = 609;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c",  (uint64_t)"AAByteRangeSub",  v11,  107,  0,  v10,  a7,  a8,  v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSizeAtOffset(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 < 0) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v5 = *(void *)(a1 + 8);
  while (1)
  {
    __int16 v6 = (uint64_t *)(v5 + 56 * v2);
    uint64_t v9 = *v6;
    char v8 = v6 + 3;
    uint64_t v7 = v9;
    uint64_t v10 = a2 - v9;
    if (a2 > v9) {
      break;
    }
LABEL_9:
    uint64_t v2 = *v8;
    if (*v8 < 0) {
      return result;
    }
  }

  uint64_t v11 = *v8;
  if (v11 < 0) {
    uint64_t v12 = 0LL;
  }
  else {
    uint64_t v12 = *(void *)(v5 + 56 * v11 + 40);
  }
  uint64_t v13 = v12 + result;
  uint64_t v14 = *(void *)(v5 + 56 * v2 + 8);
  if (v14 < a2)
  {
    uint64_t result = v14 - v7 + v13;
    char v8 = (uint64_t *)(v5 + 56 * v2 + 32);
    goto LABEL_9;
  }

  return v10 + v13;
}

uint64_t AAByteRangeOffsetAtSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if ((v2 & 0x8000000000000000LL) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    do
    {
      size_t v4 = (uint64_t *)(v3 + 56 * v2);
      if (a2 > v4[5]) {
        break;
      }
      uint64_t v5 = *(void *)(v3 + 56 * v2 + 24);
      if (v5 < 0) {
        uint64_t v6 = 0LL;
      }
      else {
        uint64_t v6 = *(void *)(v3 + 56 * v5 + 40);
      }
      BOOL v7 = __OFSUB__(a2, v6);
      uint64_t v8 = a2 - v6;
      if (!((v8 < 0) ^ v7 | (v8 == 0)))
      {
        uint64_t v9 = *v4;
        uint64_t v10 = *(void *)(v3 + 56 * v2 + 8) - v9;
        a2 = v8 - v10;
        if (v8 <= v10) {
          return v9 + v8;
        }
        uint64_t v5 = *(void *)(v3 + 56 * v2 + 32);
      }

      uint64_t v2 = v5;
    }

    while ((v5 & 0x8000000000000000LL) == 0);
  }

  return -1LL;
}

uint64_t AAByteRangeFirst(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t First = findFirst(a1, *(void *)(a1 + 16), a2);
  if (First < 0) {
    return -1LL;
  }
  uint64_t v8 = First;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(v9 + 56 * First);
  while (1)
  {
    uint64_t result = v8;
    uint64_t v12 = v9 + 56 * v8;
    uint64_t v13 = *(void *)(v12 + 8);
    uint64_t v14 = *(void *)(v12 + 32);
    uint64_t v15 = result;
    if (v14 < 0) {
      break;
    }
    do
    {
      uint64_t v8 = v14;
      uint64_t v14 = *(void *)(v9 + 56 * v14 + 24);
    }

    while ((v14 & 0x8000000000000000LL) == 0);
LABEL_8:
    if (*(void *)(v9 + 56 * v8) != v13) {
      goto LABEL_9;
    }
  }

  while (1)
  {
    uint64_t v8 = *(void *)(v9 + 56 * v15 + 16);
    if (v8 < 0) {
      break;
    }
    BOOL v16 = *(void *)(v9 + 56 * v8 + 32) == v15;
    uint64_t v15 = *(void *)(v9 + 56 * v15 + 16);
    if (!v16) {
      goto LABEL_8;
    }
  }

LABEL_9:
  *a3 = v10;
  *a4 = v13;
  return result;
}

  if (v11 == a3) {
    unint64_t v17 = 0LL;
  }
  else {
    unint64_t v17 = 0xFFFFFFFFLL;
  }
LABEL_17:
  free(v10);
  return v17;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IFileStreamCreateWithFilename",  v13,  29,  v14,  v12,  v10,  v11,  v17);
  IFileStreamDestroy((char *)v7);
  return 0LL;
}

  if ((a3 & 0x2000) != 0
    && (*(_BYTE *)a1 & 4) != 0
    && *(void *)(a1 + 28) ^ *(void *)(a2 + 28) | *(void *)(a1 + 36) ^ *(void *)(a2 + 36) | *(void *)(a1 + 44) ^ *(void *)(a2 + 44) | *(void *)(a1 + 52) ^ *(void *)(a2 + 52))
  {
    v6 |= 0x2000u;
  }

  if ((a3 & 0x4000) != 0
    && (*(_BYTE *)a1 & 8) != 0
    && memcmp((const void *)(a1 + 60), (const void *)(a2 + 60), 0x30uLL))
  {
    v6 |= 0x4000u;
  }

  return v6;
}

  uint64_t result = 0LL;
  unint64_t v17 = (void *)a1[7];
  if (v17 && v12 == 4997953)
  {
    if (a1[6] >= __smax)
    {
      uint64_t v26 = *v17 + __smax;
      if (!__CFADD__(*v17, __smax) && (v26 & 0x8000000000000000LL) == 0)
      {
        uint64_t v27 = v17[1];
        if (v27 >= v26)
        {
LABEL_74:
          uint64_t v37 = v17[2];
          if (__src)
          {
            memcpy((void *)(v37 + *v17), __src, __smax);
          }

          else if (v37)
          {
            memset_s((void *)(v37 + *v17), __smax, 0, __smax);
          }

          *v17 += __smax;
          if ((__smax & 0x8000000000000000LL) == 0)
          {
            uint64_t result = 0LL;
            a1[6] -= __smax;
            return result;
          }
        }

        else
        {
          do
          {
            while (!v27)
            {
              uint64_t v27 = 0x4000LL;
              if (v26 <= 0x4000)
              {
                uint64_t v27 = 0x4000LL;
                goto LABEL_72;
              }
            }

            uint64_t v28 = v27 >> 1;
            if ((v27 & (v27 >> 1)) != 0) {
              uint64_t v28 = v27 & (v27 >> 1);
            }
            v27 += v28;
          }

          while (v27 < v26);
          if (v27 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_84;
          }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c",  (uint64_t)"decodeStreamReadBlob",  v18,  61,  0,  v17,  a7,  a8,  v24);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

uint64_t findFirst(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    return -1LL;
  }
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)(a1 + 8);
  while (1)
  {
    if (*(void *)(v6 + 56 * v4) > a3)
    {
      uint64_t First = findFirst(a1, *(void *)(v6 + 56 * v4 + 24), a3);
      if ((First & 0x8000000000000000LL) == 0) {
        break;
      }
    }

    if (*(void *)(v6 + 56 * v4 + 8) > a3) {
      return v4;
    }
    uint64_t v4 = *(void *)(v6 + 56 * v4 + 32);
    if (v4 < 0) {
      return -1LL;
    }
  }

  return First;
}

uint64_t AAByteRangeNext(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a2 < 0) {
    return -1LL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 56 * a2 + 32);
  if (v5 < 0)
  {
    while (1)
    {
      uint64_t result = *(void *)(v4 + 56 * a2 + 16);
      if (result < 0) {
        break;
      }
      BOOL v7 = *(void *)(v4 + 56 * result + 32) == a2;
      a2 = *(void *)(v4 + 56 * a2 + 16);
      if (!v7) {
        goto LABEL_9;
      }
    }
  }

  else
  {
    do
    {
      uint64_t result = v5;
      uint64_t v5 = *(void *)(v4 + 56 * v5 + 24);
    }

    while ((v5 & 0x8000000000000000LL) == 0);
LABEL_9:
    uint64_t v8 = (void *)(v4 + 56 * result);
    *a3 = *v8;
    *a4 = v8[1];
  }

  return result;
}

uint64_t treeRotateRight(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 + 56 * v2;
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v6 = (void *)(v4 + 24);
  uint64_t v5 = v7;
  if (v7 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v3 + 56 * v5;
  uint64_t v9 = *(void *)(v8 + 32);
  *(void *)(v8 + 32) = v2;
  uint64_t v10 = v3 + 56 * v2;
  *(void *)(v8 + 16) = *(void *)(v10 + 16);
  *(void *)(v10 + 16) = v5;
  *uint64_t v6 = v9;
  if (v9 < 0)
  {
    unsigned int v12 = 0;
  }

  else
  {
    uint64_t v11 = v3 + 56 * v9;
    *(void *)(v11 + 16) = v2;
    unsigned int v12 = *(_DWORD *)(v11 + 48);
  }

  uint64_t v14 = (void *)(v3 + 56 * v2);
  uint64_t v15 = v14[4];
  if (v15 < 0) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = *(_DWORD *)(v3 + 56 * v15 + 48);
  }
  if (v16 > v12) {
    unsigned int v12 = v16;
  }
  unsigned int v17 = v12 + 1;
  uint64_t v18 = v3 + 56 * v2;
  *(_DWORD *)(v18 + 48) = v17;
  uint64_t v19 = *(void *)(v18 + 8) - *v14;
  if (v9 < 0) {
    uint64_t v20 = 0LL;
  }
  else {
    uint64_t v20 = *(void *)(v3 + 56 * v9 + 40);
  }
  uint64_t v21 = v19 + v20;
  if (v15 < 0) {
    uint64_t v22 = 0LL;
  }
  else {
    uint64_t v22 = *(void *)(v3 + 56 * v15 + 40);
  }
  uint64_t v23 = v21 + v22;
  *(void *)(v3 + 56 * v2 + 40) = v23;
  __int16 v24 = (void *)(v3 + 56 * v5);
  uint64_t v25 = v24[3];
  if (v25 < 0) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = *(_DWORD *)(v3 + 56 * v25 + 48);
  }
  if (v17 <= v26) {
    unsigned int v17 = v26;
  }
  uint64_t v27 = v3 + 56 * v5;
  *(_DWORD *)(v27 + 48) = v17 + 1;
  if (v25 < 0) {
    uint64_t v28 = 0LL;
  }
  else {
    uint64_t v28 = *(void *)(v3 + 56 * v25 + 40);
  }
  uint64_t result = 0LL;
  *(void *)(v3 + 56 * v5 + 40) = *(void *)(v27 + 8) - *v24 + v28 + v23;
  *a2 = v5;
  return result;
}

uint64_t treeRotateLeft(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 + 56 * v2;
  uint64_t v7 = *(void *)(v4 + 32);
  uint64_t v6 = (void *)(v4 + 32);
  uint64_t v5 = v7;
  if (v7 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v3 + 56 * v5;
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t v10 = v3 + 56 * v2;
  *(void *)(v8 + 16) = *(void *)(v10 + 16);
  *(void *)(v8 + 24) = v2;
  *(void *)(v10 + 16) = v5;
  *uint64_t v6 = v9;
  if ((v9 & 0x8000000000000000LL) == 0) {
    *(void *)(v3 + 56 * v9 + 16) = v2;
  }
  uint64_t v11 = (void *)(v3 + 56 * v2);
  uint64_t v12 = v11[3];
  if (v12 < 0)
  {
    unsigned int v13 = 0;
    if ((v9 & 0x8000000000000000LL) == 0) {
      goto LABEL_7;
    }
LABEL_10:
    unsigned int v14 = 0;
    goto LABEL_11;
  }

  unsigned int v13 = *(_DWORD *)(v3 + 56 * v12 + 48);
  if (v9 < 0) {
    goto LABEL_10;
  }
LABEL_7:
  unsigned int v14 = *(_DWORD *)(v3 + 56 * v9 + 48);
LABEL_11:
  if (v14 > v13) {
    unsigned int v13 = v14;
  }
  unsigned int v16 = v13 + 1;
  uint64_t v17 = v3 + 56 * v2;
  *(_DWORD *)(v17 + 48) = v16;
  uint64_t v18 = *(void *)(v17 + 8) - *v11;
  if (v12 < 0) {
    uint64_t v19 = 0LL;
  }
  else {
    uint64_t v19 = *(void *)(v3 + 56 * v12 + 40);
  }
  uint64_t v20 = v18 + v19;
  if (v9 < 0) {
    uint64_t v21 = 0LL;
  }
  else {
    uint64_t v21 = *(void *)(v3 + 56 * v9 + 40);
  }
  uint64_t v22 = v20 + v21;
  *(void *)(v3 + 56 * v2 + 40) = v22;
  uint64_t v23 = (void *)(v3 + 56 * v5);
  uint64_t v24 = v23[4];
  if (v24 < 0) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = *(_DWORD *)(v3 + 56 * v24 + 48);
  }
  if (v25 > v16) {
    unsigned int v16 = v25;
  }
  uint64_t v26 = v3 + 56 * v5;
  *(_DWORD *)(v26 + 48) = v16 + 1;
  uint64_t v27 = *(void *)(v26 + 8) - *v23 + v22;
  if (v24 < 0) {
    uint64_t v28 = 0LL;
  }
  else {
    uint64_t v28 = *(void *)(v3 + 56 * v24 + 40);
  }
  uint64_t result = 0LL;
  *(void *)(v3 + 56 * v5 + 40) = v27 + v28;
  *a2 = v5;
  return result;
}

void *aaArchiveFileOutputStreamOpenAt( int a1, const char *a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6, __int16 a7)
{
  unsigned int v14 = calloc(1uLL, 0x68uLL);
  uint64_t v15 = malloc(0x80uLL);
  uint64_t v16 = (uint64_t)v15;
  if (v15)
  {
    memset_s(v15, 0x80uLL, 0, 0x80uLL);
    if (v14)
    {
      *(_DWORD *)uint64_t v16 = -1;
      if ((a7 & 0x100) == 0)
      {
        if (a1 < 0) {
          unlink(a2);
        }
        else {
          unlinkat(a1, a2, 0);
        }
      }

      if ((a7 & 1) != 0) {
        a6 = 4;
      }
      if (a6 < 1)
      {
        int v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0)
        {
          char v46 = -92;
          int v28 = a1 < 0 ? open(a2, 1537) : openat(a1, a2, 1537);
          *(_DWORD *)uint64_t v16 = v28;
          if (v28 < 0)
          {
            int v21 = *__error();
            char v46 = (char)a2;
            uint64_t v24 = "%s";
            __int16 v25 = 358;
            goto LABEL_7;
          }
        }
      }

      else if (a1 < 0)
      {
        char v46 = -92;
        int v28 = open_dprotected_np(a2, 1537, a6, 0);
        *(_DWORD *)uint64_t v16 = v28;
        if (v28 < 0)
        {
LABEL_22:
          int v21 = *__error();
          char v46 = (char)a2;
          uint64_t v24 = "%s";
          __int16 v25 = 349;
          goto LABEL_7;
        }
      }

      else
      {
        int v27 = openat(a1, a2, 1537, 420LL);
        *(_DWORD *)uint64_t v16 = v27;
        if (v27 < 0) {
          goto LABEL_22;
        }
        char v46 = a6;
        if (fcntl(v27, 64) < 0)
        {
          int v21 = *__error();
          uint64_t v24 = "fcntl F_SETPROTECTIONCLASS";
          __int16 v25 = 347;
          goto LABEL_7;
        }

        int v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0) {
          goto LABEL_22;
        }
      }

      if ((a7 & 8) != 0)
      {
        char v46 = 1;
        if (fcntl(v28, 48))
        {
          uint64_t v29 = __error();
          pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAt",  366,  67,  "Warning: F_NOCACHE failed with error %d: %s\n",  v30,  v31,  v32,  *v29);
        }
      }

      if ((a7 & 2) != 0)
      {
        char v46 = 1;
        if (fcntl(*(_DWORD *)v16, 68) == -1)
        {
          uint64_t v33 = __error();
          pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAt",  375,  67,  "Warning: F_SETSTATICCONTENT failed with error %d: %s\n",  v34,  v35,  v36,  *v33);
        }
      }

      if (a3 > 0)
      {
        if (a4 != -1 && (a7 & 4) != 0)
        {
          uint64_t v37 = AAAFSCStreamOpen(*(_DWORD *)v16, a3, a4, a5, v17, v18, v19, v20);
          *(void *)(v16 + 40) = v37;
          if (!v37)
          {
            char v46 = (char)a2;
            uint64_t v24 = "ParallelCompressionAFSCStreamOpen failed: %s";
            __int16 v25 = 384;
            goto LABEL_60;
          }
        }

        if ((a7 & 0x40) != 0 && !*(void *)(v16 + 40))
        {
          uint64_t v38 = fpathconf(*(_DWORD *)v16, 27);
          if (v38 >= 1)
          {
            *(_DWORD *)(v16 + 88) = 1;
            if (v38 == 4096)
            {
              *(void *)(v16 + 96) = 4096LL;
            }

            else
            {
              unint64_t v39 = 0x10000LL;
              if (v38 < 0x10000) {
                unint64_t v39 = v38;
              }
              uint64_t v40 = 1024LL;
              do
              {
                unint64_t v41 = v40;
                v40 *= 2LL;
              }

              while (v41 < v39);
              *(void *)(v16 + 96) = v41;
            }
          }
        }
      }

      *(void *)(v16 + 16) = a3;
      *(void *)(v16 + 56) = 0x40000LL;
      if (*(void *)(v16 + 40)) {
        goto LABEL_58;
      }
      size_t v42 = *(void *)(v16 + 72);
      if (v42 >> 18) {
        goto LABEL_58;
      }
      do
      {
        size_t v43 = (v42 >> 1) + v42;
        if (((v42 >> 1) & v42) != 0) {
          size_t v43 = ((v42 >> 1) & v42) + v42;
        }
        if (v42) {
          size_t v42 = v43;
        }
        else {
          size_t v42 = 0x4000LL;
        }
      }

      while (v42 < 0x40000);
      uint64_t v44 = *(void **)(v16 + 80);
      uint64_t v45 = realloc(v44, v42);
      if (v45)
      {
        *(void *)(v16 + 72) = v42;
        *(void *)(v16 + 80) = v45;
LABEL_58:
        *unsigned int v14 = v16;
        v14[1] = afStreamClose;
        v14[7] = afStreamCancel;
        v14[3] = afStreamWrite;
        v14[12] = afStreamCloseWithState;
        return v14;
      }

      free(v44);
      *(void *)(v16 + 64) = 0LL;
      *(void *)(v16 + 72) = 0LL;
      *(void *)(v16 + 80) = 0LL;
      uint64_t v24 = "alloc blob";
      __int16 v25 = 429;
LABEL_60:
      int v21 = 0;
      goto LABEL_7;
    }
  }

  int v21 = *__error();
  uint64_t v24 = "malloc";
  __int16 v25 = 324;
LABEL_7:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAt",  v25,  67,  v21,  v24,  v22,  v23,  v46);
  afStreamClose(v16);
  free(v14);
  return 0LL;
}

uint64_t afStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 48));
    BOOL v3 = v2 == 0;
    if (AAByteStreamClose(*(AAByteStream *)(result + 40)) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamClose",  197,  67,  0,  "closing AFSC stream",  v4,  v5,  v15);
      BOOL v3 = 0;
    }

    if (*(void *)(v1 + 120) && *(void *)(v1 + 104))
    {
      uint64_t v6 = 0LL;
      unint64_t v7 = 0LL;
      while (1)
      {
        uint64_t v8 = (uint64_t *)(*(void *)(v1 + 120) + v6);
        uint64_t v18 = 0LL;
        uint64_t v19 = 0LL;
        uint64_t v17 = 0LL;
        uint64_t v18 = *v8;
        uint64_t v19 = v8[1] - v18;
        if (fcntl(*(_DWORD *)v1, 99, &v17) < 0) {
          break;
        }
        ++v7;
        v6 += 16LL;
        if (v7 >= *(void *)(v1 + 104)) {
          goto LABEL_11;
        }
      }

      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamClose",  209,  67,  "F_PUNCHHOLE failed",  v9,  v10,  v11,  v16);
    }

LABEL_11:
    if ((*(_BYTE *)(v1 + 8) & 0x10) != 0 && fcntl(*(_DWORD *)v1, 51) == -1)
    {
      uint64_t v12 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamClose",  218,  67,  *v12,  "Final FULLFSYNC",  v13,  v14,  0);
    }

    if ((*(_DWORD *)v1 & 0x80000000) == 0 && !*(_DWORD *)(v1 + 4)) {
      close(*(_DWORD *)v1);
    }
    free(*(void **)(v1 + 80));
    memset_s((void *)(v1 + 64), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 120));
    free((void *)v1);
    return (v3 - 1);
  }

  return result;
}

  uint64_t v13 = v5 - 1;
  uint64_t v14 = StringTableCmp(a1, v13, __s1, a3);
  if (v14 >= 1)
  {
    uint64_t result = 0LL;
    if (!a4) {
      return result;
    }
LABEL_8:
    *a4 = v13;
    return result;
  }

  if (v14)
  {
    if (v13 < 2)
    {
      char v15 = 0;
LABEL_28:
      uint64_t result = 0LL;
      uint64_t v13 = v15;
      if (a4) {
        goto LABEL_8;
      }
    }

    else
    {
      char v15 = 0;
      while (1)
      {
        char v16 = StringTableCmp(a1, v15 + ((v13 - v15) >> 1), __s1, a3);
        if (!v16) {
          break;
        }
        if (v16 < 0) {
          uint64_t v13 = v15 + ((v13 - v15) >> 1);
        }
        else {
          v15 += (v13 - v15) >> 1;
        }
        if (v15 + 1 >= v13) {
          goto LABEL_28;
        }
      }

      uint64_t result = 1LL;
      uint64_t v13 = v15 + ((v13 - v15) >> 1);
      if (a4) {
        goto LABEL_8;
      }
    }
  }

  else
  {
    uint64_t result = 1LL;
    if (a4) {
      goto LABEL_8;
    }
  }

  return result;
}

  uint64_t v4 = 0LL;
LABEL_13:
  uint64_t v11 = *(unsigned __int16 *)(a2 + 4);
  if (v23.st_mode != v11 && chmod(a1, v11 & 0xFFF) && *__error() != 1)
  {
    uint64_t v12 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"updateFileAttributes",  614,  3,  *v12,  "%s",  v13,  v14,  (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
  }

  char v15 = *(_DWORD *)(a2 + 116) & 0xFFFFFFDF | (32 * ((v23.st_flags >> 5) & 1));
  if (v23.st_flags != v15 && chflags(a1, v15) && *__error() != 1)
  {
    char v16 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"updateFileAttributes",  621,  3,  *v16,  "%s",  v17,  v18,  (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
  }

  if (utimes(a1, &v24) && *__error() != 1)
  {
    unint64_t v7 = 624;
    goto LABEL_24;
  }

  return v4;
}

  CC_SHA256_Init(&v19);
  LOBYTE(v7) = *a1;
  if ((*a1 & 8) != 0) {
    goto LABEL_12;
  }
LABEL_7:
  if ((v7 & 0x10) == 0) {
    goto LABEL_26;
  }
LABEL_13:
  CC_SHA512_Init(&v17);
  while (1)
  {
LABEL_26:
    uint64_t v9 = read(a3, v6, 0x40000uLL);
    uint64_t v10 = v9;
    if (v9 < 0)
    {
      uint64_t v11 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryHashesInitWithFD",  36,  102,  *v11,  "read",  v12,  v13,  v16);
      goto LABEL_35;
    }

    if (!v9) {
      break;
    }
    uint64_t v8 = *a1;
    if ((*a1 & 1) != 0)
    {
      CC_CKSUM_Update((uint64_t)v21, (unsigned __int8 *)v6, v9);
      uint64_t v8 = *a1;
      if ((*a1 & 2) != 0) {
        goto LABEL_22;
      }
LABEL_17:
      if ((v8 & 4) == 0) {
        goto LABEL_18;
      }
LABEL_23:
      CC_SHA256_Update(&v19, v6, v10);
      uint64_t v8 = *a1;
      if ((*a1 & 8) == 0) {
        goto LABEL_19;
      }
LABEL_24:
      CC_SHA384_Update(&v18, v6, v10);
      if ((*a1 & 0x10) != 0) {
        goto LABEL_25;
      }
    }

    else
    {
      if ((*a1 & 2) == 0) {
        goto LABEL_17;
      }
LABEL_22:
      CC_SHA1_Deprecated_Update(&c, v6, v10);
      uint64_t v8 = *a1;
      if ((*a1 & 4) != 0) {
        goto LABEL_23;
      }
LABEL_18:
      if ((v8 & 8) != 0) {
        goto LABEL_24;
      }
LABEL_19:
      if ((v8 & 0x10) != 0) {
LABEL_25:
      }
        CC_SHA512_Update(&v17, v6, v10);
    }
  }

  uint64_t v14 = *a1;
  if ((*a1 & 1) == 0)
  {
    if ((*a1 & 2) == 0) {
      goto LABEL_30;
    }
LABEL_37:
    CC_SHA1_Deprecated_Final(a1 + 8, &c);
    uint64_t v14 = *a1;
    if ((*a1 & 4) != 0) {
      goto LABEL_38;
    }
LABEL_31:
    if ((v14 & 8) == 0) {
      goto LABEL_32;
    }
LABEL_39:
    CC_SHA384_Final(a1 + 60, &v18);
    if ((*a1 & 0x10) == 0) {
      goto LABEL_34;
    }
LABEL_33:
    CC_SHA512_Final(a1 + 108, &v17);
    goto LABEL_34;
  }

  CC_CKSUM_Final((unsigned int *)a1 + 1, (uint64_t)v21);
  uint64_t v14 = *a1;
  if ((*a1 & 2) != 0) {
    goto LABEL_37;
  }
LABEL_30:
  if ((v14 & 4) == 0) {
    goto LABEL_31;
  }
LABEL_38:
  CC_SHA256_Final(a1 + 28, &v19);
  uint64_t v14 = *a1;
  if ((*a1 & 8) != 0) {
    goto LABEL_39;
  }
LABEL_32:
  if ((v14 & 0x10) != 0) {
    goto LABEL_33;
  }
LABEL_34:
  uint64_t v10 = 0LL;
LABEL_35:
  free(v6);
  return v10 >> 63;
}

  if (!v6 || (uint64_t v12 = (unsigned int *)*((void *)key_set + 1), *v12 >= v8))
  {
    uint64_t v13 = 0;
    goto LABEL_16;
  }

  uint64_t v13 = v6 - 1;
  uint64_t v14 = v12[v6 - 1];
  if (v14 >= v8)
  {
    if (v6 < 3)
    {
      char v15 = v13;
      goto LABEL_18;
    }

    uint64_t v20 = 0;
    do
    {
      if (v12[(v20 + v13) >> 1] >= v8) {
        uint64_t v13 = (v20 + v13) >> 1;
      }
      else {
        uint64_t v20 = (v20 + v13) >> 1;
      }
    }

    while (v13 - v20 > 1);
LABEL_16:
    if (v13 >= v6) {
      goto LABEL_23;
    }
    uint64_t v12 = (unsigned int *)*((void *)key_set + 1);
    char v15 = v13;
    uint64_t v14 = v12[v13];
LABEL_18:
    if (v14 == v8) {
      return 0;
    }
    memmove(&v12[v13 + 1], &v12[v15], 4LL * (v6 - v13));
    goto LABEL_23;
  }

  uint64_t v13 = v6;
LABEL_23:
  uint64_t result = 0;
  *(_DWORD *)(*((void *)key_set + 1) + 4LL * v13) = v8;
  ++*(_DWORD *)key_set;
  return result;
}

uint64_t afStreamCancel(uint64_t result)
{
  uint64_t v1 = (unsigned int *)(result + 48);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

uint64_t afStreamWrite( uint64_t a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 48);
  unint64_t v12 = a3;
  uint64_t v14 = *(void *)(a1 + 24);
  if (__CFADD__(a3, v14) || (unint64_t)(a3 + v14) > *(void *)(a1 + 16))
  {
    char v33 = a3 + v14;
    uint64_t v18 = "received too many bytes %llu/%llu";
    __int16 v19 = 275;
    goto LABEL_14;
  }

  char v15 = (char *)__src;
  char v16 = *(void **)(a1 + 40);
  if (!v16)
  {
    if (a3)
    {
      uint64_t v10 = 0LL;
      uint64_t v22 = (size_t *)(a1 + 64);
      size_t v21 = *(void *)(a1 + 64);
      while (1)
      {
        uint64_t v23 = *(void *)(a1 + 56);
        size_t v24 = v23 - v21;
        if (v23 == v21)
        {
          if ((flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
          {
            uint64_t v18 = "flush buf";
            __int16 v19 = 284;
            goto LABEL_14;
          }

          size_t v21 = *v22;
        }

        if (v12 < v24) {
          size_t v24 = v12;
        }
        BOOL v25 = __CFADD__(v21, v24);
        unint64_t v26 = v21 + v24;
        if (v25 || (v26 & 0x8000000000000000LL) != 0) {
          goto LABEL_59;
        }
        unint64_t v27 = *(void *)(a1 + 72);
        if (v27 < v26)
        {
          do
          {
            while (!v27)
            {
              unint64_t v27 = 0x4000LL;
              size_t v29 = 0x4000LL;
              if (v26 <= 0x4000) {
                goto LABEL_37;
              }
            }

            unint64_t v28 = v27 >> 1;
            if ((v27 & (v27 >> 1)) != 0) {
              unint64_t v28 = v27 & (v27 >> 1);
            }
            v27 += v28;
          }

          while (v27 < v26);
          size_t v29 = v27;
          if (v27 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_58;
          }

LABEL_37:
          uint64_t v30 = *(void **)(a1 + 80);
          uint64_t v31 = realloc(v30, v29);
          if (!v31)
          {
            free(v30);
LABEL_58:
            size_t *v22 = 0LL;
            *(void *)(a1 + 72) = 0LL;
            *(void *)(a1 + 80) = 0LL;
LABEL_59:
            uint64_t v18 = "append to buf";
            __int16 v19 = 286;
LABEL_14:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamWrite",  v19,  67,  0,  v18,  a7,  a8,  v33);
            uint64_t v10 = -1LL;
            goto LABEL_15;
          }

          *(void *)(a1 + 72) = v29;
          *(void *)(a1 + 80) = v31;
        }

        uint64_t v32 = *(void *)(a1 + 80);
        if (v15)
        {
          memcpy((void *)(v32 + *v22), v15, v24);
        }

        else if (v32)
        {
          memset_s((void *)(v32 + *v22), v24, 0, v24);
        }

        size_t v21 = *v22 + v24;
        size_t *v22 = v21;
        if ((v24 & 0x8000000000000000LL) != 0) {
          goto LABEL_59;
        }
        v15 += v24;
        v10 += v24;
        v12 -= v24;
        if (!v12)
        {
LABEL_45:
          uint64_t v14 = *(void *)(a1 + 24);
          if (v10 >= 1)
          {
            v14 += v10;
            *(void *)(a1 + 24) = v14;
          }

          goto LABEL_50;
        }
      }
    }

    if (!v25) {
      goto LABEL_81;
    }
LABEL_38:
    __int128 v60 = (a9 & 0x20000000000000LL) == 0 && v33 == 1;
    if (!v33 || v60)
    {
LABEL_81:
      uint64_t v73 = 0LL;
      goto LABEL_100;
    }

    uint64_t v34 = (uint64_t)v96;
    if ((v32 & 0x10000) != 0 && (v25 & 0x80000) != 0) {
      break;
    }
LABEL_54:
    if ((v25 & 0x184) != 0)
    {
      if ((*(_BYTE *)v98 & 4) != 0) {
        __int128 v68 = ((*(_DWORD *)(v98 + 12) >> 5) & 1) - 1;
      }
      else {
        __int128 v68 = -1;
      }
      if ((*(_BYTE *)v34 & 1) != 0) {
        __int128 v68 = *(_DWORD *)(v34 + 8);
      }
      if ((*(_BYTE *)v34 & 2) != 0) {
        __int128 v69 = *(_DWORD *)(v34 + 12);
      }
      else {
        __int128 v69 = 0;
      }
      ParallelCompressionAFSCFixupMetadata(v108, v68, v69);
    }

    if ((v25 & 0x200) != 0) {
      setFileAPFSInternalFlags((uint64_t)v108, *(void *)(v34 + 16));
    }
    if ((v25 & 0x20000) != 0)
    {
      if ((aaEntryXATBlobInitWithEncodedData( (unint64_t *)v35,  *((char **)a4 + 3),  *((void *)a4 + 4),  v44,  v45,  v46,  v47,  v48) & 0x80000000) != 0)
      {
        int v84 = "invalid XAT blob in manifest";
        int v85 = 894;
        goto LABEL_93;
      }

      AAEntryXATBlobApplyToPath(v35, __s, a8, flags);
    }

    if ((v25 & 0x40000) != 0)
    {
      __int128 v70 = acl;
      if ((aaEntryACLBlobInitWithEncodedData(acl, *((char **)a4 + 5), *((void *)a4 + 6), v44, v45, v46, v47, v48) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  901,  102,  0,  "invalid ACL blob in manifest",  v71,  v72,  v90);
        uint64_t v73 = 0xFFFFFFFFLL;
        a6 = v91;
        goto LABEL_101;
      }

      AAEntryACLBlobApplyToPath(acl, __s, a8, flags);
      uint64_t v36 = (uint64_t)v93;
    }

    if (v94) {
      aaEntryAttributesApplyToPath((char *)v98, __s, a8, a9);
    }
    --v33;
    if ((v32 & 0x20000) != 0) {
      goto LABEL_8;
    }
  }

  __int128 v102 = 0LL;
  __int128 v100 = 0;
  int v101 = -1;
  if ((ParallelCompressionAFSCGetMetadata(v108, &v102, &v101, &v100) & 0x80000000) != 0)
  {
    int v84 = "get AFSC attributes";
    int v85 = 853;
LABEL_93:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  v85,  102,  0,  v84,  v61,  v62,  v90);
    goto LABEL_99;
  }

  memset(&v103, 0, sizeof(v103));
  __int128 v63 = open(v108, 2);
  if (v63 < 0)
  {
    __int128 v77 = *__error();
    __int128 v80 = 858;
    goto LABEL_90;
  }

  uint64_t v54 = v63;
  if ((fstat(v63, &v103) & 0x80000000) == 0)
  {
    memset(v99, 0, sizeof(v99));
    __int128 v64 = ParallelArchiveECCFixFileSegment( v54,  0LL,  v103.st_size,  *((__int128 **)a4 + 1),  *((void *)a4 + 2),  (uint64_t)v99);
    close(v54);
    if (v64 >= 1) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  863,  102,  "Fixed data using ECC: %s",  v65,  v66,  v67,  (char)a8);
    }
    ParallelCompressionAFSCFixupMetadata(v108, v101, v100);
    uint64_t v35 = v95;
    uint64_t v34 = (uint64_t)v96;
    goto LABEL_54;
  }

  uint64_t v86 = *__error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCheckAndFixWithPath",  859,  102,  v86,  "fstat: %s",  v87,  v88,  (char)v108);
LABEL_97:
  close(v54);
LABEL_98:
  uint64_t v35 = v95;
LABEL_99:
  uint64_t v73 = 0xFFFFFFFFLL;
LABEL_100:
  a6 = v91;
  __int128 v70 = acl;
LABEL_101:
  *a6 = v25;
  a6[1] = 0;
  AAEntryXATBlobDestroy(v35);
  AAEntryACLBlobDestroy(v70);
  return v73;
}

              size_t v21 = 0LL;
              goto LABEL_38;
            }

            uint64_t v40 = *__error();
            __int128 v61 = (char)a2;
            uint64_t v38 = "open: %s";
            unint64_t v39 = 964;
          }

          else
          {
            __int128 v62 = -92;
            unint64_t v41 = open(a2, 0);
            if ((v41 & 0x80000000) == 0)
            {
              uint64_t v20 = v41;
              goto LABEL_37;
            }

            uint64_t v40 = *__error();
            __int128 v61 = (char)a2;
            uint64_t v38 = "open: %s";
            unint64_t v39 = 953;
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  v39,  102,  v40,  v38,  v17,  v18,  v61);
          goto LABEL_28;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  944,  102,  0,  "get XAT",  v13,  v14,  v61);
LABEL_27:
        __int16 v19 = 0LL;
LABEL_28:
        close(v7);
        size_t v21 = 0LL;
        goto LABEL_29;
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  942,  102,  0,  "get attributes",  v10,  v11,  v61);
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  941,  102,  0,  "not a regular file: %s",  v8,  v9,  (char)a1);
    }

    char v15 = 0LL;
    goto LABEL_27;
  }

  uint64_t v30 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaCopyFile",  939,  102,  *v30,  "open: %s",  v31,  v32,  (char)a1);
  size_t v21 = 0LL;
  __int16 v19 = 0LL;
  char v15 = 0LL;
LABEL_29:
  uint64_t v36 = 0;
LABEL_30:
  AAEntryXATBlobDestroy(v15);
  AAEntryACLBlobDestroy((AAEntryACLBlob)v19);
  free(v21);
  if (v36) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

      unint64_t v41 = (char *)malloc(v39);
      if (!v41) {
        goto LABEL_46;
      }
      char v15 = v41;
      *((void *)&v47 + 1) = v39;
      uint64_t value = v41;
      if (a4) {
        goto LABEL_42;
      }
      memset_s(v41, v31, 0, v31);
    }

    else
    {
      char v15 = 0LL;
LABEL_42:
      memcpy(v15, a4, v31);
    }

    *(void *)&uint64_t v47 = v31;
  }

  compression_algorithm algorithm = v30;
  uint64_t v31 = bswap64(v89);
  __uint64_t size = v31;
  if (v8 >= 13)
  {
    uint64_t v32 = 0LL;
    char v33 = 0LL;
    uint64_t v34 = 0LL;
    uint64_t v35 = 12LL;
LABEL_39:
    __int128 v80 = v33;
    if (*((void *)compressed_stream + 4))
    {
      uint64_t v36 = v34;
      uint64_t v37 = v32;
      uint64_t v38 = 0LL;
      unint64_t v39 = &v84;
      uint64_t v40 = v35;
      unint64_t v41 = 16LL;
      while (1)
      {
        size_t v42 = (*((uint64_t (**)(void, unint64_t *, uint64_t, uint64_t))compressed_stream + 4))( *(void *)compressed_stream,  v39,  v41,  v40);
        if (v42 < 0) {
          break;
        }
        if (v42)
        {
          unint64_t v39 = (unint64_t *)((char *)v39 + v42);
          v38 += v42;
          v40 += v42;
          v41 -= v42;
          if (v41) {
            continue;
          }
        }

        if ((v38 & 0x8000000000000000LL) != 0) {
          break;
        }
        if (!v38)
        {
          uint64_t v32 = v37;
          uint64_t v31 = __size;
          char v33 = v80;
          goto LABEL_53;
        }

        uint64_t v31 = __size;
        if (v38 <= 0xF)
        {
          char v15 = "Truncated stream";
          char v16 = 329;
          goto LABEL_15;
        }

        size_t v43 = v85;
        uint64_t v32 = bswap64(v84);
        char v33 = bswap64(v85);
        int v84 = v32;
        int v85 = v33;
        if (v32 < v33 || v32 - 1 >= __size || !v43)
        {
          char v15 = "Corrupted stream";
          char v16 = 339;
          goto LABEL_15;
        }

        uint64_t v36 = v35;
        v35 += v33 + 16;
        uint64_t v34 = v36;
        if (v35 < v8) {
          goto LABEL_39;
        }
        goto LABEL_53;
      }
    }

    char v15 = "reading block header";
    char v16 = 327;
    goto LABEL_15;
  }

  uint64_t v36 = 0LL;
  char v33 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v35 = 12LL;
LABEL_53:
  if (v35 != v8)
  {
    char v15 = "Corrupted stream";
    char v16 = 342;
    goto LABEL_15;
  }

  if (v32 >= v31)
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v49 = algorithm;
  }

  else
  {
    if (v31 >= 0x2000000001LL)
    {
      *__error() = 12;
      uint64_t v17 = 0LL;
      uint64_t v18 = 0LL;
      *__error() = 12;
LABEL_57:
      uint64_t v44 = *__error();
      uint64_t v47 = "malloc";
      uint64_t v48 = 349;
LABEL_105:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c",  (uint64_t)"AACompressionOutputStreamOpenExisting",  v48,  19,  v44,  v47,  v45,  v46,  v78);
      goto LABEL_16;
    }

    uint64_t v18 = (uint8_t *)malloc(v31);
    uint64_t v55 = (uint8_t *)malloc(v31);
    uint64_t v17 = v55;
    if (!v18 || !v55) {
      goto LABEL_57;
    }
    int v81 = v36;
    if (*((void *)compressed_stream + 4))
    {
      rsize_t v56 = v32;
      __int128 v57 = v33;
      if (v33)
      {
        __int128 v58 = 0LL;
        __int128 v59 = v36 + 16;
        __int128 v60 = v55;
        __int128 v61 = v57;
        while (1)
        {
          __int128 v62 = (*((uint64_t (**)(void, uint8_t *, size_t, uint64_t))compressed_stream + 4))( *(void *)compressed_stream,  v60,  v57,  v59);
          if (v62 < 0) {
            break;
          }
          if (v62)
          {
            v60 += v62;
            v58 += v62;
            v59 += v62;
            v57 -= v62;
            if (v57) {
              continue;
            }
          }

          goto LABEL_100;
        }

        __int128 v58 = v62;
      }

      else
      {
        __int128 v61 = 0LL;
        __int128 v58 = 0LL;
      }
    }

    else
    {
      __int128 v61 = v33;
      rsize_t v56 = v32;
      __int128 v58 = -1LL;
    }

uint64_t afStreamCloseWithState( uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((flushBuf(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamCloseWithState",  236,  67,  0,  "flush buf",  v13,  v14,  v31[0]);
    int v15 = 0;
  }

  else
  {
    int v15 = 1;
  }

  __int128 v16 = *(_OWORD *)(a1 + 24);
  v31[0] = *(_OWORD *)(a1 + 8);
  v31[1] = v16;
  uint64_t v17 = (uint64_t *)(a1 + 64);
  __int128 v18 = *(_OWORD *)(a1 + 96);
  v31[2] = *(_OWORD *)(a1 + 56);
  v31[3] = v18;
  BOOL v32 = *(void *)(a1 + 40) != 0LL;
  char v33 = *(_DWORD *)(a1 + 88);
  if (!a2[3]) {
    goto LABEL_32;
  }
  uint64_t v19 = 0LL;
  uint64_t v20 = v31;
  uint64_t v21 = 66LL;
  while (1)
  {
    uint64_t v22 = ((uint64_t (*)(void, _OWORD *, uint64_t))a2[3])(*a2, v20, v21);
    if (v22 < 1) {
      break;
    }
    uint64_t v20 = (_OWORD *)((char *)v20 + v22);
    v19 += v22;
    v21 -= v22;
    if (!v21)
    {
      if (v19 < 0) {
        goto LABEL_32;
      }
      goto LABEL_13;
    }
  }

  if (v22 < 0) {
    goto LABEL_32;
  }
LABEL_13:
  if (!a2[3]) {
    goto LABEL_32;
  }
  uint64_t v23 = *v17;
  if (*v17)
  {
    uint64_t v24 = 0LL;
    uint64_t v25 = *(void *)(a1 + 80);
    while (1)
    {
      uint64_t v26 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v25, v23);
      if (v26 < 1) {
        break;
      }
      v25 += v26;
      v24 += v26;
      v23 -= v26;
      if (!v23)
      {
        if (v24 < 0) {
          goto LABEL_32;
        }
        goto LABEL_21;
      }
    }

    if (v26 < 0) {
      goto LABEL_32;
    }
LABEL_21:
    if (!a2[3]) {
      goto LABEL_32;
    }
  }

  uint64_t v27 = 16LL * *(void *)(a1 + 104);
  if (v27)
  {
    uint64_t v28 = 0LL;
    uint64_t v29 = *(void *)(a1 + 120);
    while (1)
    {
      uint64_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
      if (v30 < 1) {
        break;
      }
      v29 += v30;
      v28 += v30;
      v27 -= v30;
      if (!v27) {
        goto LABEL_28;
      }
    }

    uint64_t v28 = v30;
LABEL_28:
    if (v28 < 0) {
      goto LABEL_32;
    }
  }

  if ((AAByteStreamCloseWithState(*(uint64_t (***)(void))(a1 + 40)) & 0x80000000) != 0)
  {
LABEL_32:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"afStreamCloseWithState",  253,  67,  0,  "serializing state",  v13,  v14,  v31[0]);
    int v15 = 0;
  }

  else if (a3)
  {
    *a3 = *(void *)(a1 + 24);
  }

  if ((*(_DWORD *)a1 & 0x80000000) == 0 && !*(_DWORD *)(a1 + 4)) {
    close(*(_DWORD *)a1);
  }
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  free(*(void **)(a1 + 120));
  free((void *)a1);
  if (v15) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void *aaArchiveFileOutputStreamOpenAtWithState(int a1, const char *a2, AAByteStream_impl *a3, void *a4)
{
  __int16 v61 = 0;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  uint64_t v8 = calloc(1uLL, 0x68uLL);
  uint64_t v9 = malloc(0x80uLL);
  uint64_t v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x80uLL, 0, 0x80uLL), !v8))
  {
    int v14 = *__error();
    int v15 = "malloc";
    __int16 v16 = 462;
LABEL_25:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState",  v16,  67,  v14,  v15,  v12,  v13,  v56);
LABEL_26:
    afStreamClose(v10);
    free(v8);
    return 0LL;
  }

  *(_DWORD *)uint64_t v10 = -1;
  char v56 = -92;
  if (a1 < 0) {
    int v11 = open(a2, 1);
  }
  else {
    int v11 = openat(a1, a2, 1);
  }
  *(_DWORD *)uint64_t v10 = v11;
  if (v11 < 0)
  {
    int v34 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState",  470,  67,  v34,  "%s",  v35,  v36,  (char)a2);
    goto LABEL_26;
  }

  if (!*((void *)a3 + 2))
  {
LABEL_23:
    int v15 = "loading state";
    __int16 v16 = 473;
LABEL_24:
    int v14 = 0;
    goto LABEL_25;
  }

  uint64_t v17 = 0LL;
  __int128 v18 = &v57;
  uint64_t v19 = 66LL;
  do
  {
    uint64_t v20 = (*((uint64_t (**)(void, __int128 *, uint64_t))a3 + 2))(*(void *)a3, v18, v19);
    if (v20 < 0) {
      goto LABEL_23;
    }
    if (!v20) {
      break;
    }
    __int128 v18 = (__int128 *)((char *)v18 + v20);
    v17 += v20;
    v19 -= v20;
  }

  while (v19);
  if (v17 < 0) {
    goto LABEL_23;
  }
  size_t v24 = *((void *)&v60 + 1);
  uint64_t v25 = v60;
  *(void *)(v10 + 104) = *((void *)&v60 + 1);
  uint64_t v26 = (void *)(v10 + 104);
  __int128 v27 = v58;
  *(_OWORD *)(v10 + 8) = v57;
  *(_OWORD *)(v10 + 24) = v27;
  unint64_t v28 = v59;
  *(void *)(v10 + 56) = v59;
  *(_DWORD *)(v10 + 88) = HIBYTE(v61);
  *(void *)(v10 + 96) = v25;
  *(void *)(v10 + 112) = v24;
  if ((v28 & 0x8000000000000000LL) != 0)
  {
LABEL_78:
    int v15 = "alloc buf";
    __int16 v16 = 485;
    goto LABEL_24;
  }

  uint64_t v29 = (unint64_t *)(v10 + 64);
  size_t v30 = *(void *)(v10 + 72);
  if (v30 < v28)
  {
    do
    {
      while (!v30)
      {
        size_t v30 = 0x4000LL;
        if (v28 <= 0x4000)
        {
          BOOL v32 = (void **)(v10 + 80);
          size_t v30 = 0x4000LL;
          goto LABEL_31;
        }
      }

      size_t v31 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0) {
        size_t v31 = v30 & (v30 >> 1);
      }
      v30 += v31;
    }

    while (v30 < v28);
    BOOL v32 = (void **)(v10 + 80);
    if (v30 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_77;
    }

LABEL_52:
          uint64_t v47 = *(void **)(v10 + 80);
          uint64_t v48 = realloc(v47, v46);
          if (v48)
          {
            *(void *)(v10 + 72) = v46;
            *(void *)(v10 + 80) = v48;
            unint64_t v43 = *(void *)(v10 + 64);
            goto LABEL_54;
          }

          free(v47);
LABEL_82:
          *uint64_t v29 = 0LL;
          *(void *)(v10 + 72) = 0LL;
          *(void *)(v10 + 80) = 0LL;
          goto LABEL_83;
        }

        unint64_t v43 = v42;
      }

      size_t v46 = v42;
LABEL_54:
      if (v46 - v43 >= v40) {
        size_t v49 = v40;
      }
      else {
        size_t v49 = v46 - v43;
      }
      ssize_t v50 = AAByteStreamRead(a3, (void *)(*(void *)(v10 + 80) + v43), v49);
      if (v50 < 0) {
        goto LABEL_83;
      }
      if (!v50) {
        break;
      }
      unint64_t v43 = *v29 + v50;
      if (!__CFADD__(*v29, v50))
      {
        unint64_t v42 = *(void *)(v10 + 72);
        if (v43 <= v42) {
          continue;
        }
      }

      goto LABEL_83;
      *uint64_t v29 = v43;
      v41 += v50;
      v40 -= v50;
    }

    while (v40);
    if (v41 < 0) {
      goto LABEL_83;
    }
  }

  if (!*((void *)a3 + 2))
  {
LABEL_83:
    int v15 = "loading state";
    __int16 v16 = 491;
    goto LABEL_24;
  }

  uint64_t v51 = 16LL * *v26;
  if (v51)
  {
    uint64_t v52 = 0LL;
    uint64_t v53 = *(void *)(v10 + 120);
    while (1)
    {
      uint64_t v54 = (*((uint64_t (**)(void, uint64_t, uint64_t))a3 + 2))(*(void *)a3, v53, v51);
      if (v54 < 0) {
        goto LABEL_83;
      }
      if (v54)
      {
        v53 += v54;
        v52 += v54;
        v51 -= v54;
        if (v51) {
          continue;
        }
      }

      if (v52 < 0) {
        goto LABEL_83;
      }
      break;
    }
  }

  if ((_BYTE)v61)
  {
    uint64_t v55 = AAAFSCStreamOpenWithState(*(_DWORD *)v10, a3, 0LL, v21, v22, v23, v12, v13);
    *(void *)(v10 + 40) = v55;
    if (!v55)
    {
      int v15 = "loading AFSC stream state";
      __int16 v16 = 495;
      goto LABEL_24;
    }
  }

  if (a4) {
    *a4 = *(void *)(v10 + 24);
  }
  *uint64_t v8 = v10;
  v8[1] = afStreamClose;
  v8[7] = afStreamCancel;
  v8[3] = afStreamWrite;
  v8[12] = afStreamCloseWithState;
  return v8;
}

          v56 += v157;
          uint64_t v54 = v165;
          if (v165 == 1)
          {
            __int128 v58 = v162;
            __int128 v62 = v159;
            size_t v30 = v156;
            if (v57 >= *(void *)(a4 + 2056)) {
              goto LABEL_57;
            }
          }

          else
          {
            __int128 v58 = v162;
            __int128 v62 = v159;
            size_t v30 = v156;
          }
        }

        __int128 v67 = aaByteStreamSimulate(v43);
        uint64_t v54 = v165;
        if (v62 != v67)
        {
          __int128 v124 = "aaByteStreamSimulate";
          __int128 v125 = 310;
          goto LABEL_144;
        }

                if (v57 >= v10)
                {
                  *uint64_t v29 = v54;
                  v29[1] = v53;
                  v79[3 * v28 + 2] = v57;
                  __int128 v65 = &v78[28 * v30];
                  __int128 v66 = v65[1];
                  __int128 v67 = v65[3];
                  v65[5] = v33;
                  v65[6] = v67;
                  v65[1] = v54;
                  v65[2] = i;
                  v65[3] = v57;
                  v65[4] = v66;
                  __int128 v68 = (_DWORD *)(v16 + 8 * v54);
                  if (v57 > v68[1])
                  {
                    _DWORD *v68 = v53;
                    *(_DWORD *)(*(void *)(v9 + 48) + 8 * v54 + 4) = v57;
                  }
                }

                continue;
              }

              char v33 = 0;
              unint64_t v43 = 0;
              *size_t v31 = v27;
              unint64_t v44 = &v78[28 * (v27 & 0x3FF)];
              *((void *)v44 + 1) = 0LL;
              *((_DWORD *)v44 + 1) = 0;
              goto LABEL_27;
            }
          }
        }
      }

      else
      {
        int i = i + v17 - 1024;
      }
    }
  }

  if (*(_DWORD *)(v8 + 24))
  {
    __int128 v69 = *(_DWORD *)(v8 + 16);
    __int128 v70 = (*(_DWORD *)(v8 + 12) + 1);
    if (v70 < v69)
    {
      int v71 = 8LL * (*(_DWORD *)(v8 + 12) + 1);
      do
      {
        uint64_t v72 = *(void *)(v9 + 48);
        uint64_t v73 = v72 + v71;
        __int128 v74 = *(_DWORD *)(v72 + v71 - 4);
        if (v74 > v10 && v74 > *(_DWORD *)(v72 + v71 + 4))
        {
          __int128 v76 = *(_DWORD *)(v73 - 8) + 1;
          if (v76 < *(_DWORD *)(v9 + 32))
          {
            *(_DWORD *)(v72 + v71) = v76;
            *(_DWORD *)(v73 + 4) = v74 - 1;
            __int128 v69 = *(_DWORD *)(v8 + 16);
          }
        }

        ++v70;
        v71 += 8LL;
      }

      while (v70 < v69);
    }
  }

  return 0LL;
}

    if (v11 == ++v12) {
      return 0LL;
    }
  }

  __endptr = 0LL;
  uint64_t v19 = strtol((const char *)(v10 + v12 + 1), &__endptr, 10);
  if (!*__error())
  {
    switch(v17)
    {
      case 'c':
        uint64_t v22 = a1 + 1;
        goto LABEL_51;
      case 'd':
        uint64_t v22 = a1 + 3;
        goto LABEL_51;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_55;
      case 'i':
        uint64_t v22 = a1 + 2;
        goto LABEL_51;
      case 'l':
        uint64_t v22 = a1 + 4;
        goto LABEL_51;
      default:
        uint64_t v22 = a1;
        if (v17 != 115)
        {
LABEL_55:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"parseProfile",  515,  92,  0,  "Invalid profile code: %c",  v20,  v21,  v17);
          goto LABEL_56;
        }

          if (v51 != v47) {
            break;
          }
          int v14 = 1;
          unint64_t v44 = *(size_t *)((char *)buf + 4) - v47;
          uint64_t v55 = *(size_t *)((char *)buf + 4) == v47;
          *(size_t *)((char *)buf + 4) -= v47;
          uint64_t v9 = v49;
          int v15 = v48;
          __int16 v16 = (pthread_mutex_t *)(v8 + 56);
          uint64_t v17 = (pthread_cond_t *)(v8 + 120);
          if (v55) {
            goto LABEL_4;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  914,  72,  0,  "write failed %zd",  v33,  v34,  v51);
        __int128 v65 = 1;
        int v14 = 1;
        uint64_t v9 = v49;
        int v15 = v48;
        goto LABEL_183;
      case 'E':
        char v56 = *(void *)(v8 + 168);
        if (!v56)
        {
          __int128 v65 = 0;
          int v14 = 0;
LABEL_133:
          uint64_t v17 = (pthread_cond_t *)(v8 + 120);
          goto LABEL_86;
        }

        __int128 v57 = *(void *)(v56 + 2048);
        if (v57 != 70) {
          goto LABEL_104;
        }
        __int128 v58 = *(uint64_t (***)(uint64_t))(v56 + 2288);
        if (v58) {
          goto LABEL_59;
        }
        if (*(void *)(v56 + 2192)) {
          goto LABEL_103;
        }
        if ((*(_BYTE *)(v56 + 2128) & 8) != 0 && (*(_BYTE *)(v9 + 1030) & 2) != 0) {
          __int128 v92 = *(_DWORD *)(v56 + 2132);
        }
        else {
          __int128 v92 = -1;
        }
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, *(const char **)(v8 + 168)) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  808,  72,  0,  "invalid path: %s",  v111,  v112,  v56);
        }

        else
        {
          if (*(_DWORD *)(v9 + 1056)) {
            removeFile(v130);
          }
          __int128 v58 = (uint64_t (**)(uint64_t))aaArchiveFileOutputStreamOpenAt( -1,  v130,  *(void *)(v56 + 2192),  0xFFFFFFFF,  0LL,  v92,  *(void *)(v9 + 1048));
          *(void *)(v56 + 2288) = v58;
          if (v58)
          {
            __int128 v57 = *(void *)(v56 + 2048);
            __int16 v16 = (pthread_mutex_t *)(v8 + 56);
            if (v57 != 70) {
              goto LABEL_104;
            }
LABEL_59:
            *(_DWORD *)(v56 + 2296) = aaArchiveFileOutputStreamCloseAndReturnFD(v58, v28, v29, v30, v31, v32, v33, v34);
            *(void *)(v56 + 2288) = 0LL;
            __int16 v61 = applyEntryAttributes(v9, v56);
            __int128 v62 = *(_DWORD *)(v56 + 2296);
            if ((v62 & 0x80000000) == 0)
            {
              close(v62);
              *(_DWORD *)(v56 + 2296) = -1;
            }

            if (v61 < 0)
            {
              int v118 = v56;
              int v84 = 822;
              goto LABEL_121;
            }

            if (*(_DWORD *)(v56 + 2300) != 2) {
              *(_DWORD *)(v56 + 2300) = 2;
            }
LABEL_103:
            __int128 v57 = *(void *)(v56 + 2048);
LABEL_104:
            if (v57 == 70 || v57 == 72)
            {
LABEL_106:
              if ((retireThreadEnqueue(v120, *(void *)(v8 + 168)) & 0x80000000) == 0)
              {
                __int128 v65 = 0;
                int v14 = 0;
                *(void *)(v8 + 168) = 0LL;
                goto LABEL_133;
              }

              int v84 = 837;
              int v85 = "sending entry to retire thread";
LABEL_132:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  v84,  72,  0,  v85,  v59,  v60,  v118);
              int v14 = 0;
              __int128 v65 = 1;
              goto LABEL_133;
            }

            if ((concatExtractPath(v131, 0x800uLL, (char *)v9, (const char *)v56) & 0x80000000) != 0)
            {
              int v118 = v56;
              __int128 v87 = 274;
              __int128 v88 = "invalid path: %s";
            }

            else
            {
              int v81 = *(void *)(v56 + 2048);
              if (v81 == 68)
              {
                if (*(_DWORD *)(v9 + 1056) && !lstat(v131, &v127))
                {
                  if ((v127.st_mode & 0xF000) != 0x4000)
                  {
                    removeFile(v131);
                    goto LABEL_114;
                  }

  uint64_t v37 = a1[5];
  if (__src)
  {
    memcpy((void *)(v37 + *v8), __src, __smax);
  }

  else if (v37)
  {
    memset_s((void *)(v37 + *v8), __smax, 0, __smax);
  }

  a1[3] += __smax;
  uint64_t v38 = *a1;
  if (*a1)
  {
    unint64_t v39 = 0LL;
    while (1)
    {
      if (v38 <= v39)
      {
        size_t v40 = 0LL;
        uint64_t v41 = 0xFFFFFFFFLL;
      }

      else
      {
        size_t v40 = (unsigned int *)(a1[5] + *(void *)(a1[2] + 8 * v39));
        uint64_t v41 = *v40;
        if (v41 < 5)
        {
LABEL_69:
          size_t v46 = "invalid XAT key";
          uint64_t v47 = 84;
          goto LABEL_78;
        }
      }

      unint64_t v42 = (unsigned __int8 *)(v40 + 1);
      unint64_t v43 = v41 - 4;
      while (*v42++)
      {
        if (!--v43) {
          goto LABEL_69;
        }
      }

      uint64_t result = 0LL;
      if (++v39 == v38) {
        return result;
      }
    }
  }

  return 0LL;
}

  uint64_t v37 = a1[5];
  if (__src)
  {
    memcpy((void *)(v37 + *v8), __src, __smax);
  }

  else if (v37)
  {
    memset_s((void *)(v37 + *v8), __smax, 0, __smax);
  }

  a1[3] += __smax;
  uint64_t v38 = *a1;
  if (*a1)
  {
    unint64_t v39 = 0LL;
    while (1)
    {
      if (v38 == v39 || (size_t v40 = a1[5] + *(void *)(a1[2] + 8 * v39), (*(_DWORD *)v40 + 1) <= 0x16))
      {
        size_t v49 = 179;
        goto LABEL_82;
      }

      if ((*(char *)(v40 + 4) - 65) > 0x14 || ((1 << (*(_BYTE *)(v40 + 4) - 65)) & 0x100809) == 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobInitWithEncodedData",  188,  100,  0,  "invalid ACL entry type %c",  a7,  a8,  *(_BYTE *)(v40 + 4));
        goto LABEL_83;
      }

      HIDWORD(v43) = *(char *)(v40 + 21) - 71;
      LODWORD(v43) = HIDWORD(v43);
      unint64_t v42 = v43 >> 1;
      unint64_t v44 = v42 > 7;
      unint64_t v45 = (1 << v42) & 0xC3;
      if (v44 || v45 == 0) {
        break;
      }
      if ((*(void *)(v40 + 5) & 0xFFFFFFFFFCFDFE0FLL) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobInitWithEncodedData",  199,  100,  0,  "invalid ACL flags 0x%llx",  a7,  a8,  *(void *)(v40 + 5));
        goto LABEL_83;
      }

      uint64_t v47 = *(void *)(v40 + 13);
      if ((v47 & 0xFFFFFFFFFFEFC001LL) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobInitWithEncodedData",  200,  100,  0,  "invalid ACL perms 0x%llx",  a7,  a8,  v47);
        goto LABEL_83;
      }

      uint64_t result = 0LL;
      if (v38 == ++v39) {
        return result;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c",  (uint64_t)"aaEntryACLBlobInitWithEncodedData",  197,  100,  0,  "invalid ACL qualifier type %c",  a7,  a8,  *(_BYTE *)(v40 + 21));
    goto LABEL_83;
  }

  return 0LL;
}

uint64_t aaArchiveFileOutputStreamCloseAndReturnFD( uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a1[1] == afStreamClose)
  {
    uint64_t v8 = *(unsigned int *)*a1;
    *((_DWORD *)*a1 + 1) = 1;
    if ((AAByteStreamClose((AAByteStream)a1) & 0x80000000) == 0) {
      return v8;
    }
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD",  526,  67,  0,  "closing stream",  v10,  v11,  v12);
    if ((v8 & 0x80000000) == 0) {
      close(v8);
    }
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD",  519,  67,  0,  "invalid stream",  a7,  a8,  v12);
  }

  return 0xFFFFFFFFLL;
}

uint64_t flushBuf( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = *(void *)(a1 + 64);
  if (!v8) {
    return 0LL;
  }
  off_t v10 = *(void *)(a1 + 32);
  int v11 = *(_DWORD *)(a1 + 88);
  if (v10 + v8 < *(void *)(a1 + 16))
  {
    if (v11) {
      uint64_t v12 = -*(void *)(a1 + 96);
    }
    else {
      uint64_t v12 = -16384LL;
    }
    v8 &= v12;
  }

  uint64_t v13 = *(char **)(a1 + 80);
  if (!v11)
  {
    if (!v8) {
      return 0LL;
    }
    size_t v17 = v8;
    while (1)
    {
      ssize_t v18 = pwrite(*(_DWORD *)a1, v13, v17, v10);
      if (v18 < 0) {
        break;
      }
      v13 += v18;
      off_t v10 = *(void *)(a1 + 32) + v18;
      *(void *)(a1 + 32) = v10;
      v17 -= v18;
      if (!v17) {
        goto LABEL_64;
      }
    }

    int v16 = *__error();
    int v14 = "write";
    __int16 v15 = 170;
    goto LABEL_67;
  }

  if (((*(void *)(a1 + 96) - 1LL) & v10) != 0)
  {
    int v14 = "buffer offset not aligned to holes";
    __int16 v15 = 114;
LABEL_10:
    int v16 = 0;
LABEL_67:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"flushBuf",  v15,  67,  v16,  v14,  a7,  a8,  v50);
    return 0xFFFFFFFFLL;
  }

  if (!v8) {
    return 0LL;
  }
  uint64_t v19 = (uint64_t *)(a1 + 104);
  size_t v20 = v8;
  while (2)
  {
    size_t v21 = *(void *)(a1 + 96);
    if (v21 <= v20)
    {
      unint64_t v22 = 0LL;
      uint64_t v23 = v13;
      unint64_t v24 = *(void *)(a1 + 96);
      do
      {
        unint64_t v25 = v24;
        if (v21)
        {
          unint64_t v26 = 0LL;
          do
          {
            uint64_t v27 = *(void *)&v23[v26];
            v26 += 8LL;
            if (v27) {
              BOOL v28 = 1;
            }
            else {
              BOOL v28 = v26 >= v21;
            }
          }

          while (!v28);
          if (v27) {
            break;
          }
        }

        unint64_t v24 = v21 + v25;
        v23 += v21;
        unint64_t v22 = v25;
      }

      while (v21 + v25 <= v20);
    }

    else
    {
      unint64_t v22 = 0LL;
    }

    uint64_t v29 = &v13[v22];
    size_t v30 = v22;
    do
    {
      size_t v31 = v30;
      v30 += v21;
      if (v30 > v20)
      {
        size_t v31 = v20;
        if (v22) {
          goto LABEL_41;
        }
        goto LABEL_51;
      }

      if (!v21)
      {
        size_t v31 = v22;
        if (v22) {
          goto LABEL_41;
        }
        goto LABEL_51;
      }

      unint64_t v32 = 0LL;
      do
      {
        uint64_t v33 = *(void *)&v29[v32];
        v32 += 8LL;
        if (v33) {
          BOOL v34 = 1;
        }
        else {
          BOOL v34 = v32 >= v21;
        }
      }

      while (!v34);
      v29 += v21;
    }

    while (v33);
    if (!v22)
    {
LABEL_51:
      unint64_t v39 = v10 + v22;
      goto LABEL_56;
    }

LABEL_41:
    uint64_t v35 = *v19;
    if (*v19)
    {
      uint64_t v36 = *(void *)(a1 + 120) + 16 * v35;
      uint64_t v38 = *(void *)(v36 - 8);
      uint64_t v37 = (void *)(v36 - 8);
      if (v38 == v10)
      {
        unint64_t v39 = v10 + v22;
        void *v37 = v10 + v22;
        goto LABEL_56;
      }
    }

    if (v35 == *(void *)(a1 + 112))
    {
      unint64_t v40 = 2 * v35;
      if (v40 <= 0x10) {
        unint64_t v40 = 16LL;
      }
      *(void *)(a1 + 112) = v40;
      if (16 * v40 >= 0x2000000001LL)
      {
        *__error() = 12;
      }

      else
      {
        uint64_t v41 = *(void **)(a1 + 120);
        unint64_t v42 = (char *)realloc(v41, 16 * v40);
        if (v42)
        {
          *(void *)(a1 + 120) = v42;
          uint64_t v35 = *(void *)(a1 + 104);
          off_t v10 = *(void *)(a1 + 32);
          goto LABEL_55;
        }

        free(v41);
      }

      *(void *)(a1 + 120) = 0LL;
      uint64_t v47 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c",  (uint64_t)"flushBuf",  140,  67,  *v47,  "malloc",  v48,  v49,  v50);
      *uint64_t v19 = 0LL;
      *(void *)(a1 + 112) = 0LL;
      return 0xFFFFFFFFLL;
    }

    unint64_t v42 = *(char **)(a1 + 120);
LABEL_55:
    *uint64_t v19 = v35 + 1;
    unint64_t v43 = (off_t *)&v42[16 * v35];
    unint64_t v39 = v10 + v22;
    *unint64_t v43 = v10;
    v43[1] = v10 + v22;
LABEL_56:
    if (v39 == *(void *)(a1 + 16))
    {
      if (!v22 || v22 != v31)
      {
        int v14 = "invalid state";
        __int16 v15 = 151;
        goto LABEL_10;
      }

      v22 -= *(void *)(a1 + 96);
    }

    if (v31 > v22)
    {
      if (pwrite(*(_DWORD *)a1, &v13[v22], v31 - v22, v22 + v10) != v31 - v22)
      {
        int v14 = "writing data";
        __int16 v15 = 159;
        goto LABEL_10;
      }

      off_t v10 = *(void *)(a1 + 32);
    }

    v13 += v31;
    v10 += v31;
    *(void *)(a1 + 32) = v10;
    v20 -= v31;
    if (v20) {
      continue;
    }
    break;
  }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerLoadSegment",  v22,  28,  0,  v21,  a7,  a8,  v39);
          BOOL v34 = -1LL;
LABEL_42:
          memset_s(__s, 0x104uLL, 0, 0x104uLL);
          memset_s(v48, 0x104uLL, 0, 0x104uLL);
          memset_s(v50, 0x104uLL, 0, 0x104uLL);
          return v34;
        }

      if (*((_DWORD *)a1 + 796) && v15 != aaByteStreamSimulate(*a1))
      {
        __int128 v63 = "aaByteStreamSimulate";
        __int128 v64 = 340;
        goto LABEL_74;
      }

      goto LABEL_57;
    }

    int v81 = *(unsigned __int8 *)(v10 + 28);
    int v82 = a1[1];
    if (pthread_mutex_lock(v8))
    {
      __int128 v60 = "MutexLock";
      __int16 v61 = 169;
LABEL_62:
      __int128 v62 = 0;
      goto LABEL_68;
    }

    ssize_t v18 = *(void *)(v13 + 16);
    uint64_t v19 = ((unint64_t)(0x317E428CA9LL * v18) >> 32) & 0x7F;
    size_t v20 = &v9[3 * v19];
    if (v20[1] != v18) {
      break;
    }
    size_t v21 = (uint64_t)a1[394] + 1;
    a1[394] = (void *)v21;
    v9[3 * v19 + 2] = (void *)v21;
LABEL_26:
    memcpy((void *)(a2 + v7), (const void *)(*v20 + v14), v15);
    uint64_t v41 = 0LL;
LABEL_53:
    if (pthread_mutex_unlock(v8))
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"segment_decode_to_buffer",  208,  137,  0,  "MutexUnlock",  v56,  v57,  v68);
      goto LABEL_73;
    }

    free(v41);
    if (*((_DWORD *)a1 + 796))
    {
      __int128 v58 = v15;
      __int128 v59 = *(unsigned int *)(v13 + 24);
      uint64_t v51 = aaByteStreamSimulate(*a1) == v59;
      __int16 v15 = v58;
      if (!v51)
      {
        __int128 v63 = "aaByteStreamSimulate";
        __int128 v64 = 333;
        goto LABEL_74;
      }
    }

  qsort(*((void **)v2 + 1), v7, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_keys);
  return v2;
}

uint64_t fullReplacementBXPatch5( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  int v34 = 0;
  uint64_t v12 = *(void *)(a1 + 32);
  if (a5 >= 1) {
    fwrite("Full replacement patch\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }
  if (v12 + 60 <= a2)
  {
    if (v12 + 60 < a2) {
      fwrite("Extra bytes in patch (ignored)", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
    int v14 = (char *)malloc(0x20000uLL);
    if (v14)
    {
      uint64_t v17 = ILowMemoryDecoderStreamCreateWithBuffer(a1 + 60, v12, 0x20000uLL);
      if (v17)
      {
        ssize_t v18 = (CC_SHA1_CTX *)OSHA1StreamCreate(a3, 0LL, a4);
        if (v18)
        {
          uint64_t v19 = v18;
          unint64_t v20 = *(void *)(a1 + 16);
          if (v20)
          {
            unint64_t v21 = 0LL;
            while (1)
            {
              unint64_t v22 = v20 - v21;
              if (v22 >= 0x20000) {
                size_t v23 = 0x20000LL;
              }
              else {
                size_t v23 = v22;
              }
              if (ILowMemoryDecoderStreamRead(v17, v14, v23) != v23)
              {
                unint64_t v26 = "reading from payload stream";
                __int16 v27 = 62;
                goto LABEL_32;
              }

              if (OSHA1StreamWrite(v19, v14, v23) != v23) {
                break;
              }
              v21 += v23;
              unint64_t v20 = *(void *)(a1 + 16);
              if (v21 >= v20) {
                goto LABEL_18;
              }
            }

            unint64_t v26 = "writing to digest stream";
            __int16 v27 = 64;
          }

          else
          {
LABEL_18:
            OSHA1StreamDestroy(v19, (unsigned __int8 *)&v32);
            if (v32 == *(void *)(a1 + 40)
              && v33 == *(void *)(a1 + 48)
              && v34 == (unint64_t)*(unsigned int *)(a1 + 56))
            {
              uint64_t v13 = 0LL;
LABEL_34:
              free(v14);
              ILowMemoryDecoderStreamDestroy(v17);
              return v13;
            }

            unint64_t v26 = "Invalid output digest after patch application";
            __int16 v27 = 71;
          }
        }

        else
        {
          unint64_t v26 = "Digest stream init";
          __int16 v27 = 52;
        }
      }

      else
      {
        unint64_t v26 = "Payload stream init";
        __int16 v27 = 51;
      }

uint64_t BXDiff5GetPatchInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 8) {
    return 0xFFFFFFFFLL;
  }
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 >= 0x3C && *(void *)a1 == 0x3035464649445842LL)
  {
    uint64_t result = 0LL;
    *(void *)a3 = *(void *)(a1 + 16);
    int v5 = *(_DWORD *)(a1 + 12) & 1;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8) == 0;
    *(_DWORD *)(a3 + 12) = v5;
  }

  return result;
}

uint64_t BXPatch5StreamWithFlags( uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t, void *, uint64_t), uint64_t a7, uint64_t a8)
{
  uint64_t v157 = *MEMORY[0x1895F89C0];
  if (a5 <= 0x3B)
  {
    size_t v8 = "Invalid patch size";
    __int16 v9 = 264;
    goto LABEL_48;
  }

  if (*(void *)a4 != 0x3035464649445842LL)
  {
    size_t v8 = "Invalid patch header";
    __int16 v9 = 265;
    goto LABEL_48;
  }

  unsigned int v12 = *(_DWORD *)(a4 + 8);
  unint64_t v13 = 28LL * v12 + 60;
  if (v13 > a5)
  {
    size_t v8 = "Invalid patch size";
    __int16 v9 = 269;
    goto LABEL_48;
  }

  int v16 = a8 & 1;
  uint64_t v17 = *(void *)(a4 + 24);
  BOOL v18 = __CFADD__(v13, v17);
  uint64_t v19 = v13 + v17;
  if (v18) {
    uint64_t v19 = -1LL;
  }
  if (!v12)
  {
    uint64_t v39 = *(void *)(a4 + 32);
    BOOL v18 = __CFADD__(v19, v39);
    unint64_t v40 = v19 + v39;
    if (v18) {
      unint64_t v40 = -1LL;
    }
    if (v40 <= a5) {
      return fullReplacementBXPatch5(a4, a5, (uint64_t)a6, a7, a8 & 1, (uint64_t)a6, a7, a8);
    }
    goto LABEL_42;
  }

  uint64_t v23 = *(unsigned int *)(a4 + 8);
  unint64_t v24 = (uint64_t *)(a4 + 60);
  do
  {
    uint64_t v25 = *v24;
    unint64_t v24 = (uint64_t *)((char *)v24 + 28);
    BOOL v18 = __CFADD__(v19, v25);
    v19 += v25;
    if (v18) {
      uint64_t v19 = -1LL;
    }
    --v23;
  }

  while (v23);
  uint64_t v26 = *(void *)(a4 + 32);
  BOOL v18 = __CFADD__(v19, v26);
  unint64_t v27 = v19 + v26;
  if (v18) {
    unint64_t v27 = -1LL;
  }
  if (v27 > a5)
  {
LABEL_42:
    size_t v8 = "Invalid patch size";
    __int16 v9 = 278;
    goto LABEL_48;
  }

  BOOL v151 = (uint64_t *)(a4 + 60);
  *(void *)md = 0LL;
  uint64_t v155 = 0LL;
  int v156 = 0;
  BOOL v28 = malloc(0x40000uLL);
  if (!v28)
  {
    int v42 = *__error();
    unint64_t v43 = "malloc";
    __int16 v44 = 156;
LABEL_46:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"getStreamSHA1Digest",  v44,  42,  v42,  v43,  v32,  v33,  v130);
    free(v28);
    goto LABEL_47;
  }

  int v149 = v16;
  CC_SHA1_Deprecated_Init(&c);
  unint64_t v29 = 0LL;
  if (a3)
  {
    while (1)
    {
      uint64_t v30 = v29 + 0x40000 <= a3 ? 0x40000LL : a3 - v29;
      uint64_t v31 = a1(a2, v28, v30, v29);
      if (v31 <= 0) {
        break;
      }
      uint64_t v34 = v31;
      CC_SHA1_Deprecated_Update(&c, v28, v31);
      v29 += v34;
      if (v29 >= a3) {
        goto LABEL_27;
      }
    }

    unint64_t v43 = "inProc read";
    __int16 v44 = 165;
    int v42 = 0;
    goto LABEL_46;
  }

LABEL_76:
    if ((copyStream(a1, a2, a3, a6, a7) & 0x80000000) == 0) {
      return 0LL;
    }
    size_t v8 = "Output copy failed\n";
    __int16 v9 = 293;
LABEL_48:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  v9,  42,  0,  v8,  a7,  a8,  v130);
    return 0xFFFFFFFFLL;
  }

  size_t v45 = (FILE **)MEMORY[0x1895F89D0];
  fprintf((FILE *)*MEMORY[0x1895F89D0], "Input variants in patch: %u\n", *(_DWORD *)(a4 + 8));
  uint64_t v36 = a4 + 40;
  if (*(void *)md == *(void *)(a4 + 40)
    && v155 == *(void *)(a4 + 48)
    && v156 == (unint64_t)*(unsigned int *)(a4 + 56))
  {
    fwrite("No-op patch matching, writing input\n", 0x24uLL, 1uLL, *v45);
    goto LABEL_76;
  }

          size_t v60 = a2;
          uint64_t v63 = v41;
          uint64_t v48 = *v41;
          uint64_t v49 = realloc(*v41, a2);
          if (v49)
          {
            v12[283] = v49;
            v12[282] = v60;
            goto LABEL_78;
          }

          free(v48);
LABEL_117:
          *uint64_t v63 = 0LL;
          *uint64_t v39 = 0LL;
          v12[282] = 0LL;
          goto LABEL_118;
        }

LABEL_122:
    v84 += v132;
    if (v85 >= v137) {
      goto LABEL_123;
    }
  }

  unint64_t v90 = 0LL;
  __int128 v91 = v148;
  unint64_t v92 = v87;
  while (1)
  {
    unint64_t v93 = v92 - v90;
    if (v93 >= 0x20000) {
      size_t v94 = 0x20000LL;
    }
    else {
      size_t v94 = v93;
    }
    if (ILowMemoryDecoderStreamRead(v139, v152, v94) != v94)
    {
      unint64_t v119 = "reading from diff stream";
      __int16 v120 = 379;
      goto LABEL_145;
    }

    if (a1(a2, v148, v94, v84) != v94)
    {
      unint64_t v119 = "reading from input stream";
      __int16 v120 = 381;
      goto LABEL_145;
    }

    __int128 v95 = (char *)v148;
    __int128 v96 = v152;
    for (size_t i = v94; i; --i)
    {
      char v98 = *v95++;
      *v96++ += v98;
    }

    v90 += v94;
    v84 += v94;
    v85 += v94;
    unint64_t v92 = v87;
    if (v90 >= v87) {
      goto LABEL_114;
    }
  }

  unint64_t v119 = "writing to digest stream";
  __int16 v120 = 390;
LABEL_145:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5StreamWithFlags",  v120,  42,  0,  v119,  v82,  v83,  v131);
  unsigned int v111 = -1;
  __int16 v61 = v152;
LABEL_153:
  uint64_t v115 = v143;
  uint64_t v116 = v145;
  uint64_t v73 = v139;
  __int128 v110 = (void ***)v141;
LABEL_154:
  __int128 v109 = v134;
LABEL_155:
  free(v150);
  free(v61);
  free(v91);
  OBufferedStreamDestroy(v110, v123, v124, v125, v126, v127, v128, v129);
  OSHA1StreamDestroy(v109, md);
  ILowMemoryDecoderStreamDestroy(v116);
  ILowMemoryDecoderStreamDestroy(v73);
  ILowMemoryDecoderStreamDestroy(v115);
  LODWORD(result) = leaveThreadErrorContext(0LL, 0LL, 0);
  else {
    return result;
  }
}

        __strlcat_chk();
        goto LABEL_123;
      }

      uint64_t v50 = 0;
      uint64_t v47 = v109;
      goto LABEL_50;
    }

    unint64_t v88 = atomic_load(&v116);
    int DefaultNThreads = v113;
    uint64_t v49 = v111;
    if (v88 > 0) {
      goto LABEL_120;
    }
    if (!v112) {
      goto LABEL_122;
    }
    if (v113)
    {
      for (size_t i = 0LL; i != v113; ++i)
      {
        if (*(_DWORD *)&v46[40 * i + 4] < *(_DWORD *)&v46[40 * i + 8])
        {
          unint64_t v90 = &v46[40 * i];
          unint64_t v93 = *((_DWORD *)v90 + 4);
          __int128 v91 = v90 + 16;
          unint64_t v92 = v93;
          if (v93)
          {
            *(_DWORD *)__int16 v118 = 0;
            if ((increaseCapacity((uint64_t)v27, *v27 + v92) & 0x80000000) != 0)
            {
              uint64_t v103 = "alloc";
              uint64_t v104 = 631;
              goto LABEL_121;
            }

            if ((StringTableAppendTable(*((void *)v27 + 2), *(unsigned int **)&v46[40 * i + 32], v118) & 0x80000000) != 0)
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  632,  60,  0,  "String table append",  v70,  v71,  v106);
              uint64_t v49 = v111;
              goto LABEL_122;
            }

            size_t v94 = *((void *)v27 + 1);
            __int128 v95 = *v27;
            __int128 v96 = (int *)(*(void *)&v46[40 * i + 24] + 8LL);
            do
            {
              __int128 v97 = (_DWORD *)(v94 + 24LL * v95++);
              *unint64_t v27 = v95;
              *__int128 v97 = *(v96 - 2);
              v97[3] = *(_DWORD *)v118 + *(v96 - 1);
              char v98 = *v96;
              v96 += 3;
              v97[4] = v98;
              --v92;
            }

            while (v92);
            *__int128 v91 = 0;
            uint64_t v49 = v111;
          }
        }
      }
    }

    if (v110) {
      break;
    }
    uint64_t v73 = v72 == *v27;
    __int128 v74 = v72 == *v27 ? v108 : v72;
    uint64_t v72 = *v27;
  }

  while (v74 < *v27);
LABEL_108:
  uint64_t v47 = v109;
  if ((normalize(v27) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  656,  60,  0,  "Tree normalization",  v99,  v100,  v106);
    uint64_t v50 = 0;
  }

  else
  {
    uint64_t v50 = 1;
  }

  uint64_t v49 = v111;
LABEL_50:
  if ((ThreadPoolDestroy((uint64_t)v48) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  661,  60,  0,  "ThreadPoolDestroy",  v51,  v52,  v106);
    uint64_t v50 = 0;
  }

  uint64_t v53 = atomic_load(&v116);
  if (v53 >= 1)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  662,  60,  0,  "threads reported errors",  v51,  v52,  v106);
    uint64_t v50 = 0;
  }

  if (v47)
  {
    if ((int)DefaultNThreads >= 1)
    {
      uint64_t v54 = DefaultNThreads;
      uint64_t v55 = (void ***)(v46 + 32);
      do
      {
        free(*(v55 - 1));
        uint64_t v56 = *v55;
        v55 += 5;
        StringTableDestroy(v56);
        --v54;
      }

      while (v54);
    }

    free(v47);
    free(v49);
  }

  free(v46);
  if (!v50)
  {
    AAPathListDestroy((AAPathList)v27);
    return 0LL;
  }

  return (AAPathList)v27;
}

uint64_t BXPatch5FileWithFlags( const char *a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5, uint64_t a6)
{
  char v11 = (char)a1;
  st_uint64_t size = 0LL;
  unsigned int v12 = open(a1, 0);
  uint64_t v23 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    BOOL v18 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5FileWithFlags",  235,  42,  *v18,  "open: %s",  v19,  v20,  v11);
    return 0xFFFFFFFFLL;
  }

  else
  {
    int v13 = v12;
    if (fstat(v12, &v22))
    {
      int v14 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5FileWithFlags",  236,  42,  *v14,  "fstat: %s",  v15,  v16,  v11);
      uint64_t v17 = 0xFFFFFFFFLL;
LABEL_6:
      close(v13);
      return v17;
    }

    st_uint64_t size = v22.st_size;
    uint64_t v17 = BXPatch5StreamWithFlags( (uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsFileStreamPRead,  (uint64_t)&v23,  v22.st_size,  a2,  a3,  a4,  a5,  a6);
    int v13 = v23;
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }

  return v17;
}

ssize_t BXPatch5WithFlagsFileStreamPRead(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  if (!a3) {
    return 0LL;
  }
  ssize_t result = -1LL;
  if (!__CFADD__(a4, a3) && a4 + a3 <= *(void *)(a1 + 8)) {
    return pread(*(_DWORD *)a1, a2, a3, a4);
  }
  return result;
}

uint64_t copyStream( uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5)
{
  off_t v10 = malloc(0x40000uLL);
  if (!v10)
  {
    int v18 = *__error();
    uint64_t v19 = "malloc";
    __int16 v20 = 188;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"copyStream",  v20,  42,  v18,  v19,  v14,  v15,  v22);
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }

  unint64_t v11 = 0LL;
  if (a3)
  {
    while (1)
    {
      if (v11 + 0x40000 <= a3) {
        uint64_t v12 = 0x40000LL;
      }
      else {
        uint64_t v12 = a3 - v11;
      }
      uint64_t v13 = a1(a2, v10, v12, v11);
      if (v13 <= 0)
      {
        uint64_t v19 = "inProc read";
        __int16 v20 = 196;
        goto LABEL_15;
      }

      uint64_t v16 = a4(a5, v10, v13);
      if (v16 <= 0) {
        break;
      }
      v11 += v16;
      if (v11 >= a3) {
        goto LABEL_9;
      }
    }

    uint64_t v19 = "outProc write";
    __int16 v20 = 198;
LABEL_15:
    int v18 = 0;
    goto LABEL_16;
  }

uint64_t BXPatch5InPlace( const char *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v155 = *MEMORY[0x1895F89C0];
  if (a3 <= 0x3B)
  {
    size_t v8 = "Invalid patch size";
    __int16 v9 = 441;
LABEL_29:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  v9,  42,  0,  v8,  a7,  a8,  v131);
    return 0xFFFFFFFFLL;
  }

  if (*(void *)a2 != 0x3035464649445842LL)
  {
    size_t v8 = "Invalid patch header";
    __int16 v9 = 442;
    goto LABEL_29;
  }

  if ((*(_BYTE *)(a2 + 12) & 1) == 0)
  {
    size_t v8 = "Patch can't be applied in-place";
    __int16 v9 = 445;
    goto LABEL_29;
  }

  if (a4 >= 1) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Input variants in patch: %u\n", *(_DWORD *)(a2 + 8));
  }
  uint64_t v152 = 0LL;
  uint64_t v153 = 0LL;
  int v154 = 0;
  uint64_t FileSHA1Digest = getFileSHA1Digest(a1, (uint64_t)&v152);
  if ((_DWORD)FileSHA1Digest)
  {
    size_t v8 = "computing file digest";
    __int16 v9 = 450;
    goto LABEL_29;
  }

  if (v152 != *(void *)(a2 + 40)
    || v153 != *(void *)(a2 + 48)
    || v154 != (unint64_t)*(unsigned int *)(a2 + 56))
  {
    uint64_t v22 = *(unsigned int *)(a2 + 8);
    if (!(_DWORD)v22)
    {
LABEL_28:
      size_t v8 = "Input doesn't match any of the expected patch inputs (in-place)";
      __int16 v9 = 467;
      goto LABEL_29;
    }

    uint64_t v23 = 0LL;
    unint64_t v24 = (uint64_t *)(a2 + 60);
    uint64_t v25 = a2 + 68;
    while (1)
    {
      BOOL v26 = v152 == *(void *)v25 && v153 == *(void *)(v25 + 8);
      ++v23;
      v25 += 28LL;
      if (v22 == v23) {
        goto LABEL_28;
      }
    }

    if (a4 >= 1)
    {
      uint64_t FileSHA1Digest = fprintf((FILE *)*MEMORY[0x1895F89D0], "In-place patch matching entry %u\n", v23);
      uint64_t v22 = *(unsigned int *)(a2 + 8);
    }

    uint64_t v29 = (uint64_t)v24 + 28 * v22 + *(void *)(a2 + 24);
    uint64_t v150 = *(void *)(a2 + 24);
    uint64_t v148 = (uint64_t)v24 + 28 * v22;
    if ((_DWORD)v22)
    {
      uint64_t v30 = 0LL;
      uint64_t v31 = 0LL;
      do
      {
        if (v23 == v30) {
          uint64_t v31 = v29;
        }
        uint64_t v32 = *v24;
        unint64_t v24 = (uint64_t *)((char *)v24 + 28);
        v29 += v32;
        ++v30;
      }

      while (v22 != v30);
    }

    else
    {
      uint64_t v31 = 0LL;
    }

    uint64_t v33 = *(void *)(v25 - 8);
    uint64_t v134 = *(void *)(a2 + 32);
    if (v29 + v134 - a2 != a3)
    {
      uint64_t FileSHA1Digest = pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  489,  42,  "Warning: extra bytes in patch (ignored)\n",  v19,  a7,  a8,  v131);
      LODWORD(v22) = *(_DWORD *)(a2 + 8);
    }

    enterThreadErrorContext(FileSHA1Digest, v15, v16, v17, v18, v19, a7, a8, v131);
    uint64_t v140 = malloc(0x1000uLL);
    if (v140)
    {
      uint64_t v34 = (char *)malloc(0x1000uLL);
      if (v34)
      {
        size_t v136 = v34;
        uint64_t v141 = (v22 + 2);
        uint64_t v142 = 8 * v141;
        uint64_t v139 = (char *)malloc(8 * v141);
        uint64_t v35 = ILowMemoryDecoderStreamCreateWithBuffer(v148, v150, 0x1000uLL);
        if (v35)
        {
          uint64_t v133 = v33;
          uint64_t v144 = v35;
          uint64_t v38 = 0LL;
          unint64_t v39 = 0LL;
          uint64_t v40 = 0LL;
          uint64_t v41 = 0LL;
          int v42 = v139;
          for (i = 8LL * (v22 + 2); ; uint64_t v38 = &v145[i])
          {
            uint64_t v145 = v38;
            uint64_t v149 = v40;
            if (v40 == v39)
            {
              uint64_t v44 = v39 + (v39 >> 1);
              if (v39 >> 5 <= 0xC34) {
                uint64_t v44 = 2 * v39;
              }
              unint64_t v39 = v39 ? v44 : 2000LL;
              size_t v45 = (char *)reallocf(v41, i * v39);
              size_t i = 8LL * (v22 + 2);
              int v42 = v139;
              uint64_t v41 = v45;
              if (!v45)
              {
                uint64_t v67 = v139;
                unint64_t v101 = __error();
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  527,  42,  *v101,  "malloc",  v102,  v103,  v132);
                uint64_t v66 = 0LL;
                goto LABEL_100;
              }
            }

            BOOL v151 = v41;
            uint64_t v46 = ILowMemoryDecoderStreamRead(v144, v42, i);
            if (!v46) {
              break;
            }
            uint64_t v49 = (uint64_t *)v42;
            uint64_t v50 = v145;
            uint64_t v51 = (v22 + 2);
            uint64_t v41 = v151;
            if (v46 != i)
            {
              uint64_t v67 = v42;
              uint64_t v66 = v151;
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  533,  42,  0,  "reading from control stream S=%lld",  v47,  v48,  v46);
LABEL_100:
              uint64_t v69 = 0LL;
              uint64_t v70 = 0LL;
              uint64_t v71 = 0LL;
              uint64_t v68 = v136;
              uint64_t v72 = v144;
              goto LABEL_64;
            }

            do
            {
              uint64_t v53 = *v49++;
              uint64_t v52 = v53;
              unint64_t v54 = 0x8000000000000000LL - v53;
              if (v53 < 0) {
                uint64_t v52 = v54;
              }
              *(void *)&v50[(void)v151] = v52;
              v50 += 8;
              --v51;
            }

            while (v51);
            uint64_t v40 = v149 + 1;
          }

          if (a4 >= 2) {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "%zu controls in patch (%zu B allocated)\n", v149, v142 * v39);
          }
          uint64_t v75 = PagedFileCreate(a1, *(void *)(a2 + 16), 0x2800000uLL, a4);
          if (v75)
          {
            uint64_t v76 = v75;
            if (v149)
            {
              unint64_t v77 = 0LL;
              uint64_t v78 = (unint64_t *)v151;
              uint64_t v79 = v149;
              do
              {
                unint64_t v137 = *v78;
                uint64_t v146 = (void *)v78[(v23 + 2)];
                PagedFileRetainIn(v76, v77, *v78, v61, v62, v63, v64, v65);
                v77 += (unint64_t)v146 + v137;
                uint64_t v78 = (unint64_t *)((char *)v78 + v142);
                --v79;
              }

              while (v79);
            }

            PagedFileReleaseAllIn((uint64_t)v76, v59, v60, v61, v62, v63, v64, v65);
            uint64_t v69 = (uint64_t)v76;
            if (a4 > 1) {
              PagedFileDump((uint64_t)v76, "Input retained");
            }
            uint64_t v80 = ILowMemoryDecoderStreamCreateWithBuffer(v31, v133, 0x1000uLL);
            uint64_t v72 = v144;
            if (v80)
            {
              uint64_t v143 = v80;
              unint64_t v147 = v76;
              if (v149)
              {
                uint64_t v83 = 0LL;
                unint64_t v84 = 0LL;
                unint64_t v85 = 0LL;
                uint64_t v86 = (v23 + 2);
                unint64_t v87 = v136;
                unint64_t v88 = v151;
                uint64_t v135 = v86;
                while (1)
                {
                  uint64_t v89 = (unint64_t *)&v88[8 * v83 * v141];
                  unint64_t v91 = *v89;
                  unint64_t v90 = v89[1];
                  unint64_t v92 = v89[v86];
                  if (a4 >= 3)
                  {
                    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "DIFF STREAM: I=%zu OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu IDELTA=%lld\n",  v83,  v85,  v84,  v91,  v90,  v92);
                    PagedFileDump((uint64_t)v147, "Before applying control");
                    unint64_t v87 = v136;
                  }

                  unint64_t v138 = v92;
                  if (v91) {
                    break;
                  }
LABEL_96:
                  v84 += v138;
                  v85 += v90;
                  ++v83;
                  unint64_t v88 = v151;
                  uint64_t v86 = v135;
                  if (v83 == v149) {
                    goto LABEL_104;
                  }
                }

                while (1)
                {
                  if (v91 >= 0x1000) {
                    size_t v93 = 4096LL;
                  }
                  else {
                    size_t v93 = v91;
                  }
                  if (ILowMemoryDecoderStreamRead(v143, v87, v93) != v93)
                  {
                    uint64_t v125 = "reading from diff stream";
                    __int16 v126 = 584;
                    goto LABEL_129;
                  }

                  if (PagedFileReadAndReleaseIn( (uint64_t)v147,  v84,  v93,  (uint64_t)v140,  v94,  v95,  v96,  v97))
                  {
                    uint64_t v125 = "reading from input stream";
                    __int16 v126 = 587;
                    goto LABEL_129;
                  }

                  for (uint64_t j = 0LL; j != v93; ++j)
                    v136[j] += v140[j];
                  if (PagedFileRetainAndWriteOut( (uint64_t)v147,  v85,  v93,  (uint64_t)v136,  v98,  v99,  v96,  v97)) {
                    break;
                  }
                  v84 += v93;
                  v85 += v93;
                  v91 -= v93;
                  unint64_t v87 = v136;
                  if (!v91) {
                    goto LABEL_96;
                  }
                }

                uint64_t v125 = "writing output";
                __int16 v126 = 593;
LABEL_129:
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  v126,  42,  0,  v125,  v96,  v97,  v132);
                uint64_t v70 = 0LL;
              }

              else
              {
                unint64_t v84 = 0LL;
LABEL_104:
                uint64_t v69 = (uint64_t)v147;
                if (a4 >= 2) {
                  PagedFileDump((uint64_t)v147, "Diff stream applied");
                }
                if (!PagedFileHasNoIn((uint64_t)v147))
                {
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  608,  42,  0,  "some input bytes are still mapped after diff expansion",  v104,  v105,  v132);
                  uint64_t v70 = 0LL;
                  uint64_t v68 = v136;
                  uint64_t v67 = v139;
                  uint64_t v72 = v144;
LABEL_138:
                  uint64_t v71 = v143;
                  goto LABEL_139;
                }

                uint64_t v70 = ILowMemoryDecoderStreamCreateWithBuffer(v29, v134, 0x1000uLL);
                if (v70)
                {
                  if (v149)
                  {
                    uint64_t v108 = 0LL;
                    unint64_t v109 = 0LL;
                    while (1)
                    {
                      __int128 v110 = &v151[8 * v108 * v141];
                      uint64_t v112 = *(void *)v110;
                      unint64_t v111 = *((void *)v110 + 1);
                      if (a4 >= 3) {
                        fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ARCHIVE STREAM: OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu\n",  v109,  v84,  v112,  v111);
                      }
                      v109 += v112;
                      if (v111) {
                        break;
                      }
LABEL_120:
                      if (++v108 == v149) {
                        goto LABEL_121;
                      }
                    }

                    uint64_t v68 = v136;
                    while (1)
                    {
                      if (v111 >= 0x1000) {
                        size_t v113 = 4096LL;
                      }
                      else {
                        size_t v113 = v111;
                      }
                      if (ILowMemoryDecoderStreamRead(v70, v68, v113) != v113)
                      {
                        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  630,  42,  0,  "reading from archive stream",  v116,  v117,  v132);
                        goto LABEL_137;
                      }

                      if (PagedFileRetainAndWriteOut( (uint64_t)v147,  v109,  v113,  (uint64_t)v68,  v114,  v115,  v116,  v117)) {
                        break;
                      }
                      v109 += v113;
                      v111 -= v113;
                      uint64_t v68 = v136;
                      if (!v111) {
                        goto LABEL_120;
                      }
                    }

                    uint64_t v127 = "writing output";
                    __int16 v128 = 633;
                  }

                  else
                  {
LABEL_121:
                    if (a4 >= 2) {
                      PagedFileDump((uint64_t)v147, "Archive stream applied");
                    }
                    if (PagedFileHasAllOut((uint64_t)v147))
                    {
                      PagedFileDestroy((uint64_t)v147, v118, v119, v120, v121, v122, v106, v107);
                      free(v151);
                      free(v139);
                      free(v140);
                      free(v136);
                      ILowMemoryDecoderStreamDestroy(v144);
                      ILowMemoryDecoderStreamDestroy(v143);
                      ILowMemoryDecoderStreamDestroy(v70);
                      if (getFileSHA1Digest(a1, (uint64_t)&v152))
                      {
                        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  658,  42,  0,  "computing file digest",  v123,  v124,  v132);
                        int v73 = 0;
                      }

                      else
                      {
                        int v73 = 1;
                      }

                      if (v152 == *(void *)(a2 + 40)
                        && v153 == *(void *)(a2 + 48)
                        && v154 == (unint64_t)*(unsigned int *)(a2 + 56))
                      {
                        goto LABEL_66;
                      }

                      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  659,  42,  0,  "Invalid output digest",  v123,  v124,  v132);
LABEL_65:
                      int v73 = 0;
LABEL_66:
                      LODWORD(result) = leaveThreadErrorContext(0LL, 0LL, 0);
                      if (v73) {
                        unsigned int v74 = 0;
                      }
                      else {
                        unsigned int v74 = -1;
                      }
                      else {
                        return result;
                      }
                    }

                    uint64_t v127 = "some output bytes are missing or referenced more than once after archive expansion";
                    __int16 v128 = 643;
                  }
                }

                else
                {
                  uint64_t v127 = "Archive stream init";
                  __int16 v128 = 611;
                }

                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  v128,  42,  0,  v127,  v106,  v107,  v132);
              }

              uint64_t v68 = v136;
LABEL_137:
              uint64_t v67 = v139;
              uint64_t v72 = v144;
              uint64_t v69 = (uint64_t)v147;
              goto LABEL_138;
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  563,  42,  0,  "Diff stream init",  v81,  v82,  v132);
            uint64_t v70 = 0LL;
            uint64_t v71 = 0LL;
            uint64_t v68 = v136;
            uint64_t v67 = v139;
          }

          else
          {
            uint64_t v69 = 0LL;
            uint64_t v70 = 0LL;
            uint64_t v71 = 0LL;
            uint64_t v68 = v136;
            uint64_t v67 = v139;
            uint64_t v72 = v144;
          }

LABEL_139:
          uint64_t v66 = v151;
          goto LABEL_64;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  517,  42,  0,  "Control stream init",  v36,  v37,  v132);
        uint64_t v66 = 0LL;
        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
        uint64_t v71 = 0LL;
        uint64_t v72 = 0LL;
        uint64_t v68 = v136;
        uint64_t v67 = v139;
LABEL_64:
        PagedFileDestroy(v69, v59, v60, v61, v62, v63, v64, v65);
        free(v66);
        free(v67);
        free(v140);
        free(v68);
        ILowMemoryDecoderStreamDestroy(v72);
        ILowMemoryDecoderStreamDestroy(v71);
        ILowMemoryDecoderStreamDestroy(v70);
        goto LABEL_65;
      }

      int v55 = *__error();
      __int16 v58 = 513;
    }

    else
    {
      int v55 = *__error();
      __int16 v58 = 511;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c",  (uint64_t)"BXPatch5InPlace",  v58,  42,  v55,  "malloc",  v56,  v57,  v132);
    uint64_t v66 = 0LL;
    uint64_t v67 = 0LL;
    uint64_t v68 = 0LL;
    uint64_t v69 = 0LL;
    uint64_t v70 = 0LL;
    uint64_t v71 = 0LL;
    uint64_t v72 = 0LL;
    goto LABEL_64;
  }

  if (a4 >= 1) {
    fwrite("No-op patch matching, do nothing\n", 0x21uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }
  return 0LL;
}

  __int16 v9 = "realign_fork";
  off_t v10 = 279;
LABEL_3:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"ForkOutputStreamWrite",  v10,  136,  0,  v9,  a7,  a8,  v138);
  return -1LL;
}

size_t PCompressLZVNEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0LL, (compression_algorithm)0x900u);
  if (!result) {
    return -1LL;
  }
  return result;
}

size_t PCompressLZVNDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0LL, (compression_algorithm)0x900u);
  if (!result) {
    return -1LL;
  }
  return result;
}

uint64_t AEADecryptInPlace( AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(void, float), AAFlagSet a5, int a6)
{
  unint64_t v11 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  uint64_t v14 = v11;
  if (v11)
  {
    uint64_t v17 = AEADecryptionRandomAccessInputStreamOpen(v11, a2, 0xFFFFFFFFFFFFFFFFLL, a5, a6);
    if (v17)
    {
      uint64_t FieldUInt = AEAContextGetFieldUInt(a2, 0xDu);
      if ((FieldUInt & 0x8000000000000000LL) != 0)
      {
        __int16 v20 = "bad output size";
        __int16 v21 = 80;
      }

      else
      {
        if ((processWithProgress(v17, v14, 0LL, FieldUInt, a3, a4) & 0x80000000) == 0)
        {
          int v19 = 1;
          goto LABEL_12;
        }

        __int16 v20 = "processWithProgress";
        __int16 v21 = 83;
      }
    }

    else
    {
      __int16 v20 = "AEADecryptionRandomAccessInputStreamOpen";
      __int16 v21 = 76;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEADecryptInPlace",  v21,  127,  0,  v20,  v15,  v16,  v25);
    AAByteStreamCancel(v14);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEADecryptInPlace",  72,  127,  0,  "aaInPlaceStreamOpen",  v12,  v13,  v25);
    uint64_t v17 = 0LL;
  }

  int v19 = 0;
LABEL_12:
  if (AAByteStreamClose(v17) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEADecryptInPlace",  87,  127,  0,  "AAByteStreamClose",  v22,  v23,  v25);
    int v19 = 0;
  }

  AAByteStreamClose(v14);
  if (v19) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t processWithProgress( AAByteStream_impl *a1, AAByteStream_impl *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void, float))
{
  uint64_t v8 = a4;
  if (a3 && a4)
  {
    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v12 = (char *)malloc(0x40000uLL);
    if (v12)
    {
      if (a3)
      {
        uint64_t v15 = a3;
        uint64_t v44 = a5;
        uint64_t v45 = v8;
LABEL_7:
        uint64_t v16 = v15;
        if (v15 >= 0x40000) {
          uint64_t v15 = 0x40000LL;
        }
        if (*((void *)a1 + 2))
        {
          uint64_t v17 = a6;
          uint64_t v18 = 0LL;
          int v19 = v12;
          uint64_t v20 = v15;
          while (1)
          {
            uint64_t v21 = (*((uint64_t (**)(void, char *, uint64_t))a1 + 2))(*(void *)a1, v19, v20);
            if (v21 < 0) {
              break;
            }
            if (v21)
            {
              v19 += v21;
              v18 += v21;
              v20 -= v21;
              if (v20) {
                continue;
              }
            }

            if (v18 <= 0) {
              break;
            }
            if (*((void *)a2 + 3))
            {
              uint64_t v22 = 0LL;
              uint64_t v23 = v12;
              uint64_t v24 = v15;
              while (1)
              {
                uint64_t v25 = (*((uint64_t (**)(void, char *, uint64_t))a2 + 3))(*(void *)a2, v23, v24);
                if (v25 < 1) {
                  break;
                }
                v23 += v25;
                v22 += v25;
                v24 -= v25;
                if (!v24)
                {
                  if (v22 <= 0) {
                    break;
                  }
                  uint64_t v15 = v16 - v15;
                  a6 = v17;
                  a5 = v44;
                  if (a6 && (a6(v44, (float)((float)(a3 - v15) * 100.0) / (float)a3) & 0x80000000) != 0)
                  {
                    uint64_t v40 = "progress_proc";
                    __int16 v41 = 33;
                    goto LABEL_48;
                  }

                  uint64_t v8 = v45;
                  if (v15) {
                    goto LABEL_7;
                  }
                  goto LABEL_23;
                }
              }
            }

            uint64_t v40 = "aaByteStreamWriteExpected";
            __int16 v41 = 31;
            goto LABEL_48;
          }
        }

        uint64_t v40 = "aaByteStreamReadExpected";
        __int16 v41 = 30;
      }

      else
      {
LABEL_23:
        if (!v8)
        {
LABEL_42:
          free(v12);
          return 0LL;
        }

        float v26 = (float)v8;
        uint64_t v27 = v8;
        unint64_t v43 = a6;
        uint64_t v46 = v8;
LABEL_25:
        if (v27 >= 0x40000) {
          uint64_t v28 = 0x40000LL;
        }
        else {
          uint64_t v28 = v27;
        }
        if (*((void *)a1 + 4))
        {
          uint64_t v29 = 0LL;
          v27 -= v28;
          uint64_t v30 = v12;
          uint64_t v31 = v27;
          uint64_t v32 = v28;
          while (1)
          {
            uint64_t v33 = (*((uint64_t (**)(void, char *, uint64_t, uint64_t))a1 + 4))(*(void *)a1, v30, v32, v31);
            if (v33 < 0) {
              break;
            }
            if (v33)
            {
              v30 += v33;
              v29 += v33;
              v31 += v33;
              v32 -= v33;
              if (v32) {
                continue;
              }
            }

            if (v29 <= 0) {
              break;
            }
            if (*((void *)a2 + 5))
            {
              uint64_t v34 = 0LL;
              uint64_t v35 = v12;
              uint64_t v36 = v27;
              while (1)
              {
                uint64_t v37 = (*((uint64_t (**)(void, char *, uint64_t, uint64_t))a2 + 5))( *(void *)a2,  v35,  v28,  v36);
                if (v37 < 1) {
                  break;
                }
                v35 += v37;
                v34 += v37;
                v36 += v37;
                v28 -= v37;
                if (!v28)
                {
                  if (v34 <= 0) {
                    break;
                  }
                  if (v43 && (v43(a5, (float)((float)(v46 - v27) * 100.0) / v26) & 0x80000000) != 0)
                  {
                    uint64_t v40 = "progress_proc";
                    __int16 v41 = 43;
                    goto LABEL_48;
                  }

                  if (v27) {
                    goto LABEL_25;
                  }
                  goto LABEL_42;
                }
              }
            }

            uint64_t v40 = "aaByteStreamPWriteExpected";
            __int16 v41 = 42;
            goto LABEL_48;
          }
        }

        uint64_t v40 = "aaByteStreamPReadExpected";
        __int16 v41 = 41;
      }

uint64_t AEAEncryptInPlace( AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(void, float), unint64_t a5, int a6)
{
  off_t v12 = AAByteStreamSeek(a1, 0LL, 2);
  if (v12 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEAEncryptInPlace",  106,  127,  0,  "AAByteStreamSeek",  v13,  v14,  v30);
    int v19 = 0LL;
LABEL_11:
    uint64_t v23 = 0LL;
LABEL_17:
    uint64_t v26 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }

  uint64_t v15 = v12;
  uint64_t v16 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  int v19 = v16;
  if (!v16)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEAEncryptInPlace",  110,  127,  0,  "aaInPlaceStreamOpen",  v17,  v18,  v30);
    goto LABEL_11;
  }

  uint64_t v20 = 3LL;
  if (a5 < 3) {
    uint64_t v20 = a5;
  }
  uint64_t v23 = AEAEncryptionOutputStreamOpen(v16, a2, v20 << 62, a6);
  if (!v23)
  {
    uint64_t v27 = "AEAEncryptionOutputStreamOpen";
    __int16 v28 = 114;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEAEncryptInPlace",  v28,  127,  0,  v27,  v21,  v22,  v30);
LABEL_16:
    AAByteStreamCancel(v19);
    goto LABEL_17;
  }

  if ((processWithProgress(v19, v23, v15, 0LL, a3, a4) & 0x80000000) != 0)
  {
    uint64_t v27 = "processWithProgress";
    __int16 v28 = 117;
    goto LABEL_14;
  }

  if (AEAEncryptionOutputStreamCloseAndUpdateContext(v23, a2) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c",  (uint64_t)"AEAEncryptInPlace",  121,  127,  0,  "AEAEncryptionOutputStreamCloseAndUpdateContext",  v24,  v25,  v30);
    uint64_t v23 = 0LL;
    goto LABEL_16;
  }

  uint64_t v23 = 0LL;
  uint64_t v26 = 0LL;
LABEL_18:
  AAByteStreamClose(v23);
  AAByteStreamClose(v19);
  return v26;
}

uint64_t AEAKeychainGenerateItem( int a1, unint64_t a2, unint64_t a3, void *bytes, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a1 == 1)
    {
      unint64_t v10 = (a2 + 7) >> 3;
      if (v10 <= a3)
      {
        uint64_t result = CCRandomGenerateBytes(bytes, (a2 + 7) >> 3);
        if (!(_DWORD)result)
        {
          *a5 = v10;
          return result;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"RNG",  24,  96,  0,  "generate random bytes",  v15,  v16,  v26);
        unint64_t v11 = "RNG failed";
        __int16 v12 = 43;
      }

      else
      {
        unint64_t v11 = "Insufficient buffer capacity";
        __int16 v12 = 42;
      }
    }

    else
    {
      unint64_t v11 = "Invalid item type";
      __int16 v12 = 78;
    }
  }

  else
  {
    unint64_t v13 = vcvtps_u32_f32((float)a2 / 16.61);
    if (6 * v13 <= a3)
    {
      unsigned int bytesa = 0;
      if (!v13)
      {
LABEL_24:
        uint64_t result = 0LL;
        *((_BYTE *)bytes + v13) = 0;
        *a5 = v13;
        return result;
      }

      unsigned int v17 = 0;
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      int v20 = 0;
      unint64_t v21 = 5 * v13;
      if (v21 <= 1) {
        uint64_t v22 = 1LL;
      }
      else {
        uint64_t v22 = v21;
      }
      while (1)
      {
        if (0xCCCCCCCCCCCCCCCDLL * v18 <= 0x3333333333333333LL && v19 != 0) {
          *((_BYTE *)bytes + v19++) = 45;
        }
        if (!v20) {
          break;
        }
LABEL_23:
        unint64_t v13 = v19 + 1;
        *((_BYTE *)bytes + v19) = (v17 % 0xA) | 0x30;
        unsigned int bytesa = v17 / 0xA;
        --v20;
        ++v18;
        v17 /= 0xAu;
        ++v19;
        if (v18 == v22) {
          goto LABEL_24;
        }
      }

      while (!CCRandomGenerateBytes(&bytesa, 4uLL))
      {
        if (bytesa <= 0xEE6B27FF)
        {
          unsigned int v17 = bytesa % 0x3B9ACA00;
          int v20 = 9;
          goto LABEL_23;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"RNG",  24,  96,  0,  "generate random bytes",  v24,  v25,  v26);
      unint64_t v11 = "RNG failed";
      __int16 v12 = 64;
    }

    else
    {
      unint64_t v11 = "Insufficient buffer capacity";
      __int16 v12 = 52;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainGenerateItem",  v12,  96,  0,  v11,  a7,  a8,  v26);
  return 0xFFFFFFFFLL;
}

uint64_t AEAKeychainStoreItem( unsigned __int8 *a1, uint64_t a2, int a3, const UInt8 *a4, CFIndex a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2 || !a5)
  {
    uint64_t v22 = "Invalid args";
    __int16 v23 = 178;
LABEL_10:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainStoreItem",  v23,  96,  0,  v22,  a7,  a8,  v26);
    return 0xFFFFFFFFLL;
  }

  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v22 = "create attributes";
    __int16 v23 = 182;
    goto LABEL_10;
  }

  unint64_t v11 = Attributes;
  CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], a4, a5);
  if (!v12)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainStoreItem",  186,  96,  0,  "create item data",  v13,  v14,  v26);
    CFRelease(v11);
    return 0xFFFFFFFFLL;
  }

  CFDataRef v15 = v12;
  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x18960BE78], v12);
  SecAccessControlRef v18 = SecAccessControlCreateWithFlags(0LL, (CFTypeRef)*MEMORY[0x18960B860], 1uLL, 0LL);
  if (!v18)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainStoreItem",  191,  96,  0,  "create access control",  v16,  v17,  v26);
    goto LABEL_15;
  }

  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x18960B818], v18);
  OSStatus v19 = SecItemAdd(v11, 0LL);
  if (v19)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainStoreItem",  196,  96,  0,  "adding item to the keychain: %d",  v20,  v21,  v19);
LABEL_15:
    uint64_t v24 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }

  uint64_t v24 = 0LL;
LABEL_17:
  CFRelease(v11);
  CFRelease(v15);
  if (v18) {
    CFRelease(v18);
  }
  return v24;
}

__CFDictionary *aeaKeychainCreateAttributes(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v6 = (const void **)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kSecUseDataProtectionKeychain");
  if (!v6)
  {
    unint64_t v11 = "Keychain support not available";
    __int16 v12 = 115;
LABEL_12:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"aeaKeychainCreateAttributes",  v12,  96,  0,  v11,  v7,  v8,  v35);
    return 0LL;
  }

  __int16 v9 = *v6;
  if (a3)
  {
    if (a3 != 1)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"aeaKeychainCreateAttributes",  124,  96,  0,  "Invalid item type %d",  v7,  v8,  a3);
      return 0LL;
    }

    unint64_t v10 = "kAEA";
  }

  else
  {
    unint64_t v10 = "pAEA";
  }

  uint64_t v13 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, v10);
  if (!v14)
  {
    unint64_t v11 = "create attributes";
    __int16 v12 = 128;
    goto LABEL_12;
  }

  CFNumberRef v15 = v14;
  size_t v16 = (2 * a2) | 1;
  if (v16 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_20:
    char v30 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"aeaKeychainCreateAttributes",  132,  96,  *v30,  "malloc",  v31,  v32,  v35);
    uint64_t v33 = v15;
LABEL_21:
    CFRelease(v33);
    return 0LL;
  }

  uint64_t v17 = (const char *)malloc(v16);
  if (!v17) {
    goto LABEL_20;
  }
  SecAccessControlRef v18 = (char *)v17;
  uint64_t v19 = 2 * a2;
  if (a2)
  {
    uint64_t v20 = v17 + 1;
    do
    {
      unsigned int v21 = *a1++;
      *(v20 - 1) = aeaKeychainCreateAttributes_hex[(unint64_t)v21 >> 4];
      *uint64_t v20 = aeaKeychainCreateAttributes_hex[v21 & 0xF];
      v20 += 2;
      --a2;
    }

    while (a2);
  }

  v17[v19] = 0;
  CFStringRef v24 = CFStringCreateWithCString(v13, v17, 0x600u);
  if (v24)
  {
    Mutable = CFDictionaryCreateMutable(v13, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    __int16 v28 = Mutable;
    if (Mutable)
    {
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB48]);
      CFDictionaryAddValue(v28, v9, (const void *)*MEMORY[0x189604DE8]);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x18960BAE0], v15);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x18960BA88], @"AppleEncryptedArchive");
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x18960B870], v24);
      int v29 = 0;
      goto LABEL_27;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"aeaKeychainCreateAttributes",  144,  96,  0,  "create attributes",  v26,  v27,  v35);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"aeaKeychainCreateAttributes",  141,  96,  0,  "create attributes",  v22,  v23,  v35);
    __int16 v28 = 0LL;
  }

  int v29 = 1;
LABEL_27:
  free(v18);
  CFRelease(v15);
  if (v24) {
    CFRelease(v24);
  }
  if (v29 && v28)
  {
    uint64_t v33 = v28;
    goto LABEL_21;
  }

  return v28;
}

uint64_t AEAKeychainLoadItem( unsigned __int8 *a1, uint64_t a2, int a3, unint64_t a4, void *a5, size_t *a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result = 0LL;
  if (!a2)
  {
    uint64_t v17 = "Invalid args";
    __int16 v18 = 219;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainLoadItem",  v18,  96,  0,  v17,  a7,  a8,  v28);
    return 0xFFFFFFFFLL;
  }

  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v17 = "create attributes";
    __int16 v18 = 223;
    goto LABEL_7;
  }

  __int16 v12 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x18960BE20], (const void *)*MEMORY[0x189604DE8]);
  OSStatus v13 = SecItemCopyMatching(v12, &result);
  if (v13 == -25300)
  {
    uint64_t v16 = 0LL;
    goto LABEL_18;
  }

  if (!a5 || v13)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainLoadItem",  231,  96,  0,  "searching item in keychain: %d",  v14,  v15,  v13);
  }

  else
  {
    CFTypeID v19 = CFGetTypeID(result);
    if (v19 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)result);
      if (Length - 1 < a4)
      {
        size_t v23 = Length;
        BytePtr = CFDataGetBytePtr((CFDataRef)result);
        memcpy(a5, BytePtr, v23);
        *a6 = v23;
        uint64_t v16 = 1LL;
        goto LABEL_18;
      }

      uint64_t v25 = "Invalid data size";
      __int16 v26 = 236;
    }

    else
    {
      uint64_t v25 = "Invalid return type";
      __int16 v26 = 234;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainLoadItem",  v26,  96,  0,  v25,  v20,  v21,  v28);
  }

  uint64_t v16 = 0xFFFFFFFFLL;
LABEL_18:
  CFRelease(v12);
  if (result) {
    CFRelease(result);
  }
  return v16;
}

uint64_t AEAKeychainHasItem( unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result = 0LL;
  if (!a2)
  {
    uint64_t v14 = "Invalid args";
    __int16 v15 = 258;
LABEL_8:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainHasItem",  v15,  96,  0,  v14,  a7,  a8,  v17);
    return 0xFFFFFFFFLL;
  }

  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v14 = "create attributes";
    __int16 v15 = 262;
    goto LABEL_8;
  }

  __int16 v9 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x18960BE18], (const void *)*MEMORY[0x189604DE8]);
  OSStatus v10 = SecItemCopyMatching(v9, &result);
  if (v10 == -25300)
  {
    uint64_t v13 = 0LL;
  }

  else if (v10)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainHasItem",  270,  96,  0,  "searching item in keychain: %d",  v11,  v12,  v10);
    uint64_t v13 = 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v13 = 1LL;
  }

  CFRelease(v9);
  if (result) {
    CFRelease(result);
  }
  return v13;
}

uint64_t AEAKeychainRemoveItem( unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v14 = "Invalid args";
    __int16 v15 = 289;
LABEL_8:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainRemoveItem",  v15,  96,  0,  v14,  a7,  a8,  v17);
    return 0xFFFFFFFFLL;
  }

  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v14 = "create attributes";
    __int16 v15 = 293;
    goto LABEL_8;
  }

  __int16 v9 = Attributes;
  OSStatus v10 = SecItemDelete(Attributes);
  if (v10 == -25300)
  {
    uint64_t v13 = 0LL;
  }

  else if (v10)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c",  (uint64_t)"AEAKeychainRemoveItem",  298,  96,  0,  "removing item from keychain: %d",  v11,  v12,  v10);
    uint64_t v13 = 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v13 = 1LL;
  }

  CFRelease(v9);
  return v13;
}

uint64_t PCompressZLIB5Encode(uint64_t a1, unint64_t a2, const uint8_t *a3, size_t a4)
{
  BOOL v4 = a2 >= 2;
  size_t v5 = a2 - 2;
  if (!v4) {
    return -1LL;
  }
  *(_WORD *)a1 = 24184;
  size_t v7 = compression_encode_buffer((uint8_t *)(a1 + 2), v5, a3, a4, 0LL, COMPRESSION_ZLIB);
  if (v7) {
    return v7 + 2;
  }
  else {
    return -1LL;
  }
}

size_t PCompressZLIBDecode(uint8_t *a1, size_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = a4 >= 2;
  size_t v5 = a4 - 2;
  if (!v4) {
    return -1LL;
  }
  size_t result = compression_decode_buffer(a1, a2, (const uint8_t *)(a3 + 2), v5, 0LL, COMPRESSION_ZLIB);
  if (!result) {
    return -1LL;
  }
  return result;
}

uint64_t ParallelCompressionEncode( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = 0LL;
  unsigned int v8 = *(_DWORD *)(a1 + 4);
  LODWORD(v15) = *(_DWORD *)a1;
  uint64_t v14 = *(void *)(a1 + 16);
  v12[1] = 0;
  uint64_t v13 = v8;
  v12[0] = *(_DWORD *)(a1 + 8);
  __int128 v9 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 56);
  return PCompressFilter(v12, (uint64_t)v11, 0LL, a4, a5, a6, a7, a8);
}

uint64_t ParallelCompressionDecode( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  int v8 = *(_DWORD *)(a1 + 4);
  DWORD2(v13) = *(_DWORD *)a1;
  DWORD1(v12) = 1;
  DWORD2(v12) = v8;
  __int128 v9 = *(_OWORD *)(a1 + 24);
  v11[0] = *(_OWORD *)(a1 + 8);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 40);
  return PCompressFilter((unsigned int *)&v12, (uint64_t)v11, 0LL, a4, a5, a6, a7, a8);
}

uint64_t (*PCompressGetEncoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0LL;
  }
  else {
    return off_189E3AE50[a1];
  }
}

uint64_t (*PCompressGetDecoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0LL;
  }
  else {
    return off_189E3AE88[a1];
  }
}

uint64_t RawImagePatchInternal(uint64_t a1, AAByteStream_impl *a2)
{
  int v5 = *(_DWORD *)(a1 + 40);
  int DefaultNThreads = *(_DWORD *)(a1 + 44);
  if (!DefaultNThreads)
  {
    int DefaultNThreads = getDefaultNThreads();
    *(_DWORD *)(a1 + 44) = DefaultNThreads;
  }

  if (DefaultNThreads >= 3) {
    *(_DWORD *)(a1 + 44) = 2;
  }
  if (!*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = *(void *)(a1 + 24);
  }
  uint64_t v6 = a2;
  if (!a2)
  {
    __int16 v18 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 32), 0, 0);
    uint64_t v6 = (AAByteStream_impl *)v18;
    if (!v18)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  542,  135,  0,  "AAFileStreamOpenWithPath",  v19,  v20,  v250);
      uint64_t v31 = 0LL;
      char v30 = 0LL;
      int v29 = 0LL;
      char v28 = 0LL;
      int v27 = 0;
      goto LABEL_30;
    }

    if ((v5 & 1) != 0 && (io_set_nocache(v18) & 0x80000000) != 0) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  543,  135,  "io_set_nocache %s",  v21,  v22,  v23,  *(void *)(a1 + 32));
    }
  }

  size_t v7 = malloc(0x2EuLL);
  OSStatus v10 = v7;
  if (!v7)
  {
    int v17 = *__error();
    uint64_t v15 = "aaMalloc";
    __int16 v16 = 108;
    goto LABEL_24;
  }

  if (!*((void *)v6 + 2)) {
    goto LABEL_17;
  }
  uint64_t v11 = 0LL;
  uint64_t v12 = 46LL;
  __int128 v13 = v7;
  do
  {
    uint64_t v14 = (*((uint64_t (**)(void, void *, uint64_t))v6 + 2))(*(void *)v6, v13, v12);
    if (v14 < 0) {
      goto LABEL_17;
    }
    if (!v14) {
      break;
    }
    __int128 v13 = (void *)((char *)v13 + v14);
    v11 += v14;
    v12 -= v14;
  }

  while (v12);
  if (v11 != 46)
  {
LABEL_17:
    uint64_t v15 = "aaByteStreamReadExpected";
    __int16 v16 = 110;
    goto LABEL_18;
  }

  if (*v10 != 0x3031464649444952LL
    || !*((_WORD *)v10 + 4)
    || !*(void *)((char *)v10 + 18)
    || (size_t v35 = *(void *)((char *)v10 + 30), v35 < 0x2F)
    || v35 >= *(void *)((char *)v10 + 38))
  {
    uint64_t v15 = "bad header";
    __int16 v16 = 118;
LABEL_18:
    int v17 = 0;
LABEL_24:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_header",  v16,  135,  v17,  v15,  v8,  v9,  v250);
LABEL_25:
    free(v10);
    CFStringRef v24 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  548,  135,  *v24,  "patch_read_header",  v25,  v26,  v251);
    int v27 = 0;
    char v28 = 0LL;
    int v29 = 0LL;
    char v30 = 0LL;
LABEL_26:
    uint64_t v31 = 0LL;
    goto LABEL_27;
  }

  if (v35 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_50:
    uint64_t v44 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_header",  122,  135,  *v44,  "aaReallocf",  v45,  v46,  v250);
    OSStatus v10 = 0LL;
    goto LABEL_25;
  }

  uint64_t v36 = (char *)realloc(v10, v35);
  if (!v36)
  {
    free(v10);
    goto LABEL_50;
  }

  char v30 = v36;
  uint64_t v39 = *(void *)(v36 + 30) - 46LL;
  if (*((void *)v6 + 2))
  {
    if (*(void *)(v36 + 30) == 46LL) {
      goto LABEL_54;
    }
    uint64_t v40 = 0LL;
    __int16 v41 = v36 + 46;
    uint64_t v42 = *(void *)(v36 + 30) - 46LL;
    while (1)
    {
      uint64_t v43 = (*((uint64_t (**)(void, char *, uint64_t))v6 + 2))(*(void *)v6, v41, v42);
      if (v43 < 0) {
        break;
      }
      if (v43)
      {
        v41 += v43;
        v40 += v43;
        v42 -= v43;
        if (v42) {
          continue;
        }
      }

      goto LABEL_53;
    }

    uint64_t v40 = v43;
  }

  else
  {
    uint64_t v40 = -1LL;
  }

LABEL_53:
  if (v39 != v40)
  {
    uint64_t v53 = "aaByteStreamReadExpected";
    __int16 v54 = 124;
LABEL_62:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_header",  v54,  135,  0,  v53,  v37,  v38,  v250);
    OSStatus v10 = v30;
    goto LABEL_25;
  }

    uint64_t v46 = v34;
    uint64_t v38 = *v34;
    size_t v35 = (char *)realloc(v38, v27);
    if (v35)
    {
      *((void *)acl + 5) = v35;
      uint64_t v36 = (void *)((char *)acl + 40);
      *((void *)acl + 4) = v27;
      uint64_t v31 = *((void *)acl + 3);
      goto LABEL_55;
    }

    free(v38);
    uint64_t v34 = v46;
LABEL_62:
    *uint64_t v34 = 0LL;
    *uint64_t v15 = 0LL;
    *((void *)acl + 4) = 0LL;
    goto LABEL_49;
  }

  uint64_t v36 = (void *)((char *)acl + 40);
  size_t v35 = (char *)*((void *)acl + 5);
  if (v35)
  {
LABEL_55:
    memset_s(&v35[v31], (qualifier_size + 22), 0, (qualifier_size + 22));
    uint64_t v31 = *v15;
  }

  *((void *)acl + 3) = v31 + v14;
  uint64_t v39 = *((void *)acl + 2);
  uint64_t v40 = (*(void *)acl)++;
  *(void *)(v39 + 8 * v40) = v16;
  if (v16 >= 0xFFFFFFFFFFFFFFFCLL
    || v16 + 4 > *v15
    || (*(_DWORD *)(*v36 + v16) = v14, (v19 & 0x8000000000000000LL) != 0))
  {
LABEL_49:
    CFStringRef v24 = "alloc ACL entry";
    uint64_t v25 = 626;
    goto LABEL_50;
  }

  if (*(void *)acl <= v19) {
    __int16 v41 = 0LL;
  }
  else {
    __int16 v41 = *((void *)acl + 5) + *(void *)(*((void *)acl + 2) + 8 * v19);
  }
  *(_DWORD *)__int16 v41 = v14;
  if (ace->tag == ACL_EXTENDED_DENY) {
    uint64_t v42 = 68;
  }
  else {
    uint64_t v42 = 0;
  }
  if (ace->tag == ACL_EXTENDED_ALLOW) {
    uint64_t v43 = 65;
  }
  else {
    uint64_t v43 = v42;
  }
  *(_BYTE *)(v41 + 4) = v43;
  *(void *)(v41 + 5) = ace->flags;
  *(void *)(v41 + 13) = ace->perms;
  *(_BYTE *)(v41 + 21) = ace->qualifier_type;
  if (qualifier_size) {
    memcpy((void *)(v41 + 22), qualifier_value, qualifier_size);
  }
  return 0;
}

      uint64_t v33 = "prepare decmpfs header";
      uint64_t v34 = 291;
      uint64_t v32 = 0;
LABEL_54:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"storeDecmpfsXattr",  v34,  55,  v32,  v33,  v21,  v22,  v39);
      goto LABEL_55;
    }

    if (!v16)
    {
      uint64_t v15 = 0LL;
      goto LABEL_17;
    }

    if ((storeChunkOffsets( *(_DWORD *)result,  *(_DWORD *)(result + 32),  *(_DWORD *)(result + 44),  *(_DWORD **)(result + 48),  a5,  a6,  a7,  a8) & 0x80000000) != 0)
    {
      char v28 = "storing offsets";
      int v29 = 796;
    }

    else
    {
      int v17 = resourceForkSize(*(_DWORD *)v8);
      *(_DWORD *)(v8 + 40) = v17;
      if (v17 != -1)
      {
        uint64_t v15 = *(void *)(v8 + 88);
        uint64_t v11 = *(void *)(v8 + 16);
        goto LABEL_17;
      }

      char v28 = "invalid resource fork";
      int v29 = 800;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"finalizeResourceFork",  v29,  55,  0,  v28,  a7,  a8,  v39);
    uint64_t v12 = "finalize resource fork";
    __int128 v13 = 832;
    goto LABEL_5;
  }

  return result;
}

LABEL_54:
  uint64_t v47 = 0LL;
  unint64_t v48 = *(void *)(v30 + 38);
  uint64_t v49 = *((unsigned __int16 *)v30 + 4);
  do
  {
    unint64_t v50 = *(void *)&v30[v47 + 46];
    if (v48 >= v50)
    {
      uint64_t v53 = "bad header";
      __int16 v54 = 130;
      goto LABEL_62;
    }

    v47 += 8LL;
    unint64_t v48 = v50;
  }

  while (8 * v49 + 8 != v47);
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v51 = (FILE **)MEMORY[0x1895F89D0];
    if ((_DWORD)v49 == 1) {
      uint64_t v52 = "*full replacement*";
    }
    else {
      uint64_t v52 = *(const char **)(a1 + 16);
    }
    int v55 = "(stream based)";
    if (*(void *)(a1 + 32)) {
      int v55 = *(const char **)(a1 + 32);
    }
    int v56 = *(_DWORD *)(a1 + 40);
    if ((v56 & 1) != 0) {
      uint64_t v57 = "no";
    }
    else {
      uint64_t v57 = "yes";
    }
    if ((v56 & 2) != 0) {
      __int16 v58 = "yes";
    }
    else {
      __int16 v58 = "no";
    }
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ImagePatch\n Input:        %s\n Output:       %s\n Patch:        %s\n CryptexCache: %s\n StaticContent: %s\n",  v52,  *(const char **)(a1 + 24),  v55,  v57,  v58);
    if (*(int *)(a1 + 48) >= 2)
    {
      fprintf( *v51,  "  - Variants:   %d\n - Flags:      %llx\n - # controls: %llu\n - Patch size: %llu bytes\n - Metadata: %llu bytes\n - Controls: %llu bytes\n",  *((unsigned __int16 *)v30 + 4),  *(void *)(v30 + 10),  *(void *)(v30 + 18),  *(void *)&v30[8 * *((unsigned __int16 *)v30 + 4) + 46],  *(void *)(v30 + 38) - *(void *)(v30 + 30),  *(void *)(v30 + 46) - *(void *)(v30 + 38));
      if (*((_WORD *)v30 + 4))
      {
        unint64_t v59 = 0LL;
        do
        {
          if (v59) {
            uint64_t v60 = "Diff";
          }
          else {
            uint64_t v60 = "Literal";
          }
          unint64_t v61 = v59 + 1;
          fprintf( *v51,  "    - %s stream: %llu bytes\n",  v60,  *(void *)&v30[8 * v59 + 54] - *(void *)&v30[8 * v59 + 46]);
          unint64_t v59 = v61;
        }

        while (v61 < *((unsigned __int16 *)v30 + 4));
      }
    }
  }

  uint64_t v62 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 30), *(void *)(v30 + 38));
  uint64_t v65 = v62;
  if (!v62)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_variants",  187,  135,  0,  "aaIntervalInputStreamOpen",  v63,  v64,  v250);
    int v29 = 0LL;
    AAByteStream v70 = 0LL;
    goto LABEL_95;
  }

  uint64_t v66 = *(unsigned int *)(a1 + 48);
  else {
    AAFlagSet v67 = 0xC000000000000000LL;
  }
  AAByteStream v70 = AADecompressionInputStreamOpen(v62, v67, *(_DWORD *)(a1 + 44));
  if (!v70)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_variants",  189,  135,  0,  "AADecompressionInputStreamOpen",  v68,  v69,  v250);
    int v29 = 0LL;
    goto LABEL_95;
  }

  int v29 = calloc(*((unsigned __int16 *)v30 + 4), 8uLL);
  if (!v29)
  {
    uint64_t v76 = "aaCalloc";
    __int16 v77 = 193;
    goto LABEL_94;
  }

  if (*((_WORD *)v30 + 4))
  {
    uint64_t v73 = 0LL;
    while (1)
    {
      unsigned int v74 = rawimg_create_with_stream(v70, v73 == 0);
      v29[v73] = v74;
      if (!v74) {
        break;
      }
    }

    uint64_t v76 = "rawimg_create_with_stream";
    __int16 v77 = 199;
LABEL_94:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_read_variants",  v77,  135,  0,  v76,  v71,  v72,  v250);
LABEL_95:
    free(v29);
    char v75 = 1;
  }

  else
  {
LABEL_89:
    char v75 = 0;
  }

  int v78 = AAByteStreamClose(v70);
  int v79 = AAByteStreamClose(v65);
  if (!v29 || (v75 & 1) != 0 || v79 < 0 || v78 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  552,  135,  0,  "patch_read_variants",  v80,  v81,  v250);
    int v27 = 0;
    char v28 = 0LL;
    int v29 = 0LL;
    goto LABEL_26;
  }

  uint64_t v82 = calloc(*((unsigned __int16 *)v30 + 4), 0x20uLL);
  uint64_t v31 = v82;
  if (!v82)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  556,  135,  0,  "aaCalloc",  v83,  v84,  v250);
    char v28 = 0LL;
    goto LABEL_368;
  }

  if (*((_WORD *)v30 + 4))
  {
    unint64_t v85 = 0LL;
    uint64_t v86 = v82;
    do
    {
      __int128 v87 = *(_OWORD *)(v29[v85] + 2104LL);
      *uint64_t v86 = *(_OWORD *)(v29[v85] + 2088LL);
      v86[1] = v87;
      v86 += 2;
      ++v85;
      unint64_t v88 = *((unsigned __int16 *)v30 + 4);
    }

    while (v85 < v88);
    *(void *)(*v29 + 2048LL) = *(void *)(a1 + 24);
    if ((_DWORD)v88 == 1)
    {
      char v28 = 0LL;
      int v269 = 0;
      v275 = 0LL;
      s = 0LL;
      v287 = 0LL;
      AAByteStream compressed_stream = 0LL;
      v279 = 0LL;
      uint64_t v89 = *v29;
      int v90 = *(_DWORD *)(a1 + 40);
      int v91 = v90 & 1;
      goto LABEL_106;
    }
  }

  else
  {
    *(void *)(*v29 + 2048LL) = *(void *)(a1 + 24);
  }

  uint64_t v106 = (__int128 *)malloc(0x2000uLL);
  char v28 = v106;
  if (!v106)
  {
    uint64_t v121 = "aaMalloc";
    __int16 v122 = 568;
    goto LABEL_367;
  }

  saveThreadErrorContext(v106);
  uint64_t v109 = *((unsigned __int16 *)v30 + 4);
  if (!*((_WORD *)v30 + 4))
  {
LABEL_138:
    restoreThreadErrorContext(v28);
    goto LABEL_139;
  }

  __int128 v110 = &v31[4 * v109 - 4];
  unint64_t v111 = (char *)(v29 - 1);
  while (1)
  {
    uint64_t v291 = v109;
    uint64_t v112 = v109 - 1;
    *(void *)(*(void *)&v111[8 * v109] + 2048LL) = *(void *)(a1 + 16);
    if (!rawimg_get_digests(*(void *)&v111[8 * v109], 4, 1, 1))
    {
      size_t v113 = *(void **)&v111[8 * v291];
      uint64_t v114 = v113[261];
      uint64_t v115 = v113[262];
      uint64_t v116 = v113[263];
      uint64_t v117 = v113[264];
      BOOL v118 = *v110 == v114 && v110[1] == v115;
      BOOL v119 = v118 && v110[2] == v116;
      if (v119 && v110[3] == v117) {
        break;
      }
    }

    v110 -= 4;
    uint64_t v109 = v112;
    if (!v112) {
      goto LABEL_138;
    }
  }

  restoreThreadErrorContext(v28);
  int v269 = v112;
  if ((v112 & 0x80000000) != 0)
  {
LABEL_139:
    uint64_t v121 = "ImagePatch: No variant found";
    __int16 v122 = 586;
    goto LABEL_367;
  }

  if ((_DWORD)v291 == 1) {
    goto LABEL_279;
  }
  uint64_t v184 = &v31[4 * v112];
  uint64_t v185 = *v184;
  uint64_t v186 = v184[1];
  uint64_t v188 = v184[2];
  uint64_t v187 = v184[3];
  if (*v31 == v185 && v31[1] == v186 && v31[2] == v188 && v31[3] == v187)
  {
    *(void *)(*v29 + 2048LL) = *(void *)(a1 + 16);
LABEL_279:
    uint64_t v207 = *v29;
    uint32_t v208 = *(const char **)(*v29 + 2048LL);
    v209 = *(const char **)(a1 + 24);
    int v210 = strcmp(v208, v209);
    int v211 = *(_DWORD *)(a1 + 48);
    if (v210)
    {
      if (v211 >= 2)
      {
        fwrite("ImagePatch: Digest match. Copy input to output.\n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
        uint64_t v207 = *v29;
      }

      if ((copyFileSegment(v208, 0LL, *(void *)(v207 + 2120), v209) & 0x80000000) != 0)
      {
        uint64_t v121 = "copyFileSegment";
        __int16 v122 = 607;
        goto LABEL_367;
      }
    }

    else if (v211 >= 2)
    {
      int v212 = (FILE *)*MEMORY[0x1895F89D0];
      int v213 = "ImagePatch: Digest match. Output already correct.\n";
      size_t v214 = 50LL;
      goto LABEL_375;
    }

    if (fremovexattr(a1, "com.apple.ResourceFork", 32) < 0)
    {
      __int16 v54 = *__error();
      int v55 = "Removing xattr";
      int v56 = 548;
      goto LABEL_104;
    }

    if (fremovexattr(a1, "com.apple.decmpfs", 32) < 0)
    {
      __int16 v54 = *__error();
      int v55 = "Removing xattr";
      int v56 = 549;
      goto LABEL_104;
    }

    int v27 = 0LL;
    goto LABEL_44;
  }

  uint64_t v26 = calloc((v22 + 1), 4uLL);
  if (!v26)
  {
    __int16 v54 = *__error();
    int v55 = "malloc";
    int v56 = 498;
    goto LABEL_104;
  }

  if ((loadChunkOffsets(a1, v13, v22, v26, v36, v37, v38, v39) & 0x80000000) != 0)
  {
    int v55 = "loading chunk offsets";
    int v56 = 499;
    goto LABEL_103;
  }

  if (!(_DWORD)v22)
  {
    uint64_t v44 = 0LL;
    uint64_t v43 = 0LL;
LABEL_95:
    if (v43 != v20 || v44)
    {
      int v55 = "corrupted resource fork";
      int v56 = 544;
      goto LABEL_103;
    }

    goto LABEL_54;
  }

  uint64_t v42 = 0LL;
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t value = v75;
  __srCC_SHA1_CTX c = (char *)(v75 + 1);
  __int16 v58 = v22;
  uint64_t v60 = v74;
  unint64_t v61 = v22 - 1;
  unint64_t v59 = v14;
  while (1)
  {
    uint64_t __s = 0LL;
    if (!((v7 - v44) >> 16))
    {
      int v55 = "obuf full";
      int v56 = 507;
      goto LABEL_103;
    }

    uint64_t v62 = v43;
    uint64_t v45 = &v26[v42];
    uint64_t v47 = *v45;
    uint64_t v46 = v45[1];
    unint64_t v48 = v46 - *v45;
    if (v60 < v48)
    {
      int v55 = "invalid chunk size";
      int v56 = 510;
      goto LABEL_103;
    }

    uint64_t v63 = v7 - v44;
    uint64_t v65 = v42;
    uint64_t v66 = v44;
    if (fgetxattr(a1, "com.apple.ResourceFork", value, v46 - v47, v47, 32) != v48)
    {
      int v55 = "read resource fork chunk";
      int v56 = 513;
      goto LABEL_103;
    }

    if (v46 != v47) {
      uint64_t __s = v46 - v47;
    }
    uint64_t v49 = &v10[v66];
    if (*value == v59)
    {
      unint64_t v50 = (v48 - 1);
      memcpy(v49, __src, v50);
    }

    else
    {
      unint64_t v50 = compression_decode_buffer((uint8_t *)v49, 0x10000uLL, value, v48, v25, v19);
    }

    uint64_t v51 = v65;
    uint64_t v44 = v66;
    uint64_t v52 = v63;
    if (v50 == 0x10000) {
      goto LABEL_81;
    }
    if (v50) {
      uint64_t v53 = v61 == v65;
    }
    else {
      uint64_t v53 = 0;
    }
    if (!v53 || v50 > 0x10000)
    {
LABEL_98:
      int v55 = "invalid chunk";
      int v56 = 532;
      goto LABEL_103;
    }

    if (v50)
    {
LABEL_81:
      uint64_t v44 = v66 + v50;
      if (__CFADD__(v66, v50)) {
        goto LABEL_98;
      }
      uint64_t v52 = v7 - v44;
      if (v7 < v44) {
        goto LABEL_98;
      }
      AAByteStream v70 = v66 + v50;
    }

    uint64_t v43 = v62;
    if (v61 == v65 || !(v52 >> 16)) {
      break;
    }
LABEL_88:
    uint64_t v42 = v51 + 1;
    if (v58 == v42) {
      goto LABEL_95;
    }
  }

  AAFlagSet v67 = v44;
  if (pwrite(a1, v10, v44, v62) == v44)
  {
    uint64_t v43 = v67 + v62;
    AAByteStream v70 = 0LL;
    uint64_t v44 = 0LL;
    uint64_t v51 = v65;
    goto LABEL_88;
  }

  int v55 = "writing chunk";
  int v56 = 539;
LABEL_103:
  __int16 v54 = 0;
LABEL_104:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"decompressToData",  v56,  55,  v54,  v55,  v40,  v41,  (char)__src);
LABEL_43:
  int v27 = 0xFFFFFFFFLL;
LABEL_44:
  free(v75);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  free(v10);
  memset_s(&v70, 0x18uLL, 0, 0x18uLL);
  free(v25);
  free(v26);
  return v27;
}

LABEL_376:
    int v27 = 1;
    rawimg_show(*v29, 1, *(_DWORD *)(a1 + 48));
    if (*(void *)a1
      && ((*(uint64_t (**)(void, uint64_t))a1)(*(void *)(a1 + 8), 100LL) & 0x80000000) != 0)
    {
      uint64_t v121 = "callback signaled abort";
      __int16 v122 = 641;
      goto LABEL_367;
    }

    goto LABEL_369;
  }

  rawimg_show(v29[v112], 0, *(_DWORD *)(a1 + 48));
  int v90 = *(_DWORD *)(a1 + 40);
  int v91 = v90 & 1;
  uint64_t v285 = *v29;
  v288 = (void *)v29[v112];
  v192 = (const char *)v288[256];
  int v283 = strcmp(v192, *(const char **)(*v29 + 2048LL));
  if (!v283)
  {
    if ((v30[10] & 1) != 0)
    {
      if (*(_DWORD *)(a1 + 48)) {
        fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ImagePatch: Patching with excess space <= %d bytes.\n",  *(_DWORD *)(v30 + 26));
      }
    }

    else
    {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  245,  135,  "ImagePatch: Patch not created with in place. No bound on needed excess space.",  v193,  v194,  v195,  v250);
    }

    unint64_t v223 = v288[265];
    if (*(void *)(v285 + 2120) > v223) {
      unint64_t v223 = *(void *)(v285 + 2120);
    }
    uint64_t v281 = v223;
    unsigned int v290 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v285 + 2048), 2, 0x1A4u);
    if (!v290)
    {
      v240 = "AAFileStreamOpenWithPath";
      __int16 v241 = 252;
      goto LABEL_346;
    }

    if ((v90 & 1) != 0)
    {
      if ((io_set_nocache(v290) & 0x80000000) != 0) {
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  257,  135,  "io_set_nocache %s",  v224,  v225,  v226,  *(void *)(v285 + 2048));
      }
      LODWORD(v227) = *(_DWORD *)(a1 + 48);
      uint64_t v227 = v227 >= 3 ? 3LL : v227;
      unsigned int v290 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v290, 0x1000000uLL, 14, 1, v227 << 62);
      if (!v290)
      {
        v240 = "aaCacheStreamOpen";
        __int16 v241 = 259;
        goto LABEL_346;
      }
    }

    v275 = (unsigned int **)aaInSituStreamOpen(v290, v281, *(_DWORD *)(v30 + 26), *(_DWORD *)(a1 + 48), 1);
    if (!v275)
    {
      v240 = "aaInSituStreamOpen";
      __int16 v241 = 264;
      goto LABEL_346;
    }

    if (*((unsigned __int16 *)v30 + 4) <= 1u)
    {
      s = 0LL;
      v287 = 0LL;
      AAByteStream compressed_stream = 0LL;
      v279 = 0LL;
      int v268 = 0;
      v289 = v275;
      uint64_t v123 = aaSegmentStreamOpen(v275, (void *)v285);
      goto LABEL_145;
    }

    v289 = v275;
LABEL_324:
    s = aaSegmentStreamOpen(v275, v288);
    if (!s)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  290,  135,  0,  "aaSegmentStreamOpen",  v231,  v232,  v250);
      v276 = 0LL;
      unint64_t v284 = 0LL;
      v279 = 0LL;
      v280 = 0LL;
      AAByteStream compressed_stream = 0LL;
      unint64_t v292 = 0LL;
      uint64_t v282 = 0LL;
      v287 = 0LL;
      s = 0LL;
      goto LABEL_347;
    }

    v287 = aaForkInputStreamOpen(s, (uint64_t)v288, 0, v228, v229, v230, v231, v232);
    if (!v287)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  292,  135,  0,  "aaForkInputStreamOpen",  v233,  v234,  v250);
      v276 = 0LL;
      unint64_t v284 = 0LL;
      v279 = 0LL;
      v280 = 0LL;
      AAByteStream compressed_stream = 0LL;
      unint64_t v292 = 0LL;
      uint64_t v282 = 0LL;
      v287 = 0LL;
      goto LABEL_347;
    }

    AAByteStream compressed_stream = aaIntervalInputStreamOpen( (uint64_t)v6,  *(void *)&v30[8 * v269 + 46],  *(void *)&v30[8 * v291 + 46]);
    if (compressed_stream)
    {
      LODWORD(v237) = *(_DWORD *)(a1 + 48);
      else {
        uint64_t v237 = v237;
      }
      v279 = AADecompressionInputStreamOpen(compressed_stream, v237 << 62, *(_DWORD *)(a1 + 44));
      if (v279)
      {
        if (v283) {
          goto LABEL_306;
        }
        int v268 = 0;
        goto LABEL_144;
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  298,  135,  0,  "AADecompressionInputStreamOpen",  v238,  v239,  v250);
      v276 = 0LL;
      unint64_t v284 = 0LL;
      v279 = 0LL;
      v280 = 0LL;
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  296,  135,  0,  "aaIntervalInputStreamOpen",  v235,  v236,  v250);
      v276 = 0LL;
      unint64_t v284 = 0LL;
      v279 = 0LL;
      v280 = 0LL;
      AAByteStream compressed_stream = 0LL;
    }

LABEL_273:
    unint64_t v292 = 0LL;
    uint64_t v282 = 0LL;
    goto LABEL_347;
  }

  if (*((unsigned __int16 *)v30 + 4) > 1u)
  {
    v275 = (unsigned int **)AAFileStreamOpenWithPath(v192, 0, 0);
    if (v275)
    {
      if ((v90 & 1) == 0) {
        goto LABEL_271;
      }
      if ((io_set_nocache(v275) & 0x80000000) != 0) {
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  284,  135,  "io_set_nocache %s",  v198,  v199,  v200,  v288[256]);
      }
      LODWORD(v201) = *(_DWORD *)(a1 + 48);
      uint64_t v201 = v201 >= 3 ? 3LL : v201;
      int v91 = 1;
      v275 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v275, 0x1000000uLL, 14, 1, v201 << 62);
      if (v275)
      {
LABEL_271:
        v289 = 0LL;
        goto LABEL_324;
      }

      v240 = "aaCacheStreamOpen";
      __int16 v241 = 286;
    }

    else
    {
      v240 = "AAFileStreamOpenWithPath";
      __int16 v241 = 281;
    }

LABEL_346:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  v241,  135,  0,  v240,  v196,  v197,  v250);
    v276 = 0LL;
    unint64_t v284 = 0LL;
    v279 = 0LL;
    v280 = 0LL;
    AAByteStream compressed_stream = 0LL;
    v289 = 0LL;
    unint64_t v292 = 0LL;
    uint64_t v282 = 0LL;
    v287 = 0LL;
    s = 0LL;
    v275 = 0LL;
LABEL_347:
    int v286 = 0;
    unint64_t v277 = 0LL;
    goto LABEL_348;
  }

  v275 = 0LL;
  s = 0LL;
  v287 = 0LL;
  AAByteStream compressed_stream = 0LL;
  v279 = 0LL;
LABEL_306:
  uint64_t v89 = v285;
LABEL_106:
  uint64_t v285 = v89;
  v289 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v89 + 2048), 1538, 0x1A4u);
  if (!v289)
  {
    uint64_t v104 = "AAFileStreamOpenWithPath";
    __int16 v105 = 305;
    goto LABEL_142;
  }

  if ((v90 & 2) != 0 && (io_hint_static_content(v289) & 0x80000000) != 0) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  308,  135,  "ImagePatch: Static content hint failed.",  v94,  v95,  v96,  v250);
  }
  if ((io_preallocate(v289, *(void *)(v285 + 2120)) & 0x80000000) != 0) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  311,  135,  "ImagePatch: Preallocation failed.",  v97,  v98,  v99,  v250);
  }
  if (v91)
  {
    if ((io_set_nocache(v289) & 0x80000000) != 0) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  316,  135,  "io_set_nocache %s",  v100,  v101,  v102,  *(void *)(v285 + 2048));
    }
    LODWORD(v103) = *(_DWORD *)(a1 + 48);
    else {
      uint64_t v103 = v103;
    }
    int v268 = 1;
    v289 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v289, 0x100000uLL, 14, 1, v103 << 62);
    if (!v289)
    {
      uint64_t v104 = "aaCacheStreamOpen";
      __int16 v105 = 318;
LABEL_142:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  v105,  135,  0,  v104,  v92,  v93,  v250);
      v276 = 0LL;
      uint64_t v282 = 0LL;
      unint64_t v284 = 0LL;
      v280 = 0LL;
      v289 = 0LL;
      unint64_t v292 = 0LL;
      goto LABEL_347;
    }
  }

  else
  {
    int v268 = 1;
  }

LABEL_144:
  uint64_t v123 = aaSegmentStreamOpen(v289, (void *)v285);
LABEL_145:
  uint64_t v282 = (AAByteStream_impl *)v123;
  if (!v123)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  322,  135,  0,  "aaSegmentStreamOpen",  v124,  v125,  v250);
    v276 = 0LL;
    unint64_t v284 = 0LL;
    v280 = 0LL;
    goto LABEL_273;
  }

  unint64_t v292 = aaForkOutputStreamOpen((uint64_t)v123, (void *)v285);
  if (!v292)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  324,  135,  0,  "aaForkOutputStreamOpen",  v126,  v127,  v250);
    v276 = 0LL;
    unint64_t v284 = 0LL;
    v280 = 0LL;
    unint64_t v292 = 0LL;
    goto LABEL_347;
  }

  v280 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 46), *(void *)(v30 + 54));
  if (!v280)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  328,  135,  0,  "aaIntervalInputStreamOpen",  v128,  v129,  v250);
    v276 = 0LL;
    unint64_t v284 = 0LL;
    v280 = 0LL;
    goto LABEL_347;
  }

  LODWORD(v130) = *(_DWORD *)(a1 + 48);
  else {
    uint64_t v130 = v130;
  }
  unint64_t v284 = AADecompressionInputStreamOpen(v280, v130 << 62, *(_DWORD *)(a1 + 44));
  if (!v284)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  330,  135,  0,  "AADecompressionInputStreamOpen",  v131,  v132,  v250);
    v276 = 0LL;
    unint64_t v284 = 0LL;
    goto LABEL_347;
  }

  v276 = calloc(1uLL, 0x10040uLL);
  if (!v276)
  {
    uint64_t v202 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"ctrl_reader_create",  36,  135,  *v202,  "aaCalloc",  v203,  v204,  v250);
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  338,  135,  0,  "control_reader_create",  v205,  v206,  v252);
    v276 = 0LL;
    goto LABEL_347;
  }

  *((void *)v276 + 0x2000) = v6;
  *((void *)v276 + 8195) = v30;
  *((void *)v276 + 8196) = a1;
  uint64_t v139 = *((unsigned __int16 *)v30 + 4) + 1LL;
  *((void *)v276 + 8197) = 0x2000 / v139 * v139;
  *((void *)v276 + 8198) = -1LL;
  uint64_t v140 = *(void *)(v30 + 18);
  *((void *)v276 + 8199) = v140 * v139;
  char v141 = v268;
  if (!v140) {
    char v141 = 1;
  }
  if ((v141 & 1) == 0)
  {
    uint64_t v215 = 0LL;
    unint64_t v278 = 0LL;
    while (1)
    {
      uint64_t v216 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v278, v133, v134, v135, v136, v137, v138);
      if (!v216)
      {
        uint64_t v220 = "ctrl_reader_get";
        __int16 v221 = 349;
        goto LABEL_302;
      }

      if ((*v216 & 0x8000000000000000LL) == 0LL) {
        unint64_t v217 = *v216;
      }
      else {
        unint64_t v217 = 0x8000000000000000LL - *v216;
      }
      uint64_t v218 = v216[v269 + 1];
      if (v218 < 0) {
        uint64_t v218 = 0x8000000000000000LL - v218;
      }
      uint64_t v267 = v218;
      if (v217) {
        break;
      }
LABEL_299:
      v215 += v267;
      if (++v278 >= *(void *)(v30 + 18)) {
        goto LABEL_156;
      }
    }

    while (1)
    {
      uint64_t v219 = v217 >= 0x10000 ? 0x10000LL : v217;
      if (v219 != aaByteStreamSimulate(v287)) {
        break;
      }
      v215 += v219;
      v217 -= v219;
      if (!v217) {
        goto LABEL_299;
      }
    }

    uint64_t v220 = "aaByteStreamSimulate";
    __int16 v221 = 358;
LABEL_302:
    int v222 = 0;
    goto LABEL_308;
  }

          __int16 v16 = "invalid header";
          int v17 = 337;
          goto LABEL_242;
        }
      }

      if (v90 - 1023 < 0xFFFFFFFFFFFFFBFFLL) {
        goto LABEL_144;
      }
      uint64_t v93 = 0LL;
LABEL_123:
      memcpy(&__s + v93, v19 - 512, v90);
      *(&__s + v93 + v90) = 0;
    }

    uint64_t v94 = strrchr(&__s, 47);
    uint64_t v95 = (char)*v20;
    if (v95 != 48) {
      break;
    }
    if (v94) {
      p_s = v94 + 1;
    }
    else {
      p_s = &__s;
    }
    if (*p_s != 46) {
      goto LABEL_159;
    }
    uint64_t v97 = v94 + 2;
    if (!v94) {
      uint64_t v97 = &v148;
    }
    if (*v97 != 95)
    {
LABEL_159:
      __int16 v105 = 0;
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      uint64_t v109 = 1;
      __int128 v110 = 70LL;
LABEL_160:
      v111.uint64_t ikey = 5265748;
      if (AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 88), 0xFFFFFFFF, v111, v110) < 0)
      {
        __int16 v16 = "creating header";
        int v17 = 394;
        goto LABEL_242;
      }

      v112.uint64_t ikey = 5521744;
      if (AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 88), v112) < 0)
      {
        size_t v113 = &__s;
        uint64_t v114 = strlen(&__s);
        uint64_t v115 = v114;
        if (v114 == 1 && __s == 46)
        {
          uint64_t v115 = 0LL;
        }

        else
        {
          size_t v113 = &__s;
          if (v114 >= 2 && __s == 46 && v148 == 47)
          {
            size_t v113 = v149;
            uint64_t v115 = v114 - 2;
          }
        }

        v116.uint64_t ikey = 5521744;
        if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 88), 0xFFFFFFFF, v116, v113, v115) < 0)
        {
          __int16 v16 = "creating header";
          int v17 = 405;
          goto LABEL_242;
        }
      }

      if ((v105 | v106) == 1)
      {
        v117.uint64_t ikey = 4935244;
        if (AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 88), v117) < 0)
        {
          BOOL v118 = 0LL;
          BOOL v119 = v19 - 355;
          while (v119[v118])
          {
            if (++v118 == 100) {
              goto LABEL_180;
            }
          }

          if (!v118)
          {
            __int16 v16 = "invalid linkname";
            int v17 = 412;
            goto LABEL_243;
          }

          if (v118 != 1)
          {
LABEL_180:
            if (*v119 == 46 && *(v19 - 354) == 47)
            {
              BOOL v119 = v19 - 353;
              v118 -= 2LL;
            }
          }

          v120.uint64_t ikey = 4935244;
          if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 88), 0xFFFFFFFF, v120, v119, v118) < 0)
          {
            __int16 v16 = "creating header";
            int v17 = 417;
            goto LABEL_242;
          }
        }
      }

      if ((v107 | v108) == 1)
      {
        value.tv_seCC_SHA1_CTX c = 0LL;
        uint64_t v146 = 0LL;
        if ((tarParseInt(v19 - 183, 8uLL, (unint64_t *)&value) & 0x80000000) != 0)
        {
          __int16 v16 = "invalid header";
          int v17 = 424;
          goto LABEL_242;
        }

        if ((tarParseInt(v19 - 175, 8uLL, &v146) & 0x80000000) != 0)
        {
          __int16 v16 = "invalid header";
          int v17 = 425;
          goto LABEL_242;
        }

        v121.uint64_t ikey = 5653828;
        if ((appendFieldIfNotDefinedUInt(*(AAHeader_impl **)(a1 + 88), v121, value.tv_sec) & 0x80000000) != 0)
        {
          __int16 v16 = "creating header";
          int v17 = 426;
          goto LABEL_242;
        }

        v122.uint64_t ikey = 3294532;
        if ((appendFieldIfNotDefinedUInt(*(AAHeader_impl **)(a1 + 88), v122, v146) & 0x80000000) != 0)
        {
          __int16 v16 = "creating header";
          int v17 = 427;
          goto LABEL_242;
        }
      }

      uint64_t size = 0LL;
      if ((tarParseInt(v19 - 388, 0xCuLL, &size) & 0x80000000) != 0)
      {
        __int16 v16 = "invalid header";
        int v17 = 432;
        goto LABEL_242;
      }

      if (v109)
      {
        v123.uint64_t ikey = 5521732;
        uint64_t v124 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 88), v123);
        if ((v124 & 0x80000000) != 0)
        {
          v125.uint64_t ikey = 5521732;
          if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 88), 0xFFFFFFFF, v125, size) < 0)
          {
            __int16 v16 = "creating header";
            int v17 = 438;
            goto LABEL_242;
          }
        }

        else
        {
          value.tv_seCC_SHA1_CTX c = 0LL;
          if (AAHeaderGetFieldBlob(*(AAHeader *)(a1 + 88), v124, &size, (uint64_t *)&value) < 0)
          {
            __int16 v16 = "looking up header";
            int v17 = 443;
            goto LABEL_242;
          }
        }
      }

      char v141 = 0LL;
      uint64_t v142 = 0LL;
      uint64_t v140 = 0LL;
      if ((tarParseInt(v19 - 412, 8uLL, &v142) & 0x80000000) != 0)
      {
        __int16 v16 = "invalid header";
        int v17 = 449;
        goto LABEL_242;
      }

      if ((tarParseInt(v19 - 404, 8uLL, &v141) & 0x80000000) != 0)
      {
        __int16 v16 = "invalid header";
        int v17 = 450;
        goto LABEL_242;
      }

      if ((tarParseInt(v19 - 396, 8uLL, &v140) & 0x80000000) != 0)
      {
        __int16 v16 = "invalid header";
        int v17 = 451;
        goto LABEL_242;
      }

      v126.uint64_t ikey = 4476749;
      if ((appendFieldIfNotDefinedUInt(*(AAHeader_impl **)(a1 + 88), v126, v142) & 0x80000000) != 0)
      {
        __int16 v16 = "creating header";
        int v17 = 452;
        goto LABEL_242;
      }

      v127.uint64_t ikey = 4475221;
      if ((appendFieldIfNotDefinedUInt(*(AAHeader_impl **)(a1 + 88), v127, v141) & 0x80000000) != 0)
      {
        __int16 v16 = "creating header";
        int v17 = 453;
        goto LABEL_242;
      }

      v128.uint64_t ikey = 4475207;
      if ((appendFieldIfNotDefinedUInt(*(AAHeader_impl **)(a1 + 88), v128, v140) & 0x80000000) != 0)
      {
        __int16 v16 = "creating header";
        int v17 = 454;
        goto LABEL_242;
      }

      v139.tv_seCC_SHA1_CTX c = 0LL;
      v139.tv_nseCC_SHA1_CTX c = 0LL;
      uint64_t v138 = 0LL;
      if ((tarParseInt(v19 - 376, 0xCuLL, (unint64_t *)&v138) & 0x80000000) != 0)
      {
        __int16 v16 = "invalid header";
        int v17 = 459;
        goto LABEL_242;
      }

      v139.tv_seCC_SHA1_CTX c = v138;
      if ((appendFieldIfNotDefinedTimespec(*(AAHeader_impl **)(a1 + 88), &v139) & 0x80000000) != 0)
      {
        __int16 v16 = "creating header";
        int v17 = 461;
        goto LABEL_242;
      }

      uint64_t v129 = 0LL;
      uint64_t v130 = v19 - 247;
      while (v130[v129])
      {
        if (++v129 == 32) {
          goto LABEL_232;
        }
      }

      if (v129)
      {
LABEL_232:
        v131.uint64_t ikey = 5130581;
        if ((appendFieldIfNotDefinedString(*(AAHeader_impl **)(a1 + 88), v131, v130, v129) & 0x80000000) != 0)
        {
          __int16 v16 = "creating header";
          int v17 = 465;
          goto LABEL_242;
        }
      }

      uint64_t v132 = 0LL;
      uint64_t v133 = v19 - 215;
      while (v133[v132])
      {
        if (++v132 == 32) {
          goto LABEL_238;
        }
      }

      if (v132)
      {
LABEL_238:
        v134.uint64_t ikey = 5130567;
        if ((appendFieldIfNotDefinedString(*(AAHeader_impl **)(a1 + 88), v134, v133, v132) & 0x80000000) != 0)
        {
          __int16 v16 = "creating header";
          int v17 = 467;
          goto LABEL_242;
        }
      }

      size_t result = 0LL;
      *a2 = (size + 511) & 0xFFFFFFFFFFFFFE00LL;
      return result;
    }

    value.tv_seCC_SHA1_CTX c = 0LL;
    if ((tarParseInt(v19 - 388, 0xCuLL, (unint64_t *)&value) & 0x80000000) != 0)
    {
      __int16 v16 = "invalid header";
      int v17 = 346;
      goto LABEL_242;
    }

    tv_seCC_SHA1_CTX c = value.tv_sec;
    if ((decodeStreamLoadHeader( (void *)a1,  v18 + ((value.tv_sec + 511) & 0xFFFFFFFFFFFFFE00LL) + 512,  v98,  v99,  v100,  v101,  v8,  v9) & 0x80000000) != 0)
    {
      __int16 v16 = "truncated stream";
      int v17 = 350;
      goto LABEL_242;
    }

    if (tv_sec >= 0x18)
    {
      OSStatus v10 = *(_BYTE **)(a1 + 64);
      uint64_t v103 = *(void *)&v10[v18] == 0x20007160500LL && *(void *)&v10[v18 + 8] == 0x5820534F2063614DLL;
      if (v103 && *(void *)&v10[v18 + 16] == 0x2020202020202020LL) {
        continue;
      }
    }

    __int16 v16 = "invalid ._ entry";
    int v17 = 361;
    goto LABEL_242;
  }

  __int16 v105 = 0;
  uint64_t v106 = 0;
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  __int128 v110 = 68LL;
  switch(v95)
  {
    case '0':
    case '7':
      goto LABEL_159;
    case '1':
      __int16 v105 = 0;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      uint64_t v109 = 0;
      uint64_t v106 = 1;
      __int128 v110 = 72LL;
      goto LABEL_160;
    case '2':
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      uint64_t v109 = 0;
      __int16 v105 = 1;
      __int128 v110 = 76LL;
      goto LABEL_160;
    case '3':
      __int16 v105 = 0;
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v109 = 0;
      uint64_t v108 = 1;
      __int128 v110 = 67LL;
      goto LABEL_160;
    case '4':
      __int16 v105 = 0;
      uint64_t v106 = 0;
      uint64_t v108 = 0;
      uint64_t v109 = 0;
      uint64_t v107 = 1;
      __int128 v110 = 66LL;
      goto LABEL_160;
    case '5':
      goto LABEL_160;
    case '6':
      break;
    default:
      if (!v95) {
        goto LABEL_159;
      }
      break;
  }

  uint64_t v135 = v95;
  __int16 v16 = "Non supported entry type %u";
  int v17 = 392;
LABEL_242:
  LODWORD(v118) = 0;
LABEL_243:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStreamTar.c",  (uint64_t)"loadAndDecodeHeader_Ustar",  v17,  70,  v118,  v16,  v8,  v9,  v135);
  return 0xFFFFFFFFLL;
}

LABEL_156:
  unint64_t v277 = calloc(1uLL, 0x20000uLL);
  if (!v277)
  {
    int v222 = *__error();
    uint64_t v220 = "aaCalloc";
    __int16 v221 = 371;
LABEL_308:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  v221,  135,  v222,  v220,  v137,  v138,  v250);
    goto LABEL_347;
  }

  unint64_t v257 = 0LL;
  unint64_t v264 = 0LL;
  uint64_t v254 = v269 + 1;
  unint64_t v148 = *(void *)(v30 + 18);
  unsigned int v255 = 1;
  while (!v148)
  {
LABEL_244:
    int v183 = v268;
    if (v255 > 1) {
      int v183 = 1;
    }
    ++v255;
    if (v183 == 1)
    {
      if ((AAByteStreamTruncate(v289) & 0x80000000) == 0)
      {
        int v286 = 1;
        goto LABEL_348;
      }

      uint64_t v242 = "AAByteStreamTruncate";
      __int16 v243 = 457;
LABEL_384:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  v243,  135,  0,  v242,  v146,  v147,  v250);
      int v286 = 0;
LABEL_348:
      if (v275 == v289) {
        uint64_t v244 = 0LL;
      }
      else {
        uint64_t v244 = (AAByteStream_impl *)v275;
      }
      goto LABEL_351;
    }
  }

  unint64_t v256 = 0LL;
  unint64_t v263 = 0LL;
  uint64_t v259 = 0LL;
  while (2)
  {
    uint64_t v149 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v256, v142, v143, v144, v145, v146, v147);
    if (!v149)
    {
      uint64_t v242 = "ctrl_reader_get";
      __int16 v243 = 387;
      goto LABEL_384;
    }

    unint64_t v150 = *v149;
    uint64_t v151 = v149[1];
    if ((*v149 & 0x8000000000000000LL) != 0LL) {
      unint64_t v150 = 0x8000000000000000LL - *v149;
    }
    unint64_t v261 = v150;
    unint64_t v152 = 0x8000000000000000LL - v151;
    if (v151 >= 0) {
      unint64_t v152 = v149[1];
    }
    unint64_t v260 = v152;
    uint64_t v153 = v149[v254];
    if (v153 < 0) {
      uint64_t v153 = 0x8000000000000000LL - v153;
    }
    uint64_t v253 = v153;
    if (v255 == 2)
    {
      v263 += v261;
      if ((v268 & 1) == 0 && v263 < *(void *)(v285 + 2056)) {
        goto LABEL_170;
      }
LABEL_215:
      if (v260)
      {
        unint64_t v262 = 0LL;
        while (1)
        {
          uint64_t v172 = v260 - v262;
          if (v260 - v262 >= 0x10000) {
            uint64_t v172 = 0x10000LL;
          }
          uint64_t v266 = v172;
          if (!*((void *)v284 + 2))
          {
LABEL_336:
            uint64_t v242 = "aaByteStreamReadExpected";
            __int16 v243 = 439;
            goto LABEL_384;
          }

          if (v172)
          {
            uint64_t v173 = 0LL;
            v174 = v277;
            uint64_t v175 = v172;
            while (1)
            {
              uint64_t v176 = (*((uint64_t (**)(void, _BYTE *, uint64_t))v284 + 2))(*(void *)v284, v174, v175);
              if (v176 < 0) {
                break;
              }
              if (v176)
              {
                v174 += v176;
                v173 += v176;
                v175 -= v176;
                if (v175) {
                  continue;
                }
              }

              goto LABEL_229;
            }

            uint64_t v173 = v176;
LABEL_229:
            if (v266 != v173) {
              goto LABEL_336;
            }
            if (!*((void *)v292 + 5)) {
              goto LABEL_337;
            }
            uint64_t v272 = 0LL;
            char v177 = v277;
            unint64_t v178 = v263;
            uint64_t v179 = v266;
            while (1)
            {
              uint64_t v180 = (*((uint64_t (**)(void, _BYTE *, uint64_t, unint64_t))v292 + 5))( *(void *)v292,  v177,  v179,  v178);
              if (v180 < 1) {
                break;
              }
              v177 += v180;
              v272 += v180;
              v178 += v180;
              v179 -= v180;
              if (!v179) {
                goto LABEL_236;
              }
            }

            uint64_t v272 = v180;
LABEL_236:
            if (v266 != v272)
            {
LABEL_337:
              uint64_t v242 = "aaByteStreamWriteExpected";
              __int16 v243 = 440;
              goto LABEL_384;
            }
          }

          else if (!*((void *)v292 + 5))
          {
            goto LABEL_337;
          }

          v264 += v266;
          if (*(void *)a1)
          {
            if (v264 > v257)
            {
              unint64_t v181 = *(void *)(v285 + 2080);
              if (v264 < v181)
              {
                unint64_t v182 = ((v181 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
                if (((*(uint64_t (**)(void, unint64_t))a1)( *(void *)(a1 + 8),  v264 / (v181 / 0x64 + 1)) & 0x80000000) != 0)
                {
                  __int16 v249 = 450;
                  goto LABEL_387;
                }

                unint64_t v257 = v264 + (v182 >> 2);
              }
            }
          }

          v263 += v266;
          v262 += v266;
          if (v262 >= v260) {
            goto LABEL_243;
          }
        }
      }

      goto LABEL_243;
    }

    if (!v261)
    {
LABEL_212:
      v259 += v253;
      if ((v268 & 1) != 0 || v255 != 1 || v263 < *(void *)(v285 + 2056)) {
        goto LABEL_215;
      }
LABEL_170:
      v263 += v260;
LABEL_243:
      unint64_t v148 = *(void *)(v30 + 18);
      if (++v256 >= v148) {
        goto LABEL_244;
      }
      continue;
    }

    break;
  }

  unint64_t v258 = 0LL;
  while (2)
  {
    uint64_t v154 = v261 - v258;
    if (v261 - v258 >= 0x10000) {
      uint64_t v154 = 0x10000LL;
    }
    uint64_t v265 = v154;
    if (!v287[4]) {
      goto LABEL_340;
    }
    if (v154)
    {
      uint64_t v270 = 0LL;
      uint64_t v155 = v277;
      uint64_t v156 = v259;
      uint64_t v157 = v154;
      while (1)
      {
        uint64_t v158 = ((uint64_t (*)(uint64_t, _BYTE *, uint64_t, uint64_t))v287[4])(*v287, v155, v157, v156);
        if (v158 < 0) {
          break;
        }
        if (v158)
        {
          v155 += v158;
          v270 += v158;
          v156 += v158;
          v157 -= v158;
          if (v157) {
            continue;
          }
        }

        goto LABEL_183;
      }

      uint64_t v270 = v158;
LABEL_183:
      if (v265 != v270)
      {
LABEL_340:
        uint64_t v242 = "aaByteStreamPReadExpected";
        __int16 v243 = 400;
        goto LABEL_384;
      }
    }

    unint64_t v159 = *(void *)(v285 + 2072);
    if (v263 >= v159)
    {
LABEL_198:
      if (!*((void *)v292 + 5)) {
        goto LABEL_342;
      }
      if (v265)
      {
        uint64_t v271 = 0LL;
        uint64_t v166 = v277;
        unint64_t v167 = v263;
        uint64_t v168 = v265;
        while (1)
        {
          uint64_t v169 = (*((uint64_t (**)(void, _BYTE *, uint64_t, unint64_t))v292 + 5))( *(void *)v292,  v166,  v168,  v167);
          if (v169 < 1) {
            break;
          }
          v166 += v169;
          v271 += v169;
          v167 += v169;
          v168 -= v169;
          if (!v168) {
            goto LABEL_205;
          }
        }

        uint64_t v271 = v169;
LABEL_205:
        if (v265 != v271)
        {
LABEL_342:
          uint64_t v242 = "aaByteStreamWriteExpected";
          __int16 v243 = 412;
          goto LABEL_384;
        }
      }
    }

    else
    {
      if (v265 + v263 > v159)
      {
        uint64_t v242 = "bad controls";
        __int16 v243 = 406;
        goto LABEL_384;
      }

      if (!*((void *)v279 + 2)) {
        goto LABEL_380;
      }
      if (v265)
      {
        uint64_t v160 = 0LL;
        size_t v161 = v277 + 0x10000;
        uint64_t v162 = v265;
        while (1)
        {
          uint64_t v163 = (*((uint64_t (**)(void, char *, uint64_t))v279 + 2))(*(void *)v279, v161, v162);
          if (v163 < 0) {
            break;
          }
          if (v163)
          {
            v161 += v163;
            v160 += v163;
            v162 -= v163;
            if (v162) {
              continue;
            }
          }

          goto LABEL_196;
        }

        uint64_t v160 = v163;
LABEL_196:
        uint64_t v164 = v277;
        uint64_t v165 = v265;
        if (v265 != v160)
        {
LABEL_380:
          uint64_t v242 = "aaByteStreamReadExpected";
          __int16 v243 = 407;
          goto LABEL_384;
        }

        do
        {
          *v164 += v164[0x10000];
          ++v164;
          --v165;
        }

        while (v165);
        goto LABEL_198;
      }

      if (!*((void *)v292 + 5)) {
        goto LABEL_342;
      }
    }

    v264 += v265;
    if (!*(void *)a1 || v264 <= v257 || (unint64_t v170 = *(void *)(v285 + 2080), v264 >= v170))
    {
LABEL_211:
      v259 += v265;
      v263 += v265;
      v258 += v265;
      if (v258 >= v261) {
        goto LABEL_212;
      }
      continue;
    }

    break;
  }

  unint64_t v171 = ((v170 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
  if (((*(uint64_t (**)(void, unint64_t))a1)(*(void *)(a1 + 8), v264 / (v170 / 0x64 + 1)) & 0x80000000) == 0)
  {
    unint64_t v257 = v264 + (v171 >> 2);
    goto LABEL_211;
  }

  __int16 v249 = 422;
LABEL_387:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"patch_apply",  v249,  135,  0,  "callback signaled abort",  v146,  v147,  v250);
  if (v275 == v289) {
    uint64_t v244 = 0LL;
  }
  else {
    uint64_t v244 = (AAByteStream_impl *)v275;
  }
  if (v279) {
    AAByteStreamCancel(v279);
  }
  AAByteStreamCancel(v284);
  int v286 = 0;
LABEL_351:
  if (v276)
  {
    AAByteStreamClose(*((AAByteStream *)v276 + 8194));
    AAByteStreamClose(*((AAByteStream *)v276 + 8193));
    free(v276);
  }

  free(v277);
  AAByteStreamClose((AAByteStream)v287);
  AAByteStreamClose((AAByteStream)s);
  AAByteStreamClose(v244);
  AAByteStreamClose(v292);
  AAByteStreamClose(v282);
  AAByteStreamClose((AAByteStream)v289);
  AAByteStreamClose(v279);
  AAByteStreamClose(compressed_stream);
  AAByteStreamClose(v284);
  AAByteStreamClose(v280);
  if (v286)
  {
    if (rawimg_get_digests(*v29, 4, 0, 1)
      || (*v31 == *(void *)(*v29 + 2088LL) ? (BOOL v245 = v31[1] == *(void *)(*v29 + 2096LL)) : (BOOL v245 = 0),
          v245 ? (BOOL v246 = v31[2] == *(void *)(*v29 + 2104LL)) : (BOOL v246 = 0),
          v246 ? (BOOL v247 = v31[3] == *(void *)(*v29 + 2112LL)) : (BOOL v247 = 0),
          !v247))
    {
      uint64_t v121 = "digest mismatch";
      __int16 v122 = 630;
      goto LABEL_367;
    }

    if (*(int *)(a1 + 48) >= 2)
    {
      int v212 = (FILE *)*MEMORY[0x1895F89D0];
      int v213 = "ImagePatch: Digest match. Output reconstructed.\n";
      size_t v214 = 48LL;
LABEL_375:
      fwrite(v213, v214, 1uLL, v212);
    }

    goto LABEL_376;
  }

  uint64_t v121 = "patch_apply";
  __int16 v122 = 621;
LABEL_367:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"RawImagePatchInternal",  v122,  135,  0,  v121,  v107,  v108,  v250);
LABEL_368:
  int v27 = 0;
LABEL_369:
  if (*((_WORD *)v30 + 4))
  {
    unint64_t v248 = 0LL;
    do
      rawimg_destroy((uint64_t *)v29[v248++]);
    while (v248 < *((unsigned __int16 *)v30 + 4));
  }

      __strlcat_chk();
      __int16 v54 = a1[2112];
      if ((v54 & 0x40) == 0)
      {
LABEL_111:
        if ((v54 & 0x10) == 0) {
          goto LABEL_112;
        }
        goto LABEL_158;
      }

uint64_t ctrl_reader_get( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1 + 0x10000;
  uint64_t v9 = *(void *)(a1 + 65560);
  if (*(void *)(v9 + 18) <= a2) {
    return 0LL;
  }
  unint64_t v11 = a2 + a2 * *(unsigned __int16 *)(v9 + 8);
  if (v11 >= *(void *)(a1 + 65584)) {
    goto LABEL_8;
  }
  uint64_t v12 = *(void *)(a1 + 65568);
  *(void *)(a1 + 65584) = -*(void *)(a1 + 65576);
  AAByteStreamClose(*(AAByteStream *)(a1 + 65552));
  *(void *)(v8 + 16) = 0LL;
  AAByteStreamClose(*(AAByteStream *)(v8 + 8));
  *(void *)(v8 + 8) = 0LL;
  __int128 v13 = aaIntervalInputStreamOpen(*(void *)v8, *(void *)(v9 + 38), *(void *)(v9 + 46));
  *(void *)(v8 + 8) = v13;
  if (!v13)
  {
    int v27 = "aaIntervalInputStreamOpen";
    __int16 v28 = 81;
LABEL_24:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c",  (uint64_t)"ctrl_reader_get",  v28,  135,  0,  v27,  a7,  a8,  v30);
    return 0LL;
  }

  uint64_t v14 = *(unsigned int *)(v12 + 48);
  else {
    AAFlagSet v15 = 0xC000000000000000LL;
  }
  AAByteStream v16 = AADecompressionInputStreamOpen(v13, v15, *(_DWORD *)(v12 + 44));
  *(void *)(v8 + 16) = v16;
  if (!v16)
  {
    int v27 = "AADecompressionInputStreamOpen";
    __int16 v28 = 83;
    goto LABEL_24;
  }

LABEL_8:
  while (1)
  {
    unint64_t v17 = *(void *)(v8 + 40);
    uint64_t v18 = *(void *)(v8 + 48);
    uint64_t v19 = v17 + v18;
    if (v11 < v17 + v18) {
      return a1 + 8 * (v11 - v18);
    }
    *(void *)(v8 + 48) = v19;
    unint64_t v20 = *(void *)(v8 + 56) - v19;
    if (v20 < v17) {
      unint64_t v17 = v20;
    }
    uint64_t v21 = *(void *)(v8 + 16);
    if (*(void *)(v21 + 16))
    {
      uint64_t v22 = 0LL;
      uint64_t v23 = 8 * v17;
      if (8 * v17)
      {
        uint64_t v24 = a1;
        uint64_t v25 = 8 * v17;
        while (1)
        {
          uint64_t v26 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v21 + 16))(*(void *)v21, v24, v25);
          if (v26 < 0) {
            break;
          }
          if (v26)
          {
            v24 += v26;
            v22 += v26;
            v25 -= v26;
            if (v25) {
              continue;
            }
          }

          goto LABEL_19;
        }

        uint64_t v22 = v26;
      }

  if (*(_DWORD *)v9 > 5u || ((1 << *(_DWORD *)v9) & 0x2A) == 0)
  {
    if (*(_DWORD *)(a1 + 592))
    {
      uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 240);
      if (!v31) {
        goto LABEL_36;
      }
      uint64_t v32 = v31(a1 + 332, a1 + 592);
      if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104) || v32 < 0) {
        goto LABEL_36;
      }
      uint64_t v33 = *(_DWORD *)(a1 + 592);
      if (v33 >= 0x101)
      {
LABEL_35:
        __break(1u);
LABEL_36:
        uint64_t v21 = "Invalid signing private key in context";
        uint64_t v22 = 121;
        goto LABEL_40;
      }
    }

    else
    {
      uint64_t v33 = 0;
    }

    __memcpy_chk();
    *(_DWORD *)(v9 + 1188) = v33;
    memset_s((void *)(v9 + 1192 + v33), 256LL - v33, 0, 256LL - v33);
    *(_OWORD *)(v9 + 1712) = *(_OWORD *)(a1 + 2416);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104))
    {
      uint64_t v21 = "Invalid signing public key in context";
      uint64_t v22 = 131;
      goto LABEL_40;
    }
  }

  AAFlagSet v15 = *(unsigned int *)(v9 + 120);
  __memcpy_chk();
  *(_DWORD *)(v9 + 928) = v15;
  memset_s((void *)(v9 + 932 + v15), 256 - v15, 0, 256 - v15);
  AAByteStream v16 = *(unsigned int *)(v9 + 84);
  __memcpy_chk();
  LODWORD(v98[0]) = v16;
  memset_s((char *)v98 + v16 + 4, 256 - v16, 0, 256 - v16);
  unint64_t v17 = *(unsigned int *)(v9 + 84);
  __memcpy_chk();
  LODWORD(v100[0]) = v17;
  memset_s((char *)v100 + v17 + 4, 256 - v17, 0, 256 - v17);
  uint64_t v18 = AAByteStreamSeek(a2, 0LL, 2);
  if ((v18 & 0x8000000000000000LL) == 0 && v18 != *(void *)(v9 + 40))
  {
    uint64_t v21 = "Container size mismatch";
    uint64_t v22 = 143;
    goto LABEL_40;
  }

  if (*(void *)(v9 + 376) <= 0x100000uLL) {
    uint64_t v19 = 0x100000LL;
  }
  else {
    uint64_t v19 = *(void *)(v9 + 376);
  }
  if (v19 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_28:
    __int16 v28 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateExisting",  151,  28,  *v28,  "malloc",  v29,  v30,  v90);
LABEL_42:
    uint64_t v24 = 0LL;
    goto LABEL_43;
  }

  uint64_t v23 = (char *)malloc(v19);
  if (!v23) {
    goto LABEL_28;
  }
  uint64_t v24 = v23;
  uint64_t v25 = (*(void *)(v9 + 32) + (unint64_t)*(unsigned int *)(v9 + 16) - 1) / *(unsigned int *)(v9 + 16);
  if (HIDWORD(v25))
  {
    uint64_t v26 = "Invalid sizes in root header";
    int v27 = 155;
    goto LABEL_51;
  }

  *(_DWORD *)(v9 + 400) = v25;
  uint64_t v36 = *(_DWORD *)(v9 + 20);
  uint64_t v37 = (v25 + v36 - 1) / v36;
  *(_DWORD *)(v9 + 404) = v37;
  if (((v36 * (unint64_t)v37) & 0xFFFFFFFF00000000LL) != 0)
  {
    uint64_t v26 = "Invalid sizes in root header";
    int v27 = 158;
    goto LABEL_51;
  }

  uint64_t v39 = v37 * v36;
  if (v39 >= 0xF0F0F10)
  {
    *__error() = 12;
    *(void *)(v9 + 392) = 0LL;
LABEL_99:
    uint64_t v38 = *__error();
    uint64_t v26 = "malloc";
    int v27 = 171;
    goto LABEL_52;
  }

  uint64_t v40 = calloc(v39, 0x220uLL);
  *(void *)(v9 + 392) = v40;
  if (!v40) {
    goto LABEL_99;
  }
  int v91 = v19;
  __int16 v41 = *(void *)(v9 + 344);
  uint64_t v92 = (unsigned int *)(v9 + 72);
  uint64_t v93 = a2;
  if (!*(_DWORD *)(v9 + 404))
  {
LABEL_97:
    uint64_t v69 = *(void *)(v9 + 40);
    AAByteStream v70 = v41;
    uint64_t v71 = v69 >= v41;
    uint64_t v72 = v69 - v41;
    if (!v71)
    {
      uint64_t v26 = "Invalid container size";
      int v27 = 230;
      goto LABEL_51;
    }

    *(void *)(v9 + 64) = v72;
    if (!v72 || *(_DWORD *)(a1 + 2740))
    {
      uint64_t v34 = 1;
      goto LABEL_44;
    }

    memset(v122, 0, sizeof(v122));
    memset(v121, 0, 260);
    uint64_t v120 = 0;
    BOOL v119 = 0u;
    BOOL v118 = 0u;
    uint64_t v117 = 0u;
    uint64_t v116 = 0u;
    uint64_t v115 = 0u;
    uint64_t v114 = 0u;
    size_t v113 = 0u;
    uint64_t v112 = 0u;
    __int128 v110 = 0u;
    unint64_t v111 = 0u;
    uint64_t v108 = 0u;
    uint64_t v109 = 0u;
    uint64_t v106 = 0u;
    uint64_t v107 = 0u;
    uint64_t v104 = 0u;
    __int16 v105 = 0u;
    if (*(void *)(v9 + 248)
      && (*(_DWORD *)((char *)v121 + 7) = 1262571615,
          *(void *)&v121[0] = 0x5F41454100000007LL,
          memset_s((void *)((unint64_t)v121 | 0xB), 0xF9uLL, 0, 0xF9uLL),
          (uint64_t v73 = *(uint64_t (**)(_BYTE *, void, _DWORD *, _OWORD *, __int128 *))(v9 + 144)) != 0LL)
      && *v10
      && (v73(v122, *v92, v10, v121, &v104) & 0x80000000) == 0)
    {
      unsigned int v74 = (*(uint64_t (**)(_BYTE *))(v9 + 248))(v122);
    }

    else
    {
      unsigned int v74 = 0LL;
    }

    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    memset_s(v121, 0x104uLL, 0, 0x104uLL);
    if (v74)
    {
      while (1)
      {
        if (v72 >= 0x100000) {
          __int16 v77 = 0x100000LL;
        }
        else {
          __int16 v77 = v72;
        }
        if (!*((void *)v93 + 4)) {
          goto LABEL_131;
        }
        int v78 = 0LL;
        int v79 = v24;
        uint64_t v80 = v70;
        uint64_t v81 = v77;
        while (1)
        {
          uint64_t v82 = (*((uint64_t (**)(void, char *, uint64_t, unint64_t))v93 + 4))( *(void *)v93,  v79,  v81,  v80);
          if (v82 < 0) {
            break;
          }
          if (v82)
          {
            v79 += v82;
            v78 += v82;
            v80 += v82;
            v81 -= v82;
            if (v81) {
              continue;
            }
          }

          goto LABEL_125;
        }

        int v78 = v82;
LABEL_125:
        if (v78 != v77)
        {
LABEL_131:
          uint64_t v84 = "loading padding";
          unint64_t v85 = 250;
          goto LABEL_142;
        }

        uint64_t v83 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 256);
        if (!v83 || (v83(v74, v24, v77) & 0x80000000) != 0) {
          break;
        }
        v70 += v77;
        v72 -= v77;
        if (!v72)
        {
          uint64_t v34 = 1;
          goto LABEL_133;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateExisting",  252,  28,  0,  "authenticating padding",  v75,  v76,  v90);
      uint64_t v34 = 0;
LABEL_133:
      memset(v122, 0, sizeof(v122));
      uint64_t v86 = *(uint64_t (**)(uint64_t, _BYTE *))(v9 + 264);
      if (v86)
      {
        if (LODWORD(v98[0]) == *(_DWORD *)(v9 + 84)
          && (v86(v74, v122) & 0x80000000) == 0
          && *(_DWORD *)v122 == *(_DWORD *)(v9 + 84))
        {
          if (*(_DWORD *)v122 < 8u) {
            goto LABEL_144;
          }
          __int128 v87 = 0LL;
          unint64_t v88 = 4LL;
          do
          {
            v87 |= *(void *)&v122[v88] ^ *(void *)((char *)v98 + v88);
            uint64_t v89 = v88 + 12;
            v88 += 8LL;
          }

          while (v89 <= *(unsigned int *)v122);
          if (!v87)
          {
LABEL_144:
            memset_s(v122, 0x104uLL, 0, 0x104uLL);
            goto LABEL_143;
          }
        }
      }

      memset_s(v122, 0x104uLL, 0, 0x104uLL);
      uint64_t v84 = "authenticating padding";
      unint64_t v85 = 257;
    }

    else
    {
      uint64_t v84 = "authenticating padding";
      unint64_t v85 = 241;
    }

    v13[3] = v16;
    uint64_t v19 = *(void *)(a1 + 32);
    *(_DWORD *)(v14 + 4 * v15) = *(void *)(v19 - 64);
    unint64_t v20 = pc_array_append(v19, v13, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 32) = v20;
    if (!v20) {
      break;
    }
LABEL_9:
    uint64_t v12 = ++v11 < v9;
    if (v11 == v9) {
      goto LABEL_13;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"fingerprint_consumer",  413,  112,  0,  "pc_array_append",  a7,  a8,  v22);
LABEL_16:
  pc_array_free(v8);
  return (v12 << 31 >> 31);
}

  cancelStreams((void *)a1);
LABEL_9:
  free(v4);
  return a1;
}

      *((_DWORD *)a1 + 3) = v30.st_flags;
      goto LABEL_9;
    }

  if ((v8 & 0x10) == 0)
  {
    if ((v8 & 1) == 0) {
      goto LABEL_10;
    }
LABEL_13:
    AAFlagSet v15 = *((_DWORD *)a1 + 1);
    if ((v8 & 2) != 0) {
      goto LABEL_11;
    }
    goto LABEL_14;
  }

  *(_OWORD *)((char *)v62 + v10) = *(_OWORD *)(a1 + 24);
  v10 += 16;
  HIDWORD(v61[0]) = v9 | 0x2000;
  if ((v8 & 1) != 0) {
    goto LABEL_13;
  }
LABEL_10:
  AAFlagSet v15 = -1;
  if ((v8 & 2) != 0)
  {
LABEL_11:
    AAByteStream v16 = *((_DWORD *)a1 + 2);
    goto LABEL_15;
  }

  AAByteStream v16 = ThreadPoolCreate(v3, (uint64_t)v5, (uint64_t)computePatchesWorkerProc);
  if (!v16)
  {
    __int16 v41 = "ThreadPoolCreate";
    uint64_t v42 = 1081;
    goto LABEL_34;
  }

  unint64_t v17 = *(void *)(a1 + 72);
  if (v17)
  {
    uint64_t v18 = 0LL;
    for (size_t i = 0LL; i < v17; ++i)
    {
      unint64_t v20 = *(void *)(a1 + 80);
      if (*(_DWORD *)(v20 + v18 + 8) == 4
        && *(void *)(v20 + 72 * v2 + 208 + v18) < *(void *)(*(void *)(a1 + 8) + 152LL))
      {
        uint64_t Worker = (void *)ThreadPoolGetWorker((uint64_t)v16, v9, v10, v11, v12, v13, v14, v15);
        if (!Worker)
        {
          __int16 v41 = "ThreadPoolGetWorker";
          uint64_t v42 = 1089;
          goto LABEL_34;
        }

        *uint64_t Worker = a1;
        Worker[1] = i;
        if ((ThreadPoolRunWorker((uint64_t)v16, (uint64_t)Worker, v22, v23, v24, v25, v14, v15) & 0x80000000) != 0)
        {
          __int16 v41 = "ThreadPoolRunWorker";
          uint64_t v42 = 1093;
          goto LABEL_34;
        }

        unint64_t v17 = *(void *)(a1 + 72);
      }

      v18 += 984LL;
    }
  }

  if ((ThreadPoolSync(v16) & 0x80000000) != 0)
  {
    __int16 v41 = "ThreadPoolSync";
    uint64_t v42 = 1095;
    goto LABEL_34;
  }

  uint64_t v31 = *(void *)(a1 + 72);
  if (!v31)
  {
LABEL_25:
    uint64_t v36 = 1;
    goto LABEL_36;
  }

  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  uint64_t v34 = 72 * v2 + 208;
  while (1)
  {
    size_t v35 = *(void *)(a1 + 80);
    if (*(_DWORD *)(v35 + v32 + 8) != 4 || *(void *)(v35 + v34 + v32) < *(void *)(*(void *)(a1 + 8) + 152LL)) {
      goto LABEL_24;
    }
    v48[0] = a1;
    v48[1] = v33;
    uint64_t v31 = *(void *)(a1 + 72);
LABEL_24:
    ++v33;
    v32 += 984LL;
    if (v33 >= v31) {
      goto LABEL_25;
    }
  }

  __int16 v41 = "compute patch";
  uint64_t v42 = 1105;
LABEL_34:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateComputePatches",  v42,  27,  0,  v41,  v14,  v15,  v48[0]);
LABEL_35:
  uint64_t v36 = 0;
LABEL_36:
  if ((ThreadPoolDestroy((uint64_t)v16) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"stateComputePatches",  1109,  27,  0,  "ThreadPoolDestroy",  v43,  v44,  v48[0]);
    uint64_t v36 = 0;
  }

  if (v5)
  {
    if ((_DWORD)v3)
    {
      uint64_t v45 = v5;
      do
      {
        uint64_t v46 = *v45++;
        free(v46);
        --v3;
      }

      while (v3);
    }

    free(v5);
  }

  if (v36) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  if ((AAByteStreamFlush(*(void **)(a1 + 24)) & 0x80000000) != 0) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c",  (uint64_t)"aaCompressionOutputStreamFlush",  230,  19,  "Flush on underlying stream failed",  v6,  v7,  v8,  v12);
  }
  return 0LL;
}

off_t AARandomAccessByteStreamProcess( AAByteStream istream, AAByteStream ostream, off_t max_offset, size_t block_size, AAFlagSet flags, int n_threads)
{
  if ((uint64_t)block_size <= 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"AARandomAccessByteStreamProcess",  315,  89,  0,  "Invalid arguments",  v6,  v7,  v89);
    return -1LL;
  }

  LODWORD(v8) = n_threads;
  if ((flags & 0x400) == 0)
  {
    if (n_threads <= 0) {
      LODWORD(v8) = getDefaultNThreads();
    }
    memset_s(__s, 0x18uLL, 0, 0x18uLL);
    __s[0] = ostream;
    uint64_t v8 = v8;
    __int128 v13 = (void ***)calloc(v8, 8uLL);
    if (v13)
    {
      uint64_t v14 = v13;
      if ((_DWORD)v8)
      {
        AAFlagSet v15 = (AAByteStream **)v13;
        uint64_t v16 = v8;
        while (1)
        {
          unint64_t v17 = (AAByteStream *)malloc(0x38uLL);
          if (!v17)
          {
            int v75 = *__error();
            __int16 v78 = 125;
            goto LABEL_58;
          }

          uint64_t v18 = v17;
          memset_s(v17, 0x38uLL, 0, 0x38uLL);
          *AAFlagSet v15 = v18;
          v18[1] = (AAByteStream)block_size;
          v18[2] = 0LL;
          *uint64_t v18 = istream;
          if (block_size >= 0x2000000001LL) {
            break;
          }
          uint64_t v19 = (AAByteStream_impl *)malloc(block_size);
          v18[3] = v19;
          if (!v19) {
            goto LABEL_57;
          }
          ++v15;
          if (!--v16) {
            goto LABEL_12;
          }
        }

        *__error() = 12;
        v18[3] = 0LL;
LABEL_57:
        int v75 = *__error();
        __int16 v78 = 131;
LABEL_58:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"processSequential",  v78,  89,  v75,  "malloc",  v76,  v77,  v89);
        int v27 = 0LL;
      }

      else
      {
LABEL_12:
        int v27 = ThreadPipelineCreate( v8,  (uint64_t)v14,  (uint64_t)sequentialReaderProc,  (uint64_t)__s,  (uint64_t)sequentialWriterProc,  0LL);
        if (v27)
        {
          off_t v28 = 0LL;
          else {
            off_t v29 = max_offset;
          }
          while (1)
          {
            unsigned int v30 = atomic_load(&v93);
            if (v30
              || (unsigned int v31 = atomic_load(&v92)) != 0
              || ((uint64_t)(v28 + block_size) >= v29 ? (off_t v32 = v29) : (off_t v32 = v28 + block_size), v32 < v28))
            {
              char v73 = 0;
              goto LABEL_65;
            }

            uint64_t Worker = ThreadPipelineGetWorker((uint64_t)v27, v20, v21, v22, v23, v24, v25, v26);
            if (!Worker) {
              break;
            }
            *(void *)(Worker + 32) = v32 - v28;
            *(void *)(Worker + 40) = v28;
            off_t v28 = v32;
            if ((ThreadPipelineRunWorker((uint64_t)v27, Worker, v34, v35, v36, v37, v25, v26) & 0x80000000) != 0)
            {
              uint64_t v38 = "running task";
              __int16 v39 = 158;
              goto LABEL_63;
            }
          }

          uint64_t v38 = "allocating reader";
          __int16 v39 = 153;
        }

        else
        {
          uint64_t v38 = "ThreadPipelineCreate";
          __int16 v39 = 136;
        }

LABEL_72:
  ThreadPoolDestroy((uint64_t)v54);
  off_t v85 = 0LL;
  if ((_DWORD)v40)
  {
    uint64_t v86 = v46;
    do
    {
      uint64_t v87 = *v86++;
      v85 += *(void *)(v87 + 48);
      free(*(void **)(v87 + 24));
      free((void *)v87);
      --v40;
    }

    while (v40);
  }

  free(v46);
  if ((v74 & 1) != 0) {
    return -1LL;
  }
  return v85;
}

        uint64_t v60 = a2;
        uint64_t v62 = v36;
        uint64_t v45 = *v36;
        uint64_t v46 = realloc(*v36, a2);
        if (v46)
        {
          v12[277] = v46;
          v12[276] = v60;
          goto LABEL_74;
        }

        free(v45);
LABEL_114:
        AAByteStream_impl *v62 = 0LL;
        *uint64_t v34 = 0LL;
        v12[276] = 0LL;
        goto LABEL_115;
      }

          uint64_t v35 = (void *)v17[2];
          uint64_t v36 = realloc(v35, v27);
          if (v36)
          {
            v17[1] = v27;
            v17[2] = v36;
            goto LABEL_74;
          }

          free(v35);
LABEL_84:
          v17[1] = 0LL;
          v17[2] = 0LL;
          *unint64_t v17 = 0LL;
        }
      }

      uint64_t v18 = "blob append";
      uint64_t v19 = 357;
    }

    else
    {
      uint64_t v18 = "invalid blob size";
      uint64_t v19 = 356;
    }

    goto LABEL_86;
  }

  return result;
}

uint64_t sequentialReaderProc(uint64_t a1)
{
  *(void *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 48) = 0;
  size_t v2 = *(void *)(a1 + 32);
  if (v2 <= *(void *)(a1 + 8))
  {
    if (!v2) {
      return 0LL;
    }
    ssize_t v3 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v2, *(void *)(a1 + 40));
    if ((v3 & 0x8000000000000000LL) == 0)
    {
      ssize_t v6 = v3;
      uint64_t result = 0LL;
      *(void *)(a1 + 16) = v6;
      return result;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"sequentialReaderProc",  49,  89,  0,  "PRead",  v4,  v5,  v8);
  }

  *(_DWORD *)(a1 + 48) = 1;
  return 0xFFFFFFFFLL;
}

uint64_t sequentialWriterProc(uint64_t a1, uint64_t a2)
{
  size_t v2 = (unsigned int *)(a1 + 20);
  if (*(_DWORD *)(a2 + 48)) {
    goto LABEL_4;
  }
  size_t v7 = *(void *)(a2 + 16);
  if (v7)
  {
    char v8 = *(char **)(a2 + 24);
    while (1)
    {
      ssize_t v9 = AAByteStreamWrite(*(AAByteStream *)a1, v8, v7);
      if (v9 <= 0) {
        break;
      }
      v8 += v9;
      *(void *)(a1 + 8) += v9;
      v7 -= v9;
      if (!v7) {
        return 0LL;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"sequentialWriterProc",  87,  89,  0,  "Write failed",  v10,  v11,  v12);
LABEL_4:
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_5;
  }

  uint64_t result = 0LL;
  size_t v2 = (unsigned int *)(a1 + 16);
  do
  {
LABEL_5:
    if (__ldaxr(v2))
    {
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v2));
  return result;
}

uint64_t randomAccessWorkerProc(uint64_t a1)
{
  size_t v4 = *(void *)(a1 + 56);
  if (v4 > *(void *)(a1 + 16))
  {
LABEL_17:
    __int128 v13 = *(unsigned int **)(a1 + 32);
    while (!__ldaxr(v13))
    {
      if (!__stlxr(1u, v13)) {
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  if (!v4) {
    return 0LL;
  }
  ssize_t v5 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v4, *(void *)(a1 + 64));
  if (v5 < 0)
  {
    ssize_t v9 = "PRead";
    __int16 v10 = 207;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c",  (uint64_t)"randomAccessWorkerProc",  v10,  89,  0,  v9,  v6,  v7,  v15);
    goto LABEL_17;
  }

  ssize_t v8 = v5;
  if (v5)
  {
    if (AAByteStreamPWrite(*(AAByteStream *)(a1 + 8), *(const void **)(a1 + 24), v5, *(void *)(a1 + 64)) == v5)
    {
      uint64_t result = 0LL;
      *(void *)(a1 + 48) += v8;
      return result;
    }

    ssize_t v9 = "Write";
    __int16 v10 = 219;
    goto LABEL_16;
  }

  uint64_t v11 = *(unsigned int **)(a1 + 40);
  uint64_t result = 0LL;
  while (!__ldaxr(v11))
  {
    if (!__stlxr(1u, v11)) {
      return result;
    }
  }

  uint64_t result = 0LL;
  __clrex();
  return result;
}

void *AEADecryptionDirectRandomAccessInputStreamOpen( AAByteStream_impl *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 <= 0) {
    getDefaultNThreads();
  }
  if (!*(_DWORD *)(a2 + 2736) || !*(void *)(a2 + 2728))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c",  (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen",  148,  122,  0,  "Invalid context",  a7,  a8,  v25);
    __int128 v13 = 0LL;
    uint64_t v11 = 0LL;
LABEL_17:
    BlockDecryptionStreamClose(v13);
    free(v11);
    return 0LL;
  }

  uint64_t v11 = calloc(1uLL, 0x68uLL);
  char v12 = (uint64_t *)malloc(0x30uLL);
  __int128 v13 = v12;
  if (!v12 || (memset_s(v12, 0x30uLL, 0, 0x30uLL), !v11))
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 153;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c",  (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen",  v23,  122,  v21,  v22,  v15,  v16,  v25);
    goto LABEL_17;
  }

  *__int128 v13 = (uint64_t)a1;
  v13[1] = a3;
  if ((a3 & 0x400000000000000LL) != 0) {
    *(_DWORD *)(a2 + 2740) = 1;
  }
  uint64_t Existing = aeaContainerCreateExisting(a2, a1, 1, 0);
  v13[2] = Existing;
  if (!Existing)
  {
    uint64_t v22 = "unlock container";
    __int16 v23 = 166;
    int v21 = 0;
    goto LABEL_16;
  }

  if (*(_DWORD *)(Existing + 24))
  {
    compression_algorithm v17 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(Existing + 24));
    v13[3] = compression_decode_scratch_buffer_size(v17);
    uint64_t Existing = v13[2];
  }

  void *v11 = v13;
  v11[1] = BlockDecryptionStreamClose;
  v11[7] = BlockDecryptionStreamCancel;
  v11[4] = BlockDecryptionStreamPRead;
  v11[2] = BlockDecryptionStreamRead;
  *(_OWORD *)a2 = *(_OWORD *)Existing;
  __int128 v18 = *(_OWORD *)(Existing + 16);
  __int128 v19 = *(_OWORD *)(Existing + 32);
  __int128 v20 = *(_OWORD *)(Existing + 48);
  *(void *)(a2 + 64) = *(void *)(Existing + 64);
  *(_OWORD *)(a2 + 32) = v19;
  *(_OWORD *)(a2 + 48) = v20;
  *(_OWORD *)(a2 + 16) = v18;
  return v11;
}

uint64_t BlockDecryptionStreamClose(uint64_t *a1)
{
  if (a1)
  {
    aeaContainerDestroy(a1[2]);
    free(a1);
  }

  return 0LL;
}

void BlockDecryptionStreamCancel(AAByteStream *a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 4);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }

  __clrex();
}

uint64_t BlockDecryptionStreamPRead( uint64_t a1, uint8_t *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 & 0x8000000000000000LL) != 0)
  {
    ssize_t v9 = "negative offset";
    __int16 v10 = 55;
    goto LABEL_6;
  }

  unint64_t v8 = a4;
  if (__CFADD__(a4, a3))
  {
    ssize_t v9 = "invalid request";
    __int16 v10 = 59;
LABEL_6:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c",  (uint64_t)"BlockDecryptionStreamPRead",  v10,  122,  0,  v9,  a7,  a8,  v40);
    uint64_t v11 = 0LL;
    char v12 = 0LL;
    __int128 v13 = 0LL;
    uint64_t v14 = -1LL;
    goto LABEL_47;
  }

  uint64_t v16 = *(void *)(a1 + 16);
  unint64_t v17 = *(void *)(v16 + 32);
  if (v17 <= a4) {
    goto LABEL_46;
  }
  if (a4 + a3 < v17) {
    unint64_t v17 = a4 + a3;
  }
  if (v17 <= a4)
  {
LABEL_46:
    uint64_t v14 = 0LL;
    uint64_t v11 = 0LL;
    char v12 = 0LL;
    __int128 v13 = 0LL;
    goto LABEL_47;
  }

  uint64_t v14 = 0LL;
  __int128 v13 = 0LL;
  char v12 = 0LL;
  uint64_t v11 = 0LL;
  int v42 = *(_DWORD *)(v16 + 24);
  size_t v19 = *(unsigned int *)(v16 + 16);
  unint64_t v41 = v17;
  __uint64_t size = v19;
  while (1)
  {
    __int128 v20 = v12;
    size_t v21 = v8 / v19;
    uint64_t v22 = *(void *)(a1 + 16);
    if (v8 / v19 >= *(unsigned int *)(v22 + 400))
    {
      uint64_t v36 = v13;
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDe cryptionStream.c",  (uint64_t)"BlockDecryptionStreamPRead",  69,  122,  0,  "invalid state",  a7,  a8,  v40);
      __int128 v13 = v36;
LABEL_50:
      uint64_t v14 = -1LL;
      char v12 = (uint8_t *)v20;
      goto LABEL_47;
    }

    size_t v23 = v21 * v19;
    uint64_t v24 = *(unsigned int *)(*(void *)(v22 + 392) + 544 * v21 + 4);
    size_t v25 = v21 * v19 + v24;
    if (v8 <= v23) {
      size_t v26 = v23;
    }
    else {
      size_t v26 = v8;
    }
    if (v25 >= v17) {
      size_t v25 = v17;
    }
    size_t v43 = v26;
    size_t v27 = v25 - v26;
    BOOL v28 = v23 >= v8 && v27 == v24;
    char v29 = v28;
    char v45 = v29;
    if (v28)
    {
      uint64_t v47 = a2;
      goto LABEL_29;
    }

    uint64_t v47 = v13;
    if (!v13)
    {
      __int128 v13 = (uint8_t *)malloc(__size);
      uint64_t v47 = v13;
      if (!v13)
      {
        uint64_t v37 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccess DecryptionStream.c",  (uint64_t)"BlockDecryptionStreamPRead",  93,  122,  *v37,  "malloc",  v38,  v39,  v40);
        __int128 v13 = 0LL;
        goto LABEL_50;
      }
    }

uint64_t BlockDecryptionStreamRead( uint64_t a1, uint8_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = (unint64_t *)(a1 + 40);
  do
    unint64_t v9 = __ldaxr(v8);
  while (__stlxr(v9 + a3, v8));
  return BlockDecryptionStreamPRead(a1, a2, a3, v9, a5, a6, a7, a8);
}

uint64_t ECC65537GetParity(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (a1 > 0x1FFE0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = (a1 & 1) + a1;
  if (v4)
  {
    int8x16_t v5 = 0uLL;
    int8x8_t v6 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16( (int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G),  (int16x8_t)vceqzq_s32(unk_1862D7950))));
    int8x16_t v7 = vmvnq_s8((int8x16_t)vuzp1q_s16( (int16x8_t)vceqzq_s32((int32x4_t)xmmword_1862D7960),  (int16x8_t)vceqzq_s32((int32x4_t)qword_1862D7970)));
    v8.i64[0] = 0xFFFF0000FFFFLL;
    v8.i64[1] = 0xFFFF0000FFFFLL;
    v9.i64[0] = 0x1000000010000LL;
    v9.i64[1] = 0x1000000010000LL;
    v10.i64[0] = 0x100000001LL;
    v10.i64[1] = 0x100000001LL;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
    do
    {
      uint64_t v14 = v4 - 2;
      if (v4 <= a1) {
        __int32 v15 = *(unsigned __int16 *)(a2 + v14);
      }
      else {
        __int32 v15 = *(unsigned __int8 *)(a2 + v14);
      }
      int32x4_t v16 = (int32x4_t)vextq_s8(v12, (int8x16_t)v13, 0xCuLL);
      int32x4_t v17 = (int32x4_t)vextq_s8(v11, v12, 0xCuLL);
      int32x4_t v18 = (int32x4_t)vextq_s8(qword_1862D7970, v5, 0xCuLL);
      int32x4_t v19 = vdupq_laneq_s32(v13, 3);
      v18.i32[0] = v15;
      int32x4_t v20 = (int32x4_t)vextq_s8(v5, v11, 0xCuLL);
      int32x4_t v21 = vmulq_laneq_s32((int32x4_t)xmmword_1862D7960, v13, 3);
      int32x4_t v22 = vmulq_laneq_s32((int32x4_t)qword_1862D7970, v13, 3);
      int32x4_t v23 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v13, 3);
      int32x4_t v24 = vmulq_laneq_s32(unk_1862D7950, v13, 3);
      int16x8_t v25 = (int16x8_t)vceqzq_s32(v19);
      int8x16_t v26 = (int8x16_t)vuzp1q_s16(v25, v25);
      int8x8_t v27 = vmovn_s16((int16x8_t)vmvnq_s8(v26));
      int8x8_t v28 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v23), (int16x8_t)vceqzq_s32(v24)));
      int8x16_t v29 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v21), (int16x8_t)vceqzq_s32(v22));
      int8x16_t v30 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v22, v8),  (int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x10uLL));
      int8x16_t v31 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v21, v8),  (int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x10uLL));
      int8x16_t v32 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v24, v8),  (int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x10uLL));
      int8x16_t v33 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v23, v8),  (int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x10uLL));
      *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v7, v26), v29));
      int32x4_t v34 = (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8( *(int8x8_t *)v26.i8,  (int8x8_t)0xB4200003C1CLL)),  0x1FuLL)),  v10,  vorrq_s8( vandq_s8(v30, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v30)),  (int8x16_t)vqsubq_u32((uint32x4_t)v30, v9)));
      int32x4_t v35 = (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8( *(int8x8_t *)v26.i8,  (int8x8_t)0xB4200003C1CLL)),  0x1FuLL)),  v10,  vorrq_s8( vandq_s8(v31, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v31)),  (int8x16_t)vqsubq_u32((uint32x4_t)v31, v9)));
      *(int8x8_t *)v26.i8 = vand_s8(vand_s8(v6, v28), v27);
      int8x16_t v36 = (int8x16_t)vsubq_s32( v18,  (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8( *(int8x8_t *)v26.i8,  (int8x8_t)0xB4200003C1CLL)),  0x1FuLL)),  v10,  vorrq_s8( vandq_s8(v33, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v33)),  (int8x16_t)vqsubq_u32((uint32x4_t)v33, v9))));
      int8x16_t v37 = (int8x16_t)vsubq_s32( v20,  (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8( *(int8x8_t *)v26.i8,  (int8x8_t)0xB4200003C1CLL)),  0x1FuLL)),  v10,  vorrq_s8( vandq_s8(v32, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v32)),  (int8x16_t)vqsubq_u32((uint32x4_t)v32, v9))));
      int8x16_t v38 = (int8x16_t)vsubq_s32(v17, v35);
      int8x16_t v39 = (int8x16_t)vsubq_s32(v16, v34);
      int32x4_t v13 = (int32x4_t)vorrq_s8( vandq_s8(v39, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v39)),  (int8x16_t)vqsubq_u32((uint32x4_t)v39, v9));
      int8x16_t v12 = vorrq_s8( vandq_s8(v38, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v38)),  (int8x16_t)vqsubq_u32((uint32x4_t)v38, v9));
      int8x16_t v11 = vorrq_s8( vandq_s8(v37, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v37)),  (int8x16_t)vqsubq_u32((uint32x4_t)v37, v9));
      int8x16_t v5 = vorrq_s8( vandq_s8(v36, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v36)),  (int8x16_t)vqsubq_u32((uint32x4_t)v36, v9));
      unsigned int v4 = v14;
    }

    while ((_DWORD)v14);
  }

  else
  {
    int8x16_t v5 = 0uLL;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
  }

  uint64_t v40 = 0LL;
  int v41 = 0;
  v44[0] = v5;
  v44[1] = v11;
  size_t v44[2] = v12;
  v44[3] = v13;
  do
  {
    int v42 = *((_DWORD *)v44 + v40);
    if (v42) {
      int v43 = 65537 - v42;
    }
    else {
      int v43 = 0;
    }
    v41 |= (1 << v40) & (v43 << 15 >> 31);
    *(_WORD *)(a3 + 2 * v40++) = v43;
  }

  while (v40 != 16);
  uint64_t result = 0LL;
  *(_WORD *)(a3 + 32) = v41;
  return result;
}

uint64_t ECC65537CheckAndFix(unsigned int a1, uint64_t a2, uint16x8_t *a3, _DWORD *a4)
{
  uint64_t v118 = *MEMORY[0x1895F89C0];
  int8x16_t v7 = 0uLL;
  unsigned int v8 = (a1 & 1) + a1;
  if (v8)
  {
    int8x16_t v9 = 0uLL;
    int8x8_t v10 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16( (int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G),  (int16x8_t)vceqzq_s32(unk_1862D7950))));
    int8x16_t v11 = vmvnq_s8((int8x16_t)vuzp1q_s16( (int16x8_t)vceqzq_s32((int32x4_t)xmmword_1862D7960),  (int16x8_t)vceqzq_s32((int32x4_t)qword_1862D7970)));
    v12.i64[0] = 0xFFFF0000FFFFLL;
    v12.i64[1] = 0xFFFF0000FFFFLL;
    v13.i64[0] = 0x1000000010000LL;
    v13.i64[1] = 0x1000000010000LL;
    v14.i64[0] = 0x100000001LL;
    v14.i64[1] = 0x100000001LL;
    unsigned int v15 = (a1 & 1) + a1;
    int8x16_t v16 = 0uLL;
    int8x16_t v17 = 0uLL;
    int32x4_t v18 = 0uLL;
    do
    {
      uint64_t v19 = v15 - 2;
      if (v15 <= a1) {
        __int32 v20 = *(unsigned __int16 *)(a2 + v19);
      }
      else {
        __int32 v20 = *(unsigned __int8 *)(a2 + v19);
      }
      int32x4_t v21 = (int32x4_t)vextq_s8(v17, (int8x16_t)v18, 0xCuLL);
      int32x4_t v22 = (int32x4_t)vextq_s8(v16, v17, 0xCuLL);
      int32x4_t v23 = (int32x4_t)vextq_s8((int8x16_t)0LL, v9, 0xCuLL);
      int32x4_t v24 = vdupq_laneq_s32(v18, 3);
      v23.i32[0] = v20;
      int32x4_t v25 = (int32x4_t)vextq_s8(v9, v16, 0xCuLL);
      int32x4_t v26 = vmulq_laneq_s32((int32x4_t)xmmword_1862D7960, v18, 3);
      int32x4_t v27 = vmulq_laneq_s32((int32x4_t)qword_1862D7970, v18, 3);
      int32x4_t v28 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v18, 3);
      int32x4_t v29 = vmulq_laneq_s32(unk_1862D7950, v18, 3);
      int16x8_t v30 = (int16x8_t)vceqzq_s32(v24);
      int8x16_t v31 = (int8x16_t)vuzp1q_s16(v30, v30);
      int8x8_t v32 = vmovn_s16((int16x8_t)vmvnq_s8(v31));
      int8x8_t v33 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v28), (int16x8_t)vceqzq_s32(v29)));
      int8x16_t v34 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v26), (int16x8_t)vceqzq_s32(v27));
      int8x16_t v35 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v27, v12),  (int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x10uLL));
      int8x16_t v36 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v26, v12),  (int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x10uLL));
      int8x16_t v37 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v29, v12),  (int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL));
      int8x16_t v38 = (int8x16_t)vsubq_s32( (int32x4_t)vandq_s8((int8x16_t)v28, v12),  (int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL));
      *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v11, v31), v34));
      int32x4_t v39 = (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0LL)),  0x1FuLL)),  v14,  vorrq_s8( vandq_s8(v35, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v35)),  (int8x16_t)vqsubq_u32((uint32x4_t)v35, v13)));
      int32x4_t v40 = (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0LL)),  0x1FuLL)),  v14,  vorrq_s8( vandq_s8(v36, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v36)),  (int8x16_t)vqsubq_u32((uint32x4_t)v36, v13)));
      *(int8x8_t *)v31.i8 = vand_s8(vand_s8(v10, v33), v32);
      int8x16_t v41 = (int8x16_t)vsubq_s32( v23,  (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0LL)),  0x1FuLL)),  v14,  vorrq_s8( vandq_s8(v38, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v38)),  (int8x16_t)vqsubq_u32((uint32x4_t)v38, v13))));
      int8x16_t v42 = (int8x16_t)vsubq_s32( v25,  (int32x4_t)vbslq_s8( (int8x16_t)vcltzq_s32( vshlq_n_s32( (int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0LL)),  0x1FuLL)),  v14,  vorrq_s8( vandq_s8(v37, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v37)),  (int8x16_t)vqsubq_u32((uint32x4_t)v37, v13))));
      int8x16_t v43 = (int8x16_t)vsubq_s32(v22, v40);
      int8x16_t v44 = (int8x16_t)vsubq_s32(v21, v39);
      int32x4_t v18 = (int32x4_t)vorrq_s8( vandq_s8(v44, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v44)),  (int8x16_t)vqsubq_u32((uint32x4_t)v44, v13));
      int8x16_t v17 = vorrq_s8( vandq_s8(v43, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v43)),  (int8x16_t)vqsubq_u32((uint32x4_t)v43, v13));
      int8x16_t v16 = vorrq_s8( vandq_s8(v42, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v42)),  (int8x16_t)vqsubq_u32((uint32x4_t)v42, v13));
      int8x16_t v9 = vorrq_s8( vandq_s8(v41, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v41)),  (int8x16_t)vqsubq_u32((uint32x4_t)v41, v13));
      unsigned int v15 = v19;
    }

    while ((_DWORD)v19);
  }

  else
  {
    int8x16_t v9 = 0uLL;
    int8x16_t v16 = 0uLL;
    int8x16_t v17 = 0uLL;
    int32x4_t v18 = 0uLL;
  }

  uint64_t v45 = 0LL;
  v117[0] = v9;
  v117[1] = v16;
  v117[2] = v17;
  v117[3] = v18;
  int32x4_t v46 = (int32x4_t)xmmword_1862D78F0;
  int8x16_t v47 = (int8x16_t)vdupq_n_s32(a3[2].u16[0]);
  int32x4_t v48 = (int32x4_t)xmmword_1862D7900;
  v49.i64[0] = 0x100000001LL;
  v49.i64[1] = 0x100000001LL;
  v50.i64[0] = 0x1000000010000LL;
  v50.i64[1] = 0x1000000010000LL;
  v51.i64[0] = 0x800000008LL;
  v51.i64[1] = 0x800000008LL;
  int8x16_t v52 = 0uLL;
  do
  {
    uint16x8_t v53 = *a3++;
    int8x16_t v54 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8);
    int8x16_t v55 = (int8x16_t)vmovl_high_u16(v53);
    off_t v56 = (int8x16_t *)&v117[v45];
    int32x4_t v57 = vaddq_s32( (int32x4_t)vbslq_s8( (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v46), v47)),  v55,  (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x1000000010000LL, 0x1000000010000LL))),  (int32x4_t)v117[v45 + 1]);
    int32x4_t v58 = vaddq_s32( (int32x4_t)vbslq_s8( (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v48), v47)),  v54,  (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x1000000010000LL, 0x1000000010000LL))),  (int32x4_t)v117[v45]);
    int8x16_t v59 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v57, v50), (uint32x4_t)v57);
    int8x16_t v60 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v58, v50), (uint32x4_t)v58);
    *off_t v56 = v60;
    v56[1] = v59;
    int8x16_t v52 = vorrq_s8(v59, v52);
    int8x16_t v7 = vorrq_s8(v60, v7);
    int32x4_t v48 = vaddq_s32(v48, v51);
    int32x4_t v46 = vaddq_s32(v46, v51);
    v45 += 2LL;
  }

  while (v45 != 4);
  int8x16_t v61 = vorrq_s8(v7, v52);
  if (vorr_s8(*(int8x8_t *)v61.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)))
  {
    uint64_t v62 = (int *)calloc(1uLL, 0x4C0uLL);
    if (v62)
    {
      uint64_t v63 = v62;
      uint64_t v64 = 0LL;
      unsigned int v65 = v8 >> 1;
      int v66 = 1;
      do
      {
        v63[v64] = ecc65537PolyEval(16, (uint64_t)v117, v66);
        unsigned int v67 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        if (v67 + 65537 >= v67) {
          int v66 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        }
        else {
          int v66 = v67 + 65537;
        }
        ++v64;
      }

      while (v64 != 16);
      uint64_t v115 = a4;
      uint64_t v68 = 0LL;
      uint64_t v69 = 48LL;
      do
      {
        AAByteStream v70 = &v63[v69];
        __int128 v71 = *(_OWORD *)&v63[v68];
        __int128 v72 = *(_OWORD *)&v63[v68 + 4];
        v70[8] = v63[v68 + 8];
        *(_OWORD *)AAByteStream v70 = v71;
        *((_OWORD *)v70 + 1) = v72;
        v69 += 16LL;
        ++v68;
      }

      while (v68 != 8);
      int v73 = ecc65537Triangulate(8LL, 9, (uint64_t)(v63 + 48));
      if (v73 >= 1)
      {
        int v74 = v73;
        if ((ecc65537Solve(v73, v63 + 48, (uint64_t)(v63 + 16)) & 0x80000000) == 0)
        {
          uint64_t v114 = v63 + 48;
          unsigned int v75 = v74;
          int v76 = 0;
          int v77 = 0;
          unsigned int v116 = v75;
          int v78 = v75 + 1;
          unsigned int v79 = v65 + 16;
          int v80 = 1;
          do
          {
            if (!ecc65537PolyEval(v78, (uint64_t)(v63 + 16), v80) && v77 <= 7)
            {
              uint64_t v81 = &v63[v77++];
              v81[32] = v76;
            }

            unsigned int v82 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            if (v82 + 65537 >= v82) {
              int v80 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            }
            else {
              int v80 = v82 + 65537;
            }
            ++v76;
          }

          while (v79 != v76);
          if (v77 == v116)
          {
            uint64_t v83 = 0LL;
            uint64_t v84 = v116;
            do
            {
              uint64_t v85 = 0LL;
              uint64_t v86 = (16 * v83);
              do
              {
                int v87 = v63[v85 + 32] * v83;
                if (v87)
                {
                  int v88 = 3;
                  if (v87 < 0)
                  {
                    int v88 = ecc65537Inv(3LL);
                    int v87 = -v87;
                  }

                  unsigned int v89 = (unsigned __int16)v87;
                  unsigned int v90 = 1;
                  while (1)
                  {
                    if ((v89 & 1) != 0)
                    {
                      if (v88 && v90 && !(v90 * v88))
                      {
                        unsigned int v90 = 1;
                      }

                      else
                      {
                        unsigned int v90 = (unsigned __int16)(v90 * v88) - ((v90 * v88) >> 16);
                        if (v90 + 65537 < v90) {
                          v90 += 65537;
                        }
                      }
                    }

                    if (v89 < 2) {
                      break;
                    }
                    v89 >>= 1;
                    unsigned int v91 = v88 * v88;
                    if (v88)
                    {
                      int v88 = 1;
                      if (!v91) {
                        continue;
                      }
                    }

                    unsigned int v92 = (unsigned __int16)v91 - HIWORD(v91);
                    if (v92 + 65537 >= v92) {
                      int v88 = v92;
                    }
                    else {
                      int v88 = v92 + 65537;
                    }
                  }
                }

                else
                {
                  unsigned int v90 = 1;
                }

                v63[v85 + 48 + v86] = v90;
                ++v85;
              }

              while (v85 != v116);
              int v93 = v63[v83];
              if (v93) {
                int v94 = 65537 - v93;
              }
              else {
                int v94 = 0;
              }
              v63[(int)(v86 + v116) + 48] = v94;
              ++v83;
            }

            while (v83 != v116);
            if (ecc65537Triangulate(v116, v78, (uint64_t)v114) == v116)
            {
              uint64_t v95 = v63 + 40;
              if ((ecc65537Solve(v116, v114, (uint64_t)(v63 + 40)) & 0x80000000) == 0)
              {
                uint64_t v97 = 0LL;
                int v98 = 0;
                while (1)
                {
                  int v99 = *(v95 - 8);
                  if (a1 > 2 * v99)
                  {
                    uint64_t v100 = (2 * v99);
                    BOOL v101 = (int)v100 + 2 <= a1 || a1 - (_DWORD)v100 == 2;
                    int v102 = v101;
                    if (v101) {
                      int v103 = *(unsigned __int16 *)(a2 + v100);
                    }
                    else {
                      int v103 = *(unsigned __int8 *)(a2 + v100);
                    }
                    unsigned int v104 = v103 - *v95;
                    if (v104 + 65537 < v104) {
                      v104 += 65537;
                    }
                    if (HIWORD(v104)) {
                      goto LABEL_85;
                    }
                    int v105 = v104 ^ v103;
                    v96.i32[0] = v105;
                    int8x8_t v96 = vcnt_s8(v96);
                    v96.i16[0] = vaddlv_u8((uint8x8_t)v96);
                    v98 += v96.i32[0];
                    if ((_BYTE)v105) {
                      unsigned int v106 = v97 + 1;
                    }
                    else {
                      unsigned int v106 = v97;
                    }
                    if ((v105 & 0xFF00) != 0) {
                      uint64_t v97 = v106 + 1;
                    }
                    else {
                      uint64_t v97 = v106;
                    }
                    if (v102) {
                      *(_WORD *)(a2 + v100) = v104;
                    }
                    else {
                      *(_BYTE *)(a2 + v100) = v104;
                    }
                  }

                  ++v95;
                  uint64_t v107 = v97;
                  if (!--v84) {
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }

      int v98 = 0;
      LODWORD(v97) = 0;
LABEL_85:
      uint64_t v107 = 0xFFFFFFFFLL;
LABEL_86:
      free(v63);
      if (v115 && (v107 & 0x80000000) == 0)
      {
        int v108 = v115[1] + v97;
        *v115 += v98;
        v115[1] = v108;
      }
    }

    else
    {
      uint64_t v109 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection_ECC65537.c",  (uint64_t)"ECC65537CheckAndFix",  423,  63,  *v109,  "malloc",  v110,  v111,  v113);
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    return 0LL;
  }

  return v107;
}

uint64_t ecc65537PolyEval(int a1, uint64_t a2, int a3)
{
  if (a1 < 1) {
    return 0LL;
  }
  LODWORD(result) = 0;
  unint64_t v5 = a1 + 1LL;
  do
  {
    if (a3 && (_DWORD)result && !((_DWORD)result * a3))
    {
      unsigned int v6 = 1;
    }

    else
    {
      unsigned int v6 = (unsigned __int16)(result * a3) - ((result * a3) >> 16);
      if (v6 + 65537 < v6) {
        v6 += 65537;
      }
    }

    unsigned int v7 = v6 + *(_DWORD *)(a2 + 4LL * (v5 - 2));
    if (v7 - 65537 >= v7) {
      uint64_t result = v7;
    }
    else {
      uint64_t result = v7 - 65537;
    }
    --v5;
  }

  while (v5 > 1);
  return result;
}

uint64_t ecc65537Triangulate(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v3 = 0;
  uint64_t v4 = 0LL;
  int v5 = 0;
  LODWORD(v6) = 0;
  int v7 = 16;
  uint64_t v8 = 1LL;
  while (1)
  {
    if (v5 >= a2)
    {
      LODWORD(v11) = v6;
    }

    else
    {
      unsigned int v9 = v5 + v3;
LABEL_5:
      unsigned int v10 = v9;
      uint64_t v11 = v4;
      while (!*(_DWORD *)(a3 + 4LL * (int)v10))
      {
        ++v11;
        v10 += 16;
        if (a1 == v11)
        {
          ++v5;
          ++v9;
          if (v5 != a2) {
            goto LABEL_5;
          }
          return v4;
        }
      }
    }

    uint64_t v6 = v4;
    if (v5 == a2) {
      return v6;
    }
    if (v4 == v11 || a2 <= 0)
    {
      int v12 = 16 * v4;
    }

    else
    {
      int v12 = 16 * v4;
      uint32x4_t v13 = (int *)(a3 + 64LL * (_DWORD)v11);
      uint64_t v14 = a2;
      unsigned int v15 = v3;
      do
      {
        int v16 = *v13;
        *v13++ = *(_DWORD *)(a3 + 4LL * v15);
        *(_DWORD *)(a3 + 4LL * v15++) = v16;
        --v14;
      }

      while (v14);
    }

    if (++v4 < (unint64_t)a1)
    {
      int v17 = *(_DWORD *)(a3 + 4LL * (v12 + v5));
      uint64_t v18 = v5 + 1;
      uint64_t v19 = (int *)(a3 + 4 * (v12 + v18));
      int v20 = v7;
      uint64_t v21 = v8;
      do
      {
        int v22 = v5 + 16 * v21;
        int v23 = *(_DWORD *)(a3 + 4LL * v22);
        if (v23)
        {
          *(_DWORD *)(a3 + 4LL * v22) = 0;
          if ((int)v18 < a2)
          {
            int32x4_t v24 = (_WORD *)(a3 + 4 * (v18 + v20));
            int v25 = a2 - 1 - v5;
            int32x4_t v26 = v19;
            do
            {
              if (v17 && (*(_DWORD *)v24 ? (BOOL v27 = *(_DWORD *)v24 * v17 == 0) : (BOOL v27 = 0), v27))
              {
                unsigned int v28 = 1;
              }

              else
              {
                unsigned int v28 = (unsigned __int16)(*v24 * v17) - ((*(_DWORD *)v24 * v17) >> 16);
                if (v28 + 65537 < v28) {
                  v28 += 65537;
                }
              }

              int v30 = *v26++;
              int v29 = v30;
              int v31 = v30 * v23;
              unsigned int v32 = (unsigned __int16)(v30 * v23) - ((v30 * v23) >> 16);
              if (v32 + 65537 < v32) {
                v32 += 65537;
              }
              if (v29) {
                BOOL v33 = v31 == 0;
              }
              else {
                BOOL v33 = 0;
              }
              if (v33) {
                int v34 = 1;
              }
              else {
                int v34 = v32;
              }
              unsigned int v35 = v28 - v34;
              if (v35 + 65537 < v35) {
                v35 += 65537;
              }
              *(_DWORD *)int32x4_t v24 = v35;
              v24 += 2;
              --v25;
            }

            while (v25);
          }
        }

        ++v21;
        v20 += 16;
      }

      while (v21 != a1);
    }

    ++v8;
    v3 += 16;
    v7 += 16;
  }

uint64_t ecc65537Solve(int a1, int *a2, uint64_t a3)
{
  if (!a1) {
    return 0LL;
  }
  if (a1 <= 0)
  {
    uint64_t v24 = 0LL;
    *(_DWORD *)(a3 + 4LL * a1) = 1;
  }

  else
  {
    uint64_t v5 = a1;
    uint64_t v6 = a2;
    do
    {
      int v7 = *v6;
      v6 += 17;
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
      --v5;
    }

    while (v5);
    *(_DWORD *)(a3 + 4LL * a1) = 1;
    uint64_t v8 = a1;
    int v9 = 16 * a1 - 16;
    uint64_t v10 = a1;
    do
    {
      if (v10 <= v8)
      {
        unsigned int v11 = 0;
        uint64_t v12 = v8;
        do
        {
          int v13 = *(_DWORD *)(a3 + 4LL * v12);
          int v14 = a2[v9 + v12];
          if (v13) {
            BOOL v15 = v14 == 0;
          }
          else {
            BOOL v15 = 1;
          }
          if (!v15 && v14 * v13 == 0)
          {
            unsigned int v17 = 1;
          }

          else
          {
            unsigned int v17 = (unsigned __int16)(v14 * v13) - ((v14 * v13) >> 16);
            if (v17 + 65537 < v17) {
              v17 += 65537;
            }
          }

          unsigned int v18 = v17 + v11;
          if (v18 - 65537 >= v18) {
            unsigned int v11 = v18;
          }
          else {
            unsigned int v11 = v18 - 65537;
          }
          BOOL v19 = v12-- <= v10;
        }

        while (!v19);
      }

      else
      {
        unsigned int v11 = 0;
      }

      int v20 = ecc65537Inv(a2[17 * v10 - 17]);
      if (v11 && (v20 ? (BOOL v21 = v20 * v11 == 0) : (BOOL v21 = 0), v21))
      {
        unsigned int v22 = 1;
      }

      else
      {
        unsigned int v22 = (unsigned __int16)(v20 * v11) - ((v20 * v11) >> 16);
        if (v22 + 65537 < v22) {
          v22 += 65537;
        }
      }

      if (65537 - v22 >= -v22) {
        int v23 = -v22;
      }
      else {
        int v23 = 65537 - v22;
      }
      *(_DWORD *)(a3 + 4 * (v10 - 1)) = v23;
      v9 -= 16;
      BOOL v19 = v10-- <= 1;
    }

    while (!v19);
    return 0LL;
  }

  return v24;
}

uint64_t ecc65537Inv(uint64_t a1)
{
  if ((_DWORD)a1 == 1)
  {
    LODWORD(v1) = 1;
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 1LL;
    uint64_t v4 = 65537LL;
    do
    {
      if (a1 <= v4)
      {
        char v5 = -1;
        do
        {
          unsigned int v6 = (_DWORD)a1 << (v5 + 2);
          ++v5;
        }

        while (v6 <= v4);
        uint64_t v4 = (v4 - ((_DWORD)a1 << v5));
        uint64_t v2 = (v2 - ((_DWORD)v3 << v5));
      }

      uint64_t v1 = v2;
      uint64_t v7 = v4;
      uint64_t v2 = v3;
      uint64_t v3 = v1;
      uint64_t v4 = a1;
      a1 = v7;
    }

    while ((_DWORD)v7 != 1);
  }

  int v8 = v1
     + 65537
     * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
      + (v1 >> 31));
  if (v8 <= 0x10000) {
    unsigned int v9 = 0x10000;
  }
  else {
    unsigned int v9 = v1
  }
       + 65537
       * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
        + (v1 >> 31));
  return v9 % 0x10001 - v9 + v8;
}

uint64_t ParallelCompressionGetCompressedSize(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = a2;
  if (a2 >= 0x400)
  {
    uint64_t v24 = 0LL;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    uint64_t v19 = 0LL;
    uint64_t v7 = IMemStreamCreate(a1, a2);
    if (v7)
    {
      DWORD2(v20) = a3;
      LODWORD(v20) = 0;
      DWORD1(v20) = getDefaultNThreads();
      *(void *)&__int128 v21 = 0x200000LL;
      *((void *)&v21 + 1) = IMemStreamRead;
      *((void *)&v22 + 1) = v7;
      *(void *)&__int128 v23 = getCompressedSizeCounterProc;
      uint64_t v24 = &v19;
      if (!ParallelCompressionEncode((uint64_t)&v20, v8, v9, v10, v11, v12, v13, v14))
      {
        if (v19 < v3) {
          uint64_t v3 = v19;
        }
        goto LABEL_9;
      }

      BOOL v15 = "ParallelCompressionEncode";
      __int16 v16 = 75;
    }

    else
    {
      BOOL v15 = "IMemStreamCreate";
      __int16 v16 = 64;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ParallelCompressionGetCompressedSize",  v16,  39,  0,  v15,  v5,  v6,  v18);
    uint64_t v3 = -1LL;
LABEL_9:
    OMemStreamDestroy(v7);
  }

  return v3;
}

uint64_t getCompressedSizeCounterProc(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 += a3;
  return a3;
}

uint64_t IDecoderStreamThreadProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelCompressionDecode(a1, a2, a3, a4, a5, a6, a7, a8)) {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"IDecoderStreamThreadProc",  100,  39,  0,  "decoder failed",  v8,  v9,  vars0);
  }
  return 0LL;
}

uint64_t IDecoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  uint64_t v10 = malloc(0x48uLL);
  uint64_t v18 = (uint64_t)v10;
  if (v10)
  {
    v10[2] = 0u;
    v10[3] = 0u;
    _OWORD *v10 = 0u;
    v10[1] = 0u;
    uint64_t v19 = SharedBufferCreate(a4, v11, v12, v13, v14, v15, v16, v17);
    *(void *)(v18 + 64) = v19;
    if (!v19)
    {
      __int128 v23 = "fail to init buffer";
      __int16 v24 = 112;
      int v22 = 0;
      goto LABEL_7;
    }

    *(_DWORD *)uint64_t v18 = 0;
    *(_DWORD *)(v18 + 4) = a5;
    *(void *)(v18 + 8) = a1;
    *(void *)(v18 + 16) = a2;
    *(void *)(v18 + 24) = a3;
    *(void *)(v18 + 32) = SharedBufferWrite;
    *(void *)(v18 + 40) = SharedBufferAbort;
    *(void *)(v18 + 48) = v19;
    if (createThread((pthread_t *)(v18 + 56), (uint64_t)IDecoderStreamThreadProc, v18, 0LL))
    {
      int v22 = *__error();
      __int128 v23 = "failed to start decoder thread";
      __int16 v24 = 125;
LABEL_7:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"IDecoderStreamCreate",  v24,  39,  v22,  v23,  v20,  v21,  v29);
      IDecoderStreamDestroy((void *)v18);
      return 0LL;
    }
  }

  else
  {
    int v25 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"IDecoderStreamCreate",  107,  39,  *v25,  "malloc",  v26,  v27,  v29);
  }

  return v18;
}

void IDecoderStreamDestroy(void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a1[8])
    {
      while (1)
      {
        uint64_t v2 = SharedBufferRead(a1[8], (uint64_t)v10, 0x400uLL);
        if (v2 < 0) {
          break;
        }
        if (!v2) {
          goto LABEL_7;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"IDecoderStreamDestroy",  155,  39,  0,  "flushing shared buffer",  v3,  v4,  v9);
    }

LABEL_7:
    uint64_t v5 = (_opaque_pthread_t *)a1[7];
    if (v5)
    {
      if (joinThread(v5))
      {
        uint64_t v6 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"IDecoderStreamDestroy",  163,  39,  *v6,  "failed to join decoder thread",  v7,  v8,  v9);
      }
    }

    SharedBufferDestroy(a1[8]);
    free(a1);
  }

  switch(field)
  {
    case 5u:
      if (buf_size) {
        *buf_uint64_t size = *((unsigned int *)context + 1);
      }
      if (!buf_capacity) {
        goto LABEL_28;
      }
      uint64_t v10 = *((unsigned int *)context + 1);
      if (v10 > buf_capacity)
      {
        uint64_t v8 = "buf_capacity is too small";
        char v9 = 358;
        goto LABEL_23;
      }

      memcpy(buf, *((const void **)context + 339), v10);
LABEL_28:
      uint64_t result = 0;
      break;
    case 6u:
      uint64_t v11 = (unsigned int *)((char *)context + 1372);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 7u:
      uint64_t v11 = (unsigned int *)((char *)context + 332);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 8u:
      uint64_t v11 = (unsigned int *)((char *)context + 592);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 9u:
      uint64_t v11 = (unsigned int *)((char *)context + 72);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xAu:
      uint64_t v11 = (unsigned int *)((char *)context + 852);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xBu:
      uint64_t v11 = (unsigned int *)((char *)context + 1112);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0xCu:
      uint64_t v11 = (unsigned int *)((char *)context + 1632);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0x12u:
      uint64_t v11 = (unsigned int *)((char *)context + 1892);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    case 0x13u:
      uint64_t v11 = (unsigned int *)((char *)context + 2152);
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    default:
      uint64_t v8 = "Invalid field";
      char v9 = 375;
      goto LABEL_23;
  }

  return result;
}

  switch(field)
  {
    case 5u:
      if (*((_DWORD *)context + 684))
      {
        uint64_t v11 = "Context can't be modified";
        uint64_t v12 = 477;
        goto LABEL_23;
      }

      uint64_t v16 = (void *)*((void *)context + 339);
      if (v16) {
        memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
      }
      free(v16);
      *((void *)context + 339) = 0LL;
      *((_DWORD *)context + 1) = 0;
      if (!buf_size) {
        goto LABEL_34;
      }
      if (buf_size >= 0x4000001)
      {
        uint64_t v18 = buf_size;
        uint64_t v11 = "Invalid auth data size: %zu";
        uint64_t v12 = 483;
        goto LABEL_23;
      }

      uint64_t v17 = malloc(buf_size);
      *((void *)context + 339) = v17;
      if (!v17)
      {
        uint64_t v14 = *__error();
        uint64_t v11 = "malloc";
        uint64_t v12 = 486;
        goto LABEL_24;
      }

      *((_DWORD *)context + 1) = buf_size;
      memcpy(v17, buf, buf_size);
LABEL_34:
      uint64_t result = 0;
      break;
    case 6u:
      uint64_t v13 = (char *)context + 1372;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 7u:
      uint64_t v13 = (char *)context + 332;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 8u:
      uint64_t v13 = (char *)context + 592;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 9u:
      uint64_t v13 = (char *)context + 72;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xAu:
      uint64_t v13 = (char *)context + 852;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xBu:
      uint64_t v13 = (char *)context + 1112;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0xCu:
      uint64_t v13 = (char *)context + 1632;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    case 0x13u:
      uint64_t v13 = (char *)context + 2152;
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    default:
      uint64_t v11 = "Invalid field";
      uint64_t v12 = 502;
      goto LABEL_23;
  }

  return result;
}

      *((_DWORD *)a1 + 3) = v23.st_flags;
      goto LABEL_8;
    }

uint64_t IDecoderStreamRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1) {
    return SharedBufferRead(*(void *)(a1 + 64), a2, a3);
  }
  else {
    return -1LL;
  }
}

size_t IDecoderStreamAbort( size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result) {
    return SharedBufferAbort(*(void *)(result + 64), a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

uint64_t ILowMemoryDecoderStreamCreate( uint64_t (*a1)(uint64_t, uint64_t, unint64_t), uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v8 = malloc(0xD8uLL);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    v8[26] = 0LL;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    if (a4 <= 0x1000) {
      a4 = 4096LL;
    }
    *(_OWORD *)uint64_t v8 = 0uLL;
    uint64_t v10 = MemBufferCreate(a4);
    *(void *)(v9 + 56) = v10;
    if (!v10) {
      goto LABEL_27;
    }
    uint64_t v11 = MemBufferCreate(a4);
    *(void *)(v9 + 64) = v11;
    if (!v11) {
      goto LABEL_27;
    }
    *(_DWORD *)(v9 + 32) = -1;
    *(void *)uint64_t v9 = a1;
    *(void *)(v9 + 8) = a2;
    *(void *)(v9 + 16) = a3;
    if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0xCuLL, a1, a3) != 12)
    {
      uint64_t v19 = "couldn't read enough header bytes from compressed file";
      __int16 v20 = 465;
      goto LABEL_26;
    }

    uint64_t DataPtr = MemBufferGetDataPtr(*(void *)(v9 + 56));
    if ((*(_DWORD *)(v9 + 32) & 0x80000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)DataPtr;
      if (*(_WORD *)DataPtr == 25200 && *(_BYTE *)(DataPtr + 2) == 122)
      {
        unsigned int v25 = 0;
        while (1)
        {
          int v26 = v15[3];
          if (++v25 == 7)
          {
            if ((*(_DWORD *)(v9 + 32) & 0x80000000) == 0) {
              return v9;
            }
            goto LABEL_12;
          }
        }

        *(void *)(v9 + 40) = bswap64(*(void *)(v15 + 4));
        *(void *)(v9 + 48) = PCompressGetDecoderFilter(v25);
        MemBufferDecreaseSize(*(void *)(v9 + 56), 0xCuLL, v34, v35, v36, v37, v38, v39);
        if ((MemBufferIncreaseCapacity(*(void *)(v9 + 56), *(void *)(v9 + 40)) & 0x8000000000000000LL) != 0)
        {
          uint64_t v19 = "MemBufferIncreaseCapacity in";
          __int16 v20 = 487;
        }

        else
        {
          if ((MemBufferIncreaseCapacity(*(void *)(v9 + 64), *(void *)(v9 + 40)) & 0x8000000000000000LL) == 0)
          {
            *(_DWORD *)(v9 + 32) = 0;
            return v9;
          }

          uint64_t v19 = "MemBufferIncreaseCapacity out";
          __int16 v20 = 488;
        }

        goto LABEL_26;
      }

LABEL_12:
      if (*(_DWORD *)v15 == 1484404733 && *((_WORD *)v15 + 2) == 90)
      {
        if (!lzma_stream_decoder())
        {
          *(_DWORD *)(v9 + 32) = 1;
          return v9;
        }

        uint64_t v19 = "lzma_stream_decoder";
        __int16 v20 = 503;
        goto LABEL_26;
      }

      BOOL v18 = *(_WORD *)v15 == 23106 && v15[2] == 104;
      if (v18 && v15[3] - 49 <= 8)
      {
        if (BZ2_bzDecompressInit((bz_stream *)(v9 + 72), 0, 0))
        {
          uint64_t v19 = "BZ2_bzDecompressInit";
          __int16 v20 = 514;
LABEL_26:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamCreate",  v20,  39,  0,  v19,  v12,  v13,  v47);
LABEL_27:
          ILowMemoryDecoderStreamDestroy(v9);
          return 0LL;
        }

        int v44 = 3;
LABEL_54:
        *(_DWORD *)(v9 + 32) = v44;
        return v9;
      }

      int v27 = *v15;
      if (v27 == 120)
      {
        if (-1108378657 * (v15[1] | 0x7800u) <= 0x8421084)
        {
          if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB) == COMPRESSION_STATUS_OK)
          {
            MemBufferDecreaseSize(*(void *)(v9 + 56), 2uLL, v40, v41, v42, v43, v12, v13);
            *(_DWORD *)(v9 + 32) = 2;
            return v9;
          }

          uint64_t v19 = "compression_stream_init";
          __int16 v20 = 570;
          goto LABEL_26;
        }
      }

      else if (v27 == 31 && v15[1] == 139 && v15[2] == 8)
      {
        if (MemBufferFillFromIStream( *(unint64_t **)(v9 + 56),  0x1000uLL,  *(uint64_t (**)(uint64_t, uint64_t, unint64_t))v9,  *(void *)(v9 + 16)) < 0)
        {
          uint64_t v19 = "reading gzip header data";
          __int16 v20 = 525;
          goto LABEL_26;
        }

        unint64_t DataSize = MemBufferGetDataSize(*(void *)(v9 + 56));
        if ((v15[3] & 4) != 0)
        {
          if (DataSize <= 0xB)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 531;
            goto LABEL_26;
          }

          unint64_t v33 = *((unsigned __int16 *)v15 + 5) + 12LL;
          if (v33 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 534;
            goto LABEL_26;
          }
        }

        else
        {
          unint64_t v33 = 10LL;
        }

        if ((v15[3] & 8) != 0)
        {
          unint64_t v45 = v33 + 2;
          if (v33 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 539;
            goto LABEL_26;
          }

          if (v33 + 2 < DataSize)
          {
            while (v15[v33 + 1])
            {
              if (DataSize - 2 == ++v33)
              {
                unint64_t v45 = DataSize;
                goto LABEL_63;
              }
            }

            unint64_t v45 = v33 + 2;
          }
        }

        else
        {
          unint64_t v45 = v33;
        }

  CC_SHA1_Final((unsigned __int8 *)a4, &c);
  uint64_t v17 = 0LL;
LABEL_17:
  free(v11);
  return v17;
}

    uint64_t v13 = (void *)a1[2];
    uint64_t v14 = realloc(v13, v11);
    if (v14)
    {
      a1[1] = v11;
      a1[2] = v14;
      goto LABEL_14;
    }

    free(v13);
LABEL_20:
    a1[1] = 0LL;
    a1[2] = 0LL;
    *a1 = 0LL;
    goto LABEL_21;
  }

  uint64_t v12 = a1[1];
  if (*(void *)(v12 + 24))
  {
    uint64_t v11 = 0LL;
    if (a3)
    {
      uint64_t v13 = a3;
      while (1)
      {
        uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v12 + 24))(*(void *)v12, v4, v13);
        if (v14 < 1) {
          break;
        }
        v4 += v14;
        v11 += v14;
        v13 -= v14;
        if (!v13) {
          goto LABEL_20;
        }
      }

      uint64_t v11 = v14;
    }
  }

  else
  {
    uint64_t v11 = -1LL;
  }

  uint64_t v15 = a1[1];
  if (*(void *)(v15 + 40))
  {
    uint64_t v14 = 0LL;
    if (a3)
    {
      uint64_t v16 = a3;
      while (1)
      {
        uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(void *)v15, v6, v16, v4);
        if (v17 < 1) {
          break;
        }
        v6 += v17;
        v14 += v17;
        v4 += v17;
        v16 -= v17;
        if (!v16) {
          goto LABEL_20;
        }
      }

      uint64_t v14 = v17;
    }
  }

  else
  {
    uint64_t v14 = -1LL;
  }

  free(v40);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  AAByteStreamClose(v15);
  return v16;
}

void ILowMemoryDecoderStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 32);
    switch(v2)
    {
      case 3:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 72));
        break;
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 72));
        break;
      case 1:
        lzma_end();
        break;
    }

    MemBufferDestroy(*(void ***)(a1 + 56));
    MemBufferDestroy(*(void ***)(a1 + 64));
    OMemStreamDestroy(*(void **)(a1 + 24));
    free((void *)a1);
  }

uint64_t ILowMemoryDecoderStreamCreateWithBuffer(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t v4 = IMemStreamCreate(a1, a2);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t result = ILowMemoryDecoderStreamCreate( (uint64_t (*)(uint64_t, uint64_t, unint64_t))IMemStreamRead,  (uint64_t)IMemStreamAbort,  (uint64_t)v4,  a3);
    if (result)
    {
      *(void *)(result + 24) = v7;
      return result;
    }

    OMemStreamDestroy(v7);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamCreateWithBuffer",  596,  39,  0,  "IMemStreamCreate failed",  v5,  v6,  v9);
  }

  return 0LL;
}

uint64_t ILowMemoryDecoderStreamRead(uint64_t a1, char *a2, size_t a3)
{
  if (a1)
  {
    int v6 = 0;
    uint64_t v7 = 0LL;
    stream = (bz_stream *)(a1 + 72);
    do
    {
      if (!a3) {
        return v7;
      }
      unint64_t DataSize = MemBufferGetDataSize(*(void *)(a1 + 64));
      if (DataSize >= a3) {
        size_t v9 = a3;
      }
      else {
        size_t v9 = DataSize;
      }
      if (v9)
      {
        uint64_t DataPtr = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 64));
        memcpy(a2, DataPtr, v9);
        MemBufferDecreaseSize(*(void *)(a1 + 64), v9, v11, v12, v13, v14, v15, v16);
        v7 += v9;
        a3 -= v9;
        if (!a3) {
          return v7;
        }
        a2 += v9;
      }

      if (*(_DWORD *)(a1 + 208)) {
        return v7;
      }
      uint64_t v17 = *(unint64_t **)(a1 + 56);
      if (!*(_DWORD *)(a1 + 32))
      {
        unint64_t v43 = MemBufferGetDataSize((uint64_t)v17);
        uint64_t v44 = v43;
        if (v43 <= 0xF)
        {
          if (MemBufferFillFromIStream( *(unint64_t **)(a1 + 56),  16 - v43,  *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1,  *(void *)(a1 + 16)) < 0)
          {
            unsigned int v106 = "reading block header failed";
            __int16 v107 = 645;
            goto LABEL_76;
          }

          uint64_t v44 = MemBufferGetDataSize(*(void *)(a1 + 56));
          if (!v44)
          {
            *(_DWORD *)(a1 + 208) = 1;
            return v7;
          }
        }

        unint64_t v45 = (unint64_t *)MemBufferGetDataPtr(*(void *)(a1 + 56));
        unint64_t v51 = *v45;
        unint64_t v50 = v45[1];
        unint64_t v52 = bswap64(*v45);
        unint64_t v53 = bswap64(v50);
        unint64_t v54 = *(void *)(a1 + 40);
        if (v52 > v54 || v53 > v54)
        {
          unsigned int v106 = "invalid block header";
          __int16 v107 = 655;
          goto LABEL_76;
        }

        MemBufferDecreaseSize(*(void *)(a1 + 56), 0x10uLL, v46, v47, v48, v49, v18, v19);
        BOOL v56 = v53 >= v44 - 16;
        unint64_t v57 = v53 - (v44 - 16);
        if (v57 != 0 && v56)
        {
          if (MemBufferFillFromIStream( *(unint64_t **)(a1 + 56),  v57,  *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1,  *(void *)(a1 + 16)) != v57)
          {
            unsigned int v106 = "reading block payload failed";
            __int16 v107 = 665;
            goto LABEL_76;
          }

          MemBufferGetDataSize(*(void *)(a1 + 56));
        }

        if (v51 == v50)
        {
          FreePtr = (void *)MemBufferGetFreePtr(*(void *)(a1 + 64));
          int8x16_t v59 = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 56));
          memcpy(FreePtr, v59, v52);
        }

        else
        {
          uint64_t v97 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t))(a1 + 48);
          uint64_t v98 = MemBufferGetFreePtr(*(void *)(a1 + 64));
          uint64_t v99 = MemBufferGetDataPtr(*(void *)(a1 + 56));
          if (v97(v98, v52, v99, v53) != v52)
          {
            unsigned int v106 = "decoding block payload failed";
            __int16 v107 = 677;
            goto LABEL_76;
          }
        }

        MemBufferDecreaseSize(*(void *)(a1 + 56), v53, v60, v61, v62, v63, v18, v19);
        MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v52, v100, v101, v102, v103, v104, v105);
        goto LABEL_62;
      }

      if (MemBufferFillFromIStream( v17,  0xFFFFFFFFFFFFFFFFLL,  *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1,  *(void *)(a1 + 16)) < 0)
      {
        unsigned int v106 = "reading payload failed";
        __int16 v107 = 687;
        goto LABEL_76;
      }

      uint64_t v20 = MemBufferGetDataPtr(*(void *)(a1 + 56));
      uint64_t v21 = MemBufferGetDataSize(*(void *)(a1 + 56));
      uint64_t v22 = MemBufferGetFreePtr(*(void *)(a1 + 64));
      uint64_t FreeSize = MemBufferGetFreeSize(*(void **)(a1 + 64));
      uint64_t v26 = FreeSize;
      int v27 = *(_DWORD *)(a1 + 32);
      switch(v27)
      {
        case 1:
          *(void *)(a1 + 72) = v20;
          *(void *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(void *)(a1 + 104) = FreeSize;
          unsigned int v64 = lzma_code();
          unsigned int v71 = v64;
          if (v64 > 0xA || ((1 << v64) & 0x403) == 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamRead",  738,  39,  0,  "decoding lzma payload",  v69,  v70,  v109);
            int v81 = 1;
            goto LABEL_60;
          }

          uint64_t v72 = *(void *)(a1 + 72);
          uint64_t v73 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v72 - v20, v65, v66, v67, v68, v69, v70);
          if (v73 == v22 && v72 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v73 - v22, v74, v75, v76, v77, v78, v79);
          if (v71 != 1)
          {
            int v81 = 14;
LABEL_60:
            if (v71 > 0xA || ((1 << v71) & 0x403) == 0) {
              continue;
            }
            goto LABEL_62;
          }

          break;
        case 3:
          *(void *)(a1 + 72) = v20;
          *(_DWORD *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(_DWORD *)(a1 + 104) = FreeSize;
          int v82 = BZ2_bzDecompress(stream);
          if (v82 < 0)
          {
            unsigned int v106 = "decoding bzip2 payload";
            __int16 v107 = 722;
            goto LABEL_76;
          }

          int v87 = v82;
          uint64_t v88 = *(void *)(a1 + 72);
          uint64_t v89 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v88 - v20, v83, v84, v85, v86, v18, v19);
          if (v89 == v22 && v88 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v89 - v22, v90, v91, v92, v93, v94, v95);
          if (v87 != 4) {
            goto LABEL_62;
          }
          break;
        case 2:
          *(void *)(a1 + 88) = v20;
          *(void *)(a1 + 96) = v21;
          *(void *)(a1 + 72) = v22;
          *(void *)(a1 + 80) = FreeSize;
          compression_status v28 = compression_stream_process((compression_stream *)stream, 0);
          if (v28 < 0)
          {
            unsigned int v106 = "decoding zlib payload";
            __int16 v107 = 706;
            goto LABEL_76;
          }

          compression_status v33 = v28;
          uint64_t v34 = *(void *)(a1 + 96);
          uint64_t v35 = *(void *)(a1 + 80);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v21 - v34, v29, v30, v31, v32, v18, v19);
          if (v26 == v35 && v21 == v34) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v26 - v35, v36, v37, v38, v39, v40, v41);
          if (v33 != COMPRESSION_STATUS_END) {
            goto LABEL_62;
          }
          break;
        default:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamRead",  748,  39,  0,  "invalid decoder: %d",  v24,  v25,  *(_DWORD *)(a1 + 32));
          return -1LL;
      }

      *(_DWORD *)(a1 + 208) = 1;
LABEL_62:
      if (v6 >= 3)
      {
        unsigned int v106 = "Truncated stream";
        __int16 v107 = 753;
LABEL_76:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c",  (uint64_t)"ILowMemoryDecoderStreamRead",  v107,  39,  0,  v106,  v18,  v19,  v109);
        return -1LL;
      }

      int v81 = 0;
    }

    while (!v81);
  }

  return -1LL;
}

uint64_t rawimg_force_in_place(void *a1, unint64_t *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(void *)(a4 + 2120) <= a3[265]) {
    uint64_t v12 = a3[265];
  }
  else {
    uint64_t v12 = *(void *)(a4 + 2120);
  }
  uint64_t v15 = AAFileStreamOpenWithPath(*(const char **)(a4 + 2048), 0, 0);
  if (!v15)
  {
    uint64_t v99 = "AAFileStreamOpenWithPath";
    __int16 v100 = 234;
LABEL_121:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  v100,  141,  0,  v99,  v13,  v14,  v145);
    unint64_t v43 = 0LL;
    uint64_t v40 = 0LL;
    compression_status v33 = 0LL;
    uint64_t v30 = 0LL;
    uint64_t v17 = 0LL;
LABEL_122:
    int v110 = 0;
    goto LABEL_123;
  }

  unint64_t v16 = (unint64_t)(a5 + 0x3FFF) >> 14;
  uint64_t v17 = (uint64_t *)calloc(1uLL, 0x68uLL);
  uint64_t v18 = calloc(1uLL, 0x28uLL);
  uint64_t v21 = v18;
  if ((v16 & 0x80000000) != 0)
  {
    uint64_t v101 = "too little excess";
    __int16 v102 = 184;
LABEL_120:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"aaSimStreamOpen",  v102,  141,  0,  v101,  v19,  v20,  v145);
    free(v17);
    SimStreamClose((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109);
    uint64_t v99 = "aaSimStreamOpen";
    __int16 v100 = 236;
    goto LABEL_121;
  }

  if (!v17 || !v18)
  {
    uint64_t v101 = "aaCalloc";
    __int16 v102 = 185;
    goto LABEL_120;
  }

  *uint64_t v18 = v15;
  *((_DWORD *)v18 + 4) = (unint64_t)(v12 + 0x3FFF) >> 14;
  *((_DWORD *)v18 + 8) = v16;
  *((_DWORD *)v18 + 9) = a6;
  if (((v12 + 0x3FFF) & 0x200000000000LL) != 0)
  {
    *__error() = 12;
    v21[1] = 0LL;
    goto LABEL_119;
  }

  uint64_t v22 = calloc(((unint64_t)(v12 + 0x3FFF) >> 14), 5uLL);
  v21[1] = v22;
  if (!v22)
  {
LABEL_119:
    uint64_t v101 = "aaCalloc";
    __int16 v102 = 195;
    goto LABEL_120;
  }

  AACustomByteStreamSetData((AAByteStream)v17, v21);
  AACustomByteStreamSetCloseProc((AAByteStream)v17, (AAByteStreamCloseProc)SimStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v17, (AAByteStreamPReadProc)SimStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v17, (AAByteStreamPWriteProc)SimStreamPWrite);
  v17[11] = (uint64_t)SimStreamSimulate;
  uint64_t v23 = *v17;
  uint64_t v24 = aaSegmentStreamOpen(v17, a3);
  uint64_t v30 = (AAByteStream_impl *)v24;
  if (!v24)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  241,  141,  0,  "aaSegmentStreamOpen",  v28,  v29,  v145);
    unint64_t v43 = 0LL;
    uint64_t v40 = 0LL;
    compression_status v33 = 0LL;
    goto LABEL_122;
  }

  compression_status v33 = aaForkInputStreamOpen(v24, (uint64_t)a3, 0, v25, v26, v27, v28, v29);
  if (!v33)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  243,  141,  0,  "aaForkInputStreamOpen",  v31,  v32,  v145);
    unint64_t v43 = 0LL;
    uint64_t v40 = 0LL;
    goto LABEL_122;
  }

  uint64_t v34 = aaSegmentStreamOpen(v17, (void *)a4);
  uint64_t v40 = (AAByteStream_impl *)v34;
  if (!v34)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  247,  141,  0,  "aaSegmentStreamOpen",  v38,  v39,  v145);
    unint64_t v43 = 0LL;
    goto LABEL_122;
  }

  uint64_t v169 = v23;
  unint64_t v43 = aaForkInputStreamOpen(v34, a4, 0, v35, v36, v37, v38, v39);
  if (!v43)
  {
    uint64_t v97 = "aaForkOutputStreamOpen";
    __int16 v98 = 249;
LABEL_142:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  v98,  141,  0,  v97,  v41,  v42,  v145);
    goto LABEL_122;
  }

  uint64_t v154 = 0LL;
  int64x2_t v152 = vdupq_n_s64(0x8000000000000000LL);
  int v151 = 1;
  unint64_t v171 = a1;
  uint64_t v168 = v40;
  int v153 = a6;
  unint64_t v170 = a2;
  while (2)
  {
    bzero(*(void **)(v169 + 8), 5LL * *(int *)(v169 + 16));
    int v44 = *(_DWORD *)(v169 + 16);
    *(void *)(v169 + 24) = 0LL;
    *(_DWORD *)(v169 + 20) = v44;
    unint64_t v45 = *a2;
    if (*a2)
    {
      uint64_t v46 = 0LL;
      unint64_t v47 = 0LL;
      do
      {
        uint64_t v48 = (unint64_t *)(*a1 + 24 * v47);
        if ((*v48 & 0x8000000000000000LL) == 0LL) {
          unint64_t v49 = *v48;
        }
        else {
          unint64_t v49 = 0x8000000000000000LL - *v48;
        }
        uint64_t v50 = v48[2];
        uint64_t v51 = 0x8000000000000000LL - v50;
        if (v50 >= 0) {
          uint64_t v51 = v50;
        }
        if (v49)
        {
          uint64_t v161 = v51;
          unint64_t v164 = v47;
          for (unint64_t i = 0LL; i < v49; i += v53)
          {
            if (v49 - i >= 0x10000) {
              uint64_t v53 = 0x10000LL;
            }
            else {
              uint64_t v53 = v49 - i;
            }
            if (v53 != aaByteStreamSimulate(v33))
            {
              uint64_t v124 = "aaByteStreamSimulate";
              __int16 v125 = 270;
              goto LABEL_144;
            }
          }

          a1 = v171;
          unint64_t v45 = *v170;
          uint64_t v51 = v161;
          unint64_t v47 = v164;
        }

        v46 += v49 + v51;
        ++v47;
      }

      while (v47 < v45);
    }

    int v54 = 1;
    unint64_t v55 = v45;
    uint64_t v156 = v30;
    do
    {
      if (!v55) {
        goto LABEL_59;
      }
      uint64_t v56 = 0LL;
      unint64_t v57 = 0LL;
      unint64_t v58 = 0LL;
      int v165 = v54;
      do
      {
        int8x16_t v59 = (unint64_t *)(*v171 + 24 * v58);
        uint64_t v60 = v59[1];
        unint64_t v61 = 0x8000000000000000LL - *v59;
        if ((*v59 & 0x8000000000000000LL) == 0LL) {
          unint64_t v61 = *v59;
        }
        if (v60 >= 0) {
          unint64_t v62 = v59[1];
        }
        else {
          unint64_t v62 = 0x8000000000000000LL - v60;
        }
        uint64_t v63 = v59[2];
        if (v63 < 0) {
          uint64_t v63 = 0x8000000000000000LL - v63;
        }
        if (v54 == 2)
        {
          v57 += v61;
          if (v57 < *(void *)(a4 + 2056)) {
            goto LABEL_57;
          }
        }

        else
        {
          uint64_t v157 = v63;
          unint64_t v159 = v62;
          unint64_t v162 = v58;
          if (v61)
          {
            unint64_t v64 = 0LL;
            while (1)
            {
              unint64_t v65 = v61;
              if (v61 - v64 >= 0x10000) {
                uint64_t v66 = 0x10000LL;
              }
              else {
                uint64_t v66 = v61 - v64;
              }
              if (v66 != aaByteStreamSimulate(v33))
              {
                __int16 v126 = 298;
                goto LABEL_148;
              }

              if (v66 != aaByteStreamSimulate(v43)) {
                break;
              }
              v56 += v66;
              v57 += v66;
              v64 += v66;
              unint64_t v61 = v65;
              if (v64 >= v65) {
                goto LABEL_52;
              }
            }

            __int16 v126 = 299;
LABEL_148:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  v126,  141,  0,  "aaByteStreamSimulate",  v41,  v42,  v145);
            int v110 = 0;
            uint64_t v40 = v168;
            uint64_t v30 = v156;
            goto LABEL_123;
          }

LABEL_94:
            v80 -= 24LL;
            --v79;
            a1 = v171;
            if (!v79) {
              goto LABEL_97;
            }
          }

          if (v78 < *(void *)(a4 + 2056)) {
            goto LABEL_94;
          }
          unint64_t v88 = *(void *)(a4 + 2072);
LABEL_78:
          if (v78 < v88)
          {
            if (v84.i64[0] >= v73) {
              unint64_t v87 = v73;
            }
LABEL_89:
            if (v153 >= 4)
            {
              unint64_t v91 = v73;
              uint64_t v155 = v75;
              uint64_t v163 = v81;
              unint64_t v166 = v78;
              unint64_t v158 = v86;
              unint64_t v160 = v87;
              int64x2_t v150 = v84;
              fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Dropping %llu bytes at %llu, needed=%llu bytes, type %s\n",  v87,  v78,  v73,  rawimg_force_in_place_pass_name[v147]);
              int64x2_t v84 = v150;
              unint64_t v86 = v158;
              unint64_t v87 = v160;
              uint64_t v81 = v163;
              unint64_t v78 = v166;
              unint64_t v76 = v148;
              uint64_t v75 = v155;
              unint64_t v73 = v91;
              int64x2_t v77 = v152;
            }

            v83.i64[0] = v87;
            v92.i64[0] = vsubq_s64(v84, v83).u64[0];
            v92.i64[1] = vaddq_s64(v84, vdupq_n_s64(v87)).i64[1];
            int8x16_t *v82 = vbslq_s8((int8x16_t)vcltzq_s64(v92), (int8x16_t)vsubq_s64(v77, v92), (int8x16_t)v92);
            unint64_t v93 = v87 + v86;
            *(void *)(v81 - 8) = v93;
            v75 += v87;
            v73 -= v87;
            int v74 = 1;
            goto LABEL_94;
          }

          goto LABEL_94;
        }

        int v74 = 0;
LABEL_97:
        if (v78)
        {
          uint64_t v124 = "control sequence broken";
          __int16 v125 = 411;
          goto LABEL_144;
        }

        a2 = v170;
        if (v76 != 3 || v74 || !v73 || !v149)
        {
          if (v76 > 2) {
            goto LABEL_112;
          }
          if (v74) {
            goto LABEL_112;
          }
          ++v76;
          if (!v73) {
            goto LABEL_112;
          }
          continue;
        }

        break;
      }

      uint64_t v94 = v75;
      else {
        unint64_t v95 = 0x8000000000000000LL - *(void *)v149;
      }
      int64x2_t v167 = *(int64x2_t *)(v149 + 8);
      if (v153 >= 4) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Dropping copy fork with %llu bytes, needed=%llu bytesx\n", v95, v73);
      }
      unint64_t v73 = 0LL;
      *(void *)uint64_t v149 = 0LL;
      int64x2_t v96 = vaddq_s64( (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v167), (int8x16_t)vsubq_s64(v152, v167), (int8x16_t)v167),  vdupq_n_s64(v95));
      *(int8x16_t *)(v149 + 8) = vbslq_s8((int8x16_t)vcltzq_s64(v96), (int8x16_t)vsubq_s64(v152, v96), (int8x16_t)v96);
      uint64_t v75 = v95 + v94;
      int v74 = 1;
      a2 = v170;
      a1 = v171;
LABEL_112:
      uint64_t v154 = v75;
      ++v151;
      uint64_t v40 = v168;
      if (!v74 && v73)
      {
        uint64_t v97 = "no possible conversions";
        __int16 v98 = 441;
        goto LABEL_142;
      }

      continue;
    }

    break;
  }

  uint64_t v127 = (void *)*v171;
  unint64_t v128 = *v170;
  if (!*v170) {
    goto LABEL_155;
  }
  if (v128 != 1)
  {
    uint64_t v129 = 0LL;
    uint64_t v130 = v127[1] + *v127;
    uint64_t v131 = v127 + 3;
    unint64_t v132 = 1LL;
    while (1)
    {
      uint64_t v133 = *v131;
      uint64_t v134 = v131[1];
      if (v130 != *(void *)(a4 + 2072))
      {
        uint64_t v135 = &v127[3 * v129];
        uint64_t v138 = v135[1];
        uint64_t v137 = v135 + 1;
        uint64_t v136 = v138;
        if (!v133)
        {
          uint64_t v141 = v127[3 * v129 + 2];
LABEL_167:
          v127[3 * v129] += v133;
          *uint64_t v137 = v136 + v134;
          uint64_t v142 = 0x8000000000000000LL - v141;
          if (v141 >= 0) {
            uint64_t v142 = v141;
          }
          uint64_t v143 = v131[2];
          if (v143 < 0) {
            uint64_t v143 = 0x8000000000000000LL - v143;
          }
          BOOL v70 = __OFADD__(v143, v142);
          uint64_t v144 = v143 + v142;
          if (v144 < 0 != v70) {
            uint64_t v144 = 0x8000000000000000LL - v144;
          }
          v127[3 * v129 + 2] = v144;
          goto LABEL_174;
        }

        if (!v136)
        {
          uint64_t v136 = v127[3 * v129 + 2];
          if (!v136)
          {
            uint64_t v141 = 0LL;
            goto LABEL_167;
          }
        }
      }

      ++v129;
      __int128 v139 = *(_OWORD *)v131;
      uint64_t v140 = &v127[3 * v129];
      v140[2] = v131[2];
      *(_OWORD *)uint64_t v140 = v139;
LABEL_174:
      v130 += v134 + v133;
      ++v132;
      v131 += 3;
      if (v132 >= *v170) {
        goto LABEL_154;
      }
    }
  }

  uint64_t v129 = 0LL;
LABEL_154:
  unint64_t v128 = v129 + 1;
  *unint64_t v170 = v128;
LABEL_155:
  *unint64_t v171 = v127;
  if (v127)
  {
    if (v153 >= 2) {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ForceInPlace: %zu controls. Dropped %llu bytes to stay within budget.\n",  v128,  v154);
    }
    int v110 = 1;
  }

  else
  {
    uint64_t v124 = "merge_controls";
    __int16 v125 = 447;
LABEL_144:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  v125,  141,  0,  v124,  v41,  v42,  v145);
    int v110 = 0;
  }

  uint64_t v40 = v168;
LABEL_123:
  if (AAByteStreamClose((AAByteStream)v33) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  458,  141,  0,  "AAByteStreamClose",  v111,  v112,  v145);
    int v110 = 0;
  }

  if (AAByteStreamClose(v30) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  459,  141,  0,  "AAByteStreamClose",  v113,  v114,  v145);
    int v110 = 0;
  }

  if (AAByteStreamClose((AAByteStream)v43) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  460,  141,  0,  "AAByteStreamClose",  v115,  v116,  v145);
    int v110 = 0;
  }

  if (AAByteStreamClose(v40) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  461,  141,  0,  "AAByteStreamClose",  v117,  v118,  v145);
    int v110 = 0;
  }

  if (AAByteStreamClose((AAByteStream)v17) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  462,  141,  0,  "AAByteStreamClose",  v119,  v120,  v145);
    int v110 = 0;
  }

  if (AAByteStreamClose(v15) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"rawimg_force_in_place",  463,  141,  0,  "AAByteStreamClose",  v121,  v122,  v145);
    int v110 = 0;
  }

  if (v110) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SimStreamClose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0LL;
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if (v9 < 1) {
    goto LABEL_8;
  }
  int v10 = 0;
  uint64_t v11 = *(int **)(a1 + 8);
  uint64_t v12 = *(unsigned int *)(a1 + 16);
  do
  {
    int v13 = *v11;
    uint64_t v11 = (int *)((char *)v11 + 5);
    v10 += v13;
    --v12;
  }

  while (v12);
  if (v10)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"SimStreamClose",  148,  141,  0,  "%i dangling reads",  a7,  a8,  v10);
    int v9 = *(_DWORD *)(a1 + 16);
    uint64_t v14 = 0xFFFFFFFFLL;
  }

  else
  {
LABEL_8:
    uint64_t v14 = 0LL;
  }

  int v15 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28) + v9 != *(_DWORD *)(a1 + 20) + v15)
  {
    pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"SimStreamClose",  152,  141,  "file + excess != written + free",  a6,  a7,  a8,  v17);
    int v9 = *(_DWORD *)(a1 + 16);
    int v15 = *(_DWORD *)(a1 + 24);
  }

  if (v9 < v15) {
    pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c",  (uint64_t)"SimStreamClose",  154,  141,  "file < written",  a6,  a7,  a8,  v17);
  }
  if (*(int *)(a1 + 36) >= 2) {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "SimStream: pages: %i file, %i written, %i free, %i excess (%iK)\n",  *(_DWORD *)(a1 + 16),  *(_DWORD *)(a1 + 24),  *(_DWORD *)(a1 + 20),  *(_DWORD *)(a1 + 28),  16 * *(_DWORD *)(a1 + 28));
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return v14;
}

ssize_t SimStreamPRead(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

ssize_t SimStreamPWrite(AAByteStream *a1, const void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPWrite(*a1, a2, a3, a4);
}

uint64_t SimStreamSimulate( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 < 1) {
    return a4;
  }
  if (a2 > 2)
  {
    uint64_t v20 = "not implemented";
    __int16 v21 = 87;
    goto LABEL_20;
  }

  int64_t v9 = a5 + a4;
  uint64_t v10 = *(void *)(a1 + 8);
  while (1)
  {
    uint64_t v11 = (int *)(v10 + 5 * (a5 >> 14));
    if (a2) {
      break;
    }
    if (!(*v11)++)
    {
      int v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v14 - 1;
      if (!v14)
      {
        uint64_t v20 = "no free pages";
        __int16 v21 = 94;
        goto LABEL_20;
      }
    }

int AEAContextDecryptAttributes(AEAContext context)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v16 = 0;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = 0LL;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  if (*((_DWORD *)context + 684) && *((void *)context + 341))
  {
    if ((aeaContextUnlock((uint64_t)context, (uint64_t)&v10, __s, 0LL, 1, 0) & 0x80000000) != 0)
    {
      uint64_t v4 = "unlock container";
      __int16 v5 = 18;
    }

    else
    {
      if (((unint64_t)v12 + v11 - 1) / v11 < 0xFFFFFFFF)
      {
        int v6 = 0;
        __int128 v8 = v13;
        *((_OWORD *)context + 2) = v12;
        *((_OWORD *)context + 3) = v8;
        *((void *)context + 8) = v14;
        __int128 v9 = v11;
        *(_OWORD *)context = v10;
        *((_OWORD *)context + 1) = v9;
        goto LABEL_8;
      }

      uint64_t v4 = "Invalid data size";
      __int16 v5 = 22;
    }
  }

  else
  {
    uint64_t v4 = "invalid context";
    __int16 v5 = 15;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContextValidate.c",  (uint64_t)"AEAContextDecryptAttributes",  v5,  121,  0,  v4,  v1,  v2,  v10);
  int v6 = -1;
LABEL_8:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v10, 0x48uLL, 0, 0x48uLL);
  return v6;
}

char *SharedBufferCreate( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 - 0x100000000LL > 0xFFFFFFFF00000000LL)
  {
    int v9 = getpagesize();
    if (v9 <= 0x197)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferCreate",  252,  73,  0,  "Incompatible page size",  v10,  v11,  v39);
      return 0LL;
    }

    uint64_t v14 = v9;
    if (a1 >> 2 < v9) {
      unint64_t v15 = 1LL;
    }
    else {
      unint64_t v15 = (a1 >> 2) / v9;
    }
    unint64_t v16 = v15 * v9;
    uint64_t v17 = (unsigned int *)valloc(v9 + 4 * v16);
    __int128 v12 = v17;
    if (!v17)
    {
      uint64_t v24 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferCreate",  262,  73,  *v24,  "malloc",  v25,  v26,  v39);
      return (char *)v12;
    }

    *((void *)v17 + 50) = 0LL;
    *((_OWORD *)v17 + 23) = 0u;
    *((_OWORD *)v17 + 24) = 0u;
    *((_OWORD *)v17 + 21) = 0u;
    *((_OWORD *)v17 + 22) = 0u;
    *((_OWORD *)v17 + 19) = 0u;
    *((_OWORD *)v17 + 20) = 0u;
    *((_OWORD *)v17 + 17) = 0u;
    *((_OWORD *)v17 + 18) = 0u;
    *((_OWORD *)v17 + 15) = 0u;
    *((_OWORD *)v17 + 16) = 0u;
    *((_OWORD *)v17 + 13) = 0u;
    *((_OWORD *)v17 + 14) = 0u;
    *((_OWORD *)v17 + 11) = 0u;
    *((_OWORD *)v17 + 12) = 0u;
    *((_OWORD *)v17 + 9) = 0u;
    *((_OWORD *)v17 + 10) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 8) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *(_OWORD *)uint64_t v17 = 0u;
    *((void *)v17 + 48) = -1LL;
    atomic_store(2u, v17 + 101);
    *(void *)uint64_t v17 = 0x600000000LL;
    int v18 = calloc(6uLL, 4uLL);
    *((void *)v12 + 1) = v18;
    if (v18)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v12 + 4), 0LL))
      {
        uint64_t v22 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v23 = 56;
      }

      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v12 + 20), 0LL))
        {
          *((void *)v12 + 16) = 0x600000000LL;
          uint64_t v31 = calloc(6uLL, 4uLL);
          *((void *)v12 + 17) = v31;
          if (v31)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v12 + 36), 0LL))
            {
              uint64_t v35 = "SharedArrayInit: pthread_mutex_init failed\n";
              __int16 v36 = 56;
            }

            else
            {
              if (!pthread_cond_init((pthread_cond_t *)(v12 + 52), 0LL))
              {
                uint64_t v37 = 0LL;
                for (unint64_t i = v12 + 68; ; i += 4)
                {
                  *unint64_t i = 0LL;
                  i[1] = 0LL;
                  *(i - 2) = (char *)v12 + v14;
                  *(i - 1) = v16;
                  if ((SharedArrayPush(v12 + 32, v37) & 0x80000000) != 0) {
                    break;
                  }
                  ++v37;
                  v14 += v16;
                  if (v37 == 4) {
                    return (char *)v12;
                  }
                }

                uint64_t v29 = "SharedArrayPush";
                __int16 v30 = 283;
                goto LABEL_19;
              }

              uint64_t v35 = "SharedArrayInit: pthread_cond_init failed\n";
              __int16 v36 = 57;
            }
          }

          else
          {
            uint64_t v35 = "SharedArrayInit: malloc failed\n";
            __int16 v36 = 55;
          }

          pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v36,  0,  v35,  v32,  v33,  v34,  v39);
          uint64_t v29 = "SharedArrayInit";
          __int16 v30 = 270;
LABEL_19:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferCreate",  v30,  73,  0,  v29,  v27,  v28,  v39);
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 4))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 20)))
          {
            free(*((void **)v12 + 1));
          }

          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 36))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 52)))
          {
            free(*((void **)v12 + 17));
          }

          free(v12);
          return 0LL;
        }

        uint64_t v22 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v23 = 57;
      }
    }

    else
    {
      uint64_t v22 = "SharedArrayInit: malloc failed\n";
      __int16 v23 = 55;
    }

    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v23,  0,  v22,  v19,  v20,  v21,  v39);
    uint64_t v29 = "SharedArrayInit";
    __int16 v30 = 269;
    goto LABEL_19;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferCreate",  247,  73,  0,  "SharedBuffer invalid capacity: %zu",  a7,  a8,  a1);
  return 0LL;
}

uint64_t SharedArrayPush(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    __int128 v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 117;
  }

  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    int v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v10) = a2;
      int v12 = *a1;
    }

    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        __int128 v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 124;
      }

      else
      {
        __int128 v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 125;
      }
    }

    else
    {
      __int128 v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 122;
    }
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPush",  v9,  0,  v8,  v5,  v6,  v7,  v14);
  return 0xFFFFFFFFLL;
}

void SharedBufferDestroy(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 80))) {
      free(*(void **)(a1 + 8));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 208))) {
      free(*(void **)(a1 + 136));
    }
    free((void *)a1);
  }

BOOL SharedBufferDecRefCount(uint64_t a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 404);
  do
  {
    unsigned int v2 = __ldaxr(v1);
    unsigned int v3 = v2 - 1;
  }

  while (__stlxr(v3, v1));
  return v3 == 0;
}

uint64_t SharedBufferFillFromStream( size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (!atomic_load((unsigned int *)(a1 + 400)))
    {
      if (atomic_load((unsigned int *)(a1 + 392)))
      {
        unsigned int v11 = "write after EOF";
        __int16 v12 = 365;
LABEL_26:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferFillFromStream",  v12,  73,  0,  v11,  a7,  a8,  v45);
      }

      else
      {
        unint64_t v14 = a2;
        uint64_t v15 = 0LL;
        size_t v16 = a1 + 256;
        while (1)
        {
          uint64_t v17 = *(unsigned int *)(a1 + 384);
          if (v17 <= 3)
          {
            uint64_t v22 = *(void *)(v16 + 32 * v17 + 24);
          }

          else
          {
            if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_lock failed\n";
              __int16 v43 = 91;
LABEL_25:
              pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v43,  0,  v42,  v18,  v19,  v20,  v45);
              unsigned int v11 = "SharedArrayPop";
              __int16 v12 = 378;
              goto LABEL_26;
            }

            while (1)
            {
              int v21 = *(_DWORD *)(a1 + 128);
              if (v21) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(a1 + 208), (pthread_mutex_t *)(a1 + 144)))
              {
                uint64_t v42 = "SharedArrayPop: pthread_cond_wait failed\n";
                __int16 v43 = 94;
                goto LABEL_25;
              }
            }

            unsigned int v23 = v21 - 1;
            *(_DWORD *)(a1 + 128) = v23;
            uint64_t v17 = *(unsigned int *)(*(void *)(a1 + 136) + 4LL * v23);
            if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_unlock failed\n";
              __int16 v43 = 98;
              goto LABEL_25;
            }

            uint64_t v22 = 0LL;
            *(_DWORD *)(a1 + 384) = v17;
            size_t v28 = v16 + 32 * v17;
            *(void *)(v28 + 16) = 0LL;
            *(void *)(v28 + 24) = 0LL;
          }

          size_t v29 = v16;
          __int16 v30 = (uint64_t *)(v16 + 32 * v17);
          uint64_t v32 = v30 + 1;
          uint64_t v31 = v30[1];
          uint64_t v35 = *v30;
          uint64_t v34 = v30 + 3;
          uint64_t v33 = v35;
          unint64_t v36 = v31 - v22;
          if (v36 >= v14) {
            unint64_t v37 = v14;
          }
          else {
            unint64_t v37 = v36;
          }
          uint64_t v38 = a3(a4, v33 + v22, v37);
          if (v38 < 0)
          {
            unsigned int v11 = "stream read";
            __int16 v12 = 393;
            goto LABEL_26;
          }

          uint64_t v39 = v38;
          if (!v38) {
            break;
          }
          uint64_t v40 = *v34 + v38;
          *uint64_t v34 = v40;
          BOOL v41 = v40 == *v32;
          size_t v16 = v29;
          v15 += v39;
          v14 -= v39;
          if (!v14) {
            goto LABEL_32;
          }
        }

        if ((sendEOF((unsigned int *)a1) & 0x80000000) == 0)
        {
LABEL_32:
        }
      }

uint64_t sendEOF(unsigned int *a1)
{
  unsigned int v2 = a1 + 98;
  do
  {
    if (__ldaxr(v2))
    {
      uint64_t result = 0LL;
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v2));
  if ((currentWriteBufferFull(a1) & 0x80000000) == 0)
  {
    if ((SharedArrayEnqueue_0(a1, -2) & 0x80000000) == 0) {
      return 0LL;
    }
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"sendEOF",  351,  73,  0,  "SharedArrayEnqueue",  v4,  v5,  v7);
  }

  return 0xFFFFFFFFLL;
}

uint64_t currentWriteBufferFull(unsigned int *a1)
{
  unsigned int v1 = a1[96];
  a1[96] = -1;
  if (v1 > 3 || (SharedArrayEnqueue_0(a1, v1) & 0x80000000) == 0) {
    return 0LL;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"currentWriteBufferFull",  324,  73,  0,  "SharedArrayEnqueue",  v2,  v3,  vars0);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferAbort( size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    __int16 v9 = (unsigned int *)result;
    uint64_t v10 = (unsigned int *)(result + 400);
    do
    {
      if (__ldaxr(v10))
      {
        __clrex();
        return result;
      }
    }

    while (__stlxr(1u, v10));
    if ((SharedArrayPush((unsigned int *)(result + 128), -1) & 0x80000000) != 0) {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferAbort",  500,  73,  0,  "SharedArrayPush",  v12,  v13,  v16);
    }
    uint64_t result = SharedArrayEnqueue_0(v9, -1);
    if ((result & 0x80000000) != 0) {
      return pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)"SharedBufferAbort",  501,  73,  0,  "SharedArrayPush",  v14,  v15,  a9);
    }
  }

  return result;
}

uint64_t SharedBufferFlushToStream( size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  if (!a2) {
    return -1LL;
  }
  unint64_t v11 = a2;
  uint64_t v6 = 0LL;
  size_t v44 = a1 + 256;
  uint64_t v42 = (unsigned int *)(a1 + 396);
  __int16 v43 = (unsigned int *)(a1 + 128);
  while (1)
  {
    unint64_t v12 = *(unsigned int *)(a1 + 388);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    {
      uint64_t v35 = "SharedArrayPop: pthread_mutex_lock failed\n";
      __int16 v36 = 91;
      goto LABEL_26;
    }

    while (!*(_DWORD *)a1)
    {
      if (pthread_cond_wait((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16)))
      {
        uint64_t v35 = "SharedArrayPop: pthread_cond_wait failed\n";
        __int16 v36 = 94;
        goto LABEL_26;
      }
    }

    unsigned int v16 = *(_DWORD *)a1 - 1;
    *(_DWORD *)a1 = v16;
    unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 8) + 4LL * v16);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
    {
      uint64_t v35 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      __int16 v36 = 98;
LABEL_26:
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v36,  0,  v35,  v13,  v14,  v15,  v41);
      unint64_t v37 = "SharedBufferFlushToStream";
      uint64_t v38 = "SharedArrayDequeue";
      __int16 v39 = 448;
LABEL_27:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c",  (uint64_t)v37,  v39,  73,  0,  v38,  v30,  v31,  v41);
LABEL_28:
      SharedBufferAbort(a1, v17, v18, v19, v20, v13, v14, v15, v41);
      return -1LL;
    }

    if (v12 == 4294967294) {
      break;
    }
    if (v12 > 3) {
      goto LABEL_28;
    }
    *(_DWORD *)(a1 + 388) = v12;
LABEL_17:
    size_t v21 = v44 + 32 * v12;
    unsigned int v23 = (void *)(v21 + 24);
    uint64_t v22 = *(void *)(v21 + 24);
    uint64_t v26 = *(void *)(v21 + 16);
    uint64_t v25 = (void *)(v21 + 16);
    uint64_t v24 = v26;
    unint64_t v27 = v22 - v26;
    if (v27 >= v11) {
      unint64_t v28 = v11;
    }
    else {
      unint64_t v28 = v27;
    }
    uint64_t v29 = a3(a4, *(void *)(v44 + 32 * v12) + v24, v28);
    if (v29 <= 0)
    {
      unint64_t v37 = "SharedBufferFlushToStream";
      uint64_t v38 = "stream write";
      __int16 v39 = 469;
      goto LABEL_27;
    }

    uint64_t v32 = v29;
    uint64_t v33 = *v25 + v29;
    *uint64_t v25 = v33;
    if (v33 == *v23)
    {
      unsigned int v34 = *(_DWORD *)(a1 + 388);
      *(_DWORD *)(a1 + 388) = -1;
      if (v34 <= 3 && (SharedArrayPush(v43, v34) & 0x80000000) != 0)
      {
        unint64_t v37 = "currentReadBufferEmpty";
        uint64_t v38 = "SharedArrayPush";
        __int16 v39 = 337;
        goto LABEL_27;
      }
    }

    v6 += v32;
    v11 -= v32;
    if (!v11) {
      return v6;
    }
  }

  while (!__ldaxr(v42))
  {
    if (!__stlxr(1u, v42)) {
      return v6;
    }
  }

  __clrex();
  return v6;
}

uint64_t SharedArrayEnqueue_0(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    __int128 v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 157;
  }

  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    if (v10 >= v11)
    {
      int v12 = *a1;
    }

    else
    {
      if ((_DWORD)v10) {
        memmove((void *)(*((void *)a1 + 1) + 4LL), *((const void **)a1 + 1), 4 * v10);
      }
      **((_DWORD **)a1 + 1) = a2;
      int v12 = *a1;
    }

    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        __int128 v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 168;
      }

      else
      {
        __int128 v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 169;
      }
    }

    else
    {
      __int128 v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 166;
    }
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayEnqueue",  v9,  0,  v8,  v5,  v6,  v7,  v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedBufferWrite( unsigned int *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load(a1 + 100)) {
    return -1LL;
  }
  if (!a3) {
    return (int)sendEOF(a1);
  }
  uint64_t v10 = a2;
  return SharedBufferFillFromStream( (size_t)a1,  a3,  (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferReadFromBufferProc,  (uint64_t)&v10,  a5,  a6,  a7,  a8);
}

size_t SharedBufferReadFromBufferProc(const void **a1, void *__dst, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t SharedBufferRead(size_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5 = a2;
  return SharedBufferFlushToStream( a1,  a3,  (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferWriteToBufferProc,  (uint64_t)&v5);
}

size_t SharedBufferWriteToBufferProc(void **a1, const void *a2, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t *AARemoveArchiveOutputStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads = a5;
  if (!a5) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v10 = (uint64_t *)malloc(0x38uLL);
  unsigned int v11 = v10;
  if (v10) {
    memset_s(v10, 0x38uLL, 0, 0x38uLL);
  }
  int v12 = malloc(0x478uLL);
  uint64_t v13 = (uint64_t)v12;
  if (v12 && (memset_s(v12, 0x478uLL, 0, 0x478uLL), v11))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v13))
    {
      if (stat((const char *)v13, &v39) || (v39.st_mode & 0xF000) != 0x4000)
      {
        char v38 = (char)a1;
        unint64_t v27 = "Invalid directory: %s";
        __int16 v28 = 393;
        goto LABEL_24;
      }

      *(void *)(v13 + 1024) = a4;
      *(void *)(v13 + 1032) = a2;
      *(void *)(v13 + 1040) = a3;
      *(double *)(v13 + 1048) = getRealTime();
      *(_DWORD *)(v13 + 1120) = DefaultNThreads;
      unsigned int v16 = StringTableCreate();
      *(void *)(v13 + 1088) = v16;
      if (!v16)
      {
        unint64_t v27 = "string table creation";
        __int16 v28 = 402;
        goto LABEL_24;
      }

      uint64_t v17 = calloc(*(unsigned int *)(v13 + 1120), 8uLL);
      *(void *)(v13 + 1128) = v17;
      if (v17)
      {
        if (*(_DWORD *)(v13 + 1120))
        {
          unint64_t v18 = 0LL;
          while (1)
          {
            uint64_t v19 = malloc(0x1040uLL);
            uint64_t v20 = (uint64_t)v19;
            if (v19)
            {
              memset_s(v19, 0x1040uLL, 0, 0x1040uLL);
              *(_DWORD *)(v20 + 2064) = -1;
              *(void *)uint64_t v20 = v13;
              size_t v21 = StringTableCreate();
              *(void *)(v20 + 2072) = v21;
              if (v21) {
                goto LABEL_19;
              }
              __int16 v22 = 82;
              int v23 = 0;
              uint64_t v24 = "StringTableCreate";
            }

            else
            {
              int v23 = *__error();
              __int16 v22 = 78;
              uint64_t v24 = "malloc";
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"workerCreate",  v22,  123,  v23,  v24,  v14,  v15,  v38);
            workerDestroy(v20);
            uint64_t v20 = 0LL;
LABEL_19:
            *(void *)(*(void *)(v13 + 1128) + 8 * v18) = v20;
            uint64_t v25 = *(void *)(v13 + 1128);
            if (!*(void *)(v25 + 8 * v18))
            {
              unint64_t v27 = "creating new worker";
              __int16 v28 = 410;
              goto LABEL_24;
            }

            ++v18;
            uint64_t v17 = (void *)*(unsigned int *)(v13 + 1120);
          }
        }

        uint64_t v25 = (uint64_t)v17;
        LODWORD(v17) = 0;
LABEL_31:
        unint64_t v37 = ThreadPoolCreate(v17, v25, (uint64_t)workerProc_1);
        *(void *)(v13 + 1136) = v37;
        if (v37)
        {
          _OWORD v11[3] = (uint64_t)removeStreamWriteHeader;
          v11[4] = (uint64_t)removeStreamWriteBlob;
          uint64_t *v11 = v13;
          v11[1] = (uint64_t)removeStreamClose;
          v11[2] = (uint64_t)removeStreamAbort;
          return v11;
        }

        unint64_t v27 = "ThreadPoolCreate";
        __int16 v28 = 415;
LABEL_24:
        int v26 = 0;
      }

      else
      {
        int v26 = *__error();
        unint64_t v27 = "malloc";
        __int16 v28 = 406;
      }
    }

    else
    {
      int v26 = *__error();
      char v38 = (char)a1;
      unint64_t v27 = "%s";
      __int16 v28 = 392;
    }
  }

  else
  {
    int v26 = *__error();
    unint64_t v27 = "malloc";
    __int16 v28 = 391;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"AARemoveArchiveOutputStreamOpen",  v28,  123,  v26,  v27,  v14,  v15,  v38);
  free(v11);
  removeStreamClose(v13, v29, v30, v31, v32, v33, v34, v35);
  return 0LL;
}

uint64_t workerProc_1(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)(a1 + 2080))
  {
    unint64_t v3 = 0LL;
    uint64_t v4 = (unsigned int *)(a1 + 2088);
    while ((processEntry(a1, v4, *(void *)(a1 + 2072)) & 0x80000000) == 0)
    {
      ++v3;
      v4 += 2;
      if (v3 >= *(void *)(a1 + 2080)) {
        goto LABEL_5;
      }
    }

    __int16 v11 = 185;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"workerProc",  v11,  123,  0,  "entry failed",  v5,  v6,  v15);
    int v12 = (unsigned int *)(v2 + 1056);
    while (!__ldaxr(v12))
    {
      if (!__stlxr(1u, v12)) {
        return 0LL;
      }
    }

    __clrex();
  }

  else
  {
LABEL_5:
    unint64_t v7 = *(void *)(a1 + 4136);
    unint64_t v8 = *(void *)(a1 + 4144);
    if (v7 < v8)
    {
      uint64_t v9 = 8 * v7;
      do
      {
        uint64_t v10 = *(void *)(v2 + 1112) + v9;
        if (*(_DWORD *)(a1 + 4152) == *(unsigned __int16 *)(v10 + 6))
        {
          if ((processEntry(a1, (unsigned int *)v10, *(void *)(v2 + 1088)) & 0x80000000) != 0)
          {
            __int16 v11 = 193;
            goto LABEL_14;
          }

          unint64_t v8 = *(void *)(a1 + 4144);
        }

        ++v7;
        v9 += 8LL;
      }

      while (v7 < v8);
    }
  }

  return 0LL;
}

uint64_t removeStreamClose( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(void *)(result + 1024);
    if (atomic_load((unsigned int *)(result + 1056)))
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"removeStreamClose",  314,  123,  0,  "stream cancelled",  a7,  a8,  v38);
      int v11 = 0;
    }

    else
    {
      int v11 = 1;
    }

    uint64_t v12 = *(void *)(v8 + 1080);
    if (v12)
    {
      if ((ThreadPoolRunWorker(*(void *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"removeStreamClose",  319,  123,  0,  "ThreadPoolRunWorker",  a7,  a8,  v38);
        int v11 = 0;
      }

      *(void *)(v8 + 1080) = 0LL;
    }

    uint64_t v13 = *(void *)(v8 + 1104);
    if (v13)
    {
      unsigned int v14 = 0;
      char v15 = (unsigned __int16 *)(*(void *)(v8 + 1112) + 6LL);
      unint64_t v16 = (v13 + (unint64_t)*(unsigned int *)(v8 + 1120) - 1) / (4 * *(_DWORD *)(v8 + 1120));
      do
      {
        unsigned int v18 = *v15;
        v15 += 4;
        unsigned int v17 = v18;
        if (v18 > v14) {
          unsigned int v14 = v17;
        }
        --v13;
      }

      while (v13);
      uint64_t v19 = v16 <= 0xC8 ? 200LL : v16;
      if (v11)
      {
        while (1)
        {
          if (*(void *)(v8 + 1104))
          {
            unint64_t v20 = 0LL;
            while (1)
            {
              uint64_t Worker = ThreadPoolGetWorker(*(void *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8);
              if (!Worker)
              {
                __int16 v28 = 335;
                uint64_t v29 = "ThreadPoolGetWorker";
                goto LABEL_28;
              }

              *(void *)(Worker + 2080) = 0LL;
              *(void *)(Worker + 4136) = v20;
              v20 += v19;
              unint64_t v26 = *(void *)(v8 + 1104);
              if (v20 < v26) {
                unint64_t v26 = v20;
              }
              *(void *)(Worker + 4144) = v26;
              *(_DWORD *)(Worker + 4152) = v14;
              if ((ThreadPoolRunWorker(*(void *)(v8 + 1136), Worker, v22, v23, v24, v25, a7, a8) & 0x80000000) != 0) {
                break;
              }
              if (v20 >= *(void *)(v8 + 1104)) {
                goto LABEL_25;
              }
            }

            __int16 v28 = 340;
            uint64_t v29 = "ThreadPoolRunWorker";
LABEL_28:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"removeStreamClose",  v28,  123,  0,  v29,  a7,  a8,  v38);
            int v11 = 0;
            char v27 = 1;
          }

          else
          {
LABEL_25:
            char v27 = 0;
            int v11 = 1;
          }

          ThreadPoolSync(*(unsigned int **)(v8 + 1136));
          if (!v14) {
            break;
          }
          --v14;
          if ((v27 & 1) != 0)
          {
            int v11 = 0;
            break;
          }
        }
      }
    }

    ThreadPoolDestroy(*(void *)(v8 + 1136));
    uint64_t v30 = *(void **)(v8 + 1128);
    if (v30)
    {
      if (*(_DWORD *)(v8 + 1120))
      {
        unint64_t v31 = 0LL;
        do
          workerDestroy(*(void *)(*(void *)(v8 + 1128) + 8 * v31++));
        while (v31 < *(unsigned int *)(v8 + 1120));
        uint64_t v30 = *(void **)(v8 + 1128);
      }

      free(v30);
    }

    StringTableDestroy(*(void ***)(v8 + 1088));
    free(*(void **)(v8 + 1112));
    if (v11 && v9 >> 62)
    {
      double v32 = getRealTime() - *(double *)(v8 + 1048);
      uint64_t v33 = (FILE **)MEMORY[0x1895F89D0];
      fwrite("Remove archive\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      uint64_t v34 = *v33;
      unint64_t v35 = atomic_load((unint64_t *)(v8 + 1064));
      fprintf(v34, "%12llu entries removed\n", v35);
      __int16 v36 = *v33;
      unint64_t v37 = atomic_load((unint64_t *)(v8 + 1072));
      fprintf(v36, "%12llu entries skipped\n", v37);
      fprintf(*v33, "%12.2f time (s)\n", v32);
    }

    free((void *)v8);
    if (v11) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t removeStreamWriteHeader(uint64_t a1, AAHeader header)
{
  *(void *)&v65[1023] = *MEMORY[0x1895F89C0];
  uint64_t value = -1LL;
  v7.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v7);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    uint64_t v25 = "AA entry missing TYP field";
    __int16 v26 = 215;
LABEL_21:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"removeStreamWriteHeader",  v26,  123,  v25,  v9,  v10,  v11,  v59);
    goto LABEL_22;
  }

  if (value == 77) {
    goto LABEL_22;
  }
  length[0] = 0LL;
  v12.uint64_t ikey = 5521744;
  uint32_t v13 = AAHeaderGetKeyIndex(header, v12);
  if ((v13 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v13, 0x400uLL, &__s, length) >= 2)
  {
    uint64_t v25 = "AA entry missing/invalid PAT field";
    __int16 v26 = 224;
    goto LABEL_21;
  }

  unsigned int v18 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 1040);
  if (v18)
  {
    int v19 = v18(*(void *)(a1 + 1032), 80LL, &__s, header);
    if (v19 < 0)
    {
      __int16 v28 = "user cancelled";
      __int16 v29 = 234;
      goto LABEL_49;
    }

    if (v19)
    {
LABEL_22:
      int v27 = 1;
      goto LABEL_23;
    }

    int v20 = (*(uint64_t (**)(void, uint64_t, char *, size_t *))(a1 + 1040))( *(void *)(a1 + 1032),  81LL,  &__s,  length);
    if (v20 < 0)
    {
      __int16 v28 = "user cancelled";
      __int16 v29 = 239;
      goto LABEL_49;
    }

    if (v20) {
      __strlcpy_chk();
    }
  }

  if (value != 68)
  {
    uint64_t v30 = *(void *)(a1 + 1080);
    if (!v30)
    {
      uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1136), v14, v15, v16, v17, v9, v10, v11);
      *(void *)(a1 + 1080) = Worker;
      if (!Worker)
      {
        __int16 v28 = "ThreadPoolGetWorker";
        __int16 v29 = 269;
        goto LABEL_49;
      }

      uint64_t v30 = Worker;
      *(void *)(Worker + 2080) = 0LL;
      StringTableClear(*(void *)(Worker + 2072));
      *(_OWORD *)(v30 + 4136) = 0u;
      *(_DWORD *)(v30 + 4152) = -1;
    }

    int v60 = 0;
    size_t v32 = strlen(&__s);
    if ((StringTableAppend(*(unsigned int **)(v30 + 2072), &__s, v32, &v60, v33, v34, v35, v36) & 0x80000000) != 0)
    {
      __int16 v28 = "StringTableAppend";
      __int16 v29 = 278;
      goto LABEL_49;
    }

    uint64_t v41 = *(void *)(v30 + 2080);
    uint64_t v42 = v30 + 8 * v41++;
    *(void *)(v30 + 2080) = v41;
    *(_DWORD *)(v42 + 2088) = v60;
    *(_WORD *)(v42 + 2092) = value;
    *(_WORD *)(v42 + 2094) = 0;
    if (v41 == 256)
    {
      if ((ThreadPoolRunWorker(*(void *)(a1 + 1136), v30, v37, v38, v39, v40, v10, v11) & 0x80000000) != 0)
      {
        __int16 v28 = "ThreadPoolRunWorker";
        __int16 v29 = 287;
        goto LABEL_49;
      }

      *(void *)(a1 + 1080) = 0LL;
    }

    goto LABEL_22;
  }

  uint64_t v21 = *(void *)(a1 + 1104);
  if (v21 == *(void *)(a1 + 1096))
  {
    uint64_t v22 = 2 * v21;
    BOOL v23 = v21 == 0;
    uint64_t v24 = 256LL;
    if (!v23) {
      uint64_t v24 = v22;
    }
    *(void *)(a1 + 1096) = v24;
    if ((unint64_t)(8 * v24) >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_52:
      *(void *)(a1 + 1096) = 0LL;
      *(void *)(a1 + 1104) = 0LL;
      *(void *)(a1 + 1112) = 0LL;
      int v58 = *__error();
      __int16 v28 = "malloc";
      __int16 v29 = 250;
      goto LABEL_50;
    }

    __int16 v43 = *(void **)(a1 + 1112);
    size_t v44 = realloc(v43, 8 * v24);
    if (!v44)
    {
      free(v43);
      goto LABEL_52;
    }

    *(void *)(a1 + 1112) = v44;
  }

  int v61 = 0;
  size_t v45 = strlen(&__s);
  if ((StringTableAppend(*(unsigned int **)(a1 + 1088), &__s, v45, &v61, v46, v47, v48, v49) & 0x80000000) == 0)
  {
    uint64_t v50 = *(void *)(a1 + 1112);
    uint64_t v51 = *(void *)(a1 + 1104);
    *(void *)(a1 + 1104) = v51 + 1;
    uint64_t v52 = v50 + 8 * v51;
    *(_DWORD *)uint64_t v52 = v61;
    *(_WORD *)(v52 + 4) = value;
    *(_WORD *)(v52 + 6) = 0;
    uint64_t v53 = (_WORD *)(v52 + 6);
    int v54 = __s;
    if (__s)
    {
      __int16 v55 = 0;
      uint64_t v56 = v65;
      do
      {
        if (v54 == 47) {
          ++v55;
        }
        *uint64_t v53 = v55;
        int v57 = *v56++;
        int v54 = v57;
      }

      while (v57);
    }

    goto LABEL_22;
  }

  __int16 v28 = "StringTableAppend";
  __int16 v29 = 253;
LABEL_49:
  int v58 = 0;
LABEL_50:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"removeStreamWriteHeader",  v29,  123,  v58,  v28,  v10,  v11,  v59);
  int v27 = 0;
LABEL_23:
  if (v27) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeStreamWriteBlob(uint64_t a1)
{
  else {
    return 0LL;
  }
}

uint64_t removeStreamAbort(uint64_t result)
{
  unsigned int v1 = (unsigned int *)(result + 1056);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

void workerDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 2064);
    if ((v2 & 0x80000000) == 0) {
      close(v2);
    }
    StringTableDestroy(*(void ***)(a1 + 2072));
    free((void *)a1);
  }

uint64_t processEntry(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(char **)a1;
  uint64_t v6 = (const char *)(*(void *)(a3 + 32) + *(void *)(*(void *)(a3 + 8) + 16LL * *a2));
  if ((concatPath(__s, 0x400uLL, *(char **)a1, v6) & 0x80000000) != 0)
  {
    uint64_t v17 = "invalid path";
    __int16 v18 = 114;
LABEL_11:
    int v19 = 0;
    goto LABEL_12;
  }

  uint64_t v9 = strrchr(__s, 47);
  if (!v9)
  {
    uint64_t v17 = "invalid path";
    __int16 v18 = 118;
    goto LABEL_11;
  }

  uint64_t v10 = v9;
  char *v9 = 0;
  uint64_t v11 = v9 + 1;
  size_t v12 = strlen(__s);
  size_t v15 = v12;
  int v16 = *(_DWORD *)(a1 + 2064);
  if ((v16 & 0x80000000) == 0)
  {
    close(v16);
    *(_DWORD *)(a1 + 2064) = -1;
  }

  if (v15 >= 0x800)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c",  (uint64_t)"workerUpdateDir",  95,  123,  0,  "directory path too long",  v13,  v14,  v38);
    goto LABEL_19;
  }

  *(void *)(a1 + 2056) = v15;
  memcpy((void *)(a1 + 8), __s, v15);
  *(_BYTE *)(a1 + 8 + v15) = 0;
  int v23 = open((const char *)(a1 + 8), 0);
  *(_DWORD *)(a1 + 2064) = v23;
  if (v23 < 0)
  {
LABEL_19:
    __int16 v28 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (!v28) {
      goto LABEL_28;
    }
    int v29 = v28(*((void *)v5 + 129), 82LL, v6, 0LL);
    if (!v29) {
      goto LABEL_28;
    }
    BOOL v26 = 0;
    BOOL v27 = v29 >= 0;
    goto LABEL_26;
  }

LABEL_26:
  if (!v27) {
    goto LABEL_13;
  }
  if (!v26)
  {
    uint64_t v34 = (unint64_t *)(v5 + 1064);
    do
      unint64_t v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
    return 0LL;
  }

  int v24 = (const void *)*((void *)v8 + 2);
  if (v24) {
    _Block_release(v24);
  }
  free(v8);
  return v4;
}

    CC_SHA384_Update((CC_SHA512_CTX *)(a1 + 360), __src, __smax);
    __int16 v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 0x10) == 0)
    {
LABEL_21:
      if ((v18 & 1) == 0) {
        goto LABEL_22;
      }
      goto LABEL_28;
    }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"processSegment",  v19,  98,  0,  v18,  a8,  a9,  v25);
  return 0xFFFFFFFFLL;
}

      if (v24 != v22)
      {
        uint64_t v40 = "writing data to temp file";
        uint64_t v41 = 43;
        goto LABEL_57;
      }

      v21 += v22;
      if ((unint64_t)++v20 >= *v19)
      {
        if (!*v19) {
          goto LABEL_31;
        }
        break;
      }
    }

    __int16 v28 = 0LL;
    do
      free(*(void **)(*(void *)(a1 + 32) + 8 * v28++));
    while (v28 < *(void *)(a1 + 24));
  }

  BOOL v27 = (unsigned int *)create();
  if (!v27) {
    return (AAPathList)v27;
  }
  uint64_t v113 = DefaultNThreads;
  __int16 v28 = strlen(v119);
  if (v28)
  {
    int v29 = v28;
    uint64_t v30 = 0LL;
    int v31 = 0LL;
    size_t v32 = *((void *)v27 + 1) + 24LL * v27[7];
    *(_DWORD *)(v32 + 16) |= 1u;
    do
    {
      unint64_t v33 = v119[v31];
      if (v33 == 47 || v33 == 0)
      {
        *(_DWORD *)uint64_t v118 = -1;
        if ((increaseCapacity((uint64_t)v27, *v27 + 1) & 0x80000000) != 0)
        {
          uint64_t v101 = "increase PathList capacity";
          __int16 v102 = 553;
LABEL_113:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  v102,  60,  0,  v101,  v37,  v38,  v106);
          uint64_t v48 = 0LL;
          uint64_t v49 = 0LL;
          uint64_t v47 = 0LL;
          uint64_t v46 = 0LL;
          uint64_t v50 = 0;
          int DefaultNThreads = v113;
          goto LABEL_50;
        }

        if ((StringTableAppend(*((unsigned int **)v27 + 2), &v119[v30], v31 - v30, v118, v35, v36, v37, v38) & 0x80000000) != 0)
        {
          uint64_t v101 = "inserting path component in table";
          __int16 v102 = 554;
          goto LABEL_113;
        }

        stat v39 = *v27;
        uint64_t v40 = (_DWORD *)(*((void *)v27 + 1) + 24LL * *v27);
        *uint64_t v40 = *v27 - 1;
        v40[3] = *(_DWORD *)v118;
        v40[4] = v33 != 0;
        *BOOL v27 = v39 + 1;
        if (!v33) {
          break;
        }
        uint64_t v30 = ++v31;
      }

      ++v31;
    }

    while (v31 <= v29);
  }

  int DefaultNThreads = v113;
  if (!v12) {
    goto LABEL_43;
  }
  uint64_t v41 = v12(v14, 11LL, v119, 0LL);
  if (v41 < 0)
  {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c",  (uint64_t)"AAPathListCreateWithDirectoryContents",  570,  60,  "abort from callback",  v42,  v43,  v44,  v106);
    goto LABEL_48;
  }

  if (v41)
  {
    size_t v45 = *((void *)v27 + 1) + 24LL * (*v27 - 1);
    *(_DWORD *)(v45 + 16) |= 1u;
  }

    int v16 = *(void **)(a1 + 32);
    uint64_t v17 = (char *)realloc(v16, v10);
    if (v17)
    {
      size_t v15 = v17;
      *(void *)(a1 + 24) = v10;
      *(void *)(a1 + 32) = v17;
      uint64_t v7 = *(void *)(a1 + 16);
      goto LABEL_28;
    }

    free(v16);
LABEL_30:
    uint64_t result = 0LL;
    *(void *)(a1 + 32) = 0LL;
    *int v2 = 0LL;
    v2[1] = 0LL;
  }

  return result;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"AAHeaderSetFieldTimespec",  v24,  101,  0,  v23,  v6,  v7,  v26);
  return -1;
}

  if (v29 != EncodedSize)
  {
    size_t v32 = "write header";
    unint64_t v33 = 431;
    goto LABEL_36;
  }

  if (v12 != -1)
  {
    if (s)
    {
      if (AAByteStreamSeek(s, 0LL, 0) < 0)
      {
        size_t v32 = "seek dat stream";
        unint64_t v33 = 437;
        goto LABEL_36;
      }

      uint64_t v34 = AAByteStreamProcess(s, a1);
      if ((v34 & 0x8000000000000000LL) == 0 && v34 == v12) {
        goto LABEL_32;
      }
    }

    size_t v32 = "write blob";
    unint64_t v33 = 440;
LABEL_36:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetGenerate.c",  (uint64_t)"encodeYOPEntry",  v33,  27,  0,  v32,  v15,  v16,  v37);
    goto LABEL_37;
  }

    int v31 = 0LL;
    size_t v32 = 0LL;
    char __s = 0LL;
    uint64_t v13 = "alloc buffer";
    size_t v12 = 332;
    goto LABEL_27;
  }

  uint64_t v22 = fgetxattr(fd, "com.apple.ResourceFork", 0LL, 0LL, 0, 32);
  uint64_t v21 = 0LL;
LABEL_20:
  if (v22 != v17)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAFSCStream.c",  (uint64_t)"loadChunkOffsets",  335,  55,  0,  "read resource fork header",  v23,  v24,  v29);
    goto LABEL_28;
  }

  char __s = v9 & 0xFFFFFFFC;
  if (a2 == 4)
  {
    *a4 = v9;
    if (a3)
    {
      int v25 = 0LL;
      BOOL v26 = a4 + 1;
      do
      {
        LODWORD(v9) = v9 + *(_DWORD *)&v21[v25 + 268];
        *v26++ = v9;
        v25 += 8LL;
      }

      while (8LL * a3 != v25);
    }
  }

  else
  {
    memcpy(a4, v21, v9 & 0xFFFFFFFC);
  }

  BOOL v27 = 0LL;
LABEL_29:
  free(v21);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  return v27;
}

    __int16 v28 = *(void *)(a1 + 360);
    if (v28 <= a3)
    {
      if (v28 < a3)
      {
        int v31 = 0LL;
        size_t v32 = 0LL;
        unint64_t v33 = 0LL;
        uint64_t v34 = *(void *)(a1 + 344);
        do
        {
          if (!*(void *)(v34 + v32))
          {
            uint64_t v48 = (char *)(v34 + v32);
            goto LABEL_63;
          }

          ++v33;
          v32 += 24LL;
          v31 += 2LL;
        }

        while (v33 != *(void *)(a1 + 352));
        if (*(_DWORD *)(a1 + 388))
        {
          int v29 = "too many writes pending";
          uint64_t v30 = 190;
          goto LABEL_28;
        }

        if (v33 < 0)
        {
          int v29 = "too many writes pending";
          uint64_t v30 = 198;
          goto LABEL_28;
        }

        if (is_mul_ok(v31, 0x18uLL) && 24 * v31 <= 0x2000000000LL)
        {
          uint64_t v50 = (char *)calloc(v31, 0x18uLL);
          if (v50)
          {
            uint64_t v51 = v50;
            memcpy(v50, *(const void **)(a1 + 344), 24LL * *(void *)(a1 + 352));
            free(*(void **)(a1 + 344));
            *(void *)(a1 + 344) = v51;
            *(void *)(a1 + 352) = v31;
            uint64_t v48 = &v51[v32];
LABEL_63:
            if (v10 < 0x2000000001LL)
            {
              uint64_t v49 = malloc(v10);
              *(void *)uint64_t v48 = v49;
              if (v49)
              {
                memcpy(v49, a4, v10);
                BOOL v27 = 0LL;
                *((void *)v48 + 1) = a3;
                *((void *)v48 + 2) = v10;
                goto LABEL_60;
              }
            }

            else
            {
              *__error() = 12;
              *(void *)uint64_t v48 = 0LL;
            }

            int v29 = "malloc";
            uint64_t v30 = 217;
            goto LABEL_28;
          }
        }

        else
        {
          *__error() = 12;
        }

        int v29 = "too many writes pending";
        uint64_t v30 = 200;
        goto LABEL_28;
      }

      unint64_t v35 = 0LL;
      uint64_t v36 = (unint64_t *)(a1 + 368);
      while (1)
      {
        int v37 = *(void *)(a1 + 8);
        if (*(void *)(v37 + 24))
        {
          char v38 = 0LL;
          if (v10)
          {
            stat v39 = v10;
            while (1)
            {
              uint64_t v40 = (*(uint64_t (**)(void, char *, size_t))(v37 + 24))(*(void *)v37, a4, v39);
              if (v40 < 1) {
                break;
              }
              a4 += v40;
              v38 += v40;
              v39 -= v40;
              if (!v39) {
                goto LABEL_44;
              }
            }

            char v38 = v40;
          }
        }

        else
        {
          char v38 = -1LL;
        }

uint64_t AEADecryptToFileChunk( void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, unsigned int a9)
{
  int v9 = a8;
  uint64_t v30 = 0LL;
  v29[0] = a2;
  v29[1] = a4;
  v29[2] = a5;
  v29[3] = a8 >> 62;
  LODWORD(v30) = a1[10] != 0LL;
  uint64_t v11 = (uint64_t (**)(void))AEADecryptToFileChunkAsyncStreamOpen( a3,  (uint64_t)v29,  (uint64_t)asyncContext_0,  (uint64_t)asyncProgress_0,  a6,  a7,  a8,  a9);
  uint64_t v14 = v11;
  if (!v11)
  {
    __int16 v18 = "AEADecryptToFileAsyncStreamOpen";
    __int16 v19 = 87;
LABEL_18:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c",  (uint64_t)"AEADecryptToFileChunk",  v19,  56,  0,  v18,  v12,  v13,  v26);
    int v20 = 0;
    goto LABEL_19;
  }

  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(v11, a1, v9, a9) & 0x8000000000000000LL) == 0)
    {
      int v20 = 1;
      goto LABEL_19;
    }

    __int16 v18 = "AAAsyncByteStreamProcessAllRanges";
    __int16 v19 = 115;
    goto LABEL_18;
  }

  while (1)
  {
    uint64_t v27 = 0LL;
    unint64_t v28 = 0LL;
    int Range = AAAsyncByteStreamGetRange(v14, &v28, &v27);
    if (Range < 0) {
      break;
    }
    if (Range)
    {
      if (!v28)
      {
        int v20 = 1;
        goto LABEL_16;
      }

      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        uint64_t v21 = "AAByteStreamPReadAsync";
        __int16 v22 = 104;
        goto LABEL_15;
      }
    }

    else
    {
      usleep(0x186A0u);
    }
  }

  uint64_t v21 = "AAAsyncByteStreamGetRange";
  __int16 v22 = 99;
LABEL_15:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c",  (uint64_t)"AEADecryptToFileChunk",  v22,  56,  0,  v21,  v16,  v17,  v26);
  int v20 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    __int16 v18 = "AAByteStreamPReadAsync barrier";
    __int16 v19 = 109;
    goto LABEL_18;
  }

uint64_t asyncContext_0(uint64_t result, _OWORD *context)
{
  unint64_t v3 = (_DWORD *)result;
  uint64_t v4 = *(void *)result;
  if (*(_DWORD *)(result + 28))
  {
    *(_OWORD *)uint64_t v4 = *context;
    __int128 v5 = context[1];
    __int128 v6 = context[2];
    __int128 v7 = context[3];
    *(void *)(v4 + 64) = *((void *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 24))
    {
      uint64_t v8 = (FILE **)MEMORY[0x1895F89D0];
      int v9 = (FILE *)*MEMORY[0x1895F89D0];
      int FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            size_t v15 = "none";
            goto LABEL_25;
          case 256:
            size_t v15 = "lz4";
            goto LABEL_25;
          case 774:
            size_t v15 = "lzma";
LABEL_25:
            uint64_t v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            uint64_t v17 = *v8;
            unsigned int v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2) {
              __int16 v19 = "???";
            }
            else {
              __int16 v19 = off_189E3AED8[v18];
            }
            fprintf(v17, "  checksum: %s\n", v19);
            int v20 = *v8;
            uint64_t v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            __int16 v22 = *v8;
            uint64_t v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            if (v3[8]) {
              uint64_t v24 = "yes";
            }
            else {
              uint64_t v24 = "no";
            }
            fprintf(*v8, "  async read stream: %s\n", v24);
            return 0LL;
        }
      }

      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            size_t v15 = "zlib";
            goto LABEL_25;
          }

          if (FieldUInt != 1794) {
            goto LABEL_24;
          }
          goto LABEL_20;
        }

        if (FieldUInt == 2049)
        {
LABEL_20:
          size_t v15 = "lzfse";
          goto LABEL_25;
        }

        if (FieldUInt == 2304)
        {
          size_t v15 = "lzvn";
          goto LABEL_25;
        }
      }

uint64_t asyncProgress_0(uint64_t a1)
{
  unsigned int v1 = *(uint64_t (**)(void))(a1 + 16);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0LL;
  }
}

uint64_t AEADecryptToFile( void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  return AEADecryptToFileChunk(a1, a2, a3, a4, a5, 0LL, 0LL, a6, a7);
}

uint64_t aaCompositeChunkAsyncStreamOpen( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v5 = a1;
  if (a1 && a2)
  {
    uint64_t v10 = malloc(0x10uLL);
    uint64_t v11 = (uint64_t)v10;
    if (v10)
    {
      memset_s(v10, 0x10uLL, 0, 0x10uLL);
      *(void *)uint64_t v11 = v5;
      size_t v15 = AAChunkAsyncStreamOpen(v5, a2, a3, a4 | 0x200000000000000LL, a5, v12, v13, v14);
      *(void *)(v11 + 8) = v15;
      if (v15)
      {
        unsigned int v18 = aaAsyncByteStreamAlloc(v11, (uint64_t)compositeChunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
        if (v18)
        {
          uint64_t v5 = (uint64_t)v18;
          v18[2] = compositeChunkAsyncGetRange;
          v18[3] = compositeChunkAsyncProcess;
          v18[4] = compositeChunkAsyncCancel;
          v18[5] = compositeChunkAsyncIsCancelled;
          return v5;
        }

        int v20 = "async stream alloc";
        __int16 v21 = 89;
      }

      else
      {
        int v20 = "AAChunkAsyncStreamOpen";
        __int16 v21 = 86;
      }

      int v19 = 0;
    }

    else
    {
      int v19 = *__error();
      int v20 = "malloc";
      __int16 v21 = 78;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompositeChunkAsyncStream.c",  (uint64_t)"aaCompositeChunkAsyncStreamOpen",  v21,  145,  v19,  v20,  v16,  v17,  v23);
    compositeChunkAsyncClose((uint64_t (***)(void))v11);
    AAAsyncByteStreamClose(0LL);
    return 0LL;
  }

  return v5;
}

uint64_t (***compositeChunkAsyncClose(uint64_t (***result)(void)))(void)
{
  if (result)
  {
    unsigned int v1 = result;
    int v2 = AAAsyncByteStreamClose(result[1]);
    int v3 = AAAsyncByteStreamClose(*v1) | v2;
    free(v1);
    return (uint64_t (***)(void))(v3 >> 31);
  }

  return result;
}

uint64_t compositeChunkAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*(void **)(a1 + 8), a2, a3);
}

uint64_t compositeChunkAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(void *)(a1 + 8), a2, a3, a4);
}

void *compositeChunkAsyncCancel(uint64_t a1)
{
  return AAAsyncByteStreamCancel(*(void **)(a1 + 8));
}

uint64_t compositeChunkAsyncIsCancelled(uint64_t a1)
{
  return aaAsyncByteStreamIsCancelled(*(void **)(a1 + 8));
}

void aeaContainerDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(void **)(a1 + 384);
    if (v2) {
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    }
    free(v2);
    int v3 = *(void **)(a1 + 392);
    if (v3) {
      memset_s(*(void **)(a1 + 392), 544LL * *(unsigned int *)(a1 + 400), 0, 544LL * *(unsigned int *)(a1 + 400));
    }
    free(v3);
    memset_s((void *)a1, 0x6C0uLL, 0, 0x6C0uLL);
    free((void *)a1);
  }

uint64_t aeaContainerCreateNew(uint64_t a1)
{
  int v2 = malloc(0x6C0uLL);
  uint64_t v3 = (uint64_t)v2;
  if (!v2)
  {
    int v14 = *__error();
    uint64_t v12 = "malloc";
    __int16 v13 = 22;
    goto LABEL_28;
  }

  memset_s(v2, 0x6C0uLL, 0, 0x6C0uLL);
  __int128 v4 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v3 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v3 + 48) = v4;
  *(void *)(v3 + 64) = *(void *)(a1 + 64);
  __int128 v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a1;
  *(_OWORD *)(v3 + 16) = v5;
  if ((aeaCryptoInit((char *)(v3 + 72), (unsigned int *)v3) & 0x80000000) != 0)
  {
    uint64_t v12 = "Invalid context";
    __int16 v13 = 28;
    goto LABEL_27;
  }

  size_t v8 = *(unsigned int *)(v3 + 4);
  if ((_DWORD)v8)
  {
    int v9 = malloc(*(unsigned int *)(v3 + 4));
    *(void *)(v3 + 384) = v9;
    if (v9)
    {
      memcpy(v9, *(const void **)(a1 + 2712), v8);
      goto LABEL_6;
    }

    int v14 = *__error();
    uint64_t v12 = "malloc";
    __int16 v13 = 34;
LABEL_28:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateNew",  v13,  28,  v14,  v12,  v6,  v7,  v19);
    aeaContainerDestroy(v3);
    return 0LL;
  }

LABEL_10:
  if ((aeaContainerOffsetsInit(v3 + 280, (unsigned int *)v3, (unsigned int *)(v3 + 72)) & 0x80000000) != 0)
  {
    uint64_t v12 = "deriving container offsets";
    __int16 v13 = 59;
    goto LABEL_27;
  }

  uint64_t v11 = *(void *)(v3 + 344);
  *(void *)(v3 + 32) = 0LL;
  *(void *)(v3 + 40) = v11;
  if ((aeaDeriveMainKeyNew( (unsigned int *)(v3 + 72),  (int *)v3,  (__int128 *)(v3 + 668),  (int *)(v3 + 928),  (char *)(v3 + 408),  (int *)(a1 + 72),  (_DWORD *)(a1 + 2152),  (unsigned int *)(a1 + 332),  (unsigned int *)(a1 + 852)) & 0x80000000) != 0)
  {
    uint64_t v12 = "Main key derivation";
    __int16 v13 = 75;
LABEL_27:
    int v14 = 0;
    goto LABEL_28;
  }

  return v3;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"OECCStreamCreate",  v12,  64,  v13,  v11,  v9,  v10,  v17);
  OECCStreamDestroy((void **)v7);
  return 0LL;
}

        ++v3;
        int v2 = *(void *)(v1 + 248);
      }

      while (v3 < v2);
    }

    else
    {
      __int128 v4 = 1;
    }

    uint64_t v11 = *(void *)(v1 + 24);
    if (v11)
    {
      uint64_t v12 = 0LL;
      __int16 v13 = *(uint64_t **)(v1 + 32);
      do
      {
        int v14 = *v13;
        v13 += 19;
        if (v14) {
          ++v12;
        }
        --v11;
      }

      while (v11);
      if (v12)
      {
        size_t v15 = 0LL;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 56)))
          {
            char v19 = 91;
            int v20 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_25:
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v19,  0,  v20,  v16,  v17,  v18,  v38);
            uint64_t v24 = -1;
          }

          else
          {
            while (1)
            {
              __int16 v21 = *(_DWORD *)(v1 + 40);
              if (v21) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 120), (pthread_mutex_t *)(v1 + 56)))
              {
                char v19 = 94;
                int v20 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_25;
              }
            }

            int v31 = v21 - 1;
            *(_DWORD *)(v1 + 40) = v31;
            uint64_t v24 = *(_DWORD *)(*(void *)(v1 + 48) + 4LL * v31);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 56))) {
              goto LABEL_27;
            }
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  98,  0,  "SharedArrayPop: pthread_mutex_unlock failed\n",  v32,  v33,  v34,  v38);
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamClose",  346,  59,  0,  "SharedArrayPop",  v22,  v23,  v39);
          __int128 v4 = 0;
LABEL_27:
          int v25 = *(void *)(v1 + 32);
          char v26 = v25 + 152LL * v24;
          *(void *)(v26 + 16) = 0LL;
          *(void *)(v26 + 24) = 0LL;
          if (pthread_mutex_lock((pthread_mutex_t *)(v26 + 40))
            || (v29 = v25 + 152LL * v24, uint64_t v30 = *(_DWORD *)(v29 + 32), *(_DWORD *)(v29 + 32) = v30 + 1, !v30)
            && pthread_cond_broadcast((pthread_cond_t *)(v25 + 152LL * v24 + 104))
            || pthread_mutex_unlock((pthread_mutex_t *)(v26 + 40)))
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamClose",  350,  59,  0,  "SemRelease",  v27,  v28,  v38);
            __int128 v4 = 0;
          }

          if ((joinThread(*(_opaque_pthread_t **)v26) & 0x80000000) != 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamClose",  351,  59,  0,  "joinThread",  v35,  v36,  v38);
            __int128 v4 = 0;
          }

          if (!pthread_mutex_destroy((pthread_mutex_t *)(v26 + 40))) {
            pthread_cond_destroy((pthread_cond_t *)(v25 + 152LL * v24 + 104));
          }
          if (++v15 == v12)
          {
            int v2 = *(void *)(v1 + 248);
            break;
          }
        }
      }
    }

    if (v2)
    {
      int v37 = 0LL;
      do
        chunkDestroy(*(void ***)(*(void *)(v1 + 256) + 8 * v37++));
      while (v37 < *(void *)(v1 + 248));
    }

    free(*(void **)(v1 + 256));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 176));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 120))) {
      free(*(void **)(v1 + 48));
    }
    free(*(void **)(v1 + 32));
    free((void *)v1);
    if (v4) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

  if ((v6 & 0x10) != 0)
  {
    int v16 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)((char *)v55 + v8) = v16;
    *(_OWORD *)((char *)v54 + v8) = v16;
    v8 += 16;
    v7 |= 0x2000u;
    HIDWORD(v49[0]) = v7;
    HIDWORD(v48[0]) = v7;
  }

  unsigned int v17 = v7;
  unsigned int v18 = v8;
  if ((v6 & 1) != 0)
  {
    char v19 = *((_DWORD *)a1 + 1);
    unsigned int v17 = v7;
    unsigned int v18 = v8;
    if (v19 != v50.st_uid)
    {
      *(_DWORD *)((char *)v55 + v8) = v19;
      unsigned int v18 = v8 + 4;
      unsigned int v17 = v7 | 0x8000;
      HIDWORD(v49[0]) = v7 | 0x8000;
    }
  }

  if ((v6 & 2) != 0)
  {
    int v20 = *((_DWORD *)a1 + 2);
    if (v20 != v50.st_gid)
    {
      *(_DWORD *)((char *)v55 + v18) = v20;
      v18 += 4;
      v17 |= 0x10000u;
      HIDWORD(v49[0]) = v17;
    }
  }

  if ((v6 & 8) != 0)
  {
    __int16 v21 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v21 != (v50.st_mode & 0xFFF))
    {
      *(_DWORD *)((char *)v55 + v18) = v21;
      v18 += 4;
      v17 |= 0x20000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v21;
      v8 += 4;
      v7 |= 0x20000u;
      HIDWORD(v48[0]) = v7;
    }
  }

  if ((v6 & 4) != 0)
  {
    __int16 v22 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
    if (v22 != v50.st_flags)
    {
      *(_DWORD *)((char *)v55 + v18) = v22;
      v18 += 4;
      v17 |= 0x40000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v22;
      v8 += 4;
      HIDWORD(v48[0]) = v7 | 0x40000;
    }
  }

  if (!v17) {
    return 0LL;
  }
  uint64_t result = fsetattrlist(a2, v49, v55, v18, 1u);
  if ((_DWORD)result)
  {
    char v23 = __error();
    if ((a3 & 1) == 0 || *v23 != 1 || (uint64_t result = fsetattrlist(a2, v48, v54, v8, 1u), (_DWORD)result))
    {
      uint64_t v24 = __error();
      if ((a3 & 1) != 0 && *v24 == 1) {
        return 0LL;
      }
      if ((*a1 & 1) != 0)
      {
        int v25 = *((_DWORD *)a1 + 1);
        if ((*a1 & 2) != 0)
        {
LABEL_35:
          char v26 = *((_DWORD *)a1 + 2);
          if ((*a1 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }

      else
      {
        int v25 = -1;
        if ((*a1 & 2) != 0) {
          goto LABEL_35;
        }
      }

      char v26 = -1;
      if ((*a1 & 1) == 0)
      {
LABEL_40:
        uint64_t v27 = 1;
        if ((*a1 & 2) == 0 || v26 == v50.st_gid)
        {
LABEL_47:
          if ((*a1 & 8) != 0)
          {
            size_t v32 = *((_DWORD *)a1 + 4) & 0xFFF;
            if (v32 != (v50.st_mode & 0xFFF))
            {
              if (fchmod(a2, v32))
              {
                unint64_t v33 = __error();
                if ((a3 & 1) == 0 || *v33 != 1)
                {
                  uint64_t v34 = __error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToFD",  659,  102,  *v34,  "fchmod",  v35,  v36,  v48[0]);
                  uint64_t v27 = 0;
                }
              }
            }
          }

          int v37 = *a1;
          if ((*a1 & 0x40) != 0)
          {
            char v38 = *((void *)a1 + 8);
            uint64_t v52 = *((void *)a1 + 7);
            v51.tv_seCC_SHA1_CTX c = v52;
            uint64_t v53 = (int)v38 / 1000;
            v51.tv_useCC_SHA1_CTX c = (int)v38 / 1000;
            if (futimes(a2, &v51))
            {
              stat v39 = __error();
              if ((a3 & 1) == 0 || *v39 != 1)
              {
                uint64_t v40 = __error();
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToFD",  667,  102,  *v40,  "futimes",  v41,  v42,  v48[0]);
                uint64_t v27 = 0;
              }
            }

            int v37 = *a1;
          }

          if ((v37 & 4) != 0)
          {
            __int16 v43 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
            if (v50.st_flags != v43)
            {
              if (fchflags(a2, v43))
              {
                size_t v44 = __error();
                if ((a3 & 1) == 0 || *v44 != 1)
                {
                  size_t v45 = __error();
                  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToFD",  681,  102,  *v45,  "fchflags",  v46,  v47,  v48[0]);
                  uint64_t v27 = 0;
                }
              }
            }
          }

          if (v27) {
            return 0LL;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }

uint64_t aeaContainerCreateExisting(uint64_t a1, AAByteStream_impl *a2, int a3, int a4)
{
  uint64_t v123 = *MEMORY[0x1895F89C0];
  int v103 = 0;
  memset(__s, 0, sizeof(__s));
  int v101 = 0;
  memset(v100, 0, sizeof(v100));
  int v99 = 0;
  memset(v98, 0, sizeof(v98));
  size_t v8 = malloc(0x6C0uLL);
  uint64_t v9 = (uint64_t)v8;
  if (!v8)
  {
    int v20 = *__error();
    __int16 v21 = "malloc";
    __int16 v22 = 95;
    goto LABEL_41;
  }

  memset_s(v8, 0x6C0uLL, 0, 0x6C0uLL);
  uint64_t v10 = (_DWORD *)(v9 + 668);
  if ((aeaContextUnlock(a1, v9, (_DWORD *)(v9 + 668), (_DWORD *)(v9 + 408), a3, a4) & 0x80000000) != 0)
  {
    __int16 v21 = "unlocking context";
    __int16 v22 = 99;
LABEL_40:
    int v20 = 0;
    goto LABEL_41;
  }

  if ((aeaCryptoInit((char *)(v9 + 72), (unsigned int *)v9) & 0x80000000) != 0)
  {
    __int16 v21 = "Invalid container";
    __int16 v22 = 102;
    goto LABEL_40;
  }

  if ((aeaContainerOffsetsInit(v9 + 280, (unsigned int *)v9, (unsigned int *)(v9 + 72)) & 0x80000000) != 0)
  {
    __int16 v21 = "deriving container offsets";
    __int16 v22 = 103;
    goto LABEL_40;
  }

  size_t v13 = *(unsigned int *)(v9 + 4);
  if ((_DWORD)v13)
  {
    int v14 = malloc(*(unsigned int *)(v9 + 4));
    *(void *)(v9 + 384) = v14;
    if (v14)
    {
      memcpy(v14, *(const void **)(a1 + 2712), v13);
      goto LABEL_8;
    }

    int v20 = *__error();
    __int16 v21 = "malloc";
    __int16 v22 = 110;
LABEL_41:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateExisting",  v22,  28,  v20,  v21,  v11,  v12,  v90);
    size_t v19 = 0LL;
    goto LABEL_42;
  }

LABEL_142:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateExisting",  v85,  28,  0,  v84,  v75,  v76,  v90);
    int v34 = 0;
LABEL_143:
    size_t v19 = v91;
    goto LABEL_44;
  }

  int v95 = 0;
  uint64_t v42 = *(void *)(v9 + 376);
  char v90 = v9 - 100;
  while (1)
  {
    unint64_t v94 = v41;
    uint64_t v96 = v42;
    if (*((void *)a2 + 4))
    {
      uint64_t v43 = 0LL;
      if (v42)
      {
        size_t v44 = v24;
        while (1)
        {
          uint64_t v45 = (*((uint64_t (**)(void, char *, uint64_t, unint64_t))a2 + 4))( *(void *)a2,  v44,  v42,  v41);
          if (v45 < 0) {
            break;
          }
          if (v45)
          {
            v44 += v45;
            v43 += v45;
            v41 += v45;
            v42 -= v45;
            if (v42) {
              continue;
            }
          }

          goto LABEL_67;
        }

        uint64_t v43 = v45;
      }
    }

    else
    {
      uint64_t v43 = -1LL;
    }

LABEL_67:
    if (v43 != v96)
    {
      char v26 = "loading cluster header";
      __int16 v27 = 183;
      goto LABEL_51;
    }

    int v120 = 0;
    __int128 v119 = 0u;
    __int128 v118 = 0u;
    __int128 v117 = 0u;
    __int128 v116 = 0u;
    __int128 v115 = 0u;
    __int128 v114 = 0u;
    __int128 v113 = 0u;
    __int128 v112 = 0u;
    __int128 v110 = 0u;
    __int128 v111 = 0u;
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    memset(&v122[8], 0, 252);
    memset(v121, 0, 260);
    *(_WORD *)&v122[8] = 19267;
    *(void *)uint64_t v122 = 0x5F41454100000006LL;
    memset_s(&v122[10], 0xFAuLL, 0, 0xFAuLL);
    uint64_t v46 = *(unsigned int *)v122;
    if (*(_DWORD *)v122 >= 0xFDu) {
      goto LABEL_35;
    }
    *(_DWORD *)&v122[*(unsigned int *)v122 + 4] = v95;
    *(_DWORD *)uint64_t v122 = v46 + 4;
    memset_s(&v122[v46 + 8], 252 - v46, 0, 252 - v46);
    uint64_t v47 = *(uint64_t (**)(__int128 *, void, _DWORD *, _BYTE *, _OWORD *))(v9 + 144);
    if (!v47 || !*v10)
    {
      memset_s(v122, 0x104uLL, 0, 0x104uLL);
LABEL_74:
      int v49 = 1;
      goto LABEL_75;
    }

    int v48 = v47(&v104, *v92, v10, v122, v121);
    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    int v49 = 0;
    if (v48 < 0) {
      goto LABEL_74;
    }
LABEL_75:
    memset((char *)v121 + 12, 0, 248);
    *(void *)((char *)v121 + 4) = 0x4B4548435F414541LL;
    LODWORD(v121[0]) = 8;
    memset_s((char *)v121 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v122, 0, sizeof(v122));
    uint64_t v50 = *(uint64_t (**)(_OWORD *, void, __int128 *, _OWORD *, _BYTE *))(v9 + 144);
    if (!v50 || !(_DWORD)v104) {
      break;
    }
    int v51 = v50(__s, *(unsigned int *)(v9 + 76), &v104, v121, v122);
    memset_s(v121, 0x104uLL, 0, 0x104uLL);
    if (v51 < 0) {
      goto LABEL_106;
    }
    memset_s(&v104, 0x104uLL, 0, 0x104uLL);
    if (v49) {
      goto LABEL_107;
    }
    uint64_t v52 = *(uint64_t (**)(char *, void, _OWORD *, _OWORD *, char *, void))(v9 + 168);
    if (!v52
      || LODWORD(v98[0]) != *(_DWORD *)(v9 + 84)
      || (v52( v24,  *(void *)(v9 + 360),  v98,  __s,  &v24[*(void *)(v9 + 360)],  *(void *)(v9 + 376) - *(void *)(v9 + 360)) & 0x80000000) != 0)
    {
      char v26 = "decrypting cluster header";
      __int16 v27 = 195;
      goto LABEL_51;
    }

    uint64_t v53 = *(unsigned int *)(v9 + 84);
    __memcpy_chk();
    LODWORD(v98[0]) = v53;
    memset_s((char *)v98 + v53 + 4, 256 - v53, 0, 256 - v53);
    LODWORD(v54) = *(_DWORD *)(v9 + 20);
    if ((_DWORD)v54)
    {
      unsigned int v55 = 0;
      uint64_t v97 = *(void *)(v9 + 368);
      uint64_t v56 = *(void *)(v9 + 352);
      do
      {
        unsigned int v57 = v55 + v95 * v54;
        if (v57 >= *(_DWORD *)(v9 + 400))
        {
          uint64_t v42 = *(void *)(v9 + 376);
          a2 = v93;
          unint64_t v41 = v42 + v94;
          uint64_t v10 = (_DWORD *)(v9 + 668);
          size_t v19 = v91;
          goto LABEL_93;
        }

        uint64_t v58 = *(void *)(v9 + 392);
        char v59 = (unsigned int *)(v58 + 544LL * v57);
        *char v59 = v57;
        v59[1] = *(_DWORD *)&v24[v56];
        v59[2] = *(_DWORD *)&v24[v56 + 4];
        uint64_t v60 = *(unsigned int *)(v9 + 48);
        uint64_t v61 = v56 + 8;
        uint64_t v62 = v58 + 544LL * v57;
        memcpy((void *)(v62 + 28), &v24[v61], *(unsigned int *)(v9 + 48));
        *(_DWORD *)(v62 + 24) = v60;
        memset_s((void *)(v62 + 28 + v60), 256 - v60, 0, 256 - v60);
        uint64_t v63 = *(unsigned int *)(v9 + 84);
        uint64_t v64 = v58 + 544LL * v57;
        uint64_t v56 = v61 + *(unsigned int *)(v9 + 48);
        memcpy((void *)(v64 + 288), &v24[v97], *(unsigned int *)(v9 + 84));
        *(_DWORD *)(v64 + 284) = v63;
        memset_s((void *)(v64 + 288 + v63), 256 - v63, 0, 256 - v63);
        v97 += *(unsigned int *)(v9 + 84);
        ++v55;
        LODWORD(v54) = *(_DWORD *)(v9 + 20);
      }

      while (v55 < v54);
      uint64_t v42 = *(void *)(v9 + 376);
      a2 = v93;
      unint64_t v41 = v42 + v94;
      uint64_t v10 = (_DWORD *)(v9 + 668);
      size_t v19 = v91;
      if (!(_DWORD)v54) {
        goto LABEL_96;
      }
LABEL_93:
      unint64_t v65 = (v54 * v95);
      unint64_t v66 = *(unsigned int *)(v9 + 400);
      uint64_t v54 = v54;
      uint64_t v67 = 544 * v65;
      do
      {
        if (v65 >= v66) {
          break;
        }
        uint64_t v68 = *(void *)(v9 + 392) + v67;
        *(void *)(v68 + 16) = v41;
        v41 += *(unsigned int *)(v68 + 8);
        v67 += 544LL;
        ++v65;
        --v54;
      }

      while (v54);
    }

    else
    {
      uint64_t v42 = *(void *)(v9 + 376);
      unint64_t v41 = v42 + v94;
    }

      size_t v8 = (void **)v155;
      if (v63 != v71)
      {
LABEL_70:
        uint64_t v77 = 180;
        uint64_t v78 = "aaByteStreamPWriteExpected";
        goto LABEL_72;
      }

LABEL_96:
  }

  memset_s(v121, 0x104uLL, 0, 0x104uLL);
LABEL_106:
  memset_s(&v104, 0x104uLL, 0, 0x104uLL);
LABEL_107:
  char v26 = "deriving cluster header key";
  __int16 v27 = 187;
LABEL_51:
  int v38 = 0;
LABEL_52:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerCreateExisting",  v27,  28,  v38,  v26,  v11,  v12,  v90);
LABEL_43:
  int v34 = 0;
LABEL_44:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v100, 0x104uLL, 0, 0x104uLL);
  memset_s(v98, 0x104uLL, 0, 0x104uLL);
  memset_s(v122, 0x30uLL, 0, 0x30uLL);
  if (v24) {
    memset_s(v24, v19, 0, v19);
  }
  free(v24);
  if (!v34)
  {
    aeaContainerDestroy(v9);
    return 0LL;
  }

  return v9;
}

  uint64_t v82 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
  __int128 v5 = a3;
  if (v82 < 0) {
    goto LABEL_97;
  }
  return v5;
}

uint64_t aeaContainerAppendSegment( uint64_t a1, uint64_t a2, void *__src, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)__src == -1)
  {
    __int16 v22 = "Invalid segment id\n";
    __int16 v23 = 280;
  }

  else
  {
    unsigned int v12 = *(_DWORD *)(a1 + 400);
    int v13 = *(_DWORD *)(a1 + 404);
    unsigned int v14 = *(_DWORD *)(a1 + 20);
    if (v12 < v14 * v13)
    {
      uint64_t v15 = *(void *)(a1 + 40);
      goto LABEL_4;
    }

    *(_DWORD *)(a1 + 404) = v13 + 1;
    unint64_t v24 = v14 * (unint64_t)(v13 + 1);
    if (v24 < 0xFFFFFFFF)
    {
      if (v24 < 0xF0F0F10)
      {
        unint64_t v25 = *(void **)(a1 + 392);
        char v26 = (char *)realloc(v25, 544 * v24);
        if (v26)
        {
          *(void *)(a1 + 392) = v26;
          memset_s( &v26[544 * *(unsigned int *)(a1 + 400)],  544 * (v24 - *(unsigned int *)(a1 + 400)),  0,  544 * (v24 - *(unsigned int *)(a1 + 400)));
          uint64_t v15 = *(void *)(a1 + 40) + *(void *)(a1 + 376);
          *(void *)(a1 + 40) = v15;
          unsigned int v12 = *(_DWORD *)(a1 + 400);
LABEL_4:
          void __src[2] = v15;
          uint64_t v16 = *((unsigned int *)__src + 2);
          memcpy((void *)(*(void *)(a1 + 392) + 544LL * v12), __src, 0x220uLL);
          ++*(_DWORD *)(a1 + 400);
          uint64_t v17 = *(void *)(a1 + 40) + v16;
          *(void *)(a1 + 32) += *((unsigned int *)__src + 1);
          *(void *)(a1 + 40) = v17;
          if (*(void *)(a2 + 40))
          {
            uint64_t v18 = 0LL;
            if ((_DWORD)v16)
            {
              uint64_t v19 = __src[2];
              uint64_t v20 = v16;
              while (1)
              {
                uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(a2 + 40))( *(void *)a2,  a4,  v20,  v19);
                if (v21 < 1) {
                  break;
                }
                a4 += v21;
                v18 += v21;
                v19 += v21;
                v20 -= v21;
                if (!v20) {
                  goto LABEL_9;
                }
              }

              uint64_t v18 = v21;
              if ((v21 & 0x8000000000000000LL) == 0)
              {
LABEL_19:
                if (v18 == v16) {
                  return 0LL;
                }
              }
            }

            else
            {
LABEL_9:
              if ((v18 & 0x8000000000000000LL) == 0) {
                goto LABEL_19;
              }
            }
          }

          __int16 v22 = "Segment write";
          __int16 v23 = 308;
          goto LABEL_22;
        }

        free(v25);
      }

      else
      {
        *__error() = 12;
      }

      *(void *)(a1 + 392) = 0LL;
      int v28 = *__error();
      __int16 v22 = "malloc";
      __int16 v23 = 289;
      goto LABEL_23;
    }

    __int16 v22 = "Container size limit reached";
    __int16 v23 = 287;
  }

LABEL_22:
  int v28 = 0;
LABEL_23:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerAppendSegment",  v23,  28,  v28,  v22,  a7,  a8,  v29);
  return 0xFFFFFFFFLL;
}

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"writeHeaderProc",  v20,  133,  0,  v19,  v9,  v10,  v49);
    goto LABEL_23;
  }

  return 0xFFFFFFFFLL;
}

    free(v12);
    return v8;
  }

  return 0LL;
}

  if (v22) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

  if (v14 == 0x8000 || v14 == 0x4000) {
    goto LABEL_24;
  }
LABEL_26:
  if ((st_mode & 0xF000) == 0x8000 && (*a2 & 8) != 0) {
    *((_DWORD *)a2 + 1) = getFileProtectionClass(v32);
  }
LABEL_29:
  if (!a3 || (v30.st_mode & 0xF000) != 0x8000) {
    return 0LL;
  }
  uint64_t v16 = open(v32, 0);
  if (v16 < 0)
  {
    unint64_t v24 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesInitWithPath",  376,  102,  v24,  "open: %s",  v25,  v26,  (char)v32);
  }

  else
  {
    uint64_t v17 = v16;
    if ((aaEntryHashesInitWithFD(a3, a4, v16) & 0x80000000) == 0)
    {
      close(v17);
      return 0LL;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesInitWithPath",  377,  102,  0,  "computing file digests: %s",  v18,  v19,  (char)v32);
    close(v17);
  }

  return 0xFFFFFFFFLL;
}

    if (fgetxattr(fd, v13, v18, v12, 0, 0) < 0)
    {
      int v32 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c",  (uint64_t)"aaEntryXATBlobInitWithFD",  187,  104,  v32,  "getxattr failed for name=%s",  v33,  v34,  (char)v13);
    }

    else
    {
      if ((AAEntryXATBlobAppendEntry(a1, v13, v18, v17) & 0x80000000) == 0)
      {
        int v13 = &v7[++v11];
        uint64_t v6 = v18;
        uint64_t v10 = v36;
        goto LABEL_25;
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c",  (uint64_t)"aaEntryXATBlobInitWithFD",  190,  104,  0,  "inserting XAT entry",  v19,  v20,  v35);
    }

    uint64_t v6 = v18;
    goto LABEL_28;
  }

  *__error() = 12;
LABEL_37:
  unint64_t v24 = *__error();
  __int16 v27 = "malloc";
  int v28 = 178;
LABEL_30:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c",  (uint64_t)"aaEntryXATBlobInitWithFD",  v28,  104,  v24,  v27,  v25,  v26,  v35);
  uint64_t v6 = 0LL;
LABEL_28:
  free(v6);
  free(v7);
  *(void *)a1 = 0LL;
  *((void *)a1 + 3) = 0LL;
  return 0xFFFFFFFFLL;
}

      int v38 = (char *)realloc(v15, v37);
      if (v38)
      {
        *((void *)&v47 + 1) = v37;
        uint64_t value = v38;
        uint64_t v15 = v38;
        int v32 = v37;
        goto LABEL_24;
      }

      free(v15);
LABEL_58:
      uint64_t v15 = 0LL;
      uint64_t v47 = 0uLL;
      uint64_t v45 = 406;
      goto LABEL_49;
    }

    int v31 = 264LL;
  }

  else
  {
    int v31 = v9 & 0xFFFFFFFC;
    if ((v9 & 0xFFFFFFFC) != 0)
    {
      size_t v39 = 0LL;
      do
      {
        while (!v39)
        {
          size_t v39 = 0x4000LL;
          if (v31 <= 0x4000)
          {
            size_t v39 = 0x4000LL;
            goto LABEL_37;
          }
        }

        uint64_t v40 = v39 >> 1;
        if ((v39 & (v39 >> 1)) != 0) {
          uint64_t v40 = v39 & (v39 >> 1);
        }
        v39 += v40;
      }

      while (v39 < v31);
      if (v39 >= 0x2000000001LL)
      {
        *__error() = 12;
LABEL_46:
        uint64_t value = 0LL;
        uint64_t v47 = 0uLL;
        unsigned int v14 = "prepare non zlib header";
        unsigned int v12 = 411;
        int v13 = 0;
        goto LABEL_5;
      }

    free(v10);
    return v8;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"verifySegmentProc",  112,  128,  0,  "Invalid segment size",  a7,  a8,  v35);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerRemovePadding(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 40) -= v2;
    *(void *)(a1 + 64) = 0LL;
    if ((AAByteStreamTruncate(a2) & 0x80000000) != 0) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerRemovePadding",  328,  28,  "Warning: container truncate failed",  v3,  v4,  v5,  vars0);
    }
  }

  return 0LL;
}

uint64_t aeaContainerRemoveLastSegment( uint64x2_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v8 = a1[25].i32[0];
  if (!v8)
  {
    uint64_t v10 = "No segments to remove";
    __int16 v11 = 339;
    goto LABEL_5;
  }

  if (a1[4].i64[0])
  {
    uint64_t v10 = "Padding was not removed";
    __int16 v11 = 340;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerRemoveLastSegment",  v11,  28,  0,  v10,  a7,  a8,  v19);
    return 0xFFFFFFFFLL;
  }

  uint64_t v14 = a1[24].i64[1] + 544LL * (v8 - 1);
  __int32 v15 = a1[25].i32[1];
  a1[25].i32[0] = v8 - 1;
  a1[25].i32[1] = (v8 + a1[1].i32[1] - 2) / a1[1].i32[1];
  a1[2] = vsubw_u32(a1[2], *(uint32x2_t *)(v14 + 4));
  memset_s((void *)v14, 0x220uLL, 0, 0x220uLL);
  if (v15 != a1[25].i32[1]) {
    a1[2].i64[1] -= a1[23].i64[1];
  }
  if ((AAByteStreamTruncate(a2) & 0x80000000) != 0) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerRemoveLastSegment",  364,  28,  "Warning: container truncate failed",  v16,  v17,  v18,  v19);
  }
  return 0LL;
}

uint64_t aeaContainerReencrypt( uint64_t a1, AAByteStream_impl *a2, int *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t v89 = *MEMORY[0x1895F89C0];
  int v69 = 0;
  memset(__n, 0, sizeof(__n));
  int v67 = 0;
  memset(v66, 0, sizeof(v66));
  int v65 = 0;
  memset(v64, 0, sizeof(v64));
  BOOL v13 = (*(_DWORD *)a1 & 0x3F) == 0 && *(_DWORD *)a1 < 6u;
  BOOL v60 = v13;
  rsize_t __smax = *(unsigned int *)(a1 + 16);
  uint64_t v14 = (char *)malloc(__smax);
  if (!v14)
  {
    uint64_t v47 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerReencrypt",  390,  28,  *v47,  "malloc",  v48,  v49,  v53);
    int v46 = 0;
    goto LABEL_70;
  }

  unsigned int v57 = (unsigned int *)(a1 + 72);
  if ((aeaDeriveMainKeyNew((unsigned int *)(a1 + 72), (int *)a1, v66, (int *)v64, (char *)__n, a3, a4, a5, a6) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerReencrypt",  400,  28,  0,  "generating new main key",  v15,  v16,  v54);
    int v46 = 0;
    goto LABEL_69;
  }

  if (!*(_DWORD *)(a1 + 400))
  {
LABEL_53:
    uint64_t v43 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101) {
      goto LABEL_74;
    }
    memcpy((void *)(a1 + 412), (char *)__n + 4, LODWORD(__n[0]));
    *(_DWORD *)(a1 + 408) = v43;
    memset_s((void *)(a1 + 412 + v43), 256 - v43, 0, 256 - v43);
    uint64_t v44 = LODWORD(v66[0]);
    if (LODWORD(v66[0]) >= 0x101
      || (memcpy((void *)(a1 + 672), (char *)v66 + 4, LODWORD(v66[0])),
          *(_DWORD *)(a1 + 668) = v44,
          memset_s((void *)(a1 + 672 + v44), 256 - v44, 0, 256 - v44),
          uint64_t v45 = LODWORD(v64[0]),
          LODWORD(v64[0]) >= 0x101))
    {
LABEL_74:
      __break(1u);
    }

    memcpy((void *)(a1 + 932), (char *)v64 + 4, LODWORD(v64[0]));
    *(_DWORD *)(a1 + 928) = v45;
    memset_s((void *)(a1 + 932 + v45), 256 - v45, 0, 256 - v45);
    int v46 = 1;
    goto LABEL_69;
  }

  unsigned int v17 = 0;
  uint64_t v56 = (_DWORD *)(a1 + 668);
  while (1)
  {
    if (!*((void *)a2 + 4)) {
      goto LABEL_60;
    }
    uint64_t v58 = *(void *)(a1 + 392);
    uint64_t v18 = v58 + 544LL * v17;
    size_t v19 = *(unsigned int *)(v18 + 8);
    unsigned int v59 = *(_DWORD *)(a1 + 20);
    uint64_t v20 = (off_t *)(v18 + 16);
    size_t v62 = v19;
    unsigned int v55 = v20;
    uint64_t v21 = 0LL;
    if ((_DWORD)v19)
    {
      off_t v22 = *v20;
      __int16 v23 = v14;
      while (1)
      {
        uint64_t v24 = (*((uint64_t (**)(void, char *, size_t, off_t))a2 + 4))(*(void *)a2, v23, v19, v22);
        if (v24 < 0) {
          break;
        }
        if (v24)
        {
          v23 += v24;
          v21 += v24;
          v22 += v24;
          v19 -= v24;
          if (v19) {
            continue;
          }
        }

        goto LABEL_19;
      }

      uint64_t v21 = v24;
    }

uint64_t aeaContainerLoadSegment( uint64_t a1, void *a2, unsigned int a3, uint8_t *a4, const uint8_t *a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8) {
    uint64_t v9 = (char *)a5;
  }
  else {
    uint64_t v9 = (char *)a4;
  }
  if (*(_DWORD *)(a1 + 400) <= a3)
  {
    uint64_t v21 = "Invalid segment index";
    __int16 v22 = 463;
    goto LABEL_41;
  }

  if (!a2[4]) {
    goto LABEL_20;
  }
  uint64_t v13 = *(void *)(a1 + 392);
  uint64_t v14 = v13 + 544LL * a3;
  uint64_t v15 = *(unsigned int *)(v14 + 8);
  size_t __n = *(unsigned int *)(v14 + 4);
  uint64_t v44 = v13;
  if ((_DWORD)v15)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = *(void *)(v13 + 544LL * a3 + 16);
    uint64_t v18 = v9;
    size_t v19 = *(unsigned int *)(v14 + 8);
    while (1)
    {
      uint64_t v20 = ((uint64_t (*)(void, char *, uint64_t, uint64_t))a2[4])(*a2, v9, v15, v17);
      if (v20 < 0) {
        break;
      }
      if (v20)
      {
        v9 += v20;
        v16 += v20;
        v17 += v20;
        v15 -= v20;
        if (v15) {
          continue;
        }
      }

      goto LABEL_15;
    }

    uint64_t v16 = v20;
  }

  else
  {
    uint64_t v18 = v9;
    size_t v19 = *(unsigned int *)(v14 + 8);
    uint64_t v16 = 0LL;
  }

unint64_t aeaPaddedContainerSize( unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (a2 > 0xF) {
      goto LABEL_8;
    }
    if (a2)
    {
      if (a2 == 1)
      {
        if (result >= 8)
        {
          int v9 = __clz(result);
          int v10 = __clz(v9 ^ 0x3F) - v9;
          if (v10 < -31) {
            return -1LL;
          }
          a2 = 1LL << (v10 + 31);
LABEL_8:
          if (!__CFADD__(result, a2 - 1)) {
            return (result + a2 - 1) / a2 * a2;
          }
          return -1LL;
        }
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaPaddedContainerSize",  585,  28,  0,  "Invalid padding_alignment",  a7,  a8,  v8);
        return -1LL;
      }
    }
  }

  return result;
}

uint64_t aeaContainerFinish(uint64_t a1, AAByteStream_impl *a2)
{
  uint64_t v208 = *MEMORY[0x1895F89C0];
  size_t v3 = *(void *)(a1 + 344);
  size_t v4 = *(void *)(a1 + 376);
  if (v3 <= v4) {
    unint64_t v5 = *(void *)(a1 + 376);
  }
  else {
    unint64_t v5 = *(void *)(a1 + 344);
  }
  int v171 = 0;
  if (v5 <= 0x100000) {
    rsize_t v6 = 0x100000LL;
  }
  else {
    rsize_t v6 = v5;
  }
  memset(__s, 0, sizeof(__s));
  int v169 = 0;
  __int128 v168 = 0u;
  __int128 v167 = 0u;
  __int128 v166 = 0u;
  __int128 v165 = 0u;
  __int128 v164 = 0u;
  __int128 v163 = 0u;
  __int128 v162 = 0u;
  __int128 v161 = 0u;
  __int128 v160 = 0u;
  __int128 v159 = 0u;
  __int128 v158 = 0u;
  __int128 v157 = 0u;
  __int128 v156 = 0u;
  __int128 v155 = 0u;
  __int128 v154 = 0u;
  *(_OWORD *)int v153 = 0u;
  int v152 = 0;
  memset(v151, 0, sizeof(v151));
  int v150 = 0;
  memset(v149, 0, sizeof(v149));
  int v148 = 0;
  __int128 v146 = 0u;
  __int128 v147 = 0u;
  __int128 v144 = 0u;
  __int128 v145 = 0u;
  __int128 v142 = 0u;
  __int128 v143 = 0u;
  __int128 v140 = 0u;
  __int128 v141 = 0u;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  __int128 v136 = 0u;
  __int128 v137 = 0u;
  __int128 v134 = 0u;
  __int128 v135 = 0u;
  *(_OWORD *)unint64_t v132 = 0u;
  __int128 v133 = 0u;
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v129 = 0;
  memset(v128, 0, sizeof(v128));
  int v124 = 0;
  uint64_t v123 = 0LL;
  __int128 v126 = 0u;
  __int128 v127 = 0u;
  __int128 v125 = 0u;
  if (v6 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_21:
    uint64_t v24 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  620,  28,  *v24,  "malloc",  v25,  v26,  nbyte);
    int v9 = 0LL;
    rsize_t v27 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v29 = 0xFFFFFFFFLL;
    char v30 = 1;
LABEL_25:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v153, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    memset_s(v151, 0x104uLL, 0, 0x104uLL);
    memset_s(v149, 0x104uLL, 0, 0x104uLL);
    memset_s(v132, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(&v125, 0x30uLL, 0, 0x30uLL);
    memset_s(&v123, 0xCuLL, 0, 0xCuLL);
    if ((v30 & 1) == 0) {
      memset_s(v9, v6, 0, v6);
    }
    free(v9);
    if (v28) {
      memset_s(v28, v27, 0, v27);
    }
    free(v28);
    uint64_t v33 = *(void **)(a1 + 384);
    if (v33) {
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    }
    free(v33);
    *(void *)(a1 + 384) = 0LL;
    return v29;
  }

  char v8 = (char *)malloc(v6);
  if (!v8) {
    goto LABEL_21;
  }
  int v9 = v8;
  unsigned int v10 = *(_DWORD *)(a1 + 84);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v10 > 0x100 || (uint64_t v13 = *(uint64_t (**)(void))(a1 + 136)) == 0LL || (v13() & 0x80000000) != 0)
  {
    int v31 = "generating last cluster random MAC";
    __int16 v32 = 624;
    goto LABEL_23;
  }

  LODWORD(__s[0]) = v10;
  unint64_t v18 = *(void *)(a1 + 56);
  if (v18)
  {
    unint64_t v19 = *(void *)(a1 + 40);
    unint64_t v20 = aeaPaddedContainerSize(v19, v18, v14, v15, v16, v17, v11, v12);
    if (v20 == -1LL)
    {
      int v31 = "Container size is too large to allow padding";
      __int16 v32 = 631;
      goto LABEL_23;
    }

    unint64_t v21 = v20;
    if (v20 > v19)
    {
      memset(v207, 0, sizeof(v207));
      memset(v206, 0, 260);
      int v205 = 0;
      __int128 v204 = 0u;
      __int128 v203 = 0u;
      __int128 v202 = 0u;
      __int128 v201 = 0u;
      __int128 v200 = 0u;
      __int128 v199 = 0u;
      __int128 v198 = 0u;
      __int128 v197 = 0u;
      __int128 v196 = 0u;
      __int128 v195 = 0u;
      __int128 v194 = 0u;
      __int128 v193 = 0u;
      __int128 v192 = 0u;
      __int128 v191 = 0u;
      __int128 v190 = 0u;
      __int128 v189 = 0u;
      if (*(void *)(a1 + 248)
        && (*(_DWORD *)((char *)v206 + 7) = 1262571615,
            *(void *)&v206[0] = 0x5F41454100000007LL,
            memset_s((void *)((unint64_t)v206 | 0xB), 0xF9uLL, 0, 0xF9uLL),
            (__int16 v22 = *(uint64_t (**)(_BYTE *, void))(a1 + 144)) != 0LL)
        && *(_DWORD *)(a1 + 668)
        && (v22(v207, *(unsigned int *)(a1 + 72)) & 0x80000000) == 0)
      {
        uint64_t v23 = (*(uint64_t (**)(_BYTE *))(a1 + 248))(v207);
      }

      else
      {
        uint64_t v23 = 0LL;
      }

      memset_s(v207, 0x104uLL, 0, 0x104uLL);
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
      if (v23)
      {
        size_t nbyte = v3;
        while (1)
        {
          if (v21 - v19 >= 0x100000) {
            size_t v35 = 0x100000LL;
          }
          else {
            size_t v35 = v21 - v19;
          }
          int64_t v36 = *(uint64_t (**)(char *, size_t))(a1 + 136);
          if (!v36 || (v36(v9, v35) & 0x80000000) != 0)
          {
            int v40 = "generating padding";
            __int16 v41 = 640;
            goto LABEL_50;
          }

          compression_algorithm v37 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 256);
          if (!v37 || (v37(v23, v9, v35) & 0x80000000) != 0)
          {
            int v40 = "hashing padding";
            __int16 v41 = 641;
            goto LABEL_50;
          }

          ssize_t v38 = AAByteStreamPWrite(a2, v9, v35, v19);
          if (v38 <= 0) {
            break;
          }
          v19 += v38;
          if (v19 >= v21)
          {
            int v39 = 0;
            goto LABEL_51;
          }
        }

        int v40 = "writing padding";
        __int16 v41 = 643;
LABEL_50:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  v41,  28,  0,  v40,  v11,  v12,  v3);
        int v39 = 1;
LABEL_51:
        int v42 = *(uint64_t (**)(uint64_t, _OWORD *))(a1 + 264);
        size_t v3 = nbyte;
        if (v42)
        {
          if ((v42(v23, __s) & 0x80000000) == 0 && LODWORD(__s[0]) == *(_DWORD *)(a1 + 84))
          {
            if (!v39)
            {
              *(void *)(a1 + 40) = v19;
              goto LABEL_56;
            }

            goto LABEL_114;
          }

          memset_s(__s, 0x104uLL, 0, 0x104uLL);
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  646,  28,  0,  "hashing padding",  v11,  v12,  nbyte);
LABEL_114:
        int v31 = "Padding generation and hashing failed";
        __int16 v32 = 648;
        goto LABEL_23;
      }

      int v31 = "hashing padding";
      __int16 v32 = 636;
LABEL_23:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c",  (uint64_t)"aeaContainerFinish",  v32,  28,  0,  v31,  v11,  v12,  nbyte);
      char v30 = 0;
      rsize_t v27 = 0LL;
      uint64_t v28 = 0LL;
LABEL_24:
      uint64_t v29 = 0xFFFFFFFFLL;
      goto LABEL_25;
    }
  }

LABEL_161:
          int v99 = "encrypt signature";
          __int16 v100 = 789;
          goto LABEL_125;
        }
      }

      else
      {
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
      }

      int v99 = "deriving signature encryption key";
      __int16 v100 = 787;
      goto LABEL_125;
    }

    uint64_t v112 = LODWORD(v149[0]);
    if (LODWORD(v149[0]) >= 0x101) {
      goto LABEL_162;
    }
    __memcpy_chk();
    LODWORD(v132[0]) = v112;
    memset_s((char *)v132 + v112 + 4, 256 - v112, 0, 256 - v112);
LABEL_152:
    memcpy(&v9[*(void *)(a1 + 296)], (char *)v132 + 4, LODWORD(v132[0]));
    goto LABEL_153;
  }

  *(void *)uint64_t v207 = 0LL;
  uint64_t result = v97(*(void *)(a1 + 1720), 256LL, (char *)v149 + 4, v207, (char *)v128 + 4);
  if ((result & 0x80000000) != 0)
  {
    int v99 = "Signing callback";
    __int16 v100 = 772;
    goto LABEL_125;
  }

  unint64_t v98 = *(unsigned int *)(a1 + 112);
  if (*(void *)v207 > v98)
  {
    int v99 = "Invalid callback size return value";
    __int16 v100 = 773;
    goto LABEL_125;
  }

  if (v98 < 0x101)
  {
    LODWORD(v149[0]) = *(_DWORD *)(a1 + 112);
    uint64_t result = memset_s((char *)v149 + v98 + 4, 256 - v98, 0, 256 - v98);
    goto LABEL_133;
  }

LABEL_162:
  __break(1u);
  return result;
}

      if (v81 - v79 >= v78) {
        int v86 = v78;
      }
      else {
        int v86 = v81 - v79;
      }
      int v87 = AAByteStreamRead(a2, (char *)__ptr + v79, v86);
      if (v87 < 0) {
        goto LABEL_248;
      }
      if (!v87) {
        break;
      }
      size_t v88 = __CFADD__(v79, v87);
      v79 += v87;
      if (v88 || v79 > v81) {
        goto LABEL_248;
      }
      char __s = v79;
      v80 += v87;
      v78 -= v87;
      if (v78) {
        continue;
      }
      break;
    }

    if (v80 < 0)
    {
LABEL_248:
      uint64_t v14 = "reading state";
      uint64_t v15 = 973;
      goto LABEL_225;
    }

    if (!v80) {
      goto LABEL_243;
    }
    uint64_t v89 = *(void *)(v9 + 4864);
    if (*(void *)(v89 + 24))
    {
      char v90 = 0LL;
      if (v79)
      {
        __int128 v91 = (char *)__ptr;
        while (1)
        {
          size_t v92 = (*(uint64_t (**)(void, char *, unint64_t))(v89 + 24))(*(void *)v89, v91, v79);
          if (v92 < 1) {
            break;
          }
          v91 += v92;
          v90 += v92;
          v79 -= v92;
          if (!v79) {
            goto LABEL_180;
          }
        }

        char v90 = v92;
      }
    }

    else
    {
      char v90 = -1LL;
    }

      __strlcat_chk();
      if ((a1[2184] & 4) == 0)
      {
LABEL_119:
        unint64_t v56 = a1[2240];
        if ((v56 & 4) != 0)
        {
          __strlcat_chk();
          unint64_t v56 = a1[2240];
          if ((v56 & 8) == 0)
          {
LABEL_121:
            if ((v56 & 0x10) == 0) {
              goto LABEL_123;
            }
            goto LABEL_122;
          }
        }

        else if ((a1[2240] & 8) == 0)
        {
          goto LABEL_121;
        }

        __strlcat_chk();
        if ((a1[2240] & 0x10) == 0)
        {
LABEL_123:
          unint64_t v57 = *v14;
          if ((*v14 & 1) != 0)
          {
            __strlcat_chk();
            unint64_t v57 = *v14;
            if ((*v14 & 2) == 0)
            {
LABEL_125:
              if ((v57 & 4) == 0) {
                goto LABEL_127;
              }
              goto LABEL_126;
            }
          }

          else if ((*v14 & 2) == 0)
          {
            goto LABEL_125;
          }

          __strlcat_chk();
          if ((*v14 & 4) == 0)
          {
LABEL_127:
            fprintf((FILE *)*MEMORY[0x1895F89D0], "Dst fixup %c%s %s\n", (char)a1[2088], v114, a1 + 1064);
LABEL_128:
            *(void *)int v114 = 0LL;
            if ((aaCheckAndFixWithPath( a1 + 2112,  a1 + 2184,  a1 + 2240,  a1 + 2416,  -1LL,  (unsigned int *)v114,  a1 + 3516,  a1 + 1064,  v13) & 0x80000000) == 0)
            {
LABEL_129:
              uint64_t v28 = 1;
              goto LABEL_150;
            }

            unint64_t v98 = __s;
            uint64_t v60 = "fixup failed: %s";
            uint64_t v61 = 503;
            goto LABEL_148;
          }

      int v124 = *v122;
      uint64_t v123 = (char *)realloc(*v122, v118);
      if (v123)
      {
        *unint64_t v122 = v123;
        *uint64_t v119 = v118;
        __int128 v113 = *v114;
        goto LABEL_164;
      }

      free(v124);
LABEL_169:
      *unint64_t v122 = 0LL;
      *int v114 = 0LL;
      v114[1] = 0LL;
      goto LABEL_170;
    }

    uint64_t v123 = *(char **)(v72 + 984 * v73 + 72);
LABEL_164:
    memcpy(&v123[v113], size, v111);
    *v114 += v111;
    if ((v111 & 0x8000000000000000LL) != 0)
    {
LABEL_170:
      uint64_t v16 = "LNK blob";
      uint64_t v17 = 330;
      goto LABEL_9;
    }
  }

  if ((aaEntryAttributesInitWithHeader((char *)(v72 + 984 * v73 + 136), (char *)(v72 + 984 * v73 + 208), 0LL, header) & 0x80000000) != 0)
  {
    uint64_t v16 = "attributes from header";
    uint64_t v17 = 332;
    goto LABEL_9;
  }

  uint64_t result = 0LL;
  *uint64_t v75 = v130;
  return result;
}

void *AAMemoryInputStreamOpen( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 && a2)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryInputStreamOpen",  132,  68,  0,  "Invalid arguments",  a7,  a8,  v17);
    unsigned int v10 = 0LL;
    uint64_t v11 = 0LL;
LABEL_8:
    free(v11);
    free(v10);
    return 0LL;
  }

  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v12 = malloc(0x20uLL);
  uint64_t v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    uint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryInputStreamOpen",  137,  68,  *v13,  "malloc",  v14,  v15,  v17);
    goto LABEL_8;
  }

  void *v11 = a1;
  v11[1] = a2;
  void *v10 = v11;
  v10[1] = memoryInputStreamClose;
  v10[2] = memoryInputStreamRead;
  v10[4] = memoryInputStreamPRead;
  v10[6] = memoryInputStreamSeek;
  v10[7] = memoryInputStreamCancel;
  return v10;
}

uint64_t memoryInputStreamClose(void *a1)
{
  return 0LL;
}

uint64_t memoryInputStreamCancel(uint64_t result)
{
  unsigned int v1 = (unsigned int *)(result + 24);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

size_t memoryInputStreamRead(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t *)(a1 + 16);
  do
    uint64_t v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return memoryInputStreamPRead(a1, a2, a3, v6);
}

size_t memoryInputStreamPRead(uint64_t a1, void *__dst, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = atomic_load((unsigned int *)(a1 + 24));
  size_t v5 = -1LL;
  if ((a4 & 0x8000000000000000LL) == 0 && !v4)
  {
    unint64_t v6 = *(void *)(a1 + 8);
    unint64_t v7 = (uint64_t)v6 >= a4 ? a4 : *(void *)(a1 + 8);
    if (!__CFADD__(v7, a3))
    {
      if (v7 + a3 < v6) {
        unint64_t v6 = v7 + a3;
      }
      size_t v5 = v6 - v7;
      if (v6 <= v7) {
        return 0LL;
      }
      else {
        memcpy(__dst, (const void *)(*(void *)a1 + v7), v5);
      }
    }
  }

  return v5;
}

uint64_t memoryInputStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (!a3) {
    goto LABEL_7;
  }
  if (a3 != 1)
  {
    if (a3 != 2) {
      return -1LL;
    }
    a2 += *(void *)(a1 + 8);
LABEL_7:
    atomic_store(a2, (unint64_t *)(a1 + 16));
    return a2;
  }

  unsigned int v4 = (unint64_t *)(a1 + 16);
  do
  {
    unint64_t v5 = __ldaxr(v4);
    unint64_t v6 = v5 + a2;
  }

  while (__stlxr(v6, v4));
  return v6;
}

void *AAMemoryOutputStreamOpen( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 && a2)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryOutputStreamOpen",  169,  68,  0,  "Invalid arguments",  a7,  a8,  v17);
    unsigned int v10 = 0LL;
    uint64_t v11 = 0LL;
LABEL_8:
    free(v11);
    free(v10);
    return 0LL;
  }

  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v12 = malloc(0x20uLL);
  uint64_t v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    uint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryOutputStreamOpen",  174,  68,  *v13,  "malloc",  v14,  v15,  v17);
    goto LABEL_8;
  }

  v11[1] = 0LL;
  v11[2] = a2;
  void *v11 = a1;
  void *v10 = v11;
  v10[1] = memoryOutputStreamClose;
  v10[7] = memoryOutputStreamCancel;
  v10[3] = memoryOutputStreamWrite;
  return v10;
}

uint64_t memoryOutputStreamClose(void *a1)
{
  return 0LL;
}

uint64_t memoryOutputStreamCancel(uint64_t result)
{
  unsigned int v1 = (unsigned int *)(result + 24);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

size_t memoryOutputStreamWrite( void *a1, const void *a2, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = __n;
  if (__n)
  {
    uint64_t v10 = a1[1];
    size_t v11 = v10 + __n;
    if (__CFADD__(v10, __n))
    {
      uint64_t v12 = "invalid size";
      __int16 v13 = 102;
    }

    else
    {
      if (v11 <= a1[2])
      {
        memcpy((void *)(*a1 + v10), a2, __n);
        a1[1] = v11;
        return v8;
      }

      uint64_t v12 = "buffer full";
      __int16 v13 = 103;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"memoryOutputStreamWrite",  v13,  68,  0,  v12,  a7,  a8,  v15);
    return -1LL;
  }

  return v8;
}

uint64_t AAMemoryOutputStreamCloseWithSize( uint64_t (**a1)(void *a1), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0LL;
  }
  if (a1[1] == memoryOutputStreamClose)
  {
    uint64_t v9 = *((void *)*a1 + 1);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryOutputStreamCloseWithSize",  201,  68,  0,  "invalid stream type",  a7,  a8,  v13);
    uint64_t v9 = -1LL;
  }

  if (AAByteStreamClose((AAByteStream)a1) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c",  (uint64_t)"AAMemoryOutputStreamCloseWithSize",  207,  68,  0,  "close stream",  v10,  v11,  v13);
    return -1LL;
  }

  return v9;
}

AAByteStream_impl *aaForkOutputStreamOpen(uint64_t a1, void *a2)
{
  unsigned int v4 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  unint64_t v5 = calloc(1uLL, 0x20050uLL);
  size_t v8 = v5;
  if (!v4 || !v5)
  {
    int v17 = *__error();
    unint64_t v18 = "malloc";
    __int16 v19 = 405;
LABEL_13:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"aaForkOutputStreamOpen",  v19,  136,  v17,  v18,  v6,  v7,  v38);
    goto LABEL_14;
  }

  if (!*(void *)(a1 + 40) || !*(void *)(a1 + 32))
  {
    unint64_t v18 = "stream not compatible\n";
    __int16 v19 = 406;
    int v17 = 0;
    goto LABEL_13;
  }

  uint64_t v9 = v5 + 16385;
  AACustomByteStreamSetData(v4, v5);
  AACustomByteStreamSetWriteProc(v4, (AAByteStreamWriteProc)ForkOutputStreamWrite);
  AACustomByteStreamSetPWriteProc(v4, (AAByteStreamPWriteProc)ForkOutputStreamPWrite);
  AACustomByteStreamSetCancelProc(v4, (AAByteStreamCancelProc)ForkOutputStreamCancel);
  AACustomByteStreamSetCloseProc(v4, (AAByteStreamCloseProc)ForkOutputStreamClose);
  void *v9 = a1;
  v8[16386] = a2;
  if (a2[258]) {
    size_t v10 = a2[270] + 1LL;
  }
  else {
    size_t v10 = a2[270];
  }
  v8[16390] = v10;
  if (is_mul_ok(v10, 0x30uLL) && 48 * v10 < 0x2000000001LL)
  {
    uint64_t v16 = calloc(v10, 0x30uLL);
  }

  else
  {
    char v13 = __error();
    uint64_t v16 = 0LL;
    *char v13 = 12;
  }

  v8[16389] = v16;
  *(_OWORD *)(v8 + 16391) = 0u;
  *((_DWORD *)v8 + 32786) = 0;
  if (!v16)
  {
    int v17 = *__error();
    unint64_t v18 = "aaCalloc";
    __int16 v19 = 423;
    goto LABEL_13;
  }

  uint64_t v28 = 0LL;
  uint64_t v29 = a2[270];
  uint64_t v30 = a2[258];
  char v31 = 1;
  __int16 v32 = v16;
  while (1)
  {
    if (v29)
    {
      uint64_t v33 = (void *)a2[268];
      for (uint64_t i = v29; i; --i)
      {
        uint64_t v35 = v33[51];
        if ((v31 & 1) != 0)
        {
          if ((v35 & 1) != 0)
          {
            *__int16 v32 = v33;
            v32[1] = v28;
            int64_t v36 = (void *)v33[48];
            uint64_t v37 = v33[49];
            v32[2] = 0LL;
            v32[3] = v37;
            v32[4] = *v36;
LABEL_26:
            v32[5] = v33[5];
            v28 += v37;
            v8[16392] = v28;
            v32 += 6;
          }
        }

        else if ((v35 & 2) != 0)
        {
          v32[1] = v28;
          v32[2] = 0LL;
          uint64_t v37 = v33[4];
          v32[3] = v37;
          goto LABEL_26;
        }

        v33 += 55;
      }
    }

    if ((v31 & 1) == 0) {
      break;
    }
    char v31 = 0;
    uint64_t v14 = v28;
    uint64_t v15 = v28;
    if (v30)
    {
      char v31 = 0;
      v32[1] = v28;
      v32[2] = 0LL;
      v32[3] = v30;
      v32[5] = 0LL;
      uint64_t v14 = v30 + v28;
      v32 += 6;
      uint64_t v15 = v28;
      uint64_t v28 = v14;
      v8[16392] = v14;
    }
  }

  a2[257] = v15;
  a2[259] = v14;
  if (v32 == &v16[6 * v8[16390]])
  {
    a2[260] = v28;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"aaForkOutputStreamOpen",  477,  136,  0,  "bad variant",  v11,  v12,  v38);
    a2[260] = v8[16392];
LABEL_14:
    free(v4);
    ForkOutputStreamClose((void **)v8, v20, v21, v22, v23, v24, v25, v26);
    return 0LL;
  }

  return v4;
}

uint64_t ForkOutputStreamWrite( _DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = (void **)(a1 + 32770);
  if (a1[32786])
  {
    uint64_t v9 = "bad write mode";
    __int16 v10 = 198;
    goto LABEL_3;
  }

  unint64_t v11 = a3;
  if (!a3) {
    return v11;
  }
  char v13 = (const uint8_t *)a1;
  unint64_t v14 = 0LL;
  dst_buffer = (uint8_t *)a1 + 65537;
  __dst = (char *)a1 + 65538;
  __int128 v155 = a1 + 32770;
  while (1)
  {
    uint64_t v15 = v8[6];
    if (v15 == v8[5])
    {
      uint64_t v9 = "segment out of range";
      __int16 v10 = 202;
      goto LABEL_3;
    }

    int v153 = v8[4];
    uint64_t v16 = &v153[6 * (void)v15];
    unint64_t v18 = v16 + 2;
    size_t v17 = v16[2];
    unint64_t v19 = v11 - v14;
    uint64_t v21 = v16 + 3;
    size_t v20 = v16[3];
    if (v20 - v17 >= v19) {
      size_t v22 = v19;
    }
    else {
      size_t v22 = v20 - v17;
    }
    memcpy((void *)&v13[(unsigned __int16)v17], (const void *)(a2 + v14), v22);
    size_t v23 = v22 + *v18;
    int v152 = v16 + 2;
    *unint64_t v18 = v23;
    uint64_t v149 = v16 + 3;
    size_t v24 = *v21;
    if (v23 == *v21) {
      v8[6] = (void *)((char *)v8[6] + 1);
    }
    size_t v25 = (unsigned __int16)v23;
    if ((_WORD)v23)
    {
      if (v23 < v24) {
        goto LABEL_134;
      }
    }

    else
    {
      size_t v25 = 0x10000LL;
    }

    size_t v150 = v22;
    uint64_t v26 = (void *)*v16;
    if (!*v16)
    {
      uint64_t v30 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        uint64_t v31 = 0LL;
        size_t v32 = v23 - v25 + v153[6 * (void)v15 + 5];
        uint64_t v33 = a1;
        size_t v34 = v25;
        while (1)
        {
          uint64_t v35 = (*(uint64_t (**)(void, _DWORD *, size_t, size_t))(v30 + 40))(*(void *)v30, v33, v34, v32);
          if (v35 < 1) {
            break;
          }
          uint64_t v33 = (_DWORD *)((char *)v33 + v35);
          v31 += v35;
          v32 += v35;
          v34 -= v35;
          if (!v34) {
            goto LABEL_85;
          }
        }

        uint64_t v31 = v35;
      }

      else
      {
        uint64_t v31 = -1LL;
      }

LABEL_85:
      BOOL v87 = v25 == v31;
      size_t v8 = (void **)v155;
      char v13 = (const uint8_t *)a1;
      size_t v22 = v150;
      if (!v87)
      {
        uint64_t v9 = "aaByteStreamPWriteExpected";
        __int16 v10 = 230;
        goto LABEL_3;
      }

      goto LABEL_134;
    }

    unint64_t v27 = v26[7];
    unint64_t v145 = v14;
    int v148 = &v153[6 * (void)v15];
    if ((unint64_t)v8[3] < v27)
    {
      v8[3] = (void *)v27;
      if (24 * v27 >= 0x2000000001LL)
      {
        *__error() = 12;
      }

      else
      {
        uint64_t v28 = v8[2];
        uint64_t v29 = realloc(v28, 24 * v27);
        if (v29)
        {
          v8[2] = v29;
          size_t v23 = *v152;
          goto LABEL_30;
        }

        free(v28);
      }

      v8[2] = 0LL;
      uint64_t v9 = "aaReallocf";
      __int16 v10 = 240;
      goto LABEL_3;
    }

    uint64_t v29 = v8[2];
LABEL_30:
    unint64_t v36 = (v23 - 1) >> 16;
    uint64_t v37 = v26[48] + 12 * v36;
    unint64_t v156 = v36;
    char v38 = &v29[3 * v36];
    size_t v39 = compression_encode_buffer( dst_buffer,  0x10000uLL,  v13,  v25,  0LL,  (compression_algorithm)LODWORD(v8[1][*((unsigned __int8 *)v26 + 432)]));
    if (v39 - 1 >= v25) {
      size_t v40 = v25 + 1;
    }
    else {
      size_t v40 = v39;
    }
    v38[1] = v40;
    __int16 v41 = v38 + 1;
    __int128 v144 = v38;
    v38[2] = v40;
    int v42 = v38 + 2;
    int v43 = &v153[6 * (void)v15];
    uint64_t v44 = v43[4];
    __int128 v157 = v43 + 4;
    size_t v45 = *(void *)v37 + *(unsigned int *)(v37 + 8);
    size_t v46 = v40;
    if (v44 + v40 < v45)
    {
      size_t v46 = v45 - v44;
      *int v42 = v45 - v44;
    }

    if (v46 == v25 + 1)
    {
      size_t *v41 = v25 + 1;
      uint8_t *dst_buffer = BYTE4(v8[1][*((unsigned __int8 *)v26 + 432)]);
      memcpy(__dst, a1, v25);
      size_t v40 = *v41;
      size_t v46 = *v42;
    }

    bzero(&dst_buffer[v40], v46 - v40);
    uint64_t v47 = v26[50];
    uint64_t v48 = *v157;
    unint64_t v49 = v47 - *v157;
    unint64_t v50 = *v42 - v49;
    __int128 v147 = v15;
    if (*v42 > v49) {
      break;
    }
LABEL_76:
    *__int128 v144 = v48;
    size_t v80 = *v42;
    uint64_t v81 = (uint64_t)*v8;
    if ((*v8)[5])
    {
      if (!v80) {
        goto LABEL_89;
      }
      uint64_t v82 = 0LL;
      uint64_t v83 = v153[6 * (void)v15 + 5] + v48;
      uint64_t v84 = dst_buffer;
      size_t v85 = *v42;
      while (1)
      {
        uint64_t v86 = (*(uint64_t (**)(void, uint8_t *, size_t, uint64_t))(v81 + 40))(*(void *)v81, v84, v85, v83);
        if (v86 < 1) {
          break;
        }
        v84 += v86;
        v82 += v86;
        v83 += v86;
        v85 -= v86;
        if (!v85) {
          goto LABEL_88;
        }
      }

      uint64_t v82 = v86;
    }

    else
    {
      uint64_t v82 = -1LL;
    }

          uint64_t v63 = *(void *)(v11 + 1216);
          if (__src)
          {
            uint64_t result = (uint64_t)memcpy((void *)(v63 + *v17), __src, v57);
          }

          else if (v63)
          {
            uint64_t result = memset_s((void *)(v63 + *v17), v57, 0, v57);
          }

          *v17 += v57;
          uint64_t v12 = 0uLL;
          if ((v57 & 0x8000000000000000LL) != 0) {
            goto LABEL_185;
          }
          v15 -= v57;
          __src += v57;
          v10 += v57;
          *(void *)(v11 + 1296) += v57;
          char v13 = *(_DWORD *)(v11 + 676);
LABEL_125:
          if (v13 == 5) {
            goto LABEL_188;
          }
          continue;
        }

        if (v18 != v20)
        {
          uint64_t v108 = "invalid state";
          unint64_t v109 = 234;
LABEL_158:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"writeProc",  v109,  108,  0,  v108,  a7,  a8,  v114);
          __int16 v10 = -1LL;
          goto LABEL_188;
        }

        src_buffer = *(uint8_t **)(v11 + 1216);
        __memcpy_chk();
        LODWORD(v149[0]) = v47;
        uint64_t result = memset_s((char *)v149 + v47 + 4, 256 - v47, 0, 256 - v47);
        uint64_t v66 = *(unsigned int *)(v11 + 44);
        __memcpy_chk();
        LODWORD(v130[0]) = v66;
        memset_s((char *)v130 + v66 + 4, 256 - v66, 0, 256 - v66);
        int v67 = *(_DWORD *)(v11 + 1276);
        memset((char *)v172 + 8, 0, 252);
        WORD4(v172[0]) = 19283;
        *(void *)&v172[0] = 0x5F41454100000006LL;
        uint64_t result = memset_s((char *)v172 + 10, 0xFAuLL, 0, 0xFAuLL);
        uint64_t v68 = LODWORD(v172[0]);
        if (LODWORD(v172[0]) >= 0xFD) {
          goto LABEL_224;
        }
        *(_DWORD *)((char *)v172 + LODWORD(v172[0]) + 4) = v67;
        LODWORD(v172[0]) = v68 + 4;
        memset_s((char *)v172 + v68 + 8, 252 - v68, 0, 252 - v68);
        memset(__s, 0, 260);
        uint64_t v69 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        uint64_t v15 = v118;
        if (!v69 || !*v124)
        {
          memset_s(v172, 0x104uLL, 0, 0x104uLL);
LABEL_176:
          uint64_t v106 = "decrypting segment";
          uint64_t v107 = 248;
          goto LABEL_186;
        }

        uint64_t v70 = v69(v151, *(unsigned int *)(v11 + 36), v124, v172, __s);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v70 < 0) {
          goto LABEL_176;
        }
        uint64_t v71 = *(uint64_t (**)(uint8_t *, size_t, _OWORD *, _OWORD *, void, void))(v11 + 128);
        if (!v71
          || LODWORD(v130[0]) != *(_DWORD *)(v11 + 44)
          || (v71(src_buffer, v18, v130, v151, 0LL, 0LL) & 0x80000000) != 0)
        {
          goto LABEL_176;
        }

        uint64_t v74 = v127;
        if (v20 < v49)
        {
          uint64_t v75 = *(void *)(v11 + 1232);
          if (v75 >= v49)
          {
            uint64_t v81 = *(uint8_t **)(v11 + 1240);
            goto LABEL_131;
          }

          do
          {
            while (!v75)
            {
              uint64_t v75 = 0x4000LL;
              __int16 v77 = 0x4000LL;
            }

            uint64_t v76 = v75 >> 1;
            if ((v75 & (v75 >> 1)) != 0) {
              uint64_t v76 = v75 & (v75 >> 1);
            }
            v75 += v76;
          }

          while (v75 < v49);
          __int16 v77 = v75;
          if (v75 >= 0x2000000001LL)
          {
            *__error() = 12;
          }

          else
          {
LABEL_129:
            uint64_t v82 = *(void **)(v11 + 1240);
            uint64_t v83 = (uint8_t *)realloc(v82, v77);
            if (v83)
            {
              uint64_t v81 = v83;
              *(void *)(v11 + 1240) = v83;
              *(void *)(v11 + 1232) = v77;
              uint64_t v75 = v77;
              uint64_t v15 = v118;
LABEL_131:
              _DWORD *v117 = 0LL;
              if (v81)
              {
                uint64_t v84 = *(unsigned int *)(v11 + 264);
                if ((_DWORD)v84 == 774)
                {
                  size_t v85 = PCompressLZMADecode(v81, v75, src_buffer, v18);
                  uint64_t v86 = v85 & ~(v85 >> 63);
                }

                else
                {
                  BOOL v87 = aeaEffectiveCompressionAlgorithm(v84);
                  LODWORD(v86) = compression_decode_buffer(v81, v75, src_buffer, v18, 0LL, v87);
                }

                if ((_DWORD)v86)
                {
                  size_t v88 = *v117 + v86;
                }

                uint64_t v74 = v117;
                if ((_DWORD)v49 == (_DWORD)v86) {
                  goto LABEL_140;
                }
                uint64_t v106 = "invalid compressed buffer";
                uint64_t v107 = 271;
              }

              else
              {
                uint64_t v106 = "invalid buffer";
                uint64_t v107 = 258;
              }

LABEL_134:
    v14 += v22;
    if (v14 >= v11) {
      return v11;
    }
  }

  int v51 = (_DWORD)v153 + 48 * (_DWORD)v15 + 40;
  __int128 v154 = &v153[6 * (void)v15 + 5];
  unint64_t v52 = v156;
  __int128 v140 = v42;
  do
  {
    if (!v52)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"fork_realign",  142,  136,  0,  "realignment failed",  a7,  a8,  v138);
      goto LABEL_139;
    }

    char v53 = v8[2];
    char v54 = &v53[3 * v52 - 3];
    uint64_t v57 = v54[2];
    unint64_t v55 = v54 + 2;
    uint64_t v56 = v57;
    uint64_t v58 = *(v55 - 1);
    unint64_t v59 = v57 - v58;
    unint64_t v60 = v50 - (v57 - v58);
    if (v50 > v57 - v58)
    {
      *unint64_t v55 = v58;
      --v52;
      goto LABEL_73;
    }

    *unint64_t v55 = v56 - v50;
    uint64_t v48 = v53[3 * v52 - 3] + v56 - v50;
    uint64_t *v157 = v48;
    if (v52 >= v156) {
      goto LABEL_76;
    }
    unint64_t v141 = v59;
    unint64_t v142 = v50;
    while (1)
    {
      uint64_t v61 = &v8[2][3 * v52];
      uint64_t v62 = *v154;
      uint64_t v63 = v61[1];
      uint64_t v64 = *v61 + *v154;
      uint64_t v65 = (uint64_t)*v8;
      if ((*v8)[11])
      {
        if (v63 != aaByteStreamSimulate(*v8))
        {
          __int16 v77 = 173;
          uint64_t v78 = "aaByteStreamSimulate";
          goto LABEL_72;
        }

        goto LABEL_59;
      }

      if (*(void *)(v65 + 32))
      {
        if (!v63)
        {
          if (!*(void *)(v65 + 40)) {
            goto LABEL_70;
          }
          goto LABEL_68;
        }

        uint64_t v66 = 0LL;
        int v67 = a1;
        uint64_t v68 = v61[1];
        while (1)
        {
          uint64_t v69 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v65 + 32))( *(void *)v65,  v67,  v68,  v64);
          if (v69 < 0) {
            break;
          }
          if (v69)
          {
            int v67 = (_DWORD *)((char *)v67 + v69);
            v66 += v69;
            v64 += v69;
            v68 -= v69;
            if (v68) {
              continue;
            }
          }

          goto LABEL_58;
        }

        uint64_t v66 = v69;
      }

      else
      {
        uint64_t v66 = -1LL;
      }

LABEL_68:
      uint64_t v76 = *v157;
      *uint64_t v61 = *v157;
      uint64_t v48 = v76 + v63;
      uint64_t *v157 = v76 + v63;
      if (++v52 == v156) {
        goto LABEL_75;
      }
    }

    __int16 v77 = 176;
    uint64_t v78 = "aaByteStreamPReadExpected";
LABEL_72:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"fork_realign",  v77,  136,  0,  v78,  a7,  a8,  v138);
    int v51 = -1;
    unint64_t v50 = v142;
    unint64_t v11 = a3;
    unint64_t v60 = v142;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    int v42 = v140;
    unint64_t v59 = v141;
LABEL_73:
    BOOL v79 = v50 > v59;
    unint64_t v50 = v60;
  }

  while (v79);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_75:
    uint64_t v48 = *v157;
    unint64_t v11 = a3;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    int v42 = v140;
    goto LABEL_76;
  }

    size_t v25 = -1LL;
    goto LABEL_69;
  }

  if (v16 == 4408665)
  {
    uint64_t v28 = *(void *)(a1 + 4784);
    unint64_t v18 = __CFADD__(v28, __smax);
    uint64_t v29 = v28 + __smax;
    if (!v18 && (v29 & 0x8000000000000000LL) == 0)
    {
      size_t v20 = (void *)(a1 + 4784);
      uint64_t v30 = *(void *)(a1 + 4792);
      if (v30 >= v29) {
        goto LABEL_79;
      }
      do
      {
        while (!v30)
        {
          uint64_t v30 = 0x4000LL;
          if (v29 <= 0x4000)
          {
            size_t v23 = (void **)(a1 + 4800);
            uint64_t v30 = 0x4000LL;
            goto LABEL_77;
          }
        }

        uint64_t v31 = v30 >> 1;
        if ((v30 & (v30 >> 1)) != 0) {
          uint64_t v31 = v30 & (v30 >> 1);
        }
        v30 += v31;
      }

      while (v30 < v29);
      size_t v23 = (void **)(a1 + 4800);
      if (v30 >= 0x2000000001LL) {
        goto LABEL_83;
      }
LABEL_77:
      __int16 v41 = *v23;
      uint64_t v44 = realloc(*v23, v30);
      if (v44)
      {
        *(void *)(a1 + 4800) = v44;
        *(void *)(a1 + 4792) = v30;
LABEL_79:
        int v43 = *(void *)(a1 + 4800);
        if (!v15) {
          goto LABEL_80;
        }
        goto LABEL_87;
      }

  v45.uint64_t ikey = 5521752;
  size_t v46 = AAHeaderGetKeyIndex(header, v45);
  if ((v46 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v46, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000LL) != 0)
    {
LABEL_169:
      __int16 v10 = "XAT blob allocation";
      unint64_t v11 = 1335;
      goto LABEL_4;
    }

    uint64_t v47 = *((void *)v35 + 276);
    if (v47 < size)
    {
      do
      {
        while (!v47)
        {
          uint64_t v47 = 0x4000LL;
          if (size <= 0x4000)
          {
            unint64_t v49 = (void **)(v35 + 2216);
            uint64_t v47 = 0x4000LL;
            goto LABEL_81;
          }
        }

        uint64_t v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0) {
          uint64_t v48 = v47 & (v47 >> 1);
        }
        v47 += v48;
      }

      while (v47 < size);
      unint64_t v49 = (void **)(v35 + 2216);
      if (v47 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_168;
      }

              unint64_t v60 = a2;
              uint64_t v61 = v31;
              int v42 = *v31;
              int v43 = realloc(*v31, a2);
              if (v43)
              {
                v12[280] = v43;
                v12[279] = v60;
                goto LABEL_70;
              }

              free(v42);
LABEL_111:
              *uint64_t v61 = 0LL;
              *uint64_t v29 = 0LL;
              v12[279] = 0LL;
              goto LABEL_112;
            }

        size_t v23 = 1;
        goto LABEL_69;
      case 3:
        if (((char)v18 - 48) > 9)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(void *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            unint64_t v27 = 4;
            goto LABEL_126;
          }

          uint64_t v30 = "jsonPushValue";
          uint64_t v31 = 539;
          goto LABEL_103;
        }

        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          uint64_t v31 = 533;
          goto LABEL_103;
        }

        continue;
      case 4:
        if (((char)v18 - 97) > 0x19)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(void *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            uint64_t v28 = *(const char **)(a1 + 112);
            if (!strcmp(v28, "false") || !strcmp(v28, "true"))
            {
              unint64_t v27 = 6;
            }

            else
            {
              if (strcmp(v28, "null")) {
                goto LABEL_102;
              }
              unint64_t v27 = 7;
            }

            goto LABEL_126;
          }

          uint64_t v30 = "jsonPushValue";
          uint64_t v31 = 524;
          goto LABEL_103;
        }

        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          uint64_t v30 = "jsonPushValue";
          uint64_t v31 = 519;
          goto LABEL_103;
        }

        continue;
      case 5:
        if ((char)v18 < 0)
        {
        }

        else if ((*(_DWORD *)(v14 + 4LL * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }

        size_t v24 = *(_DWORD *)(a1 + 24);
        if (!v24)
        {
          uint64_t v30 = "invalid JSON state";
          uint64_t v31 = 546;
          goto LABEL_103;
        }

        size_t v25 = v24 - 1;
        uint64_t v26 = *(_DWORD *)(*(void *)(a1 + 32) + 4LL * v25);
        if (v18 != 44)
        {
          if (v18 == 93)
          {
            if ((v26 & 1) != 0) {
              goto LABEL_121;
            }
            unint64_t v19 = 93;
          }

          else if (v18 == 125)
          {
            goto LABEL_91;
          }

uint64_t ForkOutputStreamPWrite( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a4;
  uint64_t v9 = (uint64_t *)(a1 + 131080);
  if (*(_DWORD *)(a1 + 131144))
  {
LABEL_2:
    unint64_t v10 = 0LL;
    if (a3)
    {
      unint64_t v41 = a3;
      while (1)
      {
        if (v9[7] <= v8)
        {
LABEL_35:
          size_t v32 = "no segment found";
          __int16 v33 = 340;
          goto LABEL_48;
        }

        uint64_t v11 = v9[4];
        unint64_t v12 = v9[5];
        if (v12 < 2)
        {
          if (!v11) {
            goto LABEL_35;
          }
          unint64_t v13 = 0LL;
        }

        else
        {
          unint64_t v13 = 0LL;
          do
          {
            if (*(void *)(v11 + 48 * ((v12 + v13) >> 1) + 8) <= v8) {
              unint64_t v13 = (v12 + v13) >> 1;
            }
            else {
              unint64_t v12 = (v12 + v13) >> 1;
            }
          }

          while (v13 + 1 < v12);
        }

        if (*(void *)(v11 + 48 * v13))
        {
          size_t v32 = "compressed fork";
          __int16 v33 = 341;
          goto LABEL_48;
        }

        unint64_t v14 = (void *)(v11 + 48 * v13);
        unint64_t v15 = v8 - v14[1];
        unint64_t v16 = v14[3];
        if (a3 - v10 >= v16 - v15) {
          unint64_t v17 = v16 - v15;
        }
        else {
          unint64_t v17 = a3 - v10;
        }
        unint64_t v18 = v17 + v14[2];
        v14[2] = v18;
        if (v18 > v16)
        {
          size_t v32 = "too much data";
          __int16 v33 = 349;
          goto LABEL_48;
        }

        uint64_t v19 = *v9;
        if (*(void *)(*v9 + 40))
        {
          if (!v17) {
            goto LABEL_28;
          }
          uint64_t v20 = 0LL;
          unint64_t v21 = a2 + v10;
          unint64_t v22 = *(void *)(v11 + 48 * v13 + 40) + v15;
          unint64_t v23 = v17;
          while (1)
          {
            uint64_t v24 = (*(uint64_t (**)(void, unint64_t, unint64_t, unint64_t))(v19 + 40))( *(void *)v19,  v21,  v23,  v22);
            if (v24 < 1) {
              break;
            }
            v21 += v24;
            v20 += v24;
            v22 += v24;
            v23 -= v24;
            if (!v23) {
              goto LABEL_27;
            }
          }

          uint64_t v20 = v24;
        }

        else
        {
          uint64_t v20 = -1LL;
        }

void ForkOutputStreamCancel(uint64_t a1)
{
}

uint64_t ForkOutputStreamClose( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = a1 + 16387;
    unint64_t v10 = a1[16389];
    if (v10)
    {
      uint64_t v11 = (char *)v9[3];
      if (v11)
      {
        unint64_t v12 = v10 + 3;
        while (*(v12 - 1) == *v12)
        {
          v12 += 6;
          if (!--v11) {
            goto LABEL_7;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c",  (uint64_t)"ForkOutputStreamClose",  382,  136,  0,  "data missing",  a7,  a8,  v15);
        int v13 = 0;
        unint64_t v10 = v9[2];
      }

      else
      {
LABEL_7:
        int v13 = 1;
      }

      free(v10);
    }

    else
    {
      int v13 = 1;
    }

    free(*v9);
    free(a1);
  }

  else
  {
    int v13 = 1;
  }

  if (v13) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BlobBufferStore(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  size_t v8 = *(void *)(a1 + 8) + a3;
  if ((BlobBufferIncreaseCapacity(a1, v8) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c",  (uint64_t)"BlobBufferStore",  19,  6,  0,  "BlobBufferStore",  v9,  v10,  v12);
    return 0xFFFFFFFFLL;
  }

  else
  {
    if (a2) {
      memcpy((void *)(*(void *)(a1 + 16) + *(void *)(a1 + 8)), a2, a3);
    }
    if (a4)
    {
      *a4 = *(void *)(a1 + 8);
      a4[1] = a3;
    }

    uint64_t result = 0LL;
    *(void *)(a1 + 8) = v8;
  }

  return result;
}

uint64_t BlobBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  size_t v2 = *(void *)a1;
  if (*(void *)a1 >= a2) {
    return 0LL;
  }
  do
  {
    uint64_t v4 = v2 + (v2 >> 1);
    if (__CFADD__(v2, v2 >> 1)) {
      uint64_t v4 = -1LL;
    }
    if (v2) {
      size_t v2 = v4;
    }
    else {
      size_t v2 = 0x10000LL;
    }
  }

  while (v2 < a2);
  unint64_t v5 = reallocf(*(void **)(a1 + 16), v2);
  *(void *)(a1 + 16) = v5;
  if (v5)
  {
    uint64_t result = 0LL;
    *(void *)a1 = v2;
  }

  else
  {
    uint64_t v7 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c",  (uint64_t)"BlobBufferIncreaseCapacity",  58,  6,  *v7,  "malloc",  v8,  v9,  v10);
    return 0xFFFFFFFFLL;
  }

  return result;
}

void BlobBufferFree(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
}

void *StringTableCreate()
{
  uint64_t v0 = calloc(1uLL, 0x28uLL);
  if (!v0)
  {
    unsigned int v1 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c",  (uint64_t)"StringTableCreate",  30,  35,  *v1,  "malloc",  v2,  v3,  v5);
  }

  return v0;
}

uint64_t stringTableReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2) {
    return 0LL;
  }
  unsigned int v4 = v2 ? v2 + (v2 >> 1) : 32;
  if (v4 <= a2) {
    unsigned int v4 = a2;
  }
  *(_DWORD *)(a1 + 4) = v4;
  char v5 = reallocf(*(void **)(a1 + 8), 16LL * v4);
  *(void *)(a1 + 8) = v5;
  if (v5) {
    return 0LL;
  }
  uint64_t v7 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c",  (uint64_t)"stringTableReserve",  23,  35,  *v7,  "malloc",  v8,  v9,  v10);
  return 0xFFFFFFFFLL;
}

void StringTableDestroy(void **a1)
{
  if (a1)
  {
    BlobBufferFree((uint64_t)(a1 + 2));
    free(a1[1]);
    free(a1);
  }

uint64_t StringTableClear(uint64_t result)
{
  *(void *)(result + 24) = 0LL;
  *(_DWORD *)uint64_t result = 0;
  return result;
}

uint64_t StringTableAppend( unsigned int *a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    *a4 = *a1;
  }
  if (HIDWORD(a3))
  {
    uint64_t v11 = "string too long for StringTable";
    __int16 v12 = 74;
  }

  else if (stringTableReserve((uint64_t)a1, *a1 + 1))
  {
    uint64_t v11 = "increasing string table capacity";
    __int16 v12 = 77;
  }

  else
  {
    if (!BlobBufferStore((uint64_t)(a1 + 4), 0LL, a3 + 1, &v17))
    {
      uint64_t v14 = *((void *)a1 + 1) + 16LL * *a1;
      uint64_t v15 = v17;
      *(void *)uint64_t v14 = v17;
      *(_DWORD *)(v14 + 8) = a3;
      unint64_t v16 = (void *)(*((void *)a1 + 4) + v15);
      memcpy(v16, a2, a3);
      uint64_t result = 0LL;
      *((_BYTE *)v16 + a3) = 0;
      ++*a1;
      return result;
    }

    uint64_t v11 = "insertion failed in string table";
    __int16 v12 = 81;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c",  (uint64_t)"StringTableAppend",  v12,  35,  0,  v11,  a7,  a8,  v17);
  return 0xFFFFFFFFLL;
}

uint64_t StringTableAppendTable(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  if (a3) {
    *a3 = *(_DWORD *)a1;
  }
  if (!*a2) {
    return 0LL;
  }
  if (stringTableReserve(a1, *(_DWORD *)a1 + *a2))
  {
    uint64_t v7 = "increasing string table capacity";
    __int16 v8 = 152;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c",  (uint64_t)"StringTableAppendTable",  v8,  35,  0,  v7,  v5,  v6,  v15);
    return 0xFFFFFFFFLL;
  }

  if (BlobBufferStore(a1 + 16, *((const void **)a2 + 4), *((void *)a2 + 3), &v15))
  {
    uint64_t v7 = "increasing blob capacity failed";
    __int16 v8 = 156;
    goto LABEL_9;
  }

  if (*a2)
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    uint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unsigned int v13 = v11 + *(_DWORD *)a1;
      *(_OWORD *)(v12 + 16LL * v13) = *(_OWORD *)(*((void *)a2 + 1) + v10);
      uint64_t v12 = *(void *)(a1 + 8);
      *(void *)(v12 + 16LL * v13) += v15;
      ++v11;
      unint64_t v14 = *a2;
      v10 += 16LL;
    }

    while (v11 < v14);
  }

  else
  {
    LODWORD(v14) = 0;
  }

  uint64_t result = 0LL;
  *(_DWORD *)a1 += v14;
  return result;
}

size_t StringTableSort(unsigned int *a1, void *a2)
{
  size_t result = *a1;
  if ((_DWORD)result)
  {
    if (a2)
    {
      uint64_t v5 = calloc(result, 4uLL);
      if (!v5)
      {
        unsigned int v13 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c",  (uint64_t)"StringTableSort",  195,  35,  *v13,  "malloc",  v14,  v15,  v16);
        return 0xFFFFFFFFLL;
      }

      uint64_t v6 = v5;
      *a2 = v5;
      size_t result = *a1;
      if ((_DWORD)result)
      {
        uint64_t v7 = 0LL;
        __int16 v8 = (_DWORD *)(*((void *)a1 + 1) + 12LL);
        do
        {
          *__int16 v8 = v7;
          v8 += 4;
          ++v7;
        }

        while (result != v7);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    qsort_r( *((void **)a1 + 1),  result,  0x10uLL,  a1,  (int (__cdecl *)(void *, const void *, const void *))stringTableIndexCompareProc);
    if (*a1 < 2)
    {
      unsigned int v11 = 1;
    }

    else
    {
      uint64_t v9 = 0LL;
      unint64_t v10 = 1LL;
      unsigned int v11 = 1;
      do
      {
        uint64_t v12 = *((void *)a1 + 1);
        if (!strcmp( (const char *)(*((void *)a1 + 4) + *(void *)(v12 + 16LL * (v11 - 1))),  (const char *)(*((void *)a1 + 4) + *(void *)(v12 + v9 + 16))))
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11 - 1;
          }
        }

        else
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11;
          }
          if (v10 != v11) {
            *(_OWORD *)(v12 + 16LL * v11) = *(_OWORD *)(v12 + v9 + 16);
          }
          ++v11;
        }

        ++v10;
        v9 += 16LL;
      }

      while (v10 < *a1);
    }

    size_t result = 0LL;
    *a1 = v11;
  }

  return result;
}

uint64_t stringTableIndexCompareProc(uint64_t a1, void *a2, void *a3)
{
  return strcmp((const char *)(*(void *)(a1 + 32) + *a2), (const char *)(*(void *)(a1 + 32) + *a3));
}

uint64_t StringTableSearchSortedWithLength(uint64_t a1, char *__s1, size_t a3, unsigned int *a4)
{
  int v5 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  size_t v10 = *(unsigned int *)(v9 + 8);
  int v11 = strncmp(__s1, (const char *)(*(void *)(a1 + 32) + *(void *)v9), a3);
  if (v11)
  {
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_6:
    uint64_t result = 0LL;
    if (!a4) {
      return result;
    }
    unsigned int v13 = -1;
    goto LABEL_8;
  }

  if (v10 > a3) {
    goto LABEL_6;
  }
  if (v10 >= a3)
  {
    uint64_t result = 1LL;
    if (!a4) {
      return result;
    }
    unsigned int v13 = 0;
    goto LABEL_8;
  }

uint64_t StringTableMatchesPrefixSorted(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4)
  {
    size_t v6 = v4 - 1;
    while (__s[v6] != 47 || !StringTableSearchSortedWithLength(a1, __s, v6, 0LL))
    {
      if (--v6 == -1LL) {
        return 0LL;
      }
    }

    return 1LL;
  }

  return 0LL;
}

uint64_t StringTableSize(unsigned int *a1)
{
  return *a1;
}

uint64_t StringTableCmp(uint64_t a1, unsigned int a2, char *__s1, size_t __n)
{
  uint64_t v5 = *(void *)(a1 + 8) + 16LL * a2;
  size_t v6 = *(unsigned int *)(v5 + 8);
  LODWORD(result) = strncmp(__s1, (const char *)(*(void *)(a1 + 32) + *(void *)v5), __n);
  if (v6 <= __n) {
    unsigned int v8 = v6 < __n;
  }
  else {
    unsigned int v8 = -1;
  }
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t ECCFixThreadProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      size_t v10 = "creating workBuffer";
      __int16 v11 = 157;
LABEL_31:
      int v25 = 0;
LABEL_32:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ECCFixThreadProc",  v11,  64,  v25,  v10,  a7,  a8,  v27);
      goto LABEL_33;
    }
  }

  for (unint64_t i = *(void *)(a1 + 8); i < *(void *)(a1 + 16); ++i)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 28);
    uint64_t v14 = i * v13;
    unint64_t v15 = *(void *)(a1 + 64);
    if (v15 < i * v13)
    {
      size_t v10 = "Invalid block index";
      __int16 v11 = 166;
      goto LABEL_31;
    }

    if (v14 + v13 <= v15) {
      size_t v16 = v13;
    }
    else {
      size_t v16 = (v15 - v14);
    }
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      uint64_t v19 = *(void *)(a1 + 48) + v14;
    }

    else
    {
      ssize_t v18 = pread(v17, v9, v16, *(void *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        int v25 = *__error();
        size_t v10 = "reading data segment";
        __int16 v11 = 174;
        goto LABEL_32;
      }

      uint64_t v19 = (uint64_t)v9;
      if ((_DWORD)v16 != (_DWORD)v18)
      {
        LOBYTE(v27) = v18;
        size_t v10 = "Truncated read n=%zd pos=%llu read=%u fd=%d";
        __int16 v11 = 175;
        goto LABEL_31;
      }
    }

    uint64_t v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(void *)(a1 + 80))
    {
      size_t v10 = "Parity buffer out of range";
      __int16 v11 = 187;
      goto LABEL_31;
    }

    if (*(_DWORD *)(a1 + 24) != 1)
    {
      int v27 = *(_DWORD *)(a1 + 24);
      size_t v10 = "invalid variant %u";
      __int16 v11 = 205;
      goto LABEL_31;
    }

    uint64_t v28 = 0LL;
    int v21 = ECC65537CheckAndFix(v16, v19, (uint16x8_t *)(*(void *)(a1 + 72) + i * v20), &v28);
    if (v21 < 0)
    {
      ++*(void *)(a1 + 88);
    }

    else if (v21)
    {
      ++*(void *)(a1 + 96);
      v22.i64[0] = v28;
      v22.i64[1] = HIDWORD(v28);
      *(int64x2_t *)(a1 + 104) = vaddq_s64(*(int64x2_t *)(a1 + 104), (int64x2_t)vextq_s8(v22, v22, 8uLL));
      int v23 = *(_DWORD *)(a1 + 40);
      if ((v23 & 0x80000000) == 0)
      {
        ssize_t v24 = pwrite(v23, v9, v16, *(void *)(a1 + 56) + v14);
        if (v24 < 0)
        {
          int v25 = *__error();
          size_t v10 = "writing data segment";
          __int16 v11 = 211;
          goto LABEL_32;
        }

        if ((_DWORD)v16 != (_DWORD)v24)
        {
          LOBYTE(v27) = v24;
          size_t v10 = "Truncated write n=%zd pos=%llu read=%u fd=%d";
          __int16 v11 = 212;
          goto LABEL_31;
        }
      }
    }
  }

uint64_t ParallelArchiveECCFixFileSegment( int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6)
{
  return ParallelArchiveECCFixCommon(a1, 0LL, a2, a3, a4, a5, a6);
}

uint64_t ParallelArchiveECCFixCommon( int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  unsigned int DefaultNThreads = *(_DWORD *)(a7 + 4);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  int v91 = *(_DWORD *)a7;
  uint64_t v111 = 0LL;
  uint64_t v112 = 0LL;
  int v113 = 0;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  __int128 v108 = 0u;
  double RealTime = getRealTime();
  *(void *)(a7 + 16) = 0LL;
  *(_DWORD *)(a7 + 12) = 0;
  enterThreadErrorContext(v16, v17, v18, v19, v20, v21, v22, v23, v81);
  unint64_t v90 = a4;
  if (a6 <= 0x2F)
  {
    uint64_t v26 = "Truncated ECC buffer";
    __int16 v27 = 452;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  v27,  64,  0,  v26,  v24,  v25,  v82);
LABEL_10:
    int v29 = 0;
    unint64_t v30 = 0LL;
    unint64_t v31 = 0LL;
    unint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
    unsigned int v34 = 0;
    int v35 = 0;
    goto LABEL_11;
  }

  __int128 v28 = a5[1];
  __int128 v108 = *a5;
  __int128 v109 = v28;
  __int128 v110 = a5[2];
  if ((void)v108 != 0x3031304343455842LL)
  {
    uint64_t v26 = "Invalid ECC magic";
    __int16 v27 = 454;
    goto LABEL_9;
  }

  if (HIDWORD(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 455;
    goto LABEL_9;
  }

  unsigned int v89 = DWORD2(v110);
  if (!DWORD2(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 456;
    goto LABEL_9;
  }

  if (*((void *)&v108 + 1) != a4)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  457,  64,  0,  "Input buffer size mismatch: expected %llu B, got %llu B",  v24,  v25,  SBYTE8(v108));
    goto LABEL_10;
  }

  int v35 = DWORD1(v110);
  if (DWORD1(v110) != 1)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  476,  64,  0,  "Invalid ECC variant: %u",  v24,  v25,  SBYTE4(v110));
    int v29 = 0;
    unint64_t v30 = 0LL;
    unint64_t v31 = 0LL;
    unint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
LABEL_55:
    unsigned int v34 = v89;
    goto LABEL_11;
  }

  if (DWORD2(v110) >= 0x1FFE1)
  {
    unsigned int v34 = DWORD2(v110);
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  472,  64,  0,  "Invalid blockSize: %u",  v24,  v25,  SBYTE8(v110));
    int v29 = 0;
    unint64_t v30 = 0LL;
    unint64_t v31 = 0LL;
    unint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
    int v35 = 1;
    goto LABEL_11;
  }

  unint64_t v49 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  uint64_t v84 = 34 * v49;
  if (34 * v49 + 48 != a6)
  {
    unint64_t v52 = "Invalid ECC buffer size";
    __int16 v53 = 481;
    goto LABEL_52;
  }

  unint64_t v86 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v49 >= DefaultNThreads) {
    unsigned int v50 = DefaultNThreads;
  }
  else {
    unsigned int v50 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  }
  if (v50 <= 1) {
    size_t v51 = 1LL;
  }
  else {
    size_t v51 = v50;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      unint64_t v52 = "computing buffer digest";
      __int16 v53 = 495;
      goto LABEL_52;
    }
  }

  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v111) & 0x80000000) != 0)
  {
    unint64_t v52 = "computing file digest";
    __int16 v53 = 491;
LABEL_52:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  v53,  64,  0,  v52,  v24,  v25,  v82);
    int v29 = 0;
    unint64_t v30 = 0LL;
LABEL_53:
    unint64_t v31 = 0LL;
    unint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
LABEL_54:
    int v35 = 1;
    goto LABEL_55;
  }

  unint64_t v87 = (v86 + v51 - 1) / v51;
  if (v91 >= 1)
  {
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    __int128 v102 = 0u;
    __int128 v103 = 0u;
    __int128 v100 = 0u;
    __int128 v101 = 0u;
    __int128 v98 = 0u;
    __int128 v99 = 0u;
    __int128 v96 = 0u;
    __int128 v97 = 0u;
    __int128 v94 = 0u;
    __int128 v95 = 0u;
    __int128 v92 = 0u;
    __int128 v93 = 0u;
    char v54 = (FILE **)MEMORY[0x1895F89D0];
    fwrite("ParallelArchiveECCFixCommon:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf(*v54, "  Input data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
    fprintf(*v54, "  Expected SHA1: %s\n", (const char *)&v92);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v54);
    fwrite("RS65537\n", 8uLL, 1uLL, *v54);
    fprintf(*v54, "%12llu data size\n", a4);
    fprintf(*v54, "%12u block size\n", v89);
    fprintf(*v54, "%12u ECC parity size per block\n", 34);
    fprintf(*v54, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v89);
    fprintf(*v54, "%12zu block count\n", v86);
    fprintf(*v54, "%12zu ECC buffer size\n", a6);
    fprintf(*v54, "%12u worker threads\n", v51);
    fprintf(*v54, "%12zu blocks per thread\n", v87);
  }

  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v30 = 0LL;
    unint64_t v31 = 0LL;
    unint64_t v32 = 0LL;
    unint64_t v33 = 0LL;
    int v29 = 1;
    goto LABEL_54;
  }

  uint64_t v57 = calloc(v51, 0x78uLL);
  unint64_t v30 = (unint64_t)v57;
  if (!v57)
  {
    uint64_t v72 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  526,  64,  *v72,  "malloc %u threads",  v73,  v74,  v51);
    int v29 = 0;
    goto LABEL_53;
  }

  uint64_t v58 = 0LL;
  uint64_t v83 = a5 + 3;
  size_t v59 = v51;
  uint64_t v60 = (uint64_t)v57;
  int v29 = 1;
  unint64_t v61 = (v86 + v51 - 1) / v51;
  do
  {
    unint64_t v62 = v61 * v58;
    if (v61 * v58 < v86)
    {
      unint64_t v63 = v62 + v87;
      if (v62 + v87 >= v86) {
        unint64_t v63 = v86;
      }
      *(void *)(v60 + 8) = v62;
      *(void *)(v60 + 16) = v63;
      *(_DWORD *)(v60 + 40) = a1;
      *(void *)(v60 + 48) = a2;
      *(void *)(v60 + 56) = a3;
      *(void *)(v60 + 64) = v90;
      *(void *)(v60 + 72) = v83;
      *(void *)(v60 + 80) = v84;
      *(_DWORD *)(v60 + 24) = 1;
      *(_DWORD *)(v60 + 28) = v89;
      *(void *)(v60 + 32) = 34LL;
      int Thread = createThread((pthread_t *)v60, (uint64_t)ECCFixThreadProc, v60, 0LL);
      unint64_t v61 = (v86 + v51 - 1) / v51;
      if (Thread)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  549,  64,  0,  "createThread",  v65,  v66,  v82);
        unint64_t v61 = (v86 + v51 - 1) / v51;
        int v29 = 0;
      }
    }

    ++v58;
    v60 += 120LL;
    --v59;
  }

  while (v59);
  int64x2_t v67 = 0uLL;
  int64x2_t v68 = 0uLL;
  do
  {
    if (*(void *)v30)
    {
      int64x2_t v85 = v68;
      int64x2_t v88 = v67;
      if (joinThread(*(_opaque_pthread_t **)v30))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  556,  64,  0,  "joinThread",  v69,  v70,  v82);
        int v29 = 0;
      }

      int64x2_t v68 = vaddq_s64(*(int64x2_t *)(v30 + 104), v85);
      int64x2_t v67 = vaddq_s64(*(int64x2_t *)(v30 + 88), v88);
    }

    v30 += 120LL;
    --v51;
  }

  while (v51);
  unint64_t v32 = v67.u64[1];
  unint64_t v33 = v67.i64[0];
  unint64_t v30 = v68.u64[1];
  unint64_t v71 = v68.i64[0];
  if (v67.i64[0]) {
    goto LABEL_81;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, v90, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      __int16 v77 = "computing buffer digest";
      __int16 v78 = 574;
      goto LABEL_102;
    }
  }

  else if ((getFileSegmentSHA1DigestFD(a1, a3, v90, (uint64_t)&v111) & 0x80000000) != 0)
  {
    __int16 v77 = "computing file digest";
    __int16 v78 = 570;
LABEL_102:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCFixCommon",  v78,  64,  0,  v77,  v75,  v76,  v82);
    int v29 = 0;
    unint64_t v33 = 0LL;
LABEL_81:
    int v35 = 1;
    unsigned int v34 = v89;
LABEL_82:
    unint64_t v31 = v71;
    goto LABEL_11;
  }

  unsigned int v34 = v89;
  if (v91 >= 1)
  {
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    __int128 v102 = 0u;
    __int128 v103 = 0u;
    __int128 v100 = 0u;
    __int128 v101 = 0u;
    __int128 v98 = 0u;
    __int128 v99 = 0u;
    __int128 v96 = 0u;
    __int128 v97 = 0u;
    __int128 v94 = 0u;
    __int128 v95 = 0u;
    __int128 v92 = 0u;
    __int128 v93 = 0u;
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf((FILE *)*MEMORY[0x1895F89D0], "  Output data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
  }

  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v33 = 0LL;
    int v35 = 1;
    goto LABEL_82;
  }

  unint64_t v30 = 0LL;
  unint64_t v31 = 0LL;
  unint64_t v32 = 0LL;
  int v35 = 1;
  unint64_t v33 = v86;
LABEL_11:
  uint64_t result = leaveThreadErrorContext(0LL, 0LL, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (!v29) {
    return 0xFFFFFFFFLL;
  }
  int v37 = 0x7FFF;
  if (v30 < 0x7FFF) {
    int v37 = v30;
  }
  int v38 = v37 << 8;
  int v39 = 255;
  if (v32 < 0xFF) {
    int v39 = v32;
  }
  int v40 = v38 | v39;
  int v41 = 255;
  if (v33 < 0xFF) {
    int v41 = v33;
  }
  int v42 = v38 | v41 | 0x800000;
  if (v33) {
    int v43 = v42;
  }
  else {
    int v43 = v40;
  }
  if (v91 <= 0)
  {
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 20) = v43;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    unsigned int v44 = v34;
    size_t v45 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%12llu fixed blocks\n", v32);
    unint64_t v46 = v31;
    fprintf(*v45, "%12llu fixed bytes\n", v31);
    fprintf(*v45, "%12llu fixed bits\n", v30);
    if (v33)
    {
      fprintf(*v45, "%12llu INVALID BLOCKS\n", v33);
      uint64_t v47 = "FAIL";
    }

    else
    {
      uint64_t v47 = "OK";
    }

    fprintf(*v45, "    0x%06x diagnostic code\n", v43);
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v44;
    *(_DWORD *)(a7 + 20) = v43;
    double v48 = getRealTime();
    fprintf( *v45,  "Total time %.2fs, %.2f MB/s (%s)\n",  v48 - RealTime,  (double)v90 * 0.000000953674316 / (v48 - RealTime),  v47);
    unint64_t v31 = v46;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }

  if (v31 >= 0x7FFFFFFF) {
    return 0x7FFFFFFFLL;
  }
  else {
    return v31;
  }
}

uint64_t ParallelArchiveECCVerifyCommon( int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  int v18 = 0;
  if (a6 <= 0x2F)
  {
    unsigned int v8 = "Truncated ECC buffer";
    __int16 v9 = 390;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"ParallelArchiveECCVerifyCommon",  v9,  64,  0,  v8,  a7,  a8,  v13);
    return 0xFFFFFFFFLL;
  }

  __int128 v13 = *a5;
  __int128 v14 = a5[1];
  __int128 v15 = a5[2];
  if (*(void *)a5 != 0x3031304343455842LL)
  {
    unsigned int v8 = "Invalid ECC magic";
    __int16 v9 = 392;
    goto LABEL_7;
  }

  if (HIDWORD(v15))
  {
    unsigned int v8 = "Invalid ECC header";
    __int16 v9 = 393;
    goto LABEL_7;
  }

  if (!DWORD2(v15))
  {
    unsigned int v8 = "Invalid ECC header";
    __int16 v9 = 394;
    goto LABEL_7;
  }

  if (*((void *)&v13 + 1) != a4) {
    return 0LL;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v16) & 0x80000000) != 0)
    {
      unsigned int v8 = "computing buffer digest";
      __int16 v9 = 404;
      goto LABEL_7;
    }
  }

  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v16) & 0x80000000) != 0)
  {
    unsigned int v8 = "computing file digest";
    __int16 v9 = 400;
    goto LABEL_7;
  }

  return v16 == (void)v14 && v17 == *((void *)&v14 + 1) && v18 == (unint64_t)v15;
}

uint64_t ParallelArchiveECCVerifyFileSegment( int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(a1, 0LL, a2, a3, a4, a5, a7, a8);
}

void *OECCStreamCreate(int a1, unsigned int a2, uint64_t a3)
{
  size_t v6 = calloc(1uLL, 0xB0uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *(_DWORD *)size_t v6 = a1;
    v6[4] = a3;
    *((_DWORD *)v6 + 10) = a2;
    unsigned int v8 = malloc(a2);
    v7[8] = v8;
    if (v8)
    {
      if (a1 != 1)
      {
        __int16 v11 = "Invalid ECC algorithm";
        __int16 v12 = 857;
        goto LABEL_9;
      }

      if (a2 >= 0x1FFE1)
      {
        __int16 v11 = "Invalid ECC block size";
        __int16 v12 = 853;
LABEL_9:
        int v13 = 0;
        goto LABEL_10;
      }

      *((_DWORD *)v7 + 6) = 34;
      size_t v15 = 34 * ((a3 + (unint64_t)a2 - 1) / a2) + 48;
      v7[2] = v15;
      uint64_t v16 = malloc(v15);
      v7[1] = v16;
      if (v16)
      {
        CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)((char *)v7 + 76));
        v7[7] = 48LL;
        checkEOF((int *)v7);
        return v7;
      }

      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 862;
    }

    else
    {
      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 846;
    }
  }

  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 841;
  }

int *checkEOF(int *result)
{
  if (*((void *)result + 6) == *((void *)result + 4) && !result[43])
  {
    result[43] = 1;
    uint64_t v1 = *((void *)result + 1);
    *(void *)uint64_t v1 = 0x3031304343455842LL;
    int v2 = *result;
    *(void *)(v1 + 8) = *((void *)result + 4);
    *(_DWORD *)(v1 + 44) = 0;
    int v3 = result[10];
    *(_DWORD *)(v1 + 36) = v2;
    *(_DWORD *)(v1 + 40) = v3;
    return (int *)CC_SHA1_Deprecated_Final((unsigned __int8 *)(v1 + 16), (CC_SHA1_CTX *)(result + 19));
  }

  return result;
}

void OECCStreamDestroy(void **a1)
{
  if (a1)
  {
    free(a1[8]);
    free(a1[1]);
    free(a1);
  }

uint64_t OECCStreamGetDataPtr(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 8);
  }
  else {
    return 0LL;
  }
}

uint64_t OECCStreamGetDataSize(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t OECCStreamWrite( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 48);
  BOOL v9 = __CFADD__(v8, a3);
  unint64_t v10 = v8 + a3;
  int v11 = v9;
  if (v10 <= *(void *)(a1 + 32) && v11 == 0)
  {
    uint64_t v16 = a3;
    char v17 = a2;
    CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 76), a2, a3);
    uint64_t v15 = 0LL;
    if (v16)
    {
      unsigned int v19 = *(_DWORD *)(a1 + 72);
      do
      {
        unint64_t v20 = *(unsigned int *)(a1 + 40);
        size_t v21 = v16 + (unint64_t)v19 <= v20 ? v16 : v20 - v19;
        memcpy((void *)(*(void *)(a1 + 64) + v19), v17, v21);
        unsigned int v22 = *(_DWORD *)(a1 + 72) + v21;
        *(_DWORD *)(a1 + 72) = v22;
        size_t v23 = *(void *)(a1 + 48) + v21;
        *(void *)(a1 + 48) = v23;
        v15 += v21;
        if (v22 < *(_DWORD *)(a1 + 40) && v23 < *(void *)(a1 + 32)) {
          break;
        }
        uint64_t v24 = *(void *)(a1 + 56);
        if (v24 + (unint64_t)*(unsigned int *)(a1 + 24) > *(void *)(a1 + 16))
        {
          int v13 = "ECC buffer overflow";
          __int16 v14 = 914;
          goto LABEL_9;
        }

        if (*(_DWORD *)a1 != 1)
        {
          int v13 = "Invalid ECC algorithm";
          __int16 v14 = 921;
          goto LABEL_9;
        }

        if ((ECC65537GetParity(v22, *(void *)(a1 + 64), *(void *)(a1 + 8) + v24) & 0x80000000) != 0)
        {
          int v13 = "ECC generation failed";
          __int16 v14 = 918;
          goto LABEL_9;
        }

        unsigned int v19 = 0;
        v17 += v21;
        *(void *)(a1 + 56) += *(unsigned int *)(a1 + 24);
        *(_DWORD *)(a1 + 72) = 0;
        v16 -= v21;
      }

      while (v16);
    }

    checkEOF((int *)a1);
  }

  else
  {
    int v13 = "Too many bytes received";
    __int16 v14 = 892;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c",  (uint64_t)"OECCStreamWrite",  v14,  64,  0,  v13,  a7,  a8,  v26);
    return -1LL;
  }

  return v15;
}

uint64_t initBestMatchThreadProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x1895F8858](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v80 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *(void *)v8;
  unsigned int v10 = *(_DWORD *)(v8 + 20);
  bzero(v79, 0x3000uLL);
  bzero(v78, 0x7000uLL);
  unsigned int v11 = *(_DWORD *)(v8 + 12);
  unsigned int v12 = *(_DWORD *)(v8 + 16);
  unsigned int v13 = *(_DWORD *)(v9 + 36);
  unsigned int v14 = v13 - v10;
  if (v13 < v10) {
    unsigned int v14 = 0;
  }
  if (v12 + v10 > v13) {
    unsigned int v12 = v14;
  }
  if (v11 < v12)
  {
    for (unsigned int i = *(_DWORD *)(v8 + 12); i < v12; ++i)
    {
      uint64_t v16 = *(void *)(v9 + 48);
      unsigned int v17 = *(_DWORD *)(v16 + 8LL * i + 4);
      if (v17 < 0x400)
      {
        uint64_t v18 = i;
        uint64_t v19 = *(void *)(v9 + 24);
        unsigned int v20 = 0;
        if (v10)
        {
          size_t v21 = (int *)(v19 + i);
          unsigned int v22 = v10;
          do
          {
            int v23 = *v21++;
            unsigned int v20 = -1640531535 * (v23 + v20) - 1640531535;
            v22 -= 4;
          }

          while (v22);
        }

        uint64_t v24 = *(void *)(v8 + 32);
        int v25 = v20 ^ HIWORD(v20);
        unsigned int v26 = v20 >> *(_DWORD *)(v9 + 44);
        if (*(unsigned __int16 *)(v24 + 6LL * v26 + 4) == (unsigned __int16)v25)
        {
          unsigned int v27 = *(_DWORD *)(v24 + 6LL * v26);
          if (v27 >= *(_DWORD *)(v8 + 8))
          {
            int v28 = ((_WORD)i - (_WORD)v27) & 0x3FF;
            int v29 = &v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF)];
            if (v27 != v29[1] + i - *v29 || v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF) + 2] + *v29 < i)
            {
              int v30 = v27 & 0x3FF;
              unint64_t v31 = (unsigned int *)&v78[28 * (v27 & 0x3FF)];
              if (*v31 == v27)
              {
                unint64_t v32 = &v78[28 * (v27 & 0x3FF)];
                int v33 = *((_DWORD *)v32 + 2);
                int v34 = i - v33;
                if (v33 != *((_DWORD *)v32 + 5) + i - v33) {
                  goto LABEL_26;
                }
                int v35 = &v78[28 * (v27 & 0x3FF)];
                int v37 = v35[3];
                int v36 = v35[4];
                int v38 = v36 + v34;
                unsigned int v39 = v35[1];
                if (v36 + v34 <= v39) {
                  int v38 = v35[1];
                }
                uint64_t v40 = (v38 + v34);
                unsigned int v41 = v35[6] + v36;
                if (v41 >= v37 + v39) {
                  unsigned int v41 = v37 + v39;
                }
                BOOL v42 = v41 >= v40;
                int v43 = v41 - v40;
                if (v43 != 0 && v42)
                {
                  unsigned int v27 = v27 - i + v40;
                  uint64_t v18 = v40;
                }

                else
                {
LABEL_26:
                  int v43 = 0;
LABEL_27:
                  LODWORD(v40) = i;
                }

                unsigned int v45 = 0;
                else {
                  unsigned int v46 = v27;
                }
                uint64_t v47 = *(void *)(v9 + 16);
                uint64_t v48 = v47 + v27;
                uint64_t v49 = v19 + v18;
                unsigned int v50 = -1;
                while (1)
                {
                  v45 += 8;
                  if (v45 > v46) {
                    break;
                  }
                  v50 += 8;
                  unint64_t v51 = *(void *)(v49 - v45) ^ *(void *)(v48 - v45);
                  if (v51)
                  {
                    unsigned int v50 = v45 + (__clz(v51) >> 3) - 8;
                    goto LABEL_39;
                  }
                }

                while (1)
                {
                  unsigned int v52 = v50 + 2;
                  if (v50 + 2 > v46) {
                    break;
                  }
                  ++v50;
                }

                unsigned int v50 = v46;
LABEL_39:
                uint64_t v53 = v27 - v50;
                uint64_t v54 = v40 - v50;
                unsigned int v55 = v50 + v43;
                unsigned int v56 = *(_DWORD *)(v9 + 32) - v53;
                LODWORD(v57) = *(_DWORD *)(v9 + 36) - v54;
                else {
                  unint64_t v57 = v56;
                }
                uint64_t v58 = v47 + v53;
                uint64_t v59 = v19 + v54;
                while (1)
                {
                  unsigned int v60 = v55 + 8;
                  uint64_t v61 = *(void *)(v58 + v55);
                  uint64_t v62 = *(void *)(v59 + v55);
                  v55 += 8;
                  unint64_t v63 = v62 ^ v61;
                  if (v63)
                  {
                    LODWORD(v57) = v60 + (__clz(__rbit64(v63)) >> 3) - 8;
                    goto LABEL_52;
                  }
                }

                if (v55 < v57)
                {
                  uint64_t v64 = v55;
                  while (*(unsigned __int8 *)(v58 + v64) == *(unsigned __int8 *)(v59 + v64))
                  {
                    if (++v64 >= v57) {
                      goto LABEL_52;
                    }
                  }

                  LODWORD(v57) = v64;
                }

uint64_t BXDiffMatchesCreate( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v182 = *MEMORY[0x1895F89C0];
  uint64_t v177 = 0LL;
  uint64_t v178 = 0LL;
  uint64_t v179 = 0LL;
  int v8 = *a5;
  if (!*a5) {
    int v8 = 6;
  }
  if (a4 >= 0x4B000) {
    int v9 = v8;
  }
  else {
    int v9 = 20;
  }
  if (a2 > 0xFFFFFFFE || (unint64_t v10 = a4, a4 >= 0xFFFFFFFF))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"BXDiffMatchesCreate",  994,  92,  0,  "isize,osize too large",  a7,  a8,  v167);
    return 0LL;
  }

  uint64_t v15 = calloc(1uLL, 0x40uLL);
  uint64_t v16 = (uint64_t)v15;
  if (!v15)
  {
    int v87 = *__error();
    int64x2_t v88 = "malloc";
    __int16 v89 = 998;
    goto LABEL_108;
  }

  uint64_t v17 = *(void *)a5;
  v15[2] = a5[2];
  *(void *)uint64_t v15 = v17;
  int DefaultNThreads = a5[2];
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  *(_DWORD *)(v16 + 8) = DefaultNThreads;
  *(void *)(v16 + 16) = a1;
  *(void *)(v16 + 24) = a3;
  *(_DWORD *)(v16 + 32) = a2;
  *(_DWORD *)(v16 + 36) = v10;
  if ((getProfile(&v177, v9) & 0x80000000) != 0)
  {
    int v167 = *a5;
    int64x2_t v88 = "loading profile: %d";
    __int16 v89 = 1008;
    goto LABEL_106;
  }

  if ((int)v177 >= 1)
  {
    getRealTime();
    size_t v21 = malloc(4 * a2 + 1028);
    unsigned int v22 = malloc(8 * a2);
    int v23 = v22;
    if (!v21 || !v22)
    {
      unint64_t v90 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"qsufsort32",  377,  92,  *v90,  "malloc",  v91,  v92,  v167);
      free(v21);
      free(v23);
      *(void *)(v16 + 56) = 0LL;
      __int16 v89 = 1021;
      int v87 = 0;
      int64x2_t v88 = "qsufsort32";
      goto LABEL_108;
    }

    uint64_t v24 = v21 + 257;
    v21[257] = a2;
    _DWORD *v22 = 0;
    if ((_DWORD)a2)
    {
      unint64_t v170 = v21;
      unint64_t v172 = v10;
      uint64_t v174 = v16;
      unsigned int v25 = 0;
      int v175 = a2 ^ 0x80000000;
      unsigned int v26 = v22 + 1;
      do
      {
        if (*v23 == v175) {
          break;
        }
        unsigned int v27 = 0;
        unsigned int v28 = -1;
        do
        {
          int v29 = &v23[2 * v27];
          uint64_t v30 = *v29;
          if ((v30 & 0x80000000) != 0)
          {
            LODWORD(v31) = v30 ^ 0x80000000;
          }

          else
          {
            uint64_t v31 = v24[v30];
            if (v25)
            {
              if (v31 > v27)
              {
                uint64_t v32 = v31 - v27;
                int v33 = &v26[2 * v27];
                do
                {
                  *int v33 = v24[*(v33 - 1) + v25];
                  v33 += 2;
                  --v32;
                }

                while (v32);
              }
            }

            else if (v31 > v27)
            {
              int v34 = 0;
              uint64_t v35 = (v31 - 1);
              int v36 = &v26[2 * v35];
              int v37 = (unsigned __int8 *)(a1 + v35);
              int v38 = 1;
              unsigned int v39 = v31;
              do
              {
                unsigned int v40 = *v37--;
                int v41 = __PAIR64__(v40, v34) >> 8;
                unsigned int v42 = v39 + 2;
                unsigned int v43 = v39 - 1;
                int v44 = v41 | 0xFF;
                int v34 = v38 + (v41 & 0xFFFFFF00);
                *(v36 - 1) = v43;
                *int v36 = v34;
                v36 -= 2;
                ++v38;
                unsigned int v39 = v43;
              }

              while (v27 < v43);
            }

            quicksort64(v31 - v27, (unint64_t *)&v23[2 * v27], 24);
            unsigned int v45 = v27 + 1;
            if (v27 + 1 <= v31)
            {
              unsigned int v46 = v29[1];
              do
              {
                unsigned int v47 = v46;
                else {
                  unsigned int v46 = v26[2 * v45];
                }
                if (v47 != v46)
                {
                  if (v45 - v27 < 2)
                  {
                  }

                  else if (v28 < a2)
                  {
                    v23[2 * v28] = v27 ^ 0x80000000;
                    unsigned int v28 = -1;
                  }

                  if (v45 > v27)
                  {
                    unint64_t v48 = v45 - (unint64_t)v27;
                    uint64_t v49 = &v23[2 * v27];
                    do
                    {
                      int v50 = *v49;
                      v49 += 2;
                      v24[v50] = v45;
                      --v48;
                    }

                    while (v48);
                    unsigned int v27 = v45;
                  }
                }

                ++v45;
              }

              while (v45 <= v31);
            }
          }

          unsigned int v27 = v31;
        }

        while (v31 < a2);
        if (v25 >= 3) {
          v25 *= 2;
        }
        else {
          unsigned int v25 = 3;
        }
      }

      while (v25 < a2);
      uint64_t v51 = 0LL;
      unint64_t v10 = v172;
      uint64_t v16 = v174;
      size_t v21 = v170;
      do
      {
        *(void *)&v23[2 * (v24[v51] - 1)] = v51;
        ++v51;
      }

      while (a2 != v51);
    }

    if (a2)
    {
      unsigned int v52 = (uint64_t *)v23;
      uint64_t v53 = v24;
      unint64_t v54 = a2;
      do
      {
        uint64_t v55 = *v52++;
        *v53++ = v55;
        --v54;
      }

      while (v54);
    }

    int v56 = 0;
    *size_t v21 = 0;
    v21[256] = a2;
    for (unint64_t i = 1LL; i != 256; ++i)
    {
      unsigned int v58 = a2;
      if (v56 != (_DWORD)a2)
      {
        if (v56 + 1 >= a2)
        {
          unsigned int v58 = a2;
        }

        else
        {
          unsigned int v58 = a2;
          do
          {
            else {
              v56 += (v58 - v56) >> 1;
            }
          }

          while (v58 > v56 + 1);
        }

        uint64_t v59 = v24[v56];
      }

      v21[i] = v58;
      int v56 = v58;
    }

    free(v23);
    *(void *)(v16 + 56) = v21;
    getRealTime();
  }

  if (SHIDWORD(v177) >= 1)
  {
    unsigned int v60 = malloc(8 * v10);
    *(void *)(v16 + 48) = v60;
    if (!v60)
    {
      int v87 = *__error();
      int64x2_t v88 = "malloc";
      __int16 v89 = 1033;
      goto LABEL_108;
    }

    if (*(_DWORD *)(v16 + 36))
    {
      uint64_t v61 = 0LL;
      unint64_t v62 = 0LL;
      do
      {
        *(void *)(*(void *)(v16 + 48) + v61) = 0xFFFFFFFFLL;
        ++v62;
        v61 += 8LL;
      }

      while (v62 < *(unsigned int *)(v16 + 36));
    }
  }

  uint64_t v63 = *(void *)(v16 + 48);
  if (*(void *)(v16 + 56))
  {
    if (v63)
    {
      int v64 = HIDWORD(v178);
      unsigned int v65 = v179;
      getRealTime();
      unsigned int v66 = *(_DWORD *)(v16 + 36);
      if (v66)
      {
        unsigned int v67 = 0;
        unsigned int v68 = 1;
        do
        {
          unsigned int v69 = v67;
          unint64_t v70 = (_DWORD *)(*(void *)(v16 + 48) + 8LL * v67);
          if (v70[1] < v65)
          {
            uint64_t v71 = *(void *)(v16 + 56);
            uint64_t v72 = (unsigned int *)(v71 + 4LL * *(unsigned __int8 *)(*(void *)(v16 + 24) + v67));
            unsigned int v73 = *v72;
            unsigned int v74 = v72[1] + 1;
            LODWORD(v180) = -1;
            unsigned int v75 = bestMatchInRange(v16, v71 + 1028, v67, v73, v74, &v180);
            int v76 = (int)v180;
            *unint64_t v70 = (_DWORD)v180;
            *(_DWORD *)(*(void *)(v16 + 48) + 8LL * v67 + 4) = v75;
            if (v75 >= v65)
            {
              if ((v76 + 1) < *(_DWORD *)(v16 + 32))
              {
                uint64_t v77 = 8LL * v68;
                unsigned int v78 = v75 - 1;
                int v79 = 1;
                do
                {
                  BOOL v80 = v67 + v79 < *(_DWORD *)(v16 + 36) && v78 >= v65;
                  if (!v80) {
                    break;
                  }
                  *(_DWORD *)(*(void *)(v16 + 48) + v77) = v76 + v79;
                  *(_DWORD *)(*(void *)(v16 + 48) + v77 + 4) = v78;
                  v77 += 8LL;
                  ++v79;
                  --v78;
                }

                while ((v76 + v79) < *(_DWORD *)(v16 + 32));
              }

              if (v67 && v76)
              {
                uint64_t v81 = 0LL;
                uint64_t v82 = v67 - 1LL;
                uint64_t v83 = 8LL * v67;
                unsigned int v84 = v75 + 1;
                do
                {
                  uint64_t v85 = *(void *)(v16 + 48) + v83;
                  if (*(_DWORD *)(v85 - 8) != -1) {
                    break;
                  }
                  *(_DWORD *)(v85 - 8) = v76 - 1 + v81;
                  *(_DWORD *)(*(void *)(v16 + 48) + v83 - 4) = v84;
                  if (!(v82 + v81)) {
                    break;
                  }
                  int v86 = v76 + v81--;
                  v83 -= 8LL;
                  ++v84;
                }

                while (v86 != 1);
              }
            }

            unsigned int v66 = *(_DWORD *)(v16 + 36);
          }

          v67 += v64;
          v68 += v64;
        }

        while (v69 + v64 < v66);
      }

LABEL_171:
      unsigned int v128 = v169 ^ (v120 != 0LL);
      unsigned int v127 = *(_DWORD *)(v16 + 32);
      v129 += v96;
      if (v173 >= v127)
      {
        int v99 = 1;
LABEL_175:
        __int128 v102 = v168;
        __int128 v103 = v171;
        goto LABEL_176;
      }
    }

    __int128 v165 = "ThreadPoolSync";
    __int16 v166 = 906;
LABEL_178:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"initBestMatchFromHashes",  v166,  92,  0,  v165,  v115,  v116,  v167);
    int v99 = 0;
    __int128 v102 = v168;
    __int128 v103 = v171;
    goto LABEL_179;
  }

  int v99 = 1;
LABEL_176:
  if (v120)
  {
LABEL_179:
    int v121 = "ThreadPoolDestroy";
    __int16 v122 = 930;
LABEL_181:
    int v126 = 0;
    goto LABEL_182;
  }

LABEL_184:
  free(v102);
  free(v103);
  free(v180);
  free(v181);
  if (v99) {
    goto LABEL_185;
  }
  int64x2_t v88 = "initBestMatchFromHashes";
  __int16 v89 = 1069;
LABEL_106:
  int v87 = 0;
LABEL_108:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"BXDiffMatchesCreate",  v89,  92,  v87,  v88,  v19,  v20,  v167);
  BXDiffMatchesDestroy((void **)v16);
  return 0LL;
}

size_t getProfile(_DWORD *a1, int a2)
{
  *(void *)a1 = 0LL;
  *((void *)a1 + 1) = 0LL;
  *((void *)a1 + 2) = 0LL;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = 6;
  }
  switch(v3)
  {
    case 2:
      __int128 v4 = xmmword_1862D7A60;
      goto LABEL_10;
    case 3:
      __int128 v4 = xmmword_1862D7A50;
      goto LABEL_10;
    case 4:
      __int128 v4 = xmmword_1862D7A40;
      goto LABEL_10;
    case 5:
      __int128 v4 = xmmword_1862D7A30;
      goto LABEL_10;
    case 6:
      *(_OWORD *)a1 = xmmword_1862D7A30;
      uint64_t v5 = 0x1A00000010LL;
      goto LABEL_30;
    case 7:
      __int128 v6 = xmmword_1862D7A30;
      goto LABEL_15;
    case 8:
      *(_OWORD *)a1 = xmmword_1862D7A20;
      uint64_t v5 = 0x1A0000000CLL;
      goto LABEL_30;
    case 9:
      __int128 v6 = xmmword_1862D7A20;
LABEL_15:
      *(_OWORD *)a1 = v6;
      uint64_t v5 = 0x1A00000008LL;
      goto LABEL_30;
    case 10:
      __int128 v7 = xmmword_1862D7A10;
      goto LABEL_24;
    case 11:
      __int128 v7 = xmmword_1862D7A00;
      goto LABEL_24;
    case 12:
      __int128 v7 = xmmword_1862D79F0;
      goto LABEL_24;
    case 13:
      __int128 v8 = xmmword_1862D79E0;
      goto LABEL_26;
    case 14:
      __int128 v8 = xmmword_1862D79D0;
      goto LABEL_26;
    case 15:
      __int128 v7 = xmmword_1862D79C0;
      goto LABEL_24;
    case 16:
      __int128 v7 = xmmword_1862D79B0;
      goto LABEL_24;
    case 17:
      __int128 v7 = xmmword_1862D79A0;
LABEL_24:
      *(_OWORD *)a1 = v7;
      uint64_t v5 = 24LL;
      goto LABEL_30;
    case 18:
      __int128 v8 = xmmword_1862D79A0;
LABEL_26:
      *(_OWORD *)a1 = v8;
      uint64_t v5 = 16LL;
      goto LABEL_30;
    case 19:
      *(_OWORD *)a1 = xmmword_1862D79A0;
      uint64_t v5 = 8LL;
      goto LABEL_30;
    case 20:
      *a1 = 1;
      *(void *)(a1 + 3) = 0LL;
      *(void *)(a1 + 1) = 0LL;
      a1[5] = 0;
      goto LABEL_31;
    case 21:
      *(_OWORD *)a1 = xmmword_1862D7A30;
      uint64_t v5 = 0x1800000010LL;
      goto LABEL_30;
    default:
      __int128 v4 = xmmword_1862D7A70;
LABEL_10:
      *(_OWORD *)a1 = v4;
      uint64_t v5 = 0x1A00000018LL;
LABEL_30:
      *((void *)a1 + 2) = v5;
LABEL_31:
      size_t result = (size_t)getenv("BXDIFF_MATCHES_PROFILE");
      if (!result) {
        return result;
      }
      size_t v10 = result;
      size_t result = strlen((const char *)result);
      if (!result) {
        return result;
      }
      size_t v11 = result;
      uint64_t v12 = 0LL;
      uint64_t v13 = MEMORY[0x1895F8770];
      break;
  }

  while (1)
  {
    unsigned int v14 = __tolower(*(char *)(v10 + v12));
    unsigned int v17 = v14;
    if (v14 > 0x7F)
    {
      if (__maskrune(v14, 0x4000uLL)) {
        goto LABEL_52;
      }
    }

    else if ((*(_DWORD *)(v13 + 4LL * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_52;
    }

    char v18 = v17 - 58;
    if (v17 - 58 > 0x39) {
      goto LABEL_44;
    }
    if (((1LL << v18) & 0x224820000000000LL) != 0) {
      break;
    }
    if (((1LL << v18) & 3) != 0) {
      goto LABEL_52;
    }
LABEL_44:
    if (v17 != 44)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c",  (uint64_t)"parseProfile",  505,  92,  0,  "Invalid profile code: %c",  v15,  v16,  v17);
      goto LABEL_56;
    }

void BXDiffMatchesDestroy(void **a1)
{
  if (a1)
  {
    free(a1[7]);
    free(a1[6]);
    free(a1);
  }

uint64_t BXDiffMatchesGetBestMatch(uint64_t a1, unsigned int a2, void *a3)
{
  unsigned int v10 = 0;
  if (*(_DWORD *)(a1 + 36) <= a2)
  {
    uint64_t v7 = 0LL;
    goto LABEL_6;
  }

  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    __int128 v6 = (unsigned int *)(v5 + 8LL * a2);
    uint64_t v7 = *v6;
    unsigned int v10 = v7;
    if ((_DWORD)v7 != -1)
    {
      LODWORD(result) = v6[1];
      goto LABEL_7;
    }
  }

  uint64_t v7 = *(void *)(a1 + 56);
  if (!v7)
  {
LABEL_6:
    LODWORD(result) = 0;
    goto LABEL_7;
  }

  int v9 = (unsigned int *)(v7 + 4LL * *(unsigned __int8 *)(*(void *)(a1 + 24) + a2));
  uint64_t result = bestMatchInRange(a1, v7 + 1028, a2, *v9, v9[1], &v10);
  uint64_t v7 = v10;
  if (v5) {
    *(void *)(v5 + 8LL * a2) = v10 | (unint64_t)(result << 32);
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t bestMatchInRange( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  if (a5 <= a4)
  {
    int v19 = 0;
    uint64_t result = 0LL;
  }

  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = *(unsigned int *)(a2 + 4LL * a4);
    uint64_t v8 = a4;
    int v9 = *(_DWORD *)(a1 + 32);
    unsigned int v10 = *(_DWORD *)(a1 + 36) - a3;
    else {
      uint64_t v11 = v10;
    }
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = *(void *)(a1 + 24);
    uint64_t v14 = v13 + a3;
    while (1)
    {
      unsigned int v15 = v6 + 8;
      uint64_t v16 = *(void *)(v12 + v7 + v6);
      uint64_t v17 = *(void *)(v14 + v6);
      v6 += 8;
      unint64_t v18 = v17 ^ v16;
      if (v18)
      {
        LODWORD(v11) = v15 + (__clz(__rbit64(v18)) >> 3) - 8;
        goto LABEL_16;
      }
    }

    if (v6 < v11)
    {
      uint64_t v21 = v11 - v6;
      unsigned int v22 = (unsigned __int8 *)(v13 + a3 + v6);
      uint64_t v23 = (unsigned __int8 *)(v12 + v7 + v6);
      while (1)
      {
        int v25 = *v23++;
        int v24 = v25;
        int v26 = *v22++;
        if (v24 != v26) {
          break;
        }
        ++v6;
        if (!--v21) {
          goto LABEL_16;
        }
      }

      LODWORD(v11) = v6;
    }

LABEL_39:
        if (v45 < v44
          && *(unsigned __int8 *)(v13 + v45 + a3) < *(unsigned __int8 *)(v12 + (v45 + v43)))
        {
          LODWORD(v30) = v45;
          uint64_t v28 = v42;
          uint64_t v42 = v8;
          goto LABEL_48;
        }

          int v26 = 0LL;
          unsigned int v27 = 0LL;
          uint64_t v28 = 1;
          goto LABEL_34;
        }

        int v24 = "no input dir";
        int v25 = 413;
      }

      else
      {
        int v24 = "missing PAT";
        int v25 = 412;
      }

      goto LABEL_31;
    default:
      fprintf((FILE *)*MEMORY[0x1895F89D0], "TODO(%c) %c %s\n", (char)v16, (char)a1[2088], a1 + 1064);
      goto LABEL_39;
  }

      unsigned int v15 = __n;
      uint64_t v51 = __n == v23;
      uint64_t v8 = v75;
      uint64_t v5 = a3;
      if (!v51)
      {
        uint64_t v63 = "aaSegmentStreamProcess";
        int v64 = 337;
        goto LABEL_74;
      }

      if (v25 != v50.st_uid) {
        goto LABEL_42;
      }
      goto LABEL_40;
    }
  }

  return result;
}

    unsigned int v27 = *(void **)(a1 + 24);
    uint64_t v28 = realloc(v27, v26);
    if (!v28) {
      break;
    }
    *(void *)(a1 + 16) = v26;
    *(void *)(a1 + 24) = v28;
    uint64_t v21 = *(void *)(a1 + 8);
LABEL_41:
    if (v26 - v21 >= v22) {
      uint64_t v29 = v22;
    }
    else {
      uint64_t v29 = v26 - v21;
    }
    uint64_t v30 = AAByteStreamRead(v23, (void *)(*(void *)(a1 + 24) + v21), v29);
    if (v30 < 0) {
      goto LABEL_140;
    }
    if (!v30) {
      goto LABEL_49;
    }
    uint64_t v21 = *v83 + v30;
    if (__CFADD__(*v83, v30) || (uint64_t v20 = *(void *)(a1 + 16), v21 > v20))
    {
LABEL_140:
      uint64_t v8 = -1LL;
      goto LABEL_141;
    }

    *uint64_t v83 = v21;
    v8 += v30;
    v22 -= v30;
    if (!v22)
    {
LABEL_49:
      if ((v8 & 0x8000000000000000LL) != 0) {
        goto LABEL_141;
      }
      if (!v8) {
LABEL_51:
      }
        *(_DWORD *)(a1 + 60) = 1;
LABEL_52:
      uint64_t v21 = *v83;
LABEL_53:
      uint64_t v32 = *(unint64_t **)(a1 + 24);
      unsigned int v31 = *(void *)(a1 + 32);
      uint64_t v33 = *(void *)(a1 + 40) - v31;
      unint64_t v34 = (_BYTE *)(*(void *)(a1 + 48) + v31);
      switch(*(_DWORD *)(a1 + 56))
      {
        case 1:
          if (!v21)
          {
            if (!*(_DWORD *)(a1 + 60))
            {
LABEL_146:
              int v76 = "truncated stream header";
              uint64_t v77 = 208;
              goto LABEL_154;
            }

                  uint64_t v49 = *(unsigned int *)(v19 + 120);
                  if (v49 < 0x3C3C3C3D)
                  {
                    unint64_t v50 = calloc(v49, 0x88uLL);
                    *(void *)(v19 + 128) = v50;
                    if (v50)
                    {
                      uint64_t v51 = *(unsigned int *)(v19 + 120);
                      unsigned int v52 = malloc(4 * v51);
                      *(void *)(v19 + 184) = v52;
                      if (v52)
                      {
                        *(void *)(v19 + 176) = 0LL;
                        *(_DWORD *)(v19 + 168) = v51;
                        *(_DWORD *)(v19 + 172) = 0;
                        if (!(_DWORD)v51)
                        {
LABEL_52:
                          uint64_t v55 = *(unsigned int *)(v19 + 88);
                          if (v55 < 0x33333334)
                          {
                            int v56 = calloc(v55, 0xA0uLL);
                            *(void *)(v19 + 96) = v56;
                            if (v56)
                            {
                              unint64_t v57 = *(unsigned int *)(v19 + 88);
                              unsigned int v58 = malloc(4 * v57);
                              *(void *)(v19 + 160) = v58;
                              if (v58)
                              {
                                *(void *)(v19 + 152) = 0LL;
                                *(_DWORD *)(v19 + 144) = v57;
                                *(_DWORD *)(v19 + 148) = 0;
                                if ((_DWORD)v57)
                                {
                                  uint64_t v59 = 0LL;
                                  unsigned int v60 = 0LL;
                                  while (1)
                                  {
                                    uint64_t v61 = *(void *)(v19 + 96) + v59;
                                    if ((SemInit(v61 + 16) & 0x80000000) != 0)
                                    {
                                      unsigned int v22 = "SemInit";
                                      uint64_t v23 = 729;
                                      goto LABEL_23;
                                    }

                                    *(void *)(v61 + 8) = v19;
                                    *(_DWORD *)(v61 + 136) = v60;
                                    if (*(_DWORD *)(v19 + 148) >= *(_DWORD *)(v19 + 144))
                                    {
                                      unsigned int v22 = "LocalArrayPush";
                                      uint64_t v23 = 732;
                                      goto LABEL_23;
                                    }

                                    unint64_t v62 = *(unsigned int *)(v19 + 156);
                                    *(_DWORD *)(*(void *)(v19 + 160) + 4 * v62) = v60;
                                    uint64_t v63 = *(_DWORD *)(v19 + 148);
                                    int v64 = (_DWORD)v62 + 1 == *(_DWORD *)(v19 + 144) ? 0 : v62 + 1;
                                    *(_DWORD *)(v19 + 156) = v64;
                                    *(_DWORD *)(v19 + 148) = v63 + 1;
                                    ++v60;
                                    v59 += 160LL;
                                  }

                                  unsigned int v22 = "Worker thread creation";
                                  uint64_t v23 = 733;
                                }

                                else
                                {
LABEL_68:
                                  if ((createThread((pthread_t *)(v19 + 136), (uint64_t)streamProc_0, v19, 0LL) & 0x80000000) == 0)
                                  {
                                    v17[4] = graisPRead;
                                    v17[6] = graisSeek;
                                    v17[7] = graisAbort;
                                    *uint64_t v17 = v19;
                                    v17[1] = graisClose;
                                    v17[2] = graisRead;
                                    return v17;
                                  }

                                  unsigned int v22 = "Stream thread creation";
                                  uint64_t v23 = 737;
                                }
                              }

                              else
                              {
                                unsigned int v22 = "LocalArrayInit";
                                uint64_t v23 = 725;
                              }

                              goto LABEL_23;
                            }
                          }

                          else
                          {
                            *__error() = 12;
                            *(void *)(v19 + 96) = 0LL;
                          }

                          int v24 = *__error();
                          unsigned int v22 = "malloc";
                          uint64_t v23 = 724;
                          goto LABEL_24;
                        }

                        uint64_t v53 = 0LL;
                        unint64_t v54 = 16LL;
                        while (1)
                        {
                          if ((SemInit(*(void *)(v19 + 128) + v54) & 0x80000000) != 0)
                          {
                            unsigned int v22 = "SemInit";
                            uint64_t v23 = 718;
                            goto LABEL_23;
                          }

                          ++v53;
                          v54 += 136LL;
                        }

                        unsigned int v22 = "SharedArrayPush";
                        uint64_t v23 = 719;
                      }

                      else
                      {
                        unsigned int v22 = "LocalArrayInit";
                        uint64_t v23 = 714;
                      }

uint64_t BXDiffMatchesIBuf(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t BXDiffMatchesISize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BXDiffMatchesOBuf(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t BXDiffMatchesOSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

unint64_t quicksort64(unint64_t result, unint64_t *a2, int a3)
{
  if (result >= 2)
  {
    unint64_t v5 = result;
    while (2)
    {
      switch(v5)
      {
        case 2uLL:
          unint64_t v32 = *a2;
          unint64_t v33 = a2[1];
          if (HIDWORD(*a2) > HIDWORD(v33))
          {
            *a2 = v33;
            a2[1] = v32;
          }

          break;
        case 3uLL:
          unint64_t v54 = *a2;
          unint64_t v55 = a2[2];
          unint64_t v56 = HIDWORD(*a2);
          if (v56 <= HIDWORD(v55))
          {
            unint64_t v57 = a2[2];
            unint64_t v55 = *a2;
          }

          else
          {
            unint64_t v56 = HIDWORD(v55);
            *a2 = v55;
            a2[2] = v54;
            unint64_t v57 = v54;
          }

          unint64_t v66 = a2[1];
          if (v56 <= HIDWORD(v66))
          {
            unint64_t v56 = HIDWORD(v66);
          }

          else
          {
            *a2 = v66;
            a2[1] = v55;
            unint64_t v66 = v55;
          }

          if (v56 > HIDWORD(v57))
          {
            a2[1] = v57;
            a2[2] = v66;
          }

          break;
        case 4uLL:
          unint64_t v35 = *a2;
          unint64_t v34 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v34))
          {
            unint64_t v36 = a2[1];
            unint64_t v34 = *a2;
          }

          else
          {
            *a2 = v34;
            a2[1] = v35;
            unint64_t v36 = v35;
          }

          unint64_t v59 = a2[2];
          unint64_t v58 = a2[3];
          unint64_t v60 = HIDWORD(v59);
          if (HIDWORD(v59) <= HIDWORD(v58))
          {
            unint64_t v61 = a2[3];
            unint64_t v58 = a2[2];
          }

          else
          {
            unint64_t v60 = HIDWORD(v58);
            a2[2] = v58;
            a2[3] = v59;
            unint64_t v61 = v59;
          }

          if (v60 >= HIDWORD(v34))
          {
            unint64_t v34 = v58;
          }

          else
          {
            *a2 = v58;
            a2[2] = v34;
          }

          unint64_t v68 = HIDWORD(v36);
          if (HIDWORD(v36) <= HIDWORD(v61))
          {
            unint64_t v61 = v36;
          }

          else
          {
            unint64_t v68 = HIDWORD(v61);
            a2[1] = v61;
            a2[3] = v36;
          }

          if (v68 > HIDWORD(v34))
          {
            a2[1] = v34;
            a2[2] = v61;
          }

          break;
        case 5uLL:
          unint64_t v37 = *a2;
          unint64_t v38 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v38))
          {
            unint64_t v39 = a2[1];
            unint64_t v38 = *a2;
          }

          else
          {
            *a2 = v38;
            a2[1] = v37;
            unint64_t v39 = v37;
          }

          unint64_t v63 = a2[2];
          unint64_t v62 = a2[3];
          unint64_t v64 = HIDWORD(v63);
          if (HIDWORD(v63) <= HIDWORD(v62))
          {
            unint64_t v65 = a2[3];
            unint64_t v62 = a2[2];
          }

          else
          {
            unint64_t v64 = HIDWORD(v62);
            a2[2] = v62;
            a2[3] = v63;
            unint64_t v65 = v63;
          }

          if (v64 >= HIDWORD(v38))
          {
            unint64_t v67 = v62;
            unint64_t v62 = v38;
          }

          else
          {
            *a2 = v62;
            a2[2] = v38;
            unint64_t v67 = v38;
          }

          unint64_t v69 = a2[4];
          unint64_t v70 = HIDWORD(v39);
          if (HIDWORD(v39) <= HIDWORD(v69))
          {
            unint64_t v71 = a2[4];
            unint64_t v69 = v39;
          }

          else
          {
            unint64_t v70 = HIDWORD(v69);
            a2[1] = v69;
            a2[4] = v39;
            unint64_t v71 = v39;
          }

          if (v70 >= HIDWORD(v62))
          {
            unint64_t v62 = v69;
          }

          else
          {
            *a2 = v69;
            a2[1] = v62;
          }

          unint64_t v72 = HIDWORD(v67);
          if (HIDWORD(v67) <= HIDWORD(v65))
          {
            unint64_t v73 = v65;
            unint64_t v65 = v67;
          }

          else
          {
            unint64_t v72 = HIDWORD(v65);
            a2[2] = v65;
            a2[3] = v67;
            unint64_t v73 = v67;
          }

          if (v72 >= HIDWORD(v62))
          {
            unint64_t v62 = v65;
          }

          else
          {
            a2[1] = v65;
            a2[2] = v62;
          }

          unint64_t v74 = HIDWORD(v73);
          if (HIDWORD(v73) <= HIDWORD(v71))
          {
            unint64_t v71 = v73;
          }

          else
          {
            unint64_t v74 = HIDWORD(v71);
            a2[3] = v71;
            a2[4] = v73;
          }

          if (v74 < HIDWORD(v62))
          {
            a2[2] = v71;
            a2[3] = v62;
          }

          break;
        default:
          if (a3 <= 0)
          {
            for (uint64_t i = 1LL; i != v5; ++i)
            {
              unint64_t v41 = a2[i];
              unint64_t v42 = i;
              while (1)
              {
                unint64_t v43 = v42 - 1;
                unint64_t v44 = (v42 - 1) >> 1;
                unint64_t v45 = a2[v44];
                if (v45 >= v41) {
                  break;
                }
                a2[v42] = v45;
                unint64_t v42 = (v42 - 1) >> 1;
                if (v43 <= 1) {
                  goto LABEL_63;
                }
              }

              unint64_t v44 = v42;
LABEL_63:
              a2[v44] = v41;
            }

            unint64_t v46 = v5 - 1;
            unint64_t v47 = a2[v5 - 1];
            a2[v5 - 1] = *a2;
            if (v5 - 1 >= 2)
            {
              do
              {
                uint64_t v48 = 0LL;
                unint64_t v49 = 0LL;
                unint64_t v50 = 1LL;
                while (1)
                {
                  unint64_t v51 = a2[v50];
                  unint64_t v52 = v48 + 2;
                  if (v48 + 2 >= v46)
                  {
                    unint64_t v52 = v50;
                  }

                  else
                  {
                    unint64_t v53 = a2[v52];
                    if (v51 >= v53) {
                      unint64_t v52 = v50;
                    }
                    if (v51 <= v53) {
                      unint64_t v51 = v53;
                    }
                  }

                  if (v47 >= v51) {
                    break;
                  }
                  a2[v49] = v51;
                  uint64_t v48 = 2 * v52;
                  unint64_t v50 = (2 * v52) | 1;
                  unint64_t v49 = v52;
                  if (v50 >= v46) {
                    goto LABEL_77;
                  }
                }

                unint64_t v52 = v49;
LABEL_77:
                a2[v52] = v47;
                unint64_t v47 = a2[--v46];
                a2[v46] = *a2;
              }

              while (v46 > 1);
            }

            *a2 = v47;
          }

          else
          {
            unint64_t v6 = v5 >> 2;
            uint64_t v7 = &a2[v5 >> 1];
            unint64_t v8 = *a2;
            unint64_t v9 = v7[-(v5 >> 2)];
            if (HIDWORD(*a2) <= HIDWORD(v9))
            {
              unint64_t v10 = v7[-(v5 >> 2)];
              unint64_t v9 = *a2;
            }

            else
            {
              *a2 = v9;
              v7[-(v5 >> 2)] = v8;
              unint64_t v10 = v8;
            }

            unint64_t v11 = *v7;
            unint64_t v12 = v7[v6];
            unint64_t v13 = HIDWORD(*v7);
            if (v13 <= HIDWORD(v12))
            {
              unint64_t v14 = v7[v6];
              unint64_t v12 = *v7;
            }

            else
            {
              unint64_t v13 = HIDWORD(v12);
              *uint64_t v7 = v12;
              v7[v6] = v11;
              unint64_t v14 = v11;
            }

            if (v13 >= HIDWORD(v9))
            {
              unint64_t v15 = v12;
              unint64_t v12 = v9;
            }

            else
            {
              *a2 = v12;
              *uint64_t v7 = v9;
              unint64_t v15 = v9;
            }

            uint64_t v16 = &a2[v5];
            unint64_t v17 = *(v16 - 1);
            unint64_t v18 = HIDWORD(v10);
            if (HIDWORD(v10) <= HIDWORD(v17))
            {
              unint64_t v19 = *(v16 - 1);
              unint64_t v17 = v10;
            }

            else
            {
              unint64_t v18 = HIDWORD(v17);
              v7[-(v5 >> 2)] = v17;
              *(v16 - 1) = v10;
              unint64_t v19 = v10;
            }

            if (v18 >= HIDWORD(v12))
            {
              unint64_t v12 = v17;
            }

            else
            {
              *a2 = v17;
              v7[-(v5 >> 2)] = v12;
            }

            unint64_t v20 = HIDWORD(v15);
            if (HIDWORD(v15) <= HIDWORD(v14))
            {
              unint64_t v21 = v14;
              unint64_t v14 = v15;
            }

            else
            {
              unint64_t v20 = HIDWORD(v14);
              *uint64_t v7 = v14;
              v7[v6] = v15;
              unint64_t v21 = v15;
            }

            if (v20 >= HIDWORD(v12))
            {
              unint64_t v12 = v14;
            }

            else
            {
              v7[-(v5 >> 2)] = v14;
              *uint64_t v7 = v12;
            }

            unint64_t v22 = HIDWORD(v21);
            if (HIDWORD(v21) <= HIDWORD(v19))
            {
              unint64_t v19 = v21;
            }

            else
            {
              unint64_t v22 = HIDWORD(v19);
              v7[v6] = v19;
              *(v16 - 1) = v21;
            }

            if (v22 < HIDWORD(v12))
            {
              *uint64_t v7 = v19;
              v7[v6] = v12;
            }

            unint64_t v23 = 0LL;
            unint64_t v24 = *((unsigned int *)v7 + 1);
            int v25 = a2 - 1;
            unint64_t v26 = v5;
            while (1)
            {
              if (v23 < v5)
              {
                while (HIDWORD(a2[v23]) < v24)
                {
                  if (v5 == ++v23)
                  {
                    unint64_t v23 = v5;
                    goto LABEL_36;
                  }
                }
              }

              do
              {
LABEL_36:
                unint64_t v27 = v26;
                if (!v26) {
                  break;
                }
                --v26;
              }

              while (HIDWORD(v25[v27]) >= v24);
              if (v23 >= v27) {
                break;
              }
              if (v23 + 1 != v27)
              {
                unint64_t v28 = a2[v23];
                a2[v23] = v25[v27];
                v25[v27] = v28;
              }

              unint64_t v26 = v27 - 1;
              ++v23;
            }

            for (unint64_t j = v27; j < v5; ++j)
            {
              unint64_t v30 = a2[j];
              if (v24 == HIDWORD(v30))
              {
                if (j != v27)
                {
                  unint64_t v31 = a2[v27];
                  a2[v27] = v30;
                  a2[j] = v31;
                }

                ++v27;
              }
            }

            --a3;
            uint64_t result = quicksort64();
            v5 -= v27;
            a2 += v27;
            if (v5 >= 2) {
              continue;
            }
          }

          break;
      }

      break;
    }
  }

  return result;
}

void **MemBufferCreate(size_t a1)
{
  int v2 = (void **)malloc(0x28uLL);
  int v3 = v2;
  if (v2)
  {
    v2[4] = 0LL;
    *(_OWORD *)int v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    if ((MemBufferIncreaseCapacity((uint64_t)v2, a1) & 0x8000000000000000LL) != 0)
    {
      free(v3[4]);
      free(v3);
      return 0LL;
    }
  }

  else
  {
    __int128 v4 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferCreate",  41,  36,  *v4,  "malloc",  v5,  v6,  v8);
  }

  return v3;
}

unint64_t MemBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  unint64_t result = *(void *)a1;
  if (result < a2)
  {
    uint64_t v5 = reallocf(*(void **)(a1 + 32), a2);
    *(void *)(a1 + 32) = v5;
    if (v5)
    {
      *(void *)a1 = a2;
      return a2;
    }

    else
    {
      uint64_t v6 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferIncreaseCapacity",  91,  36,  *v6,  "malloc",  v7,  v8,  v9);
      return -1LL;
    }
  }

  return result;
}

void MemBufferDestroy(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1);
  }

uint64_t MemBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t MemBufferGetFreeSize(void *a1)
{
  return *a1 - a1[1];
}

uint64_t MemBufferGetDataPtr(uint64_t a1)
{
  return *(void *)(a1 + 32) + *(void *)(a1 + 16);
}

uint64_t MemBufferGetFreePtr(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      memmove(*(void **)(a1 + 32), (const void *)(*(void *)(a1 + 32) + v3), v2);
      uint64_t v4 = *(void *)(a1 + 8);
      *(void *)(a1 + 16) = 0LL;
      *(void *)(a1 + 24) = v4;
    }
  }

  return *(void *)(a1 + 32) + *(void *)(a1 + 24);
}

uint64_t MemBufferDecreaseSize( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = (void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t result = v10 - a2;
  if (v10 >= a2)
  {
    if (v10 == a2)
    {
      uint64_t result = 0LL;
      void *v9 = 0LL;
      v9[1] = 0LL;
      v9[2] = 0LL;
    }

    else
    {
      unint64_t v12 = *(void *)(a1 + 16) + a2;
      *(void *)(a1 + 8) = result;
      *(void *)(a1 + 16) = v12;
    }
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferDecreaseSize",  117,  36,  0,  "MemBufferDecreaseSize n is too large: %zu",  a7,  a8,  a2);
    return -1LL;
  }

  return result;
}

uint64_t MemBufferIncreaseSize( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[3] + a2;
  if (v8 <= *a1)
  {
    a1[3] = v8;
    unint64_t v9 = a1[1] + a2;
    a1[1] = v9;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferIncreaseSize",  137,  36,  0,  "MemBufferIncreaseSize n is too large: %zu",  a7,  a8,  a2);
    return -1LL;
  }

  return v9;
}

uint64_t MemBufferFillFromBuffer(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6 = *a1 - a1[1];
  FreePtr = (void *)MemBufferGetFreePtr((uint64_t)a1);
  if (v6 >= a2)
  {
    memcpy(FreePtr, a3, a2);
    return MemBufferIncreaseSize(a1, a2, v11, v12, v13, v14, v15, v16);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferFillFromBuffer",  162,  36,  0,  "MemBufferFillFromBuffer n is too large: %zu",  v8,  v9,  a2);
    return -1LL;
  }

uint64_t MemBufferFillFromIStream( unint64_t *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  unint64_t v8 = *a1 - a1[1];
  uint64_t FreePtr = MemBufferGetFreePtr((uint64_t)a1);
  if (v8 >= a2) {
    unint64_t v8 = a2;
  }
  if (v8)
  {
    uint64_t v16 = FreePtr;
    uint64_t v17 = 0LL;
    while (1)
    {
      uint64_t v18 = a3(a4, v16, v8);
      if (v18 < 0) {
        break;
      }
      if (v18)
      {
        v16 += v18;
        v17 += v18;
        v8 -= v18;
        if (v8) {
          continue;
        }
      }

      return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
    }

    return -1LL;
  }

  else
  {
    uint64_t v17 = 0LL;
    return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
  }

uint64_t MemBufferFlushToOStream( void *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] >= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = a1[1];
  }
  if (v9)
  {
    unint64_t v12 = 0LL;
    uint64_t v13 = a1[4] + a1[2];
    while (1)
    {
      uint64_t v14 = a3(a4, v13, v9);
      if (v14 < 0) {
        break;
      }
      if (!v14)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MemBufferFlushToOStream",  265,  36,  0,  "MemBuffer write proc returned 0",  a7,  a8,  v16);
        return -1LL;
      }

      v13 += v14;
      v12 += v14;
      v9 -= v14;
      if (!v9) {
        return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
      }
    }

    return -1LL;
  }

  else
  {
    unint64_t v12 = 0LL;
    return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  }

uint64_t MemBufferTransmit( unint64_t *a1, unint64_t a2, size_t (*a3)(int a1, void *a2, size_t a3), uint64_t a4, uint64_t (*a5)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a2;
  if ((unint64_t)a3 | (unint64_t)a5)
  {
    if (a3) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = 0LL;
    }
    if (a3) {
      unint64_t v12 = a3;
    }
    else {
      unint64_t v12 = IZeroStreamRead;
    }
    if (a5) {
      uint64_t v13 = a6;
    }
    else {
      uint64_t v13 = 0LL;
    }
    if (a5) {
      uint64_t v14 = a5;
    }
    else {
      uint64_t v14 = ONullStreamWrite;
    }
    if (*a1)
    {
      a1[1] = 0LL;
      a1[2] = 0LL;
      a1[3] = 0LL;
      uint64_t v9 = 0LL;
      if (!a2) {
        return v9;
      }
      while (1)
      {
        if (*a1 >= v8) {
          size_t v15 = v8;
        }
        else {
          size_t v15 = *a1;
        }
        uint64_t v16 = v12(v11, (void *)a1[4], v15);
        if (v16 < 0)
        {
          unint64_t v19 = "read failed";
          __int16 v20 = 294;
          goto LABEL_30;
        }

        unint64_t v17 = v16;
        unint64_t v18 = v14(v13, a1[4], v16);
        if ((v18 & 0x8000000000000000LL) != 0)
        {
          unint64_t v19 = "write failed";
          __int16 v20 = 298;
          goto LABEL_30;
        }

        if (v18 < v17) {
          break;
        }
        if (v17)
        {
          v9 += v17;
          if (v8 == -1LL) {
            unint64_t v8 = -1LL;
          }
          else {
            v8 -= v17;
          }
          if (v8) {
            continue;
          }
        }

        return v9;
      }

      unint64_t v19 = "truncated write";
      __int16 v20 = 299;
    }

    else
    {
      unint64_t v19 = "MemBuffer is not allocated";
      __int16 v20 = 281;
    }

void MappedBufferDestroy(void *a1)
{
  if (a1)
  {
    size_t v2 = (void *)a1[1];
    if (*((_DWORD *)a1 + 1))
    {
      if ((*(_DWORD *)a1 & 0x80000000) == 0) {
        close(*(_DWORD *)a1);
      }
    }

    free(a1);
  }

void *MappedBufferCreateWithFD(int a1, unint64_t a2, unint64_t a3)
{
  size_t v6 = malloc(0x28uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[3] = 0LL;
    v6[4] = 0LL;
    v6[1] = -1LL;
    v6[2] = 0LL;
    int v8 = getpagesize();
    *(_DWORD *)uint64_t v7 = a1;
    *((_DWORD *)v7 + 1) = 0;
    if (a1 < 0)
    {
      uint64_t v13 = "invalid file descriptor";
      __int16 v14 = 397;
LABEL_17:
      int v12 = 0;
      goto LABEL_18;
    }

    int v11 = v8;
    if (fstat(a1, &v23))
    {
      int v12 = *__error();
      uint64_t v13 = "MappedBuffer fstat";
      __int16 v14 = 400;
LABEL_18:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MappedBufferCreateWithFD",  v14,  36,  v12,  v13,  v9,  v10,  v22);
      MappedBufferDestroy(v7);
      return 0LL;
    }

    if (v23.st_size <= a2)
    {
      char v22 = a2;
      uint64_t v13 = "invalid offset=%llu for fd";
      __int16 v14 = 401;
      goto LABEL_17;
    }

    if (a3 == -1LL)
    {
      a3 = v23.st_size - a2;
    }

    else if (a3 + a2 > v23.st_size)
    {
      char v22 = a2;
      uint64_t v13 = "invalid offset=%llu, size=%llu for fd";
      __int16 v14 = 405;
      goto LABEL_17;
    }

    if (!a3)
    {
      char v22 = 0;
      uint64_t v13 = "invalid size=%llu for fd";
      __int16 v14 = 407;
      goto LABEL_17;
    }

    v7[4] = a3;
    off_t v18 = a2 / v11 * v11;
    unint64_t v19 = a2 % v11;
    v7[2] = v19 + a3;
    __int16 v20 = (char *)mmap(0LL, v19 + a3, 1, 1, a1, v18);
    v7[1] = v20;
    if (v20 == (char *)-1LL)
    {
      int v12 = *__error();
      uint64_t v13 = "mmap file segment";
      __int16 v14 = 417;
      goto LABEL_18;
    }

    v7[3] = &v20[v19];
  }

  else
  {
    size_t v15 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c",  (uint64_t)"MappedBufferCreateWithFD",  382,  36,  *v15,  "malloc",  v16,  v17,  v22);
  }

  return v7;
}

uint64_t MappedBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

size_t IZeroStreamRead(int a1, void *a2, size_t a3)
{
  return a3;
}

uint64_t ONullStreamWrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *OSHA1StreamCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = malloc(0x80uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)size_t v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)v6);
    v7[13] = a1;
    v7[14] = a2;
    v7[15] = a3;
  }

  else
  {
    int v8 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OSHA1StreamCreate",  76,  29,  *v8,  "malloc",  v9,  v10,  v12);
  }

  return v7;
}

void OSHA1StreamDestroy(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  if (c)
  {
    CC_SHA1_Deprecated_Final(md, c);
    free(c);
  }

uint64_t OSHA1StreamWrite(CC_SHA1_CTX *c, const void *a2, uint64_t a3)
{
  if (!c || c[1].h0) {
    return -1LL;
  }
  uint64_t v4 = a3;
  CC_SHA1_Deprecated_Update(c, a2, a3);
  uint64_t v7 = *(uint64_t (**)(void, const void *, uint64_t))&c[1].h2;
  if (!v7) {
    return v4;
  }
  return v7(*(void *)&c[1].Nh, a2, v4);
}

uint64_t OSHA1StreamAbort(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    size_t v2 = *(uint64_t (**)(void))(result + 112);
    if (v2) {
      uint64_t result = v2(*(void *)(result + 120));
    }
    *(_DWORD *)(v1 + 96) = 1;
  }

  return result;
}

uint64_t IFileStreamCreateWithFilename(const char *a1, unint64_t a2, uint64_t a3)
{
  size_t v6 = (char *)malloc(0x70uLL);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((void *)v6 + 13) = 0LL;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    int v8 = (pthread_mutex_t *)(v6 + 40);
    *(void *)uint64_t v7 = 0x1FFFFFFFFLL;
    uint64_t v9 = a2 + a3;
    if (__CFADD__(a2, a3)) {
      uint64_t v9 = -1LL;
    }
    *(void *)(v7 + 16) = a2;
    *(void *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0LL))
    {
      char v12 = "pthread_mutex_init";
      __int16 v13 = 293;
    }

    else
    {
      int v16 = open(a1, 0);
      *(_DWORD *)uint64_t v7 = v16;
      if (v16 < 0)
      {
        int v14 = *__error();
        char v17 = (char)a1;
        char v12 = "%s";
        __int16 v13 = 297;
        goto LABEL_9;
      }

      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0) {
        return v7;
      }
      char v12 = "seek error";
      __int16 v13 = 303;
    }

    int v14 = 0;
  }

  else
  {
    int v14 = *__error();
    char v12 = "malloc";
    __int16 v13 = 282;
  }

uint64_t clampIfRegularFile(uint64_t a1)
{
  uint64_t result = fstat(*(_DWORD *)a1, &v4);
  if (!(_DWORD)result && (v4.st_mode & 0xF000) == 0x8000)
  {
    st_uint64_t size = v4.st_size;
    if (*(void *)(a1 + 16) > v4.st_size) {
      *(void *)(a1 + 16) = v4.st_size;
    }
    if (*(void *)(a1 + 24) > st_size) {
      *(void *)(a1 + 24) = st_size;
    }
  }

  return result;
}

uint64_t seekTo(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 32) == a2) {
    return 0LL;
  }
  off_t v4 = lseek(*(_DWORD *)a1, a2, 0);
  if ((v4 & 0x8000000000000000LL) == 0)
  {
    unint64_t v7 = v4;
    *(void *)(a1 + 32) = v4;
LABEL_4:
    if (v7 == a2) {
      return 0LL;
    }
    uint64_t v9 = "pos not reached";
    __int16 v10 = 261;
    goto LABEL_10;
  }

  if (*__error() != 32)
  {
    int v11 = *__error();
    uint64_t v9 = "lseek failed";
    __int16 v10 = 258;
    goto LABEL_12;
  }

  unint64_t v7 = *(void *)(a1 + 32);
  if (v7 <= a2)
  {
    char v12 = valloc(0x4000uLL);
    if (!v12)
    {
      int v11 = *__error();
      uint64_t v9 = "malloc";
      __int16 v10 = 244;
      goto LABEL_12;
    }

    for (uint64_t i = v12; v7 < a2; *(void *)(a1 + 32) = v7)
    {
      if (v7 + 0x4000 <= a2) {
        size_t v14 = 0x4000LL;
      }
      else {
        size_t v14 = a2 - v7;
      }
      ssize_t v15 = read(*(_DWORD *)a1, i, v14);
      unint64_t v7 = *(void *)(a1 + 32);
      if (v15 < 1) {
        break;
      }
      v7 += v15;
    }

    free(i);
    goto LABEL_4;
  }

  uint64_t v9 = "lseek failed and pos < s->pos";
  __int16 v10 = 240;
LABEL_10:
  int v11 = 0;
LABEL_12:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"seekTo",  v10,  29,  v11,  v9,  v5,  v6,  v16);
  return 0xFFFFFFFFLL;
}

void IFileStreamDestroy(char *a1)
{
  if (a1)
  {
    if (*((_DWORD *)a1 + 1))
    {
      int v2 = *(_DWORD *)a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }

    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
    free(a1);
  }

uint64_t IFileStreamCreateWithFD(int a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)malloc(0x70uLL);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((void *)v6 + 13) = 0LL;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    int v8 = (pthread_mutex_t *)(v6 + 40);
    *(_DWORD *)uint64_t v7 = a1;
    *(_DWORD *)(v7 + 4) = 0;
    uint64_t v9 = a2 + a3;
    if (__CFADD__(a2, a3)) {
      uint64_t v9 = -1LL;
    }
    *(void *)(v7 + 16) = a2;
    *(void *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0LL))
    {
      char v12 = "pthread_mutex_init";
      __int16 v13 = 325;
    }

    else
    {
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0) {
        return v7;
      }
      char v12 = "seek error";
      __int16 v13 = 331;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IFileStreamCreateWithFD",  v13,  29,  0,  v12,  v10,  v11,  v18);
    IFileStreamDestroy((char *)v7);
    return 0LL;
  }

  else
  {
    size_t v14 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IFileStreamCreateWithFD",  314,  29,  *v14,  "malloc",  v15,  v16,  v18);
  }

  return v7;
}

uint64_t IFileStreamRead( uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1LL;
  }
  if (!a3) {
    return 0LL;
  }
  unint64_t v10 = *(void *)(a1 + 32);
  if (v10 < *(void *)(a1 + 16))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IFileStreamRead",  358,  29,  0,  "pos out of range",  a7,  a8,  v25);
    return -1LL;
  }

  if (~v10 < a3) {
    size_t v11 = ~v10;
  }
  else {
    size_t v11 = a3;
  }
  unint64_t v12 = a3 + v10;
  if (__CFADD__(a3, v10)) {
    unint64_t v12 = -1LL;
  }
  unint64_t v13 = *(void *)(a1 + 24);
  if (v12 <= v13) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v13 - v10;
  }
  if (v14)
  {
    uint64_t v16 = 0LL;
    while (1)
    {
      ssize_t v17 = read(*(_DWORD *)a1, a2, v14);
      if (v17 < 0) {
        break;
      }
      if (v17)
      {
        a2 += v17;
        v16 += v17;
        v14 -= v17;
        if (v14) {
          continue;
        }
      }

      unint64_t v10 = *(void *)(a1 + 32);
      uint64_t result = v16;
      goto LABEL_23;
    }

    __int16 v20 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IFileStreamRead",  374,  29,  *v20,  "read",  v21,  v22,  v25);
    *(void *)(a1 + 32) += v16;
    stat v23 = (unint64_t *)(a1 + 104);
    uint64_t result = -1LL;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 + v16, v23));
  }

  else
  {
    uint64_t result = 0LL;
LABEL_23:
    *(void *)(a1 + 32) = v10 + result;
    char v18 = (unint64_t *)(a1 + 104);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 + result, v18));
  }

  return result;
}

int *OFileStreamCreateWithFilename(const char *a1, uint64_t a2)
{
  off_t v4 = (int *)malloc(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *((void *)v4 + 2) = a2;
    *((void *)v4 + 3) = 0LL;
    v4[1] = 1;
    *((void *)v4 + 1) = 0LL;
    int v6 = open(a1, 1537, 420LL);
    int *v5 = v6;
    if (v6 < 0)
    {
      uint64_t v7 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OFileStreamCreateWithFilename",  490,  29,  *v7,  "%s",  v8,  v9,  (char)a1);
      free(v5);
      return 0LL;
    }
  }

  else
  {
    unint64_t v10 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OFileStreamCreateWithFilename",  484,  29,  *v10,  "malloc",  v11,  v12,  v14);
  }

  return v5;
}

void OFileStreamDestroy(int *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      int v2 = *a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }

    free(a1);
  }

uint64_t OFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1LL;
  }
  if (*(void *)(a1 + 16) >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(void *)(a1 + 16);
  }
  if (v5)
  {
    uint64_t v3 = 0LL;
    while (1)
    {
      size_t v7 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      ssize_t v8 = write(*(_DWORD *)a1, __buf, v7);
      if (v8 < 0) {
        break;
      }
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 16);
        if (v9 != -1) {
          *(void *)(a1 + 16) = v9 - v8;
        }
        __buf += v8;
        v3 += v8;
        v5 -= v8;
        if (v5) {
          continue;
        }
      }

      goto LABEL_18;
    }

    uint64_t v11 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OFileStreamWrite",  538,  29,  *v11,  "write",  v12,  v13,  v14);
    return -1LL;
  }

  uint64_t v3 = 0LL;
LABEL_18:
  *(void *)(a1 + 24) += v3;
  return v3;
}

int *OArchiveFileStreamCreate(const char *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  unint64_t v10 = (int *)malloc(0x60uLL);
  uint64_t v11 = v10;
  if (v10)
  {
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *(_OWORD *)unint64_t v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if ((a3 & 0x100) == 0) {
      unlink(a1);
    }
    v11[1] = (a3 >> 4) & 1;
    *((void *)v11 + 2) = a2;
    if ((a3 & 1) != 0) {
      int v12 = 4;
    }
    else {
      int v12 = a4;
    }
    if (v12 < 1)
    {
      int v13 = open(a1, 1537, 420LL);
      int *v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 648;
        goto LABEL_31;
      }
    }

    else
    {
      int v13 = open_dprotected_np(a1, 1537, v12, 0, 420LL);
      int *v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 640;
LABEL_31:
        unint64_t v37 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamCreate",  v14,  29,  *v37,  "%s",  v38,  v39,  (char)a1);
        ParallelCompressionAFSCStreamClose(0LL, v40, v41, v42, v43, v44, v45, v46);
        goto LABEL_32;
      }
    }

    if ((a3 & 8) != 0 && fcntl(v13, 48, 1LL)) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamCreate",  656,  29,  "Warning: F_NOCACHE failed: %s\n",  v18,  v19,  v20,  (char)a1);
    }
    if ((a3 & 2) != 0 && fcntl(v13, 68, 1LL) == -1)
    {
      uint64_t v21 = __error();
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamCreate",  665,  29,  "Warning: F_SETSTATICCONTENT failed with error %d: %s\n",  v22,  v23,  v24,  *v21);
    }

    if (a2 && (a3 & 4) != 0 && a5 != -1)
    {
      if ((a3 & 0x80) != 0) {
        int v25 = 6;
      }
      else {
        int v25 = 4;
      }
      unint64_t v26 = ParallelCompressionAFSCStreamOpen(v13, a2, a5, v25);
      *((void *)v11 + 3) = v26;
      if (!v26)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamCreate",  677,  29,  0,  "ParallelCompressionAFSCStreamOpen failed: %s",  v27,  v28,  (char)a1);
        ParallelCompressionAFSCStreamClose(0LL, v29, v30, v31, v32, v33, v34, v35);
        close(v13);
LABEL_32:
        free(v11);
        return 0LL;
      }
    }

    else if ((a3 & 0x40) != 0)
    {
      uint64_t v36 = fpathconf(v13, 27);
      if (v36 >= 1)
      {
        v11[10] = 1;
        if (v36 == 4096)
        {
          v11[18] = 4096;
        }

        else
        {
          unsigned int v48 = 0x10000;
          if (v36 < 0x10000) {
            unsigned int v48 = v36;
          }
          int v49 = 1024;
          do
          {
            unsigned int v50 = v49;
            v49 *= 2;
          }

          while (v50 < v48);
          v11[18] = v50;
        }
      }
    }
  }

  else
  {
    uint64_t v15 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamCreate",  617,  29,  *v15,  "malloc",  v16,  v17,  v51);
  }

  return v11;
}

uint64_t OArchiveFileStreamDestroy( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OArchiveFileStreamDestroyEx(a1, 0LL, 0LL, 0LL, a5, a6, a7, a8);
}

uint64_t OArchiveFileStreamDestroyEx( unsigned int *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v10 = a2;
  if (*((void *)a1 + 2)) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamDestroyEx",  863,  29,  "OArchiveFileStream didn't receive enough data before being destroyed\n",  a6,  a7,  a8,  v27);
  }
  ParallelCompressionAFSCStreamClose(*((void *)a1 + 3), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((*a1 & 0x80000000) != 0)
  {
    uint64_t v13 = 0LL;
    uint64_t v19 = 0xFFFFFFFFLL;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (*((void *)a1 + 7))
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    uint64_t v15 = *((void *)a1 + 8);
    while (fcntl(*a1, 99, v15 + v12) != -1)
    {
      uint64_t v15 = *((void *)a1 + 8);
      v13 += *(void *)(v15 + v12 + 16);
      ++v14;
      v12 += 24LL;
      if (v14 >= *((void *)a1 + 7)) {
        goto LABEL_15;
      }
    }

    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamDestroyEx",  875,  29,  "F_PUNCHHOLE failed",  v16,  v17,  v18,  v27);
  }

  else
  {
    uint64_t v13 = 0LL;
  }

uint64_t OArchiveFileStreamWrite( uint64_t a1, char *__buf, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1LL;
  }
  unint64_t v11 = a3;
  if (a3)
  {
    uint64_t v9 = 0LL;
    unsigned int v48 = (unint64_t *)(a1 + 48);
    unint64_t v13 = *(void *)(a1 + 16);
    while (v13)
    {
      if (v13 >= v11) {
        unint64_t v13 = v11;
      }
      if (v13 >= 0x40000000) {
        unint64_t v14 = 0x40000000LL;
      }
      else {
        unint64_t v14 = v13;
      }
      uint64_t v15 = *(void *)(a1 + 24);
      if (v15)
      {
        uint64_t v16 = ParallelCompressionAFSCStreamWrite(v15, (uint64_t)__buf, v14, a4, a5, a6, a7, a8);
        ssize_t v17 = v16;
        if (v16 < 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamWrite",  955,  29,  0,  "ParallelCompressionAFSCStreamWrite failed with status %d",  a7,  a8,  v16);
          return -1LL;
        }
      }

      else
      {
        if ((*(_DWORD *)a1 & 0x80000000) != 0) {
          return -1LL;
        }
        ssize_t v17 = write(*(_DWORD *)a1, __buf, v14);
        if (v17 < 0)
        {
          int v44 = *__error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OArchiveFileStreamWrite",  960,  29,  v44,  "write",  v45,  v46,  v47);
          return -1LL;
        }
      }

      if (*(_DWORD *)(a1 + 40))
      {
        unint64_t v18 = 0LL;
        LODWORD(v19) = *(_DWORD *)(a1 + 72);
        int v20 = *(_DWORD *)(a1 + 76);
        do
        {
          uint64_t v21 = (v19 - v20);
          if (v18 + v21 <= v14) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = (v14 - v18);
          }
          uint64_t v23 = &__buf[v18];
          uint64_t v24 = &__buf[v18 + v22];
          if (((unint64_t)&__buf[v18] & 7) != 0 && (_DWORD)v22)
          {
            uint64_t v25 = &__buf[v18 + 1];
            while (!*v23)
            {
              if (++v23 < v24)
              {
              }

              goto LABEL_29;
            }

void *OMemStreamCreate(uint64_t a1, uint64_t a2)
{
  off_t v4 = malloc(0x20uLL);
  unint64_t v5 = v4;
  if (v4)
  {
    *off_t v4 = a1;
    v4[1] = 0LL;
    v4[2] = a2;
    v4[3] = 0LL;
  }

  else
  {
    int v6 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OMemStreamCreate",  1050,  29,  *v6,  "malloc",  v7,  v8,  v10);
  }

  return v5;
}

uint64_t OMemStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1LL;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(*(void **)a1, a2, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

void *IMemStreamCreate(uint64_t a1, uint64_t a2)
{
  size_t v4 = malloc(0x20uLL);
  size_t v5 = v4;
  if (v4)
  {
    *size_t v4 = a1;
    v4[1] = 0LL;
    v4[2] = a2;
    v4[3] = 0LL;
  }

  else
  {
    int v6 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"IMemStreamCreate",  1112,  29,  *v6,  "malloc",  v7,  v8,  v10);
  }

  return v5;
}

size_t IMemStreamRead(uint64_t a1, void *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1LL;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(__dst, *(const void **)a1, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

uint64_t IMemStreamAbort(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 8) = 1;
  }
  return result;
}

char *OBufferedStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v8 = (char *)malloc(0x28uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    char v10 = MemBufferCreate(a4);
    *(void *)uint64_t v9 = v10;
    if (v10)
    {
      *((void *)v9 + 1) = a1;
      *((void *)v9 + 2) = a2;
      *((void *)v9 + 3) = a3;
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OBufferedStreamCreate",  1182,  29,  0,  "creating internal buffer",  v11,  v12,  v24);
      OBufferedStreamDestroy((void ***)v9, v16, v17, v18, v19, v20, v21, v22);
      return 0LL;
    }
  }

  else
  {
    unint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OBufferedStreamCreate",  1176,  29,  *v13,  "malloc",  v14,  v15,  v24);
  }

  return v9;
}

void OBufferedStreamDestroy( void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    MemBufferFlushToOStream( *a1,  0xFFFFFFFFFFFFFFFFLL,  (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1],  (uint64_t)a1[3],  a5,  a6,  a7,  a8);
    MemBufferDestroy(*a1);
    free(a1);
  }

uint64_t OBufferedStreamWrite(unint64_t **a1, char *a2, unint64_t a3)
{
  if (a1 && !*((_DWORD *)a1 + 8))
  {
    unint64_t v6 = a3;
    if (!a3) {
      return 0LL;
    }
    uint64_t v4 = 0LL;
    while (1)
    {
      unint64_t FreeSize = MemBufferGetFreeSize(*a1);
      if (!FreeSize)
      {
        if (MemBufferFlushToOStream( *a1,  0xFFFFFFFFFFFFFFFFLL,  (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1],  (uint64_t)a1[3],  v9,  v10,  v11,  v12) < 0) {
          return -1LL;
        }
        unint64_t FreeSize = MemBufferGetFreeSize(*a1);
      }

      size_t v13 = v6 >= FreeSize ? FreeSize : v6;
      if (MemBufferFillFromBuffer(*a1, v13, a2) < 0) {
        break;
      }
      a2 += v13;
      v4 += v13;
      v6 -= v13;
      if (!v6) {
        return v4;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c",  (uint64_t)"OBufferedStreamWrite",  1221,  29,  0,  "MemBufferFillFromBuffer failed",  v14,  v15,  v16);
  }

  return -1LL;
}

void *aaAssetDecompressionStreamOpen(uint64_t a1)
{
  int v2 = malloc(0x70uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __int16 v6 = 277;
LABEL_6:
    uint64_t v7 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c",  (uint64_t)"aaAssetDecompressionStreamOpen",  v6,  132,  *v7,  "malloc",  v8,  v9,  v11);
    closeProc_0((uint64_t)v3);
    return 0LL;
  }

  memset_s(v2, 0x70uLL, 0, 0x70uLL);
  *uint64_t v3 = a1;
  uint64_t v4 = malloc(0x38uLL);
  if (!v4)
  {
    __int16 v6 = 282;
    goto LABEL_6;
  }

  size_t v5 = v4;
  memset_s(v4, 0x38uLL, 0, 0x38uLL);
  void *v5 = v3;
  v5[1] = closeProc_0;
  v5[6] = closeWithStateProc_0;
  v5[2] = cancelProc_0;
  v5[3] = writeProc_0;
  return v5;
}

uint64_t closeProc_0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    uint64_t v3 = (void *)(result + 56);
    free(*(void **)(result + 72));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[12]);
    memset_s(v1 + 10, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x70uLL, 0, 0x70uLL);
    free(v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t closeWithStateProc_0( uint64_t result, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v9 = result;
    unsigned int v10 = atomic_load((unsigned int *)(result + 8));
    uint64_t v12 = (uint64_t *)(result + 80);
    uint64_t v11 = *(void *)(result + 80);
    uint64_t v32 = *(void *)(result + 24);
    __int128 v13 = *(_OWORD *)(result + 48);
    __int128 v33 = *(_OWORD *)(result + 32);
    __int128 v34 = v13;
    BOOL v14 = v10 == 0;
    uint64_t v15 = (uint64_t *)(result + 56);
    uint64_t v16 = *(void *)(result + 104);
    uint64_t v35 = v11;
    uint64_t v36 = v16;
    if (a2[3])
    {
      uint64_t v18 = 0LL;
      uint64_t v19 = &v32;
      uint64_t v20 = 56LL;
      while (1)
      {
        uint64_t v21 = ((uint64_t (*)(void, uint64_t *, uint64_t))a2[3])(*a2, v19, v20);
        if (v21 < 1) {
          break;
        }
        uint64_t v19 = (uint64_t *)((char *)v19 + v21);
        v18 += v21;
        v20 -= v21;
        if (!v20)
        {
          if (v18 != 56) {
            break;
          }
          if (!a2[3]) {
            goto LABEL_29;
          }
          uint64_t v22 = *v15;
          if (*v15)
          {
            uint64_t v23 = 0LL;
            uint64_t v24 = *(void *)(v9 + 72);
            while (1)
            {
              uint64_t v25 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v24, v22);
              if (v25 < 1) {
                break;
              }
              v24 += v25;
              v23 += v25;
              v22 -= v25;
              if (!v22) {
                goto LABEL_18;
              }
            }

            uint64_t v23 = v25;
LABEL_18:
            if (v23 < 0 || !a2[3]) {
              goto LABEL_29;
            }
          }

          uint64_t v27 = *v12;
          if (*v12)
          {
            uint64_t v28 = 0LL;
            uint64_t v29 = *(void *)(v9 + 96);
            while (1)
            {
              uint64_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
              if (v30 < 1) {
                break;
              }
              v29 += v30;
              v28 += v30;
              v27 -= v30;
              if (!v27) {
                goto LABEL_26;
              }
            }

            uint64_t v28 = v30;
LABEL_26:
            if (v28 < 0)
            {
LABEL_29:
              __int16 v26 = 250;
              goto LABEL_14;
            }
          }

          if (a3) {
            *a3 = *(void *)(v9 + 104);
          }
          goto LABEL_15;
        }
      }
    }

    __int16 v26 = 245;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c",  (uint64_t)"closeWithStateProc",  v26,  132,  0,  "write state",  a7,  a8,  v31);
    BOOL v14 = 0;
LABEL_15:
    free(*(void **)(v9 + 72));
    memset_s(v12 - 3, 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v9 + 96));
    memset_s(v12, 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v9, 0x70uLL, 0, 0x70uLL);
    free((void *)v9);
    return (v14 - 1);
  }

  return result;
}

uint64_t writeProc_0( void **a1, char *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 1);
  uint64_t v10 = 0LL;
  uint64_t v15 = (unint64_t *)(a1 + 7);
  unint64_t v14 = (unint64_t)a1[7];
  uint64_t v16 = (unint64_t *)(a1 + 10);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v17 = *((_DWORD *)a1 + 6);
        if (v17 != 2) {
          break;
        }
        uint64_t v18 = a1[5];
        size_t v19 = (size_t)v18 - v14;
        if ((unint64_t)v18 <= v14)
        {
          uint64_t v35 = (uint64_t (*)(char *))a1[2];
          if (v35 && a1[6] != v18)
          {
            if (v18 != (void *)v14 || (uint64_t v40 = (char *)a1[10], (char *)a1[11] - v40 < (unint64_t)a1[4]))
            {
              unint64_t v57 = "invalid state";
              __int16 v58 = 174;
              goto LABEL_126;
            }

            uint64_t v41 = v35(&v40[(void)a1[12]]);
            if ((void *)v41 != a1[6])
            {
              unint64_t v57 = "corrupted stream";
              __int16 v58 = 176;
              goto LABEL_126;
            }

            unint64_t v14 = *v16;
            if (v41)
            {
              BOOL v42 = __CFADD__(v14, v41);
              v14 += v41;
              if (v42 || v14 > (unint64_t)a1[11])
              {
                unint64_t v57 = "invalid size";
                __int16 v58 = 177;
                goto LABEL_126;
              }

              *uint64_t v16 = v14;
            }

            uint64_t v36 = v16;
            if (v14)
            {
LABEL_67:
              unint64_t v43 = v36[2];
              while (1)
              {
                int v44 = (uint64_t (*)(void, unint64_t, unint64_t))(*a1)[3];
                if (!v44) {
                  break;
                }
                uint64_t v45 = v44(**a1, v43, v14);
                if (v45 <= 0) {
                  break;
                }
                v43 += v45;
                v14 -= v45;
                if (!v14) {
                  goto LABEL_71;
                }
              }

              unint64_t v57 = "write";
              __int16 v58 = 187;
              goto LABEL_126;
            }
          }

          else
          {
            uint64_t v36 = v15;
            if (v14) {
              goto LABEL_67;
            }
          }

LABEL_100:
        unint64_t v54 = a1[12];
        unint64_t v55 = realloc(v54, v53);
        if (!v55)
        {
          free(v54);
LABEL_123:
          uint64_t v15 = v16;
          goto LABEL_124;
        }

        a1[11] = (void *)v53;
        a1[12] = v55;
      }

      unint64_t v14 = 0LL;
      a1[7] = 0LL;
      *((_DWORD *)a1 + 6) = 1;
    }

    if (!(a3 | v14)) {
      goto LABEL_106;
    }
    if (v14 <= 0xF) {
      break;
    }
    uint64_t v29 = a1[9];
    unint64_t v30 = v29[1];
    unint64_t v31 = bswap64(*v29);
    unint64_t v32 = bswap64(v30);
    a1[5] = (void *)v32;
    a1[6] = (void *)v31;
    if (v31 < v32
      || ((__int128 v33 = a1[4], v31 <= (unint64_t)v33) ? (v34 = v32 > (unint64_t)v33) : (v34 = 1), v34))
    {
      unint64_t v57 = "invalid compressed stream";
      __int16 v58 = 149;
      goto LABEL_126;
    }

    unint64_t v14 = 0LL;
    a1[7] = 0LL;
    *((_DWORD *)a1 + 6) = 2;
  }

  uint64_t v56 = 16LL;
LABEL_105:
  size_t v19 = v56 - v14;
  if (a3) {
    goto LABEL_7;
  }
LABEL_106:
  if (v10 < 0)
  {
    do
    {
LABEL_128:
      if (__ldaxr(v8))
      {
        __clrex();
        return v10;
      }
    }

    while (__stlxr(1u, v8));
    unint64_t v60 = (void (*)(void))(*a1)[2];
    if (v60) {
      v60(**a1);
    }
  }

  return v10;
}

    if (v58 != v61)
    {
      unint64_t v47 = "loading last block";
      unint64_t v48 = 352;
      goto LABEL_104;
    }

    unint64_t v32 = v56;
    if (((v61 != v56) & ~HIDWORD(v79)) != 0)
    {
      unint64_t v31 = __size;
      uint64_t v8 = v81;
      if ((_DWORD)v79)
      {
        unint64_t v73 = PCompressLZMADecode(v18, __size, v17, v61);
        unint64_t v74 = v73 & ~(v73 >> 63);
        size_t v49 = algorithm;
      }

      else
      {
        size_t v49 = algorithm;
        unint64_t v74 = compression_decode_buffer(v18, __size, v17, v61, 0LL, algorithm);
      }

      if (v74 != v32)
      {
        unint64_t v47 = "Last block decompression";
        unint64_t v48 = 369;
        goto LABEL_104;
      }
    }

    else
    {
      memcpy(v18, v17, v56);
      size_t v49 = algorithm;
      unint64_t v31 = __size;
      uint64_t v8 = v81;
    }

    if ((AAByteStreamTruncate(compressed_stream) & 0x80000000) != 0) {
      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c",  (uint64_t)"AACompressionOutputStreamOpenExisting",  375,  19,  "Warning: container truncate failed",  v75,  v76,  v77,  v78);
    }
  }

  if (AAByteStreamSeek(compressed_stream, v8, 0) < 0)
  {
    unint64_t v47 = "Stream seek";
    unint64_t v48 = 380;
LABEL_104:
    int v44 = 0;
    goto LABEL_105;
  }

  size_t v20 = calloc(1uLL, 0x68uLL);
  if (!v20)
  {
    unint64_t v63 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c",  (uint64_t)"AACompressionOutputStreamOpenExisting",  384,  19,  *v63,  "malloc",  v64,  v65,  v78);
    size_t v19 = 0LL;
    goto LABEL_17;
  }

  size_t v19 = (unsigned int *)calloc(1uLL, 0x30uLL);
  if (!v19)
  {
    unint64_t v66 = *__error();
    unint64_t v67 = "malloc";
    unint64_t v68 = 386;
LABEL_98:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c",  (uint64_t)"AACompressionOutputStreamOpenExisting",  v68,  19,  v66,  v67,  v52,  v53,  v78);
    goto LABEL_17;
  }

  if (!n_threads) {
    n_threads = getDefaultNThreads();
  }
  v19[2] = n_threads;
  unsigned int v50 = calloc(n_threads, 8uLL);
  *((void *)v19 + 2) = v50;
  if (v19[2])
  {
    unint64_t v51 = 0LL;
    while (1)
    {
      *(void *)(*((void *)v19 + 2) + 8 * v51) = CompressionWorkerDataCreate(v31, v49);
      unint64_t v54 = *((void *)v19 + 2);
      if (!*(void *)(v54 + 8 * v51)) {
        break;
      }
      ++v51;
      unsigned int v50 = (void *)v19[2];
    }

    unint64_t v67 = "Worker data allocation";
    unint64_t v68 = 394;
    goto LABEL_97;
  }

  unint64_t v54 = (uint64_t)v50;
  LODWORD(v50) = 0;
LABEL_88:
  unint64_t v69 = ThreadPipelineCreate( v50,  v54,  (uint64_t)CompressionWorkerProc,  (uint64_t)v19,  (uint64_t)CompressionConsumerProc,  0LL);
  *(void *)size_t v19 = v69;
  if (!v69)
  {
    unint64_t v67 = "Thread allocation";
    unint64_t v68 = 397;
LABEL_97:
    unint64_t v66 = 0;
    goto LABEL_98;
  }

  *((void *)v19 + 3) = compressed_stream;
  if (v18 && aaCompressionOutputStreamWrite((uint64_t)v19, (uint64_t)v18, v32, v70, v71, v72, v52, v53) != v32)
  {
    unint64_t v67 = "re-writing last block";
    unint64_t v68 = 404;
    goto LABEL_97;
  }

  unint64_t v21 = 0;
  v20[3] = aaCompressionOutputStreamWrite;
  v20[7] = aaCompressionOutputStreamAbort;
  *size_t v20 = v19;
  v20[1] = aaCompressionOutputStreamClose;
  v20[9] = aaCompressionOutputStreamFlush;
LABEL_18:
  free(v18);
  free(v17);
  if (v21)
  {
    free(v20);
    aaCompressionOutputStreamClose((uint64_t *)v19, v22, v23, v24, v25, v26, v27, v28);
    return 0LL;
  }

  return (AAByteStream)v20;
}

void **cancelProc_0(void **result)
{
  uint64_t v1 = (unsigned int *)(result + 1);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v1));
  uint64_t v3 = (uint64_t (*)(void))(*result)[2];
  if (v3) {
    return (void **)v3(**result);
  }
  return result;
}

void (**aaAssetDecompressionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  size_t v5 = (void (**)(void))aaAssetDecompressionStreamOpen(a1);
  uint64_t v8 = v5;
  if (!v5) {
    return v8;
  }
  uint64_t v9 = *v5;
  uint64_t v61 = 0LL;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v58 = 0u;
  if (!*((void *)a2 + 2))
  {
LABEL_14:
    unint64_t v21 = "truncated state";
    __int16 v22 = 316;
LABEL_15:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c",  (uint64_t)"aaAssetDecompressionStreamOpenWithState",  v22,  132,  0,  v21,  v6,  v7,  v58);
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0LL;
  }

  uint64_t v10 = 0LL;
  uint64_t v11 = &v58;
  uint64_t v12 = 56LL;
  do
  {
    uint64_t v13 = (*((uint64_t (**)(void, __int128 *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
    if (v13 < 0) {
      goto LABEL_14;
    }
    if (!v13) {
      break;
    }
    uint64_t v11 = (__int128 *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }

  while (v12);
  if (v10 < 0) {
    goto LABEL_14;
  }
  unsigned int v15 = v58;
  int v14 = DWORD1(v58);
  *((_DWORD *)v9 + 6) = v58;
  *((_DWORD *)v9 + 7) = v14;
  unint64_t v16 = *((void *)&v58 + 1);
  unint64_t v17 = v59;
  *((void *)v9 + 4) = *((void *)&v58 + 1);
  *((void *)v9 + 5) = v17;
  unint64_t v18 = *((void *)&v59 + 1);
  uint64_t v19 = v61;
  *((void *)v9 + 6) = *((void *)&v59 + 1);
  *((void *)v9 + 13) = v19;
  if (v15 >= 3)
  {
    unint64_t v21 = "invalid state";
    __int16 v22 = 330;
    goto LABEL_15;
  }

  if (v14 <= 1284)
  {
    switch(v14)
    {
      case 0:
        size_t v20 = 0LL;
        goto LABEL_31;
      case 256:
        size_t v20 = PCompressLZ4Decode;
        goto LABEL_31;
      case 774:
        size_t v20 = PCompressLZMADecode;
        goto LABEL_31;
    }

LABEL_61:
    __int128 v33 = (void *)*((void *)v9 + 12);
    BOOL v34 = realloc(v33, v30);
    if (v34)
    {
      *((void *)v9 + 11) = v30;
      *((void *)v9 + 12) = v34;
      goto LABEL_63;
    }

    free(v33);
LABEL_120:
    *((void *)v9 + 11) = 0LL;
    *((void *)v9 + 12) = 0LL;
LABEL_121:
    *((void *)v9 + 10) = 0LL;
LABEL_122:
    unint64_t v21 = "truncated state";
    __int16 v22 = 359;
    goto LABEL_15;
  }

      if (v18)
      {
        unint64_t v37 = 0LL;
        while (1)
        {
          unint64_t v38 = a1[13];
          unint64_t v39 = a1[15][v16];
          unint64_t v40 = &v38[6 * v39];
          size_t v41 = v40[2];
          BOOL v42 = v40[3];
          if (v41 == v42) {
            goto LABEL_70;
          }
          unint64_t v43 = *v12;
          if (*v12 == *v14) {
            goto LABEL_70;
          }
          if (v43 <= v41) {
            unint64_t v43 = v41;
          }
          if (v42 >= *v14) {
            BOOL v42 = *v14;
          }
          if (v43 >= v42)
          {
LABEL_70:
            unint64_t v43 = 0LL;
            BOOL v42 = 0LL;
          }

          size_t v44 = v42 - v43 + v37;
          if (v44 > v35) {
            break;
          }
          memcpy((char *)a1[23] + v37, (const void *)(v38[6 * v39 + 5] + v43 - v41), v42 - v43);
          ++v16;
          unint64_t v37 = v44;
          if (v16 == v17) {
            goto LABEL_73;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateRetireRanges",  328,  143,  0,  "invalid state",  v5,  v6,  v168);
        goto LABEL_122;
      }

      unint64_t v38 = "no overlapping segment found";
      unint64_t v39 = 539;
      goto LABEL_62;
    }

  if ((AAAFSCGetMetadata(a1, &v42, &v41) & 0x80000000) != 0)
  {
    uint64_t v11 = "reading current metadata";
    uint64_t v12 = 1229;
    goto LABEL_5;
  }

  if (v42 != a2 || (v16 = 0LL, unsigned int v15 = 0LL, a3) && v41 != a3)
  {
    if ((resizeResourceFork(a1, a3) & 0x80000000) == 0)
    {
      unsigned int v15 = 0LL;
      unint64_t v16 = 0LL;
      goto LABEL_12;
    }

    uint64_t v11 = "resizing resource fork";
    uint64_t v12 = 1236;
    goto LABEL_5;
  }

        if (v18 == 34)
        {
          unint64_t v23 = 7;
          goto LABEL_69;
        }

        if (v18 != 125) {
          goto LABEL_102;
        }
        uint64_t v29 = *(_DWORD *)(a1 + 24);
        if (!v29) {
          goto LABEL_92;
        }
        size_t v25 = v29 - 1;
        size_t v26 = *(_DWORD *)(*(void *)(a1 + 32) + 4LL * v25);
LABEL_91:
        if ((v26 & 1) != 0)
        {
LABEL_92:
          uint64_t v19 = 125;
          goto LABEL_102;
        }

LABEL_104:
          size_t v53 = (void *)*((void *)v9 + 12);
          unint64_t v54 = realloc(v53, v52);
          if (v54)
          {
            *((void *)v9 + 11) = v52;
            *((void *)v9 + 12) = v54;
            unint64_t v49 = *((void *)v9 + 10);
            goto LABEL_106;
          }

          free(v53);
LABEL_128:
          *unint64_t v31 = 0LL;
          *((void *)v9 + 12) = 0LL;
          goto LABEL_121;
        }

        unint64_t v49 = v48;
      }

      size_t v52 = v48;
LABEL_106:
      if (v52 - v49 >= v46) {
        size_t v55 = v46;
      }
      else {
        size_t v55 = v52 - v49;
      }
      ssize_t v56 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 12) + v49), v55);
      if (v56 < 0) {
        goto LABEL_122;
      }
      if (!v56) {
        break;
      }
      uint64_t v57 = *((void *)v9 + 10);
      unint64_t v49 = v57 + v56;
      if (!__CFADD__(v57, v56))
      {
        unint64_t v48 = *v31;
        if (v49 <= *v31) {
          continue;
        }
      }

      goto LABEL_122;
      *((void *)v9 + 10) = v49;
      v47 += v56;
      v46 -= v56;
    }

    while (v46);
    if (v47 < 0) {
      goto LABEL_122;
    }
  }

  if (a3) {
    *a3 = *((void *)v9 + 13);
  }
  return v8;
}

unsigned int *ThreadPipelineCreate( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  uint64_t v12 = (unsigned int *)calloc(1uLL, 0x1A8uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    unsigned int *v12 = a1;
    int v14 = calloc(a1, 0x198uLL);
    *((void *)v13 + 1) = v14;
    if (v14)
    {
      unsigned int v15 = calloc(1uLL, 0x20uLL);
      *((void *)v13 + 2) = v15;
      if (v15)
      {
        size_t v16 = *v13;
        v13[10] = 0;
        v13[11] = v16;
        unint64_t v17 = calloc(v16, 4uLL);
        *((void *)v13 + 6) = v17;
        if (v17)
        {
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + 14), 0LL))
          {
            unint64_t v21 = "SharedArrayInit: pthread_mutex_init failed\n";
            __int16 v22 = 56;
          }

          else
          {
            if (!pthread_cond_init((pthread_cond_t *)(v13 + 30), 0LL))
            {
              size_t v29 = *v13 + 1;
              v13[42] = 0;
              v13[43] = v29;
              size_t v30 = calloc(v29, 4uLL);
              *((void *)v13 + 22) = v30;
              if (v30)
              {
                if (pthread_mutex_init((pthread_mutex_t *)(v13 + 46), 0LL))
                {
                  BOOL v34 = "SharedArrayInit: pthread_mutex_init failed\n";
                  __int16 v35 = 56;
                }

                else
                {
                  if (!pthread_cond_init((pthread_cond_t *)(v13 + 62), 0LL))
                  {
                    v13[6] = -1;
                    v13[74] = 0;
                    if (pthread_mutex_init((pthread_mutex_t *)(v13 + 76), 0LL)
                      || pthread_cond_init((pthread_cond_t *)(v13 + 92), 0LL))
                    {
                      size_t v26 = "SemInit";
                      __int16 v27 = 184;
                    }

                    else if (*v13)
                    {
                      uint64_t v36 = 0LL;
                      uint64_t v37 = 0LL;
                      while (1)
                      {
                        uint64_t v38 = *((void *)v13 + 1);
                        uint64_t v39 = v38 + v36;
                        *(void *)(v39 + 16) = v13;
                        *(_DWORD *)(v39 + 8) = v37;
                        uint64_t v43 = v37;
                        *(void *)(v39 + 24) = *(void *)(a2 + 8 * v37);
                        *(void *)(v39 + 32) = a3;
                        *(_DWORD *)(v39 + 40) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 48), 0LL)
                          || pthread_cond_init((pthread_cond_t *)(v39 + 112), 0LL))
                        {
                          size_t v26 = "SemInit";
                          __int16 v27 = 194;
                          goto LABEL_14;
                        }

                        *(_DWORD *)(v38 + v36 + 160) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 168), 0LL)
                          || pthread_cond_init((pthread_cond_t *)(v38 + v36 + 232), 0LL))
                        {
                          size_t v26 = "SemInit";
                          __int16 v27 = 195;
                          goto LABEL_14;
                        }

                        uint64_t v40 = v38 + v36;
                        *(_DWORD *)(v40 + 280) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v40 + 288), 0LL)
                          || pthread_cond_init((pthread_cond_t *)(v40 + 352), 0LL))
                        {
                          size_t v26 = "SemInit";
                          __int16 v27 = 196;
                          goto LABEL_14;
                        }

                        uint64_t v37 = v43 + 1;
                        v36 += 408LL;
                      }

                      size_t v26 = "Thread creation";
                      __int16 v27 = 197;
                    }

                    else
                    {
LABEL_37:
                      uint64_t v41 = *((void *)v13 + 2);
                      *(void *)(v41 + 8) = v13;
                      *(void *)(v41 + 16) = a4;
                      *(void *)(v41 + 24) = a5;
                      size_t v26 = "Thread creation";
                      __int16 v27 = 206;
                    }

                    goto LABEL_14;
                  }

                  BOOL v34 = "SharedArrayInit: pthread_cond_init failed\n";
                  __int16 v35 = 57;
                }
              }

              else
              {
                BOOL v34 = "SharedArrayInit: malloc failed\n";
                __int16 v35 = 55;
              }

              pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v35,  0,  v34,  v31,  v32,  v33,  v42);
              size_t v26 = "SharedArrayInit";
              __int16 v27 = 182;
LABEL_14:
              int v23 = 0;
              goto LABEL_15;
            }

            unint64_t v21 = "SharedArrayInit: pthread_cond_init failed\n";
            __int16 v22 = 57;
          }
        }

        else
        {
          unint64_t v21 = "SharedArrayInit: malloc failed\n";
          __int16 v22 = 55;
        }

        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v22,  0,  v21,  v18,  v19,  v20,  v42);
        size_t v26 = "SharedArrayInit";
        __int16 v27 = 180;
        goto LABEL_14;
      }

      int v23 = *__error();
      size_t v26 = "malloc";
      __int16 v27 = 179;
    }

    else
    {
      int v23 = *__error();
      size_t v26 = "malloc";
      __int16 v27 = 177;
    }
  }

  else
  {
    int v23 = *__error();
    size_t v26 = "malloc";
    __int16 v27 = 172;
  }

uint64_t threadPipelineWorkerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = (pthread_mutex_t *)(a1 + 48);
  uint64_t v4 = (pthread_cond_t *)(a1 + 112);
  size_t v5 = (unsigned int *)(v2 + 416);
  size_t v30 = (pthread_mutex_t *)(a1 + 168);
  uint64_t v31 = (pthread_mutex_t *)(v2 + 56);
  size_t v29 = (pthread_cond_t *)(a1 + 232);
  uint64_t v6 = (pthread_mutex_t *)(a1 + 288);
  uint64_t v7 = (pthread_cond_t *)(a1 + 352);
  while (1)
  {
    int v8 = *(_DWORD *)(a1 + 8);
    if (pthread_mutex_lock(v31))
    {
      __int16 v27 = "SharedArrayPush: pthread_mutex_lock failed\n";
      __int16 v28 = 117;
      goto LABEL_37;
    }

    uint64_t v12 = *(unsigned int *)(v2 + 40);
    unsigned int v13 = *(_DWORD *)(v2 + 44);
    int v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(void *)(v2 + 48) + 4 * v12) = v8;
      int v14 = *(_DWORD *)(v2 + 40);
    }

    *(_DWORD *)(v2 + 40) = v14 + 1;
    if (!v14)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 120))) {
        break;
      }
    }

    if (pthread_mutex_unlock(v31))
    {
      __int16 v27 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      __int16 v28 = 124;
      goto LABEL_37;
    }

    if (v12 >= v13)
    {
      __int16 v27 = "SharedArrayPush: stack is full\n";
      __int16 v28 = 125;
      goto LABEL_37;
    }

    if (pthread_mutex_lock(v3)) {
      goto LABEL_28;
    }
    while (1)
    {
      int v17 = *(_DWORD *)(a1 + 40);
      if (v17 > 0) {
        break;
      }
      if (pthread_cond_wait(v4, v3)) {
        goto LABEL_28;
      }
    }

    *(_DWORD *)(a1 + 40) = v17 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_28:
      int v23 = "SemAcquire";
      __int16 v24 = 72;
      goto LABEL_29;
    }

    if ((*(void *)(a1 + 400) & 0x8000000000000000LL) != 0) {
      return a1;
    }
    if (((*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24)) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"threadPipelineWorkerThreadProc",  82,  87,  0,  "worker proc reported an error",  v18,  v19,  (char)v29);
      do
        unsigned int v20 = __ldxr(v5);
      while (__stxr(v20 + 1, v5));
    }

    if (pthread_mutex_lock(v30)
      || (int v21 = *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 160) = v21 + 1, !v21) && pthread_cond_broadcast(v29)
      || pthread_mutex_unlock(v30))
    {
      int v23 = "SemRelease";
      __int16 v24 = 85;
      goto LABEL_29;
    }

    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        int v22 = *(_DWORD *)(a1 + 280);
        if (v22 > 0) {
          break;
        }
        if (pthread_cond_wait(v7, v6)) {
          goto LABEL_27;
        }
      }

      *(_DWORD *)(a1 + 280) = v22 - 1;
      if (!pthread_mutex_unlock(v6)) {
        continue;
      }
    }

uint64_t threadPipelineConsumerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)))
  {
    uint64_t v12 = (pthread_cond_t *)(v2 + 248);
    unsigned int v13 = (pthread_mutex_t *)(v2 + 304);
    uint64_t v32 = (pthread_cond_t *)(v2 + 368);
    int v14 = (unsigned int *)(v2 + 416);
    do
    {
      while (1)
      {
        int v15 = *(_DWORD *)(v2 + 168);
        if (v15) {
          break;
        }
        if (pthread_cond_wait(v12, (pthread_mutex_t *)(v2 + 184)))
        {
          uint64_t v6 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v7 = 94;
          goto LABEL_3;
        }
      }

      unsigned int v16 = v15 - 1;
      *(_DWORD *)(v2 + 168) = v16;
      unsigned int v17 = *(_DWORD *)(*(void *)(v2 + 176) + 4LL * v16);
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 184)))
      {
        uint64_t v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v7 = 98;
        goto LABEL_3;
      }

      if (v17 == -2)
      {
        if (!pthread_mutex_lock(v13))
        {
          int v23 = *(_DWORD *)(v2 + 296);
          *(_DWORD *)(v2 + 296) = v23 + 1;
          if (v23 || !pthread_cond_broadcast(v32)) {
            pthread_mutex_unlock(v13);
          }
        }
      }

      else
      {
        if (v17 == -1) {
          return a1;
        }
        uint64_t v18 = v12;
        uint64_t v19 = *(void *)(v2 + 8);
        uint64_t v20 = v19 + 408LL * v17;
        int v21 = (pthread_mutex_t *)(v20 + 168);
        if (pthread_mutex_lock((pthread_mutex_t *)(v20 + 168))) {
          goto LABEL_31;
        }
        int v22 = (int *)(v20 + 160);
        while (*v22 <= 0)
        {
          if (pthread_cond_wait((pthread_cond_t *)(v19 + 408LL * v17 + 232), v21)) {
            goto LABEL_31;
          }
        }

        --*v22;
        if (pthread_mutex_unlock(v21))
        {
LABEL_31:
          uint64_t v10 = "SemAcquire";
          __int16 v11 = 134;
          goto LABEL_32;
        }

        if (((*(uint64_t (**)(void, void))(a1 + 24))( *(void *)(a1 + 16),  *(void *)(v19 + 408LL * v17 + 24)) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"threadPipelineConsumerThreadProc",  141,  87,  0,  "consumer proc reported an error",  v24,  v25,  (char)v32);
          do
            unsigned int v26 = __ldxr(v14);
          while (__stxr(v26 + 1, v14));
        }

        uint64_t v12 = v18;
        unsigned int v13 = (pthread_mutex_t *)(v2 + 304);
        if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 408LL * v17 + 288))
          || (uint64_t v27 = v19 + 408LL * v17, v28 = *(_DWORD *)(v27 + 280), *(_DWORD *)(v27 + 280) = v28 + 1, !v28)
          && pthread_cond_broadcast((pthread_cond_t *)(v19 + 408LL * v17 + 352))
          || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 408LL * v17 + 288)))
        {
          uint64_t v10 = "SemRelease";
          __int16 v11 = 144;
          goto LABEL_32;
        }
      }
    }

    while (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)));
  }

  uint64_t v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
  __int16 v7 = 91;
LABEL_3:
  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v7,  0,  v6,  v3,  v4,  v5,  (char)v32);
  uint64_t v10 = "SharedArrayDequeue";
  __int16 v11 = 114;
LABEL_32:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"threadPipelineConsumerThreadProc",  v11,  87,  0,  v10,  v8,  v9,  (char)v32);
  size_t v29 = (unsigned int *)(v2 + 416);
  do
    unsigned int v30 = __ldxr(v29);
  while (__stxr(v30 + 1, v29));
  return a1;
}

uint64_t ThreadPipelineDestroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (unsigned int *)result;
    uint64_t v2 = *(void **)(result + 8);
    if (v2)
    {
      uint64_t v3 = *(unsigned int *)result;
      if (!(_DWORD)v3)
      {
        int v6 = 1;
        goto LABEL_41;
      }

      int v4 = 0;
      do
      {
        if (*v2) {
          ++v4;
        }
        v2 += 51;
        --v3;
      }

      while (v3);
      if (v4)
      {
        int v5 = 0;
        int v6 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 14)))
          {
            __int16 v10 = 91;
            __int16 v11 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v10,  0,  v11,  v7,  v8,  v9,  v41);
            unsigned int v15 = -1;
          }

          else
          {
            while (1)
            {
              unsigned int v12 = v1[10];
              if (v12) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 30), (pthread_mutex_t *)(v1 + 14)))
              {
                __int16 v10 = 94;
                __int16 v11 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }

            unsigned int v22 = v12 - 1;
            v1[10] = v22;
            unsigned int v15 = *(_DWORD *)(*((void *)v1 + 6) + 4LL * v22);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14))) {
              goto LABEL_17;
            }
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  98,  0,  "SharedArrayPop: pthread_mutex_unlock failed\n",  v23,  v24,  v25,  v41);
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  237,  87,  0,  "SharedArrayPop",  v13,  v14,  v42);
          int v6 = 0;
LABEL_17:
          uint64_t v16 = *((void *)v1 + 1);
          uint64_t v17 = v16 + 408LL * v15;
          *(void *)(v17 + 400) = -1LL;
          if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 48))
            || (uint64_t v20 = v16 + 408LL * v15, v21 = *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40) = v21 + 1, !v21)
            && pthread_cond_broadcast((pthread_cond_t *)(v16 + 408LL * v15 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 48)))
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  245,  87,  0,  "SemRelease",  v18,  v19,  v41);
            int v6 = 0;
          }

          if ((joinThread(*(_opaque_pthread_t **)v17) & 0x80000000) != 0)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  246,  87,  0,  "joinThread",  v26,  v27,  v41);
            int v6 = 0;
          }

          *(void *)uint64_t v17 = 0LL;
          if (++v5 == v4)
          {
            if (!*v1) {
              goto LABEL_41;
            }
            goto LABEL_33;
          }
        }
      }

      int v6 = 1;
LABEL_33:
      unint64_t v28 = 0LL;
      uint64_t v29 = 352LL;
      do
      {
        uint64_t v30 = *((void *)v1 + 1);
        uint64_t v31 = v30 + v29;
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v30 + v29 - 304))) {
          pthread_cond_destroy((pthread_cond_t *)(v31 - 240));
        }
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v31 - 184))) {
          pthread_cond_destroy((pthread_cond_t *)(v30 + v29 - 120));
        }
        uint64_t v32 = (pthread_cond_t *)(v30 + v29);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v32[-2].__opaque[24])) {
          pthread_cond_destroy(v32);
        }
        ++v28;
        v29 += 408LL;
      }

      while (v28 < *v1);
LABEL_41:
      free(*((void **)v1 + 1));
      *((void *)v1 + 1) = 0LL;
    }

    else
    {
      int v6 = 1;
    }

    uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
    if (v33)
    {
      if (*v33)
      {
        if ((SharedArrayEnqueue_0(v1 + 42, -1) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  272,  87,  0,  "SharedArrayEnqueue",  v34,  v35,  v41);
          int v6 = 0;
        }

        if ((joinThread(*v33) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  273,  87,  0,  "joinThread",  v36,  v37,  v41);
          int v6 = 0;
        }

        *uint64_t v33 = 0LL;
        uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
      }

      free(v33);
      *((void *)v1 + 2) = 0LL;
    }

    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 14)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 30))) {
      free(*((void **)v1 + 6));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 46)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 62))) {
      free(*((void **)v1 + 22));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 76))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 92));
    }
    int v40 = atomic_load(v1 + 104);
    if (v40 >= 1)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineDestroy",  285,  87,  0,  "Threads reported errors",  v38,  v39,  v41);
      int v6 = 0;
    }

    free(v1);
    if (v6) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t ThreadPipelineGetWorker( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24) != -1)
  {
    uint64_t v8 = "Missing call to RunWorker before GetWorker";
    __int16 v9 = 294;
LABEL_11:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineGetWorker",  v9,  87,  0,  v8,  a7,  a8,  v21);
    return 0LL;
  }

  __int16 v11 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    unsigned int v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v16 = 91;
LABEL_10:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v16,  0,  v15,  v12,  v13,  v14,  v21);
    uint64_t v8 = "SharedArrayPop failed";
    __int16 v9 = 298;
    goto LABEL_11;
  }

  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v11))
    {
      unsigned int v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v16 = 94;
      goto LABEL_10;
    }
  }

  unsigned int v18 = v17 - 1;
  *(_DWORD *)(a1 + 40) = v18;
  unsigned int v19 = *(_DWORD *)(*(void *)(a1 + 48) + 4LL * v18);
  if (pthread_mutex_unlock(v11))
  {
    unsigned int v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v16 = 98;
    goto LABEL_10;
  }

  *(_DWORD *)(a1 + 24) = v19;
  return *(void *)(*(void *)(a1 + 8) + 408LL * v19 + 24);
}

uint64_t ThreadPipelineRunWorker( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 24);
  if (v8 == -1)
  {
    uint64_t v14 = "Missing call to GetWorker before RunWorker";
    __int16 v15 = 311;
    goto LABEL_10;
  }

  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v10 + 1;
  *(void *)(v9 + 408LL * v8 + 400) = v10;
  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), v8) & 0x80000000) != 0)
  {
    uint64_t v14 = "SharedArrayEnqueue failed";
    __int16 v15 = 324;
    goto LABEL_10;
  }

  if (pthread_mutex_lock((pthread_mutex_t *)(v9 + 408LL * v8 + 48))
    || (uint64_t v11 = v9 + 408LL * v8, v12 = *(_DWORD *)(v11 + 40), *(_DWORD *)(v11 + 40) = v12 + 1, !v12)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 408LL * v8 + 112))
    || (uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 408LL * v8 + 48)), (_DWORD)result))
  {
    uint64_t v14 = "SemRelease failed";
    __int16 v15 = 325;
LABEL_10:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineRunWorker",  v15,  87,  0,  v14,  a7,  a8,  v16);
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t ThreadPipelineFlush(uint64_t a1)
{
  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), -2) & 0x80000000) != 0)
  {
    int v5 = "SharedArrayEnqueue failed";
    __int16 v6 = 333;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c",  (uint64_t)"ThreadPipelineFlush",  v6,  87,  0,  v5,  v2,  v3,  v8);
    return 0xFFFFFFFFLL;
  }

  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 304))) {
    goto LABEL_8;
  }
  while (1)
  {
    int v4 = *(_DWORD *)(a1 + 296);
    if (v4 > 0) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 368), (pthread_mutex_t *)(a1 + 304))) {
      goto LABEL_8;
    }
  }

  *(_DWORD *)(a1 + 296) = v4 - 1;
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if ((_DWORD)result)
  {
LABEL_8:
    int v5 = "SemAquire failed";
    __int16 v6 = 336;
    goto LABEL_9;
  }

  return result;
}

void *AARangeInputStreamOpen(uint64_t a1, uint64_t a2)
{
  int v4 = calloc(1uLL, 0x68uLL);
  int v5 = malloc(0x30uLL);
  __int16 v6 = v5;
  if (!v5 || (memset_s(v5, 0x30uLL, 0, 0x30uLL), !v4))
  {
    int v10 = *__error();
    uint64_t v11 = "malloc";
    __int16 v12 = 81;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c",  (uint64_t)"AARangeInputStreamOpen",  v12,  118,  v10,  v11,  v8,  v9,  v14);
    free(v6);
    free(v4);
    return 0LL;
  }

  *__int16 v6 = a1;
  uint64_t v7 = AAByteRangeClone(a2);
  v6[1] = v7;
  if (!v7)
  {
    uint64_t v11 = "AAByteRangeClone";
    __int16 v12 = 86;
    int v10 = 0;
    goto LABEL_7;
  }

  v6[4] = AAByteRangeFirst((uint64_t)v7, 0LL, v6 + 2, v6 + 3);
  *int v4 = v6;
  v4[1] = rangeInputStreamClose;
  v4[7] = rangeInputStreamCancel;
  v4[2] = rangeInputStreamRead;
  return v4;
}

uint64_t rangeInputStreamClose(void ***a1)
{
  return 0LL;
}

void rangeInputStreamCancel(AAByteStream *a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 5);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }

  __clrex();
}

uint64_t rangeInputStreamRead(uint64_t a1, char *buf, unint64_t a3)
{
  uint64_t v3 = (unsigned int *)(a1 + 40);
  uint64_t v5 = 0LL;
  if ((*(void *)(a1 + 32) & 0x8000000000000000LL) == 0)
  {
    unint64_t v8 = a3;
    if (a3)
    {
      uint64_t v5 = 0LL;
      uint64_t v11 = (off_t *)(a1 + 16);
      off_t v10 = *(void *)(a1 + 16);
      __int16 v12 = (off_t *)(a1 + 24);
      while (1)
      {
        off_t v13 = *v12;
        if (v10 >= *v12)
        {
          uint64_t v14 = AAByteRangeNext(*(void *)(a1 + 8), *(void *)(a1 + 32), (void *)(a1 + 16), (void *)(a1 + 24));
          *(void *)(a1 + 32) = v14;
          if (v14 < 0) {
            return v5;
          }
          off_t v10 = *v11;
          off_t v13 = *v12;
        }

        uint64_t v15 = v8 >= 0x10000000 ? 0x10000000LL : v8;
        size_t v16 = v10 + v15 <= v13 ? v15 : v13 - v10;
        ssize_t v17 = AAByteStreamPRead(*(AAByteStream *)a1, buf, v16, v10);
        if (v17 < 1) {
          break;
        }
        off_t v10 = *v11 + v17;
        off_t *v11 = v10;
        buf += v17;
        v5 += v17;
        v8 -= v17;
        if (!v8) {
          return v5;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c",  (uint64_t)"rangeInputStreamRead",  59,  118,  0,  "Stream pread",  v18,  v19,  v21);
      while (!__ldaxr(v3))
      {
        if (!__stlxr(1u, v3))
        {
          AAByteStreamCancel(*(AAByteStream *)a1);
          return -1LL;
        }
      }

      __clrex();
      return -1LL;
    }
  }

  return v5;
}

_DWORD *ParallelCompressionAFSCStreamOpen(int a1, unint64_t a2, int a3, int a4)
{
  off_t v10 = calloc(1uLL, 0x78uLL);
  if (!v10)
  {
    off_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCStreamOpen",  163,  86,  *v13,  "malloc",  v14,  v15,  v35);
LABEL_39:
    free(v10);
    return 0LL;
  }

  if (!a2)
  {
    uint64_t v11 = "File too small for AFSC";
    __int16 v12 = 167;
LABEL_7:
    int v16 = 0;
LABEL_38:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCStreamOpen",  v12,  86,  v16,  v11,  v8,  v9,  v35);
    free(*((void **)v10 + 5));
    free(*((void **)v10 + 8));
    free(*((void **)v10 + 10));
    free(*((void **)v10 + 11));
    goto LABEL_39;
  }

  if (a2 >= 0xFA000001)
  {
    uint64_t v11 = "File too large for AFSC";
    __int16 v12 = 168;
    goto LABEL_7;
  }

  if (a3) {
    int v17 = a3;
  }
  else {
    int v17 = 8;
  }
  int v18 = v17 - 3;
  compression_algorithm v19 = 0;
  size_t v20 = 0LL;
  char v21 = -52;
  compression_algorithm v22 = 1285;
  char v23 = -1;
  switch(v17)
  {
    case 4:
      goto LABEL_19;
    case 8:
      compression_algorithm v22 = 2304;
      char v23 = 6;
      goto LABEL_19;
    case 10:
      goto LABEL_22;
    case 12:
      compression_algorithm v22 = COMPRESSION_LZFSE;
      goto LABEL_19;
    case 14:
      compression_algorithm v22 = 1794;
LABEL_19:
      size_t v20 = compression_encode_scratch_buffer_size(v22);
      size_t v24 = compression_decode_scratch_buffer_size(v22);
      if (v20 <= v24) {
        size_t v20 = v24;
      }
      compression_algorithm v19 = v22;
      char v21 = v23;
LABEL_22:
      _DWORD *v10 = a1;
      unint64_t v25 = (a2 + 0xFFFF) >> 16;
      *((void *)v10 + 1) = a2;
      v10[4] = v17;
      v10[5] = v19;
      *((_BYTE *)v10 + 24) = v21;
      v10[7] = a4;
      v10[8] = v25;
      uint64_t v26 = calloc(v25 + 1, 4uLL);
      *((void *)v10 + 5) = v26;
      if (!v26)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 210;
        goto LABEL_38;
      }

      uint64_t v27 = v26;
      *((_OWORD *)v10 + 3) = xmmword_1862D7AF0;
      unint64_t v28 = malloc(0x100000uLL);
      *((void *)v10 + 8) = v28;
      if (!v28)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 214;
        goto LABEL_38;
      }

      *((void *)v10 + 9) = 0LL;
      uint64_t v29 = malloc(0x10000uLL);
      *((void *)v10 + 10) = v29;
      if (!v29)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 217;
        goto LABEL_38;
      }

      if (v20)
      {
        uint64_t v30 = malloc(v20);
        *((void *)v10 + 11) = v30;
        if (!v30)
        {
          int v16 = *__error();
          uint64_t v11 = "malloc";
          __int16 v12 = 221;
          goto LABEL_38;
        }
      }

      char v31 = 2;
      if (v10[4] == 4) {
        char v31 = 3;
      }
      uint64_t v32 = 4LL;
      if (v10[4] == 4) {
        uint64_t v32 = 264LL;
      }
      unint64_t v33 = ((unint64_t)v10[8] << v31) + v32;
      if (HIDWORD(v33))
      {
        uint64_t v11 = "File too large for AFSC";
        __int16 v12 = 235;
        goto LABEL_7;
      }

      v10[27] = v33;
      *uint64_t v27 = v33;
      v10[26] = 0;
      *((void *)v10 + 12) = 0LL;
      v10[28] = 0;
      break;
    default:
      char v35 = v17;
      uint64_t v11 = "invalid compression type %d";
      __int16 v12 = 192;
      goto LABEL_7;
  }

  return v10;
}

uint64_t ParallelCompressionAFSCStreamWrite( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 96) + a3 <= *(void *)(a1 + 8))
  {
    if (!a3) {
      return 0LL;
    }
    unint64_t v10 = 0LL;
    size_t v14 = *(void *)(a1 + 56);
    while (v14 + 65537 <= *(void *)(a1 + 48) || (flushToResourceFork(a1) & 0x80000000) == 0)
    {
      uint64_t v15 = *(void *)(a1 + 72);
      if (0x10000 - v15 + v10 <= a3) {
        size_t v16 = 0x10000 - v15;
      }
      else {
        size_t v16 = a3 - v10;
      }
      if (v16 == 0x10000)
      {
        int v17 = (char *)(a2 + v10);
      }

      else
      {
        int v17 = *(char **)(a1 + 80);
        memcpy(&v17[v15], (const void *)(a2 + v10), v16);
        uint64_t v15 = *(void *)(a1 + 72);
      }

      size_t v18 = *(void *)(a1 + 96) + v16;
      *(void *)(a1 + 96) = v18;
      v10 += v16;
      size_t v19 = v15 + v16;
      *(void *)(a1 + 72) = v15 + v16;
      if ((v15 + v16) >> 16 || v18 >= *(void *)(a1 + 8))
      {
        uint64_t v21 = *(void *)(a1 + 56);
        uint64_t v20 = *(void *)(a1 + 64);
        compression_algorithm v22 = (_BYTE *)(v20 + v21);
        compression_algorithm v23 = *(_DWORD *)(a1 + 20);
        BOOL v24 = v19 < 0x78 || v23 == 0;
        if (v24
          || (size_t v25 = compression_encode_buffer( (uint8_t *)(v20 + v21),  0x10000uLL,  (const uint8_t *)v17,  v19,  *(void **)(a1 + 88),  v23)) == 0 || (*(_BYTE *)(a1 + 28) & 1) != 0 && (v26 = v25 + (v25 >> 6), size_t v25 = v26 + 32, v26 == -32LL)
          || v25 > *(void *)(a1 + 72) + 1LL)
        {
          _BYTE *v22 = *(_BYTE *)(a1 + 24);
          memcpy(v22 + 1, v17, *(void *)(a1 + 72));
          size_t v25 = *(void *)(a1 + 72) + 1LL;
        }

        *(void *)(a1 + 72) = 0LL;
        size_t v14 = *(void *)(a1 + 56) + v25;
        *(void *)(a1 + 56) = v14;
        if (v10 < a3) {
          continue;
        }
      }

      return v10;
    }

    uint64_t v8 = "update resource fork";
    __int16 v9 = 270;
  }

  else
  {
    uint64_t v8 = "too many bytes received";
    __int16 v9 = 262;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCStreamWrite",  v9,  86,  0,  v8,  a7,  a8,  v28);
  return -1LL;
}

uint64_t flushToResourceFork(uint64_t a1)
{
  int v2 = fsetxattr( *(_DWORD *)a1,  "com.apple.ResourceFork",  *(const void **)(a1 + 64),  *(void *)(a1 + 56),  *(_DWORD *)(a1 + 108),  0);
  if (v2 < 0)
  {
    uint64_t v3 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"flushToResourceFork",  142,  86,  *v3,  "fsetxattr resource fork",  v4,  v5,  v8);
  }

  int v6 = *(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 108) = v6;
  *(_DWORD *)(a1 + 112) = 1;
  return (v2 >> 31);
}

uint64_t ParallelCompressionAFSCStreamClose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  if (*(void *)(a1 + 96) >= *(void *)(a1 + 8) && !*(void *)(a1 + 72))
  {
    unsigned int v14 = *(_DWORD *)(a1 + 112);
    int v15 = *(_DWORD *)(a1 + 20);
    if (v15) {
      int v15 = (*(unsigned __int8 *)(a1 + 28) >> 1) & 1;
    }
    if (*(_DWORD *)(a1 + 32) > 1u) {
      int v15 = 1;
    }
    if (v14 | v15)
    {
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 341;
        goto LABEL_5;
      }

      unsigned int v14 = *(_DWORD *)(a1 + 112);
    }

    int v16 = (__PAIR64__(*(_DWORD *)(a1 + 16), v14) - 1) >> 32;
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v18 = *(void *)(a1 + 80);
    *(_DWORD *)uint64_t v18 = 1668116582;
    *(_DWORD *)(v18 + 4) = v16;
    *(void *)(v18 + 8) = v17;
    size_t v19 = 16LL;
    *(void *)(a1 + 72) = 16LL;
    if (!*(_DWORD *)(a1 + 112))
    {
      memcpy((void *)(*(void *)(a1 + 80) + 16LL), *(const void **)(a1 + 64), *(void *)(a1 + 56));
      size_t v19 = *(void *)(a1 + 72) + *(void *)(a1 + 56);
      *(void *)(a1 + 72) = v19;
      *(void *)(a1 + 56) = 0LL;
    }

    if (fsetxattr(*(_DWORD *)a1, "com.apple.decmpfs", *(const void **)(a1 + 80), v19, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr decmpfs";
      __int16 v10 = 363;
      goto LABEL_6;
    }

    if (!*(_DWORD *)(a1 + 112))
    {
      unsigned int v21 = 0;
      goto LABEL_36;
    }

    if (*(_DWORD *)(a1 + 16) == 4)
    {
      uint64_t v20 = *(void *)(a1 + 64);
      *(_OWORD *)uint64_t v20 = old_resource_fork_map;
      *(_OWORD *)(v20 + 16) = unk_1862D7B1B;
      *(_OWORD *)(v20 + 32) = xmmword_1862D7B2B;
      *(_WORD *)(v20 + 48) = 0;
      *(void *)(a1 + 56) = 50LL;
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 373;
        goto LABEL_5;
      }

      unsigned int v21 = *(_DWORD *)(a1 + 108);
      if (*(_DWORD *)(a1 + 16) == 4)
      {
        int v22 = *(_DWORD *)(a1 + 32);
        if ((unint64_t)(8 * v22) + 264 > *(void *)(a1 + 48))
        {
          LOBYTE(v42) = 8 * v22 + 8;
          __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
          __int16 v10 = 382;
          goto LABEL_5;
        }

        memset(&v43, 0, sizeof(v43));
        __int128 v44 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v49 = 0u;
        uint64_t v32 = *(void *)(a1 + 64);
        *(_DWORD *)uint64_t v32 = 0x10000;
        *(int8x8_t *)(v32 + 4) = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v21), (int32x2_t)0xFFFFFECEFFFFFFCELL));
        *(_DWORD *)(v32 + 12) = 838860800;
        st_atimespeCC_SHA1_CTX c = v43.st_atimespec;
        __int128 v34 = *(_OWORD *)&v43.st_dev;
        *(_OWORD *)(v32 + 32) = *(_OWORD *)&v43.st_uid;
        *(timespec *)(v32 + 48) = st_atimespec;
        *(_OWORD *)(v32 + 16) = v34;
        __int128 v35 = *(_OWORD *)&v43.st_size;
        *(timespec *)(v32 + 96) = v43.st_birthtimespec;
        *(_OWORD *)(v32 + 112) = v35;
        st_ctimespeCC_SHA1_CTX c = v43.st_ctimespec;
        *(timespec *)(v32 + 64) = v43.st_mtimespec;
        *(timespec *)(v32 + 80) = st_ctimespec;
        __int128 v37 = v45;
        *(_OWORD *)(v32 + 160) = v44;
        *(_OWORD *)(v32 + 176) = v37;
        __int128 v38 = *(_OWORD *)v43.st_qspare;
        *(_OWORD *)(v32 + 128) = *(_OWORD *)&v43.st_blksize;
        *(_OWORD *)(v32 + 144) = v38;
        __int128 v39 = v48;
        __int128 v40 = v46;
        *(_OWORD *)(v32 + 208) = v47;
        *(_OWORD *)(v32 + 224) = v39;
        *(_OWORD *)(v32 + 192) = v40;
        *(_OWORD *)(v32 + 240) = v49;
        *(_DWORD *)(v32 + 256) = bswap32(v21 - 310);
        *(_DWORD *)(v32 + 260) = v22;
        size_t v23 = 264LL;
        *(void *)(a1 + 56) = 264LL;
        if (*(_DWORD *)(a1 + 32))
        {
          unint64_t v41 = 0LL;
          size_t v23 = 264LL;
          do
          {
            *(void *)(*(void *)(a1 + 64) + v23) = (*(_DWORD *)(*(void *)(a1 + 40) + 4 * v41) - 260) | ((unint64_t)(*(_DWORD *)(*(void *)(a1 + 40) + 4 * v41 + 4) - *(_DWORD *)(*(void *)(a1 + 40) + 4 * v41)) << 32);
            ++v41;
            size_t v23 = *(void *)(a1 + 56) + 8LL;
            *(void *)(a1 + 56) = v23;
          }

          while (v41 < *(unsigned int *)(a1 + 32));
        }

        goto LABEL_35;
      }
    }

    else
    {
      unsigned int v21 = *(_DWORD *)(a1 + 108);
    }

    size_t v23 = (4 * *(_DWORD *)(a1 + 32) + 4);
    if (*(void *)(a1 + 48) < v23)
    {
      int v42 = 4 * *(_DWORD *)(a1 + 32) + 4;
      __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
      __int16 v10 = 408;
      goto LABEL_5;
    }

    memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 40), (4 * *(_DWORD *)(a1 + 32) + 4));
    *(void *)(a1 + 56) = v23;
LABEL_35:
    if (fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), v23, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr resource fork header";
      __int16 v10 = 418;
      goto LABEL_6;
    }

uint64_t ParallelCompressionAFSCGetMetadataFD(int a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  if (fstat(a1, &v24))
  {
    char v8 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCGetMetadataFD",  488,  86,  *v8,  "fstat",  v9,  v10,  v23);
    int v11 = 0LL;
LABEL_22:
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }

  if ((v24.st_flags & 0x20) != 0)
  {
    int v11 = (off_t *)malloc(0x1000uLL);
    if (v11)
    {
      unint64_t v13 = fgetxattr(a1, "com.apple.decmpfs", v11, 0x1000uLL, 0, 32);
      if ((v13 & 0x8000000000000000LL) != 0)
      {
        int v16 = "Missing decmpfs xattr";
        __int16 v17 = 504;
      }

      else if (v13 > 0xF)
      {
        if (*(_DWORD *)v11 == 1668116582)
        {
          unsigned int v19 = *((_DWORD *)v11 + 1);
          if (v19 > 0xE) {
            goto LABEL_27;
          }
          off_t v20 = v11[1];
          if (((1 << v19) & 0x2A88) != 0)
          {
            uint64_t v12 = 0LL;
            *a2 = v20;
            *a3 = v19;
            goto LABEL_5;
          }

          if (((1 << v19) & 0x5510) != 0)
          {
            *a2 = v20;
            *a3 = v19;
            unint64_t v21 = fgetxattr(a1, "com.apple.ResourceFork", 0LL, 0LL, 0, 32);
            if ((v21 & 0x8000000000000000LL) != 0)
            {
              int v16 = "Missing resource fork xattr";
              __int16 v17 = 532;
            }

            else
            {
              if (!HIDWORD(v21))
              {
                uint64_t v12 = 0LL;
                *a4 = v21;
                goto LABEL_23;
              }

              int v16 = "Invalid resource fork xattr";
              __int16 v17 = 533;
            }
          }

          else
          {
LABEL_27:
            int v23 = *((_DWORD *)v11 + 1);
            int v16 = "Invalid compression type %u in decmpfs xattr";
            __int16 v17 = 524;
          }
        }

        else
        {
          int v16 = "Invalid decmpfs xattr";
          __int16 v17 = 507;
        }
      }

      else
      {
        int v16 = "Truncated decmpfs xattr";
        __int16 v17 = 505;
      }

      int v18 = 0;
    }

    else
    {
      int v18 = *__error();
      int v16 = "malloc";
      __int16 v17 = 501;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCGetMetadataFD",  v17,  86,  v18,  v16,  v14,  v15,  v23);
    goto LABEL_22;
  }

  int v11 = 0LL;
  uint64_t v12 = 0LL;
  *a2 = v24.st_size;
  *a3 = -1;
LABEL_5:
  *a4 = 0;
LABEL_23:
  free(v11);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadata(const char *a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    unint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCGetMetadata",  550,  86,  *v13,  "open %s",  v14,  v15,  v7);
    return 0xFFFFFFFFLL;
  }

  else
  {
    int v9 = v8;
    if ((ParallelCompressionAFSCGetMetadataFD(v8, a2, a3, a4) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCGetMetadata",  553,  86,  0,  "retrieving AFSC metadata: %s",  v10,  v11,  v7);
      uint64_t v12 = 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    close(v9);
  }

  return v12;
}

uint64_t ParallelCompressionAFSCFixupMetadata(const char *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v209 = *MEMORY[0x1895F89C0];
  unsigned int v191 = -1;
  u_int32_t v190 = 0;
  unint64_t v189 = 0LL;
  if ((unint64_t)__strlcpy_chk() >= 0x400)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  581,  86,  0,  "Path too long: %s",  v6,  v7,  (char)a1);
LABEL_5:
    int v17 = 0;
    int v18 = 0LL;
LABEL_134:
    __int128 v44 = 0LL;
    unint64_t v74 = 0LL;
    int v76 = 0LL;
    int v34 = -1;
LABEL_135:
    int v36 = -1;
    goto LABEL_136;
  }

  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  582,  86,  0,  "Path too long: %s",  v15,  v16,  (char)a1);
    goto LABEL_5;
  }

  int v18 = (int *)malloc(0x100000uLL);
  if (!v18)
  {
    int v23 = *__error();
    unint64_t v21 = "malloc";
    __int16 v22 = 586;
LABEL_133:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCFixupMetadata",  v22,  86,  v23,  v21,  v13,  v14,  v167);
    int v17 = 0;
    goto LABEL_134;
  }

  if (a2) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = 8LL;
  }
  int v20 = 1 << (v19 + 1);
  if ((v20 & 0x5511) != 0)
  {
    if (a3)
    {
      char v167 = a3;
      unint64_t v21 = "Invalid resource fork size request: %u";
      __int16 v22 = 605;
LABEL_132:
      int v23 = 0;
      goto LABEL_133;
    }

    goto LABEL_16;
  }

  if ((v20 & 0xAA20) == 0)
  {
LABEL_131:
    char v167 = v19;
    unint64_t v21 = "Invalid compression type request %d";
    __int16 v22 = 608;
    goto LABEL_132;
  }

uint64_t ParallelCompressionAFSCCompress(const char *a1, int a2)
{
  unint64_t v61 = 0LL;
  unsigned int v60 = -1;
  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v61, &v60, &v59) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  907,  86,  0,  "looking up AFSC data: %s",  v4,  v5,  (char)a1);
    return 0xFFFFFFFFLL;
  }

  unint64_t v6 = v61;
  if (!v61) {
    return 0LL;
  }
  if (v60 == -1)
  {
    if (!a2) {
      return 0LL;
    }
    int v17 = malloc(0x10000uLL);
    if (v17)
    {
      int v18 = open(a1, 2);
      if ((v18 & 0x80000000) == 0)
      {
        int v19 = v18;
        int v20 = ParallelCompressionAFSCStreamOpen(v18, v6, 0, 0);
        if (v20)
        {
          uint64_t v28 = (uint64_t)v20;
          uint64_t v29 = 0LL;
          unint64_t v30 = 0LL;
          uint64_t v31 = 0x10000LL;
          unint64_t v32 = 0x10000LL;
          while (1)
          {
            if (v6 >= v32) {
              unint64_t v33 = v32;
            }
            else {
              unint64_t v33 = v6;
            }
            if (v32 - 0x10000 >= v6)
            {
              int v51 = 1;
              goto LABEL_43;
            }

            unint64_t v34 = v33 + v29;
            ssize_t v35 = read(v19, v17, v33 + v29);
            if (v35 < 0)
            {
              int v52 = *__error();
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  950,  86,  v52,  "read: %s",  v53,  v54,  (char)a1);
              goto LABEL_42;
            }

            if (v34 != v35)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated read: %s";
              __int16 v42 = 951;
              goto LABEL_41;
            }

            uint64_t v39 = ParallelCompressionAFSCStreamWrite(v28, (uint64_t)v17, v34, v36, v37, v38, v26, v27);
            if (v39 < 0) {
              break;
            }
            v30 += 0x10000LL;
            v32 += 0x10000LL;
            v29 -= 0x10000LL;
            if (v6 >= v30) {
              unint64_t v40 = v30;
            }
            else {
              unint64_t v40 = v6;
            }
            v31 -= 0x10000LL;
            if (v40 + v31 != v39)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated write: %s";
              __int16 v42 = 954;
              goto LABEL_41;
            }
          }

          char v58 = (char)a1;
          uint64_t v41 = "Stream write failed: %s";
          __int16 v42 = 953;
LABEL_41:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  v42,  86,  0,  v41,  v26,  v27,  v58);
LABEL_42:
          int v51 = 0;
LABEL_43:
          if ((ParallelCompressionAFSCStreamClose(v28, v21, v22, v23, v24, v25, v26, v27) & 0x80000000) == 0) {
            goto LABEL_46;
          }
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  956,  86,  0,  "AFSC compression failed: %s",  v55,  v56,  (char)a1);
        }

        else
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  942,  86,  0,  "creating AFSC stream: %s",  v26,  v27,  (char)a1);
        }

        int v51 = 0;
LABEL_46:
        close(v19);
LABEL_47:
        free(v17);
        if (v51) {
          return 0LL;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }

      int v46 = *__error();
      char v57 = (char)a1;
      unint64_t v49 = "open: %s";
      __int16 v50 = 940;
    }

    else
    {
      int v46 = *__error();
      unint64_t v49 = "malloc";
      __int16 v50 = 938;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  v50,  86,  v46,  v49,  v47,  v48,  v57);
    int v51 = 0;
    goto LABEL_47;
  }

  if (a2) {
    return 0LL;
  }
  int v7 = open(a1, 9);
  if (v7 < 0)
  {
    int v43 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  921,  86,  v43,  "open: %s",  v44,  v45,  (char)a1);
    return 0xFFFFFFFFLL;
  }

  int v8 = v7;
  ssize_t v9 = write(v7, 0LL, 0LL);
  if (v9 < 0)
  {
    uint64_t v10 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  922,  86,  *v10,  "write: %s",  v11,  v12,  (char)a1);
  }

  if (close(v8) < 0)
  {
    uint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c",  (uint64_t)"ParallelCompressionAFSCCompress",  923,  86,  *v13,  "close: %s",  v14,  v15,  (char)a1);
  }

  return v9 >> 63;
}

void *AAChunkInputStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads = a5;
  if (!a5) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = malloc(0x90uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x90uLL, 0, 0x90uLL), !v10))
  {
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 277;
LABEL_23:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"AAChunkInputStreamOpen",  v25,  66,  v21,  v24,  v22,  v23,  v27);
    free(v10);
    streamClose(v12);
    return 0LL;
  }

  *(void *)uint64_t v12 = a1;
  *(void *)(v12 + 8) = a2;
  *(void *)(v12 + 16) = a4;
  unint64_t v13 = DefaultNThreads;
  if (DefaultNThreads * a2 > a3) {
    unint64_t v13 = a3 / a2;
  }
  if (v13 <= 1) {
    unint64_t v14 = 1LL;
  }
  else {
    unint64_t v14 = v13;
  }
  *(void *)(v12 + 128) = v14;
  if (!is_mul_ok(v14, 0x30uLL) || 48 * v14 >= 0x2000000001LL)
  {
    *__error() = 12;
    *(void *)(v12 + 136) = 0LL;
    goto LABEL_22;
  }

  uint64_t v15 = (char *)calloc(v14, 0x30uLL);
  *(void *)(v12 + 136) = v15;
  if (!v15)
  {
LABEL_22:
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 290;
    goto LABEL_23;
  }

  uint64_t v16 = *(void *)(v12 + 128);
  if (v16)
  {
    int v17 = v15;
    size_t v18 = *(void *)(v12 + 8);
    int v19 = v15 + 16;
    while (1)
    {
      *(v19 - 2) = -1LL;
      if (v18 >= 0x2000000001LL) {
        break;
      }
      int v20 = malloc(v18);
      *int v19 = v20;
      if (!v20) {
        goto LABEL_26;
      }
      v19 += 6;
      if (!--v16) {
        goto LABEL_18;
      }
    }

    *__error() = 12;
    *((void *)v17 + 2) = 0LL;
LABEL_26:
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 296;
    goto LABEL_23;
  }

uint64_t streamClose(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 16) >> 62)
    {
      int v2 = (FILE **)MEMORY[0x1895F89D0];
      fwrite("ChunkInputStream\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      fprintf(*v2, "%12zu chunk size (B)\n", *(void *)(a1 + 8));
      fprintf(*v2, "%12zu chunks in cache\n", *(void *)(a1 + 128));
      uint64_t v3 = *v2;
      unint64_t v4 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v3, "%12llu bytes read from upstream\n", v4);
      uint64_t v5 = *v2;
      unint64_t v6 = atomic_load((unint64_t *)(a1 + 120));
      fprintf(v5, "%12llu bytes read from clients\n", v6);
      int v7 = *v2;
      unint64_t v8 = atomic_load((unint64_t *)(a1 + 120));
      double v9 = (double)v8 * 100.0;
      unint64_t v10 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v7, "%12.2f percent usage\n", v9 / (double)v10);
    }

    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
    uint64_t v11 = *(void **)(a1 + 136);
    if (v11)
    {
      if (*(void *)(a1 + 128))
      {
        unint64_t v12 = 0LL;
        uint64_t v13 = 16LL;
        do
        {
          free(*(void **)(*(void *)(a1 + 136) + v13));
          ++v12;
          v13 += 48LL;
        }

        while (v12 < *(void *)(a1 + 128));
        uint64_t v11 = *(void **)(a1 + 136);
      }

      free(v11);
    }

    free((void *)a1);
  }

  return 0LL;
}

void streamAbort(AAByteStream *a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 3);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }

  __clrex();
}

uint64_t streamPRead(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = (unsigned int *)(a1 + 24);
  if (!atomic_load((unsigned int *)(a1 + 24)))
  {
    if (!a3) {
      return 0LL;
    }
    unint64_t v7 = a4;
    unint64_t v8 = a4 + a3;
    if (a4 + a3 <= a4) {
      return 0LL;
    }
    uint64_t v9 = a1;
    size_t v6 = 0LL;
    unint64_t v10 = (pthread_mutex_t *)(a1 + 32);
    unint64_t v11 = *(void *)(v9 + 8);
    unint64_t v12 = (unint64_t *)(v9 + 96);
    uint64_t v13 = (unint64_t *)(v9 + 112);
    unint64_t v14 = (unint64_t *)(v9 + 120);
    uint64_t v71 = v9;
    unint64_t v63 = v11;
    unint64_t v64 = a4 + a3;
    u_int32_t v69 = v10;
    while (1)
    {
      __dst = a2;
      unint64_t v15 = v7 / v11;
      unint64_t v16 = v7 / v11 * v11;
      if (v16 <= v7) {
        unint64_t v17 = v7;
      }
      else {
        unint64_t v17 = v7 / v11 * v11;
      }
      unint64_t v67 = v7 / v11 * v11;
      unint64_t v68 = v17;
      unint64_t v18 = v16 + v11;
      if (v8 >= v18) {
        unint64_t v19 = v18;
      }
      else {
        unint64_t v19 = v8;
      }
      if (pthread_mutex_lock(v10) < 0)
      {
        uint64_t v55 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamGetChunk",  51,  66,  *v55,  "pthread_mutex_lock",  v56,  v57,  v62);
LABEL_70:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamReadChunkData",  119,  66,  0,  "get a valid chunk from cache",  v33,  v34,  v62);
        goto LABEL_75;
      }

      unint64_t v65 = v19;
      size_t v66 = v6;
      uint64_t v22 = *(void *)(v9 + 128);
      if (v22)
      {
        uint64_t v23 = *(void *)(v9 + 136);
        uint64_t v24 = v23;
        uint64_t v25 = *(void *)(v9 + 128);
        do
        {
          if (*(void *)v24 == v15)
          {
            do
LABEL_33:
              unint64_t v30 = __ldaxr(v12);
            while (__stlxr(v30 + 1, v12));
            *(void *)(v24 + 8) = v30;
            uint64_t v31 = (unsigned int *)(v24 + 40);
            do
              unsigned int v32 = __ldaxr(v31);
            while (__stlxr(v32 + 1, v31));
            goto LABEL_36;
          }

          v24 += 48LL;
          --v25;
        }

        while (v25);
        uint64_t v24 = *(void *)(v9 + 136);
        uint64_t v26 = *(void *)(v9 + 128);
        do
        {
          if (*(void *)v24 == -1LL)
          {
            uint64_t v27 = -1LL;
LABEL_29:
            if (v27 != v15)
            {
              int v28 = atomic_load((unsigned int *)(v24 + 40));
              if (v28 >= 1)
              {
                do
                {
                  pthread_yield_np();
                  int v29 = atomic_load((unsigned int *)(v24 + 40));
                }

                while (v29 > 0);
              }

              *(void *)uint64_t v24 = v15;
              *(void *)(v24 + 24) = 0LL;
              atomic_store(0, (unsigned int *)(v24 + 32));
              atomic_store(0, (unsigned int *)(v24 + 36));
              atomic_store(0, (unsigned int *)(v24 + 40));
            }

            goto LABEL_33;
          }

          v24 += 48LL;
          --v26;
        }

        while (v26);
        uint64_t v24 = 0LL;
        do
        {
          if (!v24 || *(void *)(v23 + 8) < *(void *)(v24 + 8)) {
            uint64_t v24 = v23;
          }
          v23 += 48LL;
          --v22;
        }

        while (v22);
        if (v24)
        {
          uint64_t v27 = *(void *)v24;
          goto LABEL_29;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamGetChunk",  75,  66,  0,  "Invalid state",  v20,  v21,  v62);
      uint64_t v24 = 0LL;
LABEL_36:
      if (pthread_mutex_unlock(v69) < 0)
      {
        ssize_t v35 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamGetChunk",  107,  66,  *v35,  "pthread_mutex_unlock",  v36,  v37,  v62);
      }

      if (!v24) {
        goto LABEL_70;
      }
      uint64_t v38 = (unsigned int *)(v24 + 32);
LABEL_40:
      unint64_t v40 = *(void *)(v24 + 24);
      if (v40 < v68 - v67)
      {
        uint64_t v53 = "Read out of range";
        __int16 v54 = 148;
LABEL_72:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c",  (uint64_t)"streamReadChunkData",  v54,  66,  0,  v53,  v33,  v34,  v62);
        goto LABEL_73;
      }

      if (v40 >= v65 - v67) {
        size_t v41 = v65 - v68;
      }
      else {
        size_t v41 = v40 - (v68 - v67);
      }
      memcpy(__dst, (const void *)(*(void *)(v24 + 16) + v68 - v67), v41);
      do
        unint64_t v42 = __ldxr(v14);
      while (__stxr(v42 + v41, v14));
      int v43 = (unsigned int *)(v24 + 40);
      uint64_t v9 = v71;
      do
        unsigned int v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      size_t v6 = v66;
      if ((v41 & 0x8000000000000000LL) != 0) {
        goto LABEL_79;
      }
      if (v41)
      {
        size_t v6 = v41 + v66;
        v7 += v41;
        unint64_t v10 = v69;
        a2 = &__dst[v41];
        unint64_t v11 = v63;
        unint64_t v8 = v64;
        if (v7 < v64) {
          continue;
        }
      }

      return v6;
    }

    uint64_t v45 = (unsigned int *)(v24 + 36);
    while (!atomic_load(v4))
    {
      do
      {
        if (__ldaxr(v45))
        {
          __clrex();
          pthread_yield_np();
          goto LABEL_64;
        }
      }

      while (__stlxr(1u, v45));
      ssize_t v48 = AAByteStreamPRead( *(AAByteStream *)v71,  *(void **)(v24 + 16),  *(void *)(v71 + 8),  *(void *)(v71 + 8) * v15);
      if (v48 < 0)
      {
        uint64_t v53 = "Stream read";
        __int16 v54 = 132;
        goto LABEL_72;
      }

      *(void *)(v24 + 24) = v48;
      while (!__ldaxr(v38))
      {
        if (!__stlxr(1u, v38)) {
          goto LABEL_63;
        }
      }

      __clrex();
      do
LABEL_63:
        unint64_t v50 = __ldxr(v13);
      while (__stxr(v50 + v48, v13));
LABEL_64:
      if (atomic_load(v38)) {
        goto LABEL_40;
      }
    }

uint64_t streamRead(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v5 = (unint64_t *)(a1 + 104);
  do
    unint64_t v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return streamPRead(a1, a2, a3, v6);
}

uint64_t streamSeek(uint64_t a1, off_t a2, int a3)
{
  if (!a3)
  {
LABEL_8:
    atomic_store(a2, (unint64_t *)(a1 + 104));
    return a2;
  }

  if (a3 != 1)
  {
    if (a3 != 2) {
      return -1LL;
    }
    a2 = AAByteStreamSeek(*(AAByteStream *)a1, a2, 2);
    if (a2 < 0) {
      return -1LL;
    }
    goto LABEL_8;
  }

  unint64_t v6 = (unint64_t *)(a1 + 104);
  do
  {
    unint64_t v7 = __ldaxr(v6);
    unint64_t v8 = v7 + a2;
  }

  while (__stlxr(v8, v6));
  return v8;
}

uint64_t CC_CKSUM_Init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0LL;
  return 1LL;
}

uint64_t CC_CKSUM_Update(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)a1;
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = a3;
    do
    {
      int v6 = *a2++;
      unsigned int v3 = CKSUMTable[v6 ^ HIBYTE(v3)] ^ (v3 << 8);
      --v5;
    }

    while (v5);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *(_DWORD *)a1 = v3;
  *(void *)(a1 + 8) += v4;
  return 1LL;
}

uint64_t CC_CKSUM_Final(unsigned int *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    do
    {
      unsigned int v2 = CKSUMTable[v3 ^ HIBYTE(v2)] ^ (v2 << 8);
      BOOL v4 = v3 > 0xFF;
      v3 >>= 8;
    }

    while (v4);
  }

  *a1 = ~v2;
  return 1LL;
}

uint64_t (**AAChunkAsyncStreamOpen( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8))(void)
{
  int DefaultNThreads = a5;
  if (a5)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_12:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"AAChunkAsyncStreamOpen",  651,  143,  0,  "invalid chunk size",  a7,  a8,  v28);
    uint64_t v16 = 0LL;
LABEL_16:
    chunkAsyncClose(v16);
    unint64_t v18 = 0LL;
    goto LABEL_17;
  }

  int DefaultNThreads = getDefaultNThreads();
  if (!a2) {
    goto LABEL_12;
  }
LABEL_3:
  uint64_t v13 = malloc(0xF0uLL);
  uint64_t v16 = (uint64_t)v13;
  if (!v13)
  {
    __int16 v24 = 655;
    int v25 = 0;
LABEL_15:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"AAChunkAsyncStreamOpen",  v24,  143,  v25,  "malloc",  v14,  v15,  v28);
    goto LABEL_16;
  }

  memset_s(v13, 0xF0uLL, 0, 0xF0uLL);
  unint64_t v17 = (uint64_t (**)(void))aaAsyncByteStreamAlloc(v16, (uint64_t)chunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
  if (!v17)
  {
    int v25 = *__error();
    __int16 v24 = 657;
    goto LABEL_15;
  }

  unint64_t v18 = v17;
  *(void *)(v16 + 8) = a2;
  *(void *)(v16 + 16) = a4;
  *(void *)uint64_t v16 = a1;
  *(_DWORD *)(v16 + 24) = a4 >> 62;
  if (a3 == -1LL) {
    unint64_t v19 = DefaultNThreads;
  }
  else {
    unint64_t v19 = a3 / a2;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v16 + 32), 0LL))
  {
    uint64_t v22 = "mutex init";
    __int16 v23 = 668;
  }

  else
  {
    if (v19 <= 1) {
      unint64_t v27 = 1LL;
    }
    else {
      unint64_t v27 = v19;
    }
    if ((lockedStateReserveActiveChunks(v16, v27) & 0x80000000) != 0)
    {
      uint64_t v22 = "init active chunks";
      __int16 v23 = 669;
    }

    else
    {
      v18[2] = (uint64_t (*)(void))chunkAsyncGetRange;
      v18[3] = (uint64_t (*)(void))chunkAsyncProcess;
      v18[4] = (uint64_t (*)(void))chunkAsyncCancel;
      v18[5] = (uint64_t (*)(void))chunkAsyncIsCancelled;
      uint64_t v22 = "createThread";
      __int16 v23 = 678;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"AAChunkAsyncStreamOpen",  v23,  143,  0,  v22,  v20,  v21,  v28);
LABEL_17:
  AAAsyncByteStreamClose(v18);
  return 0LL;
}

uint64_t chunkAsyncClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = (unsigned int *)(result + 204);
    while (!__ldaxr(v2))
    {
      if (!__stlxr(1u, v2)) {
        goto LABEL_7;
      }
    }

    __clrex();
LABEL_7:
    BOOL v4 = *(_opaque_pthread_t **)(result + 192);
    if (v4) {
      joinThread(v4);
    }
    unsigned int v5 = atomic_load((unsigned int *)(v1 + 200));
    if (*(_DWORD *)(v1 + 24))
    {
      int v6 = (FILE **)MEMORY[0x1895F89D0];
      fwrite("AAChunkAsyncStream\n", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      fprintf(*v6, "%12zu chunk size\n", *(void *)(v1 + 8));
      fprintf(*v6, "%12zu allocated chunks\n", *(void *)(v1 + 96));
      unint64_t v7 = *v6;
      unint64_t v8 = atomic_load((unint64_t *)(v1 + 208));
      fprintf(v7, "%12llu ranges requested\n", v8);
      uint64_t v9 = *v6;
      unint64_t v10 = atomic_load((unint64_t *)(v1 + 224));
      fprintf(v9, "%12llu chunks processed\n", v10);
      fprintf( *v6,  "%12zu bytes in chunks (%.2f MB)\n",  *(void *)(v1 + 8) * *(void *)(v1 + 96),  (double)(unint64_t)(*(void *)(v1 + 8) * *(void *)(v1 + 96)) * 0.000000953674316);
      unint64_t v11 = *v6;
      unint64_t v12 = atomic_load((unint64_t *)(v1 + 216));
      unint64_t v13 = atomic_load((unint64_t *)(v1 + 216));
      fprintf(v11, "%12llu bytes requested in ranges (%.2f MB)\n", v12, (double)v13 * 0.000000953674316);
      uint64_t v14 = *v6;
      unint64_t v15 = atomic_load((unint64_t *)(v1 + 232));
      unint64_t v16 = atomic_load((unint64_t *)(v1 + 232));
      fprintf(v14, "%12llu bytes processed in chunks (%.2f MB)\n", v15, (double)v16 * 0.000000953674316);
    }

    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
    free(*(void **)(v1 + 168));
    if (*(void *)(v1 + 96))
    {
      unint64_t v17 = 0LL;
      uint64_t v18 = 40LL;
      do
      {
        free(*(void **)(*(void *)(v1 + 104) + v18));
        ++v17;
        v18 += 48LL;
      }

      while (v17 < *(void *)(v1 + 96));
    }

    free(*(void **)(v1 + 104));
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 184));
    memset_s((void *)v1, 0xF0uLL, 0, 0xF0uLL);
    free((void *)v1);
    if (v5) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t lockedStateReserveActiveChunks(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 96) >= a2) {
    return 0LL;
  }
  if (*(_DWORD *)(a1 + 24) >= 3u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "    %zu active chunks\n", a2);
  }
  if (48 * a2 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_15:
    *(void *)(a1 + 104) = 0LL;
    int v14 = *__error();
    __int16 v17 = 147;
    goto LABEL_16;
  }

  unsigned int v5 = *(void **)(a1 + 104);
  int v6 = realloc(v5, 48 * a2);
  if (!v6)
  {
    free(v5);
    goto LABEL_15;
  }

  *(void *)(a1 + 104) = v6;
  unint64_t v7 = *(void *)(a1 + 96);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
LABEL_13:
    uint64_t result = 0LL;
    *(void *)(a1 + 96) = a2;
    return result;
  }

  uint64_t v9 = 48 * v7;
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 104);
    size_t v11 = *(void *)(a1 + 8);
    if (v11 >= 0x2000000001LL) {
      break;
    }
    unint64_t v12 = malloc(v11);
    uint64_t v13 = v10 + v9;
    *(void *)(v10 + v9 + 40) = v12;
    if (!v12) {
      goto LABEL_18;
    }
    *(_DWORD *)uint64_t v13 = 0;
    *(void *)(v13 + 16) = 0LL;
    *(void *)(v13 + 24) = 0LL;
    v9 += 48LL;
    *(void *)(v13 + 8) = -1LL;
    if (!--v8) {
      goto LABEL_13;
    }
  }

  *__error() = 12;
  *(void *)(v10 + v9 + 40) = 0LL;
LABEL_18:
  int v14 = *__error();
  __int16 v17 = 152;
LABEL_16:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"lockedStateReserveActiveChunks",  v17,  143,  v14,  "malloc",  v15,  v16,  v18);
  return 0xFFFFFFFFLL;
}

uint64_t chunkAsyncGetRange(uint64_t a1, void *a2, void *a3)
{
  unint64_t v3 = (unsigned int *)(a1 + 200);
  unint64_t v8 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"chunkAsyncGetRange",  519,  143,  0,  "lock",  v9,  v10,  v25);
    return 0xFFFFFFFFLL;
  }

  uint64_t v13 = *(void *)(a1 + 96);
  if (v13)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = *(int **)(a1 + 104);
    while (1)
    {
      int v16 = *v15;
      v15 += 12;
      if (v16 == 1) {
        break;
      }
      if (v13 == ++v14) {
        goto LABEL_13;
      }
    }
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  if (v14 != v13)
  {
    uint64_t v17 = *(void *)(a1 + 104);
    uint64_t v18 = v17 + 48 * v14;
    *(_DWORD *)uint64_t v18 = 2;
    *a3 = *(void *)(v18 + 16);
    uint64_t v21 = v18 + 16;
    uint64_t v20 = *(void *)(v18 + 16);
    uint64_t v19 = *(void *)(v21 + 8);
    *a2 = v19 - v20;
    if (*(_DWORD *)(a1 + 24) >= 3u) {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "<-- chunk %10llx %10llx -- %8zu\n",  v20,  v19,  *(void *)(v17 + 48 * v14 + 8));
    }
    goto LABEL_19;
  }

LABEL_13:
  if (!*(void *)(a1 + 160) && *(_DWORD *)(a1 + 128))
  {
    *a2 = 0LL;
    *a3 = 0LL;
LABEL_19:
    if (*(_DWORD *)(a1 + 24) < 3u || *a2)
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v11 = 1LL;
      fwrite("<-- EOF\n", 8uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }

    goto LABEL_22;
  }

  uint64_t v11 = 0LL;
LABEL_22:
  if (!pthread_mutex_unlock(v8)) {
    return v11;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"chunkAsyncGetRange",  546,  143,  0,  "unlock",  v22,  v23,  v25);
  while (!__ldaxr(v3))
  {
    if (!__stlxr(1u, v3))
    {
      AAAsyncByteStreamCancel(*(void **)a1);
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c",  (uint64_t)"ThreadPoolCreate",  v20,  90,  v16,  v19,  v17,  v18,  v26);
  ThreadPoolDestroy((uint64_t)v7);
  return 0LL;
}

uint64_t chunkAsyncProcess(uint64_t a1, const void *a2, size_t a3, unint64_t a4)
{
  BOOL v4 = (unsigned int *)(a1 + 200);
  uint64_t v10 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    uint64_t v13 = "lock";
    __int16 v14 = 556;
LABEL_4:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"chunkAsyncProcess",  v14,  143,  0,  v13,  v11,  v12,  v25);
    return 0xFFFFFFFFLL;
  }

  if ((a4 & 0x8000000000000000LL) != 0)
  {
    uint64_t v13 = "invalid range";
    __int16 v14 = 559;
    goto LABEL_4;
  }

  v26[0] = a4;
  v26[1] = a4 + a3;
  if (__CFADD__(a4, a3))
  {
    uint64_t v13 = "invalid range";
    __int16 v14 = 561;
    goto LABEL_4;
  }

  int v16 = (unint64_t *)(a1 + 232);
  do
    unint64_t v17 = __ldxr(v16);
  while (__stxr(v17 + a3, v16));
  uint64_t v18 = (unint64_t *)(a1 + 224);
  do
    unint64_t v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  uint64_t v20 = *(void *)(a1 + 96);
  if (v20)
  {
    uint64_t v21 = *(void *)(a1 + 104);
    while (*(_DWORD *)v21 != 2 || rangeCmp((unint64_t *)(v21 + 16), v26))
    {
      v21 += 48LL;
      if (!--v20) {
        goto LABEL_20;
      }
    }

    memcpy(*(void **)(v21 + 40), a2, a3);
    *(_DWORD *)uint64_t v21 = 3;
    if (*(_DWORD *)(a1 + 24) >= 3u) {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "--> chunk %10llx %10llx -- %8zu\n",  *(void *)(v21 + 16),  *(void *)(v21 + 24),  *(void *)(v21 + 8));
    }
  }

void *chunkAsyncCancel(void *result)
{
  uint64_t v1 = (unsigned int *)(result + 25);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return AAAsyncByteStreamCancel((void *)*result);
    }
  }

  __clrex();
  return result;
}

uint64_t chunkAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 200));
}

void **streamProc(void **a1)
{
  unint64_t v3 = (unint64_t *)(a1 + 27);
  BOOL v4 = (unint64_t *)(a1 + 26);
  int v169 = a1 + 17;
  uint64_t v170 = (uint64_t *)(a1 + 19);
  unsigned int v176 = (pthread_mutex_t *)(a1 + 4);
  while (1)
  {
    if (*((_DWORD *)a1 + 32))
    {
LABEL_4:
      int v175 = 0;
      goto LABEL_5;
    }

    unint64_t v49 = (void)a1[1] * (void)a1[12];
    unint64_t v50 = a1[20];
    if (v50)
    {
      unint64_t v51 = 0LL;
      int v52 = a1[21] + 1;
      do
      {
        unint64_t v51 = *v52 + v51 - *(v52 - 1);
        v52 += 2;
        unint64_t v50 = (void *)((char *)v50 - 1);
      }

      while (v50);
      uint64_t v174 = (void *)(v49 + (v49 >> 2));
    }

    else
    {
      unint64_t v51 = 0LL;
      uint64_t v174 = (void *)(v49 + (v49 >> 2));
    }

    int v175 = 0;
    while (1)
    {
      int Range = AAAsyncByteStreamGetRange(*a1, &v177, (uint64_t *)&v178);
      if (Range < 0)
      {
        __int128 v154 = "GetRange";
        __int16 v155 = 220;
LABEL_273:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateFetchRanges",  v155,  143,  0,  v154,  v54,  v55,  v168);
        goto LABEL_274;
      }

      if (!Range) {
        goto LABEL_126;
      }
      if (!v177) {
        break;
      }
      unint64_t v56 = v178;
      if ((v178 & 0x8000000000000000LL) != 0)
      {
        __int128 v154 = "invalid range";
        __int16 v155 = 228;
        goto LABEL_273;
      }

      uint64_t v57 = (void *)(v178 + v177);
      *(void *)&__int128 v179 = v178;
      *((void *)&v179 + 1) = v178 + v177;
      if (__CFADD__(v178, v177))
      {
        __int128 v154 = "invalid range overflow";
        __int16 v155 = 230;
        goto LABEL_273;
      }

      char v58 = a1[20];
      if (v58)
      {
        unsigned int v59 = a1[21];
        unsigned int v60 = 0LL;
        unint64_t v61 = v59 + 2;
        do
        {
          int v62 = rangeCmp(v61, (unint64_t *)&v179);
          v61 += 2;
          unsigned int v60 = (void *)((char *)v60 + 1);
        }

        while (v62);
        if (v60 < v58) {
          goto LABEL_119;
        }
      }

LABEL_99:
      uint64_t v63 = *v170;
      if ((unint64_t)v58 >= *v170)
      {
        uint64_t v64 = 2 * v63;
        BOOL v33 = v63 == 0;
        uint64_t v65 = 32LL;
        if (!v33) {
          uint64_t v65 = v64;
        }
        *uint64_t v170 = v65;
        if ((unint64_t)(16 * v65) >= 0x2000000001LL)
        {
          *__error() = 12;
        }

        else
        {
          size_t v66 = a1[21];
          unint64_t v67 = realloc(v66, 16 * v65);
          if (v67)
          {
            a1[21] = v67;
            goto LABEL_105;
          }

          free(v66);
        }

        a1[21] = 0LL;
        __int128 v165 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateFetchRanges",  248,  143,  *v165,  "malloc",  v166,  v167,  v168);
        *uint64_t v170 = 0LL;
        v170[1] = 0LL;
LABEL_274:
        uint64_t v156 = "fetching ranges";
        __int16 v157 = 493;
        goto LABEL_283;
      }

  int v86 = getRealTime();
  uint64_t v87 = (unsigned __int16 *)malloc(0x10000uLL);
  if (!v87)
  {
    unint64_t v120 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"stateScanArchive",  1074,  120,  *v120,  "malloc",  v121,  v122,  v247);
    uint64_t v90 = 0LL;
    goto LABEL_142;
  }

  uint64_t v90 = AAHeaderCreate();
  if (!v90)
  {
    uint64_t v118 = "AAHeaderCreate";
    uint64_t v119 = 1076;
    goto LABEL_141;
  }

  int v91 = *(void **)v15;
  unint64_t v92 = (void *)(*(void *)v15 + 32LL);
  if (!*v92)
  {
LABEL_138:
    uint64_t v118 = "read";
    uint64_t v119 = 1083;
    goto LABEL_141;
  }

  uint64_t v93 = 0LL;
  while (1)
  {
    unint64_t v94 = 0LL;
    unint64_t v95 = v87;
    unint64_t v96 = v93;
    unint64_t v97 = 6LL;
    do
    {
      unsigned int v98 = ((uint64_t (*)(void, unsigned __int16 *, uint64_t, uint64_t))*v92)(*v91, v95, v97, v96);
      if (v98 < 0) {
        goto LABEL_138;
      }
      if (!v98) {
        break;
      }
      unint64_t v95 = (unsigned __int16 *)((char *)v95 + v98);
      v94 += v98;
      v96 += v98;
      v97 -= v98;
    }

    while (v97);
    if (!v94) {
      break;
    }
    if ((v94 & 0x8000000000000000LL) != 0) {
      goto LABEL_138;
    }
    if (v94 <= 5)
    {
      uint64_t v118 = "truncated archive";
      uint64_t v119 = 1084;
      goto LABEL_141;
    }

    if (*(_DWORD *)v87 != 825246017 && *(_DWORD *)v87 != 826360153)
    {
      uint64_t v118 = "invalid header magic";
      uint64_t v119 = 1085;
      goto LABEL_141;
    }

    unint64_t v99 = *(void *)v15;
    if (!*(void *)(*(void *)v15 + 32LL)) {
      goto LABEL_191;
    }
    uint64_t v100 = v87[2];
    if (v87[2])
    {
      size_t v101 = 0LL;
      unint64_t v102 = v87;
      __int128 v103 = v93;
      __int128 v104 = v87[2];
      do
      {
        unint64_t v105 = (*(uint64_t (**)(void, unsigned __int16 *, uint64_t, uint64_t))(v99 + 32))( *(void *)v99,  v102,  v104,  v103);
        if (v105 < 0) {
          goto LABEL_191;
        }
        if (!v105) {
          break;
        }
        unint64_t v102 = (unsigned __int16 *)((char *)v102 + v105);
        v101 += v105;
        v103 += v105;
        v104 -= v105;
      }

      while (v104);
      if (v101 < 0)
      {
LABEL_191:
        uint64_t v118 = "read";
        uint64_t v119 = 1091;
        goto LABEL_141;
      }
    }

    else
    {
      size_t v101 = 0LL;
    }

    if (v101 < v100)
    {
      uint64_t v118 = "truncated archive";
      uint64_t v119 = 1092;
      goto LABEL_141;
    }

    if ((aaHeaderInitWithEncodedData((uint64_t)v90, v87, v100) & 0x80000000) != 0)
    {
      uint64_t v118 = "invalid archive";
      uint64_t v119 = 1093;
      goto LABEL_141;
    }

    PayloadSize = AAHeaderGetPayloadSize(v90);
    if (__CFADD__(v100, PayloadSize))
    {
      uint64_t v118 = "invalid payload size";
      uint64_t v119 = 1096;
      goto LABEL_141;
    }

    __int128 v107 = PayloadSize;
    *(void *)&v252.st_dev = 0LL;
    if ((stateAppendEntry(v15, v90, v93, v100 + PayloadSize, (char **)&v252) & 0x80000000) != 0)
    {
      uint64_t v118 = "adding entry";
      uint64_t v119 = 1100;
      goto LABEL_141;
    }

    if (*(void *)&v252.st_dev && !*(_DWORD *)(v15 + 1072) && *(_DWORD *)(*(void *)&v252.st_dev + 60LL) == 68)
    {
      if (v107 == -1LL)
      {
        uint64_t v118 = "invalid payload size";
        uint64_t v119 = 1108;
LABEL_141:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"stateScanArchive",  v119,  120,  0,  v118,  v88,  v89,  v247);
LABEL_142:
        free(v87);
        AAHeaderDestroy(v90);
        uint64_t v125 = "scanning archive";
        int v126 = 1364;
        goto LABEL_277;
      }

      EntryData = (char *)stateGetEntryData(v15, *(uint64_t *)&v252.st_dev, v108, v109, v110, v111, v88, v89);
      memcpy(EntryData, v87, v100);
      if (v107)
      {
        __int16 v249 = *(void *)v15;
        if (!*(void *)(*(void *)v15 + 32LL)) {
          goto LABEL_283;
        }
        unint64_t v113 = 0LL;
        int v114 = v93 + v100;
        __int16 v115 = &EntryData[v100];
        uint64_t v116 = v107;
        do
        {
          uint64_t v117 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(v249 + 32))( *(void *)v249,  v115,  v116,  v114);
          if (v117 < 0) {
            goto LABEL_283;
          }
          if (!v117) {
            break;
          }
          v115 += v117;
          v113 += v117;
          v114 += v117;
          v116 -= v117;
        }

        while (v116);
        if (v113 < 0 || v113 != v107)
        {
LABEL_283:
          uint64_t v118 = "loading DIR entry";
          uint64_t v119 = 1115;
          goto LABEL_141;
        }
      }
    }

    v93 += v100 + v107;
    int v91 = *(void **)v15;
    unint64_t v92 = (void *)(*(void *)v15 + 32LL);
    if (!*v92) {
      goto LABEL_138;
    }
  }

  *(_DWORD *)(v15 + 1072) = 1;
  free(v87);
  AAHeaderDestroy(v90);
  __int128 v201 = getRealTime();
  if (*(_DWORD *)(v15 + 1080)) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%12.2f time (s)\n", v201 - v86);
  }
LABEL_69:
  memset(&v252, 255, 24);
  size_t v66 = *(void *)(v15 + 1136);
  if (!v66) {
    goto LABEL_86;
  }
  unint64_t v67 = 0LL;
  unint64_t v68 = *(void *)(v15 + 1144);
  do
  {
    u_int32_t v69 = 0LL;
    unint64_t v70 = (unint64_t *)(v68 + 72 * v67);
    unint64_t v71 = v70 + 4;
    int v72 = v70 + 3;
    int v73 = v70 + 2;
    do
    {
      unint64_t v74 = v73;
      if ((_DWORD)v69)
      {
        if ((_DWORD)v69 == 2)
        {
          unint64_t v74 = v71;
        }

        else
        {
          unint64_t v74 = v72;
          if ((_DWORD)v69 != 1) {
            goto LABEL_84;
          }
        }
      }

      unint64_t v75 = *v74;
      if (v75 != -1LL)
      {
        int v76 = *((void *)&v252.st_dev + v69);
        if (v75 <= v76 && v76 != -1LL) {
          unint64_t v75 = *((void *)&v252.st_dev + v69);
        }
        *((void *)&v252.st_dev + v69) = v75;
      }

        uint64_t v125 = v77;
        if ((*(_BYTE *)(v42 + 2128) & 8) != 0 && (*(_BYTE *)(v9 + 1030) & 2) != 0) {
          int v78 = *(_DWORD *)(v42 + 2132);
        }
        else {
          int v78 = -1;
        }
        uint64_t v119 = v78;
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, (const char *)v42) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  885,  72,  0,  "invalid path: %s",  v93,  v94,  v42);
          goto LABEL_84;
        }

        if (*(_DWORD *)(v9 + 1056)) {
          removeFile(v130);
        }
        __strlcpy_chk();
        unint64_t v95 = strrchr(__s, 47);
        if (!v95)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  890,  72,  0,  "invalid path: %s",  v96,  v97,  (char)v130);
          uint64_t v65 = 1;
          __int16 v14 = 1;
          unint64_t v16 = (pthread_mutex_t *)(v8 + 56);
          goto LABEL_86;
        }

        *unint64_t v95 = 0;
        unsigned int v98 = v95 + 1;
        if (v122 < 0) {
          goto LABEL_154;
        }
        if (!strcmp(__s, __s2))
        {
          unint64_t v99 = v122;
        }

        else
        {
          close(v122);
LABEL_154:
          __strlcpy_chk();
          unint64_t v99 = open(__s2, 0);
          if (v99 < 0)
          {
            unint64_t v122 = v99;
            uint64_t v100 = *(void **)(v42 + 2288);
            goto LABEL_170;
          }
        }

        unint64_t v122 = v99;
        uint64_t v100 = aaArchiveFileOutputStreamOpenAt( v99,  v98,  *(void *)(v42 + 2192),  v125,  v76,  v119,  *(void *)(v9 + 1048));
        *(void *)(v42 + 2288) = v100;
LABEL_170:
        unint64_t v16 = (pthread_mutex_t *)(v8 + 56);
        if (!v100)
        {
          BOOL v108 = aaArchiveFileOutputStreamOpenAt( -1,  v130,  *(void *)(v42 + 2192),  v125,  v76,  v119,  *(void *)(v9 + 1048));
          *(void *)(v42 + 2288) = v108;
          if (!v108)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractThreadProc",  904,  72,  0,  "opening output file: %s",  v109,  v110,  (char)v130);
LABEL_84:
            uint64_t v65 = 1;
LABEL_85:
            __int16 v14 = 1;
            goto LABEL_86;
          }
        }

  *((void *)v35 + 285) = -1LL;
  *((void *)v35 + 284) = -1LL;
  v59.uint64_t ikey = 5784649;
  unsigned int v60 = AAHeaderGetKeyIndex(header, v59);
  if ((v60 & 0x80000000) == 0)
  {
    int FieldUInt = AAHeaderGetFieldUInt(header, v60, &v98);
    int v62 = FieldUInt <= 1 ? 1 : FieldUInt;
    if (v62 >= 1) {
      *((void *)v35 + 284) = v98;
    }
  }

  v63.uint64_t ikey = 5915721;
  uint64_t v64 = AAHeaderGetKeyIndex(header, v63);
  if ((v64 & 0x80000000) == 0)
  {
    unint64_t v70 = AAHeaderGetFieldUInt(header, v64, &v98);
    unint64_t v71 = v70 <= 1 ? 1 : v70;
    if (v71 >= 1) {
      *((void *)v35 + 285) = v98;
    }
  }

  if (value == 70)
  {
    *((void *)v35 + 274) = -1LL;
    v72.uint64_t ikey = 5521732;
    int v73 = AAHeaderGetKeyIndex(header, v72);
    unint64_t v74 = 0LL;
    unint64_t v75 = 0;
    int v76 = v9 & 0x10;
    unint64_t v77 = 0;
    do
    {
      if (v74 == 2 && v76) {
        break;
      }
      v78.uint64_t ikey = 4410451;
      if (v74 != 2) {
        v78.uint64_t ikey = 4144959;
      }
      if ((_DWORD)v74 == 1) {
        v78.uint64_t ikey = 4410435;
      }
      if ((_DWORD)v74) {
        unint64_t v79 = v78;
      }
      else {
        v79.uint64_t ikey = 4410440;
      }
      unint64_t v97 = -1LL;
      unint64_t v80 = AAHeaderGetKeyIndex(header, v79);
      if ((v80 & 0x80000000) == 0 && AAHeaderGetFieldUInt(header, v80, &v97) <= 1)
      {
        unint64_t v81 = v97;
        *(void *)&v35[8 * v74 + 2312] = v97;
        unint64_t v96 = 0LL;
        if (*((void *)v35 + 274) == -1LL) {
          int v82 = 0LL;
        }
        else {
          int v82 = (uint64_t)v35;
        }
        int updated = clusterEntryUpdateDAT(a1, v74, v81, v82, &v96);
        if (updated < 0)
        {
          uint64_t v10 = "cluster entry query";
          unint64_t v11 = 1371;
          goto LABEL_4;
        }

        if (updated) {
          unint64_t v77 = 1;
        }
        if (v96) {
          __int128 v84 = updated == 0;
        }
        else {
          __int128 v84 = 0;
        }
        if (v84) {
          unint64_t v75 = 1;
        }
      }

      ++v74;
    }

    while (v74 != 3);
    if (!v77 && v75 && *((void *)v35 + 274) != -1LL) {
      *((void *)v35 + 274) = -1LL;
    }
  }

  else if ((value & 0xFFFFFFFFFFFFFFFBLL) == 0x48)
  {
    unint64_t v97 = 0LL;
    v85.uint64_t ikey = 4935244;
    int v86 = AAHeaderGetKeyIndex(header, v85);
    if ((v86 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v86, 0x400uLL, v35 + 1024, &v97) > 1)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamWriteHeader",  1389,  72,  0,  "YAA link entry has no LNK field: %s",  a7,  a8,  (char)__s);
      goto LABEL_5;
    }
  }

  else if ((value & 0xFFFFFFFFFFFFFFFELL) == 0x42)
  {
    v87.uint64_t ikey = 5653828;
    size_t v88 = AAHeaderGetKeyIndex(header, v87);
    if ((v88 & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, v88, (uint64_t *)v35 + 273) >= 2)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c",  (uint64_t)"extractStreamWriteHeader",  1394,  72,  0,  "YAA device entry has no DEV field: %s",  a7,  a8,  (char)__s);
      goto LABEL_5;
    }
  }

  *(_DWORD *)(a1 + 1648) = 0;
  __int16 v89 = *(unsigned int *)(a1 + 1616);
  if ((_DWORD)v89 && (uint64_t v90 = *(void *)(a1 + 1624), !*(void *)(v90 + 8)))
  {
    unint64_t v92 = (uint64_t *)(v90 + 32);
    uint64_t v93 = 1LL;
    do
    {
      int v91 = v93;
      if (v89 == v93) {
        break;
      }
      unint64_t v94 = *v92;
      v92 += 3;
      ++v93;
    }

    while (!v94);
    *(_DWORD *)(a1 + 1648) = v91;
  }

  else
  {
    int v91 = 0;
  }

  if (v91 >= v89 && (extractStreamEntryEnd(a1, v65, v66, v67, v68, v69, a7, a8) & 0x80000000) != 0)
  {
    uint64_t v10 = "end entry";
    unint64_t v11 = 1404;
    goto LABEL_4;
  }

  return 0LL;
}

      if (++v54 != v112) {
        continue;
      }
      break;
    }

LABEL_263:
          stateSortRanges((uint64_t)a1);
          int v48 = 0;
LABEL_79:
          int v47 = v171;
          goto LABEL_130;
        }

        break;
      }

LABEL_194:
        if (++v96 == v97) {
          goto LABEL_195;
        }
        continue;
      }
    }

LABEL_196:
    if (v86)
    {
      uint64_t v109 = 0LL;
      int v82 = 0;
      unint64_t v110 = 0LL;
      while (1)
      {
        uint64_t v111 = a1[13];
        if (!v111[v109 + 4] && LODWORD(v111[v109]))
        {
          int v112 = &v111[v109];
          unint64_t v113 = v111[v109 + 1];
          if (v113 >= (unint64_t)a1[14])
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateUpdateChunks",  410,  143,  0,  "invalid chunk index",  v80,  v81,  v168);
            goto LABEL_255;
          }

          a1[15][v113] = -1LL;
          *(_DWORD *)int v112 = 0;
          v112[2] = 0LL;
          v112[3] = 0LL;
          v112[1] = -1LL;
          int v86 = a1[12];
          int v82 = 1;
        }

        ++v110;
        v109 += 6LL;
        if (v110 >= (unint64_t)v86)
        {
          if (v86)
          {
            int v114 = a1[13] + 4;
            do
            {
              *int v114 = 0LL;
              v114 += 6;
              int v86 = (void *)((char *)v86 - 1);
            }

            while (v86);
          }

          goto LABEL_209;
        }
      }
    }

    int v82 = 0;
LABEL_209:
    uint64_t v117 = a1[20];
    if (!v117)
    {
      int v143 = 0;
      goto LABEL_256;
    }

    uint64_t v118 = 0LL;
    int v172 = v47;
    while (1)
    {
      uint64_t v119 = &a1[21][2 * v118];
      unint64_t v120 = (unint64_t)a1[1];
      unint64_t v121 = *v119 / v120;
      unint64_t v122 = (v120 + v119[1] - 1) / v120;
      if (!v118 && v121 < v122)
      {
        int v123 = a1[15];
        unint64_t v124 = v121;
        do
        {
          uint64_t v125 = v123[v124];
          if (v125 != -1) {
            a1[13][6 * v125 + 4] = 1LL;
          }
          ++v124;
        }

        while (v124 != v122);
      }

      if (v121 < v122) {
        break;
      }
LABEL_247:
      int v47 = v172;
      int v143 = 0;
    }

    while (2)
    {
      int v126 = a1[15];
      if (v126[v121] != -1LL) {
        goto LABEL_245;
      }
      uint64_t v127 = a1[12];
      if (v127)
      {
        uint64_t v128 = 0LL;
        unsigned int v129 = (int *)a1[13];
        while (1)
        {
          int v130 = *v129;
          v129 += 12;
          if (!v130) {
            break;
          }
          uint64_t v128 = (void *)((char *)v128 + 1);
          if (v127 == v128) {
            goto LABEL_226;
          }
        }
      }

      else
      {
        uint64_t v128 = 0LL;
      }

      if (v128 != v127) {
        goto LABEL_234;
      }
LABEL_226:
      if (!v118)
      {
        uint64_t v128 = 0LL;
        if (v127)
        {
          uint64_t v131 = a1[13] + 4;
          while (1)
          {
            uint64_t v132 = *v131;
            v131 += 6;
            if (!v132) {
              break;
            }
            uint64_t v128 = (void *)((char *)v128 + 1);
            if (v127 == v128) {
              goto LABEL_249;
            }
          }
        }

        if (v128 == v127)
        {
LABEL_249:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateUpdateChunks",  451,  143,  0,  "no available chunk",  v80,  v81,  v168);
          int v143 = 1;
          goto LABEL_250;
        }

        uint64_t v133 = (uint64_t)&a1[13][6 * (void)v128];
        uint64_t v134 = *(void *)(v133 + 8);
        v126[v134] = -1LL;
        *(_DWORD *)uint64_t v133 = 0;
        *(void *)(v133 + 16) = 0LL;
        *(void *)(v133 + 24) = 0LL;
        *(void *)(v133 + 8) = -1LL;
        fprintf((FILE *)*MEMORY[0x1895F89D0], "BYE chunk %8zu evicted\n", v134);
        int v126 = a1[15];
LABEL_234:
        uint64_t v135 = (uint64_t)&a1[13][6 * (void)v128];
        *(void *)(v135 + 8) = v121;
        v126[v121] = v128;
        *(_DWORD *)uint64_t v135 = 1;
        *(void *)(v135 + 32) = v118 == 0;
        uint64_t v136 = a1[1];
        unint64_t v137 = (void)v136 * *(void *)(v135 + 8);
        *(void *)(v135 + 16) = v137;
        int v138 = (unint64_t *)(v135 + 16);
        uint64_t v139 = (char *)v136 + v137;
        *(void *)(v135 + 24) = (char *)v136 + v137;
        uint64_t v140 = (char **)(v135 + 24);
        if (!v136) {
          goto LABEL_241;
        }
        __int16 v142 = (char *)a1[17];
        unsigned int v141 = (char *)a1[18];
        if (v142 == v141) {
          goto LABEL_241;
        }
        *int v138 = v137;
        if (v139 >= v141) {
          uint64_t v139 = v141;
        }
        *uint64_t v140 = v139;
        if (v137 >= (unint64_t)v139)
        {
LABEL_241:
          *int v138 = 0LL;
          v138[1] = 0LL;
        }

        if (*((_DWORD *)a1 + 6) >= 3u) {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "SET range %10llx %10llx -- %8zu\n", *v119, v119[1], v121);
        }
        int v82 = 1;
LABEL_245:
        if (++v121 == v122)
        {
          uint64_t v117 = a1[20];
          goto LABEL_247;
        }

        continue;
      }

      break;
    }

    int v143 = 0;
LABEL_250:
    int v47 = v172;
LABEL_256:
    if (pthread_mutex_unlock(v176))
    {
      int v160 = "unlock";
      __int16 v161 = 478;
      goto LABEL_281;
    }

    if (v143) {
      goto LABEL_282;
    }
LABEL_258:
    if (!(v47 | v175 | v82)) {
      usleep(0x9C40u);
    }
  }

  int v160 = "lock";
  __int16 v161 = 359;
LABEL_281:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"stateUpdateChunks",  v161,  143,  0,  v160,  v5,  v6,  v168);
LABEL_282:
  uint64_t v156 = "updating chunks";
  __int16 v157 = 501;
LABEL_283:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c",  (uint64_t)"streamProc",  v157,  143,  0,  v156,  v5,  v6,  v168);
  int v162 = (unsigned int *)(a1 + 25);
  while (!__ldaxr(v162))
  {
    if (!__stlxr(1u, v162))
    {
      AAAsyncByteStreamCancel(*a1);
      return a1;
    }
  }

  __clrex();
  return a1;
}

uint64_t rangeCmp(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (v3 == *a1 && v5 != v4) {
    return 1LL;
  }
  if (v3 >= v5) {
    int v7 = v5 < v3;
  }
  else {
    int v7 = -1;
  }
  if (v4 >= v2) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 1;
  }
  if ((v5 != v4 || v3 == v2) && v2 >= v4) {
    return v8;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void stateSortRanges(uint64_t a1)
{
  size_t v1 = *(void *)(a1 + 160);
  if (v1)
  {
    qsort(*(void **)(a1 + 168), v1, 0x10uLL, (int (__cdecl *)(const void *, const void *))rangeCmp);
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3)
    {
      uint64_t v4 = v3 - 1;
      unint64_t v5 = (void *)(*(void *)(a1 + 168) + 16 * v3 - 8);
      do
      {
        if (*(v5 - 1) != *v5) {
          break;
        }
        v5 -= 2;
        *(void *)(a1 + 160) = v4--;
      }

      while (v4 != -1);
    }
  }

unint64_t AAAsyncByteStreamProcessAllRanges(void *a1, void *a2, int a3, size_t __count)
{
  if (!(_DWORD)__count) {
    LODWORD(__count) = getDefaultNThreads();
  }
  unsigned int v47 = 0;
  unint64_t v46 = 0LL;
  uint64_t v6 = __count;
  int v7 = (void ***)calloc(__count, 8uLL);
  unsigned int v8 = v7;
  if (!v7)
  {
    unint64_t v17 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"AAAsyncByteStreamProcessAllRanges",  79,  116,  *v17,  "malloc",  v18,  v19,  v44);
    unint64_t v15 = 0LL;
    goto LABEL_15;
  }

  if ((_DWORD)v6)
  {
    uint64_t v9 = v6;
    uint64_t v10 = v7;
    do
    {
      unint64_t v11 = (void **)malloc(0x48uLL);
      uint64_t v12 = v11;
      if (!v11)
      {
        BOOL v20 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"AAAsyncByteStreamProcessAllRanges",  83,  116,  *v20,  "malloc",  v21,  v22,  v44);
        unint64_t v15 = 0LL;
        goto LABEL_16;
      }

      memset_s(v11, 0x48uLL, 0, 0x48uLL);
      uint64_t *v12 = a2;
      v12[1] = a1;
      unsigned int v12[2] = &v47;
      v12[3] = &v46;
      *v10++ = v12;
      --v9;
    }

    while (v9);
  }

  unint64_t v15 = ThreadPoolCreate(v6, (uint64_t)v8, (uint64_t)workerProc_2);
  if (!v15)
  {
    uint64_t v23 = "ThreadPoolCreate";
    __int16 v24 = 93;
    goto LABEL_14;
  }

  if (atomic_load(&v47))
  {
LABEL_10:
    LODWORD(v12) = 1;
    goto LABEL_16;
  }

  LODWORD(v12) = 1;
  while (1)
  {
    uint64_t v44 = 0LL;
    unint64_t v45 = 0LL;
    int Range = AAAsyncByteStreamGetRange(a1, &v45, &v44);
    if (Range < 0)
    {
      uint64_t v23 = "AAAsyncByteStreamGetRange";
      __int16 v24 = 101;
      goto LABEL_14;
    }

    if (!Range)
    {
      usleep(0x4E20u);
      goto LABEL_38;
    }

    if (!v45) {
      goto LABEL_10;
    }
    uint64_t Worker = ThreadPoolGetWorker((uint64_t)v15, v32, v33, v34, v35, v36, v13, v14);
    if (!Worker) {
      break;
    }
    uint64_t v42 = v44;
    *(void *)(Worker + 32) = v45;
    *(void *)(Worker + 40) = v42;
    if ((ThreadPoolRunWorker((uint64_t)v15, Worker, v38, v39, v40, v41, v13, v14) & 0x80000000) != 0)
    {
      uint64_t v23 = "ThreadPoolRunWorker";
      __int16 v24 = 110;
      goto LABEL_14;
    }

uint64_t workerProc_2(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 48) < v2)
  {
    *(void *)(a1 + 48) = v2;
    if (v2 >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_18:
      *(void *)(a1 + 64) = 0LL;
      unint64_t v15 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"workerProc",  36,  116,  *v15,  "malloc",  v16,  v17,  v20);
      *(void *)(a1 + 48) = 0LL;
      goto LABEL_19;
    }

    uint64_t v3 = *(void **)(a1 + 64);
    uint64_t v4 = realloc(v3, v2);
    if (!v4)
    {
      free(v3);
      goto LABEL_18;
    }

    *(void *)(a1 + 64) = v4;
    size_t v2 = *(void *)(a1 + 32);
  }

  *(void *)(a1 + 56) = 0LL;
  unint64_t v5 = 0LL;
  if (v2)
  {
    while (1)
    {
      ssize_t v6 = AAByteStreamPRead( *(AAByteStream *)a1,  (void *)(*(void *)(a1 + 64) + v5),  v2 - v5,  *(void *)(a1 + 40) + v5);
      if (v6 < 0) {
        break;
      }
      unint64_t v5 = *(void *)(a1 + 56);
      if (v6)
      {
        v5 += v6;
        *(void *)(a1 + 56) = v5;
        size_t v2 = *(void *)(a1 + 32);
        if (v5 < v2) {
          continue;
        }
      }

      goto LABEL_10;
    }

    uint64_t v13 = "istream read";
    __int16 v14 = 43;
  }

  else
  {
LABEL_10:
    if ((AAAsyncByteStreamProcess(*(void *)(a1 + 8), *(void *)(a1 + 64), v5, *(void *)(a1 + 40)) & 0x80000000) == 0)
    {
      uint64_t v9 = *(unint64_t **)(a1 + 24);
      uint64_t v10 = *(void *)(a1 + 56);
      do
        unint64_t v11 = __ldxr(v9);
      while (__stxr(v11 + v10, v9));
      return 0LL;
    }

    uint64_t v13 = "stream process";
    __int16 v14 = 50;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c",  (uint64_t)"workerProc",  v14,  116,  0,  v13,  v7,  v8,  v20);
LABEL_19:
  *(void *)(a1 + 56) = 0LL;
  uint64_t v18 = *(unsigned int **)(a1 + 16);
  while (!__ldaxr(v18))
  {
    if (!__stlxr(1u, v18)) {
      return 0xFFFFFFFFLL;
    }
  }

  __clrex();
  return 0xFFFFFFFFLL;
}

void *reallocToFit(void *a1, size_t __size)
{
  if (__size >= 0x1000)
  {
    uint64_t v4 = malloc(__size);
    if (v4)
    {
      unint64_t v5 = v4;
      memcpy(v4, a1, __size);
      free(a1);
      return v5;
    }
  }

  return a1;
}

double getRealTime()
{
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t getDefaultNThreads()
{
  unsigned int v5 = 0;
  size_t v4 = 4LL;
  if (!sysctlbyname("hw.physicalcpu", &v5, &v4, 0LL, 0LL)) {
    return v5;
  }
  uint64_t v0 = __error();
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getDefaultNThreads",  107,  3,  *v0,  "sysctlbyname",  v1,  v2,  v4);
  return 1LL;
}

uint64_t sha1ToString(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = (_BYTE *)(result + 1);
  do
  {
    unint64_t v4 = *(unsigned __int8 *)(a2 + v2);
    *(v3 - 1) = serializeHexString_digit[v4 >> 4];
    *uint64_t v3 = serializeHexString_digit[v4 & 0xF];
    v3 += 2;
    ++v2;
  }

  while (v2 != 20);
  *(_BYTE *)(result + 40) = 0;
  return result;
}

uint64_t serializeHexString(uint64_t result, unsigned int a2, unsigned __int8 *a3)
{
  if (a2)
  {
    uint64_t v3 = 0LL;
    do
    {
      unsigned int v4 = *a3++;
      *(_BYTE *)(result + pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c",  (uint64_t)"RNG",  222,  94,  0,  "generate random bytes",  v0,  v1, v3) = serializeHexString_digit[(unint64_t)v4 >> 4];
      *(_BYTE *)(result + (v3 + 1)) = serializeHexString_digit[v4 & 0xF];
      v3 += 2LL;
    }

    while (2LL * a2 != v3);
  }

  *(_BYTE *)(result + 2 * a2) = 0;
  return result;
}

uint64_t sha1cmp(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)a1);
  unint64_t v3 = bswap64(*(void *)a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 8));
    unint64_t v3 = bswap64(*(void *)(a2 + 8));
    if (v2 == v3)
    {
      unint64_t v2 = bswap32(*(_DWORD *)(a1 + 16));
      unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3) {
        return 0LL;
      }
    }
  }

  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1LL;
}

const char *makePath(const char *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      if (v3[v4] == 47)
      {
        v3[v4] = 0;
        uint64_t result = (const char *)stat(v3, &v6);
        if (!(_DWORD)result) {
          break;
        }
      }

      --v4;
    }

    while (v4);
  }

  else
  {
    unint64_t v4 = 0LL;
  }

  if (v4 < a2)
  {
    int v5 = 1;
    do
    {
      if (!v3[v4])
      {
        if (!v5) {
          uint64_t result = (const char *)mkdir(v3, 0x1EDu);
        }
        int v5 = 0;
        v3[v4] = 47;
      }

      ++v4;
    }

    while (a2 != v4);
  }

  return result;
}

uint64_t normalizePath(uint64_t a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = 0LL;
  while (2)
  {
    uint64_t v3 = v2 - 1;
    while (1)
    {
      while (1)
      {
        uint64_t v4 = v1++;
        int v5 = *(unsigned __int8 *)(a1 + v4);
        if (v5 != 47) {
          break;
        }
        if (v2)
        {
          int v6 = *(unsigned __int8 *)(a1 + v3);
          if (v6 != 47) {
            goto LABEL_9;
          }
        }
      }

      if (!*(_BYTE *)(a1 + v4)) {
        goto LABEL_28;
      }
      if (v2)
      {
        int v6 = *(unsigned __int8 *)(a1 + v3);
LABEL_9:
        char v7 = 0;
        BOOL v8 = v6 == 47;
        goto LABEL_11;
      }

      char v7 = 1;
      BOOL v8 = 1;
LABEL_11:
      if (v5 != 46 || !v8) {
        goto LABEL_26;
      }
      int v10 = *(unsigned __int8 *)(a1 + v1);
      if (v10 != 47) {
        break;
      }
      uint64_t v1 = v4 + 2;
    }

    if (*(_BYTE *)(a1 + v1))
    {
      if (v10 != 46 || *(_BYTE *)(v4 + a1 + 2) != 47 && *(_BYTE *)(v4 + a1 + 2))
      {
LABEL_26:
        *(_BYTE *)(a1 + v2++) = v5;
        continue;
      }

      if ((v7 & 1) == 0)
      {
        do
        {
          uint64_t v11 = v2 - 1;
          if (v2 == 1) {
            break;
          }
          int v12 = *(unsigned __int8 *)(a1 - 2 + v2--);
        }

        while (v12 != 47);
        uint64_t v1 = v4 + 3;
        uint64_t v2 = v11;
        if (!*(_BYTE *)(v4 + a1 + 2))
        {
          uint64_t v2 = v11;
          goto LABEL_28;
        }

        continue;
      }

      return 0xFFFFFFFFLL;
    }

    else
    {
      do
      {
LABEL_28:
        uint64_t v14 = v2;
        if (!v2) {
          break;
        }
        --v2;
      }

      while (*(_BYTE *)(a1 + v14 - 1) == 47);
      uint64_t v13 = 0LL;
      *(_BYTE *)(a1 + v14) = 0;
    }

    return v13;
  }

uint64_t concatPath(char *a1, unint64_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (v8 + v9 + 2 > a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v11 = v9;
  if (a1 != __s) {
    memcpy(a1, __s, v8);
  }
  if (v11)
  {
    if (!v8 || a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], a4, v11);
    v8 += v11;
  }

  uint64_t result = 0LL;
  a1[v8] = 0;
  return result;
}

uint64_t concatExtractPath(char *a1, size_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (!v8)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  278,  3,  0,  "invalid dir: %s",  v10,  v11,  (char)__s);
    return 0xFFFFFFFFLL;
  }

  unint64_t v12 = v9;
  if (v8 + v9 + 1 >= a2)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  279,  3,  0,  "dir/path too long: %s",  v10,  v11,  (char)__s);
    return 0xFFFFFFFFLL;
  }

  strlcpy(a1, __s, a2);
  if (!v12) {
    return 0LL;
  }
  int64_t v13 = 0LL;
  while (1)
  {
    uint64_t v14 = &a4[v13];
    unint64_t v15 = strchr(&a4[v13], 47);
    int64_t v18 = v15 - a4;
    if (v15) {
      unint64_t v19 = v15 - a4;
    }
    else {
      unint64_t v19 = v12;
    }
    size_t v20 = v19 - v13;
    if (v19 == v13)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  297,  3,  0,  "invalid path: %s",  v16,  v17,  (char)a4);
      return 0xFFFFFFFFLL;
    }

    uint64_t v21 = v15;
    if (v20 != 2)
    {
      if (v20 == 1 && *v14 == 46) {
        goto LABEL_29;
      }
      goto LABEL_15;
    }

    if (*v14 == 46 && a4[v13 + 1] == 46) {
      break;
    }
LABEL_15:
    int v22 = lstat(a1, &v29);
    if (v13)
    {
      if (v22)
      {
        if (mkdir(a1, 0x1EDu) && (lstat(a1, &v29) || (v29.st_mode & 0xF000) != 0x4000))
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  326,  3,  0,  "a parent of path is not a directory: %s",  v25,  v26,  (char)a4);
          return 0xFFFFFFFFLL;
        }
      }

      else if ((v29.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  316,  3,  0,  "a parent of path is not a directory: %s",  v23,  v24,  (char)a4);
        return 0xFFFFFFFFLL;
      }
    }

    else if (v22 || (int v27 = v29.st_mode & 0xF000, v27 != 0x4000) && v27 != 40960)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  311,  3,  0,  "dir doesn't exist, or is invalid: %s",  v23,  v24,  (char)__s);
      return 0xFFFFFFFFLL;
    }

    if (a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], &a4[v13], v20);
    v8 += v20;
    a1[v8] = 0;
LABEL_29:
    if (v21)
    {
      int64_t v13 = v18 + 1;
      if (v18 + 1 < v12) {
        continue;
      }
    }

    return 0LL;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"concatExtractPath",  304,  3,  0,  "invalid path: %s",  v16,  v17,  (char)a4);
  return 0xFFFFFFFFLL;
}

BOOL pathIsValid(_BYTE *a1, size_t __n)
{
  if (!__n) {
    return 1LL;
  }
  if (__n > 0x3FF) {
    return 0LL;
  }
  int v5 = memchr(a1, 0, __n);
  BOOL result = 0LL;
  if (v5) {
    return result;
  }
  if (*a1 == 47) {
    return 0LL;
  }
  uint64_t v6 = 0LL;
  do
  {
    char v7 = &a1[v6];
    size_t v8 = memchr(&a1[v6], 47, __n - v6);
    if (!v8) {
      break;
    }
    uint64_t v9 = v8 - a1;
    uint64_t v10 = v8 - a1 - v6;
    if (v8 - a1 == v6) {
      return 0LL;
    }
    if (v6 && v10 == 1)
    {
      int v11 = *v7;
      goto LABEL_13;
    }

    if (v10 == 2 && *v7 == 46)
    {
      int v11 = a1[v6 + 1];
LABEL_13:
      if (v11 == 46) {
        return 0LL;
      }
    }

    uint64_t v6 = v9 + 1;
  }

  while (v9 + 1 < __n);
  return v6 != __n;
}

uint64_t getTempDir(char *a1, size_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (const char *)confstr(65537, a1, a2);
  if (!v4)
  {
    if (issetugid())
    {
      uint64_t v4 = 0LL;
    }

    else
    {
      uint64_t v4 = getenv("TMPDIR");
      if (v4) {
        uint64_t v4 = (const char *)strlcpy(a1, v4, a2);
      }
    }
  }

  size_t v6 = strlen(a1);
  do
  {
    size_t v7 = v6;
    if (!v6) {
      break;
    }
    --v6;
  }

  while (a1[v7 - 1] == 47);
  a1[v7] = 0;
  if (v7) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t isDirEmpty(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = opendir(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    while (1)
    {
      if (readdir_r(v3, &v14, &v13))
      {
        size_t v8 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"isDirEmpty",  438,  3,  *v8,  "readdir_r",  v9,  v10,  v12);
        uint64_t v4 = 0xFFFFFFFFLL;
        goto LABEL_14;
      }

      if (!v13) {
        break;
      }
      if (v14.d_namlen != 1 || v14.d_name[0] != 46)
      {
        uint64_t v4 = 0LL;
        if (v14.d_namlen != 2 || v14.d_name[0] != 46 || v14.d_name[1] != 46) {
          goto LABEL_14;
        }
      }
    }

    uint64_t v4 = 1LL;
LABEL_14:
    closedir(v3);
  }

  else
  {
    int v5 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"isDirEmpty",  428,  3,  *v5,  "%s",  v6,  v7,  v1);
    return 0xFFFFFFFFLL;
  }

  return v4;
}

uint64_t storeFileContents(const char *a1, uint64_t a2, unint64_t a3)
{
  char v5 = (char)a1;
  int v6 = open(a1, 1537, 420LL);
  if (v6 < 0)
  {
    dirent v14 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"storeFileContents",  535,  3,  *v14,  "%s",  v15,  v16,  v5);
    int v13 = 0;
  }

  else
  {
    int v7 = v6;
    if (a3)
    {
      unint64_t v8 = 0LL;
      while (1)
      {
        if (a3 - v8 >= 0x10000000) {
          size_t v9 = 0x10000000LL;
        }
        else {
          size_t v9 = a3 - v8;
        }
        ssize_t v10 = write(v7, (const void *)(a2 + v8), v9);
        if (v10 < 0)
        {
          int v17 = *__error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"storeFileContents",  544,  3,  v17,  "%s",  v18,  v19,  v5);
          goto LABEL_14;
        }

        if (!v10) {
          break;
        }
        v8 += v10;
        if (v8 >= a3) {
          goto LABEL_10;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"storeFileContents",  545,  3,  0,  "write error: %s",  v11,  v12,  v5);
LABEL_14:
      int v13 = 0;
    }

    else
    {
LABEL_10:
      int v13 = 1;
    }

    close(v7);
  }

  if (v13) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t copyFileSegment(const char *a1, unint64_t a2, unint64_t a3, const char *a4)
{
  ssize_t v10 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (v10)
  {
    int v13 = (char *)IFileStreamCreateWithFilename(a1, a2, a3);
    if (v13)
    {
      uint64_t v16 = OFileStreamCreateWithFilename(a4, a3);
      if (v16)
      {
        if ((MemBufferTransmit( v10,  a3,  (size_t (*)(int, void *, size_t))IFileStreamRead,  (uint64_t)v13,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))OFileStreamWrite,  (uint64_t)v16,  v14,  v15) & 0x8000000000000000LL) == 0)
        {
          int v19 = 0;
          goto LABEL_11;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileSegment",  569,  3,  0,  "copy failed: %s to %s",  v17,  v18,  (char)a1);
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileSegment",  566,  3,  0,  "opening file: %s",  v14,  v15,  (char)a4);
      }
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileSegment",  565,  3,  0,  "opening file: %s",  v11,  v12,  (char)a1);
      uint64_t v16 = 0LL;
    }
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileSegment",  564,  3,  0,  "mem buffer creation",  v8,  v9,  v21);
    uint64_t v16 = 0LL;
    int v13 = 0LL;
  }

  int v19 = 1;
LABEL_11:
  IFileStreamDestroy(v13);
  OFileStreamDestroy(v16);
  MemBufferDestroy((void **)v10);
  if (v19) {
    unlink(a4);
  }
  return (v19 << 31 >> 31);
}

uint64_t updateFileAttributes(const char *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  v24.tv_seCC_SHA1_CTX c = *(void *)(a2 + 32);
  v24.tv_useCC_SHA1_CTX c = 0;
  uint64_t v25 = *(void *)(a2 + 48);
  int v26 = 0;
  if (stat(a1, &v23))
  {
    if (*__error() == 1) {
      return 0LL;
    }
    __int16 v7 = 604;
LABEL_24:
    int v19 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"updateFileAttributes",  v7,  3,  *v19,  "%s",  v20,  v21,  (char)a1);
    return 0xFFFFFFFFLL;
  }

  uid_t v5 = *(_DWORD *)(a2 + 16);
  if (v23.st_uid == v5)
  {
    gid_t v6 = *(_DWORD *)(a2 + 20);
    if (v23.st_gid == v6) {
      goto LABEL_11;
    }
  }

  else
  {
    gid_t v6 = *(_DWORD *)(a2 + 20);
  }

  if (chown(a1, v5, v6) && *__error() != 1)
  {
    uint64_t v8 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"updateFileAttributes",  610,  3,  *v8,  "%s",  v9,  v10,  (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_13;
  }

uint64_t copyFileWithAttributes(const char *a1, const char *a2, int a3, uint64_t a4, int a5)
{
  int v9 = open(a1, 0);
  if (v9 < 0)
  {
    uint64_t v16 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  645,  3,  *v16,  "%s",  v17,  v18,  (char)a1);
LABEL_18:
    timeval v24 = 0LL;
LABEL_19:
    unint64_t v28 = 0LL;
LABEL_20:
    uint64_t v32 = 0LL;
LABEL_21:
    IFileStreamDestroy(v24);
    OArchiveFileStreamDestroy((unsigned int *)v28, v44, v45, v46, v47, v48, v49, v50);
    MemBufferDestroy(v32);
    unlink(a2);
    return 0xFFFFFFFFLL;
  }

  int v10 = v9;
  if (fstat(v9, &v54))
  {
    int v13 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  646,  3,  v13,  "%s",  v14,  v15,  (char)a1);
LABEL_17:
    close(v10);
    goto LABEL_18;
  }

  if ((v54.st_mode & 0xF000) != 0x8000)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  647,  3,  0,  "not a regular file: %s",  v11,  v12,  (char)a1);
    goto LABEL_17;
  }

  int FileProtectionClassFD = getFileProtectionClassFD(v10);
  close(v10);
  st_size_t size = v54.st_size;
  __uint32_t st_flags = v54.st_flags;
  timeval v24 = (char *)IFileStreamCreateWithFilename(a1, 0LL, v54.st_size);
  if (!v24)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  666,  3,  0,  "open failed: %s",  v22,  v23,  (char)a1);
    goto LABEL_19;
  }

  if ((st_flags & 0x40000020) == 0x20) {
    int v25 = a5 | 4;
  }
  else {
    int v25 = a5;
  }
  unint64_t v28 = OArchiveFileStreamCreate(a2, st_size, v25 | 8u, FileProtectionClassFD, a3);
  if (!v28)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  667,  3,  0,  "open failed: %s",  v26,  v27,  (char)a1);
    goto LABEL_20;
  }

  stat v29 = (unint64_t *)MemBufferCreate(0x100000uLL);
  uint64_t v32 = (void **)v29;
  if (!v29)
  {
    unint64_t v51 = "alloc";
    __int16 v52 = 670;
LABEL_28:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  v52,  3,  0,  v51,  v30,  v31,  v53);
    goto LABEL_21;
  }

  uint64_t v33 = MemBufferTransmit( v29,  st_size,  (size_t (*)(int, void *, size_t))IFileStreamRead,  (uint64_t)v24,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))OArchiveFileStreamWrite,  (uint64_t)v28,  v30,  v31);
  if (v33 < 0 || v33 != st_size)
  {
    char v53 = v33;
    unint64_t v51 = "copy failed %lld";
    __int16 v52 = 674;
    goto LABEL_28;
  }

  IFileStreamDestroy(v24);
  OArchiveFileStreamDestroy((unsigned int *)v28, v34, v35, v36, v37, v38, v39, v40);
  MemBufferDestroy(v32);
  uint64_t result = updateFileAttributes(a2, (uint64_t)&v54);
  if (!(_DWORD)result) {
    return result;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"copyFileWithAttributes",  690,  3,  0,  "update file attributes",  v42,  v43,  v53);
  return 0xFFFFFFFFLL;
}

uint64_t getFileProtectionClassFD(int a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  v4[1] = 0LL;
  v4[2] = 0LL;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005LL;
  int v1 = fgetattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0) {
    return DWORD1(v5[0]);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getFileAPFSInternalFlagsFD()
{
  return 0LL;
}

uint64_t statIsCompressed(unsigned int a1)
{
  if ((a1 & 0x40000000) != 0) {
    return 0LL;
  }
  else {
    return (a1 >> 5) & 1;
  }
}

uint64_t setFileAPFSInternalFlags(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0LL;
  }
}

uint64_t areFilesEqual(const char *a1, const char *a2)
{
  if (stat(a1, &v39))
  {
    int v4 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  708,  3,  v4,  "%s",  v5,  v6,  (char)a1);
LABEL_5:
    int v10 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_6;
  }

  if (stat(a2, &v38))
  {
    int v7 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  709,  3,  v7,  "%s",  v8,  v9,  (char)a2);
    goto LABEL_5;
  }

  if ((v39.st_mode & 0xF000) != 0x8000 || (v38.st_mode & 0xF000) != 0x8000 || v39.st_size != v38.st_size)
  {
    int v10 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    goto LABEL_6;
  }

  int v14 = open(a1, 0);
  if (v14 < 0)
  {
    int v22 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  714,  3,  v22,  "%s",  v23,  v24,  (char)a1);
    goto LABEL_5;
  }

  int v15 = v14;
  int v16 = open(a2, 0);
  if (v16 < 0)
  {
    int v25 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  716,  3,  *v25,  "%s",  v26,  v27,  (char)a2);
    close(v15);
    goto LABEL_5;
  }

  int v17 = v16;
  uint64_t v11 = malloc(0x40000uLL);
  uint64_t v18 = malloc(0x40000uLL);
  int v10 = v18;
  if (!v11 || !v18)
  {
    unint64_t v28 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  719,  3,  *v28,  "malloc",  v29,  v30,  v37);
    close(v15);
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }

  while (1)
  {
    ssize_t v19 = read(v15, v11, 0x40000uLL);
    if (v19 < 0)
    {
      int v31 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  723,  3,  v31,  "%s read",  v32,  v33,  (char)a1);
LABEL_26:
      uint64_t v12 = 0xFFFFFFFFLL;
      goto LABEL_28;
    }

    size_t v20 = v19;
    ssize_t v21 = read(v17, v10, 0x40000uLL);
    if (v21 < 0)
    {
      int v34 = *__error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"areFilesEqual",  725,  3,  v34,  "%s read",  v35,  v36,  (char)a2);
      goto LABEL_26;
    }

    if (v20 != v21) {
      goto LABEL_19;
    }
    if (!v20) {
      break;
    }
    if (memcmp(v11, v10, v20))
    {
LABEL_19:
      uint64_t v12 = 0LL;
      goto LABEL_28;
    }
  }

  uint64_t v12 = 1LL;
LABEL_28:
  close(v15);
  if ((v17 & 0x80000000) == 0) {
LABEL_29:
  }
    close(v17);
LABEL_6:
  free(v11);
  free(v10);
  return v12;
}

uint64_t areFilesEqual2()
{
  uint64_t v0 = (char *)MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v8 = *MEMORY[0x1895F89C0];
  else {
    return areFilesEqual(v7, v6);
  }
}

uint64_t getFilesystemBlockSize(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if ((statfs(a1, &v6) & 0x80000000) == 0) {
    return v6.f_bsize;
  }
  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFilesystemBlockSize",  752,  3,  "statfs failed: %s\n",  v2,  v3,  v4,  v1);
  return 4096LL;
}

uint64_t getFileDiskUsage(const char *a1)
{
  if (lstat(a1, &v12))
  {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFileDiskUsage",  765,  3,  "stat failed: %s\n",  v2,  v3,  v4,  (char)a1);
    return -1LL;
  }

  else
  {
    else {
      st_size_t size = v12.st_blocks << 9;
    }
    if ((v12.st_mode & 0xF000) == 0x8000)
    {
      uint64_t v10 = 0LL;
      off_t v11 = 0LL;
      int v7 = ParallelCompressionAFSCGetMetadata(a1, &v11, (unsigned int *)&v10 + 1, &v10);
      if (HIDWORD(v10) != -1 && v7 == 0) {
        return v10;
      }
    }
  }

  return st_size;
}

uint64_t getFileProtectionClass(const char *a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  v4[1] = 0LL;
  v4[2] = 0LL;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005LL;
  int v1 = getattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0) {
    return DWORD1(v5[0]);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getBufferSHA1Digest(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  if (a2)
  {
    unint64_t v6 = 0LL;
    CC_LONG v7 = a2;
    do
    {
      unint64_t v8 = v6 + 0x100000;
      if (v6 + 0x100000 <= a2) {
        CC_LONG v9 = 0x100000;
      }
      else {
        CC_LONG v9 = v7;
      }
      CC_SHA1_Update(&v11, (const void *)(a1 + v6), v9);
      v7 -= 0x100000;
      unint64_t v6 = v8;
    }

    while (v8 < a2);
  }

  CC_SHA1_Final(a3, &v11);
  return 0LL;
}

uint64_t getFileSHA1Digest(const char *a1, uint64_t a2)
{
  return getFileSegmentSHA1Digest(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, a2);
}

uint64_t getFileSegmentSHA1Digest(const char *a1, off_t a2, unint64_t a3, uint64_t a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    stat v12 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFileSegmentSHA1Digest",  1025,  3,  *v12,  "%s",  v13,  v14,  v7);
    return 0xFFFFFFFFLL;
  }

  else
  {
    int v9 = v8;
    uint64_t FileSegmentSHA1DigestFD = getFileSegmentSHA1DigestFD(v8, a2, a3, a4);
    close(v9);
    return FileSegmentSHA1DigestFD;
  }

uint64_t getFileSegmentSHA1DigestFD(int a1, off_t a2, unint64_t a3, uint64_t a4)
{
  *(void *)a4 = 0LL;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  char v24 = 1;
  if (fcntl(a1, 48)) {
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFileSegmentSHA1DigestFD",  1044,  3,  "Warning: couldn't set F_NOCACHE\n",  v8,  v9,  v10,  1);
  }
  CC_SHA1_CTX v11 = valloc(0x100000uLL);
  if (!v11)
  {
    int v18 = *__error();
    ssize_t v21 = "malloc";
    __int16 v22 = 1049;
LABEL_15:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFileSegmentSHA1DigestFD",  v22,  3,  v18,  v21,  v19,  v20,  v24);
LABEL_16:
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }

  CC_SHA1_Init(&c);
  if (a3)
  {
    while (1)
    {
      if (a3 >= 0x100000) {
        size_t v12 = 0x100000LL;
      }
      else {
        size_t v12 = a3;
      }
      unint64_t v13 = pread(a1, v11, v12, a2);
      if ((v13 & 0x8000000000000000LL) != 0)
      {
        int v18 = *__error();
        ssize_t v21 = "read";
        __int16 v22 = 1059;
        goto LABEL_15;
      }

      unint64_t v16 = v13;
      if (!v13) {
        goto LABEL_12;
      }
      if (v13 > v12) {
        break;
      }
      CC_SHA1_Update(&c, v11, v13);
      a2 += v16;
      a3 -= v16;
      if (!a3) {
        goto LABEL_12;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"getFileSegmentSHA1DigestFD",  1062,  3,  0,  "error: read more bytes than requested: %zd (requested %zu)",  v14,  v15,  v13);
    goto LABEL_16;
  }

uint64_t enumerateTree(void *a1, char *__s)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  size_t v3 = strlen(__s);
  if (v3 - 1024 < 0xFFFFFFFFFFFFFBFFLL) {
    return 0xFFFFFFFFLL;
  }
  size_t v5 = v3;
  bzero(v7, 0x400uLL);
  __memcpy_chk();
  do
  {
    uint64_t v6 = v5;
    if (!v5) {
      break;
    }
    --v5;
  }

  while (v7[v6 - 1] == 47);
  v7[v6] = 0;
  return enumerateTree_rec(a1, v7, v6);
}

uint64_t removeFile(const char *a1)
{
  if (lstat(a1, &v3)) {
    return 0LL;
  }
  if ((v3.st_mode & 0xF000) == 0x4000) {
    return 0xFFFFFFFFLL;
  }
  if ((v3.st_flags & 0x20002) != 0) {
    lchflags(a1, v3.st_flags & 0xFFFDFFFD);
  }
  return unlink(a1);
}

uint64_t enumerateTree_rec(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a3) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = "/";
  }
  char v7 = opendir(v6);
  if (v7)
  {
    uint64_t v8 = (uint64_t (*)(void, const char *))a1[1];
    if (v8 && (v8(*a1, a2) & 0x80000000) != 0)
    {
LABEL_35:
      int v28 = 0;
    }

    else
    {
      uint64_t v9 = a3 + 1;
      uint64_t v10 = (char *)&a2[a3];
      CC_SHA1_CTX v11 = (char *)&a2[a3 + 1];
      while (1)
      {
        if (readdir_r(v7, &v33, &v32))
        {
          int v25 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"enumerateTree_rec",  1143,  3,  *v25,  "readdir_r",  v26,  v27,  v30);
          goto LABEL_35;
        }

        if (!v32) {
          break;
        }
        size_t d_namlen = v33.d_namlen;
        if ((v33.d_namlen != 1 || v33.d_name[0] != 46)
          && (v33.d_namlen != 2 || v33.d_name[0] != 46 || v33.d_name[1] != 46))
        {
          unint64_t v13 = v9 + v33.d_namlen;
          if (v13 > 0x3FF) {
            goto LABEL_35;
          }
          char *v10 = 47;
          memcpy(v11, v33.d_name, d_namlen);
          a2[v13] = 0;
          int v14 = lstat(a2, &v31);
          if (v14)
          {
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"enumerateTree_rec",  1170,  3,  "lstat after readdir failed (errno=%d): %s",  v15,  v16,  v17,  v14);
          }

          else if ((v31.st_flags & 0x40000000) != 0)
          {
            pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"enumerateTree_rec",  1175,  3,  "skip dataless: %s",  v15,  v16,  v17,  (char)a2);
          }

          else
          {
            int d_type = v33.d_type;
            if (!v33.d_type)
            {
              if ((v31.st_mode & 0xF000) == 0x4000)
              {
                int d_type = 4;
                v33.int d_type = 4;
              }

              else
              {
                int d_type = 0;
              }
            }

            uint64_t v19 = (int (*)(void, const char *))a1[3];
            if (v19)
            {
              BOOL v20 = v19(*a1, a2) >= 0;
              int d_type = v33.d_type;
            }

            else
            {
              BOOL v20 = 1;
            }

            char *v10 = 0;
            if (!v20) {
              goto LABEL_35;
            }
          }
        }
      }

      int v28 = 1;
    }

    closedir(v7);
    uint64_t v29 = (int (*)(void, const char *))a1[2];
    if (v29 && v29(*a1, a2) < 0) {
      int v28 = 0;
    }
    if (v28) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    ssize_t v21 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"enumerateTree_rec",  1126,  3,  *v21,  "%s",  v22,  v23,  (char)a2);
    return 0xFFFFFFFFLL;
  }

uint64_t removeTree(char *__s)
{
  v2[0] = 0LL;
  v2[1] = 0LL;
  v2[2] = removeLeaveDirProc;
  v2[3] = removeEntryProc;
  return enumerateTree(v2, __s);
}

uint64_t removeEntryProc(int a1, char *a2)
{
  if (lstat(a2, &v8))
  {
    __int16 v3 = 1247;
LABEL_3:
    uint64_t v4 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"removeEntryProc",  v3,  3,  *v4,  "%s",  v5,  v6,  (char)a2);
    return 0xFFFFFFFFLL;
  }

  if ((v8.st_mode & 0xF000) == 0x4000) {
    return 0LL;
  }
  uint64_t result = unlink(a2);
  if ((_DWORD)result)
  {
    __int16 v3 = 1250;
    goto LABEL_3;
  }

  return result;
}

uint64_t removeLeaveDirProc(int a1, char *a2)
{
  char v2 = (char)a2;
  uint64_t result = rmdir(a2);
  if ((_DWORD)result)
  {
    uint64_t v4 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c",  (uint64_t)"removeLeaveDirProc",  1258,  3,  *v4,  "%s",  v5,  v6,  v2);
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t statIsDataless(unsigned int a1)
{
  return (a1 >> 30) & 1;
}

uint64_t getVolumeCapabilities(const char *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  bzero(&v11, 0x878uLL);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  int v7 = 0;
  memset(v6, 0, sizeof(v6));
  if (statfs(a1, &v11) < 0) {
    return -1LL;
  }
  LOWORD(v8) = 5;
  LODWORD(v9) = -2147352576;
  int v2 = getattrlist(v11.f_mntonname, &v8, v6, 0x24uLL, 1u);
  uint64_t result = -1LL;
  if (!v2 && LODWORD(v6[0]) == 36)
  {
    v3.i64[0] = *(void *)((char *)v6 + 4);
    int8x16_t v5 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vzip1q_s32(v3, v3), (uint32x4_t)xmmword_1862D7FB0),  (int8x16_t)xmmword_1862D7FC0);
    *(int8x8_t *)v5.i8 = vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    return (v5.i32[0] | v5.i32[1]);
  }

  return result;
}

uint64_t aaAssetExtractStreamSetParameterPtr( uint64_t *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((uint64_t (*)(uint64_t))a1[1] == closeProc_1)
  {
    char v9 = (char)a3;
    uint64_t v10 = *a1;
    switch(a2)
    {
      case 'e':
        uint64_t result = 0LL;
        *(void *)(v10 + 1040) = a3;
        return result;
      case 'j':
        int v14 = (const char *)(v10 + 3516);
        if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 3516)) || stat(v14, &v18) < 0 || (v18.st_mode & 0xF000) != 0x4000)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamSetParameterPtr",  820,  133,  0,  "invalid output dir: %s",  v15,  v16,  v9);
          return 0xFFFFFFFFLL;
        }

        break;
      case 'i':
        statfs v11 = (const char *)(v10 + 2492);
        if (a3)
        {
          if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 2492))
            || stat(v11, &v18) < 0
            || (v18.st_mode & 0xF000) != 0x4000)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamSetParameterPtr",  816,  133,  0,  "invalid input dir: %s",  v12,  v13,  v9);
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          memset_s((void *)(v10 + 2492), 0x400uLL, 0, 0x400uLL);
        }

        break;
      default:
        return 0xFFFFFFFFLL;
    }

    return 0LL;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamSetParameterPtr",  808,  133,  0,  "invalid stream",  a7,  a8,  v17);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc_1(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    AAHeaderDestroy(*(AAHeader *)(result + 4768));
    free(*(void **)(v1 + 4800));
    memset_s((void *)(v1 + 4784), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4824));
    memset_s((void *)(v1 + 4808), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4848));
    memset_s((void *)(v1 + 4832), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4888));
    memset_s((void *)(v1 + 4872), 0x18uLL, 0, 0x18uLL);
    AAByteStreamClose(*(AAByteStream *)(v1 + 4864));
    AAByteStreamClose(*(AAByteStream *)(v1 + 4856));
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t aaAssetExtractStreamSetParameterCallback( uint64_t (**a1)(uint64_t result), int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    char v9 = "NULL stream";
    __int16 v10 = 834;
    goto LABEL_5;
  }

  if (a1[1] != closeProc_1)
  {
    char v9 = "invalid stream";
    __int16 v10 = 835;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamSetParameterCallback",  v10,  133,  0,  v9,  a7,  a8,  vars0);
    return 0xFFFFFFFFLL;
  }

  if (a2 == 104)
  {
    uint64_t result = 0LL;
    *((void *)*a1 + 131) = a3;
    return result;
  }

  return 0xFFFFFFFFLL;
}

uint64_t *aaAssetExtractStreamOpen(const char *a1, uint64_t a2)
{
  uint64_t v4 = malloc(0x1320uLL);
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    __int16 v10 = 855;
LABEL_9:
    statfs v11 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"openProc",  v10,  133,  *v11,  "malloc",  v12,  v13,  v20);
    closeProc_1(v5);
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamOpen",  885,  133,  0,  "create extract stream",  v14,  v15,  v21);
    closeProc_1(0LL);
    return 0LL;
  }

  memset_s(v4, 0x1320uLL, 0, 0x1320uLL);
  uint64_t v6 = (uint64_t *)malloc(0x38uLL);
  if (!v6)
  {
    __int16 v10 = 859;
    goto LABEL_9;
  }

  int v7 = v6;
  memset_s(v6, 0x38uLL, 0, 0x38uLL);
  *int v7 = v5;
  v7[1] = (uint64_t)closeProc_1;
  v7[4] = (uint64_t)writeHeaderProc;
  v7[5] = (uint64_t)writeBlobProc;
  v7[6] = (uint64_t)closeWithStateProc_1;
  v7[2] = (uint64_t)cancelProc_1;
  *(void *)uint64_t v5 = a2;
  *(void *)(v5 + 4752) = 0x100000LL;
  if (!realpath_DARWIN_EXTSN(a1, (char *)(v5 + 12)))
  {
    int v16 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamOpen",  893,  133,  v16,  a1,  v17,  v18,  v20);
    goto LABEL_12;
  }

  if (stat((const char *)(v5 + 12), &v22) || (v22.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamOpen",  894,  133,  0,  "Not a directory: %s",  v8,  v9,  (char)a1);
LABEL_12:
    if (*v7) {
      ((void (*)(void))v7[1])();
    }
    free(v7);
    return 0LL;
  }

  __strlcpy_chk();
  return v7;
}

uint64_t *aaAssetExtractStreamOpenWithState(const char *a1, AAByteStream_impl *a2, void *a3)
{
  uint64_t v125 = *MEMORY[0x1895F89C0];
  data_size_t size = 0LL;
  size_t v122 = 0LL;
  data = 0LL;
  int v120 = 0;
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  uint32x4_t v116 = 0u;
  __int128 v117 = 0u;
  __int128 v115 = 0u;
  unint64_t __s = 0LL;
  size_t v113 = 0LL;
  __ptr = 0LL;
  StreamOpen = aaAssetExtractStreamOpen(a1, 0LL);
  uint64_t v8 = StreamOpen;
  if (!StreamOpen)
  {
    uint64_t v14 = "create extract stream";
    __int16 v15 = 927;
    goto LABEL_225;
  }

  uint64_t v9 = *StreamOpen;
  if (*((void *)a2 + 2))
  {
    uint64_t v10 = 0LL;
    statfs v11 = &v115;
    uint64_t v12 = 84LL;
    while (1)
    {
      uint64_t v13 = (*((uint64_t (**)(void, __int128 *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
      if (v13 < 0) {
        break;
      }
      if (v13)
      {
        statfs v11 = (__int128 *)((char *)v11 + v13);
        v10 += v13;
        v12 -= v13;
        if (v12) {
          continue;
        }
      }

      goto LABEL_11;
    }

    uint64_t v10 = v13;
LABEL_11:
    uint32x4_t v16 = v116;
  }

  else
  {
    uint64_t v10 = -1LL;
    uint32x4_t v16 = 0uLL;
  }

  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32(v16, (uint32x4_t)xmmword_1862D7FD0))) & 1) != 0 || v10 < 0)
  {
    uint64_t v14 = "invalid state";
    __int16 v15 = 935;
    goto LABEL_225;
  }

  *(void *)uint64_t v9 = v115;
  uint64_t v17 = v117;
  *(void *)(v9 + 4752) = *((void *)&v115 + 1);
  *(void *)(v9 + 4776) = v17;
  *(_DWORD *)(v9 + 4740) = BYTE2(v120);
  *(_DWORD *)(v9 + 4744) = HIBYTE(v120);
  *(void *)(v9 + 4760) = *((void *)&v117 + 1);
  if (!*((void *)a2 + 2)) {
    goto LABEL_224;
  }
  uint64_t v18 = v16.u32[0];
  if (v16.i32[0])
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = v9 + 2492;
    do
    {
      uint64_t v21 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v20, v18);
      if (v21 < 0) {
        goto LABEL_224;
      }
      if (!v21) {
        break;
      }
      v20 += v21;
      v19 += v21;
      v18 -= v21;
    }

    while (v18);
    if (v19 < 0 || !*((void *)a2 + 2)) {
      goto LABEL_224;
    }
  }

  uint64_t v22 = v116.u32[1];
  if (v116.i32[1])
  {
    uint64_t v23 = 0LL;
    uint64_t v24 = v9 + 3516;
    do
    {
      uint64_t v25 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v24, v22);
      if (v25 < 0) {
        goto LABEL_224;
      }
      if (!v25) {
        break;
      }
      v24 += v25;
      v23 += v25;
      v22 -= v25;
    }

    while (v22);
    if (v23 < 0) {
      goto LABEL_224;
    }
  }

  if (!*((void *)a2 + 2)) {
    goto LABEL_224;
  }
  uint64_t v26 = v116.u32[2];
  if (v116.i32[2])
  {
    uint64_t v27 = 0LL;
    uint64_t v28 = v9 + 4540;
    do
    {
      uint64_t v29 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v28, v26);
      if (v29 < 0) {
        goto LABEL_224;
      }
      if (!v29) {
        break;
      }
      v28 += v29;
      v27 += v29;
      v26 -= v29;
    }

    while (v26);
    if (v27 < 0) {
      goto LABEL_224;
    }
  }

  size_t v30 = v116.u32[3];
  if (v116.i32[3])
  {
    stat v31 = 0LL;
    unint64_t v32 = 0LL;
    size_t v33 = 0LL;
    uint64_t v34 = 0LL;
    do
    {
      if (v33 != v32) {
        goto LABEL_47;
      }
      unint64_t v35 = v32 + 0x40000;
      if (v32 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v32)
          {
            unint64_t v32 = 0x4000LL;
            size_t v37 = 0x4000LL;
            if (v35 <= 0x4000) {
              goto LABEL_49;
            }
          }

          unint64_t v36 = v32 >> 1;
          if ((v32 & (v32 >> 1)) != 0) {
            unint64_t v36 = v32 & (v32 >> 1);
          }
          v32 += v36;
        }

        while (v32 < v35);
        size_t v37 = v32;
        if (v32 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_187;
        }

LABEL_75:
    uint64_t v49 = *(void **)(v9 + 4800);
    uint64_t v50 = realloc(v49, v48);
    if (!v50)
    {
LABEL_185:
      free(v49);
LABEL_223:
      *p_data_size_t size = 0LL;
      p_data_size[1] = 0LL;
      p_data_uint64_t size[2] = 0LL;
      goto LABEL_224;
    }

    *(void *)(v9 + 4800) = v50;
    *(void *)(v9 + 4792) = v48;
    unint64_t v44 = *(void *)(v9 + 4784);
LABEL_77:
    if (v48 - v44 >= v41) {
      size_t v51 = v41;
    }
    else {
      size_t v51 = v48 - v44;
    }
    ssize_t v52 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4800) + v44), v51);
    if (v52 < 0) {
      goto LABEL_224;
    }
    if (!v52) {
      break;
    }
    unint64_t v44 = *p_data_size + v52;
    if (!__CFADD__(*p_data_size, v52))
    {
      unint64_t v45 = *(void *)(v9 + 4792);
      if (v44 <= v45) {
        continue;
      }
    }

    goto LABEL_224;
    *p_data_size_t size = v44;
    v42 += v52;
    v41 -= v52;
  }

  while (v41);
  if (v42 < 0) {
    goto LABEL_224;
  }
LABEL_86:
  size_t v53 = v119;
  if (!(void)v119) {
    goto LABEL_112;
  }
  uint64_t v54 = 0LL;
  p_data_size_t size = (size_t *)(v9 + 4808);
  unint64_t v55 = *(void *)(v9 + 4808);
  unint64_t v56 = *(void *)(v9 + 4816);
  while (2)
  {
    if (v55 != v56) {
      goto LABEL_99;
    }
    unint64_t v57 = v56 + 0x40000;
    if (v56 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v55 = v56;
LABEL_99:
      size_t v59 = v56;
      goto LABEL_103;
    }

    do
    {
      while (!v56)
      {
        unint64_t v56 = 0x4000LL;
        size_t v59 = 0x4000LL;
        if (v57 <= 0x4000) {
          goto LABEL_101;
        }
      }

      unint64_t v58 = v56 >> 1;
      if ((v56 & (v56 >> 1)) != 0) {
        unint64_t v58 = v56 & (v56 >> 1);
      }
      v56 += v58;
    }

    while (v56 < v57);
    size_t v59 = v56;
    if (v56 >= 0x2000000001LL) {
      goto LABEL_222;
    }
LABEL_101:
    uint64_t v49 = *(void **)(v9 + 4824);
    unsigned int v60 = realloc(v49, v59);
    if (!v60) {
      goto LABEL_185;
    }
    *(void *)(v9 + 4824) = v60;
    *(void *)(v9 + 4816) = v59;
    unint64_t v55 = *(void *)(v9 + 4808);
LABEL_103:
    if (v59 - v55 >= v53) {
      size_t v61 = v53;
    }
    else {
      size_t v61 = v59 - v55;
    }
    ssize_t v62 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4824) + v55), v61);
    if (v62 < 0) {
      goto LABEL_224;
    }
    if (v62)
    {
      unint64_t v55 = *p_data_size + v62;
      if (__CFADD__(*p_data_size, v62)) {
        goto LABEL_224;
      }
      unint64_t v56 = *(void *)(v9 + 4816);
      if (v55 > v56) {
        goto LABEL_224;
      }
      *p_data_size_t size = v55;
      v54 += v62;
      v53 -= v62;
      if (v53) {
        continue;
      }
    }

    break;
  }

  if (v54 < 0) {
    goto LABEL_224;
  }
LABEL_112:
  size_t v63 = *((void *)&v119 + 1);
  if (*((void *)&v119 + 1))
  {
    uint64_t v64 = 0LL;
    p_data_size_t size = (size_t *)(v9 + 4832);
    unint64_t v65 = *(void *)(v9 + 4832);
    unint64_t v66 = *(void *)(v9 + 4840);
    while (1)
    {
      if (v65 == v66)
      {
        unint64_t v67 = v66 + 0x40000;
        if (v66 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v66)
            {
              unint64_t v66 = 0x4000LL;
              size_t v69 = 0x4000LL;
              if (v67 <= 0x4000) {
                goto LABEL_127;
              }
            }

            unint64_t v68 = v66 >> 1;
            if ((v66 & (v66 >> 1)) != 0) {
              unint64_t v68 = v66 & (v66 >> 1);
            }
            v66 += v68;
          }

          while (v66 < v67);
          size_t v69 = v66;
          if (v66 >= 0x2000000001LL) {
            goto LABEL_222;
          }
LABEL_127:
          uint64_t v49 = *(void **)(v9 + 4848);
          unint64_t v70 = realloc(v49, v69);
          if (!v70) {
            goto LABEL_185;
          }
          *(void *)(v9 + 4848) = v70;
          *(void *)(v9 + 4840) = v69;
          unint64_t v65 = *(void *)(v9 + 4832);
          goto LABEL_129;
        }

        unint64_t v65 = v66;
      }

      size_t v69 = v66;
LABEL_129:
      if (v69 - v65 >= v63) {
        size_t v71 = v63;
      }
      else {
        size_t v71 = v69 - v65;
      }
      ssize_t v72 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4848) + v65), v71);
      if (v72 < 0) {
        goto LABEL_224;
      }
      if (!v72) {
        goto LABEL_137;
      }
      unint64_t v65 = *p_data_size + v72;
      if (__CFADD__(*p_data_size, v72)) {
        goto LABEL_224;
      }
      unint64_t v66 = *(void *)(v9 + 4840);
      if (v65 > v66) {
        goto LABEL_224;
      }
      *p_data_size_t size = v65;
      v64 += v72;
      v63 -= v72;
      if (!v63)
      {
LABEL_137:
        if ((v64 & 0x8000000000000000LL) == 0) {
          break;
        }
LABEL_224:
        uint64_t v14 = "write state";
        __int16 v15 = 953;
        goto LABEL_225;
      }
    }
  }

  *(_BYTE *)(v9 + v116.u32[0] + 2492) = 0;
  *(_BYTE *)(v9 + v116.u32[1] + 3516) = 0;
  *(_BYTE *)(v9 + v116.u32[2] + 4540) = 0;
  if (v116.i32[3])
  {
    AAHeader v73 = AAHeaderCreateWithEncodedData(data_size, data);
    *(void *)(v9 + 4768) = v73;
    if (!v73)
    {
      uint64_t v14 = "invalid header in state";
      __int16 v15 = 959;
      goto LABEL_225;
    }
  }

  if (!BYTE1(v120))
  {
    size_t v93 = v118;
    if (!(void)v118) {
      goto LABEL_214;
    }
    uint64_t v94 = 0LL;
    unint64_t v95 = (unint64_t *)(v9 + 4872);
    unint64_t v96 = *(void *)(v9 + 4872);
    unint64_t v97 = *(void *)(v9 + 4880);
    while (1)
    {
      if (v96 != v97) {
        goto LABEL_201;
      }
      unint64_t v98 = v97 + 0x40000;
      if (v97 > 0xFFFFFFFFFFFBFFFFLL) {
        break;
      }
      do
      {
        while (!v97)
        {
          unint64_t v97 = 0x4000LL;
          size_t v100 = 0x4000LL;
          if (v98 <= 0x4000) {
            goto LABEL_203;
          }
        }

        unint64_t v99 = v97 >> 1;
        if ((v97 & (v97 >> 1)) != 0) {
          unint64_t v99 = v97 & (v97 >> 1);
        }
        v97 += v99;
      }

      while (v97 < v98);
      size_t v100 = v97;
      if (v97 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_251;
      }

LABEL_203:
      size_t v101 = *(void **)(v9 + 4888);
      unint64_t v102 = realloc(v101, v100);
      if (!v102)
      {
        free(v101);
LABEL_251:
        *unint64_t v95 = 0LL;
        *(void *)(v9 + 4880) = 0LL;
        *(void *)(v9 + 4888) = 0LL;
        goto LABEL_252;
      }

      *(void *)(v9 + 4888) = v102;
      *(void *)(v9 + 4880) = v100;
      unint64_t v96 = *(void *)(v9 + 4872);
LABEL_205:
      if (v100 - v96 >= v93) {
        size_t v103 = v93;
      }
      else {
        size_t v103 = v100 - v96;
      }
      ssize_t v104 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4888) + v96), v103);
      if (v104 < 0) {
        goto LABEL_252;
      }
      if (!v104) {
        goto LABEL_213;
      }
      unint64_t v96 = *v95 + v104;
      if (__CFADD__(*v95, v104)) {
        goto LABEL_252;
      }
      unint64_t v97 = *(void *)(v9 + 4880);
      if (v96 > v97) {
        goto LABEL_252;
      }
      *unint64_t v95 = v96;
      v94 += v104;
      v93 -= v104;
      if (!v93)
      {
LABEL_213:
        if ((v94 & 0x8000000000000000LL) == 0) {
          goto LABEL_214;
        }
LABEL_252:
        uint64_t v14 = "truncated state";
        __int16 v15 = 983;
LABEL_225:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamOpenWithState",  v15,  133,  0,  v14,  v6,  v7,  v110);
        goto LABEL_226;
      }
    }

    unint64_t v96 = v97;
LABEL_201:
    size_t v100 = v97;
    goto LABEL_205;
  }

  unint64_t v74 = AATempFileStreamOpenWithDirectory((const char *)(v9 + 12));
  *(void *)(v9 + 4864) = v74;
  if (!v74)
  {
    uint64_t v14 = "create temp file";
    __int16 v15 = 965;
    goto LABEL_225;
  }

  uint64_t v75 = v118;
  if (!(void)v118) {
    goto LABEL_214;
  }
  uint64_t v76 = 0LL;
  while (2)
  {
    unint64_t __s = 0LL;
    uint64_t v111 = v76;
    unint64_t v77 = v75 - v76;
    if (v77 >= 0x40000) {
      unint64_t v78 = 0x40000LL;
    }
    else {
      unint64_t v78 = v77;
    }
    if (!v78)
    {
LABEL_243:
      uint64_t v75 = v118;
      uint64_t v76 = v111;
      break;
    }

    unint64_t v79 = 0LL;
    uint64_t v80 = 0LL;
    unint64_t v81 = v113;
    while (2)
    {
      if (v79 == v81)
      {
        unint64_t v82 = v81 + 0x40000;
        if (v81 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v81)
            {
              unint64_t v81 = 0x4000LL;
              size_t v84 = 0x4000LL;
              if (v82 <= 0x4000) {
                goto LABEL_160;
              }
            }

            unint64_t v83 = v81 >> 1;
            if ((v81 & (v81 >> 1)) != 0) {
              unint64_t v83 = v81 & (v81 >> 1);
            }
            v81 += v83;
          }

          while (v81 < v82);
          size_t v84 = v81;
          if (v81 >= 0x2000000001LL)
          {
            *__error() = 12;
            goto LABEL_247;
          }

LABEL_160:
          unint64_t v85 = realloc(__ptr, v84);
          if (v85)
          {
            size_t v113 = v84;
            __ptr = v85;
            unint64_t v81 = v84;
            goto LABEL_162;
          }

          free(__ptr);
LABEL_247:
          unint64_t __s = 0LL;
          size_t v113 = 0LL;
          __ptr = 0LL;
          goto LABEL_248;
        }
      }

LABEL_214:
  if ((updateFromHeader((_BYTE *)v9) & 0x80000000) != 0)
  {
    uint64_t v14 = "deriving fields from header";
    __int16 v15 = 987;
    goto LABEL_225;
  }

  if ((_BYTE)v120)
  {
    if (!*(_DWORD *)(v9 + 1056))
    {
      uint64_t v14 = "missing PAT";
      __int16 v15 = 995;
      goto LABEL_225;
    }

    if ((concatExtractPath(v124, 0x400uLL, (char *)(v9 + 3516), (const char *)(v9 + 1064)) & 0x80000000) == 0)
    {
      __int128 v107 = aaArchiveFileOutputStreamOpenAtWithState(-1, v124, a2, a3);
      *(void *)(v9 + 4856) = v107;
      if (!v107)
      {
        uint64_t v14 = "aaArchiveFileOutputStreamOpenAtWithState";
        __int16 v15 = 1000;
        goto LABEL_225;
      }

      goto LABEL_219;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"aaAssetExtractStreamOpenWithState",  996,  133,  0,  "invalid PAT: %s",  v105,  v106,  v9 + 40);
LABEL_226:
    int v108 = 0;
  }

  else
  {
LABEL_219:
    if (a3) {
      *a3 = -1LL;
    }
    int v108 = 1;
  }

  free(data);
  memset_s(&data_size, 0x18uLL, 0, 0x18uLL);
  free(__ptr);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v108) {
    uint64_t result = v8;
  }
  else {
    uint64_t result = 0LL;
  }
  if (v8 && (v108 & 1) == 0)
  {
    if (*v8) {
      ((void (*)(void))v8[1])();
    }
    free(v8);
    return 0LL;
  }

  return result;
}

uint64_t updateFromHeader(_BYTE *a1)
{
  uint64_t size = 0LL;
  size_t length = 0LL;
  uint64_t v46 = 0LL;
  uint64_t offset = 0LL;
  *((void *)a1 + 132) = 0LL;
  unsigned int v2 = a1 + 2112;
  *((void *)a1 + 261) = 0LL;
  *((void *)a1 + 263) = 0LL;
  *((void *)a1 + 262) = 0LL;
  memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
  memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
  memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
  memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
  int32x4_t v3 = (AAHeader_impl *)*((void *)a1 + 596);
  if (!v3) {
    return 0LL;
  }
  v4.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(*((AAHeader *)a1 + 596), v4);
  if ((KeyIndex & 0x80000000) != 0
    || ((unsigned int FieldUInt = AAHeaderGetFieldUInt(v3, KeyIndex, (uint64_t *)a1 + 261), FieldUInt <= 1)
      ? (int v9 = 1)
      : (int v9 = FieldUInt),
        v9 <= 0))
  {
    uint64_t v42 = "missing TYP";
    __int16 v43 = 141;
LABEL_46:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"updateFromHeader",  v43,  133,  0,  v42,  v6,  v7,  v46);
    return 0xFFFFFFFFLL;
  }

  if ((aaEntryAttributesInitWithHeader(v2, a1 + 2184, a1 + 2240, *((AAHeader *)a1 + 596)) & 0x80000000) != 0)
  {
    uint64_t v42 = "attributes from header";
    __int16 v43 = 142;
    goto LABEL_46;
  }

  uint64_t v10 = (AAHeader_impl *)*((void *)a1 + 596);
  v11.uint64_t ikey = 5521744;
  uint32_t v12 = AAHeaderGetKeyIndex(v10, v11);
  if ((v12 & 0x80000000) == 0)
  {
    unsigned int FieldString = AAHeaderGetFieldString(v10, v12, 0x400uLL, a1 + 1064, &length);
    int v14 = FieldString <= 1 ? 1 : FieldString;
    if (v14 >= 1) {
      *((_DWORD *)a1 + 264) = 1;
    }
  }

  __int16 v15 = (AAHeader_impl *)*((void *)a1 + 596);
  v16.uint64_t ikey = 4408665;
  uint32_t v17 = AAHeaderGetKeyIndex(v15, v16);
  if ((v17 & 0x80000000) == 0)
  {
    unsigned int FieldBlob = AAHeaderGetFieldBlob(v15, v17, &size, &offset);
    int v19 = FieldBlob <= 1 ? 1 : FieldBlob;
    if (v19 >= 1)
    {
      a1[2416] |= 1u;
      *((void *)a1 + 304) = size;
    }
  }

  uint64_t v20 = (AAHeader_impl *)*((void *)a1 + 596);
  v21.uint64_t ikey = 5521752;
  uint32_t v22 = AAHeaderGetKeyIndex(v20, v21);
  if ((v22 & 0x80000000) == 0)
  {
    unsigned int v23 = AAHeaderGetFieldBlob(v20, v22, &size, &offset);
    int v24 = v23 <= 1 ? 1 : v23;
    if (v24 >= 1)
    {
      a1[2416] |= 2u;
      *((void *)a1 + 306) = size;
    }
  }

  uint64_t v25 = (AAHeader_impl *)*((void *)a1 + 596);
  v26.uint64_t ikey = 4997953;
  uint32_t v27 = AAHeaderGetKeyIndex(v25, v26);
  if ((v27 & 0x80000000) == 0)
  {
    unsigned int v28 = AAHeaderGetFieldBlob(v25, v27, &size, &offset);
    int v29 = v28 <= 1 ? 1 : v28;
    if (v29 >= 1)
    {
      a1[2416] |= 4u;
      *((void *)a1 + 308) = size;
    }
  }

  size_t v30 = (AAHeader_impl *)*((void *)a1 + 596);
  v31.uint64_t ikey = 5521732;
  uint32_t v32 = AAHeaderGetKeyIndex(v30, v31);
  if ((v32 & 0x80000000) == 0)
  {
    unsigned int v33 = AAHeaderGetFieldBlob(v30, v32, &size, &offset);
    int v34 = v33 <= 1 ? 1 : v33;
    if (v34 >= 1)
    {
      *((_DWORD *)a1 + 265) = 1;
      *((void *)a1 + 263) = size;
    }
  }

  uint64_t v35 = *((void *)a1 + 595);
  *((void *)a1 + 262) = v35;
  if (!v35)
  {
    unint64_t v36 = (AAHeader_impl *)*((void *)a1 + 596);
    v37.uint64_t ikey = 5263193;
    uint32_t v38 = AAHeaderGetKeyIndex(v36, v37);
    if ((v38 & 0x80000000) != 0
      || ((unsigned int v39 = AAHeaderGetFieldUInt(v36, v38, &v46), v39 <= 1) ? (v40 = 1) : (v40 = v39), v40 < 1))
    {
      uint64_t v41 = *((void *)a1 + 262);
    }

    else
    {
      uint64_t v41 = v46;
      *((void *)a1 + 262) = v46;
    }

    if (!v41 && *((void *)a1 + 261) != 77LL) {
      *((void *)a1 + 262) = 69LL;
    }
  }

  *((void *)a1 + 310) = 40LL;
  *((_DWORD *)a1 + 618) = -1;
  *((_DWORD *)a1 + 622) = -1;
  if ((a1[2112] & 4) != 0)
  {
    char v45 = a1[2184];
    if ((a1[2124] & 0x20) != 0)
    {
      *((void *)a1 + 310) = 44LL;
      *((_DWORD *)a1 + 622) = 0;
      if ((v45 & 1) != 0) {
        *((_DWORD *)a1 + 622) = *((_DWORD *)a1 + 548);
      }
    }
  }

  else
  {
    char v45 = a1[2184];
  }

  if ((v45 & 8) != 0)
  {
    uint64_t result = 0LL;
    *((_DWORD *)a1 + 618) = *((_DWORD *)a1 + 547);
    return result;
  }

  return 0LL;
}

uint64_t closeWithStateProc_1(uint64_t *a1, void *a2, void *a3)
{
  int v99 = 0;
  __int128 v97 = 0u;
  __int128 v98 = 0u;
  unint64_t __s = 0LL;
  size_t v88 = 0LL;
  uint64_t v8 = *a1;
  uint64_t v9 = a1[594];
  uint64_t v89 = 0LL;
  v90[0] = v8;
  v90[1] = v9;
  uint64_t v10 = (uint64_t)a1 + 2492;
  unsigned int v91 = strlen((const char *)a1 + 2492);
  uint64_t v11 = (uint64_t)a1 + 3516;
  unsigned int v92 = strlen((const char *)a1 + 3516);
  uint64_t v12 = (uint64_t)a1 + 4540;
  unsigned int v93 = strlen((const char *)a1 + 4540);
  BYTE2(v99) = *((_DWORD *)a1 + 1185);
  HIBYTE(v99) = *((_DWORD *)a1 + 1186);
  __int16 v15 = (AAHeader_impl *)a1[596];
  if (v15) {
    LODWORD(v15) = AAHeaderGetEncodedSize(v15);
  }
  unsigned int v94 = v15;
  uint64_t v16 = a1[595];
  uint64_t v95 = a1[597];
  uint64_t v96 = v16;
  uint64_t v17 = a1[601];
  *((void *)&v97 + 1) = a1[598];
  *(void *)&__int128 v98 = v17;
  *((void *)&v98 + 1) = a1[604];
  uint64_t v18 = (AAByteStream_impl *)a1[608];
  if (v18)
  {
    off_t v19 = AAByteStreamSeek(v18, 0LL, 2);
    char v20 = 1;
  }

  else
  {
    char v20 = 0;
    off_t v19 = a1[609];
  }

  BYTE1(v99) = v20;
  *(void *)&__int128 v97 = v19;
  LOBYTE(v99) = a1[607] != 0;
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v21 = 0LL;
  uint32_t v22 = v90;
  uint64_t v23 = 84LL;
  do
  {
    uint64_t v24 = ((uint64_t (*)(void, void *, uint64_t))a2[3])(*a2, v22, v23);
    if (v24 < 1)
    {
      if ((v24 & 0x8000000000000000LL) == 0) {
        goto LABEL_15;
      }
      goto LABEL_120;
    }

    uint32_t v22 = (void *)((char *)v22 + v24);
    v21 += v24;
    v23 -= v24;
  }

  while (v23);
  if (v21 < 0) {
    goto LABEL_120;
  }
LABEL_15:
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v25 = v91;
  if (!v91) {
    goto LABEL_24;
  }
  uint64_t v26 = 0LL;
  while (2)
  {
    uint64_t v27 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v10, v25);
    if (v27 < 1)
    {
      if ((v27 & 0x8000000000000000LL) == 0) {
        goto LABEL_23;
      }
      goto LABEL_120;
    }

    v10 += v27;
    v26 += v27;
    v25 -= v27;
    if (v25) {
      continue;
    }
    break;
  }

  if (v26 < 0) {
    goto LABEL_120;
  }
LABEL_23:
  if (!a2[3])
  {
LABEL_120:
    size_t v71 = "write state";
    __int16 v72 = 747;
    goto LABEL_121;
  }

LABEL_93:
          uint64_t v64 = (char *)realloc(v53, v63);
          if (v64)
          {
            size_t v88 = v63;
            uint64_t v89 = v64;
            unint64_t v85 = v64;
            unint64_t v58 = __s;
            goto LABEL_95;
          }

          free(v53);
LABEL_146:
          unint64_t __s = 0LL;
          size_t v88 = 0LL;
          uint64_t v89 = 0LL;
          goto LABEL_147;
        }

        unint64_t v58 = v54;
      }

      size_t v63 = v54;
      uint64_t v64 = v53;
LABEL_95:
      if (v63 - v58 >= v57) {
        size_t v65 = v57;
      }
      else {
        size_t v65 = v63 - v58;
      }
      size_t v53 = v64;
      ssize_t v66 = AAByteStreamPRead(s, &v64[v58], v65, v60);
      if (v66 < 0) {
        goto LABEL_147;
      }
      if (v66)
      {
        unint64_t v58 = __s + v66;
        if (__CFADD__(__s, v66)) {
          goto LABEL_147;
        }
        unint64_t v54 = v88;
        if (v58 > v88) {
          goto LABEL_147;
        }
        __s += v66;
        v59 += v66;
        v60 += v66;
        v57 -= v66;
        if (!v57) {
          goto LABEL_105;
        }
        continue;
      }

      break;
    }

    unint64_t v54 = v63;
LABEL_105:
    if (v59 < 0)
    {
LABEL_147:
      size_t v71 = "reading DAT file";
      __int16 v72 = 759;
      goto LABEL_121;
    }

    unint64_t v55 = v84;
    if (!v59) {
      goto LABEL_142;
    }
    if (a2[3])
    {
      unint64_t v67 = __s;
      if (__s)
      {
        uint64_t v68 = 0LL;
        size_t v69 = v85;
        while (1)
        {
          uint64_t v70 = ((uint64_t (*)(void, char *, unint64_t))a2[3])(*a2, v69, v67);
          if (v70 < 1) {
            break;
          }
          v69 += v70;
          v68 += v70;
          v67 -= v70;
          if (!v67)
          {
            size_t v53 = v85;
            goto LABEL_116;
          }
        }

        size_t v53 = v85;
        uint64_t v68 = v70;
LABEL_116:
        unint64_t v55 = v84;
      }

      else
      {
        uint64_t v68 = 0LL;
        size_t v53 = v85;
      }
    }

    else
    {
      uint64_t v68 = -1LL;
    }

    if (v68 != v59)
    {
      size_t v71 = "write state";
      __int16 v72 = 762;
LABEL_121:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"closeWithStateProc",  v72,  133,  0,  v71,  v13,  v14,  v84);
      uint64_t v4 = 0xFFFFFFFFLL;
      AAHeader v73 = a1 + 604;
      goto LABEL_122;
    }

    v55 += v59;
    uint64_t v52 = v97;
    break;
  }

  if (v55 != v52)
  {
    size_t v71 = "truncated DAT file";
    __int16 v72 = 765;
    goto LABEL_121;
  }

uint64_t writeHeaderProc(uint64_t a1, AAHeader header)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  unsigned int v2 = (unsigned int *)(a1 + 8);
  if (!atomic_load((unsigned int *)(a1 + 8)))
  {
    size_t length = 0LL;
    uint64_t value = 0LL;
    v7.uint64_t ikey = 5265748;
    uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v7);
    if ((KeyIndex & 0x80000000) != 0
      || ((unsigned int v11 = AAHeaderGetFieldUInt(header, KeyIndex, &value), v11 <= 1) ? (v12 = 1) : (v12 = v11), v12 <= 0))
    {
      off_t v19 = "missing TYP";
      __int16 v20 = 569;
    }

    else
    {
      v13.uint64_t ikey = 4997708;
      uint32_t v14 = AAHeaderGetKeyIndex(header, v13);
      if ((v14 & 0x80000000) == 0)
      {
        unsigned int FieldString = AAHeaderGetFieldString(header, v14, 0xC8uLL, __s1, &length);
        int v16 = FieldString <= 1 ? 1 : FieldString;
        if (v16 >= 1)
        {
          if (strcmp(__s1, (const char *)(a1 + 4540)))
          {
            __strlcpy_chk();
            *(_DWORD *)(a1 + 4740) = 0;
            uint64_t v17 = *(uint64_t (**)(void, uint64_t, char *, void))(a1 + 1048);
            if (v17)
            {
              int v18 = v17(*(void *)(a1 + 1040), 90LL, __s1, 0LL);
              if (v18 < 0)
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"updateLabel",  205,  133,  0,  "Caller cancelled",  v9,  v10,  v49);
                off_t v19 = "updating label";
                __int16 v20 = 571;
                goto LABEL_22;
              }

              if (v18) {
                *(_DWORD *)(a1 + 4740) = 1;
              }
            }
          }
        }
      }

      if (*(_DWORD *)(a1 + 4740)) {
        return 0LL;
      }
      if (value != 77) {
        goto LABEL_85;
      }
      v52[0] = 0LL;
      v22.uint64_t ikey = 5263193;
      uint32_t v23 = AAHeaderGetKeyIndex(header, v22);
      if ((v23 & 0x80000000) != 0) {
        goto LABEL_85;
      }
      unsigned int FieldUInt = AAHeaderGetFieldUInt(header, v23, v52);
      int v25 = FieldUInt <= 1 ? 1 : FieldUInt;
      if (v25 < 1) {
        goto LABEL_85;
      }
      if (v52[0] == 93)
      {
        *(void *)(a1 + 4760) = 0LL;
        return 0LL;
      }

      if (v52[0] == 91)
      {
        v26.uint64_t ikey = 5328729;
        uint32_t v27 = AAHeaderGetKeyIndex(header, v26);
        if ((v27 & 0x80000000) == 0)
        {
          uint64_t v28 = (uint64_t *)(a1 + 4760);
          unsigned int v29 = AAHeaderGetFieldUInt(header, v27, v28);
          int v30 = v29 <= 1 ? 1 : v29;
          if (v30 >= 1 && *v28) {
            return 0LL;
          }
        }

        off_t v19 = "expected valid YOQ field";
        __int16 v20 = 584;
      }

      else
      {
LABEL_85:
        if (*(void *)(a1 + 4864)
          || *(void *)(a1 + 4856)
          || *(void *)(a1 + 4768)
          || *(void *)(a1 + 4872)
          || *(void *)(a1 + 4784)
          || *(void *)(a1 + 4808)
          || *(void *)(a1 + 4832))
        {
          off_t v19 = "invalid extractor state (blobs)";
          __int16 v20 = 603;
        }

        else
        {
          *(void *)(a1 + 4768) = AAHeaderClone(header);
          *(void *)(a1 + 4776) = AAHeaderGetPayloadSize(header);
          if ((updateFromHeader((_BYTE *)a1) & 0x80000000) != 0)
          {
            off_t v19 = "extract entry attributes from header";
            __int16 v20 = 610;
          }

          else
          {
            if (*(void *)(a1 + 2096) == 77LL)
            {
              uint64_t v36 = (_DWORD *)(a1 + 1056);
            }

            else
            {
              if (!*(_DWORD *)(a1 + 4744))
              {
                off_t v19 = "invalid AssetArchive stream (missing manifest)";
                __int16 v20 = 616;
                goto LABEL_22;
              }

              uint64_t v36 = (_DWORD *)(a1 + 1056);
              if (*(_DWORD *)(a1 + 1056))
              {
                uint64_t v42 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(a1 + 1048);
                if (v42)
                {
                  LOBYTE(v52[0]) = 0;
                  int v43 = v42(*(void *)(a1 + 1040), 91LL, a1 + 1064, v52);
                  if (v43 < 0)
                  {
                    off_t v19 = "Caller cancelled";
                    __int16 v20 = 626;
                    goto LABEL_22;
                  }

                  if (v43)
                  {
                    __strlcpy_chk();
                    v44.uint64_t ikey = 5521744;
                    int v45 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 4768), v44);
                    if (v45 < 0)
                    {
                      off_t v19 = "no PAT field in header";
                      __int16 v20 = 632;
                      goto LABEL_22;
                    }

                    uint32_t v46 = v45;
                    size_t v47 = strlen((const char *)(a1 + 1064));
                    v48.uint64_t ikey = 5521744;
                    if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 4768), v46, v48, (const char *)(a1 + 1064), v47) < 0)
                    {
                      off_t v19 = "set PAT";
                      __int16 v20 = 633;
                      goto LABEL_22;
                    }
                  }
                }
              }
            }

            if (*(void *)(a1 + 2088) == 70LL && *(void *)(a1 + 2096) == 69LL)
            {
              if (!*v36)
              {
                off_t v19 = "missing PAT";
                __int16 v20 = 640;
                goto LABEL_22;
              }

              if ((concatExtractPath((char *)v52, 0x400uLL, (char *)(a1 + 3516), (const char *)(a1 + 1064)) & 0x80000000) != 0)
              {
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"writeHeaderProc",  641,  133,  0,  "invalid PAT: %s",  v37,  v38,  a1 + 40);
LABEL_23:
                while (!__ldaxr(v2))
                {
                  if (!__stlxr(1u, v2)) {
                    return 0xFFFFFFFFLL;
                  }
                }

                __clrex();
                return 0xFFFFFFFFLL;
              }

              size_t v39 = strlen((const char *)v52);
              makePath((const char *)v52, v39);
              uint64_t v40 = aaArchiveFileOutputStreamOpenAt( -1,  (const char *)v52,  *(void *)(a1 + 2104),  *(_DWORD *)(a1 + 2488),  0LL,  *(_DWORD *)(a1 + 2472),  *(void *)(a1 + 2480));
              *(void *)(a1 + 4856) = v40;
              if (!v40)
              {
                off_t v19 = "file stream";
                __int16 v20 = 647;
                goto LABEL_22;
              }
            }

            if (!*(_DWORD *)(a1 + 1060)
              || *(void *)(a1 + 4856)
              || *(void *)(a1 + 2104) < *(void *)(a1 + 4752)
              || (uint64_t v41 = AATempFileStreamOpenWithDirectory((const char *)(a1 + 12)), (*(void *)(a1 + 4864) = v41) != 0LL))
            {
              if (*(void *)(a1 + 4776)
                || (processEntry_0((_BYTE *)a1, v31, v32, v33, v34, v35, v9, v10) & 0x80000000) == 0)
              {
                return 0LL;
              }

              off_t v19 = "entry processing";
              __int16 v20 = 658;
            }

            else
            {
              off_t v19 = "temp stream";
              __int16 v20 = 654;
            }
          }
        }
      }
    }

uint64_t writeBlobProc( uint64_t a1, size_t a2, uint64_t __src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)(a1 + 8);
  uint64_t result = 0LL;
  if (!__smax || *(_DWORD *)(a1 + 4740)) {
    return result;
  }
  if (*(void *)(a1 + 4776) < __smax)
  {
    AAFieldKey v13 = "blob size mismatch";
    __int16 v14 = 672;
    goto LABEL_93;
  }

  if (!*(void *)(a1 + 4768))
  {
    AAFieldKey v13 = "invalid state";
    __int16 v14 = 673;
    goto LABEL_93;
  }

  __int16 v15 = (char *)__src;
  uint64_t result = 0LL;
  uint64_t v16 = a2 & 0xFFFFFF;
  if ((a2 & 0xFFFFFF) > 0x544143)
  {
    if (v16 == 5521752)
    {
      uint64_t v32 = *(void *)(a1 + 4808);
      BOOL v18 = __CFADD__(v32, __smax);
      unint64_t v33 = v32 + __smax;
      if (!v18 && (v33 & 0x8000000000000000LL) == 0)
      {
        __int16 v20 = (void *)(a1 + 4808);
        size_t v34 = *(void *)(a1 + 4816);
        if (v34 < v33)
        {
          do
          {
            while (!v34)
            {
              size_t v34 = 0x4000LL;
              if (v33 <= 0x4000)
              {
                uint32_t v23 = (void **)(a1 + 4824);
                size_t v34 = 0x4000LL;
                goto LABEL_84;
              }
            }

            size_t v35 = v34 >> 1;
            if ((v34 & (v34 >> 1)) != 0) {
              size_t v35 = v34 & (v34 >> 1);
            }
            v34 += v35;
          }

          while (v34 < v33);
          uint32_t v23 = (void **)(a1 + 4824);
          if (v34 >= 0x2000000001LL)
          {
LABEL_83:
            *__error() = 12;
            goto LABEL_100;
          }

LABEL_84:
          uint64_t v41 = *v23;
          int v45 = realloc(*v23, v34);
          if (!v45) {
            goto LABEL_98;
          }
          *(void *)(a1 + 4824) = v45;
          *(void *)(a1 + 4816) = v34;
        }

        uint64_t v43 = *(void *)(a1 + 4824);
        if (!v15) {
          goto LABEL_80;
        }
        goto LABEL_87;
      }
    }

    else
    {
      if (v16 != 5521732) {
        return result;
      }
      uint64_t v24 = *(void **)(a1 + 4856);
      if (v24)
      {
        if (!v24[3]) {
          goto LABEL_68;
        }
        uint64_t v25 = 0LL;
        rsize_t v26 = __smax;
        while (1)
        {
          uint64_t v27 = ((uint64_t (*)(void, char *, rsize_t))v24[3])(*v24, v15, v26);
          if (v27 < 1) {
            break;
          }
          v15 += v27;
          v25 += v27;
          v26 -= v27;
          if (!v26) {
            goto LABEL_69;
          }
        }

      ++v69;
    }

    while (v69 != 3);
    ++v67;
  }

  while (v67 != v66);
LABEL_86:
  uint64_t v78 = 0LL;
  uint64_t v79 = 1;
  while (1)
  {
    uint64_t v80 = *((void *)&v252.st_dev + v78);
    if (v80 == -1LL) {
      goto LABEL_92;
    }
    if (v80 == -2LL)
    {
      uint64_t v127 = "too many cluster entries";
      uint64_t v128 = 1164;
      unsigned int v129 = 0;
      goto LABEL_149;
    }

    unint64_t v81 = v80 + 1;
    uint64_t v82 = v15 + 8 * v78;
    *(void *)(v82 + 1240) = v80 + 1;
    if (v80 >> 34) {
      break;
    }
    uint64_t v83 = calloc(v81, 8uLL);
    *(void *)(v82 + 1264) = v83;
    if (!v83) {
      goto LABEL_148;
    }
    memset(v83, 255, 8 * v81);
LABEL_92:
    uint64_t v79 = v78++ < 2;
    if (v78 == 3) {
      goto LABEL_151;
    }
  }

  *__error() = 12;
  *(void *)(v82 + 1264) = 0LL;
LABEL_148:
  unsigned int v129 = *__error();
  uint64_t v127 = "malloc";
  uint64_t v128 = 1168;
LABEL_149:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"stateAllocClusters",  v128,  120,  v129,  v127,  v63,  v64,  v247);
  if (v79)
  {
    uint64_t v125 = "allocating clusters";
    int v126 = 1367;
    goto LABEL_277;
  }

LABEL_87:
          memcpy((void *)(v43 + *v20), v15, __smax);
LABEL_88:
          *v20 += __smax;
LABEL_89:
          rsize_t v46 = *(void *)(a1 + 4776) - __smax;
          *(void *)(a1 + 4776) = v46;
          if (v46 || (processEntry_0((_BYTE *)a1, a2, __src, __smax, a5, a6, a7, a8) & 0x80000000) == 0) {
            return 0LL;
          }
          AAFieldKey v13 = "entry processing";
          __int16 v14 = 693;
          goto LABEL_93;
        }

        goto LABEL_68;
      }

      if (*(void *)(v36 + 24))
      {
        uint64_t v25 = 0LL;
        rsize_t v37 = __smax;
        while (1)
        {
          uint64_t v27 = (*(uint64_t (**)(void, char *, rsize_t))(v36 + 24))(*(void *)v36, v15, v37);
          if (v27 < 1) {
            goto LABEL_57;
          }
          v15 += v27;
          v25 += v27;
          v37 -= v27;
          if (!v37) {
            goto LABEL_69;
          }
        }
      }
    }

LABEL_98:
      AAFieldKey v48 = v41;
      goto LABEL_99;
    }

    goto LABEL_68;
  }

  if (v16 == 4997953)
  {
    uint64_t v17 = *(void *)(a1 + 4832);
    BOOL v18 = __CFADD__(v17, __smax);
    unint64_t v19 = v17 + __smax;
    if (!v18 && (v19 & 0x8000000000000000LL) == 0)
    {
      __int16 v20 = (void *)(a1 + 4832);
      size_t v21 = *(void *)(a1 + 4840);
      if (v21 >= v19) {
        goto LABEL_74;
      }
      do
      {
        while (!v21)
        {
          size_t v21 = 0x4000LL;
          if (v19 <= 0x4000)
          {
            uint32_t v23 = (void **)(a1 + 4848);
            size_t v21 = 0x4000LL;
            goto LABEL_72;
          }
        }

        size_t v22 = v21 >> 1;
        if ((v21 & (v21 >> 1)) != 0) {
          size_t v22 = v21 & (v21 >> 1);
        }
        v21 += v22;
      }

      while (v21 < v19);
      uint32_t v23 = (void **)(a1 + 4848);
      if (v21 >= 0x2000000001LL) {
        goto LABEL_83;
      }
LABEL_72:
      uint64_t v41 = *v23;
      uint64_t v42 = realloc(*v23, v21);
      if (v42)
      {
        *(void *)(a1 + 4848) = v42;
        *(void *)(a1 + 4840) = v21;
LABEL_74:
        uint64_t v43 = *(void *)(a1 + 4848);
        if (!v15) {
          goto LABEL_80;
        }
        goto LABEL_87;
      }

      goto LABEL_98;
    }

    goto LABEL_68;
  }

  return result;
}

      size_t v71 = *v50;
      unint64_t v67 = (char *)realloc(*v50, v48);
      if (v67)
      {
        *(void *)(a1 + 1120) = v67;
        *(void *)(a1 + 1112) = v48;
        int v45 = *(void *)(a1 + 1104);
        goto LABEL_100;
      }

      free(v71);
LABEL_111:
      *size_t v50 = 0LL;
      *size_t v47 = 0LL;
      *(void *)(a1 + 1112) = 0LL;
      goto LABEL_112;
    }

    unint64_t v67 = *(char **)(a1 + 1120);
    if (v67)
    {
LABEL_100:
      memset_s(&v67[v45], a4, 0, a4);
      int v45 = *v47;
    }

    *size_t v47 = v45 + a4;
    if ((a4 & 0x8000000000000000LL) != 0)
    {
LABEL_112:
      uint64_t v17 = "inserting blob placeholder";
      BOOL v18 = 964;
      goto LABEL_10;
    }

    __int16 v72 = v83;
    if (v83)
    {
      uint64_t v54 = 0;
      AAHeader v73 = v84;
      do
      {
        if (v72 == 47) {
          ++v54;
        }
        unint64_t v74 = *v73++;
        __int16 v72 = v74;
      }

      while (v74);
    }

    else
    {
      uint64_t v54 = 0;
    }

    size_t v53 = a4;
  }

  else
  {
    int v45 = 0LL;
    size_t v53 = 0LL;
    uint64_t v54 = 0;
  }

  unint64_t v55 = *(void *)(a1 + 1136);
  unint64_t v56 = *(void *)(a1 + 1128);
  if (v55 >= v56)
  {
    size_t v63 = 2 * v56;
    if (!v56) {
      size_t v63 = 256LL;
    }
    *(void *)(a1 + 1128) = v63;
    if ((unint64_t)(72 * v63) < 0x2000000001LL)
    {
      ssize_t v66 = *(void **)(a1 + 1144);
      unint64_t v57 = (char *)realloc(v66, 72 * v63);
      if (v57)
      {
        *(void *)(a1 + 1144) = v57;
        unint64_t v55 = *(void *)(a1 + 1136);
        goto LABEL_91;
      }

      free(v66);
    }

    else
    {
      *__error() = 12;
    }

    *(void *)(a1 + 1144) = 0LL;
    uint64_t v68 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"stateAppendEntry",  973,  120,  *v68,  "malloc",  v69,  v70,  v75);
    *(void *)(a1 + 1128) = 0LL;
    *(void *)(a1 + 1136) = 0LL;
    return 0xFFFFFFFFLL;
  }

  unint64_t v57 = *(char **)(a1 + 1144);
LABEL_91:
  *(void *)(a1 + 1136) = v55 + 1;
  __int16 v20 = &v57[72 * v55];
  *((_DWORD *)v20 + 15) = value;
  *((_DWORD *)v20 + 16) = v77;
  *(void *)__int16 v20 = a3;
  *((void *)v20 + 1) = a4;
  *((void *)v20 + 2) = v80;
  *((void *)v20 + 3) = v79;
  *((void *)v20 + 4) = v78;
  *((void *)v20 + 5) = v45;
  *((void *)v20 + 6) = v53;
  *((_WORD *)v20 + 34) = v54;
  *((_DWORD *)v20 + 14) = -1;
LABEL_15:
  uint64_t result = 0LL;
  if (a5) {
    *a5 = v20;
  }
  return result;
}

      if (*v20 == 103 && AAHeaderAssign(*(AAHeader *)(a1 + 96), *(AAHeader *)(a1 + 88)) < 0)
      {
        uint64_t v16 = "update global header";
        uint64_t v17 = 330;
        goto LABEL_242;
      }

      uint64_t v10 = *(_BYTE **)(a1 + 64);
    }

    if ((uint64_t v82 = *(AAHeader_impl **)(a1 + 88)) != 0LL
      && (v83.ikey = 5521744, unint64_t v84 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 88), v83), (v84 & 0x80000000) == 0)
      && ((unsigned int FieldString = AAHeaderGetFieldString(v82, v84, 0x400uLL, &__s, 0LL), FieldString <= 1)
        ? (size_t v86 = 1)
        : (size_t v86 = FieldString),
          v86 < 0 || FieldString < 2))
    {
      if (v86 < 0) {
        goto LABEL_144;
      }
    }

    else
    {
      ssize_t v87 = 0LL;
      size_t v88 = v19 - 512;
      do
      {
        if (!v88[v87]) {
          break;
        }
        ++v87;
      }

      while (v87 != 100);
      for (uint64_t i = 0LL; i != 155; ++i)
      {
        if (!v19[i - 167]) {
          break;
        }
      }

      do
      {
        uint64_t v90 = v87;
        if (!v87) {
          break;
        }
        --v87;
      }

      while (v88[v90 - 1] == 47);
      unsigned int v91 = i - 1022;
      while (v91 != -1022)
      {
        unsigned int v92 = v19[v91-- + 854];
        if (v92 != 47)
        {
          if (v90 + v91 >= 0xFFFFFFFFFFFFFBFFLL)
          {
            __memcpy_chk();
            unsigned int v93 = v91 + 1024;
            v149[v91 + 1021] = 47;
            goto LABEL_123;
          }

uint64_t cancelProc_1(uint64_t result)
{
  uint64_t v1 = (unsigned int *)(result + 8);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

uint64_t processEntry_0( _BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v127 = *MEMORY[0x1895F89C0];
  size_t length = 0LL;
  memset(&v106, 0, sizeof(v106));
  AAHashFunction hash_function = 0;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  *(_OWORD *)uint64_t value = 0u;
  __int128 v109 = 0u;
  unint64_t v9 = *(void *)a1;
  uint64_t v10 = a1 + 2492;
  int v11 = a1[2492];
  if (a1[2492]) {
    BOOL v12 = strcmp(a1 + 2492, a1 + 3516) == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if ((v9 & 2) != 0) {
    uint64_t v13 = 0x20000000000001LL;
  }
  else {
    uint64_t v13 = 0x20000000000000LL;
  }
  __int16 v14 = a1 + 2416;
  char v15 = a1[2416];
  if ((v15 & 1) != 0)
  {
    if (*((void *)a1 + 304) != *((void *)a1 + 598))
    {
      uint64_t v24 = "blob size mismatch";
      __int16 v25 = 235;
      goto LABEL_31;
    }

    *((void *)a1 + 303) = *((void *)a1 + 600);
  }

  if ((v15 & 2) != 0)
  {
    if (*((void *)a1 + 306) != *((void *)a1 + 601))
    {
      uint64_t v24 = "blob size mismatch";
      __int16 v25 = 240;
      goto LABEL_31;
    }

    *((void *)a1 + 305) = *((void *)a1 + 603);
  }

  if ((v15 & 4) != 0)
  {
    if (*((void *)a1 + 308) == *((void *)a1 + 604))
    {
      *((void *)a1 + 307) = *((void *)a1 + 606);
      goto LABEL_16;
    }

    uint64_t v24 = "blob size mismatch";
    __int16 v25 = 245;
LABEL_31:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  v25,  133,  0,  v24,  a7,  a8,  (char)v98);
LABEL_32:
    rsize_t v26 = 0LL;
    uint64_t v27 = 0LL;
LABEL_33:
    int v28 = 0;
    goto LABEL_34;
  }

LABEL_158:
      __strlcat_chk();
      if ((a1[2112] & 0x20) != 0) {
LABEL_113:
      }
        __strlcat_chk();
LABEL_114:
      char v55 = a1[2184];
      if ((v55 & 2) != 0)
      {
        __strlcat_chk();
        char v55 = a1[2184];
        if ((v55 & 1) == 0)
        {
LABEL_116:
          if ((v55 & 8) == 0) {
            goto LABEL_117;
          }
          goto LABEL_162;
        }
      }

      else if ((a1[2184] & 1) == 0)
      {
        goto LABEL_116;
      }

      __strlcat_chk();
      char v55 = a1[2184];
      if ((v55 & 8) == 0)
      {
LABEL_117:
        if ((v55 & 4) == 0) {
          goto LABEL_119;
        }
        goto LABEL_118;
      }

LABEL_126:
          __strlcat_chk();
          goto LABEL_127;
        }

LABEL_118:
      __strlcat_chk();
      goto LABEL_119;
    case 'P':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 301;
        goto LABEL_31;
      }

      if (!v11)
      {
        uint64_t v24 = "no input dir";
        __int16 v25 = 303;
        goto LABEL_31;
      }

      if (*((void *)a1 + 607))
      {
        uint64_t v24 = "file stream already opened";
        __int16 v25 = 304;
        goto LABEL_31;
      }

      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  305,  133,  0,  "invalid PAT: %s",  v62,  v63,  (_BYTE)a1 + 40);
        goto LABEL_32;
      }

      uint64_t v103 = 0LL;
      uint64_t v104 = 0LL;
      uint64_t v64 = (unsigned int **)*((void *)a1 + 608);
      if (v64)
      {
        int FD = aaFileStreamGetFD(v64);
        ssize_t v66 = MappedBufferCreateWithFD(FD, 0LL, 0xFFFFFFFFFFFFFFFFLL);
        rsize_t v26 = v66;
        if (!v66)
        {
          uint64_t v89 = "mapping patch file";
          __int16 v90 = 316;
          goto LABEL_229;
        }

        size_t v69 = (void *)BXDiffMatchesOBuf((uint64_t)v66);
        unint64_t DataSize = MappedBufferGetDataSize((uint64_t)v26);
      }

      else
      {
        rsize_t v26 = 0LL;
        size_t v69 = (void *)*((void *)a1 + 611);
        unint64_t DataSize = *((void *)a1 + 609);
      }

      size_t v79 = strlen(__s);
      makePath(__s, v79);
      if (DataSize >= 9 && *v69 == 0x3031464649444952LL)
      {
        uint64_t v102 = 0LL;
        __int128 v100 = 0u;
        __int128 v101 = 0u;
        __int128 v99 = 0u;
        uint64_t v27 = (AAByteStream_impl *)AAMemoryInputStreamOpen((uint64_t)v69, DataSize, v80, v81, v82, v83, v84, v85);
        if (v27)
        {
          if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
          {
            LOBYTE(v98) = (_BYTE)a1 + 40;
            uint64_t v95 = "invalid PAT: %s";
            __int16 v96 = 339;
          }

          else
          {
            *(void *)&__int128 v100 = v114;
            *((void *)&v100 + 1) = __s;
            int v28 = 1;
            DWORD2(v101) = 1;
            LODWORD(v102) = 1;
            uint64_t v95 = "RawImagePatchInternal";
            __int16 v96 = 348;
          }
        }

        else
        {
          uint64_t v95 = "AAMemoryInputStreamOpen";
          __int16 v96 = 336;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  v96,  133,  0,  v95,  v93,  v94,  (char)v98);
        goto LABEL_33;
      }

      if ((BXDiff5GetPatchInfo((uint64_t)v69, DataSize, (uint64_t)&v103) & 0x80000000) != 0)
      {
        LOBYTE(v98) = (_BYTE)a1 + 40;
        uint64_t v89 = "invalid patch: %s";
        __int16 v90 = 353;
      }

      else if ((_DWORD)v104)
      {
        size_t v86 = aaArchiveFileOutputStreamOpenAt( -1,  __s,  v103,  *((_DWORD *)a1 + 622),  0LL,  *((_DWORD *)a1 + 618),  *((void *)a1 + 310));
        *((void *)a1 + 607) = v86;
        if (v86)
        {
          if ((BXPatch5StreamWithFlags( 0LL,  0LL,  0LL,  (uint64_t)v69,  DataSize,  (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc,  (uint64_t)v86,  2LL) & 0x80000000) == 0)
          {
LABEL_201:
            AAByteStreamClose(*((AAByteStream *)a1 + 607));
            *((void *)a1 + 607) = 0LL;
            goto LABEL_202;
          }

          __int128 v98 = __s;
          uint64_t v89 = "patching failed: %s";
          __int16 v90 = 364;
        }

        else
        {
          uint64_t v89 = "file stream";
          __int16 v90 = 359;
        }
      }

      else if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        LOBYTE(v98) = (_BYTE)a1 + 40;
        uint64_t v89 = "invalid PAT: %s";
        __int16 v90 = 371;
      }

      else if (v12)
      {
        if (HIDWORD(v104))
        {
          if ((BXPatch5InPlace(__s, (uint64_t)v69, DataSize, 0, v91, v92, v67, v68) & 0x80000000) == 0)
          {
LABEL_202:
            MappedBufferDestroy(v26);
            if (!*((void *)a1 + 598) || (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) == 0)
            {
              rsize_t v26 = 0LL;
              int v28 = 1;
              goto LABEL_151;
            }

            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"processEntry",  392,  133,  0,  "apply YEC (patch)",  v87,  v88,  (char)v98);
            rsize_t v26 = 0LL;
            goto LABEL_231;
          }

          uint64_t v89 = "in-place patching failed";
          __int16 v90 = 376;
        }

        else
        {
          uint64_t v89 = "patch doesn't allow in-place";
          __int16 v90 = 375;
        }
      }

      else
      {
        __int128 v97 = aaArchiveFileOutputStreamOpenAt( -1,  __s,  v103,  *((_DWORD *)a1 + 622),  0LL,  *((_DWORD *)a1 + 618),  *((void *)a1 + 310));
        *((void *)a1 + 607) = v97;
        if (!v97)
        {
          uint64_t v89 = "file stream";
          __int16 v90 = 381;
          goto LABEL_230;
        }

        if ((BXPatch5FileWithFlags( v114,  (uint64_t)v69,  DataSize,  (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc,  (uint64_t)v97,  2LL) & 0x80000000) == 0) {
          goto LABEL_201;
        }
        __int128 v98 = __s;
        uint64_t v89 = "patching failed: %s";
        __int16 v90 = 386;
      }

      __int16 v14 = "too many blob bytes received";
      char v15 = 1443;
      goto LABEL_8;
    }

    if (v25 == 5521732)
    {
      if (!v12 || v12[274] != -1LL)
      {
        if (!v13)
        {
          if ((extractStreamSendEntryToExtractThread(a1) & 0x80000000) != 0)
          {
            __int16 v14 = "send entry to thread";
            char v15 = 1453;
            goto LABEL_8;
          }

          uint64_t v13 = *(void *)(a1 + 1640);
        }

        if ((extractThreadSendCommand(v13, 68, __smax, __src) & 0x80000000) != 0)
        {
          __int16 v14 = "sending DAT blob";
          char v15 = 1457;
          goto LABEL_8;
        }
      }

      goto LABEL_97;
    }

    if (v25 != 5521752)
    {
LABEL_97:
      size_t v51 = *v22 == __smax;
      *v22 -= __smax;
      if (!v51) {
        return 0LL;
      }
      uint32_t v52 = *(_DWORD *)(a1 + 1648);
      int v53 = (v52 + 1);
      *(_DWORD *)(a1 + 1648) = v53;
      char v54 = *(unsigned int *)(a1 + 1616);
      if (v53 < v54)
      {
        char v55 = *(void *)(a1 + 1624);
        if (!*(void *)(v55 + 24LL * v53 + 8))
        {
          char v56 = (uint64_t *)(v55 + 24LL * v53 + 32);
          char v57 = ~v53 + v54;
          uint64_t v58 = v52 + 2;
          do
          {
            LODWORD(v53) = v58;
            if (!v57) {
              break;
            }
            uint64_t v59 = *v56;
            v56 += 3;
            --v57;
            ++v58;
          }

          while (!v59);
          *(_DWORD *)(a1 + 1648) = v53;
        }
      }

      if (v53 < v54
        || (extractStreamEntryEnd(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) == 0)
      {
        return 0LL;
      }

      uint64_t v19 = "end entry failed";
      uint64_t v20 = 1472;
      goto LABEL_13;
    }

    if (!v12) {
      goto LABEL_90;
    }
    size_t v32 = v12[275];
    uint64_t v27 = __CFADD__(v32, __smax);
    uint64_t v33 = v32 + __smax;
    if (!v27 && (v33 & 0x8000000000000000LL) == 0)
    {
      uint64_t v34 = v12 + 275;
      a2 = v12[276];
      if (a2 < v33)
      {
        do
        {
          while (!a2)
          {
            a2 = 0x4000LL;
            if (v33 <= 0x4000)
            {
              uint64_t v36 = (void **)(v12 + 277);
              a2 = 0x4000LL;
              goto LABEL_72;
            }
          }

          uint64_t v35 = a2 >> 1;
          if ((a2 & (a2 >> 1)) != 0) {
            uint64_t v35 = a2 & (a2 >> 1);
          }
          a2 += v35;
        }

        while (a2 < v33);
        uint64_t v36 = (void **)(v12 + 277);
        if (a2 >= 0x2000000001LL)
        {
          uint64_t v62 = (void **)(v12 + 277);
          *__error() = 12;
          goto LABEL_114;
        }

        if (!v88) {
          goto LABEL_336;
        }
        __int128 v98 = v29;
        __int128 v99 = AAHeaderGetEncodedSize(v10);
        __int128 v100 = AAHeaderGetEncodedData(v10);
        if (bufa)
        {
          __int128 v98 = v263[4];
          if (!v98) {
            __int128 v98 = v263[3];
          }
        }

        if (*((void *)v98 + 3))
        {
          __int128 v101 = 0LL;
          if (v99)
          {
            uint64_t v102 = v99;
            while (1)
            {
              uint64_t v103 = (*((uint64_t (**)(void, const uint8_t *, size_t))v98 + 3))(*(void *)v98, v100, v102);
              if (v103 < 1) {
                break;
              }
              v100 += v103;
              v101 += v103;
              v102 -= v103;
              if (!v102) {
                goto LABEL_130;
              }
            }

            __int128 v101 = v103;
          }
        }

        else
        {
          __int128 v101 = -1LL;
        }

uint64_t applyYEC(uint64_t *a1, char *a2, const char *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *a1;
  if (!*a1) {
    return 0LL;
  }
  char v4 = (char)a3;
  uint64_t v17 = 0LL;
  memset(v16, 0, sizeof(v16));
  uint64_t v15 = 0LL;
  memset(v14, 0, sizeof(v14));
  memset(v18, 0, 172);
  uint64_t v13 = 0LL;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v10 = 0u;
  LOBYTE(v10) = 1;
  *((void *)&v10 + 1) = a1[2];
  *(void *)&__int128 v11 = v3;
  uint64_t v9 = 0LL;
  int v7 = aaCheckAndFixWithPath( v16,  (unsigned __int8 *)v14,  v18,  (unsigned __int8 *)&v10,  -1LL,  (unsigned int *)&v9,  a2,  a3,  0x20000000000000LL);
  if (v7 < 0) {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c",  (uint64_t)"applyYEC",  113,  133,  0,  "ECC failed: %s",  v5,  v6,  v4);
  }
  return (v7 >> 31);
}

_WORD *enterThreadErrorContext( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t result = pthread_getspecific(ErrorContextKey);
  if (result)
  {
    ++result[2];
  }

  else
  {
    __int128 v11 = calloc(1uLL, 0x2000uLL);
    if (v11)
    {
      v11[2] = 1;
      *((_DWORD *)v11 + 18) = 531890176;
      return (_WORD *)setThreadErrorContext(v11, v12, v13, v14, v15, v16, v17, v18, a9);
    }

    else
    {
      uint64_t v19 = __error();
      return (_WORD *)pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"createThreadErrorContext",  76,  5,  *v19,  "malloc",  v20,  v21,  a9);
    }
  }

  return result;
}

size_t setThreadErrorContext( const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = pthread_setspecific(ErrorContextKey, a1);
  if ((_DWORD)result)
  {
    uint64_t v12 = __error();
    return pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"setThreadErrorContext",  65,  5,  *v12,  "pthread_setspecific",  v13,  v14,  a9);
  }

  return result;
}

uint64_t leaveThreadErrorContext(__CFError **a1, const __CFString **a2, int a3)
{
  userInfoValues[1] = *(void **)MEMORY[0x1895F89C0];
  pthread_key_t ErrorContextKey = getErrorContextKey();
  int v7 = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (v7)
  {
    uint64_t v15 = v7;
    unsigned __int16 v16 = v7[2] - 1;
    v7[2] = v16;
    if (!v16)
    {
      uint64_t v18 = v7[36];
      uint64_t v17 = *(unsigned int *)v7;
      if (!v7[36] && (v17 & 0x80000000) == 0)
      {
        if (!v7[3] || !a2 && !a3) {
          goto LABEL_46;
        }
        bzero(userInfoKeys, 0x400uLL);
        unint64_t v35 = 0LL;
        do
        {
          size_t v36 = strlen((const char *)userInfoKeys);
          if (v36 + 20 > 0x3FF) {
            break;
          }
          if (v36) {
            snprintf((char *)userInfoKeys + v36, 1024 - v36, ",0x%08x");
          }
          else {
            snprintf((char *)userInfoKeys, 0x400uLL, "Warnings:0x%08x");
          }
          ++v35;
        }

        while (v35 < v15[3]);
        uint64_t v37 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)userInfoKeys, 0x600u);
        if (!v37) {
          goto LABEL_46;
        }
        uint64_t v38 = v37;
        if (a2)
        {
          *a2 = v37;
          goto LABEL_46;
        }

        CFIndex v45 = CFStringGetLength(v37) + 1;
        uint64_t v46 = (char *)calloc(1uLL, v45);
        if (v46)
        {
          size_t v47 = v46;
          CFStringGetCString(v38, v46, v45, 0x600u);
          fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v47);
          free(v47);
        }

        AAFieldKey v44 = v38;
LABEL_45:
        CFRelease(v44);
        goto LABEL_46;
      }

      if (!a1 && !a3) {
        goto LABEL_46;
      }
      size_t v19 = v18 + 32;
      uint64_t v20 = (char *)calloc(v18 + 32, 1uLL);
      if (!v20) {
        goto LABEL_46;
      }
      uint64_t v21 = v20;
      uint64_t v22 = v20;
      if ((v17 & 0x80000000) != 0)
      {
        snprintf(v20, v19, "Error 0x%08x\n", v17);
        uint64_t v22 = &v21[strlen(v21)];
      }

      unsigned int v23 = v15[36];
      if (v15[36])
      {
        unsigned int v24 = 0;
        do
        {
          __int16 v25 = (unsigned __int16 *)((char *)v15 + v24 + 76);
          unsigned int v26 = *v25;
          unsigned int v27 = v26 + v24;
          if (v26 < 4 || v27 > v23) {
            break;
          }
          size_t v29 = v26 - 3;
          memcpy(v22, v25 + 1, v29);
          uint64_t v30 = &v22[v29];
          *uint64_t v30 = 10;
          uint64_t v22 = v30 + 1;
          unsigned int v24 = (unsigned __int16)v27;
          unsigned int v23 = v15[36];
        }

        while (v23 > (unsigned __int16)v27);
      }

      if (v22 > v21) {
        *(v22 - 1) = 0;
      }
      uint64_t v31 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFStringRef v32 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v21, 0x600u);
      if (!v32)
      {
        free(v21);
        goto LABEL_46;
      }

      CFStringRef v33 = v32;
      userInfoKeys[0] = *(void **)MEMORY[0x189604F68];
      userInfoValues[0] = (void *)v32;
      uint64_t v34 = CFErrorCreateWithUserInfoKeysAndValues( v31,  @"com.apple.ParallelCompression",  1LL,  (const void *const *)userInfoKeys,  (const void *const *)userInfoValues,  1LL);
      CFRelease(v33);
      free(v21);
      if (v34)
      {
        if (!a1)
        {
          uint64_t v39 = CFErrorCopyDescription(v34);
          if (v39)
          {
            uint64_t v40 = v39;
            CFIndex v41 = CFStringGetLength(v39) + 1;
            uint32_t v42 = (char *)calloc(1uLL, v41);
            if (v42)
            {
              uint64_t v43 = v42;
              CFStringGetCString(v40, v42, v41, 0x600u);
              fprintf((FILE *)*MEMORY[0x1895F89D0], "%s\n", v43);
              free(v43);
            }

            CFRelease(v40);
          }

          AAFieldKey v44 = v34;
          goto LABEL_45;
        }

        *a1 = v34;
      }

size_t appendThreadErrorContextString(size_t result)
{
  if (result)
  {
    uint64_t v1 = (const void *)result;
    size_t result = strlen((const char *)result);
    if (result - 8193 >= 0xFFFFFFFFFFFFE000LL)
    {
      size_t v2 = result;
      pthread_key_t ErrorContextKey = getErrorContextKey();
      size_t result = (size_t)pthread_getspecific(ErrorContextKey);
      if (result)
      {
        size_t v4 = result;
        __int16 v5 = v2 + 3;
        uint64_t v6 = *(unsigned __int16 *)(result + 72);
        if (v6 + (unsigned __int16)(v2 + 3) <= *(unsigned __int16 *)(result + 74))
        {
          size_t v7 = result + v6;
          *(_WORD *)(v7 + 76) = v5;
          size_t v8 = v7 + 78;
          size_t result = (size_t)memcpy((void *)(v7 + 78), v1, v2);
          *(_BYTE *)(v8 + v2) = 0;
          *(_WORD *)(v4 + 72) += v5;
        }
      }
    }
  }

  return result;
}

_WORD *updateThreadErrorContextErrorCode(_WORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    size_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*(_DWORD *)result & 0x80000000) == 0)
      {
        *(_DWORD *)size_t result = v1;
        result[3] = 0;
      }
    }
  }

  return result;
}

_DWORD *updateThreadErrorContextWarningCode(_DWORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    size_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*result & 0x80000000) == 0)
      {
        uint64_t v3 = *((unsigned __int16 *)result + 3);
        if (v3 <= 0xF)
        {
          result[v3 + 2] = v1;
          *((_WORD *)result + 3) = v3 + 1;
        }
      }
    }
  }

  return result;
}

unsigned __int16 *saveThreadErrorContext(void *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    size_t v4 = result;
    bzero(a1, 0x2000uLL);
    uint64_t v5 = v4[36];
    else {
      size_t v6 = 0LL;
    }
    return (unsigned __int16 *)memcpy(a1, v4, v6);
  }

  return result;
}

unsigned __int16 *restoreThreadErrorContext(__int128 *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    __int128 v4 = a1[1];
    __int128 v13 = *a1;
    __int128 v14 = v4;
    __int128 v5 = a1[3];
    __int128 v15 = a1[2];
    *(_OWORD *)unsigned __int16 v16 = v5;
    *(_OWORD *)&v16[12] = *(__int128 *)((char *)a1 + 60);
    if ((v13 & 0x80000000) == 0)
    {
      unsigned int v6 = WORD3(v13);
      if ((*(_DWORD *)result & 0x80000000) != 0 && WORD3(v13) <= 0xFu)
      {
        unsigned int v6 = WORD3(v13) + 1;
        *((_DWORD *)&v13 + WORD3(v13) + 2) = *(_DWORD *)result;
      }

      unint64_t v7 = result[3];
      if (result[3] && v6 <= 0xF)
      {
        unint64_t v8 = 0LL;
        do
        {
          int v9 = *(_DWORD *)&result[2 * v8 + 4];
          if (v8 >= v6 || *((_DWORD *)&v13 + v8 + 2) != v9)
          {
            uint64_t v10 = v6++;
            *((_DWORD *)&v13 + v10 + 2) = v9;
          }

          ++v8;
        }

        while (v8 < v7 && v6 < 0x10);
      }

      WORD3(v13) = v6;
    }

    __int128 v11 = *(_OWORD *)v16;
    *((_OWORD *)result + 2) = v15;
    *((_OWORD *)result + 3) = v11;
    *(_OWORD *)(result + 30) = *(_OWORD *)&v16[12];
    __int128 v12 = v14;
    *(_OWORD *)size_t result = v13;
    *((_OWORD *)result + 1) = v12;
  }

  return result;
}

uint64_t createThread(pthread_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  *(void *)__relative_priority = 0LL;
  unint64_t v8 = calloc(1uLL, 0x2000uLL);
  if (!v8)
  {
    size_t v19 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"createThread",  552,  5,  *v19,  "malloc",  v20,  v21,  v36[0]);
    return -*__error();
  }

  int v9 = v8;
  uint64_t v10 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v10)
  {
    uint64_t v22 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"createThread",  555,  5,  *v22,  "malloc",  v23,  v24,  v36[0]);
    __int16 v25 = __error();
    uint64_t v13 = -*v25;
    if (!*v25) {
      return v13;
    }
    goto LABEL_10;
  }

  __int128 v11 = v10;
  uint64_t v12 = pthread_attr_init(v10);
  if ((_DWORD)v12)
  {
    uint64_t v13 = v12;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_init";
    __int16 v18 = 558;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"createThread",  v18,  5,  v14,  v17,  v15,  v16,  v36[0]);
    goto LABEL_6;
  }

  if (a4)
  {
    uint64_t v28 = pthread_attr_setstacksize(v11, a4);
    if ((_DWORD)v28)
    {
      uint64_t v13 = v28;
      int v14 = *__error();
      uint64_t v17 = "pthread_attr_setstacksize";
      __int16 v18 = 564;
      goto LABEL_5;
    }
  }

  size_t v29 = pthread_self();
  uint64_t qos_class_np = pthread_get_qos_class_np(v29, (qos_class_t *)&__relative_priority[1], __relative_priority);
  if ((_DWORD)qos_class_np)
  {
    uint64_t v13 = qos_class_np;
    int v14 = *__error();
    uint64_t v17 = "pthread_get_qos_class_np";
    __int16 v18 = 570;
    goto LABEL_5;
  }

  uint64_t v31 = pthread_attr_set_qos_class_np(v11, (qos_class_t)__relative_priority[1], __relative_priority[0]);
  if ((_DWORD)v31)
  {
    uint64_t v13 = v31;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_set_qos_class_np";
    __int16 v18 = 572;
    goto LABEL_5;
  }

  v36[0] = MEMORY[0x1895F87A8];
  v36[1] = 0x40000000LL;
  v36[2] = __createThread_block_invoke;
  v36[3] = &__block_descriptor_tmp;
  v36[4] = v9;
  dispatch_block_t v32 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v36);
  v9[2] = v32;
  if (v32)
  {
    void *v9 = a2;
    v9[1] = a3;
    *((_DWORD *)v9 + 7) = 1;
    *((_DWORD *)v9 + 24) = 530317312;
    uint64_t v13 = pthread_create(a1, v11, (void *(__cdecl *)(void *))threadWrapperProc, v9);
    if ((_DWORD)v13)
    {
      int v14 = *__error();
      uint64_t v17 = "pthread_create";
      __int16 v18 = 591;
      goto LABEL_5;
    }
  }

  else
  {
    CFStringRef v33 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"createThread",  578,  5,  *v33,  "dispatch_block_create",  v34,  v35,  v36[0]);
    uint64_t v13 = -*__error();
  }

uint64_t __createThread_block_invoke(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))(*(void *)(*(void *)(a1 + 32) + 8LL));
}

uint64_t threadWrapperProc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return a1;
}

uint64_t joinThread(_opaque_pthread_t *a1)
{
  unsigned int v27 = 0LL;
  uint64_t v1 = pthread_join(a1, &v27);
  if ((_DWORD)v1)
  {
    uint64_t v4 = v1;
    __int128 v5 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"joinThread",  623,  5,  *v5,  "pthread_join",  v6,  v7,  v26);
    unint64_t v8 = 0LL;
    goto LABEL_26;
  }

  unint64_t v8 = v27;
  if (*((_WORD *)v27 + 14) != 1)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  (uint64_t)"joinThread",  627,  5,  0,  "expected ref_count=1 for terminating thread",  v2,  v3,  v26);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }

  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t v10 = pthread_getspecific(ErrorContextKey);
  if (!v10) {
    goto LABEL_25;
  }
  uint64_t v11 = v10;
  int v12 = *v10;
  if ((*v10 & 0x80000000) == 0)
  {
    int v13 = v8[6];
    if (v13 < 0)
    {
      _DWORD *v10 = v13;
      int v12 = v13;
    }
  }

  unsigned int v14 = *((unsigned __int16 *)v8 + 48);
  if (!*((_WORD *)v8 + 48))
  {
LABEL_15:
    if (v12)
    {
      uint64_t v4 = 0LL;
      *((_WORD *)v11 + 3) = 0;
      goto LABEL_26;
    }

    if (*((_WORD *)v8 + 15))
    {
      unint64_t v19 = 0LL;
      uint64_t v20 = *((unsigned __int16 *)v11 + 3);
      LODWORD(v21) = 16 - v20;
      else {
        uint64_t v21 = 0LL;
      }
      uint64_t v22 = (uint64_t)&v11[v20 + 2];
      __int16 v23 = v20 + 1;
      do
      {
        if (v21 == v19) {
          break;
        }
        *(_DWORD *)(v22 + 4 * v19) = v8[v19 + 8];
        *((_WORD *)v11 + 3) = v23 + v19++;
      }

      while (v19 < *((unsigned __int16 *)v8 + 15));
    }

size_t ParallelCompressionUpdateError(_WORD *a1, size_t a2)
{
  return appendThreadErrorContextString(a2);
}

uint64_t getErrorContextKey()
{
  if (pthread_once(&getErrorContextKey_errorContextOnce, (void (*)(void))createErrorContextKey))
  {
    uint64_t v0 = __error();
    pc_log_error( "/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  "getErrorContextKey",  53LL,  5LL,  *v0,  "pthread_once");
  }

  return gErrorContextKey;
}

uint64_t createErrorContextKey()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&gErrorContextKey, 0LL);
  if ((_DWORD)result)
  {
    uint64_t v1 = __error();
    return pc_log_error( "/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c",  "createErrorContextKey",  42LL,  5LL,  *v1,  "pthread_key_create");
  }

  return result;
}

AAArchiveStream AAConvertArchiveOutputStreamOpen( AAArchiveStream stream, AAFieldKeySet insert_key_set, AAFieldKeySet remove_key_set, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  int v13 = (AAArchiveStream **)malloc(0x38uLL);
  unsigned int v14 = v13;
  if (v13) {
    memset_s(v13, 0x38uLL, 0, 0x38uLL);
  }
  unsigned int v15 = (AAArchiveStream *)malloc(0x310uLL);
  uint64_t v16 = v15;
  if (!v15 || (memset_s(v15, 0x310uLL, 0, 0x310uLL), !v14))
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 507;
LABEL_11:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"AAConvertArchiveOutputStreamOpen",  v23,  111,  v21,  v22,  v18,  v19,  v25);
    free(v14);
    convertStreamClose((uint64_t)v16);
    return 0LL;
  }

  *uint64_t v16 = stream;
  v16[1] = AAFieldKeySetClone(insert_key_set);
  AAFieldKeySet v17 = AAFieldKeySetClone(remove_key_set);
  v16[2] = v17;
  if (!v16[1] || !v17)
  {
    uint64_t v22 = "copy key set";
    __int16 v23 = 512;
    int v21 = 0;
    goto LABEL_11;
  }

  v16[3] = (AAArchiveStream)flags;
  _OWORD v16[4] = (AAArchiveStream)msg_data;
  v16[5] = (AAArchiveStream)msg_proc;
  v16[12] = (AAArchiveStream)0x10000;
  uint64_t v20 = (AAArchiveStream_impl *)malloc(0x10000uLL);
  v16[13] = v20;
  if (!v20)
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 518;
    goto LABEL_11;
  }

  _OWORD v14[3] = (AAArchiveStream *)convertStreamWriteHeader;
  v14[4] = (AAArchiveStream *)convertStreamWriteBlob;
  *unsigned int v14 = v16;
  v14[1] = (AAArchiveStream *)convertStreamClose;
  v14[2] = (AAArchiveStream *)convertStreamAbort;
  return (AAArchiveStream)v14;
}

uint64_t convertStreamClose(uint64_t a1)
{
  if (a1)
  {
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 8));
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 16));
    AAHeaderDestroy(*(AAHeader *)(a1 + 56));
    OECCStreamDestroy(*(void ***)(a1 + 776));
    free(*(void **)(a1 + 128));
    memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 104));
    free(*(void **)(a1 + 88));
    memset_s((void *)(a1 + 80), 0x10uLL, 0, 0x10uLL);
    free((void *)a1);
  }

  return 0LL;
}

uint64_t convertStreamWriteHeader(uint64_t a1, AAHeader header)
{
  uint64_t v87 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 48)) {
    return 0LL;
  }
  uint64_t value = 0LL;
  *(_OWORD *)uint64_t v81 = 0u;
  __int128 v82 = 0u;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 112) = 0LL;
  v6.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v6);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    unsigned int v15 = "Invalid entry missing TYP field (skipped)";
    __int16 v16 = 237;
LABEL_10:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamWriteHeader",  v16,  111,  v15,  v8,  v9,  v10,  v72);
LABEL_11:
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 52) = 1;
    return result;
  }

  v11.uint64_t ikey = 5521744;
  uint32_t v12 = AAHeaderGetKeyIndex(header, v11);
  if ((v12 & 0x80000000) != 0)
  {
    int v14 = 0;
  }

  else
  {
    unsigned int FieldString = AAHeaderGetFieldString(header, v12, 0x400uLL, __s, 0LL);
    if (FieldString <= 1) {
      int v14 = 1;
    }
    else {
      int v14 = FieldString;
    }
  }

  if (v14 <= 0 && value != 77)
  {
    unsigned int v15 = "Invalid non metadata entry missing PAT field (skipped)";
    __int16 v16 = 244;
    goto LABEL_10;
  }

  if (v14 >= 1)
  {
    AAFieldKeySet v17 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 40);
    if (v17)
    {
      int v18 = v17(*(void *)(a1 + 32), 40LL, __s, header);
      if (v18 < 0) {
        goto LABEL_103;
      }
      if (v18) {
        goto LABEL_11;
      }
      int v19 = (*(uint64_t (**)(void, uint64_t, char *, _BYTE *))(a1 + 40))( *(void *)(a1 + 32),  41LL,  __s,  v85);
      if (v19 < 0)
      {
LABEL_103:
        *(_DWORD *)(a1 + 48) = 1;
        return 0xFFFFFFFFLL;
      }

      if (v19) {
        __strlcpy_chk();
      }
    }
  }

  if (value == 77 && (*(_BYTE *)(a1 + 25) & 2) != 0) {
    goto LABEL_11;
  }
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 80, header) & 0x80000000) != 0)
  {
    uint64_t v70 = "capturing non-empty blobs";
    __int16 v71 = 262;
    goto LABEL_132;
  }

  AAHeader v22 = AAHeaderCreate();
  *(void *)(a1 + 56) = v22;
  if (!v22)
  {
    uint64_t v70 = "create new header";
    __int16 v71 = 266;
LABEL_132:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamWriteHeader",  v71,  111,  0,  v70,  v20,  v21,  v72);
    if (!*(_DWORD *)(a1 + 48))
    {
      *(_DWORD *)(a1 + 48) = 1;
      AAArchiveStreamCancel(*(AAArchiveStream *)a1);
    }

    return 0xFFFFFFFFLL;
  }

  uint32_t FieldCount = AAHeaderGetFieldCount(header);
  if (!FieldCount) {
    goto LABEL_108;
  }
  uint32_t v29 = FieldCount;
  int v73 = 0;
  uint32_t v30 = 0;
  uint64_t v72 = a1 + 144;
  do
  {
    AAFieldKey FieldKey = AAHeaderGetFieldKey(header, v30);
    AAFieldKey v32 = FieldKey;
    int v33 = AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 16), v32);
    uint64_t v34 = *(void *)FieldKey.skey & 0xFFFFFFLL;
    if ((*(void *)FieldKey.skey & 0xFFFFFFLL) == 0x544144)
    {
      size.tv_seCC_SHA1_CTX c = 0LL;
      uint64_t offset = 0LL;
      if (AAHeaderGetFieldBlob(header, v30, (uint64_t *)&size, &offset) < 0)
      {
        uint64_t v70 = "getting header blob field";
        __int16 v71 = 290;
        goto LABEL_132;
      }

      if (!v33
        || ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (uint64_t v35 = 5521744LL) : (uint64_t v35 = 5265748LL), v34 == v35))
      {
        AAFieldKey v36 = FieldKey;
        if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v36, size.tv_sec) < 0)
        {
          uint64_t v70 = "inserting header field";
          __int16 v71 = 295;
          goto LABEL_132;
        }

        int v73 = 1;
      }

      v37.uint64_t ikey = 3229779;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v37))
      {
        v38.uint64_t ikey = 3229779;
        if (AAHeaderGetKeyIndex(header, v38) < 0)
        {
          v39.uint64_t ikey = 3229779;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v39, 2u, v81) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 300;
            goto LABEL_132;
          }

          *(_BYTE *)(a1 + 136) |= 2u;
          CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)(a1 + 160));
        }
      }

      v40.uint64_t ikey = 3295315;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v40))
      {
        v41.uint64_t ikey = 3295315;
        if (AAHeaderGetKeyIndex(header, v41) < 0)
        {
          v42.uint64_t ikey = 3295315;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v42, 3u, v81) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 306;
            goto LABEL_132;
          }

          *(_BYTE *)(a1 + 136) |= 4u;
          CC_SHA256_Init((CC_SHA256_CTX *)(a1 + 256));
        }
      }

      v43.uint64_t ikey = 3360851;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v43))
      {
        v44.uint64_t ikey = 3360851;
        if (AAHeaderGetKeyIndex(header, v44) < 0)
        {
          v45.uint64_t ikey = 3360851;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v45, 4u, v81) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 312;
            goto LABEL_132;
          }

          *(_BYTE *)(a1 + 136) |= 8u;
          CC_SHA384_Init((CC_SHA512_CTX *)(a1 + 360));
        }
      }

      v46.uint64_t ikey = 3491923;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v46))
      {
        v47.uint64_t ikey = 3491923;
        if (AAHeaderGetKeyIndex(header, v47) < 0)
        {
          v48.uint64_t ikey = 3491923;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v48, 5u, v81) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 318;
            goto LABEL_132;
          }

          *(_BYTE *)(a1 + 136) |= 0x10u;
          CC_SHA512_Init((CC_SHA512_CTX *)(a1 + 568));
        }
      }

      v49.uint64_t ikey = 5458755;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v49))
      {
        v50.uint64_t ikey = 5458755;
        if (AAHeaderGetKeyIndex(header, v50) < 0)
        {
          v51.uint64_t ikey = 5458755;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v51, 1u, v81) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 324;
            goto LABEL_132;
          }

          *(_BYTE *)(a1 + 136) |= 1u;
          CC_CKSUM_Init(v72);
        }
      }

      v52.uint64_t ikey = 5917011;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v52))
      {
        v53.uint64_t ikey = 5917011;
        if (AAHeaderGetKeyIndex(header, v53) < 0)
        {
          v54.uint64_t ikey = 5917011;
          if (AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v54, size.tv_sec) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 330;
            goto LABEL_132;
          }
        }
      }

      v55.uint64_t ikey = 4408665;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v55))
      {
        v56.uint64_t ikey = 4408665;
        if (AAHeaderGetKeyIndex(header, v56) < 0)
        {
          if (size.tv_sec)
          {
            v57.uint64_t ikey = 4408665;
            if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v57, 0LL) < 0)
            {
              uint64_t v70 = "inserting header field";
              __int16 v71 = 334;
              goto LABEL_132;
            }

            *(_BYTE *)(a1 + 136) |= 0x20u;
            uint64_t v58 = OECCStreamCreate(1, 0x4000u, size.tv_sec);
            *(void *)(a1 + 776) = v58;
            if (!v58)
            {
              uint64_t v70 = "creating YEC context";
              __int16 v71 = 337;
              goto LABEL_132;
            }
          }
        }
      }

      if (!v33
        || ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (uint64_t v59 = 5521744LL) : (uint64_t v59 = 5265748LL), v34 == v59))
      {
        if (*(_DWORD *)(a1 + 136))
        {
          uint64_t v70 = "can't generate a field from DAT, and keep DAT at the same time";
          __int16 v71 = 342;
          goto LABEL_132;
        }
      }
    }

    if (v33)
    {
      if ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F)
      {
        if (v34 == 5521744)
        {
LABEL_85:
          size_t v63 = strlen(__s);
          AAFieldKey v64 = FieldKey;
          if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v64, __s, v63) < 0)
          {
            uint64_t v70 = "inserting header field";
            __int16 v71 = 350;
            goto LABEL_132;
          }

          goto LABEL_86;
        }

        uint64_t v60 = 5653828LL;
        goto LABEL_80;
      }

      if (v34 != 4935244)
      {
        uint64_t v60 = 5265748LL;
LABEL_80:
        if (v34 != v60) {
          goto LABEL_86;
        }
      }
    }

    else if (v34 == 5521744)
    {
      goto LABEL_85;
    }

    if (v34 != 5521732)
    {
      int FieldType = AAHeaderGetFieldType(header, v30);
      uint64_t v78 = 0LL;
      uint64_t offset = 0LL;
      uint64_t v76 = 0LL;
      uint64_t v77 = 0LL;
      AAHashFunction hash_function = 0;
      size.tv_seCC_SHA1_CTX c = 0LL;
      size.tv_nseCC_SHA1_CTX c = 0LL;
      switch(FieldType)
      {
        case 0:
          AAFieldKey v62 = FieldKey;
          if ((AAHeaderSetFieldFlag(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v62) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          uint64_t v70 = "inserting header field";
          __int16 v71 = 375;
          goto LABEL_132;
        case 1:
          if (AAHeaderGetFieldUInt(header, v30, &v76) < 0)
          {
            uint64_t v70 = "Invalid input header";
            __int16 v71 = 367;
            goto LABEL_132;
          }

          AAFieldKey v65 = FieldKey;
          if ((AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v65, v76) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          uint64_t v70 = "inserting header field";
          __int16 v71 = 368;
          break;
        case 2:
          if (AAHeaderGetFieldString(header, v30, *(void *)(a1 + 96), *(char **)(a1 + 104), &offset) < 0)
          {
            uint64_t v70 = "Invalid input header";
            __int16 v71 = 371;
            goto LABEL_132;
          }

          AAFieldKey v66 = FieldKey;
          uint64_t v70 = "inserting header field";
          __int16 v71 = 372;
          goto LABEL_132;
        case 3:
          if (AAHeaderGetFieldHash(header, v30, *(void *)(a1 + 96), &hash_function, *(uint8_t **)(a1 + 104)) < 0)
          {
            uint64_t v70 = "Invalid input header";
            __int16 v71 = 378;
            goto LABEL_132;
          }

          AAFieldKey v67 = FieldKey;
          if ((AAHeaderSetFieldHash( *(AAHeader *)(a1 + 56),  0xFFFFFFFF,  v67,  hash_function,  *(const uint8_t **)(a1 + 104)) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          uint64_t v70 = "inserting header field";
          __int16 v71 = 379;
          goto LABEL_132;
        case 4:
          if (AAHeaderGetFieldTimespec(header, v30, &size) < 0)
          {
            uint64_t v70 = "Invalid input header";
            __int16 v71 = 382;
            goto LABEL_132;
          }

          AAFieldKey v68 = FieldKey;
          if ((AAHeaderSetFieldTimespec(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v68, &size) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          uint64_t v70 = "inserting header field";
          __int16 v71 = 383;
          goto LABEL_132;
        case 5:
          if (AAHeaderGetFieldBlob(header, v30, &v78, &v77) < 0)
          {
            uint64_t v70 = "Invalid input header";
            __int16 v71 = 363;
            goto LABEL_132;
          }

          AAFieldKey v69 = FieldKey;
          if ((AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v69, v78) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          uint64_t v70 = "inserting header field";
          __int16 v71 = 364;
          goto LABEL_132;
        default:
          uint64_t v70 = "Invalid header field type";
          __int16 v71 = 385;
          goto LABEL_132;
      }

      goto LABEL_132;
    }

LABEL_108:
  *(_DWORD *)(a1 + 76) = 0;
  if ((convertStreamToNextNonEmptyBlob(a1, v24, v25, v26, v27, v28, v20, v21) & 0x80000000) != 0)
  {
    uint64_t v70 = "iterating to next blob";
    __int16 v71 = 396;
    goto LABEL_132;
  }

  if (*(_DWORD *)(a1 + 76) >= *(_DWORD *)(a1 + 80) && (convertStreamEndEntry(a1) & 0x80000000) != 0)
  {
    uint64_t v70 = "finishing entry";
    __int16 v71 = 399;
    goto LABEL_132;
  }

  return 0LL;
}

    a1[3] = v81;
  }

  uint64_t v91 = a1[4];
  if (v91)
  {
    if ((v91 & 0x8000000000000000LL) != 0)
    {
LABEL_155:
      __int16 v16 = "XAT blob";
      AAFieldKeySet v17 = 319;
      goto LABEL_9;
    }

    uint64_t v92 = (void *)(v72 + 984 * v73 + 80);
    uint64_t v93 = v72 + 984 * v73;
    __int16 v96 = *(void *)(v93 + 88);
    uint64_t v95 = (size_t *)(v93 + 88);
    uint64_t v94 = v96;
    if (v96 < v91)
    {
      do
      {
        while (!v94)
        {
          uint64_t v94 = 0x4000LL;
          if (v91 <= 0x4000)
          {
            __int128 v98 = (void **)(v72 + 984 * v73 + 96);
            uint64_t v94 = 0x4000LL;
            goto LABEL_121;
          }
        }

        __int128 v97 = v94 >> 1;
        if ((v94 & (v94 >> 1)) != 0) {
          __int128 v97 = v94 & (v94 >> 1);
        }
        v94 += v97;
      }

      while (v94 < v91);
      __int128 v98 = (void **)(v72 + 984 * v73 + 96);
      if (v94 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_154;
      }

uint64_t convertStreamWriteBlob( uint64_t a1, uint64_t a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 48)) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if (__smax && !*(_DWORD *)(a1 + 52))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 76);
    if (v11 >= *(_DWORD *)(a1 + 80))
    {
      int v14 = "invalid state";
      __int16 v15 = 414;
      goto LABEL_9;
    }

    uint64_t v12 = *(void *)(a1 + 88);
    int v13 = *(_DWORD *)(v12 + 24LL * v11);
    if (((v13 ^ a2) & 0xFFFFFF) != 0)
    {
      int v14 = "invalid state";
      __int16 v15 = 416;
      goto LABEL_9;
    }

    v17.uint64_t ikey = a2;
    if (!*(_DWORD *)(a1 + 68))
    {
      if ((convertStreamBeginBlob(a1, (AAFieldKey)a2, *(void *)(v12 + 24LL * v11 + 8)) & 0x80000000) != 0)
      {
        int v14 = "starting blob";
        __int16 v15 = 422;
        goto LABEL_9;
      }

      *(_DWORD *)(a1 + 68) = 1;
    }

    if ((*(void *)&v13 & 0xFFFFFFLL) != 0x544144) {
      goto LABEL_30;
    }
    char v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 2) != 0)
    {
      CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 160), __src, __smax);
      char v18 = *(_BYTE *)(a1 + 136);
      if ((v18 & 4) == 0)
      {
LABEL_19:
        if ((v18 & 8) == 0) {
          goto LABEL_20;
        }
        goto LABEL_26;
      }
    }

    else if ((*(_BYTE *)(a1 + 136) & 4) == 0)
    {
      goto LABEL_19;
    }

    CC_SHA256_Update((CC_SHA256_CTX *)(a1 + 256), __src, __smax);
    char v18 = *(_BYTE *)(a1 + 136);
    if ((v18 & 8) == 0)
    {
LABEL_20:
      if ((v18 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_27;
    }

void convertStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAArchiveStreamCancel(*(AAArchiveStream *)a1);
  }

uint64_t sendHeader(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 48)) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a1 + 64))
  {
    if (AAArchiveStreamWriteHeader(*(AAArchiveStream *)a1, *(AAHeader *)(a1 + 56)) < 0)
    {
      uint64_t v12 = "Encoding failed";
      __int16 v13 = 56;
    }

    else
    {
      unint64_t v5 = 0LL;
      *(_DWORD *)(a1 + 64) = 1;
      unint64_t v6 = *(void *)(a1 + 112);
      uint64_t v7 = *(void *)(a1 + 128);
      while (1)
      {
        if (v5 >= v6)
        {
          uint64_t result = 0LL;
          *(void *)(a1 + 112) = 0LL;
          return result;
        }

        unint64_t v8 = v5 + 24;
        if (v5 + 24 > v6)
        {
          uint64_t v12 = "Invalid payload";
          __int16 v13 = 66;
          goto LABEL_16;
        }

        uint64_t v9 = (AAFieldKey *)(v7 + v5);
        size_t v10 = *(void *)(v7 + v5 + 8);
        unint64_t v5 = v10 + v8;
        if (v10 + v8 > v6) {
          break;
        }
        AAFieldKey v11 = *v9;
        if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v11, (const void *)(v7 + v8), v10) < 0)
        {
          uint64_t v12 = "Blob encoding failed";
          __int16 v13 = 70;
          goto LABEL_16;
        }
      }

      uint64_t v12 = "Invalid payload";
      __int16 v13 = 69;
    }

uint64_t convertStreamToNextNonEmptyBlob( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 76);
  if (v8 >= *(_DWORD *)(a1 + 80)) {
    return 0LL;
  }
  int v10 = 1;
  do
  {
    uint64_t v11 = *(void *)(a1 + 88);
    if (*(void *)(v11 + 24LL * v8 + 8)) {
      break;
    }
    AAFieldKey v12 = *(AAFieldKey *)(v11 + 24LL * v8);
    int v13 = convertStreamBeginBlob(a1, v12, 0LL);
    unsigned int v21 = *(_DWORD *)(a1 + 80);
    unsigned int v8 = *(_DWORD *)(a1 + 76) + 1;
    *(_DWORD *)(a1 + 76) = v8;
  }

  while (v8 < v21);
  if (v10) {
    return 0LL;
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamToNextNonEmptyBlob",  204,  111,  0,  "iterating to next non-empty blob",  a7,  a8,  v23);
  return 0xFFFFFFFFLL;
}

uint64_t convertStreamEndEntry(uint64_t a1)
{
  int v4 = sendHeader(a1);
  if (v4 < 0) {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c",  (uint64_t)"convertStreamEndEntry",  182,  111,  0,  "send header",  v2,  v3,  v6);
  }
  AAHeaderDestroy(*(AAHeader *)(a1 + 56));
  *(void *)(a1 + 56) = 0LL;
  OECCStreamDestroy(*(void ***)(a1 + 776));
  *(void *)(a1 + 776) = 0LL;
  free(*(void **)(a1 + 128));
  memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
  return (v4 >> 31);
}

uint64_t convertStreamBeginBlob(uint64_t a1, AAFieldKey a2, uint64_t a3)
{
  int KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), a2);
  *(_DWORD *)(a1 + 72) = KeyIndex >= 0;
  if (KeyIndex < 0 || *(_DWORD *)(a1 + 64))
  {
LABEL_3:
    int v9 = 1;
    goto LABEL_40;
  }

  uint64_t v11 = (void *)(a1 + 112);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v12 = a3 + v10 + 24;
  if ((v12 & 0x8000000000000000LL) != 0LL) {
    goto LABEL_29;
  }
  size_t v13 = *(void *)(a1 + 120);
  if (v13 < v12)
  {
    do
    {
      while (!v13)
      {
        size_t v13 = 0x4000LL;
        if (v12 <= 0x4000)
        {
          uint64_t v15 = (void **)(a1 + 128);
          size_t v13 = 0x4000LL;
          goto LABEL_15;
        }
      }

      size_t v14 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0) {
        size_t v14 = v13 & (v13 >> 1);
      }
      v13 += v14;
    }

    while (v13 < v12);
    uint64_t v15 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001LL)
    {
      *__error() = 12;
      goto LABEL_28;
    }

uint64_t convertStreamEndBlob( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  int v9 = *(_DWORD *)(a1 + 136);
  if (!v9)
  {
LABEL_28:
    if ((sendHeader(a1) & 0x80000000) != 0)
    {
      unint64_t v10 = "send header";
      __int16 v11 = 162;
      goto LABEL_46;
    }

    if ((*(_BYTE *)(a1 + 136) & 0x20) != 0)
    {
      size_t DataSize = OECCStreamGetDataSize(*(void *)(a1 + 776));
      uint64_t DataPtr = (const void *)OECCStreamGetDataPtr(*(void *)(a1 + 776));
      v33.uint64_t ikey = 4408665;
      if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v33, DataPtr, DataSize) < 0)
      {
        unint64_t v10 = "sending blob data";
        __int16 v11 = 169;
        goto LABEL_46;
      }
    }

void *aaInPlaceStreamOpen(AAByteStream_impl *a1)
{
  uint64_t v2 = calloc(1uLL, 0x68uLL);
  uint64_t v3 = (pthread_mutex_t *)calloc(1uLL, 0x80uLL);
  char v6 = v3;
  if (!v3 || !v2)
  {
    int v9 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"aaInPlaceStreamOpen",  237,  126,  *v9,  "malloc",  v10,  v11,  v19);
    free(v2);
    if (!v6) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }

  if (!*((void *)a1 + 4) || !*((void *)a1 + 5) || !*((void *)a1 + 6) || !*((void *)a1 + 8))
  {
    uint64_t v7 = "stream not in-place compatible\n";
    __int16 v8 = 243;
    goto LABEL_12;
  }

  if (pthread_mutex_init(v3, 0LL))
  {
    uint64_t v7 = "mutex failed";
    __int16 v8 = 246;
LABEL_12:
    int v12 = 0;
LABEL_13:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"aaInPlaceStreamOpen",  v8,  126,  v12,  v7,  v4,  v5,  v19);
    free(v2);
LABEL_14:
    pthread_mutex_destroy(v6);
    free(*(void **)&v6[1].__opaque[32]);
LABEL_15:
    free(v6);
    return 0LL;
  }

  v6[1].__sig = (uint64_t)a1;
  *(void *)v6[1].__opaque = 0LL;
  *(void *)&v6[1].__opaque[16] = 0LL;
  unint64_t v14 = AAByteStreamSeek(a1, 0LL, 2);
  *(void *)&v6[1].__opaque[8] = v14;
  *(void *)&v6[1].__opaque[24] = 0LL;
  if ((v14 & 0x8000000000000000LL) != 0)
  {
    uint64_t v7 = "bad input size";
    __int16 v8 = 252;
    goto LABEL_12;
  }

  *(void *)&v6[1].__opaque[40] = (v14 + 0xFFFFF) >> 20;
  if (v14 >= 0x20000000000001LL)
  {
    *__error() = 12;
    *(void *)&v6[1].__opaque[32] = 0LL;
LABEL_26:
    int v12 = *__error();
    uint64_t v7 = "malloc";
    __int16 v8 = 257;
    goto LABEL_13;
  }

  AAFieldKey v15 = (char *)calloc((v14 + 0xFFFFF) >> 20, 0x10uLL);
  *(void *)&v6[1].__opaque[32] = v15;
  if (!v15) {
    goto LABEL_26;
  }
  uint64_t v16 = *(void *)&v6[1].__opaque[40];
  if (v16)
  {
    AAFieldKey v17 = v15 + 8;
    for (uint64_t i = v16 - 1; ; --i)
    {
      *(v17 - 1) = 0LL;
      if (!i) {
        break;
      }
      *AAFieldKey v17 = 0x100000LL;
      v17 += 2;
    }

    *AAFieldKey v17 = ((*(_DWORD *)&v6[1].__opaque[8] - 1) & 0xFFFFF) + 1LL;
  }

  AACustomByteStreamSetData((AAByteStream)v2, v6);
  AACustomByteStreamSetPReadProc((AAByteStream)v2, (AAByteStreamPReadProc)aaInPlaceStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v2, (AAByteStreamPWriteProc)aaInPlaceStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v2, (AAByteStreamReadProc)aaInPlaceStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v2, (AAByteStreamWriteProc)aaInPlaceStreamWrite);
  AACustomByteStreamSetSeekProc((AAByteStream)v2, (AAByteStreamSeekProc)aaInPlaceStreamSeek);
  AACustomByteStreamSetCloseProc((AAByteStream)v2, (AAByteStreamCloseProc)aaInPlaceStreamClose);
  AACustomByteStreamSetCancelProc((AAByteStream)v2, (AAByteStreamCancelProc)aaInPlaceStreamCancel);
  return v2;
}

uint64_t aaInPlaceStreamPRead(uint64_t a1, void *a2, size_t a3, uint64_t a4)
{
  return blockReader(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamPWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  return blockWriter(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return blockReader(a1, a2, a3, 0LL, 1);
}

uint64_t aaInPlaceStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  return blockWriter(a1, a2, a3, 0LL, 1);
}

uint64_t aaInPlaceStreamSeek(uint64_t a1, off_t a2, int a3)
{
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"aaInPlaceStreamSeek",  176,  126,  0,  "MutexLock",  v6,  v7,  v11);
    *(_DWORD *)(a1 + 120) = 1;
    return -1LL;
  }

  if (*(_DWORD *)(a1 + 120))
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return -1LL;
  }

  off_t v10 = AAByteStreamSeek(*(AAByteStream *)(a1 + 64), a2, a3);
  off_t v8 = v10;
  if ((v10 & 0x8000000000000000LL) == 0)
  {
    *(void *)(a1 + 88) = v10;
    *(void *)(a1 + 72) = v10;
  }

  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v8;
}

uint64_t aaInPlaceStreamClose(pthread_mutex_t *a1)
{
  if (!a1) {
    return 0LL;
  }
  if (!*(_DWORD *)&a1[1].__opaque[48]
    && *(void *)&a1[1].__opaque[24] < *(void *)&a1[1].__opaque[8]
    && (AAByteStreamTruncate((void *)a1[1].__sig) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"aaInPlaceStreamClose",  210,  126,  0,  "truncate failed",  v2,  v3,  v10);
    uint64_t v4 = 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  pthread_mutex_destroy(a1);
  uint64_t v5 = *(char **)&a1[1].__opaque[32];
  if (v5)
  {
    if (*(void *)&a1[1].__opaque[40])
    {
      uint64_t v6 = 0LL;
      unint64_t v7 = 0LL;
      do
      {
        free(*(void **)&v5[v6]);
        uint64_t v5 = *(char **)&a1[1].__opaque[32];
        unint64_t v8 = *(void *)&a1[1].__opaque[40];
        *(void *)&v5[v6] = 0LL;
        ++v7;
        v6 += 16LL;
      }

      while (v7 < v8);
    }

    free(v5);
  }

  free(a1);
  return v4;
}

uint64_t aaInPlaceStreamCancel(uint64_t a1)
{
  if (pthread_mutex_lock((pthread_mutex_t *)a1)) {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"aaInPlaceStreamCancel",  191,  126,  0,  "MutexLock",  v2,  v3,  v5);
  }
  if (!*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 1;
    AAByteStreamCancel(*(AAByteStream *)(a1 + 64));
  }

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

uint64_t blockReader(uint64_t a1, void *a2, size_t a3, uint64_t a4, int a5)
{
  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1LL;
    }

    if (a5)
    {
      a4 = *(void *)(a1 + 72);
      if (!a3) {
        goto LABEL_24;
      }
    }

    else
    {
      *(void *)(a1 + 72) = a4;
      if (!a3) {
        goto LABEL_24;
      }
    }

    if (*(void *)(a1 + 80) <= a4)
    {
      a3 = 0LL;
    }

    else
    {
      size_t v13 = blockGetFromCache(a1, a4);
      if (v13)
      {
        uint64_t v16 = v13;
        unint64_t v17 = (unint64_t)v13[1];
        if (v17)
        {
          if (0x100000 - (a4 & 0xFFFFFuLL) < v17) {
            unint64_t v17 = 0x100000 - (a4 & 0xFFFFF);
          }
          if (v17 < a3) {
            a3 = v17;
          }
          memcpy(a2, &(*v13)[a4 & 0xFFFFF], a3);
          size_t v18 = (size_t)&v16[1][-a3];
          v16[1] = (char *)v18;
          if (!v18)
          {
            free(*v16);
            *uint64_t v16 = 0LL;
          }

          *(void *)(a1 + 72) += a3;
          goto LABEL_24;
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"blockPRead",  72,  126,  0,  "block already consumed",  v14,  v15,  v19);
      }

      *(_DWORD *)(a1 + 120) = 1;
      a3 = -1LL;
    }

char **blockGetFromCache(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 104) + 16 * (a2 >> 20));
  uint64_t v3 = (char **)v2;
  if (!*v2)
  {
    size_t v6 = v2[1];
    char v5 = v2 + 1;
    size_t v4 = v6;
    if (v6)
    {
      if (v4 >= 0x2000000001LL)
      {
        *__error() = 12;
        *uint64_t v3 = 0LL;
LABEL_12:
        int v17 = *__error();
        size_t v18 = "malloc";
        __int16 v19 = 52;
LABEL_13:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"blockGetFromCache",  v19,  126,  v17,  v18,  v10,  v11,  v21);
        return 0LL;
      }

      int v9 = (char *)malloc(v4);
      *uint64_t v3 = v9;
      if (!v9) {
        goto LABEL_12;
      }
      uint64_t v12 = *(void *)(a1 + 64);
      if (*(void *)(v12 + 32))
      {
        size_t v13 = v9;
        uint64_t v14 = 0LL;
        unint64_t v15 = a2 & 0xFFFFFFFFFFF00000LL;
        while (1)
        {
          uint64_t v16 = (*(uint64_t (**)(void, char *, size_t, unint64_t))(v12 + 32))( *(void *)v12,  v13,  v4,  v15);
          if (v16 < 0) {
            break;
          }
          if (v16)
          {
            v13 += v16;
            v14 += v16;
            v15 += v16;
            v4 -= v16;
            if (v4) {
              continue;
            }
          }

          goto LABEL_17;
        }

        uint64_t v14 = v16;
LABEL_17:
        size_t v4 = *v5;
      }

      else
      {
        uint64_t v14 = -1LL;
      }

      if (v14 != v4)
      {
        size_t v18 = "stream read error";
        __int16 v19 = 58;
        int v17 = 0;
        goto LABEL_13;
      }
    }
  }

  return v3;
}

uint64_t blockWriter(uint64_t a1, const void *a2, size_t a3, uint64_t a4, int a5)
{
  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1LL;
    }

    if (a5)
    {
      a4 = *(void *)(a1 + 88);
      if (a3) {
        goto LABEL_9;
      }
    }

    else
    {
      *(void *)(a1 + 88) = a4;
      if (a3)
      {
LABEL_9:
        if (*(void *)(a1 + 80) > a4)
        {
          if (!blockGetFromCache(a1, a4))
          {
            uint64_t v12 = -1LL;
LABEL_20:
            *(_DWORD *)(a1 + 120) = 1;
            goto LABEL_21;
          }

          if (0x100000 - (a4 & 0xFFFFFuLL) < a3) {
            a3 = 0x100000 - (a4 & 0xFFFFF);
          }
        }

        ssize_t v14 = AAByteStreamPWrite(*(AAByteStream *)(a1 + 64), a2, a3, a4);
        uint64_t v12 = v14;
        if ((v14 & 0x8000000000000000LL) == 0)
        {
          if (v14)
          {
            ssize_t v15 = *(void *)(a1 + 96);
            ssize_t v16 = *(void *)(a1 + 88) + v14;
            *(void *)(a1 + 88) = v16;
            if (v15 < v16) {
              *(void *)(a1 + 96) = v16;
            }
          }

          goto LABEL_21;
        }

        goto LABEL_20;
      }
    }

    uint64_t v12 = 0LL;
LABEL_21:
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return v12;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c",  (uint64_t)"blockWriter",  131,  126,  0,  "MutexLock",  v10,  v11,  v17);
  *(_DWORD *)(a1 + 120) = 1;
  return -1LL;
}

uint64_t io_hint_static_content(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    size_t v6 = "file not open";
    __int16 v7 = 63;
  }

  else
  {
    char v8 = 1;
    if (fcntl(FD, 68) != -1) {
      return 0LL;
    }
    size_t v6 = "static content hint failed";
    __int16 v7 = 64;
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_hint_static_content",  v7,  137,  v6,  v2,  v3,  v4,  v8);
  return 0xFFFFFFFFLL;
}

uint64_t io_preallocate(unsigned int **a1, unint64_t a2)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    ssize_t v15 = "file not open";
    __int16 v16 = 84;
LABEL_12:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_preallocate",  v16,  137,  v15,  v5,  v6,  v7,  v21);
    LOBYTE(v10) = 0;
    goto LABEL_13;
  }

  int v8 = FD;
  if (fstat(FD, &v25) || v25.st_size)
  {
    ssize_t v15 = "file not empty";
    __int16 v16 = 85;
    goto LABEL_12;
  }

  pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_preallocate",  88,  137,  "preallocating %llu B",  v5,  v6,  v7,  a2);
  if (!a2)
  {
    uint64_t v14 = 0LL;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }

  int v9 = 0;
  unint64_t v10 = 0LL;
  while (1)
  {
    v23[0] = 0x300000002LL;
    v23[1] = 0LL;
    v23[2] = a2 - v10;
    uint64_t v24 = 0LL;
    if (fcntl(v8, 42, v23) == -1 || v24 <= 0) {
      break;
    }
    v10 += v24;
    ++v9;
    if (v10 >= a2)
    {
      uint64_t v14 = 0LL;
      goto LABEL_14;
    }
  }

  pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_preallocate",  99,  137,  "preallocation failed",  v11,  v12,  v13,  v22);
LABEL_13:
  uint64_t v14 = 0xFFFFFFFFLL;
LABEL_14:
  getRealTime();
  pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_preallocate",  110,  137,  "preallocation %llu/%llu B took %0.2f seconds (# of calls=%i)",  v17,  v18,  v19,  v10);
  return v14;
}

uint64_t io_set_nocache(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    uint64_t v5 = "aaFileStreamGetFD";
    __int16 v6 = 126;
    int v7 = 0;
  }

  else
  {
    char v8 = 1;
    if (fcntl(FD, 48) != -1) {
      return 0LL;
    }
    int v7 = *__error();
    uint64_t v5 = "fcntl";
    __int16 v6 = 127;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"io_set_nocache",  v6,  137,  v7,  v5,  v2,  v3,  v8);
  return 0xFFFFFFFFLL;
}

uint64_t **aaSegmentStreamOpen(void *a1, void *a2)
{
  uint64_t v3 = (uint64_t **)SegmentStreamCreate(a1, (uint64_t)a2);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *v3;
    uint64_t v12 = pc_array_indirect_sort(a2[267], compare_extents_by_position);
    if (v12)
    {
      unint64_t v13 = 0LL;
      unint64_t v14 = 0LL;
      unint64_t v15 = a2[269];
      do
      {
        if (v14 >= v15)
        {
          unint64_t v17 = 0LL;
          __int16 v16 = a2 + 265;
        }

        else
        {
          __int16 v16 = (unint64_t *)v12[v14];
          unint64_t v17 = v16[1];
        }

        unint64_t v18 = *v16;
        BOOL v19 = *v16 >= v13;
        unint64_t v20 = *v16 - v13;
        if (v20 != 0 && v19)
        {
          uint64_t v40 = v5[397];
          unint64_t v41 = v20;
          unint64_t v42 = v13;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v20;
          char v21 = pc_array_append(v5[395], &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v21;
          if (!v21)
          {
            char v37 = "segment_add";
            __int16 v38 = 476;
            goto LABEL_28;
          }

          unint64_t v15 = a2[269];
        }

        unint64_t v13 = v18 + v17;
        ++v14;
      }

      while (v14 <= v15);
      uint64_t v22 = v5[397];
      a2[258] = v22;
      unint64_t v23 = a2[270];
      if (v23)
      {
        uint64_t v24 = 0LL;
        while (1)
        {
          uint64_t v25 = a2[267];
          uint64_t v26 = a2[268] + 440 * v24;
          *(void *)(v26 + 32) = 0LL;
          uint64_t v27 = (void *)(v26 + 32);
          v27[1] = v5[397];
          if (v27[49]) {
            break;
          }
LABEL_19:
          if (++v24 >= v23)
          {
            uint64_t v22 = v5[397];
            goto LABEL_21;
          }
        }

        uint64_t v28 = 0LL;
        uint32_t v29 = (void *)v5[395];
        AAFieldKey v30 = (uint64_t *)(v25 + 16LL * v27[48] + 8);
        while (1)
        {
          unint64_t v32 = *(v30 - 1);
          unint64_t v31 = *v30;
          uint64_t v40 = v5[397];
          unint64_t v41 = v31;
          unint64_t v42 = v32;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v31;
          uint32_t v29 = pc_array_append((uint64_t)v29, &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v29;
          if (!v29) {
            break;
          }
          uint64_t v33 = *v30;
          v30 += 2;
          *v27 += v33;
          if ((unint64_t)++v28 >= v27[49])
          {
            unint64_t v23 = a2[270];
            goto LABEL_19;
          }
        }

        char v37 = "segment_add";
        __int16 v38 = 500;
      }

      else
      {
LABEL_21:
        v5[396] = *(void *)(v5[395] - 64);
        if (v22 == a2[265])
        {
          free(v12);
          return v4;
        }

        char v37 = "bad image";
        __int16 v38 = 507;
      }
    }

    else
    {
      char v37 = "pc_array_indirect_sort";
      __int16 v38 = 465;
    }

void *SegmentStreamCreate(void *a1, uint64_t a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  uint64_t v5 = calloc(1uLL, 0xC78uLL);
  uint64_t v8 = v5;
  if (!v4 || !v5)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 416;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"SegmentStreamCreate",  v11,  137,  v9,  v10,  v6,  v7,  v13);
    free(v4);
    SegmentStreamClose((uint64_t)v8);
    return 0LL;
  }

  if (!a1[4] || !a1[5])
  {
    uint64_t v10 = "stream not compatible";
    __int16 v11 = 417;
    int v9 = 0;
    goto LABEL_9;
  }

  void *v5 = a1;
  v5[1] = a2;
  v5[395] = pc_array_init(29LL);
  AACustomByteStreamSetData((AAByteStream)v4, v8);
  AACustomByteStreamSetPReadProc((AAByteStream)v4, (AAByteStreamPReadProc)SegmentStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v4, (AAByteStreamPWriteProc)SegmentStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v4, (AAByteStreamCancelProc)SegmentStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v4, (AAByteStreamCloseProc)SegmentStreamClose);
  if (a1[11]) {
    v4[11] = SegmentStreamSimulate;
  }
  return v4;
}

uint64_t SegmentStreamClose(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 3152))
    {
      for (uint64_t i = 16LL; i != 3088; i += 24LL)
        free(*(void **)(a1 + i));
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3088));
    }

    pc_array_free(*(void *)(a1 + 3160));
    free((void *)a1);
  }

  return 0LL;
}

uint64_t *aaForkInputStreamOpen( void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a2 + 2128) & 8) == 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaForkInputStreamOpen",  538,  137,  0,  "no chunk info",  a7,  a8,  v58);
    uint64_t v8 = 0LL;
LABEL_13:
    uint64_t v13 = 0LL;
    goto LABEL_16;
  }

  uint64_t v10 = (void *)a2;
  uint64_t v12 = SegmentStreamCreate(a1, a2);
  uint64_t v8 = v12;
  if (!v12)
  {
    uint64_t v26 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaForkInputStreamOpen",  542,  137,  *v26,  "SegmentStreamCreate",  v27,  v28,  v58);
    goto LABEL_13;
  }

  uint64_t v13 = *v12;
  if (a1[11]) {
    *(_DWORD *)(v13 + 3184) = 1;
  }
  uint64_t v14 = 0LL;
  *(void *)(v13 + 3152) = 1LL;
  do
  {
    unint64_t v15 = malloc(0x10000uLL);
    uint64_t v16 = v13 + v14;
    *(void *)(v16 + 16) = v15;
    *(void *)(v16 + 24) = -1LL;
    if (!v15)
    {
      int v25 = *__error();
      unint64_t v23 = "malloc";
      __int16 v24 = 554;
      goto LABEL_15;
    }

    v14 += 24LL;
  }

  while (v14 != 3072);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 3088), 0LL))
  {
    unint64_t v23 = "MutexInit";
    __int16 v24 = 556;
    goto LABEL_11;
  }

  uint64_t v59 = v8;
  char v63 = 0;
  __int16 v61 = v10;
  char v62 = 1;
  int v60 = a3;
  while (!v10[270])
  {
LABEL_36:
    uint64_t v8 = v59;
    if ((v62 & 1) == 0)
    {
      *(void *)(v13 + 3168) = *(void *)(*(void *)(v13 + 3160) - 64LL);
      v10[260] = *(void *)(v13 + 3176);
      return v8;
    }

    uint64_t v53 = *(void *)(v13 + 3176);
    v10[257] = v53;
    unint64_t v54 = v10[258];
    if (v54)
    {
      __srCC_SHA1_CTX c = v53;
      __int128 v67 = v54;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v54 + v53;
      AAFieldKey v55 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v55;
      if (!v55)
      {
        unint64_t v23 = "segment_add";
        __int16 v24 = 607;
LABEL_11:
        int v25 = 0;
LABEL_15:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaForkInputStreamOpen",  v24,  137,  v25,  v23,  v21,  v22,  v58);
        goto LABEL_16;
      }

      uint64_t v53 = *(void *)(v13 + 3176);
    }

    char v62 = 0;
    v10[259] = v53;
    char v63 = 1;
  }

  unint64_t v30 = 0LL;
  while (1)
  {
    uint64_t v65 = v10[268];
    if (a3) {
      LOBYTE(v31) = 1;
    }
    else {
      uint64_t v31 = *(void *)(v10[268] + 440 * v30 + 408);
    }
    char v64 = v31;
    if (!(v63 & 1 | ((v31 & 1) == 0))) {
      break;
    }
LABEL_33:
    if (!(v62 & 1 | ((v64 & 2) == 0LL)))
    {
      uint64_t v49 = *(void *)(v13 + 3176);
      uint64_t v50 = v65 + 440 * v30;
      *(void *)(v50 + 48) = v49;
      __int128 v51 = *(_OWORD *)(v50 + 32);
      __srCC_SHA1_CTX c = v49;
      __int128 v67 = v51;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v51 + v49;
      AAFieldKey v52 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v52;
      if (!v52)
      {
        AAFieldKey v56 = "segment_add";
        __int16 v57 = 597;
        goto LABEL_42;
      }
    }

AAByteStream_impl *aaIntervalInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  uint64_t v7 = calloc(1uLL, 0x20uLL);
  uint64_t v10 = v7;
  if (v6 && v7)
  {
    if (a3 >= a2)
    {
      *uint64_t v7 = a1;
      v7[1] = a2;
      v7[2] = a3 - a2;
      v7[3] = 0LL;
      AACustomByteStreamSetData(v6, v7);
      AACustomByteStreamSetReadProc(v6, (AAByteStreamReadProc)IntervalStreamRead);
      AACustomByteStreamSetPReadProc(v6, (AAByteStreamPReadProc)IntervalStreamPRead);
      AACustomByteStreamSetSeekProc(v6, (AAByteStreamSeekProc)IntervalStreamSeek);
      AACustomByteStreamSetCancelProc(v6, (AAByteStreamCancelProc)IntervalStreamCancel);
      AACustomByteStreamSetCloseProc(v6, (AAByteStreamCloseProc)IntervalStreamClose);
      return v6;
    }

    __int16 v11 = "bad interval";
    __int16 v12 = 703;
    int v13 = 0;
  }

  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 702;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"aaIntervalInputStreamOpen",  v12,  137,  v13,  v11,  v8,  v9,  v15);
  free(v6);
  free(v10);
  return 0LL;
}

ssize_t IntervalStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return IntervalStreamPRead(a1, a2, a3, *(void *)(a1 + 24));
}

ssize_t IntervalStreamPRead(uint64_t a1, void *a2, size_t a3, int64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  int64_t v5 = *(void *)(a1 + 16);
  if (v5 == a4) {
    return 0LL;
  }
  if (v5 < a4) {
    return -1LL;
  }
  ssize_t result = AAByteStreamPRead(*(AAByteStream *)a1, a2, a3, *(void *)(a1 + 8) + a4);
  if (result < 0) {
    return -1LL;
  }
  *(void *)(a1 + 24) += result;
  return result;
}

uint64_t IntervalStreamSeek(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (void *)(a1 + 24);
    if (a3 != 1)
    {
      if (a3 != 2) {
        return -1LL;
      }
      uint64_t v3 = (void *)(a1 + 16);
    }

    a2 += *v3;
  }

  if ((a2 & 0x8000000000000000LL) == 0 && a2 <= *(void *)(a1 + 16))
  {
    *(void *)(a1 + 24) = a2;
    return a2;
  }

  return -1LL;
}

void IntervalStreamCancel(AAByteStream *a1)
{
}

uint64_t IntervalStreamClose(void *a1)
{
  return 0LL;
}

uint64_t SegmentStreamPRead(void **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v5 = a3;
  unint64_t v7 = 0LL;
  uint64_t v8 = (pthread_mutex_t *)(a1 + 386);
  uint64_t v9 = a1 + 2;
  int v73 = (unint64_t *)(a1 + 4);
  int v75 = (pthread_mutex_t *)(a1 + 386);
  while (1)
  {
    uint64_t v10 = segment_find(a1, a4);
    if (!v10)
    {
      char v63 = "no segment found";
      __int16 v64 = 321;
      goto LABEL_74;
    }

    uint64_t v13 = v10;
    unint64_t v14 = a4 - *(void *)v10;
    if (v5 - v7 >= *(void *)(v10 + 8) - v14) {
      size_t v15 = *(void *)(v10 + 8) - v14;
    }
    else {
      size_t v15 = v5 - v7;
    }
    if (!*(_DWORD *)(v10 + 24))
    {
      uint64_t v22 = (uint64_t)*a1;
      if ((*a1)[4])
      {
        if (!v15) {
          goto LABEL_41;
        }
        uint64_t v23 = 0LL;
        uint64_t v24 = a2 + v7;
        size_t v25 = v15;
        unint64_t v26 = *(void *)(v10 + 16) + a4 - *(void *)v10;
        size_t __n = v25;
        while (1)
        {
          uint64_t v27 = (*(uint64_t (**)(void, uint64_t, size_t, unint64_t))(v22 + 32))( *(void *)v22,  v24,  v25,  v26);
          if (v27 < 0) {
            break;
          }
          if (v27)
          {
            v24 += v27;
            v23 += v27;
            v26 += v27;
            v25 -= v27;
            if (v25) {
              continue;
            }
          }

          goto LABEL_39;
        }

        uint64_t v23 = v27;
      }

      else
      {
        size_t __n = v15;
        uint64_t v23 = -1LL;
      }

LABEL_45:
    BOOL v51 = v47 == v69;
    uint64_t v8 = v75;
    unint64_t v5 = a3;
    if (v51)
    {
      size_t v52 = *(void *)(v13 + 8);
      if (*src_buffer == BYTE4(v82[v81]))
      {
        if (v52 + 1 != *(_DWORD *)(v13 + 24))
        {
          uint64_t v65 = "chunk error";
          __int16 v66 = 189;
          goto LABEL_72;
        }

        uint64_t v53 = src_buffer + 1;
      }

      else
      {
        size_t v54 = *(unsigned int *)(v13 + 24);
        uint64_t v53 = &src_buffer[v54];
        if (compression_decode_buffer( &src_buffer[v54],  v52,  src_buffer,  v54,  0LL,  (compression_algorithm)LODWORD(v82[v81])) != *(void *)(v13 + 8))
        {
          uint64_t v65 = "compression_decode_buffer";
          __int16 v66 = 195;
          goto LABEL_72;
        }
      }

      memcpy((void *)(a2 + v7), &v53[v80], __na);
      if (pthread_mutex_lock(v75))
      {
        uint64_t v65 = "MutexLock";
        __int16 v66 = 202;
        goto LABEL_72;
      }

      memcpy(*v72, v53, *(void *)(v13 + 8));
      *__int16 v71 = *(void *)(v13 + 16);
      uint64_t v55 = (uint64_t)a1[394] + 1;
      a1[394] = (void *)v55;
      *uint64_t v70 = v55;
      size_t v15 = __na;
      unint64_t v41 = src_buffer;
      goto LABEL_53;
    }
  }

  uint64_t v65 = "aaByteStreamPReadExpected";
  __int16 v66 = 183;
LABEL_72:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"segment_decode_to_buffer",  v66,  137,  0,  v65,  v44,  v45,  v68);
  unint64_t v41 = src_buffer;
LABEL_73:
  free(v41);
  char v63 = "segment_decode_to_buffer";
  __int16 v64 = 330;
LABEL_74:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"SegmentStreamPRead",  v64,  137,  0,  v63,  v11,  v12,  v68);
  return -1LL;
}

uint64_t SegmentStreamPWrite(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  while (1)
  {
    uint64_t v8 = segment_find(a1, a4);
    if (!v8)
    {
      unint64_t v19 = "no segment found";
      __int16 v20 = 363;
      goto LABEL_23;
    }

    unint64_t v11 = a4 - *(void *)v8;
    if (a3 - v7 >= *(void *)(v8 + 8) - v11) {
      unint64_t v12 = *(void *)(v8 + 8) - v11;
    }
    else {
      unint64_t v12 = a3 - v7;
    }
    if (*(_DWORD *)(v8 + 24))
    {
      unint64_t v19 = "compressed content";
      __int16 v20 = 370;
      goto LABEL_23;
    }

    uint64_t v13 = *a1;
    if (!*(void *)(*a1 + 40LL))
    {
      uint64_t v14 = -1LL;
      goto LABEL_16;
    }

    if (v12) {
      break;
    }
LABEL_17:
    a4 += v12;
    v7 += v12;
    if (v7 >= a3) {
      return v7;
    }
  }

  uint64_t v14 = 0LL;
  uint64_t v15 = a2 + v7;
  unint64_t v16 = *(void *)(v8 + 16) + v11;
  unint64_t v17 = v12;
  while (1)
  {
    uint64_t v18 = (*(uint64_t (**)(void, uint64_t, unint64_t, unint64_t))(v13 + 40))( *(void *)v13,  v15,  v17,  v16);
    if (v18 < 1) {
      break;
    }
    v15 += v18;
    v14 += v18;
    v16 += v18;
    v17 -= v18;
    if (!v17) {
      goto LABEL_16;
    }
  }

  uint64_t v14 = v18;
LABEL_16:
  if (v12 == v14) {
    goto LABEL_17;
  }
  unint64_t v19 = "aaByteStreamPWriteExpected";
  __int16 v20 = 374;
LABEL_23:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"SegmentStreamPWrite",  v20,  137,  0,  v19,  v9,  v10,  v22);
  return -1LL;
}

void SegmentStreamCancel(AAByteStream *a1)
{
}

uint64_t SegmentStreamSimulate(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v8 = 0LL;
  while (a4 > v8)
  {
    uint64_t v9 = segment_find(a1, a5);
    if (!v9)
    {
      uint64_t v14 = "no segment found";
      __int16 v15 = 276;
      goto LABEL_12;
    }

    unint64_t v12 = *(void *)(v9 + 8) - (a5 - *(void *)v9);
    if (a4 - v8 < v12) {
      unint64_t v12 = a4 - v8;
    }
    a5 += v12;
    v8 += v12;
    if (*(_DWORD *)(v9 + 24)) {
      unint64_t v13 = *(unsigned int *)(v9 + 24);
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 != aaByteStreamSimulate((void *)*a1))
    {
      uint64_t v14 = "aaByteStreamSimulate";
      __int16 v15 = 303;
LABEL_12:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c",  (uint64_t)"SegmentStreamSimulate",  v15,  137,  0,  v14,  v10,  v11,  v17);
      return -1LL;
    }
  }

  return v8;
}

uint64_t segment_find(void *a1, unint64_t a2)
{
  if (a1[397] <= a2) {
    return 0LL;
  }
  unint64_t v2 = a1[396];
  uint64_t v3 = a1[395];
  if (v2 < 2)
  {
    unint64_t v4 = 0LL;
  }

  else
  {
    unint64_t v4 = 0LL;
    do
    {
      if (*(void *)(v3 + 29 * ((v4 + v2) >> 1)) <= a2) {
        unint64_t v4 = (v4 + v2) >> 1;
      }
      else {
        unint64_t v2 = (v4 + v2) >> 1;
      }
    }

    while (v4 + 1 < v2);
  }

  return v3 + 29 * v4;
}

uint64_t load_variants(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v6 = (const char **)(a2 + 16);
  unint64_t v7 = (FILE **)MEMORY[0x1895F89D0];
  while (1)
  {
    unint64_t v8 = v6;
    if (v4) {
      unint64_t v8 = (const char **)(*(void *)(a2 + 8) + 8 * v4 - 8);
    }
    uint64_t v9 = rawimg_create_with_path(*v8);
    *(void *)(a1 + 8 * v4) = v9;
    if (!v9)
    {
      char v22 = "rawimg_create_with_file";
      __int16 v23 = 37;
      goto LABEL_26;
    }

    unint64_t v12 = *(uint64_t **)(a1 + 8 * v4);
    if (v4 < 2)
    {
LABEL_19:
      *(void *)(a1 + 8 * v5++) = v12;
    }

    else
    {
      uint64_t v13 = 1LL;
      while (1)
      {
        uint64_t v14 = *(void **)(a1 + 8 * v13);
        uint64_t v15 = v14[261];
        uint64_t v16 = v14[262];
        uint64_t v17 = v14[263];
        uint64_t v18 = v14[264];
        BOOL v19 = v12[261] == v15 && v12[262] == v16;
        BOOL v20 = v19 && v12[263] == v17;
        if (v20 && v12[264] == v18) {
          break;
        }
        if (v4 == ++v13) {
          goto LABEL_19;
        }
      }

      rawimg_destroy(v12);
      if (*(_DWORD *)(a2 + 40)) {
        fprintf( *v7,  "ImageDiff: Removed non-unique input variant <%s>.\n",  *(const char **)(*(void *)(a1 + 8 * v4) + 2048LL));
      }
    }

    if (++v4 > *(void *)a2) {
      return v5;
    }
  }

  char v22 = "rawimg_get_digests";
  __int16 v23 = 38;
LABEL_26:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"load_variants",  v23,  134,  0,  v22,  v10,  v11,  v25);
  return 0LL;
}

uint64_t patch_write_controls(AAByteStream_impl *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  off_t v8 = AAByteStreamSeek(a1, 0LL, 1);
  *(void *)(a3 + 38) = v8;
  if (v8 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_controls",  331,  134,  0,  "AAByteStreamSeek",  v9,  v10,  v33);
    uint64_t v20 = 0LL;
    uint64_t v16 = 0LL;
  }

  else
  {
    uint64_t v11 = *(unsigned int *)(a4 + 40);
    else {
      AAFlagSet v12 = 0xC000000000000000LL;
    }
    AAByteStream v13 = AACompressionOutputStreamOpen(a1, 0x306u, 0x100000uLL, v12, *(_DWORD *)(a4 + 36));
    uint64_t v16 = v13;
    if (v13)
    {
      unint64_t v17 = a2[2];
      if (v17 < 2)
      {
        unint64_t v21 = a2[3];
        uint64_t v18 = (uint64_t *)(v21 + 56);
        BOOL v19 = (uint64_t *)(v21 + 40);
      }

      else
      {
        uint64_t v18 = (uint64_t *)(a2 + 11);
        BOOL v19 = (uint64_t *)(a2 + 9);
      }

      uint64_t v22 = *v18;
      *(void *)(a3 + 18) = v22;
      uint64_t v20 = *v19;
      if (*((void *)v13 + 3))
      {
        uint64_t v23 = 8 * v17 + 16;
        uint64_t v24 = v23 * v22;
        if (!(v23 * v22)) {
          goto LABEL_19;
        }
        uint64_t v25 = 0LL;
        uint64_t v26 = *v19;
        uint64_t v27 = v23 * v22;
        while (1)
        {
          uint64_t v28 = (*((uint64_t (**)(void, uint64_t, uint64_t))v16 + 3))(*(void *)v16, v26, v27);
          if (v28 < 1) {
            break;
          }
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (!v27) {
            goto LABEL_18;
          }
        }

        uint64_t v25 = v28;
LABEL_18:
        if (v24 == v25)
        {
LABEL_19:
          int v29 = 0;
          goto LABEL_22;
        }
      }

      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_controls",  350,  134,  0,  "aaByteStreamWriteExpected",  v14,  v15,  v33);
    }

    else
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_controls",  335,  134,  0,  "AACompressionOutputStreamOpen",  v14,  v15,  v33);
      uint64_t v20 = 0LL;
    }
  }

  int v29 = 1;
LABEL_22:
  if (AAByteStreamClose(v16) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_controls",  353,  134,  0,  "AAByteStreamClose",  v30,  v31,  v33);
  }

  else if (!v29)
  {
    return v20;
  }

  return 0LL;
}

uint64_t RawImageDiff(uint64_t a1)
{
  uint64_t v326 = *MEMORY[0x1895F89C0];
  __int128 v324 = 0u;
  __int128 v325 = 0u;
  __int128 v322 = 0u;
  __int128 v323 = 0u;
  __int128 v320 = 0u;
  __int128 v321 = 0u;
  __int128 v319 = 0u;
  if (!*(_DWORD *)(a1 + 36)) {
    *(_DWORD *)(a1 + 36) = getDefaultNThreads();
  }
  if (*(_DWORD *)(a1 + 40))
  {
    unint64_t v2 = (FILE **)MEMORY[0x1895F89D0];
    fwrite("ImageDiff\n", 0xAuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    unint64_t v3 = *(void *)a1;
    if (*(void *)a1)
    {
      unint64_t v4 = 0LL;
      do
      {
        uint64_t v5 = *(const char **)(*(void *)(a1 + 8) + 8 * v4);
        if (v5)
        {
          fprintf(*v2, "  Input %zu: %s\n", v4, v5);
          unint64_t v3 = *(void *)a1;
        }

        ++v4;
      }

      while (v4 < v3);
    }

    if (*(void *)(a1 + 16)) {
      fprintf(*v2, "  Output: %s\n", *(const char **)(a1 + 16));
    }
    if (*(void *)(a1 + 24)) {
      fprintf(*v2, "  Patch: %s\n", *(const char **)(a1 + 24));
    }
    if ((*(_DWORD *)(a1 + 32) & 1) != 0) {
      uint64_t v6 = "yes";
    }
    else {
      uint64_t v6 = "no";
    }
    fprintf(*v2, "  In-place: %s\n", v6);
  }

  size_t v7 = *(void *)a1 + 1LL;
  if (v7 > 0x400000000LL)
  {
    *__error() = 12;
LABEL_95:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"RawImageDiff",  592,  134,  0,  "aaCalloc",  v8,  v9,  v282);
    uint64_t v104 = 0xFFFFFFFFLL;
    goto LABEL_117;
  }

  uint64_t v10 = (uint64_t *)calloc(v7, 8uLL);
  if (!v10) {
    goto LABEL_95;
  }
  uint64_t v11 = v10;
  unint64_t variants = load_variants((uint64_t)v10, a1);
  if (!variants)
  {
    uint64_t v105 = "load_variants";
    __int16 v106 = 596;
    goto LABEL_113;
  }

  *(void *)a1 = variants - 1;
  if ((rawimg_set_fork_types((uint64_t)v11, variants, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    uint64_t v105 = "rawimg_set_fork_types";
    __int16 v106 = 600;
    goto LABEL_113;
  }

  unint64_t v19 = *(void *)a1;
  if ((*(void *)a1 & 0x80000000) == 0)
  {
    uint64_t v20 = *(void *)a1;
    do
    {
      rawimg_show(v11[v20], v20 == 0, *(_DWORD *)(a1 + 40));
      --v20;
    }

    while (v20 != -1);
    unint64_t v19 = *(void *)a1;
  }

  uint64_t v21 = *v11;
  uint64_t v22 = (void **)(*(void *)(*v11 + 2120) / 0x64uLL + 0x2000000);
  __int128 v319 = 0u;
  __int128 v320 = 0u;
  __int128 v321 = 0u;
  __int128 v322 = 0u;
  __int128 v323 = 0u;
  __int128 v324 = 0u;
  __int128 v325 = 0u;
  *(int32x2_t *)((char *)&v319 + 4) = vrev64_s32(*(int32x2_t *)(a1 + 36));
  *(void *)&__int128 v320 = v19;
  if (v19 <= 1) {
    unint64_t v23 = 1LL;
  }
  else {
    unint64_t v23 = v19;
  }
  if (!is_mul_ok(v23, 0x50uLL) || 80 * v23 >= 0x2000000001LL)
  {
    *__error() = 12;
    *((void *)&v320 + 1) = 0LL;
    goto LABEL_99;
  }

  uint64_t v24 = (char *)calloc(v23, 0x50uLL);
  *((void *)&v320 + 1) = v24;
  if (!v24)
  {
LABEL_99:
    int v107 = *__error();
    __int16 v110 = 205;
LABEL_100:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  v110,  134,  v107,  "aaCalloc",  v108,  v109,  v282);
    uint64_t v45 = 0LL;
    uint64_t v37 = 0LL;
    uint64_t v30 = 0LL;
LABEL_101:
    char v63 = 0LL;
    uint64_t v59 = 0LL;
    size_t v52 = 0LL;
    goto LABEL_102;
  }

  uint64_t v25 = v24;
  if (v19)
  {
    uint64_t v26 = v24 + 36;
    do
    {
      *uint64_t v26 = 1;
      v26 += 20;
      --v19;
    }

    while (v19);
  }

  if (!*(void *)a1)
  {
    char v250 = calloc(1uLL, 0x18uLL);
    *((void *)v25 + 5) = v250;
    if (v250)
    {
      uint64_t v45 = 0LL;
      uint64_t v30 = 0LL;
      char v63 = 0LL;
      uint64_t v59 = 0LL;
      size_t v52 = 0LL;
      uint64_t v251 = *(void *)(v21 + 2080);
      if (v251 < 0) {
        uint64_t v251 = 0x8000000000000000LL - v251;
      }
      v250[1] = v251;
      int v111 = 1;
      *((void *)v25 + 7) = 1LL;
      uint64_t v37 = 0LL;
      goto LABEL_103;
    }

    int v107 = *__error();
    __int16 v110 = 213;
    goto LABEL_100;
  }

  AAByteStream v27 = AAFileStreamOpenWithPath(*(const char **)(v21 + 2048), 0, 0);
  uint64_t v30 = v27;
  if (!v27)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  223,  134,  0,  "AAFileStreamOpenWithPath",  v28,  v29,  v282);
    uint64_t v45 = 0LL;
    uint64_t v37 = 0LL;
    goto LABEL_101;
  }

  uint64_t v31 = aaSegmentStreamOpen(v27, (void *)v21);
  uint64_t v37 = (AAByteStream_impl *)v31;
  if (!v31)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  225,  134,  0,  "aaSegmentStreamOpen",  v35,  v36,  v282);
    uint64_t v45 = 0LL;
    goto LABEL_101;
  }

  uint64_t v45 = aaForkInputStreamOpen(v31, v21, 0, v32, v33, v34, v35, v36);
  if (!v45)
  {
    char v252 = "aaForkInputStreamOpen";
    __int16 v253 = 227;
LABEL_290:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  v253,  134,  0,  v252,  v43,  v44,  v282);
    goto LABEL_101;
  }

  unint64_t v46 = 0LL;
  int64x2_t v303 = vdupq_n_s64(0x8000000000000000LL);
  v311 = v37;
  AAByteStream v315 = (AAByteStream)v22;
  while (1)
  {
    if (v46 >= (unint64_t)v320)
    {
      if ((unint64_t)v320 < 2)
      {
        char v63 = 0LL;
        uint64_t v59 = 0LL;
        size_t v52 = 0LL;
        int v111 = 1;
      }

      else
      {
        if (bxdiff5CreateComboControls((uint64_t)&v319, v38, v39, v40, v41, v42, v43, v44))
        {
          char v252 = "bxdiff5CreateComboControls";
          __int16 v253 = 270;
          goto LABEL_290;
        }

        if ((controls_combo_enforce_copy_fork_boundary(*v11, &v319, v265, v266, v267, v268, v43, v44) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  272,  134,  0,  "controls_combo_enforce_copy_fork_boundary",  v280,  v281,  v282);
          char v63 = 0LL;
          uint64_t v59 = 0LL;
          size_t v52 = 0LL;
          int v111 = 0;
        }

        else
        {
          if (*(_DWORD *)(a1 + 40)) {
            fprintf( (FILE *)*MEMORY[0x1895F89D0],  "ImageDiff: Constructed %zd combo controls.\n",  *((size_t *)&v324 + 1));
          }
          char v63 = 0LL;
          uint64_t v59 = 0LL;
          size_t v52 = 0LL;
          int v111 = 1;
        }

        uint64_t v37 = v311;
      }

      goto LABEL_103;
    }

    uint64_t v22 = (void **)v30;
    unint64_t v317 = v46;
    unint64_t v47 = v46 + 1;
    uint64_t v48 = v11[v46 + 1];
    AAByteStream v49 = AAFileStreamOpenWithPath(*(const char **)(v48 + 2048), 0, 0);
    size_t v52 = v49;
    if (!v49)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  236,  134,  0,  "AAFileStreamOpenWithPath",  v50,  v51,  v282);
      char v63 = 0LL;
      uint64_t v59 = 0LL;
LABEL_318:
      int v111 = 0;
      uint64_t v30 = (AAByteStream_impl *)v22;
      LODWORD(v22) = (_DWORD)v315;
      goto LABEL_103;
    }

    uint64_t v53 = aaSegmentStreamOpen(v49, (void *)v48);
    uint64_t v59 = (AAByteStream_impl *)v53;
    if (!v53)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  238,  134,  0,  "aaSegmentStreamOpen",  v57,  v58,  v282);
      char v63 = 0LL;
      goto LABEL_318;
    }

    unint64_t v309 = v47;
    int v60 = aaForkInputStreamOpen(v53, v48, 0, v54, v55, v56, v57, v58);
    char v63 = (AAByteStream_impl *)v60;
    if (!v60)
    {
      int v269 = "aaForkInputStreamOpen";
      __int16 v270 = 240;
LABEL_317:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  v270,  134,  0,  v269,  v61,  v62,  v282);
      goto LABEL_318;
    }

    v313 = (_BYTE *)v48;
    if ((GetLargeFileControlsWithStreams( (uint64_t)v60,  *(void *)(v48 + 2072),  (unint64_t)v45,  *(void *)(v21 + 2072),  (void **)(*((void *)&v320 + 1) + 80 * v317 + 40),  (uint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56),  (uint64_t *)&v319) & 0x80000000) != 0)
    {
      int v269 = "GetLargeFileControlsWithStreams";
      __int16 v270 = 246;
      goto LABEL_317;
    }

    uint64_t v64 = *(void *)(v21 + 2160);
    uint64_t v30 = (AAByteStream_impl *)v22;
    uint64_t v22 = (void **)v315;
    if (v64)
    {
      uint64_t v65 = *((void *)&v320 + 1) + 80 * v317;
      AAByteStream v307 = (AAByteStream)(v65 + 56);
      uint64_t v66 = *(void *)(v65 + 56);
      if (!v66)
      {
        unint64_t v256 = "empty controls";
        __int16 v257 = 124;
LABEL_293:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_append_copy_forks",  v257,  134,  0,  v256,  v61,  v62,  v282);
        goto LABEL_294;
      }

      if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0 || (v313[2128] & 0x10) == 0)
      {
        unint64_t v256 = "no digests found";
        __int16 v257 = 126;
        goto LABEL_293;
      }

      uint64_t v22 = (void **)(v65 + 40);
      size_t v67 = 24 * (v66 + v64);
      if (v67 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_332;
      }

      int v305 = *(_DWORD *)(a1 + 40);
      char v68 = *v22;
      uint64_t v69 = (uint64_t *)realloc(*v22, v67);
      if (!v69)
      {
        free(v68);
        uint64_t v37 = v311;
LABEL_332:
        const char *v22 = 0LL;
        v276 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_append_copy_forks",  130,  134,  *v276,  "aaReallocf",  v277,  v278,  v282);
        LODWORD(v22) = (_DWORD)v315;
LABEL_294:
        unint64_t v258 = "controls_append_copy_forks";
        __int16 v259 = 250;
LABEL_295:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  v259,  134,  0,  v258,  v99,  v100,  v282);
        goto LABEL_102;
      }

      const char *v22 = v69;
      uint64_t v70 = *(void *)v307;
      if (*(void *)v307)
      {
        uint64_t v71 = 0LL;
        uint64_t v72 = v69 + 2;
        uint64_t v73 = *(void *)v307;
        uint64_t v22 = (void **)v315;
        uint64_t v37 = v311;
        do
        {
          uint64_t v74 = *(v72 - 2);
          if (v74 < 0) {
            uint64_t v74 = 0x8000000000000000LL - v74;
          }
          uint64_t v76 = *v72;
          v72 += 3;
          uint64_t v75 = v76;
          unint64_t v77 = 0x8000000000000000LL - v76;
          if (v76 < 0) {
            uint64_t v75 = v77;
          }
          v71 += v74 + v75;
          --v73;
        }

        while (v73);
      }

      else
      {
        uint64_t v71 = 0LL;
        uint64_t v22 = (void **)v315;
        uint64_t v37 = v311;
      }

      unint64_t v78 = *(void *)(v21 + 2160);
      if (v78)
      {
        unint64_t v79 = 0LL;
        uint64_t v80 = *(void *)(v21 + 2144);
        uint64_t v81 = (char *)(v69 - 1);
        do
        {
          uint64_t v82 = v80 + 440 * v79;
          if ((*(_BYTE *)(v82 + 408) & 2) != 0)
          {
            uint64_t v83 = *((void *)v313 + 270);
            if (!v83) {
              goto LABEL_292;
            }
            uint64_t v84 = *((void *)v313 + 268);
            uint64_t v85 = (void *)(v80 + 440 * v79);
            size_t v86 = v85 + 49;
            uint64_t v87 = v85 + 50;
            uint64_t v88 = v85 + 4;
            while (1)
            {
              if ((*(_BYTE *)(v84 + 408) & 2) != 0 && *(void *)(v84 + 392) == *v86 && *(void *)(v84 + 400) == *v87)
              {
                uint64_t v89 = *(void *)(v84 + 32);
                if (v89 == *v88)
                {
                  uint64_t v61 = *(void *)(v82 + 8);
                  uint64_t v62 = *(void *)(v84 + 16);
                  BOOL v90 = *(void *)v84 == *(void *)v82 && *(void *)(v84 + 8) == v61;
                  BOOL v91 = v90 && v62 == *(void *)(v82 + 16);
                  uint64_t v22 = (void **)v315;
                  BOOL v92 = v91 && *(void *)(v84 + 24) == *(void *)(v82 + 24);
                  uint64_t v37 = v311;
                  if (v92) {
                    break;
                  }
                }
              }

              v84 += 440LL;
              if (!--v83) {
                goto LABEL_292;
              }
            }

            uint64_t v93 = *(void *)(v84 + 48);
            if (v93 < 0)
            {
LABEL_292:
              unint64_t v256 = "copy fork not found";
              __int16 v257 = 161;
              goto LABEL_293;
            }

            uint64_t v94 = 3 * v70++;
            *(void *)AAByteStream v307 = v70;
            uint64_t v95 = (char *)&v69[v94];
            uint64_t v96 = 8 * v94;
            *((void *)v95 + 1) = 0LL;
            *((void *)v95 + 2) = 0LL;
            uint64_t v97 = *(void *)&v81[8 * v94];
            if (v97 < 0) {
              uint64_t v97 = 0x8000000000000000LL - v97;
            }
            v98.i64[0] = v97 + v93 - v71;
            v98.i64[1] = v89;
            *(int8x16_t *)&v81[v96] = vbslq_s8( (int8x16_t)vcltzq_s64(v98),  (int8x16_t)vsubq_s64(v303, v98),  (int8x16_t)v98);
            uint64_t v71 = v93 + v89;
            unint64_t v78 = *(void *)(v21 + 2160);
          }

          ++v79;
        }

        while (v79 < v78);
      }

      if (v305 >= 2) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "ImageDiff: Processed copy forks: %zd controls\n", v70);
      }
    }

    if ((*(_BYTE *)(a1 + 32) & 1) != 0
      && (rawimg_force_in_place( (void *)(*((void *)&v320 + 1) + 80 * v317 + 40),  (unint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56),  v313,  v21,  (uint64_t)v22,  *(_DWORD *)(a1 + 40)) & 0x80000000) != 0)
    {
      unint64_t v258 = "rawimg_force_in_place";
      __int16 v259 = 258;
      goto LABEL_295;
    }

    if (AAByteStreamClose(v63) < 0)
    {
      unint64_t v258 = "AAByteStreamClose";
      __int16 v259 = 262;
      goto LABEL_295;
    }

    if (AAByteStreamClose(v59) < 0) {
      break;
    }
    int v103 = AAByteStreamClose(v52);
    unint64_t v46 = v309;
    if (v103 < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  264,  134,  0,  "AAByteStreamClose",  v43,  v44,  v282);
      char v63 = 0LL;
      uint64_t v59 = 0LL;
      goto LABEL_102;
    }
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  263,  134,  0,  "AAByteStreamClose",  v101,  v102,  v282);
  char v63 = 0LL;
LABEL_102:
  int v111 = 0;
LABEL_103:
  if (AAByteStreamClose((AAByteStream)v45) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  280,  134,  0,  "AAByteStreamClose",  v112,  v113,  v282);
    int v111 = 0;
  }

  if (AAByteStreamClose(v37) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  281,  134,  0,  "AAByteStreamClose",  v114,  v115,  v282);
    if ((AAByteStreamClose(v30) & 0x80000000) == 0) {
      goto LABEL_112;
    }
LABEL_111:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_create_with_variants",  282,  134,  0,  "AAByteStreamClose",  v116,  v117,  v282);
    goto LABEL_112;
  }

  if (AAByteStreamClose(v30) < 0) {
    goto LABEL_111;
  }
  if (!v111)
  {
LABEL_112:
    AAByteStreamClose(v63);
    AAByteStreamClose(v59);
    AAByteStreamClose(v52);
    BXDiff5Data_free((uint64_t)&v319);
    uint64_t v105 = "controls_create_with_variants";
    __int16 v106 = 612;
    goto LABEL_113;
  }

  int v118 = (int)v22;
  unint64_t v119 = 8LL * *(void *)a1 + 62;
  if (v119 >= 0x2000000001LL)
  {
    *__error() = 12;
    goto LABEL_281;
  }

  int v122 = *(_DWORD *)(a1 + 32);
  __int128 v123 = (char *)calloc(1uLL, 8LL * *(void *)a1 + 62);
  if (!v123)
  {
LABEL_281:
    BOOL v247 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write",  515,  134,  *v247,  "aaCalloc",  v248,  v249,  v282);
    uint64_t v124 = 0LL;
    unsigned int v129 = 0LL;
LABEL_303:
    int v262 = 1;
    goto LABEL_304;
  }

  uint64_t v124 = (uint64_t)v123;
  *(void *)__int128 v123 = 0x3031464649444952LL;
  *((_WORD *)v123 + 4) = *(_WORD *)a1 + 1;
  *(void *)(v123 + 10) = v122 & 1;
  if ((v122 & 1) != 0) {
    int v125 = v118;
  }
  else {
    int v125 = 0;
  }
  *(_DWORD *)(v123 + 26) = v125;
  *(void *)(v123 + 30) = v119;
  uint64_t v126 = AAFileStreamOpenWithPath(*(const char **)(a1 + 24), 1537, 0x1A4u);
  unsigned int v129 = v126;
  if (!v126)
  {
    uint64_t v254 = "AAFileStreamOpenWithPath";
    __int16 v255 = 526;
LABEL_302:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write",  v255,  134,  0,  v254,  v127,  v128,  v282);
    goto LABEL_303;
  }

  if (AAByteStreamSeek(v126, v119, 0) < 0)
  {
    uint64_t v254 = "AAByteStreamSeek";
    __int16 v255 = 527;
    goto LABEL_302;
  }

  uint64_t v130 = *(unsigned int *)(a1 + 40);
  else {
    AAFlagSet v131 = 0xC000000000000000LL;
  }
  unint64_t v137 = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v131, *(_DWORD *)(a1 + 36));
  if (!v137)
  {
    unint64_t v260 = "AACompressionOutputStreamOpen";
    __int16 v261 = 305;
    goto LABEL_299;
  }

  unint64_t v138 = 0LL;
  do
  {
    if ((rawimg_save_to_stream(v137, v11[v138], v138 == 0, v132, v133, v134, v135, v136) & 0x80000000) != 0)
    {
      unint64_t v260 = "rawimg_save_to_stream";
      __int16 v261 = 311;
LABEL_299:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_metadata",  v261,  134,  0,  v260,  v135,  v136,  v282);
      if ((AAByteStreamClose(v137) & 0x80000000) == 0)
      {
LABEL_301:
        uint64_t v254 = "patch_write_metadata";
        __int16 v255 = 530;
        goto LABEL_302;
      }

LABEL_300:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_metadata",  315,  134,  0,  "AAByteStreamClose",  v127,  v128,  v282);
      goto LABEL_301;
    }

    ++v138;
  }

  while (v138 <= *(void *)a1);
  if (AAByteStreamClose(v137) < 0) {
    goto LABEL_300;
  }
  uint64_t v139 = patch_write_controls(v129, (unint64_t *)&v319, v124, a1);
  if (!v139)
  {
    uint64_t v254 = "patch_write_controls";
    __int16 v255 = 534;
    goto LABEL_302;
  }

  uint64_t v292 = v139;
  uint64_t v140 = 0LL;
  do
  {
    uint64_t v141 = v11[v140];
    uint64_t v300 = *v11;
    off_t v142 = AAByteStreamSeek(v129, 0LL, 1);
    v299 = (off_t *)(v124 + 46 + 8 * v140);
    off_t *v299 = v142;
    uint64_t v310 = v140;
    if (v142 < 0)
    {
      __int16 v160 = 383;
      __int16 v161 = "AAByteStreamSeek";
LABEL_147:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  v160,  134,  0,  v161,  v143,  v144,  v282);
      v312 = 0LL;
      v314 = 0LL;
      v318 = 0LL;
      v302 = 0LL;
      v304 = 0LL;
      v316 = 0LL;
      v306 = 0LL;
      v308 = 0LL;
      goto LABEL_148;
    }

    LODWORD(v145) = *(_DWORD *)(a1 + 40);
    else {
      uint64_t v145 = v145;
    }
    s = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v145 << 62, *(_DWORD *)(a1 + 36));
    if (!s)
    {
      __int16 v160 = 387;
      __int16 v161 = "AACompressionOutputStreamOpen";
      goto LABEL_147;
    }

    if (v140)
    {
      AAByteStream v146 = AAFileStreamOpenWithPath(*(const char **)(v141 + 2048), 0, 0);
      if (!v146)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  394,  134,  0,  "AAFileStreamOpenWithPath",  v147,  v148,  v282);
        v312 = 0LL;
        v314 = 0LL;
        v318 = 0LL;
        v302 = 0LL;
        v304 = 0LL;
        v316 = 0LL;
        v306 = 0LL;
        v308 = 0LL;
        goto LABEL_254;
      }

      v308 = v146;
      uint64_t v149 = aaSegmentStreamOpen(v146, (void *)v141);
      if (!v149)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  396,  134,  0,  "aaSegmentStreamOpen",  v153,  v154,  v282);
        v312 = 0LL;
        v314 = 0LL;
        v318 = 0LL;
        v302 = 0LL;
        v304 = 0LL;
        v316 = 0LL;
        v306 = 0LL;
        goto LABEL_254;
      }

      v306 = (AAByteStream_impl *)v149;
      v316 = (AAByteStream_impl *)aaForkInputStreamOpen(v149, v141, 0, v150, v151, v152, v153, v154);
      if (!v316)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  398,  134,  0,  "aaForkInputStreamOpen",  v155,  v156,  v282);
        v312 = 0LL;
        v314 = 0LL;
        v318 = 0LL;
        v302 = 0LL;
        v304 = 0LL;
        v316 = 0LL;
        goto LABEL_254;
      }

      v312 = malloc(0x10000uLL);
      if (!v312)
      {
        __int16 v157 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  400,  134,  *v157,  "aaMalloc",  v158,  v159,  v282);
        v312 = 0LL;
        v314 = 0LL;
        goto LABEL_235;
      }
    }

    else
    {
      v312 = 0LL;
      v316 = 0LL;
      v306 = 0LL;
      v308 = 0LL;
    }

    uint64_t v164 = v300;
    AAByteStream v165 = AAFileStreamOpenWithPath(*(const char **)(v300 + 2048), 0, 0);
    if (!v165)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  405,  134,  0,  "AAFileStreamOpenWithPath",  v166,  v167,  v282);
      v314 = 0LL;
LABEL_235:
      v318 = 0LL;
      v302 = 0LL;
      v304 = 0LL;
LABEL_254:
      int v163 = 0;
      int v162 = s;
      goto LABEL_255;
    }

    v304 = v165;
    char v168 = aaSegmentStreamOpen(v165, (void *)v300);
    if (!v168)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  407,  134,  0,  "aaSegmentStreamOpen",  v172,  v173,  v282);
      v314 = 0LL;
      v318 = 0LL;
      v302 = 0LL;
      goto LABEL_254;
    }

    v302 = (AAByteStream_impl *)v168;
    v318 = aaForkInputStreamOpen(v168, v300, 0, v169, v170, v171, v172, v173);
    if (!v318)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  409,  134,  0,  "aaForkInputStreamOpen",  v174,  v175,  v282);
      v314 = 0LL;
      v318 = 0LL;
      goto LABEL_254;
    }

    unsigned int v176 = malloc(0x10000uLL);
    if (!v176)
    {
      __int16 v221 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  411,  134,  *v221,  "aaMalloc",  v222,  v223,  v282);
      v314 = 0LL;
      goto LABEL_254;
    }

    v314 = v176;
    uint64_t v179 = v292;
    if (*(void *)(v124 + 18))
    {
      uint64_t v180 = 0LL;
      unint64_t v181 = 0LL;
      uint64_t v182 = 0LL;
      unint64_t v183 = 0LL;
      uint64_t v283 = v140 + 1;
      while (1)
      {
        unint64_t v289 = v183;
        v288 = (unint64_t *)(v179 + 8 * (v183 + v183 * *(unsigned __int16 *)(v124 + 8)));
        uint64_t v184 = v288[1];
        unint64_t v185 = 0x8000000000000000LL - *v288;
        if ((*v288 & 0x8000000000000000LL) == 0LL) {
          unint64_t v185 = *v288;
        }
        unint64_t v186 = 0x8000000000000000LL - v184;
        if (v184 >= 0) {
          unint64_t v186 = v288[1];
        }
        if (v140)
        {
          unint64_t v286 = v186;
          unint64_t v187 = *(void *)(v164 + 2072);
          if (v181 < v187 && v185 + v181 > v187)
          {
            __int16 v227 = 427;
            goto LABEL_246;
          }

          BOOL v188 = v181 >= v187;
          if (v181 >= v187) {
            unint64_t v189 = v185 + v181;
          }
          else {
            unint64_t v189 = v181;
          }
          if (v181 >= v187) {
            unint64_t v190 = v185;
          }
          else {
            unint64_t v190 = 0LL;
          }
          unint64_t v293 = v189;
          uint64_t v295 = v190 + v180;
          uint64_t v284 = v182;
          if (!v188 && v185)
          {
            unint64_t v191 = v185;
            unint64_t v290 = v185;
            while (1)
            {
              unint64_t v291 = v191;
              if (v191 >= 0x10000) {
                uint64_t v192 = 0x10000LL;
              }
              else {
                uint64_t v192 = v191;
              }
              if (!*((void *)v316 + 4)) {
                goto LABEL_248;
              }
              uint64_t v193 = 0LL;
              __int128 v194 = v312;
              uint64_t v195 = v295;
              unint64_t v297 = v192;
              while (1)
              {
                uint64_t v196 = (*((uint64_t (**)(void, _BYTE *, uint64_t, uint64_t))v316 + 4))( *(void *)v316,  v194,  v192,  v195);
                if (v196 < 0) {
                  break;
                }
                if (v196)
                {
                  v194 += v196;
                  v193 += v196;
                  v195 += v196;
                  v192 -= v196;
                  if (v192) {
                    continue;
                  }
                }

                goto LABEL_183;
              }

              uint64_t v193 = v196;
LABEL_183:
              unint64_t v197 = v297;
              if (v297 != v193)
              {
LABEL_248:
                __int16 v227 = 442;
                goto LABEL_251;
              }

              __int128 v198 = v314;
              if (!v318[4]) {
                goto LABEL_250;
              }
              uint64_t v199 = 0LL;
              unint64_t v200 = v293;
              while (1)
              {
                uint64_t v201 = ((uint64_t (*)(uint64_t, _BYTE *, unint64_t, unint64_t))v318[4])( *v318,  v198,  v197,  v200);
                if (v201 < 0) {
                  break;
                }
                if (v201)
                {
                  v198 += v201;
                  v199 += v201;
                  v200 += v201;
                  v197 -= v201;
                  if (v197) {
                    continue;
                  }
                }

                goto LABEL_191;
              }

              uint64_t v199 = v201;
LABEL_191:
              unint64_t v202 = v297;
              __int128 v203 = v314;
              if (v297 != v199)
              {
LABEL_250:
                __int16 v227 = 443;
                goto LABEL_251;
              }

              uint64_t v204 = 0LL;
              uint64_t v205 = v297 <= 1 ? 1LL : v297;
              do
              {
                v314[v204] -= v312[v204];
                ++v204;
              }

              while (v205 != v204);
              if (!*((void *)s + 3)) {
                break;
              }
              uint64_t v206 = 0LL;
              while (1)
              {
                uint64_t v207 = (*((uint64_t (**)(void, _BYTE *, unint64_t))s + 3))(*(void *)s, v203, v202);
                if (v207 < 1) {
                  break;
                }
                v203 += v207;
                v206 += v207;
                v202 -= v207;
                if (!v202) {
                  goto LABEL_202;
                }
              }

              uint64_t v206 = v207;
LABEL_202:
              unsigned int v176 = v314;
              if (v297 != v206) {
                break;
              }
              v295 += v297;
              v293 += v297;
              unint64_t v191 = v291 - v297;
              unint64_t v185 = v290;
              if (v291 == v297) {
                goto LABEL_204;
              }
            }

            __int16 v227 = 447;
            uint64_t v228 = "aaByteStreamWriteExpected";
            goto LABEL_253;
          }

LABEL_204:
          uint64_t v182 = v284;
          uint64_t v208 = v288[v283];
          if (v208 < 0) {
            uint64_t v208 = 0x8000000000000000LL - v208;
          }
          uint64_t v180 = v208 + v295;
          unint64_t v181 = v293 + v286;
          uint64_t v164 = v300;
        }

        else
        {
          v181 += v185;
          if (v186)
          {
            uint64_t v294 = v180;
            uint64_t v285 = v182;
            unint64_t v287 = v186;
            unint64_t v209 = v186;
            while (1)
            {
              uint64_t v210 = v209 >= 0x10000 ? 0x10000LL : v209;
              if (!v318[4]) {
                break;
              }
              uint64_t v211 = 0LL;
              int v212 = v176;
              unint64_t v296 = v181;
              uint64_t v298 = v210;
              unint64_t v213 = v181;
              while (1)
              {
                uint64_t v214 = ((uint64_t (*)(uint64_t, char *, uint64_t, unint64_t))v318[4])( *v318,  v212,  v210,  v213);
                if (v214 < 0) {
                  break;
                }
                if (v214)
                {
                  v212 += v214;
                  v211 += v214;
                  v213 += v214;
                  v210 -= v214;
                  if (v210) {
                    continue;
                  }
                }

                goto LABEL_219;
              }

              uint64_t v211 = v214;
LABEL_219:
              uint64_t v215 = v298;
              uint64_t v216 = v314;
              if (v298 != v211) {
                break;
              }
              unint64_t v217 = v209;
              int v162 = s;
              if (!*((void *)s + 3)) {
                goto LABEL_249;
              }
              uint64_t v218 = 0LL;
              while (1)
              {
                uint64_t v219 = (*((uint64_t (**)(void, _BYTE *, uint64_t))s + 3))(*(void *)s, v216, v215);
                if (v219 < 1) {
                  break;
                }
                v216 += v219;
                v218 += v219;
                v215 -= v219;
                if (!v215) {
                  goto LABEL_226;
                }
              }

              uint64_t v218 = v219;
LABEL_226:
              unsigned int v176 = v314;
              if (v298 != v218)
              {
LABEL_249:
                pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  467,  134,  0,  "aaByteStreamWriteExpected",  v177,  v178,  v282);
                goto LABEL_149;
              }

              unint64_t v181 = v298 + v296;
              unint64_t v209 = v217 - v298;
              if (v217 == v298)
              {
                uint64_t v182 = v285;
                unint64_t v185 = v287;
                uint64_t v140 = v310;
                uint64_t v164 = v300;
                unint64_t v220 = v289;
                uint64_t v180 = v294;
                goto LABEL_231;
              }
            }

            __int16 v227 = 466;
LABEL_251:
            uint64_t v228 = "aaByteStreamPReadExpected";
            goto LABEL_253;
          }

          unint64_t v185 = 0LL;
        }

        unint64_t v220 = v289;
LABEL_231:
        v182 += v185;
        unint64_t v183 = v220 + 1;
        uint64_t v179 = v292;
        if (v183 >= *(void *)(v124 + 18)) {
          goto LABEL_242;
        }
      }
    }

    uint64_t v182 = 0LL;
    unint64_t v181 = 0LL;
LABEL_242:
    if (v181 != *(void *)(v164 + 2080))
    {
      __int16 v227 = 472;
LABEL_246:
      uint64_t v228 = "bad controls";
LABEL_253:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  v227,  134,  0,  v228,  v177,  v178,  v282);
      goto LABEL_254;
    }

    uint64_t v224 = v182;
    if (AAByteStreamClose(s) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  475,  134,  0,  "AAByteStreamClose",  v225,  v226,  v282);
      int v163 = 0;
    }

    else
    {
      int v163 = 1;
    }

    off_t v243 = AAByteStreamSeek(v129, 0LL, 1);
    v299[1] = v243;
    if ((v243 & 0x8000000000000000LL) == 0)
    {
      if (*(int *)(a1 + 40) >= 2)
      {
        BOOL v246 = "Diff";
        if (!v310) {
          BOOL v246 = "Literal";
        }
        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s stream: %llu bytes -> %llu bytes\n", v246, v224, v243 - *v299);
      }

      int v162 = 0LL;
      goto LABEL_255;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  480,  134,  0,  "AAByteStreamSeek",  v244,  v245,  v282);
LABEL_148:
    int v162 = 0LL;
LABEL_149:
    int v163 = 0;
LABEL_255:
    if (AAByteStreamClose(v162) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  489,  134,  0,  "AAByteStreamClose",  v229,  v230,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose(v316) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  490,  134,  0,  "AAByteStreamClose",  v231,  v232,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose(v306) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  491,  134,  0,  "AAByteStreamClose",  v233,  v234,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose(v308) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  492,  134,  0,  "AAByteStreamClose",  v235,  v236,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose((AAByteStream)v318) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  493,  134,  0,  "AAByteStreamClose",  v237,  v238,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose(v302) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  494,  134,  0,  "AAByteStreamClose",  v239,  v240,  v282);
      int v163 = 0;
    }

    if (AAByteStreamClose(v304) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write_stream",  495,  134,  0,  "AAByteStreamClose",  v241,  v242,  v282);
      int v163 = 0;
    }

    free(v312);
    free(v314);
    if (!v163)
    {
      uint64_t v254 = "patch_write_stream";
      __int16 v255 = 539;
      goto LABEL_302;
    }

    uint64_t v140 = v310 + 1;
  }

  while ((unint64_t)(v310 + 1) <= *(void *)a1);
  if (!*((void *)v129 + 5)) {
    goto LABEL_341;
  }
  uint64_t v271 = 0LL;
  uint64_t v272 = 0LL;
  uint64_t v273 = v124;
  unint64_t v274 = v119;
  while (1)
  {
    uint64_t v275 = (*((uint64_t (**)(void, uint64_t, unint64_t, uint64_t))v129 + 5))( *(void *)v129,  v273,  v274,  v272);
    if (v275 < 1) {
      break;
    }
    v273 += v275;
    v271 += v275;
    v272 += v275;
    v274 -= v275;
    if (!v274) {
      goto LABEL_335;
    }
  }

  uint64_t v271 = v275;
LABEL_335:
  if (v119 != v271)
  {
LABEL_341:
    uint64_t v254 = "aaByteStreamPWriteExpected";
    __int16 v255 = 543;
    goto LABEL_302;
  }

  int v279 = *(_DWORD *)(a1 + 40);
  if (v279 > 1)
  {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "  Metadata: %llu bytes\n  Controls: %llu bytes\n",  *(void *)(v124 + 38) - *(void *)(v124 + 30),  *(void *)(v124 + 46) - *(void *)(v124 + 38));
    int v279 = *(_DWORD *)(a1 + 40);
  }

  if (v279 >= 1) {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "%12llu final patch size\n",  *(void *)(v124 + 8LL * *(unsigned __int16 *)(v124 + 8) + 46));
  }
  int v262 = 0;
LABEL_304:
  if (AAByteStreamClose(v129) < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"patch_write",  562,  134,  0,  "AAByteStreamClose",  v263,  v264,  v282);
    free((void *)v124);
  }

  else
  {
    free((void *)v124);
    if (!v262)
    {
      uint64_t v104 = 0LL;
      goto LABEL_114;
    }
  }

  uint64_t v105 = "patch_write";
  __int16 v106 = 615;
LABEL_113:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"RawImageDiff",  v106,  134,  0,  v105,  v17,  v18,  v282);
  uint64_t v104 = 0xFFFFFFFFLL;
LABEL_114:
  unint64_t v120 = 0LL;
  do
    rawimg_destroy((uint64_t *)v11[v120++]);
  while (v120 <= *(void *)a1);
  free(v11);
LABEL_117:
  BXDiff5Data_free((uint64_t)&v319);
  return v104;
}

double BXDiff5Data_free(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v3 = 0LL;
      uint64_t v4 = 40LL;
      do
      {
        free(*(void **)(*(void *)(a1 + 24) + v4));
        ++v3;
        v4 += 80LL;
      }

      while (v3 < *(void *)(a1 + 16));
      unint64_t v2 = *(void **)(a1 + 24);
    }

    free(v2);
  }

  free(*(void **)(a1 + 72));
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t controls_combo_enforce_copy_fork_boundary( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  unint64_t v9 = a2[11];
  if (v9)
  {
    uint64_t v11 = 0LL;
    unint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    unint64_t v36 = a2[2];
    uint64_t v14 = v36 + 2;
    uint64_t v15 = 8 * (v36 + 2);
    if (v36 == 0 || v36 >= 0xFFFFFFFFFFFFFFFELL) {
      uint64_t v14 = 2LL;
    }
    uint64_t v35 = 8 * v14 - 8;
    uint64_t v16 = -1LL;
    while (1)
    {
      uint64_t v17 = (char *)a2[9];
      uint64_t v18 = *(void *)&v17[v11];
      if (v18 >= 0) {
        unint64_t v19 = *(void *)&v17[v11];
      }
      else {
        unint64_t v19 = 0x8000000000000000LL - v18;
      }
      unint64_t v20 = *(void *)(v8 + 2072);
      unint64_t v21 = v19 + v12;
      uint64_t v22 = v20 - v12;
      if (v20 > v12 && v21 > v20)
      {
        unint64_t v25 = v9 + 1;
        a2[11] = v25;
        if (v15 * v25 >= 0x2000000001LL)
        {
          *__error() = 12;
          goto LABEL_32;
        }

        uint64_t v26 = (char *)realloc(v17, v15 * v25);
        if (!v26)
        {
          free(v17);
LABEL_32:
          a2[9] = 0LL;
          uint64_t v32 = "aaReallocf";
          __int16 v33 = 88;
LABEL_33:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c",  (uint64_t)"controls_combo_enforce_copy_fork_boundary",  v33,  134,  0,  v32,  a7,  a8,  v34);
          return 0xFFFFFFFFLL;
        }

        a2[9] = v26;
        AAByteStream v27 = (uint64_t *)&v26[v11];
        uint64_t v28 = (unint64_t *)&v26[v11 + v15];
        memmove(v28, &v26[v11], v15 * (v16 + a2[11]));
        uint64_t v29 = 0x8000000000000000LL - v22;
        if (v22 >= 0) {
          uint64_t v29 = v22;
        }
        *AAByteStream v27 = v29;
        if (v36 <= 0xFFFFFFFFFFFFFFFDLL) {
          bzero(v27 + 1, v35);
        }
        unint64_t v30 = v19 - v22;
        *uint64_t v28 = v30;
        unint64_t v9 = a2[11];
        unint64_t v12 = v20;
        uint64_t v8 = a1;
      }

      else
      {
        uint64_t v24 = *(void *)&v17[v11 + 8];
        if (v24 < 0) {
          uint64_t v24 = 0x8000000000000000LL - v24;
        }
        unint64_t v12 = v21 + v24;
      }

      ++v13;
      v11 += v15;
      --v16;
      if (v13 >= v9) {
        goto LABEL_27;
      }
    }
  }

  unint64_t v12 = 0LL;
LABEL_27:
  if (v12 != *(void *)(v8 + 2080))
  {
    uint64_t v32 = "SIZE MISMATCH";
    __int16 v33 = 108;
    goto LABEL_33;
  }

  return 0LL;
}

uint64_t *AEADecryptToFileAsyncStreamOpen( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  strcpy(v30, ".tmp_decrypt");
  memset(&v29, 0, sizeof(v29));
  unint64_t v12 = malloc(0x898uLL);
  uint64_t v13 = (uint64_t)v12;
  if (v12)
  {
    memset_s(v12, 0x898uLL, 0, 0x898uLL);
    uint64_t v14 = (uint64_t *)malloc(0x38uLL);
    uint64_t v15 = v14;
    if (v14)
    {
      memset_s(v14, 0x38uLL, 0, 0x38uLL);
      *(void *)(v13 + 8) = a2;
      *(void *)(v13 + 16) = a3;
      *(void *)(v13 + 24) = a4;
      *(void *)(v13 + 2084) = -1LL;
      *(_DWORD *)(v13 + 2080) = a5 >> 62;
      if (pthread_mutex_init((pthread_mutex_t *)(v13 + 2136), 0LL))
      {
        uint64_t v18 = "MutexInit";
        __int16 v19 = 290;
      }

      else if (strlen(a1) - 1012 > 0xFFFFFFFFFFFFFBFELL)
      {
        __strlcpy_chk();
        __strlcpy_chk();
        __strlcat_chk();
        int v25 = stat((const char *)(v13 + 32), &v29);
        if (v25 || (v29.st_mode & 0xF000) == 0x8000)
        {
          int v26 = stat((const char *)(v13 + 1056), &v29);
          if (v26 || (v29.st_mode & 0xF000) == 0x8000)
          {
            if (v26 | v25)
            {
              AAByteStream v27 = AEADecryptAsyncStreamOpen( v13,  (uint64_t)setupContext,  (uint64_t)verifySegment,  (uint64_t)processSegment_0,  a5,  a6);
              *(void *)uint64_t v13 = v27;
              if (v27)
              {
                *uint64_t v15 = v13;
                v15[1] = (uint64_t)decryptToFileAsyncClose;
                v15[2] = (uint64_t)decryptToFileAsyncGetRange;
                v15[3] = (uint64_t)decryptToFileAsyncProcess;
                v15[4] = (uint64_t)decryptToFileAsyncCancel;
                return v15;
              }

              uint64_t v18 = "creating DecryptAsyncStream";
              __int16 v19 = 313;
            }

            else
            {
              char v28 = v13 + 32;
              uint64_t v18 = "Both file and temp file exist: %s";
              __int16 v19 = 309;
            }
          }

          else
          {
            char v28 = v13 + 32;
            uint64_t v18 = "Temp file exists but is not a regular file: %s";
            __int16 v19 = 306;
          }
        }

        else
        {
          char v28 = v13 + 32;
          uint64_t v18 = "File exists but is not a regular file: %s";
          __int16 v19 = 301;
        }
      }

      else
      {
        char v28 = (char)a1;
        uint64_t v18 = "Filename is too long: %s";
        __int16 v19 = 293;
      }

      int v23 = 0;
    }

    else
    {
      int v23 = *__error();
      uint64_t v18 = "malloc";
      __int16 v19 = 281;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"AEADecryptToFileAsyncStreamOpen",  v19,  98,  v23,  v18,  v16,  v17,  v28);
  }

  else
  {
    unint64_t v20 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"AEADecryptToFileAsyncStreamOpen",  279,  98,  *v20,  "malloc",  v21,  v22,  v28);
    uint64_t v15 = 0LL;
  }

  decryptToFileAsyncClose(v13);
  free(v15);
  return 0LL;
}

uint64_t setupContext( uint64_t a1, AEAContext context, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(uint64_t (**)(void, AEAContext))(a1 + 16);
  if (v10 && (v10(*(void *)(a1 + 8), context) & 0x80000000) != 0)
  {
    uint64_t v11 = "Client context callback returned an error";
    __int16 v12 = 58;
    goto LABEL_9;
  }

  if (!*(_DWORD *)(a1 + 2096))
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 2096) = 1;
    return result;
  }

  if ((*(_DWORD *)(a1 + 2084) & 0x80000000) == 0 || (*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
    uint64_t v11 = "Invalid state, file already open";
    __int16 v12 = 64;
LABEL_9:
    int v14 = 0;
LABEL_10:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"setupContext",  v12,  98,  v14,  v11,  a7,  a8,  v17);
    return 0xFFFFFFFFLL;
  }

  *(void *)(a1 + 2104) = AEAContextGetFieldUInt(context, 0xDu);
  *(void *)(a1 + 2112) = AEAContextGetFieldUInt(context, 4u);
  if (!stat((const char *)(a1 + 32), &v18) && (v18.st_mode & 0xF000) == 0x8000)
  {
    if (v18.st_size && v18.st_size != *(void *)(a1 + 2104))
    {
      char v17 = a1 + 32;
      uint64_t v11 = "Destination file exists and size doesn't match: %s";
      __int16 v12 = 77;
      goto LABEL_9;
    }

    if (rename((const char *)(a1 + 32), (const char *)(a1 + 1056)))
    {
      int v14 = *__error();
      char v17 = a1 + 32;
      uint64_t v11 = "rename: %s";
      __int16 v12 = 82;
      goto LABEL_10;
    }

    if (*(_DWORD *)(a1 + 2080)) {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "Verifying file: %s\n", (const char *)(a1 + 32));
    }
  }

  if (stat((const char *)(a1 + 1056), &v18) || (v18.st_mode & 0xF000) != 0x8000)
  {
    *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 1537, 420LL);
    *(_DWORD *)(a1 + 2092) = 1;
    int v15 = *(_DWORD *)(a1 + 2084);
  }

  else
  {
    int v15 = open((const char *)(a1 + 1056), 0);
    *(_DWORD *)(a1 + 2084) = v15;
  }

  int v16 = *(_DWORD *)(a1 + 2088);
  if (v15 < 0)
  {
    if (v16 < 0)
    {
      int v14 = *__error();
      char v17 = a1 + 32;
      uint64_t v11 = "open: %s";
      __int16 v12 = 98;
      goto LABEL_10;
    }
  }

  else if (v16 < 0)
  {
    return 0LL;
  }

  uint64_t result = ftruncate(v16, *(void *)(a1 + 2104));
  if ((_DWORD)result)
  {
    int v14 = *__error();
    char v17 = a1 + 32;
    uint64_t v11 = "truncate to final size: %s";
    __int16 v12 = 101;
    goto LABEL_10;
  }

  return result;
}

uint64_t verifySegment( uint64_t a1, unint64_t a2, uint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!*(_DWORD *)(a1 + 2092))
  {
    size_t v11 = *(void *)(a1 + 2112);
    if (v11 < a2)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"verifySegment",  117,  98,  0,  "Invalid segment size",  a7,  a8,  v33);
      return 0xFFFFFFFFLL;
    }

    int v35 = 0;
    memset(v34, 0, sizeof(v34));
    if (v11 < 0x2000000001LL)
    {
      __int16 v12 = malloc(v11);
      if (v12)
      {
        unint64_t v21 = 0LL;
        while (a2 > v21)
        {
          ssize_t v22 = pread(*(_DWORD *)(a1 + 2084), (char *)v12 + v21, a2 - v21, v21 + a3);
          if (v22) {
            int v23 = 0;
          }
          else {
            int v23 = 5;
          }
          v21 += v22 & ~(v22 >> 63);
          if (v22 < 0) {
            int v23 = 4;
          }
          if (v23)
          {
            if (v23 == 4) {
              goto LABEL_21;
            }
            break;
          }
        }

        if (v21 == a2)
        {
          int v24 = aeaChecksum((uint64_t)v34, a4, v12, a2, v17, v18, v19, v20);
          uint64_t v8 = 0LL;
          if (v24 < 0 || LODWORD(v34[0]) != a6) {
            goto LABEL_22;
          }
          if (!memcmp((char *)v34 + 4, a5, a6))
          {
            AAByteStream v27 = (unint64_t *)(a1 + 2128);
            do
              unint64_t v28 = __ldxr(v27);
            while (__stxr(v28 + a2, v27));
            stat v29 = *(uint64_t (**)(void, __n128))(a1 + 24);
            if (v29
              && ((unint64_t v30 = *(void *)(a1 + 2104)) == 0
                ? (v25.n128_u32[0] = 0)
                : (v25.n128_f32[0] = (float)((float)*v27 * 100.0) / (float)v30),
                  (v29(*(void *)(a1 + 8), v25) & 0x80000000) != 0))
            {
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"verifySegment",  144,  98,  0,  "Client progress callback reported an error",  v31,  v32,  v33);
              uint64_t v8 = 0xFFFFFFFFLL;
            }

            else
            {
              if (*(_DWORD *)(a1 + 2080) >= 3u) {
                fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment verified: offset=%llu size=%zu\n", a3, a2);
              }
              uint64_t v8 = 1LL;
            }

            goto LABEL_22;
          }
        }
      }

uint64_t processSegment_0( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, __n128 a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if ((*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
LABEL_2:
    unint64_t v13 = 0LL;
    do
    {
      unint64_t v14 = v13;
      if (a2 <= v13) {
        break;
      }
      ssize_t v15 = pwrite(*(_DWORD *)(a1 + 2088), (const void *)(a4 + v13), a2 - v13, v13 + a3);
      unint64_t v13 = v15 + v14;
    }

    while (v15 > 0);
    if (a2 == v14)
    {
      int v16 = (unint64_t *)(a1 + 2128);
      do
        unint64_t v17 = __ldxr(v16);
      while (__stxr(v17 + a2, v16));
      if (*(_DWORD *)(a1 + 2080) >= 3u) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment processed: offset=%llu size=%zu\n", a3, a2);
      }
    }

    else
    {
      uint64_t v20 = (unint64_t *)(a1 + 2120);
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + a2, v20));
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"processSegment",  181,  98,  0,  "Segment write failed: offset=%llu size=%zu\n",  a8,  a9,  a3);
    }

    ssize_t v22 = *(uint64_t (**)(void, __n128))(a1 + 24);
    if (!v22) {
      return 0LL;
    }
    unint64_t v23 = *(void *)(a1 + 2104);
    if (v23) {
      a5.n128_f32[0] = (float)((float)*(unint64_t *)(a1 + 2128) * 100.0) / (float)v23;
    }
    else {
      a5.n128_u32[0] = 0;
    }
    if ((v22(*(void *)(a1 + 8), a5) & 0x80000000) == 0) {
      return 0LL;
    }
    uint64_t v18 = "Client progress callback reported an error";
    __int16 v19 = 190;
    goto LABEL_26;
  }

  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2136)))
  {
    uint64_t v18 = "MutexInit";
    __int16 v19 = 165;
  }

  else
  {
    if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0) {
      *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 2);
    }
    if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2136)))
    {
      if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"processSegment",  168,  98,  0,  "Can't reopen %s for writing",  a8,  a9,  a1 + 32);
        return 0xFFFFFFFFLL;
      }

      goto LABEL_2;
    }

    uint64_t v18 = "MutexUnlock";
    __int16 v19 = 167;
  }

uint64_t decryptToFileAsyncClose(uint64_t a1)
{
  if (a1)
  {
    uint64_t v4 = AAAsyncByteStreamClose(*(uint64_t (***)(void))a1);
    if ((v4 & 0x80000000) != 0) {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"decryptToFileAsyncClose",  207,  98,  0,  "Async stream reported errors",  v2,  v3,  v16);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 2136));
    unint64_t v7 = atomic_load((unint64_t *)(a1 + 2128));
    unint64_t v8 = atomic_load((unint64_t *)(a1 + 2120));
    if (!(_DWORD)v4)
    {
      if (v7 == *(void *)(a1 + 2104) && v8 == 0)
      {
        uint64_t v4 = 0LL;
      }

      else
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"decryptToFileAsyncClose",  216,  98,  0,  "Some segments failed to process",  v5,  v6,  v16);
        uint64_t v4 = 0xFFFFFFFFLL;
      }
    }

    int v10 = *(_DWORD *)(a1 + 2084);
    if (v10 < 0)
    {
      int v11 = *(_DWORD *)(a1 + 2088);
      if (v11 < 0)
      {
        if ((_DWORD)v4) {
          goto LABEL_24;
        }
        goto LABEL_21;
      }
    }

    else
    {
      close(v10);
      int v11 = *(_DWORD *)(a1 + 2088);
      if (v11 < 0)
      {
        if (!(_DWORD)v4)
        {
LABEL_18:
          if (rename((const char *)(a1 + 1056), (const char *)(a1 + 32)))
          {
            __int16 v12 = __error();
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"decryptToFileAsyncClose",  227,  98,  *v12,  "rename: %s",  v13,  v14,  a1 + 32);
            uint64_t v4 = 0xFFFFFFFFLL;
            goto LABEL_24;
          }

void *decryptToFileAsyncCancel(void **a1)
{
  return AAAsyncByteStreamCancel(*a1);
}

uint64_t decryptToFileAsyncGetRange(void **a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*a1, a2, a3);
}

uint64_t decryptToFileAsyncProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*a1, a2, a3, a4);
}

uint64_t AEADecryptToFileChunkAsyncStreamOpen( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, unsigned int a8)
{
  __int16 v12 = AEADecryptToFileAsyncStreamOpen(a1, a2, a3, a4, a7 | 0x200000000000000LL, a8);
  if (v12) {
    return aaCompositeChunkAsyncStreamOpen((uint64_t)v12, a5, a6, a7, a8);
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c",  (uint64_t)"AEADecryptToFileChunkAsyncStreamOpen",  349,  98,  0,  "AEADecryptToFileAsyncStreamOpen",  v13,  v14,  v16);
  return 0LL;
}

void *AATempStreamOpen(unint64_t a1)
{
  return AATempStreamOpenWithDirectory(a1, 0LL);
}

void *AATempStreamOpenWithDirectory(unint64_t a1, const char *a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  uint64_t v5 = (char *)malloc(0x88uLL);
  uint64_t v6 = v5;
  if (v5 && (memset_s(v5, 0x88uLL, 0, 0x88uLL), v4))
  {
    if (a2)
    {
      size_t v7 = strlen(a2);
      size_t v8 = v7 + 1;
      if (v7 + 1 < 0x2000000001LL)
      {
        ssize_t v15 = malloc(v7 + 1);
        unint64_t v9 = v15;
        if (v15) {
          memcpy(v15, a2, v8);
        }
      }

      else
      {
        unint64_t v9 = 0LL;
        *__error() = 12;
      }
    }

    else
    {
      unint64_t v9 = 0LL;
    }

    *((void *)v6 + 13) = v9;
    uint64_t v16 = a1 >> 20;
    if (a1 == -1LL) {
      uint64_t v16 = -1LL;
    }
    *((void *)v6 + 1) = 0x100000LL;
    *((void *)v6 + 2) = v16;
    if ((pthread_mutex_init((pthread_mutex_t *)(v6 + 40), 0LL) & 0x80000000) == 0)
    {
      *uint64_t v4 = v6;
      v4[1] = tempStreamClose;
      v4[6] = tempStreamSeek;
      v4[7] = tempStreamCancel;
      v4[2] = tempStreamRead;
      void v4[3] = tempStreamWrite;
      v4[4] = tempStreamPRead;
      v4[5] = tempStreamPWrite;
      v4[8] = tempStreamTruncate;
      return v4;
    }

    int v10 = *__error();
    uint64_t v13 = "mutex init";
    __int16 v14 = 326;
  }

  else
  {
    int v10 = *__error();
    uint64_t v13 = "malloc";
    __int16 v14 = 320;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"AATempStreamOpenWithDirectory",  v14,  50,  v10,  v13,  v11,  v12,  v18);
  free(v6);
  free(v4);
  return 0LL;
}

uint64_t tempStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 128));
    AAByteStreamClose(*(AAByteStream *)(result + 112));
    uint64_t v3 = *(void **)(v1 + 32);
    if (v3)
    {
      if (*(void *)(v1 + 24))
      {
        unint64_t v4 = 0LL;
        do
          free(*(void **)(*(void *)(v1 + 32) + 8 * v4++));
        while (v4 < *(void *)(v1 + 24));
        uint64_t v3 = *(void **)(v1 + 32);
      }

      free(v3);
    }

    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
    free(*(void **)(v1 + 104));
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t tempStreamCancel(uint64_t result)
{
  uint64_t v1 = (unsigned int *)(result + 128);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1)) {
      return result;
    }
  }

  __clrex();
  return result;
}

ssize_t tempStreamRead(uint64_t a1, void *a2, size_t a3)
{
  if (*(void *)(a1 + 112)) {
    return AAByteStreamRead(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  uint64_t v5 = (unint64_t *)(a1 + 120);
  do
    off_t v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPRead(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPRead(uint64_t a1, char *buf, size_t a3, off_t offset)
{
  unint64_t v4 = (unsigned int *)(a1 + 128);
  unint64_t v8 = offset;
  unint64_t v9 = buf;
  uint64_t v11 = *(AAByteStream_impl **)(a1 + 112);
  if (!v11)
  {
    if (((offset | a3) & 0x8000000000000000LL) == 0)
    {
      int64_t v12 = offset + a3;
      if (!__OFADD__(offset, a3))
      {
        if (*(void *)a1 <= offset) {
          return 0LL;
        }
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
        {
          unint64_t v21 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamPRead",  120,  50,  *v21,  "mutex lock",  v22,  v23,  v29);
          uint64_t v6 = -1LL;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4)) {
              return v6;
            }
          }
        }

        else
        {
          if (v12 >= *(void *)a1) {
            unint64_t v13 = *(void *)a1;
          }
          else {
            unint64_t v13 = v12;
          }
          if (v13 <= v8)
          {
            uint64_t v6 = 0LL;
          }

          else
          {
            uint64_t v6 = 0LL;
            unint64_t v14 = *(void *)(a1 + 8);
            unint64_t v15 = v8 / v14;
            unint64_t v16 = v8 / v14 * v14;
            unint64_t v17 = v16 + v14;
            do
            {
              if (v17 >= v13) {
                unint64_t v18 = v13;
              }
              else {
                unint64_t v18 = v17;
              }
              memcpy(v9, (const void *)(*(void *)(*(void *)(a1 + 32) + 8 * v15) + v8 - v16), v18 - v8);
              v9 += v18 - v8;
              v6 += v18 - v8;
              ++v15;
              uint64_t v19 = *(void *)(a1 + 8);
              v16 += v19;
              unint64_t v8 = v18;
              BOOL v20 = v13 > v17;
              v17 += v19;
            }

            while (v20);
          }

          if ((pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) & 0x80000000) == 0) {
            return v6;
          }
          char v25 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamPRead",  148,  50,  *v25,  "mutex unlock",  v26,  v27,  (char)v4);
          uint64_t v6 = -1LL;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4)) {
              return v6;
            }
          }
        }

        __clrex();
      }
    }

    return -1LL;
  }

  return AAByteStreamPRead(v11, buf, a3, offset);
}

off_t tempStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (!*(void *)(a1 + 112))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        uint64_t v5 = (unint64_t *)(a1 + 120);
        do
        {
          unint64_t v6 = __ldaxr(v5);
          unint64_t v7 = v6 + a2;
        }

        while (__stlxr(v7, v5));
        return v7;
      }

      if (a3 != 2) {
        return -1LL;
      }
      a2 += *(void *)a1;
    }

    atomic_store(a2, (unint64_t *)(a1 + 120));
    return a2;
  }

  return AAByteStreamSeek(*(AAByteStream *)(a1 + 112), a2, a3);
}

ssize_t tempStreamWrite(uint64_t a1, void *a2, size_t a3)
{
  if (*(void *)(a1 + 112)) {
    return AAByteStreamWrite(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  uint64_t v5 = (unint64_t *)(a1 + 120);
  do
    unint64_t v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPWrite(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPWrite(uint64_t a1, char *buf, size_t nbyte, unint64_t offset)
{
  unint64_t v4 = (unsigned int *)(a1 + 128);
  unint64_t v8 = offset;
  int v10 = buf;
  int64_t v12 = *(AAByteStream_impl **)(a1 + 112);
  if (!v12)
  {
    if (((offset | nbyte) & 0x8000000000000000LL) != 0) {
      return -1LL;
    }
    int64_t v13 = offset + nbyte;
    if (__OFADD__(offset, nbyte)) {
      return -1LL;
    }
    unint64_t v14 = (pthread_mutex_t *)(a1 + 40);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
    {
      uint64_t v27 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamPWrite",  164,  50,  *v27,  "mutex lock",  v28,  v29,  v45);
      uint64_t v6 = -1LL;
      while (!__ldaxr(v4))
      {
        if (!__stlxr(1u, v4)) {
          return v6;
        }
      }

uint64_t tempStreamTruncate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = (unsigned int *)(a1 + 128);
  int64_t v13 = *(void **)(a1 + 112);
  if (v13) {
    return AAByteStreamTruncate(v13);
  }
  if (a2 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamTruncate",  271,  50,  0,  "invalid length",  a7,  a8,  v31);
    return 0xFFFFFFFFLL;
  }

  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    uint64_t v23 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamTruncate",  272,  50,  *v23,  "mutex lock",  v24,  v25,  v31);
    uint64_t result = 0xFFFFFFFFLL;
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8)) {
        return result;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  if ((resizeStream(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamTruncate",  274,  50,  0,  "resize stream",  v20,  v21,  v31);
    int v22 = 0;
  }

  else
  {
    int v22 = 1;
  }

  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    uint64_t v27 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"tempStreamTruncate",  276,  50,  *v27,  "mutex lock",  v28,  v29,  v31);
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
      {
        int v22 = 0;
        goto LABEL_22;
      }
    }

    int v22 = 0;
    __clrex();
  }

uint64_t resizeStream( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112))
  {
    unint64_t v8 = "invalid state";
    __int16 v9 = 64;
LABEL_3:
    int v10 = 0;
LABEL_4:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c",  (uint64_t)"resizeStream",  v9,  50,  v10,  v8,  a7,  a8,  v42);
    return 0xFFFFFFFFLL;
  }

  if (*(void *)a1 >= a2) {
    goto LABEL_51;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  if (__OFADD__(a2, v14))
  {
    char v42 = a2;
    unint64_t v8 = "new size out of range: %zu";
    __int16 v9 = 70;
    goto LABEL_3;
  }

  uint64_t v15 = (a2 + v14 - 1) / v14;
  if (v15 <= *(void *)(a1 + 16))
  {
    unint64_t v32 = *(void *)(a1 + 24);
    while (v32 < v15)
    {
      if (v32) {
        v32 *= 2LL;
      }
      else {
        unint64_t v32 = 32LL;
      }
    }

    if (8 * v32 >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_55:
      *(void *)(a1 + 32) = 0LL;
      int v10 = *__error();
      unint64_t v8 = "malloc";
      __int16 v9 = 89;
      goto LABEL_4;
    }

    unint64_t v33 = *(void **)(a1 + 32);
    unint64_t v34 = (char *)realloc(v33, 8 * v32);
    if (!v34)
    {
      free(v33);
      goto LABEL_55;
    }

    *(void *)(a1 + 32) = v34;
    memset_s(&v34[8 * *(void *)(a1 + 24)], 8 * (v32 - *(void *)(a1 + 24)), 0, 8 * (v32 - *(void *)(a1 + 24)));
    *(void *)(a1 + 24) = v32;
    uint64_t v35 = v15 - 1;
    while (v35 != -1 && !*(void *)(*(void *)(a1 + 32) + 8 * v35))
    {
      rsize_t v36 = *(void *)(a1 + 8);
      if (v36 < 0x2000000001LL)
      {
        uint64_t v38 = malloc(*(void *)(a1 + 8));
        unint64_t v37 = v38;
        if (v38) {
          memset_s(v38, v36, 0, v36);
        }
      }

      else
      {
        unint64_t v37 = 0LL;
        *__error() = 12;
      }

      *(void *)(*(void *)(a1 + 32) + 8 * v35) = v37;
      if (!*(void *)(*(void *)(a1 + 32) + 8 * v35--))
      {
        int v10 = *__error();
        unint64_t v8 = "malloc";
        __int16 v9 = 99;
        goto LABEL_4;
      }
    }

uint64_t bxdiff5Alloc(size_t a1, uint64_t *a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(void *)(a3 + 16) = a1;
  uint64_t v3 = *a2;
  *(_DWORD *)(a3 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a3 = v3;
  if (a1) {
    *(void *)(a3 + 24) = calloc(a1, 0x50uLL);
  }
  return 0LL;
}

uint64_t bxdiff5Free( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v9 = 0LL;
    unint64_t v10 = 0LL;
    int v11 = 1;
    do
    {
      uint64_t v12 = *(void *)(a1 + 24);
      if (*(void *)(v12 + v9))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  40,  54,  0,  "in[%zu] is not NULL",  a7,  a8,  v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }

      if (*(void *)(v12 + v9 + 64))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  41,  54,  0,  "inPatch[%zu] is not NULL",  a7,  a8,  v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }

      if (*(void *)(v12 + v9 + 40))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  42,  54,  0,  "inControls[%zu] is not NULL",  a7,  a8,  v10);
        int v11 = 0;
      }

      ++v10;
      v9 += 80LL;
    }

    while (v10 < *(void *)(a1 + 16));
  }

  else
  {
    int v11 = 1;
  }

  if (*(void *)(a1 + 32))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  44,  54,  0,  "out is not NULL",  a7,  a8,  v14);
    int v11 = 0;
  }

  if (*(void *)(a1 + 72))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  45,  54,  0,  "comboControls is not NULL",  a7,  a8,  v14);
    int v11 = 0;
  }

  if (*(void *)(a1 + 96))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5Free",  46,  54,  0,  "comboPatch is not NULL",  a7,  a8,  v14);
    int v11 = 0;
  }

  free(*(void **)(a1 + 24));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  if (v11) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  *(_OWORD *)a1 = 0uLL;
  return result;
}

uint64_t bxdiff5Dump(uint64_t a1, FILE *a2)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = (int *)(*(void *)(a1 + 24) + 36LL);
    uint64_t v6 = *(void *)(a1 + 16);
    do
    {
      int v7 = *v5;
      v5 += 20;
      if (v7) {
        ++v4;
      }
      --v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  fprintf(a2, "BXDiff5Data: n=%zu, nUnique=%zu\n", *(void *)(a1 + 16), v4);
  if (*(void *)(a1 + 16))
  {
    unint64_t v8 = 0LL;
    unint64_t v9 = 0LL;
    uint64_t v10 = 16LL;
    do
    {
      fprintf(a2, "- input %zu\n", v9);
      uint64_t v11 = *(void *)(a1 + 24);
      if (*(void *)(v11 + 80 * v9))
      {
        fprintf(a2, "    in set, inSize=%zu, inSHA1=", *(void *)(v11 + 80 * v9 + 8));
        for (uint64_t i = 0LL; i != 20; ++i)
          fprintf(a2, "%02x", *(unsigned __int8 *)(*(void *)(a1 + 24) + v10 + i));
        int64_t v13 = "unique";
        if (!*(_DWORD *)(*(void *)(a1 + 24) + 80 * v9 + 36)) {
          int64_t v13 = "non unique";
        }
        fprintf(a2, ", %s", v13);
        fputc(10, a2);
      }

      else
      {
        fwrite("    in is NULL\n", 0xFuLL, 1uLL, a2);
      }

      uint64_t v14 = *(void *)(a1 + 24);
      if (*(void *)(v14 + 80 * v9 + 40))
      {
        uint64_t v15 = v14 + 80 * v9;
        unint64_t v16 = 3LL * *(void *)(v15 + 56);
        fprintf( a2,  "    inControls set, nControls=%zu, inPlace=%d (%zu MB)\n",  *(void *)(v15 + 56),  *(_DWORD *)(v15 + 48),  (v16 >> 17) & 0xFFFFFFFFFFFLL);
        v8 += 8 * v16;
      }

      else
      {
        fwrite("    inControls is NULL\n", 0x17uLL, 1uLL, a2);
      }

      uint64_t v17 = *(void *)(a1 + 24);
      if (*(void *)(v17 + 80 * v9 + 64))
      {
        unint64_t v18 = *(void *)(v17 + 80 * v9 + 72);
        fprintf(a2, "    inPatch set, inPatchSize=%zu (%zu MB)\n", v18, v18 >> 20);
        v8 += v18;
      }

      else
      {
        fwrite("    inPatch is NULL\n", 0x14uLL, 1uLL, a2);
      }

      ++v9;
      v10 += 80LL;
    }

    while (v9 < *(void *)(a1 + 16));
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  fwrite("- output\n", 9uLL, 1uLL, a2);
  if (*(void *)(a1 + 32))
  {
    fprintf(a2, "    out set, outSize=%zu, outSHA1=", *(void *)(a1 + 40));
    for (uint64_t j = 0LL; j != 20; ++j)
      fprintf(a2, "%02x", *(unsigned __int8 *)(a1 + 48 + j));
    fputc(10, a2);
  }

  else
  {
    fwrite("    out is NULL\n", 0x10uLL, 1uLL, a2);
  }

  if (*(void *)(a1 + 72))
  {
    unint64_t v20 = (8 * v4 + 16) * *(void *)(a1 + 88);
    fprintf( a2,  "    comboControls set, nControls=%zu, inPlace=%d (%zu MB)\n",  *(void *)(a1 + 88),  *(_DWORD *)(a1 + 80),  v20 >> 20);
    v8 += v20;
  }

  else
  {
    fwrite("    comboControls is NULL\n", 0x1AuLL, 1uLL, a2);
  }

  if (*(void *)(a1 + 96))
  {
    unint64_t v21 = *(void *)(a1 + 104);
    fprintf(a2, "    comboPatch set, comboPatchSize=%zu (%zu MB)\n", v21, v21 >> 20);
    v8 += v21;
  }

  else
  {
    fwrite("    comboPatch is NULL\n", 0x17uLL, 1uLL, a2);
  }

  fprintf(a2, "Total size %zu MB\n", v8 >> 20);
  return 0LL;
}

uint64_t bxdiff5SetIn( void *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] <= a2)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5SetIn",  122,  54,  0,  "invalid I=%zu",  a7,  a8,  a2);
    return 0xFFFFFFFFLL;
  }

  if (!a3 || !a4)
  {
    unint64_t v16 = "invalid in,inSize";
    __int16 v17 = 123;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5SetIn",  v17,  54,  0,  v16,  a7,  a8,  v19);
    return 0xFFFFFFFFLL;
  }

  if (!a1[4])
  {
    unint64_t v16 = "missing out";
    __int16 v17 = 124;
    goto LABEL_16;
  }

  uint64_t v10 = a1[3] + 80 * a2;
  *(void *)uint64_t v10 = a3;
  *(void *)(v10 + 8) = a4;
  getBufferSHA1Digest(a3, a4, (unsigned __int8 *)(v10 + 16));
  unint64_t v11 = a1[2];
  uint64_t v12 = a1[3];
  *(_DWORD *)(v12 + 80 * a2 + 36) = 1;
  if (v11)
  {
    uint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    while (1)
    {
      if (a2 != v14)
      {
        uint64_t v15 = a1[3];
        if (*(void *)(v15 + v13))
        {
          if (!sha1cmp(v15 + 80 * a2 + 16, v15 + v13 + 16))
          {
            uint64_t v12 = a1[3];
            *(_DWORD *)(v12 + 80 * a2 + 36) = 0;
            break;
          }

          unint64_t v11 = a1[2];
        }
      }

      ++v14;
      v13 += 80LL;
      if (v14 >= v11)
      {
        uint64_t v12 = a1[3];
        break;
      }
    }
  }

  uint64_t result = sha1cmp(v12 + 80 * a2 + 16, (uint64_t)(a1 + 6));
  if ((_DWORD)result) {
    return 0LL;
  }
  *(_DWORD *)(a1[3] + 80 * a2 + 36) = 0;
  return result;
}

uint64_t bxdiff5SetOut( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && a3)
  {
    *(void *)(a1 + 32) = a2;
    *(void *)(a1 + 40) = a3;
    getBufferSHA1Digest(a2, a3, (unsigned __int8 *)(a1 + 48));
    return 0LL;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5SetOut",  155,  54,  0,  "invalid out,outSize",  a7,  a8,  vars0);
    return 0xFFFFFFFFLL;
  }

uint64_t bxdiff5CreateInControls( uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    unint64_t v14 = "invalid input index";
    __int16 v15 = 247;
    goto LABEL_5;
  }

  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = v10 + 80 * a2;
  uint64_t v13 = *(void *)(v11 + 40);
  uint64_t v12 = (int8x16_t **)(v11 + 40);
  if (v13)
  {
    unint64_t v14 = "input controls already present";
    __int16 v15 = 248;
LABEL_5:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateInControls",  v15,  54,  0,  v14,  a7,  a8,  v25);
    return 0xFFFFFFFFLL;
  }

  uint64_t v17 = *(void *)(v10 + 80 * a2);
  if (!v17 || (unint64_t v18 = *(void *)(v10 + 80 * a2 + 8)) == 0)
  {
    unint64_t v14 = "input is missing or invalid";
    __int16 v15 = 249;
    goto LABEL_5;
  }

  if (!*(_DWORD *)(v10 + 80 * a2 + 36)) {
    return 0LL;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  uint64_t v22 = (uint64_t *)(v10 + 80 * a2 + 56);
  if (!(v18 >> 28) || v21 >> 28 == 0)
  {
    if ((getBXDiffControls(v17, v18, v20, v21, v12, (uint64_t)v22, (int *)a1, a8) & 0x80000000) != 0)
    {
      unint64_t v14 = "generic controls";
      __int16 v15 = 270;
      goto LABEL_5;
    }
  }

  else
  {
    int LargeFileControls = GetLargeFileControls(v17, v18, v20, v21, (void **)v12, v22, (uint64_t *)a1, a8);
    if (LargeFileControls < 0)
    {
      unint64_t v14 = "largefile controls";
      __int16 v15 = 262;
      goto LABEL_5;
    }
  }

  if (!a3) {
    return 0LL;
  }
  if ((forceInPlaceControls( *(void *)(*(void *)(a1 + 24) + 80 * a2 + 8),  *(void *)(a1 + 40),  *(void *)(*(void *)(a1 + 24) + 80 * a2 + 40),  *(void *)(*(void *)(a1 + 24) + 80 * a2 + 56),  *(_DWORD *)(a1 + 4)) & 0x80000000) != 0)
  {
    unint64_t v14 = "forceInPlaceControls";
    __int16 v15 = 278;
    goto LABEL_5;
  }

  uint64_t result = 0LL;
  *(_DWORD *)(*(void *)(a1 + 24) + 80 * a2 + 48) = 1;
  return result;
}

uint64_t bxdiff5CreateComboControls( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    goto LABEL_7;
  }
  unint64_t v10 = 0LL;
  uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36LL);
  uint64_t v12 = *(void *)(a1 + 16);
  do
  {
    int v13 = *v11;
    v11 += 20;
    if (v13) {
      ++v10;
    }
    --v12;
  }

  while (v12);
  if (v10 > 1)
  {
    *(_DWORD *)(a1 + 80) = 1;
    __int16 v15 = (uint64_t *)calloc(v8, 0x18uLL);
    if (v15)
    {
      unint64_t v16 = v15;
      uint64_t v17 = v15;
      size_t v18 = v8;
      do
      {
        initDiffSegmentVector(v17);
        v17 += 3;
        --v18;
      }

      while (v18);
      uint64_t v25 = 0LL;
      unint64_t v26 = 0LL;
      uint64_t v27 = *(void *)(a1 + 24);
      do
      {
        if (*(_DWORD *)(v27 + v25 + 36))
        {
          uint64_t v28 = *(void *)(v27 + v25 + 40);
          if (!v28)
          {
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboControls",  309,  54,  0,  "missing controls for input %zu",  v23,  v24,  v18);
            goto LABEL_28;
          }

          if ((pushControls((unint64_t *)&v16[3 * v26], v28, *(void *)(v27 + v25 + 56), 0LL, 0LL) & 0x80000000) != 0)
          {
            unint64_t v33 = "pushControls";
            __int16 v34 = 312;
            goto LABEL_27;
          }

          uint64_t v27 = *(void *)(a1 + 24);
          if (!*(_DWORD *)(v27 + v25 + 48)) {
            *(_DWORD *)(a1 + 80) = 0;
          }
          ++v26;
        }

        ++v18;
        v25 += 80LL;
      }

      while (v8 != v18);
      if ((mergeDiffSegmentVectors(v26, v16, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        unint64_t v33 = "mergeDiffSegmentVectors";
        __int16 v34 = 321;
      }

      else
      {
        if ((getComboControlsFromMergedDiffSegmentVectors((char *)v26, v16, (void *)(a1 + 72), (uint64_t *)(a1 + 88)) & 0x80000000) == 0)
        {
          int v29 = 1;
          goto LABEL_29;
        }

        unint64_t v33 = "getComboControlsFromMergedDiffSegmentVectors";
        __int16 v34 = 324;
      }

uint64_t bxdiff5CreateInPatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24) + 80 * a2;
  return bxdiff5CreatePatchBackend( 1LL,  v2,  v2 + 8,  v2 + 16,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a1 + 48,  *(void *)(v2 + 40),  *(void *)(v2 + 56),  (void *)(v2 + 64),  (size_t *)(v2 + 72),  *(_DWORD *)(v2 + 48),  *(_DWORD *)(a1 + 4),  *(_DWORD *)(a1 + 8));
}

uint64_t bxdiff5CreatePatchBackend( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t __size, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, size_t *a11, int a12, int a13, unsigned int a14)
{
  uint64_t v19 = a10;
  size_t v18 = a11;
  uint64_t v22 = (char *)malloc(__size);
  if (!v22)
  {
    int v28 = *__error();
    int v29 = "malloc";
    __int16 v30 = 447;
LABEL_48:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  v30,  54,  v28,  v29,  v20,  v21,  v86);
    __int16 v34 = 0LL;
LABEL_49:
    free(v22);
    free(v34);
    size_t v67 = 0LL;
    size_t v68 = 0LL;
    uint64_t v69 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }

  uint64_t v23 = a9;
  if (a9)
  {
    int64x2_t v24 = 0uLL;
    int64x2_t v25 = vdupq_n_s64(0x8000000000000000LL);
    unint64_t v26 = (int64x2_t *)a8;
    uint64_t v27 = a9;
    do
    {
      int64x2_t v24 = vaddq_s64( (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v26), (int8x16_t)vsubq_s64(v25, *v26), *(int8x16_t *)v26),  v24);
      unint64_t v26 = (int64x2_t *)((char *)v26 + 8 * a1 + 16);
      --v27;
    }

    while (v27);
  }

  else
  {
    int64x2_t v24 = 0uLL;
  }

  uint64_t v88 = a1 + 2;
  if (a13 > 1)
  {
    *(int64x2_t *)__dsta = v24;
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "BXDiff5 backend, out: %zu B, diff: %zu B, lit: %zu B, ctrl: %zu B\n",  __size,  v24.u64[0],  v24.u64[1],  8 * (a1 + 2) * a9);
    int64x2_t v24 = *(int64x2_t *)__dsta;
  }

  if (vaddvq_s64(v24) != __size)
  {
    int v29 = "size inconsistency: diff + archive != out";
    __int16 v30 = 458;
    int v28 = 0;
    goto LABEL_48;
  }

  __dst = v22;
  uint64_t v31 = 28 * a1 + lzma_stream_buffer_bound() * a1;
  size_t v32 = v31 + lzma_stream_buffer_bound() + 60;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch allocated: %zu B\n", v32);
  }
  unint64_t v33 = malloc(v32);
  __int16 v34 = v33;
  if (!v33)
  {
    uint64_t v71 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  469,  54,  *v71,  "malloc",  v72,  v73,  v86);
LABEL_52:
    uint64_t v19 = a10;
    uint64_t v22 = __dst;
    goto LABEL_49;
  }

  *(_OWORD *)((char *)v33 + 44) = 0u;
  v33[1] = 0u;
  v33[2] = 0u;
  *unint64_t v33 = 0u;
  uint64_t v87 = (char *)v33 + 60;
  bzero((char *)v33 + 60, 28 * a1);
  *__int16 v34 = 0x3035464649445842LL;
  v34[2] = __size;
  *(_OWORD *)(v34 + 5) = *(_OWORD *)a7;
  *((_DWORD *)v34 + 14) = *(_DWORD *)(a7 + 16);
  *((_DWORD *)v34 + 2) = a1;
  *((_DWORD *)v34 + 3) = a12 != 0;
  if (a1)
  {
    uint64_t v35 = (char *)v34 + 68;
    uint64_t v36 = a1;
    do
    {
      *(_OWORD *)uint64_t v35 = *(_OWORD *)a4;
      *((_DWORD *)v35 + 4) = *(_DWORD *)(a4 + 16);
      a4 += 20LL;
      v35 += 28;
      --v36;
    }

    while (v36);
  }

  char v37 = (char *)v34 + v32;
  uint64_t v38 = (uint64_t)&v87[28 * a1];
  if (a13 > 1) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch headers: %zu B\n", v38 - (void)v34);
  }
  uint64_t v19 = a10;
  uint64_t v39 = plzmaEncodeBuffer(v38, (uint64_t)&v37[-v38], a8, 8 * (a1 + 2) * a9, a14);
  if (v39 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  499,  54,  0,  "Payload compression",  v40,  v41,  v86);
    uint64_t v22 = __dst;
    goto LABEL_49;
  }

  uint64_t v42 = v38 + v39;
  v34[3] = v39;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch control payload: %zu B\n", v39);
  }
  uint64_t v22 = __dst;
  if (a1)
  {
    uint64_t v43 = 0LL;
    uint64_t v44 = a5;
    while (!a9)
    {
      uint64_t v48 = v22;
LABEL_42:
      uint64_t v63 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)v22, v48 - v22, a14);
      if (v63 < 0)
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  530,  54,  0,  "Payload compression",  v64,  v65,  v86);
        goto LABEL_52;
      }

      uint64_t v66 = v63;
      *(void *)&v87[28 * v43] = v63;
      if (a13 >= 2) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch diff[%zu] payload: %zu B\n", v43, v63);
      }
      v42 += v66;
      ++v43;
      uint64_t v22 = __dst;
      uint64_t v44 = a5;
      if (v43 == a1) {
        goto LABEL_56;
      }
    }

    uint64_t v45 = 0LL;
    uint64_t v46 = 0LL;
    uint64_t v47 = 0LL;
    uint64_t v48 = v22;
    while (1)
    {
      AAByteStream v49 = (int64_t *)(a8 + 8 * v45 * v88);
      uint64_t v50 = v49[1];
      int64_t v51 = 0x8000000000000000LL - *v49;
      if (*v49 >= 0) {
        int64_t v51 = *v49;
      }
      unint64_t v52 = 0x8000000000000000LL - v50;
      if (v50 >= 0) {
        unint64_t v52 = v49[1];
      }
      uint64_t v53 = v49[v43 + 2];
      if (v53 < 0) {
        uint64_t v53 = 0x8000000000000000LL - v53;
      }
      if (v46 < 0) {
        break;
      }
      uint64_t v54 = v51 + v46;
      if (v51 + v46 > __size) {
        break;
      }
      if (v47 < 0 || (uint64_t v55 = v51 + v47, v51 + v47 > *(void *)(a3 + 8 * v43)))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  519,  54,  0,  "in[%zu] access out of range",  a2,  v88,  v43);
        goto LABEL_69;
      }

      if (v51 >= 1)
      {
        uint64_t v56 = (char *)(*(void *)(a2 + 8 * v43) + v47);
        uint64_t v57 = (char *)(v44 + v46);
        uint64_t v58 = v48;
        int64_t v59 = v51;
        do
        {
          char v61 = *v57++;
          char v60 = v61;
          char v62 = *v56++;
          *v58++ = v60 - v62;
          --v59;
        }

        while (v59);
      }

      v48 += v51;
      uint64_t v46 = v54 + v52;
      uint64_t v47 = v55 + v53;
      if (++v45 == a9) {
        goto LABEL_42;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  518,  54,  0,  "out access out of range",  a2,  v88,  v86);
    goto LABEL_69;
  }

  uint64_t v44 = a5;
LABEL_56:
  if (a9)
  {
    size_t v74 = 0LL;
    uint64_t v75 = (size_t *)(a8 + 8);
    uint64_t v76 = 8 * a1 + 16;
    uint64_t v22 = __dst;
    do
    {
      uint64_t v77 = *(v75 - 1);
      if (v77 < 0) {
        uint64_t v77 = 0x8000000000000000LL - v77;
      }
      if ((*v75 & 0x8000000000000000LL) == 0LL) {
        size_t v78 = *v75;
      }
      else {
        size_t v78 = 0x8000000000000000LL - *v75;
      }
      size_t v79 = v77 + v74;
      memcpy(v22, (const void *)(v44 + v77 + v74), v78);
      uint64_t v44 = a5;
      v22 += v78;
      size_t v74 = v79 + v78;
      uint64_t v75 = (size_t *)((char *)v75 + v76);
      --v23;
    }

    while (v23);
  }

  uint64_t v80 = v22 - __dst;
  uint64_t v22 = __dst;
  uint64_t v81 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)__dst, v80, a14);
  if (v81 < 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreatePatchBackend",  554,  54,  0,  "Payload compression",  v82,  v83,  v86);
    size_t v18 = a11;
LABEL_69:
    uint64_t v19 = a10;
    goto LABEL_49;
  }

  uint64_t v84 = v42 + v81;
  v34[4] = v81;
  if (a13 <= 1)
  {
    size_t v68 = v84 - (void)v34;
  }

  else
  {
    uint64_t v85 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch archive payload: %zu B\n", v81);
    size_t v68 = v84 - (void)v34;
    fprintf(*v85, "BXDiff5 patch total size: %zu B\n", v84 - (void)v34);
  }

  size_t v18 = a11;
  uint64_t v19 = a10;
  free(__dst);
  size_t v67 = reallocToFit(v34, v68);
  uint64_t v69 = 0LL;
LABEL_50:
  *uint64_t v19 = v67;
  *size_t v18 = v68;
  return v69;
}

uint64_t bxdiff5CreateComboPatch( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      size_t v10 = 0LL;
      uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36LL);
      do
      {
        int v12 = *v11;
        v11 += 20;
        if (v12) {
          ++v10;
        }
        --v9;
      }

      while (v9);
    }

    else
    {
      size_t v10 = 0LL;
    }

    unint64_t v14 = calloc(v10, 8uLL);
    __int16 v15 = calloc(v10, 8uLL);
    unint64_t v16 = (char *)calloc(v10, 0x14uLL);
    uint64_t v17 = v16;
    if (v14) {
      BOOL v18 = v15 == 0LL;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18 || v16 == 0LL)
    {
      uint64_t v20 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboPatch",  609,  54,  *v20,  "malloc",  v21,  v22,  v32);
      uint64_t PatchBackend = 0xFFFFFFFFLL;
    }

    else
    {
      unint64_t v23 = *(void *)(a1 + 16);
      if (v23)
      {
        uint64_t v24 = 0LL;
        unint64_t v25 = 0LL;
        uint64_t v26 = 0LL;
        do
        {
          uint64_t v27 = *(void *)(a1 + 24);
          if (*(_DWORD *)(v27 + v24 + 36))
          {
            v14[v26] = *(void *)(v27 + v24);
            uint64_t v28 = *(void *)(a1 + 24) + v24;
            v15[v26] = *(void *)(v28 + 8);
            int v29 = &v16[20 * v26];
            __int128 v30 = *(_OWORD *)(v28 + 16);
            *((_DWORD *)v29 + 4) = *(_DWORD *)(v28 + 32);
            *(_OWORD *)int v29 = v30;
            ++v26;
            unint64_t v23 = *(void *)(a1 + 16);
          }

          ++v25;
          v24 += 80LL;
        }

        while (v25 < v23);
      }

      uint64_t PatchBackend = bxdiff5CreatePatchBackend( v10,  (uint64_t)v14,  (uint64_t)v15,  (uint64_t)v16,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a1 + 48,  *(void *)(a1 + 72),  *(void *)(a1 + 88),  (void *)(a1 + 96),  (size_t *)(a1 + 104),  *(_DWORD *)(a1 + 80),  *(_DWORD *)(a1 + 4),  *(_DWORD *)(a1 + 8));
    }

    free(v14);
    free(v15);
    free(v17);
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateComboPatch",  600,  54,  0,  "missing combo controls",  a7,  a8,  v32);
    return 0xFFFFFFFFLL;
  }

  return PatchBackend;
}

uint64_t BXDiff5( uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BXDiff5WithIndividualPatches(a1, a2, a3, 0LL, 0LL, a6, a7, a8);
}

uint64_t BXDiff5WithIndividualPatches( uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v109 = *MEMORY[0x1895F89C0];
  if (HIDWORD(*(void *)a1))
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"BXDiff5WithIndividualPatches",  645,  54,  0,  "Invalid number of inputs: %zu",  a7,  a8,  *(void *)a1);
    return 0xFFFFFFFFLL;
  }

  uint64_t v9 = (void *)a5;
  size_t v10 = (void *)a4;
  int v14 = *(_DWORD *)(a1 + 48);
  enterThreadErrorContext(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v93);
  size_t v15 = *(void *)a1;
  int v16 = *(_DWORD *)(a1 + 52);
  if (v10) {
    BOOL v17 = v9 == 0LL;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = !v17;
  __int128 v107 = 0u;
  __int128 v108 = 0u;
  __int128 v105 = 0u;
  *(_OWORD *)__int16 v106 = 0u;
  __int128 v103 = 0u;
  __int128 v104 = 0u;
  __int128 v102 = 0u;
  int v19 = *(_DWORD *)(a1 + 44);
  int v99 = v18;
  LODWORD(v100) = *(_DWORD *)(a1 + 40);
  HIDWORD(v100) = v16;
  int v101 = v19;
  bxdiff5Alloc(v15, &v100, (uint64_t)&v102);
  *a2 = 0LL;
  *a3 = 0LL;
  if (v10 && v15) {
    bzero(v10, 8 * v15);
  }
  if (v9 && v15) {
    bzero(v9, 8 * v15);
  }
  if (bxdiff5SetOut((uint64_t)&v102, *(void *)(a1 + 24), *(void *)(a1 + 32), v20, v21, v22, v23, v24))
  {
    char v32 = "bxdiff5SetOut";
    __int16 v33 = 672;
LABEL_17:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"BXDiff5WithIndividualPatches",  v33,  54,  0,  v32,  v30,  v31,  v94);
    LODWORD(v34) = 0;
    goto LABEL_18;
  }

  if (v15)
  {
    unint64_t v45 = 0LL;
    while (!bxdiff5SetIn( &v102,  v45,  *(void *)(*(void *)(a1 + 8) + 8 * v45),  *(void *)(*(void *)(a1 + 16) + 8 * v45),  v28,  v29,  v30,  v31))
    {
      if (v15 == ++v45) {
        goto LABEL_28;
      }
    }

    char v32 = "bxdiff5SetIn";
    __int16 v33 = 675;
    goto LABEL_17;
  }

LABEL_97:
        LODWORD(v34) = 1;
LABEL_18:
        if (v15)
        {
          uint64_t v35 = 0LL;
          uint64_t v36 = *((void *)&v103 + 1);
          do
          {
            uint64_t v37 = v36 + v35;
            *(void *)uint64_t v37 = 0LL;
            free(*(void **)(v37 + 40));
            uint64_t v36 = *((void *)&v103 + 1);
            *(void *)(*((void *)&v103 + 1) + v35 + 40) = 0LL;
            v35 += 80LL;
            --v15;
          }

          while (v15);
        }

        goto LABEL_21;
      }

      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
    }

    else
    {
      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
      unint64_t v34 = 0LL;
    }

    uint64_t v53 = -1LL;
    goto LABEL_59;
  }

  __int128 v56 = v104;
  int v57 = DWORD1(v102);
  unsigned int v58 = DWORD2(v102);
  uint64_t v59 = lzma_stream_buffer_bound();
  size_t v60 = v59 + 60;
  if (v57 >= 1) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch capacity: %zu B\n", v60);
  }
  char v61 = (char *)malloc(v60);
  char v62 = v61;
  if (v61)
  {
    *(_OWORD *)char v61 = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *(_OWORD *)(v61 + 44) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(void *)char v61 = 0x3035464649445842LL;
    *((void *)v61 + 1) = 0LL;
    *((void *)v61 + 2) = *((void *)&v56 + 1);
    *(_OWORD *)(v61 + 40) = v105;
    *((_DWORD *)v61 + 14) = v106[0];
    uint64_t v63 = plzmaEncodeBuffer((uint64_t)(v61 + 60), v59, v56, *((uint64_t *)&v56 + 1), v58);
    if ((v63 & 0x8000000000000000LL) == 0)
    {
      uint64_t v66 = (char *)v62 + v63 + 60;
      v62[4] = v63;
      if (v57 >= 1) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "BXDiff5 patch archive payload size: %zu B\n", v63);
      }
      *a2 = reallocToFit(v62, v66 - (char *)v62);
      *a3 = v66 - (char *)v62;
      LODWORD(v34) = 1;
      goto LABEL_21;
    }

    uint64_t v75 = "Payload compression";
    __int16 v76 = 406;
    int v74 = 0;
  }

  else
  {
    int v74 = *__error();
    uint64_t v75 = "malloc patch";
    __int16 v76 = 386;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"bxdiff5CreateFullReplacementBackend",  v76,  54,  v74,  v75,  v64,  v65,  v94);
  free(v62);
  *a2 = 0LL;
  *a3 = 0LL;
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"BXDiff5WithIndividualPatches",  689,  54,  0,  "bxdiff5CreateFullReplacementBackend",  v77,  v78,  v95);
  LODWORD(v34) = 0;
LABEL_21:
  *(void *)&__int128 v104 = 0LL;
  free(v106[1]);
  v106[1] = 0LL;
  bxdiff5Free((uint64_t)&v102, v38, v39, v40, v41, v42, v43, v44);
  LODWORD(result) = leaveThreadErrorContext(0LL, 0LL, 0);
  else {
    return result;
  }
}

      int v57 = *v56;
      unsigned int v58 = realloc(*v56, v54);
      if (v58)
      {
        *((void *)v35 + 283) = v58;
        *((void *)v35 + 282) = v54;
        goto LABEL_99;
      }

      free(v57);
LABEL_171:
      *__int128 v56 = 0LL;
      *((void *)v35 + 281) = 0LL;
      *((void *)v35 + 282) = 0LL;
      goto LABEL_172;
    }
  }

          a2 = v136;
          uint64_t v29 = v137;
          if (v27 >= v26) {
            goto LABEL_98;
          }
        }

        v41.uint64_t ikey = 4475221;
        uint64_t v40 = 1;
LABEL_46:
        uint64_t v39 = 1;
        goto LABEL_47;
      }

uint64_t plzmaEncodeBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v29 = 0LL;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  size_t v10 = IMemStreamCreate(a3, a4);
  if (!v10)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"plzmaEncodeBuffer",  348,  54,  0,  "is",  v8,  v9,  v25);
    int v19 = 0LL;
LABEL_8:
    int v22 = 1;
    goto LABEL_9;
  }

  uint64_t v11 = OMemStreamCreate(a1, a2);
  int v19 = v11;
  if (!v11)
  {
    uint64_t v20 = "os";
    __int16 v21 = 349;
    goto LABEL_7;
  }

  *(void *)((char *)&v25 + 4) = a5 | 0x100000000LL;
  LODWORD(v25) = 0;
  *(void *)&__int128 v26 = 0x100000LL;
  *((void *)&v26 + 1) = IMemStreamRead;
  *((void *)&v27 + 1) = v10;
  *(void *)&__int128 v28 = OMemStreamWrite;
  uint64_t v29 = v11;
  if (ParallelCompressionEncode((uint64_t)&v25, v12, v13, v14, v15, v16, v17, v18))
  {
    uint64_t v20 = "encode";
    __int16 v21 = 358;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c",  (uint64_t)"plzmaEncodeBuffer",  v21,  54,  0,  v20,  v17,  v18,  v25);
    goto LABEL_8;
  }

  int v22 = 0;
LABEL_9:
  uint64_t v23 = BXDiffMatchesOBuf((uint64_t)v19);
  OMemStreamDestroy(v10);
  OMemStreamDestroy(v19);
  if (v22) {
    return -1LL;
  }
  else {
    return v23;
  }
}

void *aaInSituStreamOpen(void *a1, uint64_t a2, int a3, int a4, int a5)
{
  size_t v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = calloc(1uLL, 0x140uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v10 || !v11)
  {
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 336;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"aaInSituStreamOpen",  v24,  140,  0,  v23,  v12,  v13,  v33);
    free(v10);
    InSituStreamClose(v14, v25, v26, v27, v28, v29, v30, v31);
    return 0LL;
  }

  *(void *)uint64_t v11 = a1;
  v11[78] = a5;
  unint64_t v15 = (unint64_t)(a2 + 0x3FFF) >> 14;
  v11[72] = v15;
  LODWORD(v15) = v15 + ((a3 + 0x3FFF) >> 14) + ((int)v15 >> 2);
  v11[79] = a4;
  size_t v16 = (v15 + 256);
  *(_DWORD *)(v14 + 292) = v16;
  if ((int)v15 + 256 < 0)
  {
    *__error() = 12;
    *(void *)(v14 + 8) = 0LL;
    goto LABEL_14;
  }

  uint64_t v17 = calloc(v16, 0xDuLL);
  *(void *)(v14 + 8) = v17;
  if (!v17)
  {
LABEL_14:
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 347;
    goto LABEL_16;
  }

  *(void *)&__int128 v18 = -1LL;
  *((void *)&v18 + 1) = -1LL;
  *(_OWORD *)(v14 + 240) = v18;
  *(_OWORD *)(v14 + 256) = v18;
  *(_OWORD *)(v14 + 208) = v18;
  *(_OWORD *)(v14 + 224) = v18;
  *(_OWORD *)(v14 + 176) = v18;
  *(_OWORD *)(v14 + 192) = v18;
  *(_OWORD *)(v14 + 144) = v18;
  *(_OWORD *)(v14 + 160) = v18;
  *(_OWORD *)(v14 + 112) = v18;
  *(_OWORD *)(v14 + 128) = v18;
  *(_OWORD *)(v14 + 80) = v18;
  *(_OWORD *)(v14 + 96) = v18;
  *(_OWORD *)(v14 + 48) = v18;
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 16) = v18;
  *(_OWORD *)(v14 + 32) = v18;
  int v19 = *(_DWORD *)(v14 + 292);
  if (v19 >= 1)
  {
    uint64_t v20 = 0LL;
    for (uint64_t i = 0LL; i < v19; ++i)
    {
      uint64_t v22 = *(void *)(v14 + 8) + v20;
      *(_DWORD *)(v22 + 1) = i;
      *(void *)(v22 + 5) = 0xFFFFFFFF00000000LL;
      if (i < *(int *)(v14 + 288))
      {
        free_page(v14, i);
        int v19 = *(_DWORD *)(v14 + 292);
      }

      v20 += 13LL;
    }
  }

  if ((AAByteStreamTruncate(a1) & 0x80000000) != 0)
  {
    uint64_t v23 = "AAByteStreamTruncate";
    __int16 v24 = 362;
    goto LABEL_16;
  }

  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)InSituStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)InSituStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)InSituStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  v10[8] = InSituTruncate;
  v10[11] = InSituStreamSimulate;
  return v10;
}

uint64_t free_page(uint64_t result, int a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); ; a2 = *(_DWORD *)(i + 13LL * a2 + 1))
  {
    uint64_t v5 = (_BYTE *)(i + 13LL * a2);
    int v6 = *v5;
    if (v6 != 2) {
      break;
    }
  }

  if (v6 == 1)
  {
    _BYTE *v5 = 0;
    *(_DWORD *)(i + 13LL * a2 + 5) = 0;
  }

  ++*(_DWORD *)(result + 296);
  uint64_t v7 = i + 13LL * a2;
  int v9 = *(_DWORD *)(v7 + 9);
  uint64_t v8 = (_DWORD *)(v7 + 9);
  if (v9 < 0)
  {
    int v10 = *(_DWORD *)(result + 276);
    *(_DWORD *)(result + 276) = v10 - 1;
    if (v10 >= 2)
    {
      int v11 = *(_DWORD *)(result + 272);
    }

    else
    {
      *(_DWORD *)(result + 276) = 32;
      uint64_t result = rand();
      int v11 = result & 0x3F;
      *(_DWORD *)(v3 + 272) = v11;
    }

    uint64_t v12 = v3 + 4LL * v11;
    *uint64_t v8 = *(_DWORD *)(v12 + 16);
    *(_DWORD *)(v12 + 16) = a2;
  }

  return result;
}

uint64_t InSituStreamClose( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(unsigned int *)(result + 292);
    int v10 = 0;
    int v11 = (int *)(*(void *)(result + 8) + 5LL);
    do
    {
      int v12 = *v11;
      int v11 = (int *)((char *)v11 + 13);
      v10 += v12;
      --v9;
    }

    while (v9);
    if (v10)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamClose",  298,  140,  0,  "%i dangling reads",  a7,  a8,  v10);
      int v13 = 0;
    }

    else
    {
LABEL_7:
      int v13 = 1;
    }

    int v14 = *(_DWORD *)(v8 + 288);
    int v15 = *(_DWORD *)(v8 + 308);
    if (*(_DWORD *)(v8 + 300) + v14 != *(_DWORD *)(v8 + 296) + v15)
    {
      pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamClose",  301,  140,  "file + excess != written + free",  a6,  a7,  a8,  v18);
      int v14 = *(_DWORD *)(v8 + 288);
      int v15 = *(_DWORD *)(v8 + 308);
    }

    if (v14 < v15) {
      pc_log_info( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamClose",  302,  140,  "file < written",  a6,  a7,  a8,  v18);
    }
    if (*(_DWORD *)(v8 + 316)) {
      fprintf( (FILE *)*MEMORY[0x1895F89D0],  "InSituStream: pages: %i file, %i written, %i remapped, %i free, %i excess (%iK)\n",  *(_DWORD *)(v8 + 288),  *(_DWORD *)(v8 + 308),  *(_DWORD *)(v8 + 304),  *(_DWORD *)(v8 + 296),  *(_DWORD *)(v8 + 300),  16 * *(_DWORD *)(v8 + 300));
    }
    free(*(void **)(v8 + 8));
    if (*(_DWORD *)(v8 + 312) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamClose",  319,  140,  0,  "AAByteStreamClose",  v16,  v17,  v18);
      int v13 = 0;
    }

    free((void *)v8);
    if (v13) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t InSituStreamPRead( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v11 = 0LL;
  while (1)
  {
    uint64_t v12 = a1[1];
    uint64_t v13 = (v11 + a4) & 0x3FFF;
    uint64_t v14 = a3 - v11 >= 0x4000 - v13 ? 0x4000 - v13 : a3 - v11;
    uint64_t v15 = *a1;
    if (!*(void *)(*a1 + 32LL)) {
      goto LABEL_19;
    }
    if (v14)
    {
      uint64_t v16 = 0LL;
      uint64_t v17 = v13 | ((uint64_t)*(int *)(v12 + 13LL * (int)((uint64_t)(v11 + a4) >> 14) + 1) << 14);
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v14;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 32))(*(void *)v15, v18, v19, v17);
        if (v20 < 0) {
          break;
        }
        if (v20)
        {
          v18 += v20;
          v16 += v20;
          v17 += v20;
          v19 -= v20;
          if (v19) {
            continue;
          }
        }

        goto LABEL_15;
      }

      uint64_t v16 = v20;
LABEL_15:
      if (v14 != v16)
      {
LABEL_19:
        __int16 v21 = "aaByteStreamPReadExpected";
        __int16 v22 = 238;
        goto LABEL_21;
      }
    }

    v11 += v14;
    if (v11 >= a3) {
      return v11;
    }
  }

  __int16 v21 = "data not locked";
  __int16 v22 = 235;
LABEL_21:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamPRead",  v22,  140,  0,  v21,  a7,  a8,  v24);
  return -1LL;
}

uint64_t InSituStreamPWrite( uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v11 = 0LL;
  while (1)
  {
    uint64_t v12 = v11 + a4;
    unint64_t v13 = (v11 + a4) >> 14;
    uint64_t v14 = (_BYTE *)(a1[1] + 13LL * (int)v13);
    if (a3 - v11 >= 0x4000 - ((v11 + a4) & 0x3FFF)) {
      uint64_t v15 = 0x4000 - ((v11 + a4) & 0x3FFF);
    }
    else {
      uint64_t v15 = a3 - v11;
    }
    if (*v14 == 2) {
      goto LABEL_9;
    }
    if ((remap_page(a1, v13) & 0x80000000) != 0) {
      break;
    }
    *uint64_t v14 = 2;
    --*((_DWORD *)a1 + 74);
    ++*((_DWORD *)a1 + 77);
LABEL_9:
    uint64_t v16 = *a1;
    if (!*(void *)(*a1 + 40)) {
      goto LABEL_20;
    }
    if (v15)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v15;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v16 + 40))(*(void *)v16, v18, v19, v12);
        if (v20 < 1) {
          break;
        }
        v18 += v20;
        v17 += v20;
        v12 += v20;
        v19 -= v20;
        if (!v19) {
          goto LABEL_16;
        }
      }

      uint64_t v17 = v20;
LABEL_16:
      if (v15 != v17)
      {
LABEL_20:
        __int16 v21 = "aaByteStreamPWriteExpected";
        __int16 v22 = 268;
        goto LABEL_22;
      }
    }

    v11 += v15;
    if (v11 >= a3) {
      return v11;
    }
  }

  __int16 v21 = "remap_page";
  __int16 v22 = 261;
LABEL_22:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamPWrite",  v22,  140,  0,  v21,  a7,  a8,  v24);
  return -1LL;
}

void InSituStreamCancel(AAByteStream *a1)
{
}

uint64_t InSituTruncate(void **a1)
{
  return AAByteStreamTruncate(*a1);
}

uint64_t InSituStreamSimulate( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a5;
  uint64_t v9 = a4;
  if (a2 == 3)
  {
    uint64_t v11 = *(void *)a1;
    if (!*(void *)(*(void *)a1 + 32LL)) {
      return -1LL;
    }
    if (!a4) {
      return 0LL;
    }
    uint64_t v13 = 0LL;
    while (1)
    {
      uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v11 + 32))( *(void *)v11,  a3,  v9,  v8);
      if (v14 < 0) {
        break;
      }
      if (v14)
      {
        a3 += v14;
        v13 += v14;
        v8 += v14;
        v9 -= v14;
        if (v9) {
          continue;
        }
      }

      return v13;
    }

    return v14;
  }

  if (a4 < 1) {
    return v9;
  }
  if (a2 > 1)
  {
    uint64_t v23 = "not implemented";
    __int16 v24 = 197;
    goto LABEL_24;
  }

  int64_t v16 = a5 + a4;
  while (1)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 13LL * (int)(v8 >> 14);
    int v20 = *(_DWORD *)(v17 + 5);
    uint64_t v18 = (int *)(v17 + 5);
    int v19 = v20;
    if (!a2) {
      break;
    }
    if (v19 <= 0)
    {
      uint64_t v23 = "data not locked";
      __int16 v24 = 209;
      goto LABEL_24;
    }

    int v21 = v19 - 1;
    *uint64_t v18 = v21;
    if (!v21) {
      free_page(a1, v8 >> 14);
    }
LABEL_18:
    unint64_t v8 = (v8 & 0xFFFFFFFFFFFFC000LL) + 0x4000;
  }

  *uint64_t v18 = v19 + 1;
  if (v19) {
    goto LABEL_18;
  }
  int v22 = *(_DWORD *)(a1 + 296);
  *(_DWORD *)(a1 + 296) = v22 - 1;
  if (v22) {
    goto LABEL_18;
  }
  uint64_t v23 = "no free pages";
  __int16 v24 = 204;
LABEL_24:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"InSituStreamSimulate",  v24,  140,  0,  v23,  a7,  a8,  v26);
  return -1LL;
}

uint64_t remap_page(_DWORD *a1, int a2)
{
  uint64_t v2 = *((void *)a1 + 1);
  uint64_t v3 = v2 + 13LL * a2;
  int v5 = *(_DWORD *)(v3 + 5);
  uint64_t v4 = (_DWORD *)(v3 + 5);
  if (v5)
  {
    if (*(_BYTE *)(v2 + 13LL * a2) == 1)
    {
      uint64_t result = remap_page(a1, *(unsigned int *)(v2 + 13LL * a2 + 1));
      *uint64_t v4 = 0;
      return result;
    }

    uint64_t v11 = (char *)malloc(0x4000uLL);
    uint64_t v14 = v11;
    if (v11)
    {
      int v15 = a1[74];
      if (v15 <= 0)
      {
        int v26 = a1[72];
        int v27 = a1[75];
        a1[75] = v27 + 1;
        unsigned int v19 = v27 + v26;
        if (v27 + v26 >= a1[73])
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c",  (uint64_t)"allocate_page",  97,  140,  0,  "too many excess pages",  v12,  v13,  v42);
        }

        else if ((v19 & 0x80000000) == 0)
        {
LABEL_20:
          uint64_t v28 = *(void *)a1;
          if (*(void *)(*(void *)a1 + 32LL))
          {
            uint64_t v29 = 0LL;
            uint64_t v30 = (unsigned int *)(v2 + 13LL * a2 + 1);
            uint64_t v31 = (uint64_t)(int)*v30 << 14;
            uint64_t v32 = 0x4000LL;
            char v33 = v11;
            while (1)
            {
              uint64_t v34 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(v28 + 32))( *(void *)v28,  v33,  v32,  v31);
              if (v34 < 0) {
                break;
              }
              if (v34)
              {
                v33 += v34;
                v29 += v34;
                v31 += v34;
                v32 -= v34;
                if (v32) {
                  continue;
                }
              }

              if (v29 != 0x4000) {
                break;
              }
              uint64_t v35 = *(void *)a1;
              if (*(void *)(*(void *)a1 + 40LL))
              {
                uint64_t v36 = 0LL;
                unint64_t v37 = (unint64_t)v19 << 14;
                uint64_t v38 = 0x4000LL;
                uint64_t v39 = v14;
                while (1)
                {
                  uint64_t v40 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v35 + 40))( *(void *)v35,  v39,  v38,  v37);
                  if (v40 < 1) {
                    break;
                  }
                  v39 += v40;
                  v36 += v40;
                  v37 += v40;
                  v38 -= v40;
                  if (!v38)
                  {
                    if (v36 != 0x4000) {
                      break;
                    }
                    uint64_t v10 = 0LL;
                    *uint64_t v30 = v19;
                    uint64_t v41 = *((void *)a1 + 1) + 13LL * v19;
                    *(_BYTE *)uint64_t v41 = 1;
                    *(_DWORD *)(v41 + 1) = a2;
                    *(_DWORD *)(v41 + 5) = 0x7FFFFFFF;
                    ++a1[76];
                    ++a1[74];
                    goto LABEL_35;
                  }
                }
              }

              __int16 v24 = "aaByteStreamPWriteExpected";
              __int16 v25 = 158;
              goto LABEL_34;
            }
          }

          __int16 v24 = "aaByteStreamPReadExpected";
          __int16 v25 = 157;
          goto LABEL_34;
        }
      }

      else
      {
        int v16 = a1[70];
        a1[74] = v15 - 1;
        int v17 = a1[73];
        if (v17)
        {
          uint64_t v18 = &a1[(v16 & 0x3F) + 4];
          do
          {
            unsigned int v19 = *v18;
            if ((*v18 & 0x80000000) != 0
              || (int v20 = a1[71], v21 = __OFSUB__(v20, 1), --v20, a1[71] = v20, (v20 < 0) ^ v21 | (v20 == 0)))
            {
              a1[71] = 32;
              int v22 = a1[70] + 1;
              a1[70] = v22;
              uint64_t v18 = &a1[(v22 & 0x3F) + 4];
            }

            else
            {
              uint64_t v23 = v2 + 13LL * v19;
              *uint64_t v18 = *(_DWORD *)(v23 + 9);
              *(_DWORD *)(v23 + 9) = -1;
              if (!*(_DWORD *)(v23 + 5) && !*(_BYTE *)(v2 + 13LL * v19)) {
                goto LABEL_20;
              }
            }

            --v17;
          }

          while (v17);
        }
      }

      __int16 v24 = "allocate_page";
      __int16 v25 = 153;
    }

    else
    {
      __int16 v24 = "aaMalloc";
      __int16 v25 = 149;
    }

uint64_t aeaContextUnlock(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5, int a6)
{
  uint64_t v134 = *MEMORY[0x1895F89C0];
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v66 = 0u;
  memset(v65, 0, sizeof(v65));
  uint64_t v64 = 0LL;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v61 = 0u;
  memset(v60, 0, sizeof(v60));
  __int128 v127 = 0u;
  __int128 v126 = 0u;
  __int128 v125 = 0u;
  int v124 = 0;
  __int128 v123 = 0u;
  __int128 v122 = 0u;
  __int128 v121 = 0u;
  __int128 v120 = 0u;
  __int128 v119 = 0u;
  __int128 v118 = 0u;
  __int128 v117 = 0u;
  __int128 v116 = 0u;
  __int128 v115 = 0u;
  __int128 v114 = 0u;
  __int128 v113 = 0u;
  __int128 v112 = 0u;
  __int128 v111 = 0u;
  __int128 v110 = 0u;
  __int128 v109 = 0u;
  *(_OWORD *)__int128 v108 = 0u;
  int v107 = 0;
  __int128 v106 = 0u;
  __int128 v105 = 0u;
  __int128 v104 = 0u;
  __int128 v103 = 0u;
  __int128 v102 = 0u;
  __int128 v101 = 0u;
  __int128 v100 = 0u;
  __int128 v99 = 0u;
  __int128 v98 = 0u;
  __int128 v97 = 0u;
  __int128 v96 = 0u;
  __int128 v95 = 0u;
  __int128 v94 = 0u;
  __int128 v93 = 0u;
  __int128 v92 = 0u;
  *(_OWORD *)size_t __n = 0u;
  int v90 = 0;
  memset(v89, 0, sizeof(v89));
  int v88 = 0;
  memset(v87, 0, sizeof(v87));
  int v86 = 0;
  memset(v85, 0, sizeof(v85));
  int v84 = 0;
  memset(v83, 0, sizeof(v83));
  int v82 = 0;
  memset(v81, 0, sizeof(v81));
  int v80 = 0;
  memset(v79, 0, sizeof(v79));
  int v78 = 0;
  memset(v77, 0, sizeof(v77));
  int v12 = *(_DWORD *)(a1 + 1372);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  __int128 v13 = *(_OWORD *)(a1 + 16);
  __int128 v14 = *(_OWORD *)(a1 + 32);
  __int128 v15 = *(_OWORD *)(a1 + 48);
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(_OWORD *)(a2 + 32) = v14;
  *(_OWORD *)(a2 + 48) = v15;
  *(_OWORD *)(a2 + 16) = v13;
  if ((aeaCryptoInit((char *)v65, (unsigned int *)a2) & 0x80000000) != 0)
  {
    int v22 = "initializing crypto params";
    __int16 v23 = 33;
    goto LABEL_74;
  }

  if ((aeaContainerOffsetsInit((uint64_t)v60, (unsigned int *)a2, (unsigned int *)v65) & 0x80000000) != 0)
  {
    int v22 = "deriving container offsets";
    __int16 v23 = 34;
    goto LABEL_74;
  }

  uint64_t v18 = DWORD2(v65[0]);
  if (DWORD2(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  uint64_t v59 = a4;
  __memcpy_chk();
  LODWORD(v108[0]) = v18;
  memset_s((char *)v108 + v18 + 4, 256 - v18, 0, 256 - v18);
  uint64_t v19 = v67;
  __memcpy_chk();
  LODWORD(v87[0]) = v19;
  memset_s((char *)v87 + v19 + 4, 256 - v19, 0, 256 - v19);
  if (*(_DWORD *)a2 <= 4u && ((1 << *(_DWORD *)a2) & 0x15) != 0)
  {
    uint64_t v20 = *(unsigned int *)(a1 + 332);
    if ((_DWORD)v20)
    {
      __memcpy_chk();
      LODWORD(v89[0]) = v20;
      memset_s((char *)v89 + v20 + 4, 256 - v20, 0, 256 - v20);
    }

    else if (*(_DWORD *)(a1 + 592))
    {
      if (!*((void *)&v74 + 1)
        || (int v46 = (*((uint64_t (**)(_OWORD *, uint64_t))&v74 + 1))(v89, a1 + 592),
            LODWORD(v89[0]) != (_DWORD)v66)
        || v46 < 0)
      {
        int v22 = "deriving signing public key";
        __int16 v23 = 47;
        goto LABEL_74;
      }
    }
  }

  if (!a6 || !v12)
  {
    if ((aeaDeriveMainKeyExisting( (unsigned int *)v65,  (_DWORD *)a2,  __n,  (_DWORD *)(a1 + 72),  (_DWORD *)(a1 + 2152),  (unsigned int *)v87,  (unsigned int *)v89,  (unsigned int *)(a1 + 852),  (_DWORD *)(a1 + 1112),  v108,  *(uint64_t (**)(uint64_t, void, char *, __int128 *, unsigned int *, void))(a1 + 2432),  *(void *)(a1 + 2440)) & 0x80000000) == 0) {
      goto LABEL_17;
    }
    int v22 = "Main key derivation";
    __int16 v23 = 70;
LABEL_74:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"aeaContextUnlock",  v23,  57,  0,  v22,  v16,  v17,  v58);
    char v33 = 0LL;
    goto LABEL_75;
  }

  uint64_t v21 = *(unsigned int *)(a1 + 1372);
  __memcpy_chk();
  LODWORD(__n[0]) = v21;
  memset_s((char *)__n + v21 + 4, 256 - v21, 0, 256 - v21);
LABEL_17:
  if (!a5) {
    goto LABEL_20;
  }
  if (*(_DWORD *)a2 > 5u)
  {
    int v22 = "Unsupported signature mode";
    __int16 v23 = 102;
    goto LABEL_74;
  }

  int v24 = 1 << *(_DWORD *)a2;
  if ((v24 & 0x2A) != 0) {
    goto LABEL_20;
  }
  if ((v24 & 0x14) == 0)
  {
    uint64_t v55 = *(unsigned int *)(a1 + 2448);
    __memcpy_chk();
    LODWORD(v83[0]) = v55;
    memset_s((char *)v83 + v55 + 4, 256 - v55, 0, 256 - v55);
    goto LABEL_63;
  }

  memset(&v133[8], 0, 252);
  memset(__s, 0, 260);
  *(_DWORD *)&v133[7] = 1262834527;
  *(void *)uint64_t v133 = 0x5F41454100000007LL;
  memset_s(&v133[11], 0xF9uLL, 0, 0xF9uLL);
  if (!*((void *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(v133, 0x104uLL, 0, 0x104uLL);
    goto LABEL_70;
  }

  int v47 = (*((uint64_t (**)(_OWORD *, void, size_t *, _BYTE *, _OWORD *))&v68 + 1))( v85,  LODWORD(v65[0]),  __n,  v133,  __s);
  memset_s(v133, 0x104uLL, 0, 0x104uLL);
  if (v47 < 0)
  {
LABEL_70:
    int v22 = "deriving signature encryption key";
    __int16 v23 = 89;
    goto LABEL_74;
  }

  if (!*((void *)&v73 + 1))
  {
LABEL_73:
    int v22 = "decrypting signature";
    __int16 v23 = 90;
    goto LABEL_74;
  }

  memset(__s, 0, 260);
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v129 = 0;
  memset(v128, 0, sizeof(v128));
  if (*(_DWORD *)(a1 + 2448) != HIDWORD(v66)) {
    goto LABEL_72;
  }
  if (LODWORD(v85[0]) != LODWORD(v65[0])) {
    goto LABEL_72;
  }
  *(void *)((char *)v130 + 4) = 0x324B45535F414541LL;
  LODWORD(v130[0]) = 8;
  memset_s((void *)((unint64_t)v130 | 0xC), 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((void *)&v68 + 1)
    || !LODWORD(v85[0])
    || ((*((uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _BYTE *))&v68 + 1))( __s,  DWORD1(v65[0]),  v85,  v130,  v133) & 0x80000000) != 0)
  {
    goto LABEL_72;
  }

  uint64_t v48 = DWORD2(v66);
  if (DWORD2(v66) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v83[0]) = v48;
  memset_s((char *)v83 + v48 + 4, 256 - v48, 0, 256 - v48);
  uint64_t v49 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v128[0]) = v49;
  memset_s((char *)v128 + v49 + 4, 256 - v49, 0, 256 - v49);
  if (((*((uint64_t (**)(char *, void, _OWORD *, _OWORD *, void, void))&v73 + 1))( (char *)v83 + 4,  LODWORD(v83[0]),  v128,  __s,  0LL,  0LL) & 0x80000000) != 0)
  {
LABEL_72:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    goto LABEL_73;
  }

  int v50 = v83[0];
  int v51 = DWORD2(v66);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v128, 0x104uLL, 0, 0x104uLL);
  memset_s(v130, 0x104uLL, 0, 0x104uLL);
  if (v50 != v51) {
    goto LABEL_73;
  }
LABEL_63:
  if (!*((void *)&v71 + 1)
    || (int v56 = (*((uint64_t (**)(_OWORD *, void, void))&v71 + 1))( v81,  *(void *)(a1 + 2720),  *(void *)(a1 + 2728)),  LODWORD(v81[0]) != DWORD1(v66))
    || v56 < 0)
  {
    int v22 = "digesting prologue";
    __int16 v23 = 94;
    goto LABEL_74;
  }

  if (!*((void *)&v72 + 1)
    || ((*((uint64_t (**)(_OWORD *, _OWORD *, _OWORD *))&v72 + 1))(v83, v89, v81) & 0x80000000) != 0)
  {
    int v22 = "verifying signature";
    __int16 v23 = 97;
    goto LABEL_74;
  }

uint64_t aeaContextCreateWithPrologue(_DWORD *a1, size_t a2)
{
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v31 = 0u;
  memset(__s, 0, sizeof(__s));
  uint64_t v29 = 0LL;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  uint64_t v4 = (AEAContext_impl *)malloc(0xAB8uLL);
  int v5 = v4;
  if (!v4)
  {
    int v14 = *__error();
    int v12 = "malloc";
    __int16 v13 = 161;
LABEL_16:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"aeaContextCreateWithPrologue",  v13,  57,  v14,  v12,  v10,  v11,  v23);
    AEAContextDestroy(v5);
    return 0LL;
  }

  memset_s(v4, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v5 + 684) = 1;
  if (a2 <= 0xB)
  {
    int v12 = "Invalid prologue";
    __int16 v13 = 167;
LABEL_15:
    int v14 = 0;
    goto LABEL_16;
  }

  if ((aeaContainerParamsInitWithMagic((int *)v5, a1, v6, v7, v8, v9, v10, v11) & 0x80000000) != 0)
  {
    int v12 = "Invalid magic";
    __int16 v13 = 168;
    goto LABEL_15;
  }

  if ((aeaCryptoInit((char *)__s, (unsigned int *)v5) & 0x80000000) != 0)
  {
    int v12 = "Invalid container";
    __int16 v13 = 169;
    goto LABEL_15;
  }

  if ((aeaContainerOffsetsInit((uint64_t)&v23, (unsigned int *)v5, (unsigned int *)__s) & 0x80000000) != 0)
  {
    int v12 = "deriving container offsets";
    __int16 v13 = 170;
    goto LABEL_15;
  }

  if ((void)v27 != a2)
  {
    int v12 = "Prologue size mismatch";
    __int16 v13 = 171;
    goto LABEL_15;
  }

  *((void *)v5 + 341) = a2;
  if (a2 >= 0x2000000001LL)
  {
    *__error() = 12;
    *((void *)v5 + 340) = 0LL;
LABEL_28:
    int v14 = *__error();
    int v12 = "malloc";
    __int16 v13 = 176;
    goto LABEL_16;
  }

  uint64_t v16 = (char *)malloc(a2);
  *((void *)v5 + 340) = v16;
  if (!v16) {
    goto LABEL_28;
  }
  uint64_t v17 = v16;
  memcpy(v16, a1, a2);
  size_t v18 = *((unsigned int *)v5 + 1);
  if ((_DWORD)v18)
  {
    uint64_t v19 = malloc(*((unsigned int *)v5 + 1));
    *((void *)v5 + 339) = v19;
    if (!v19)
    {
      int v14 = *__error();
      int v12 = "malloc";
      __int16 v13 = 184;
      goto LABEL_16;
    }

    memcpy(v19, &v17[*((void *)&v23 + 1)], v18);
  }

  if (!*((void *)&v41 + 1)
    || (uint64_t result = (*((uint64_t (**)(uint64_t, char *, size_t))&v41 + 1))((uint64_t)v5 + 1892, v17, a2),
        *((_DWORD *)v5 + 473) != DWORD1(v32))
    || (result & 0x80000000) != 0)
  {
    int v12 = "digesting prologue";
    __int16 v13 = 189;
    goto LABEL_15;
  }

  rsize_t v20 = HIDWORD(v31);
  if (HIDWORD(v31) < 0x101)
  {
    uint64_t v21 = *((void *)v5 + 340);
    int v22 = (void *)(v21 + v24);
    __memcpy_chk();
    *((_DWORD *)v5 + 612) = v20;
    memset_s((char *)v5 + v20 + 2452, 256 - v20, 0, 256 - v20);
    if (v21) {
      memset_s(v22, v20, 0, v20);
    }
    return (uint64_t)v5;
  }

  __break(1u);
  return result;
}

void AEAContextDestroy(AEAContext context)
{
  if (context)
  {
    uint64_t v2 = (void *)*((void *)context + 339);
    if (v2) {
      memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
    }
    free(v2);
    uint64_t v3 = (void *)*((void *)context + 340);
    if (v3) {
      memset_s(*((void **)context + 340), *((void *)context + 341), 0, *((void *)context + 341));
    }
    free(v3);
    memset_s(context, 0xAB8uLL, 0, 0xAB8uLL);
    free(context);
  }

AEAContext AEAContextCreateWithProfile(AEAProfile profile)
{
  uint64_t v2 = (AEAContext_impl *)malloc(0xAB8uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    int v12 = *__error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextCreateWithProfile",  237,  57,  v12,  "malloc",  v13,  v14,  v16);
    goto LABEL_5;
  }

  memset_s(v2, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v3 + 684) = 0;
  if ((aeaContainerParamsInitWithProfile((uint64_t)v3, profile, v4, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextCreateWithProfile",  243,  57,  0,  "Invalid profile: %u",  v10,  v11,  profile);
LABEL_5:
    AEAContextDestroy(v3);
    return 0LL;
  }

  return v3;
}

AEAContext AEAContextCreateWithEncryptedStream(AAByteStream encrypted_stream)
{
  uint64_t v36 = 0LL;
  memset(v35, 0, sizeof(v35));
  uint64_t v34 = 0LL;
  *(_OWORD *)__timespec size = 0u;
  __int128 v33 = 0u;
  memset(v31, 0, sizeof(v31));
  int v30 = 0;
  uint64_t v29 = 0LL;
  if (*((void *)encrypted_stream + 2))
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = &v29;
    uint64_t v6 = 12LL;
    do
    {
      uint64_t v7 = (*((uint64_t (**)(void, uint64_t *, uint64_t))encrypted_stream + 2))( *(void *)encrypted_stream,  v5,  v6);
      if (v7 < 0) {
        goto LABEL_12;
      }
      if (!v7) {
        break;
      }
      uint64_t v5 = (uint64_t *)((char *)v5 + v7);
      v4 += v7;
      v6 -= v7;
    }

    while (v6);
    if (v4 != 12) {
      goto LABEL_12;
    }
    if ((aeaContainerParamsInitWithMagic((int *)v35, &v29, v8, v9, v10, v11, v1, v2) & 0x80000000) != 0)
    {
      uint64_t v13 = "Invalid magic";
      __int16 v14 = 264;
      goto LABEL_13;
    }

    if ((aeaCryptoInit((char *)__s, (unsigned int *)v35) & 0x80000000) != 0)
    {
      uint64_t v13 = "Invalid container";
      __int16 v14 = 265;
      goto LABEL_13;
    }

    if ((aeaContainerOffsetsInit((uint64_t)v31, (unsigned int *)v35, (unsigned int *)__s) & 0x80000000) != 0)
    {
      uint64_t v13 = "deriving container offsets";
      __int16 v14 = 266;
      goto LABEL_13;
    }

    size_t v12 = __size[0];
    if (__size[0] >= 0x2000000001LL)
    {
      *__error() = 12;
LABEL_28:
      int v15 = *__error();
      uint64_t v13 = "malloc";
      __int16 v14 = 271;
      goto LABEL_14;
    }

    uint64_t v19 = malloc(__size[0]);
    if (!v19) {
      goto LABEL_28;
    }
    char v16 = v19;
    *(void *)uint64_t v19 = v29;
    v19[2] = v30;
    if (*((void *)encrypted_stream + 2))
    {
      uint64_t v22 = 0LL;
      if (v12 != 12)
      {
        __int128 v23 = (char *)(v19 + 3);
        size_t v24 = v12 - 12;
        while (1)
        {
          uint64_t v25 = (*((uint64_t (**)(void, char *, size_t))encrypted_stream + 2))( *(void *)encrypted_stream,  v23,  v24);
          if (v25 < 0) {
            break;
          }
          if (v25)
          {
            v23 += v25;
            v22 += v25;
            v24 -= v25;
            if (v24) {
              continue;
            }
          }

          goto LABEL_31;
        }

        uint64_t v22 = v25;
      }
    }

    else
    {
      uint64_t v22 = -1LL;
    }

uint64_t AEAContextGetFieldUInt(AEAContext context, AEAContextField field)
{
  switch(field)
  {
    case 0u:
      uint64_t result = *(unsigned int *)context;
      break;
    case 1u:
      uint64_t result = *((void *)context + 7);
      break;
    case 2u:
      uint64_t result = *((unsigned int *)context + 3);
      break;
    case 3u:
      uint64_t result = *((unsigned int *)context + 6);
      break;
    case 4u:
      uint64_t result = *((unsigned int *)context + 4);
      break;
    case 0xDu:
      uint64_t result = *((void *)context + 4);
      break;
    case 0xEu:
      uint64_t result = *((void *)context + 5);
      break;
    case 0x11u:
      uint64_t result = *((unsigned int *)context + 5);
      break;
    default:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextGetFieldUInt",  314,  57,  0,  "Invalid field",  v2,  v3,  vars0);
      uint64_t result = -1LL;
      break;
  }

  return result;
}

int AEAContextGetFieldBlob( AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, size_t buf_capacity, uint8_t *buf, size_t *buf_size)
{
  if (field > 0x13) {
    goto LABEL_14;
  }
  if (((1 << field) & 0xC1260) != 0)
  {
    if (representation)
    {
      uint64_t v8 = "Invalid representation";
      __int16 v9 = 337;
LABEL_23:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextGetFieldBlob",  v9,  57,  0,  v8,  v6,  v7,  vars0);
      return -1;
    }

    goto LABEL_7;
  }

  if (((1 << field) & 0xD80) == 0)
  {
LABEL_14:
    uint64_t v8 = "Invalid field";
    __int16 v9 = 346;
    goto LABEL_23;
  }

  if (representation != 1)
  {
    uint64_t v8 = "Invalid representation";
    __int16 v9 = 343;
    goto LABEL_23;
  }

uint64_t getFieldBlob( unsigned int *a1, size_t a2, void *__dst, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    *a4 = *a1;
  }
  if (a2)
  {
    size_t v8 = *a1;
    if (v8 > a2)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"getFieldBlob",  212,  57,  0,  "buf_capacity is too small",  a7,  a8,  vars0);
      return 0xFFFFFFFFLL;
    }

    memcpy(__dst, a1 + 1, v8);
  }

  return 0LL;
}

int AEAContextSetFieldUInt(AEAContext context, AEAContextField field, uint64_t value)
{
  if (field == 1 || !*((_DWORD *)context + 684))
  {
    switch(field)
    {
      case 1u:
        if (value - 16 >= 0xFFFFFFFFFFFFFFF2LL)
        {
          uint64_t v6 = "Invalid padding size";
          __int16 v7 = 415;
          goto LABEL_4;
        }

        int result = 0;
        *((void *)context + 7) = value;
        return result;
      case 2u:
        if (value > 2)
        {
          uint64_t v6 = "Invalid checksum mode";
          __int16 v7 = 429;
          goto LABEL_4;
        }

        *((_DWORD *)context + 3) = value;
        int v10 = aeaChecksumSize(value);
        int result = 0;
        *((_DWORD *)context + 12) = v10;
        return result;
      case 3u:
        if ((uint64_t)value <= 1284)
        {
          if (value && value != 256 && value != 774) {
            goto LABEL_36;
          }
        }

        else if ((uint64_t)value > 2048)
        {
          if (value != 2304 && value != 2049) {
            goto LABEL_36;
          }
        }

        else if (value != 1285 && value != 1794)
        {
LABEL_36:
          uint64_t v6 = "Invalid compression algorithm";
          __int16 v7 = 398;
          goto LABEL_4;
        }

        int result = 0;
        *((_DWORD *)context + 6) = value;
        return result;
      case 4u:
        int result = 0;
        uint64_t v11 = 0x4000LL;
        if (value > 0x4000) {
          uint64_t v11 = value;
        }
        if (v11 >= 0x10000000) {
          LODWORD(v11) = 0x10000000;
        }
        *((_DWORD *)context + 4) = v11;
        return result;
      default:
        if (field != 17)
        {
          uint64_t v6 = "Invalid field";
          __int16 v7 = 439;
          goto LABEL_4;
        }

        int result = 0;
        uint64_t v9 = 32LL;
        if (value > 0x20) {
          uint64_t v9 = value;
        }
        if (v9 >= 0x40000) {
          LODWORD(v9) = 0x40000;
        }
        *((_DWORD *)context + 5) = v9;
        return result;
    }
  }

  uint64_t v6 = "Context can't be modified";
  __int16 v7 = 384;
LABEL_4:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextSetFieldUInt",  v7,  57,  0,  v6,  v3,  v4,  v12);
  return -1;
}

int AEAContextSetFieldBlob( AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, const uint8_t *buf, size_t buf_size)
{
  if (field > 0x13) {
    goto LABEL_14;
  }
  if (((1 << field) & 0x81260) == 0)
  {
    if (((1 << field) & 0xD80) != 0)
    {
      if (representation != 1)
      {
        uint64_t v11 = "Invalid representation";
        __int16 v12 = 464;
        goto LABEL_23;
      }

      goto LABEL_7;
    }

LABEL_14:
    uint64_t v11 = "Invalid field";
    __int16 v12 = 467;
LABEL_23:
    int v14 = 0;
LABEL_24:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextSetFieldBlob",  v12,  57,  v14,  v11,  v6,  v7,  v18);
    return -1;
  }

  if (representation)
  {
    uint64_t v11 = "Invalid representation";
    __int16 v12 = 458;
    goto LABEL_23;
  }

  if (field == 19 && buf_size <= 0x13)
  {
    uint64_t v11 = "Password is too short";
    __int16 v12 = 471;
    goto LABEL_23;
  }

  extractToDirAsyncClose(v19);
  free(v21);
  return 0LL;
}

  char v16 = -1;
LABEL_15:
  if (lstat(v63, &v60) < 0)
  {
    uint64_t v22 = __error();
    if ((a4 & 1) != 0 && *v22 == 13) {
      return 0LL;
    }
    uint64_t v13 = *__error();
    uint64_t v59 = v63;
    uint64_t v11 = "%s";
    __int16 v12 = 443;
    goto LABEL_33;
  }

  uint64_t v17 = v60.st_mode & 0xF000;
  if (v17 != 0x4000 && v17 != 40960 && v17 != 0x8000)
  {
    if ((*a1 & 1) != 0 && v15 != v60.st_uid || (uint64_t v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
    {
      if (!lchown(v63, v15, v16) || (size_t v24 = __error(), (a4 & 1) != 0) && *v24 == 1)
      {
        uint64_t v20 = 1;
      }

      else
      {
        uint64_t v42 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  494,  102,  *v42,  "%s",  v43,  v44,  (char)v63);
        uint64_t v20 = 0;
      }
    }

    if ((*a1 & 8) != 0)
    {
      uint64_t v45 = *((_DWORD *)a1 + 4) & 0xFFF;
      if (v45 != (v60.st_mode & 0xFFF))
      {
        if (lchmod(v63, v45))
        {
          int v46 = __error();
          if ((a4 & 1) == 0 || *v46 != 1)
          {
            int v47 = __error();
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  499,  102,  *v47,  "%s",  v48,  v49,  (char)v63);
            uint64_t v20 = 0;
          }
        }
      }
    }

    if (HIDWORD(v61[0]))
    {
      if (setattrlist(v63, v61, v62, v10, 1u))
      {
        int v50 = __error();
        if ((a4 & 1) == 0 || *v50 != 1)
        {
          int v51 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  512,  102,  *v51,  "%s",  v52,  v53,  (char)v63);
          uint64_t v20 = 0;
        }
      }
    }

    if ((*a1 & 4) != 0)
    {
      uint64_t v54 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
      if (v60.st_flags != v54)
      {
        if (lchflags(v63, v54))
        {
          uint64_t v55 = __error();
          if ((a4 & 1) == 0 || *v55 != 1)
          {
            int v56 = __error();
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  526,  102,  *v56,  "%s",  v57,  v58,  (char)v63);
            uint64_t v20 = 0;
          }
        }
      }
    }

    goto LABEL_61;
  }

  char v18 = open(v63, 0x200000);
  if (v18 < 0)
  {
    uint64_t v13 = *__error();
    uint64_t v59 = v63;
    uint64_t v11 = "%s";
    __int16 v12 = 456;
    goto LABEL_33;
  }

  uint64_t v19 = v18;
  if ((*a1 & 1) != 0 && v15 != v60.st_uid || (uint64_t v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
  {
    if (!fchown(v18, v15, v16) || (uint64_t v21 = __error(), (a4 & 1) != 0) && *v21 == 1)
    {
      uint64_t v20 = 1;
    }

    else
    {
      uint64_t v25 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  460,  102,  *v25,  "%s",  v26,  v27,  (char)v63);
      uint64_t v20 = 0;
    }
  }

  if ((*a1 & 8) != 0)
  {
    __int16 v28 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v28 != (v60.st_mode & 0xFFF))
    {
      if (fchmod(v19, v28))
      {
        uint64_t v29 = __error();
        if ((a4 & 1) == 0 || *v29 != 1)
        {
          int v30 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  464,  102,  *v30,  "%s",  v31,  v32,  (char)v63);
          uint64_t v20 = 0;
        }
      }
    }
  }

  if (HIDWORD(v61[0]))
  {
    if (fsetattrlist(v19, v61, v62, v10, 1u))
    {
      __int128 v33 = __error();
      if ((a4 & 1) == 0 || *v33 != 1)
      {
        uint64_t v34 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  469,  102,  *v34,  "%s",  v35,  v36,  (char)v63);
        uint64_t v20 = 0;
      }
    }
  }

  if ((*a1 & 4) != 0)
  {
    __int128 v37 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
    if (v60.st_flags != v37)
    {
      if (fchflags(v19, v37))
      {
        __int128 v38 = __error();
        if ((a4 & 1) == 0 || *v38 != 1)
        {
          __int128 v39 = __error();
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c",  (uint64_t)"aaEntryAttributesApplyToPath",  483,  102,  *v39,  "%s",  v40,  v41,  (char)v63);
          uint64_t v20 = 0;
        }
      }
    }
  }

  close(v19);
LABEL_61:
  if (v20) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

        int v14 = *v11;
        int v15 = realloc(*v11, v9);
        if (v15)
        {
          *((void *)header + 3) = v9;
          *((void *)header + 4) = v15;
          goto LABEL_16;
        }

        free(v14);
LABEL_23:
        const char *v11 = 0LL;
        *uint64_t v6 = 0LL;
        *((void *)header + 3) = 0LL;
      }
    }

    __int16 v12 = "realloc blob";
    uint64_t v13 = 514;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c",  (uint64_t)"AAHeaderAssign",  v13,  101,  0,  v12,  v4,  v5,  v19);
  return -1;
}

  int v15 = a1[2];
  if (__src)
  {
    memcpy((void *)(v15 + *a1), __src, __smax);
  }

  else if (v15)
  {
    memset_s((void *)(v15 + *a1), __smax, 0, __smax);
  }

  int result = 0LL;
  *a1 += __smax;
  return result;
}

    uint64_t v5 = v6 - 1;
    uint64_t v4 = 1;
  }

  while (v6);
  if ((AAAsyncByteStreamProcess(v2[4], (uint64_t)v23, (uint64_t)a1[2], (uint64_t)a1[1]) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToStream.c",  (uint64_t)"readerProc",  149,  128,  0,  "AAAsyncByteStreamProcess",  v14,  v15,  v22);
  }

  else if ((v4 & 1) == 0)
  {
    char v16 = 0LL;
    goto LABEL_25;
  }

uint64_t setFieldBlob( _DWORD *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0x101)
  {
    uint64_t v11 = a1 + 1;
    memcpy(a1 + 1, a2, a3);
    *a1 = a3;
    memset_s((char *)v11 + a3, 256 - a3, 0, 256 - a3);
    return 0LL;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"setFieldBlob",  223,  57,  0,  "Invalid field size",  a7,  a8,  v12);
    return 0xFFFFFFFFLL;
  }

int AEAContextGenerateFieldBlob(AEAContext context, AEAContextField field)
{
  unint64_t v11 = 0LL;
  if (field == 19)
  {
    uint64_t v5 = (char *)context + 2156;
    int result = AEAKeychainGenerateItem(0, 0x63uLL, 0x100uLL, (char *)context + 2156, &v11, 0LL, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      unint64_t v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 538) = v11;
        goto LABEL_9;
      }

      goto LABEL_15;
    }

    size_t v8 = "generate random field";
    __int16 v9 = 527;
  }

  else if (field == 9)
  {
    uint64_t v5 = (char *)context + 76;
    int result = AEAKeychainGenerateItem(1, 0x100uLL, 0x100uLL, (char *)context + 76, &v11, 0LL, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      unint64_t v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 18) = v11;
LABEL_9:
        memset_s(&v5[v7], 256 - v7, 0, 256 - v7);
        return 0;
      }

uint64_t AEAContextSetFieldCallback( void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 16)
  {
    uint64_t result = 0LL;
    a1[305] = a3;
    a1[304] = a4;
  }

  else if (a2 == 15)
  {
    uint64_t result = 0LL;
    a1[303] = a3;
    a1[302] = a4;
  }

  else
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextSetFieldCallback",  555,  57,  0,  "Invalid field",  a7,  a8,  vars0);
    return 0xFFFFFFFFLL;
  }

  return result;
}

unint64_t AEAContextGetContainerSizeUpperBound(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0LL;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  memset(v16, 0, sizeof(v16));
  if ((aeaCryptoInit((char *)__s, (unsigned int *)a1) & 0x80000000) != 0)
  {
    uint64_t v13 = "Invalid context";
    __int16 v14 = 569;
    goto LABEL_13;
  }

  if ((aeaContainerOffsetsInit((uint64_t)v16, (unsigned int *)a1, (unsigned int *)__s) & 0x80000000) != 0)
  {
    uint64_t v13 = "deriving container offsets";
    __int16 v14 = 572;
    goto LABEL_13;
  }

  unint64_t v10 = v19
      * (((a2 + (unint64_t)*(unsigned int *)(a1 + 16) - 1) / *(unsigned int *)(a1 + 16)
        + *(unsigned int *)(a1 + 20)
        - 1)
       / *(unsigned int *)(a1 + 20));
  BOOL v11 = __CFADD__((void)v17, v10);
  uint64_t v12 = v17 + v10;
  if (v11)
  {
    uint64_t v13 = "invalid sizes";
    __int16 v14 = 580;
LABEL_13:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c",  (uint64_t)"AEAContextGetContainerSizeUpperBound",  v14,  57,  0,  v13,  v4,  v5,  v16[0]);
    return -1LL;
  }

  if (__CFADD__(v12, a2))
  {
    uint64_t v13 = "invalid sizes";
    __int16 v14 = 581;
    goto LABEL_13;
  }

  unint64_t result = aeaPaddedContainerSize(v12 + a2, *(void *)(a1 + 56), v6, v7, v8, v9, v4, v5);
  if (result == -1LL)
  {
    uint64_t v13 = "Container size is too large to allow padding";
    __int16 v14 = 585;
    goto LABEL_13;
  }

  return result;
}

uint64_t LargeFileWorker( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x1895F8858](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v82 = *MEMORY[0x1895F89C0];
  *(void *)(v8 + 8) = 0LL;
  unint64_t v10 = (void *)v8;
  BOOL v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = *(void *)v8;
  uint64_t v15 = *(unsigned int *)(v8 + 32);
  char v16 = (unint64_t *)(v8 + 16);
  int v80 = 0LL;
  else {
    size_t v17 = *(void *)(v14 + 56) - (v15 << 21);
  }
  size_t v18 = v17 - 17;
  if (v17 >= 0x11)
  {
    uint64_t v12 = malloc(0x1000000uLL);
    BOOL v11 = (unsigned __int8 *)malloc(v17);
    uint64_t v22 = (char *)malloc(0x40000uLL);
    uint64_t v13 = v22;
    if (!v12 || (v11 ? (BOOL v23 = v22 == 0LL) : (BOOL v23 = 1), v23))
    {
      int v33 = *__error();
      uint64_t v34 = "aaMalloc";
      __int16 v35 = 496;
LABEL_72:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_output_block",  v35,  112,  v33,  v34,  v24,  v25,  v72);
      int v21 = 0;
      goto LABEL_73;
    }

    __int128 v74 = v16;
    memset(__b, 255, sizeof(__b));
    uint64_t v26 = *(void **)(v14 + 24);
    if (!v26[4]) {
      goto LABEL_70;
    }
    __base = v13;
    uint64_t v27 = 0LL;
    size_t v28 = v17;
    uint64_t v29 = v15 << 21;
    int v30 = v11;
    int v75 = v15;
    unint64_t v76 = v28;
    size_t v31 = v28;
    while (1)
    {
      uint64_t v32 = ((uint64_t (*)(void, unsigned __int8 *, size_t, uint64_t))v26[4])(*v26, v30, v31, v29);
      if (v32 < 0) {
        break;
      }
      if (v32)
      {
        v30 += v32;
        v27 += v32;
        v29 += v32;
        v31 -= v32;
        if (v31) {
          continue;
        }
      }

      goto LABEL_25;
    }

    uint64_t v27 = v32;
LABEL_25:
    LODWORD(v15) = v75;
    size_t v17 = v76;
    BOOL v23 = v76 == v27;
    uint64_t v13 = __base;
    if (v23)
    {
      uint64_t v36 = 0LL;
      unsigned int v37 = 0;
      do
        unsigned int v37 = -1640531535 * (v37 + v11[v36++]);
      while (v36 != 16);
      uint64_t v77 = (uint64_t)v12;
      unint64_t v38 = 0LL;
      unint64_t v39 = 0LL;
      unint64_t v40 = 0LL;
      unsigned int v41 = 0;
      int v42 = *(_DWORD *)(v14 + 76);
      uint64_t v43 = 16LL;
      do
      {
        if (v38 >= v40 || (*(_DWORD *)(v14 + 68) & ~v37) == 0)
        {
          unint64_t v40 = v38 + (2 * *(_DWORD *)(v14 + 72));
          if (v38 >= v39)
          {
            uint64_t v44 = *(unsigned int *)(*(void *)(v14 + 40) + 4LL * (v37 >> -*(_BYTE *)(v14 + 64)));
            if ((_DWORD)v44 != -1)
            {
              uint64_t v45 = __ROR8__( __ROR8__(2654435761LL * *(void *)&v11[v38], 41) + 2654435761LL * *(void *)&v11[v38 + 8],  41);
              int v46 = HIDWORD(v45) ^ v45;
              uint64_t v47 = *(void *)(v14 + 32);
              while (1)
              {
                uint64_t v48 = v47 + 16 * v44;
                if (*(_DWORD *)(v48 + 8) == v46) {
                  break;
                }
                uint64_t v44 = *(unsigned int *)(v48 + 12);
                if ((_DWORD)v44 == -1) {
                  goto LABEL_46;
                }
              }

              uint64_t v49 = *(void *)(v47 + 16 * v44);
              uint64_t v50 = v49 >> 20;
              unint64_t v51 = v49 & 0xFFFFFFFFFFF00000LL;
              int v52 = __b[v50];
              if (v52 == -1)
              {
LABEL_42:
                if (v41 != 0x4000)
                {
                  uint64_t v54 = &__base[16 * v41];
                  *(void *)uint64_t v54 = v51;
                  *((_DWORD *)v54 + 2) = v52;
                  *((_DWORD *)v54 + 3) = 1;
                  __b[v50] = v41++;
                }
              }

              else
              {
                uint64_t v53 = __b[v50];
                while (*(void *)&__base[16 * v53] != v51)
                {
                  uint64_t v53 = *(unsigned int *)&__base[16 * v53 + 8];
                  if ((_DWORD)v53 == -1) {
                    goto LABEL_42;
                  }
                }

                ++*(_DWORD *)&__base[16 * v53 + 12];
              }

              unint64_t v39 = v43;
            }
          }
        }

uint64_t LargeFileConsumer( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = a2[1];
  if (result)
  {
    if (a2[2])
    {
      uint64_t v12 = 0LL;
      unint64_t v13 = 0LL;
      uint64_t v14 = *(char **)a1;
      do
      {
        uint64_t v14 = add_control( v14,  (unint64_t *)(a1 + 8),  (unint64_t *)(a1 + 16),  *(void *)(a2[1] + v12),  *(void *)(a2[1] + v12 + 8),  *(void *)(a2[1] + v12 + 16),  a7,  a8);
        *(void *)a1 = v14;
        if (!v14) {
          break;
        }
        ++v13;
        v12 += 24LL;
      }

      while (v13 < a2[2]);
      uint64_t result = a2[1];
    }

    free((void *)result);
    if (*(void *)a1) {
      return 0LL;
    }
    uint64_t v15 = (unsigned int *)(*a2 + 104LL);
    while (!__ldaxr(v15))
    {
      if (!__stlxr(1u, v15)) {
        return 0xFFFFFFFFLL;
      }
    }

    __clrex();
    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t GetLargeFileControlsWithStreams( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7)
{
  double RealTime = getRealTime();
  unsigned int DefaultNThreads = *((_DWORD *)a7 + 2);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  *(void *)__int128 v109 = 0LL;
  __int128 v107 = 0u;
  *(_OWORD *)__int128 v108 = 0u;
  *(_OWORD *)__int128 v105 = 0u;
  __int128 v106 = 0u;
  uint64_t v102 = 0LL;
  __int128 v98 = 0LL;
  uint64_t v99 = 0LL;
  uint64_t v103 = a1;
  __int128 v104 = a3;
  uint64_t v16 = *a7;
  int v17 = 16;
  unint64_t v100 = 0LL;
  v101[1] = HIDWORD(v16);
  v101[0] = 21;
  int v18 = __clz((a2 + 15) >> 4);
  LODWORD(v102) = 1;
  v105[1] = (void *)a2;
  *(void *)&__int128 v106 = a4;
  if (1LL << ~(_BYTE)v18 >= (a2 + 15) >> 4) {
    unsigned int v19 = 63 - v18;
  }
  else {
    unsigned int v19 = 64 - v18;
  }
  LODWORD(v107) = 16;
  if (v19 >= 0x1E)
  {
    do
    {
      --v19;
      v17 *= 2;
    }

    while (v19 > 0x1D);
    LODWORD(v107) = v17;
    unsigned int v19 = 29;
  }

  DWORD2(v106) = v19;
  HIDWORD(v106) = v17 - 1;
  DWORD1(v107) = 840293553;
  if (DefaultNThreads < 0xCCCCCCCD)
  {
    size_t v20 = calloc(DefaultNThreads, 0x28uLL);
  }

  else
  {
    size_t v20 = 0LL;
    *__error() = 12;
  }

  v108[0] = v20;
  int v21 = calloc(DefaultNThreads, 8uLL);
  v108[1] = v21;
  if (!v20 || !v21)
  {
    int v49 = *__error();
    uint64_t v50 = "aaCalloc";
    __int16 v51 = 672;
LABEL_35:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"GetLargeFileControlsWithStreams",  v51,  112,  v49,  v50,  v22,  v23,  v95);
    goto LABEL_36;
  }

  *((void *)&v104 + 1) = pc_array_init(16LL, (5 * (a2 / v107)) >> 2);
  if (!*((void *)&v104 + 1))
  {
    uint64_t v50 = "pc_array_init";
    __int16 v51 = 678;
LABEL_34:
    int v49 = 0;
    goto LABEL_35;
  }

  uint64_t v24 = malloc(4LL << SBYTE8(v106));
  v105[0] = v24;
  if (!v24)
  {
    int v49 = *__error();
    uint64_t v50 = "malloc";
    __int16 v51 = 683;
    goto LABEL_35;
  }

  memset(v24, 255, 4LL << SBYTE8(v106));
  uint64_t v25 = calloc(DefaultNThreads, 0x20uLL);
  uint64_t v26 = calloc(DefaultNThreads, 8uLL);
  uint64_t v27 = v26;
  if (!v25 || !v26)
  {
    uint64_t v54 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_input",  433,  112,  *v54,  "aaCalloc",  v55,  v56,  v95);
    unint64_t v39 = 0LL;
LABEL_49:
    int v48 = 0;
    goto LABEL_50;
  }

  if (DefaultNThreads)
  {
    size_t v28 = v25;
    uint64_t v29 = v26;
    uint64_t v30 = DefaultNThreads;
    size_t v31 = v25;
    do
    {
      *size_t v31 = v101;
      v31 += 4;
      *v29++ = v28;
      size_t v28 = v31;
      --v30;
    }

    while (v30);
  }

  unint64_t v39 = ThreadPipelineCreate( DefaultNThreads,  (uint64_t)v26,  (uint64_t)fingerprint_worker,  (uint64_t)v101,  (uint64_t)fingerprint_consumer,  0LL);
  if (!v39)
  {
    uint64_t v57 = "ThreadPipelineCreate";
    __int16 v58 = 444;
LABEL_48:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_input",  v58,  112,  0,  v57,  v37,  v38,  v95);
    goto LABEL_49;
  }

  __int128 v97 = a6;
  if (!v105[1])
  {
LABEL_29:
    a6 = v97;
    if ((ThreadPipelineFlush((uint64_t)v39) & 0x80000000) != 0)
    {
      uint64_t v57 = "ThreadPipelineFlush";
      __int16 v58 = 461;
    }

    else
    {
      *((void *)&v104 + 1) = pc_array_compact(*((uint64_t *)&v104 + 1));
      if (*((void *)&v104 + 1))
      {
        int v48 = 1;
        goto LABEL_50;
      }

      uint64_t v57 = "pc_array_compact";
      __int16 v58 = 465;
    }

    goto LABEL_48;
  }

  uint64_t v40 = 0LL;
  unsigned int v41 = 0LL;
  while (1)
  {
    uint64_t Worker = (void *)ThreadPipelineGetWorker((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
    if (!Worker)
    {
      uint64_t v59 = "ThreadPipelineGetWorker";
      __int16 v60 = 451;
      goto LABEL_45;
    }

    Worker[1] = 0LL;
    Worker[2] = v41;
    uint64_t v47 = (uint64_t)v105[1] + v40;
    Worker[3] = v47;
    v41 += 0x200000;
    v40 -= 0x200000LL;
    if (v41 >= v105[1]) {
      goto LABEL_29;
    }
  }

  uint64_t v59 = "ThreadPipelineRunWorker";
  __int16 v60 = 457;
LABEL_45:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_input",  v60,  112,  0,  v59,  v37,  v38,  v95);
  int v48 = 0;
  a6 = v97;
LABEL_50:
  if ((ThreadPipelineDestroy((uint64_t)v39) & 0x80000000) != 0)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"process_input",  468,  112,  0,  "ThreadPipelineDestroy",  v61,  v62,  v95);
    int v48 = 0;
  }

  free(v25);
  free(v27);
  if (!v48) {
    goto LABEL_36;
  }
  if (*((int *)a7 + 1) >= 3)
  {
    uint64_t v65 = (FILE *)*MEMORY[0x1895F89D0];
    unint64_t v66 = (unint64_t)(4LL << SBYTE8(v106)) >> 20;
    uint64_t v67 = a5;
    uint64_t v68 = (*(void *)(*((void *)&v104 + 1) - 64LL) >> 16) & 0xFFFFFFFFFFFLL;
    unint64_t v69 = (unint64_t)v105[1] >> 20;
    double v70 = getRealTime();
    uint64_t v96 = v68;
    a5 = v67;
    fprintf( v65,  " LargeFile: Using %zu M for hashing.\n LargeFile: Using %zu M for fingerprints.\n LargeFile: Parsed %zu M in %0.2f (s). Added %zu/%zu fingerprints.\n",  v66,  v96,  v69,  v70 - RealTime,  *(void *)(*((void *)&v104 + 1) - 64LL),  (unint64_t)v105[1] / v107);
  }

  __int128 v98 = add_control(0LL, (unint64_t *)&v99, &v100, 0LL, 0LL, 0LL, v63, v64);
  if (!v98) {
    goto LABEL_36;
  }
  if (DefaultNThreads)
  {
    for (uint64_t i = 0LL; i != DefaultNThreads; *((void *)v108[1] + i++) = v72)
    {
      char v72 = (char *)v108[0] + 40 * i;
      void *v72 = v101;
    }
  }

  uint64_t v73 = ThreadPipelineCreate( DefaultNThreads,  (uint64_t)v108[1],  (uint64_t)LargeFileWorker,  (uint64_t)&v98,  (uint64_t)LargeFileConsumer,  0LL);
  *((void *)&v107 + 1) = v73;
  if (!v73)
  {
    uint64_t v50 = "creating pipeline";
    __int16 v51 = 711;
    goto LABEL_34;
  }

  if (!a4)
  {
LABEL_67:
    if ((ThreadPipelineDestroy((uint64_t)v73) & 0x80000000) == 0)
    {
      *((void *)&v107 + 1) = 0LL;
      uint64_t v99 = sanitize_internal_controls(v98, v99);
      convert_internal_controls((uint64_t)&v98);
      if (*((int *)a7 + 1) >= 2)
      {
        uint64_t v89 = (FILE *)*MEMORY[0x1895F89D0];
        uint64_t v90 = v99;
        double v91 = getRealTime();
        fprintf(v89, "LargeFile: Constructed %zu controls in %0.2f (s).\n", v90, v91 - RealTime);
      }

      int v52 = 0;
      uint64_t v92 = v99;
      *a5 = v98;
      *a6 = v92;
      goto LABEL_37;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"GetLargeFileControlsWithStreams",  725,  112,  0,  "ThreadPipelineDestroy failed",  v87,  v88,  v95);
    *((void *)&v107 + 1) = 0LL;
LABEL_36:
    int v52 = 1;
    goto LABEL_37;
  }

  unsigned int v79 = 1;
  while (1)
  {
    uint64_t v80 = ThreadPipelineGetWorker(*((uint64_t *)&v107 + 1), v74, v75, v76, v77, v78, v22, v23);
    if (!v80) {
      break;
    }
    *(_DWORD *)(v80 + 32) = v79 - 1;
    if ((ThreadPipelineRunWorker(*((uint64_t *)&v107 + 1), v80, v81, v82, v83, v84, v22, v23) & 0x80000000) != 0
      || (unsigned int v85 = atomic_load(v109)) != 0)
    {
      __int128 v93 = "RunWorker";
      __int16 v94 = 723;
      goto LABEL_75;
    }

    uint64_t v86 = v79++;
    if (a4 <= v86 << 21)
    {
      uint64_t v73 = (unsigned int *)*((void *)&v107 + 1);
      goto LABEL_67;
    }
  }

  __int128 v93 = "getting worker from pipeline";
  __int16 v94 = 718;
LABEL_75:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"GetLargeFileControlsWithStreams",  v94,  112,  0,  v93,  v22,  v23,  v95);
  int v52 = 1;
LABEL_37:
  ThreadPipelineDestroy(*((uint64_t *)&v107 + 1));
  free(v108[0]);
  free(v108[1]);
  free(v105[0]);
  pc_array_free(*((uint64_t *)&v104 + 1));
  if (v52)
  {
    free(v98);
    *a5 = 0LL;
    *a6 = 0LL;
  }

  return (v52 << 31 >> 31);
}

char *add_control( char *__ptr, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = __ptr;
  unint64_t v13 = *a2;
  if (*a2 < *a3) {
    goto LABEL_2;
  }
  unint64_t v15 = v13 + (v13 >> 1) + 1;
  *a3 = v15;
  if (*a2 >= v15)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"add_control",  213,  112,  0,  "too many controls",  a7,  a8,  v21);
    free(v12);
    return 0LL;
  }

  if (24 * v15 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_10:
    int v17 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"add_control",  215,  112,  *v17,  "aaReallocf",  v18,  v19,  v21);
    return 0LL;
  }

  uint64_t v16 = (char *)realloc(__ptr, 24 * v15);
  if (!v16)
  {
    free(v12);
    goto LABEL_10;
  }

  unint64_t v13 = *a2;
  uint64_t v12 = v16;
LABEL_2:
  *a2 = v13 + 1;
  uint64_t v14 = &v12[24 * v13];
  *(void *)uint64_t v14 = a4;
  *((void *)v14 + 1) = a5;
  *((void *)v14 + 2) = a6;
  return v12;
}

uint64_t sanitize_internal_controls(void *a1, uint64_t a2)
{
  uint64_t v2 = (char *)a1;
  if (a2 >= 2)
  {
    unint64_t v3 = (unint64_t)&a1[3 * a2];
    uint64_t v4 = a1 + 3;
    uint64_t v5 = a1;
    uint64_t v6 = (char *)a1;
    do
    {
      uint64_t v7 = v5;
      while (1)
      {
        uint64_t v5 = v4;
        uint64_t v8 = *v4;
        if (!v8)
        {
          uint64_t v9 = *((void *)v6 + 1) + v7[4];
          goto LABEL_9;
        }

        if (*((void *)v6 + 1) || *(void *)v6 + *((void *)v6 + 2) != v7[5]) {
          break;
        }
        *(void *)v6 += v8;
        uint64_t v9 = v7[4];
LABEL_9:
        *((void *)v6 + 1) = v9;
        uint64_t v4 = v5 + 3;
        uint64_t v7 = v5;
        if ((unint64_t)(v5 + 3) >= v3)
        {
          uint64_t v2 = v6;
          return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
        }
      }

      uint64_t v2 = v6 + 24;
      __int128 v10 = *(_OWORD *)v5;
      *((void *)v6 + 5) = v5[2];
      *(_OWORD *)(v6 + 24) = v10;
      uint64_t v4 = v5 + 3;
      v6 += 24;
    }

    while ((unint64_t)(v5 + 3) < v3);
  }

  return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
}

uint64_t convert_internal_controls(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    unint64_t v2 = 0LL;
    unint64_t v3 = *(uint64_t **)result;
    int64x2_t v4 = vdupq_n_s64(0x8000000000000000LL);
    do
    {
      uint64_t v5 = *v3;
      uint64_t v6 = v3[2] + *v3;
      ++v2;
      uint64_t v7 = v6;
      if (v2 < v1) {
        uint64_t v7 = v3[5];
      }
      if (v5 < 0) {
        uint64_t v5 = 0x8000000000000000LL - v5;
      }
      *unint64_t v3 = v5;
      v8.i64[0] = v3[1];
      v8.i64[1] = v7 - v6;
      *(int8x16_t *)(v3 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(v8), (int8x16_t)vsubq_s64(v4, v8), (int8x16_t)v8);
      v3 += 3;
    }

    while (v1 != v2);
  }

  return result;
}

uint64_t GetLargeFileControls( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v14 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  char v21 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a3, a4, v15, v16, v17, v18, v19, v20);
  uint64_t v24 = v21;
  if (!v14 || !v21)
  {
    uint64_t v26 = "AAMemoryInputStreamOpen";
    __int16 v27 = 758;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"GetLargeFileControls",  v27,  112,  0,  v26,  v22,  v23,  v29);
    uint64_t v25 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }

  if ((GetLargeFileControlsWithStreams((uint64_t)v14, a2, (unint64_t)v21, a4, a5, a6, a7) & 0x80000000) != 0)
  {
    uint64_t v26 = "GetLargeFileControlsWithStreams";
    __int16 v27 = 761;
    goto LABEL_7;
  }

  uint64_t v25 = 0LL;
LABEL_8:
  AAByteStreamClose(v14);
  AAByteStreamClose(v24);
  return v25;
}

uint64_t chunk_compare_by_rating(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12));
}

uint64_t chunk_compare_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

char *convert_block_controls( unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v26 = 0LL;
  *a1 = 0LL;
  if (a3)
  {
    BOOL v11 = 0LL;
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    do
    {
      uint64_t v14 = a2[3 * v12];
      if (v14 >= 0) {
        uint64_t v15 = a2[3 * v12];
      }
      else {
        uint64_t v15 = 0x8000000000000000LL - v14;
      }
      while (1)
      {
        uint64_t v16 = v13 & 0xFFFFF;
        uint64_t v17 = 0x100000 - (v13 & 0xFFFFF);
        if (v17 >= v15) {
          break;
        }
        uint64_t v18 = add_control( v11,  a1,  &v26,  0x100000 - (v13 & 0xFFFFF),  0LL,  *(void *)(a4 + 16 * (v13 >> 20)) + v16,  a7,  a8);
        if (!v18)
        {
          __int16 v23 = 251;
LABEL_18:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"convert_block_controls",  v23,  112,  0,  "add_control",  a7,  a8,  a3);
          goto LABEL_19;
        }

        BOOL v11 = v18;
        v15 -= v17;
        v13 += v17;
      }

      uint64_t v19 = a2[3 * v12 + 1];
      if (v19 >= 0) {
        uint64_t v20 = a2[3 * v12 + 1];
      }
      else {
        uint64_t v20 = 0x8000000000000000LL - v19;
      }
      char v21 = add_control(v11, a1, &v26, v15, v20, *(void *)(a4 + 16 * (v13 >> 20)) + v16, a7, a8);
      if (!v21)
      {
        __int16 v23 = 255;
        goto LABEL_18;
      }

      BOOL v11 = v21;
      uint64_t v22 = a2[3 * v12 + 2];
      if (v22 < 0) {
        uint64_t v22 = 0x8000000000000000LL - v22;
      }
      v13 += v15 + v22;
      ++v12;
    }

    while (v12 != a3);
  }

  else
  {
LABEL_19:
    BOOL v11 = 0LL;
  }

  free(a2);
  return v11;
}

uint64_t fingerprint_worker(uint64_t *a1)
{
  size_t v2 = a1[3];
  if (v2 < 0x11) {
    return 0LL;
  }
  if (v2 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c",  (uint64_t)"fingerprint_worker",  325,  112,  0,  "aaMalloc",  v4,  v5,  v40);
    int64x2_t v8 = 0LL;
    uint64_t v15 = 0LL;
    goto LABEL_32;
  }

  uint64_t v6 = *a1;
  uint64_t v7 = (unsigned __int8 *)malloc(v2);
  if (!v7) {
    goto LABEL_14;
  }
  int64x2_t v8 = v7;
  uint64_t v15 = pc_array_init(16LL);
  if (!v15)
  {
    __int16 v23 = "pc_array_init";
    __int16 v24 = 329;
    goto LABEL_31;
  }

  uint64_t v16 = a1[3];
  uint64_t v17 = *(void **)(v6 + 16);
  if (!v17[4])
  {
    uint64_t v18 = -1LL;
LABEL_18:
    if (v16 != v18)
    {
      __int16 v23 = "aaByteStreamPReadExpected";
      __int16 v24 = 333;
      goto LABEL_31;
    }

    goto LABEL_19;
  }

  if (v16)
  {
    uint64_t v18 = 0LL;
    uint64_t v19 = a1[2];
    uint64_t v20 = v8;
    uint64_t v21 = a1[3];
    while (1)
    {
      uint64_t v22 = ((uint64_t (*)(void, unsigned __int8 *, uint64_t, uint64_t))v17[4])(*v17, v20, v21, v19);
      if (v22 < 0) {
        break;
      }
      if (v22)
      {
        v20 += v22;
        v18 += v22;
        v19 += v22;
        v21 -= v22;
        if (v21) {
          continue;
        }
      }

      goto LABEL_18;
    }

    uint64_t v18 = v22;
    goto LABEL_18;
  }

uint64_t fingerprint_consumer( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8) {
    return 0LL;
  }
  unint64_t v9 = *(void *)(v8 - 64);
  if (!v9)
  {
LABEL_13:
    int v12 = 0;
    goto LABEL_16;
  }

  uint64_t v11 = 0LL;
  int v12 = 1;
  while (1)
  {
    uint64_t v13 = (_DWORD *)(v8 + 16 * v11);
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = v13[3];
    int v16 = *(_DWORD *)(v14 + 4 * v15);
    if (v16 != -1)
    {
      uint64_t v17 = *(unsigned int *)(v14 + 4 * v15);
      while (1)
      {
        uint64_t v18 = *(void *)(a1 + 32) + 16 * v17;
        if (v13[2] == *(_DWORD *)(v18 + 8)) {
          break;
        }
        uint64_t v17 = *(unsigned int *)(v18 + 12);
        if ((_DWORD)v17 == -1) {
          goto LABEL_8;
        }
      }

      if (*(void *)v18 < *(void *)v13) {
        *(void *)uint64_t v18 = *(void *)v13;
      }
      goto LABEL_9;
    }

size_t pc_log_error( uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  bzero(__str, 0x400uLL);
  uint64_t v13 = (_WORD *)(((a3 & 0x3FFF) << 10) | (a4 << 24) | a5 & 0x3FF | 0x80000000);
  if (a5 >= 1)
  {
    uint64_t v14 = strerror(a5);
    snprintf(__str, 0x400uLL, "%s: ", v14);
  }

  size_t v15 = strlen(__str);
  vsnprintf(&__str[v15], 1024 - v15, a6, &a9);
  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR)) {
    pc_log_error_cold_1((uint64_t)__str, (int)v13);
  }
  return ParallelCompressionUpdateError(v13, (size_t)__str);
}

uint64_t pc_log_warning( uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  bzero(__s, 0x400uLL);
  uint64_t v12 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
  size_t v13 = strlen(__s);
  vsnprintf(&__s[v13], 1024 - v13, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    int v16 = v12;
    __int16 v17 = 2080;
    uint64_t v18 = __s;
    _os_log_impl(&dword_186243000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_INFO, "[0x%08x](warning) %s", buf, 0x12u);
  }

  return ParallelCompressionUpdateWarning(v12, __s);
}

void pc_log_info( uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  bzero(__s, 0x400uLL);
  size_t v12 = strlen(__s);
  vsnprintf(&__s[v12], 1024 - v12, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    unsigned int v14 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
    __int16 v15 = 2080;
    int v16 = __s;
    _os_log_impl(&dword_186243000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_INFO, "[0x%08x] %s", buf, 0x12u);
  }

void *AAChunkOutputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int DefaultNThreads = a4;
  if (!a4) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v8 = calloc(1uLL, 0x68uLL);
  unint64_t v9 = malloc(0x108uLL);
  uint64_t v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x108uLL, 0, 0x108uLL), !v8))
  {
    int v19 = *__error();
    char v22 = "malloc";
    __int16 v23 = 425;
    goto LABEL_15;
  }

  *(void *)uint64_t v10 = a1;
  *(void *)(v10 + 8) = a2;
  *(void *)(v10 + 16) = a3;
  *(void *)(v10 + 24) = DefaultNThreads;
  if (!is_mul_ok(DefaultNThreads, 0x98uLL) || (unint64_t)(152LL * DefaultNThreads) >= 0x2000000001LL)
  {
    *__error() = 12;
    *(void *)(v10 + 32) = 0LL;
    goto LABEL_14;
  }

  uint64_t v11 = calloc(DefaultNThreads, 0x98uLL);
  *(void *)(v10 + 32) = v11;
  if (!v11)
  {
LABEL_14:
    int v19 = *__error();
    char v22 = "malloc";
    __int16 v23 = 433;
    goto LABEL_15;
  }

  if ((pthread_mutex_init((pthread_mutex_t *)(v10 + 176), 0LL) & 0x80000000) == 0)
  {
    uint64_t v12 = *(void *)(v10 + 24);
    *(_DWORD *)(v10 + 40) = 0;
    *(_DWORD *)(v10 + 44) = v12;
    size_t v13 = calloc(v12, 4uLL);
    *(void *)(v10 + 48) = v13;
    if (v13)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v10 + 56), 0LL))
      {
        __int16 v17 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v18 = 56;
      }

      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v10 + 120), 0LL))
        {
          if (!*(void *)(v10 + 24))
          {
LABEL_29:
            *uint64_t v8 = v10;
            v8[1] = streamClose_0;
            v8[7] = streamAbort_0;
            v8[5] = streamPWrite;
            return v8;
          }

          uint64_t v25 = 0LL;
          unint64_t v26 = 0LL;
          while (1)
          {
            uint64_t v27 = *(void *)(v10 + 32);
            *(_DWORD *)(v27 + v25 + 32) = 0;
            if (pthread_mutex_init((pthread_mutex_t *)(v27 + v25 + 40), 0LL)
              || pthread_cond_init((pthread_cond_t *)(v27 + v25 + 104), 0LL))
            {
              char v22 = "SemInit";
              __int16 v23 = 441;
              goto LABEL_22;
            }

            *(void *)(v27 + v25 + 8) = v10;
            ++v26;
            v25 += 152LL;
            if (v26 >= *(void *)(v10 + 24)) {
              goto LABEL_29;
            }
          }

          char v22 = "createThread";
          __int16 v23 = 443;
          goto LABEL_22;
        }

        __int16 v17 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v18 = 57;
      }
    }

    else
    {
      __int16 v17 = "SharedArrayInit: malloc failed\n";
      __int16 v18 = 55;
    }

    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayInit",  v18,  0,  v17,  v14,  v15,  v16,  v28);
    char v22 = "SharedArrayInit";
    __int16 v23 = 435;
LABEL_22:
    int v19 = 0;
    goto LABEL_15;
  }

  int v19 = *__error();
  char v22 = "pthread_mutex_init";
  __int16 v23 = 434;
LABEL_15:
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"AAChunkOutputStreamOpen",  v23,  59,  v19,  v22,  v20,  v21,  v28);
  free(v8);
  streamClose_0(v10);
  return 0LL;
}

uint64_t writerProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v36 = 678152731 * ((unint64_t)(a1 - *(void *)(v2 + 32)) >> 3);
  uint64_t v3 = (pthread_mutex_t *)(v2 + 56);
  uint64_t v33 = (pthread_cond_t *)(v2 + 120);
  uint64_t v4 = (pthread_mutex_t *)(a1 + 40);
  uint64_t v5 = (pthread_cond_t *)(a1 + 104);
  uint64_t v6 = (unsigned int *)(v2 + 168);
  int v7 = 1;
  while (1)
  {
LABEL_2:
    if (!pthread_mutex_lock(v3))
    {
      uint64_t v15 = v3;
      uint64_t v16 = *(unsigned int *)(v2 + 40);
      unsigned int v17 = *(_DWORD *)(v2 + 44);
      int v18 = v16;
      if (v16 < v17)
      {
        *(_DWORD *)(*(void *)(v2 + 48) + 4 * v16) = v36;
        int v18 = *(_DWORD *)(v2 + 40);
      }

      *(_DWORD *)(v2 + 40) = v18 + 1;
      if (v18 || !pthread_cond_broadcast(v33))
      {
        if (!pthread_mutex_unlock(v15))
        {
          BOOL v31 = v16 >= v17;
          uint64_t v3 = v15;
          if (!v31) {
            goto LABEL_14;
          }
          __int16 v11 = 125;
          uint64_t v12 = "SharedArrayPush: stack is full\n";
          goto LABEL_4;
        }

        __int16 v19 = 124;
        uint64_t v20 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      }

      else
      {
        __int16 v19 = 122;
        uint64_t v20 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      }

      pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPush",  v19,  0,  v20,  v8,  v9,  v10,  (char)v33);
      uint64_t v3 = v15;
      goto LABEL_13;
    }

    __int16 v11 = 117;
    uint64_t v12 = "SharedArrayPush: pthread_mutex_lock failed\n";
LABEL_4:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPush",  v11,  0,  v12,  v8,  v9,  v10,  (char)v33);
LABEL_13:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"writerProc",  210,  59,  0,  "SharedArrayPush",  v13,  v14,  v34);
    int v7 = 0;
LABEL_14:
    if (pthread_mutex_lock(v4)) {
      goto LABEL_19;
    }
    while (1)
    {
      int v23 = *(_DWORD *)(a1 + 32);
      if (v23 > 0) {
        break;
      }
      if (pthread_cond_wait(v5, v4)) {
        goto LABEL_19;
      }
    }

    *(_DWORD *)(a1 + 32) = v23 - 1;
    if (pthread_mutex_unlock(v4))
    {
LABEL_19:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"writerProc",  212,  59,  0,  "SemAcquire",  v21,  v22,  (char)v33);
      int v7 = 0;
    }

    uint64_t v24 = *(void *)(a1 + 16);
    if (!v24) {
      return a1;
    }
    if (!atomic_load((unsigned int *)(v24 + 48)))
    {
      __int16 v26 = 186;
      uint64_t v27 = "Invalid state";
      goto LABEL_29;
    }

    if (*(void *)(v24 + 32))
    {
      __int16 v26 = 187;
      uint64_t v27 = "Chunk still has holes";
LABEL_29:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkWriteToStream",  v26,  59,  0,  v27,  v21,  v22,  (char)v33);
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"writerProc",  214,  59,  0,  "Write to stream",  v28,  v29,  v35);
      goto LABEL_30;
    }

    if (AAByteStreamPWrite(*(AAByteStream *)v2, *(const void **)v24, *(void *)(v24 + 16), *(void *)(a1 + 24)) != *(void *)(v24 + 16))
    {
      __int16 v26 = 189;
      uint64_t v27 = "Chunk write failed";
      goto LABEL_29;
    }

    free(*(void **)v24);
    *(void *)uint64_t v24 = 0LL;
    *(void *)(v24 + 8) = 0LL;
    *(void *)(v24 + 16) = 0LL;
    free(*(void **)(v24 + 40));
    *(void *)(v24 + 24) = 0LL;
    *(void *)(v24 + 32) = 0LL;
    *(void *)(v24 + 40) = 0LL;
    if (!v7)
    {
LABEL_30:
      while (!__ldaxr(v6))
      {
        if (!__stlxr(1u, v6))
        {
          AAByteStreamCancel(*(AAByteStream *)v2);
          int v7 = 0;
          goto LABEL_2;
        }
      }

      int v7 = 0;
      __clrex();
    }
  }

uint64_t streamClose_0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = *(void *)(result + 248);
    if (v2)
    {
      unint64_t v3 = 0LL;
      int v4 = 1;
      do
      {
        uint64_t v5 = *(void *)(*(void *)(v1 + 256) + 8 * v3);
        uint64_t v6 = *(void *)(v1 + 8);
        int v7 = (unsigned int *)(v5 + 48);
        do
        {
          if (__ldaxr(v7))
          {
            __clrex();
            goto LABEL_10;
          }
        }

        while (__stlxr(1u, v7));
        if ((streamEnqueueWriteChunkToStream(v1, v5, v6 * v3) & 0x80000000) != 0)
        {
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamClose",  336,  59,  0,  "enqueue chunk write",  v9,  v10,  v38);
          int v4 = 0;
        }

void streamAbort_0(AAByteStream *a1)
{
  uint64_t v1 = (unsigned int *)(a1 + 21);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
    {
      AAByteStreamCancel(*a1);
      return;
    }
  }

  __clrex();
}

uint64_t streamPWrite(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  unint64_t v7 = a4;
  unint64_t v9 = a4 + a3;
  if (a4 + a3 <= a4)
  {
    unint64_t v11 = -1LL;
    goto LABEL_86;
  }

  char v97 = a1 - 88;
  __int128 v105 = (pthread_mutex_t *)(a1 + 176);
  uint64_t v103 = (unint64_t *)(a1 + 240);
  unint64_t v100 = a4 + a3;
  unint64_t v101 = *(void *)(a1 + 8);
  unint64_t v11 = -1LL;
  do
  {
    unint64_t v12 = v7 / v101;
    unint64_t v13 = v7 / v101 * v101;
    if (v13 <= v7) {
      unint64_t v14 = v7;
    }
    else {
      unint64_t v14 = v7 / v101 * v101;
    }
    if (v9 >= v13 + v101) {
      unint64_t v15 = v13 + v101;
    }
    else {
      unint64_t v15 = v9;
    }
    if (pthread_mutex_lock(v105) < 0)
    {
      int v88 = *__error();
      double v91 = "pthread_mutex_lock";
      __int16 v92 = 262;
      goto LABEL_103;
    }

    size_t __n = v15 - v14;
    unint64_t v22 = *v103;
    if (*v103 <= v12)
    {
      do
      {
        if (v22) {
          v22 *= 2LL;
        }
        else {
          unint64_t v22 = 16LL;
        }
      }

      while (v22 <= v12);
      *(void *)(a1 + 240) = v22;
      if (8 * v22 >= 0x2000000001LL)
      {
        *__error() = 12;
LABEL_44:
        *(void *)(a1 + 256) = 0LL;
        int v48 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamWriteChunkData",  272,  59,  *v48,  "malloc",  v49,  v50,  v97);
        char v47 = 0;
        unint64_t v43 = v15 - v14;
        unint64_t *v103 = 0LL;
        v103[1] = 0LL;
        goto LABEL_68;
      }

      uint64_t v23 = a2;
      unsigned int v24 = *(void **)(a1 + 256);
      uint64_t v25 = realloc(v24, 8 * v22);
      if (!v25)
      {
        free(v24);
        a2 = v23;
        goto LABEL_44;
      }

      *(void *)(a1 + 256) = v25;
      a2 = v23;
    }

    __srCC_SHA1_CTX c = a2;
    unint64_t v26 = *(void *)(a1 + 248);
    while (1)
    {
      if (v26 > v12)
      {
        unint64_t v38 = v14 - v13;
        uint64_t v39 = *(void *)(*(void *)(a1 + 256) + 8 * v12);
        unint64_t v40 = *(void *)(v39 + 16);
        uint64_t v42 = v14 - v13 - v40;
        BOOL v41 = v14 - v13 > v40;
        a2 = __src;
        unint64_t v43 = v15 - v14;
        if (v41)
        {
          if ((chunkAppendHole(*(void *)(*(void *)(a1 + 256) + 8 * v12), v42, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            __int16 v58 = 301;
            uint64_t v59 = "Hole append";
LABEL_67:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamWriteChunkData",  v58,  59,  0,  v59,  v20,  v21,  v97);
            char v47 = 0;
            goto LABEL_68;
          }

          unint64_t v40 = *(void *)(v39 + 16);
        }

        if (v40 == v38)
        {
          if (v15 != v14)
          {
            if (atomic_load((unsigned int *)(v39 + 48)))
            {
              __int16 v45 = 104;
              uint64_t v46 = "Chunk has already been written";
LABEL_55:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkAppendData",  v45,  59,  0,  v46,  v20,  v21,  v97);
              __int16 v58 = 308;
              uint64_t v59 = "Data append";
              goto LABEL_67;
            }

            uint64_t v60 = *(void *)(v39 + 16);
            if (v60 + __n > *(void *)(v39 + 8))
            {
              __int16 v45 = 105;
              uint64_t v46 = "Invalid data size";
              goto LABEL_55;
            }

            memcpy((void *)(*(void *)v39 + v60), __src, __n);
            *(void *)(v39 + 16) += __n;
          }

uint64_t streamEnqueueWriteChunkToStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v10 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v11 = 91;
LABEL_8:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v11,  0,  v10,  v7,  v8,  v9,  v25);
    uint64_t v17 = "SharedArrayPop";
    __int16 v18 = 226;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"streamEnqueueWriteChunkToStream",  v18,  59,  0,  v17,  v15,  v16,  v25);
    return 0xFFFFFFFFLL;
  }

  while (1)
  {
    int v12 = *(_DWORD *)(a1 + 40);
    if (v12) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v6))
    {
      uint64_t v10 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v11 = 94;
      goto LABEL_8;
    }
  }

  unsigned int v13 = v12 - 1;
  *(_DWORD *)(a1 + 40) = v13;
  unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 48) + 4LL * v13);
  if (pthread_mutex_unlock(v6))
  {
    uint64_t v10 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v11 = 98;
    goto LABEL_8;
  }

  uint64_t v20 = *(void *)(a1 + 32);
  uint64_t v21 = v20 + 152LL * v14;
  *(void *)(v21 + 16) = a2;
  *(void *)(v21 + 24) = a3;
  unint64_t v22 = (pthread_mutex_t *)(v21 + 40);
  if (pthread_mutex_lock((pthread_mutex_t *)(v21 + 40))
    || (uint64_t v23 = v20 + 152LL * v14, v24 = *(_DWORD *)(v23 + 32), *(_DWORD *)(v23 + 32) = v24 + 1, !v24)
    && pthread_cond_broadcast((pthread_cond_t *)(v20 + 152LL * v14 + 104))
    || (uint64_t result = pthread_mutex_unlock(v22), (_DWORD)result))
  {
    uint64_t v17 = "SemRelease";
    __int16 v18 = 230;
    goto LABEL_9;
  }

  return result;
}

void chunkDestroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1[5]);
    free(a1);
  }

uint64_t chunkAppendHole( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0LL;
  }
  if (atomic_load((unsigned int *)(a1 + 48)))
  {
    uint64_t v10 = "Chunk has already been written";
    __int16 v11 = 115;
LABEL_7:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkAppendHole",  v11,  59,  0,  v10,  a7,  a8,  v33);
    return 0xFFFFFFFFLL;
  }

  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = v14 + a2;
  if ((unint64_t)(v14 + a2) > *(void *)(a1 + 8))
  {
    uint64_t v10 = "Invalid hole size";
    __int16 v11 = 116;
    goto LABEL_7;
  }

  unint64_t v16 = *(void *)(a1 + 32);
  if (!v16
    || (uint64_t v17 = *(void *)(a1 + 40) + 16 * v16,
        uint64_t v19 = *(void *)(v17 - 16),
        uint64_t v20 = *(void *)(v17 - 8),
        __int16 v18 = (void *)(v17 - 16),
        v19 + v20 != v14))
  {
    unint64_t v22 = (void *)(a1 + 24);
    unint64_t v21 = *(void *)(a1 + 24);
    if (v16 < v21)
    {
      uint64_t v23 = *(char **)(a1 + 40);
LABEL_20:
      uint64_t result = 0LL;
      *(void *)(a1 + 32) = v16 + 1;
      unint64_t v29 = &v23[16 * v16];
      *(void *)unint64_t v29 = a2;
      *((void *)v29 + 1) = v14;
      goto LABEL_21;
    }

    uint64_t v24 = 2 * v21;
    BOOL v25 = v21 == 0;
    uint64_t v26 = 8LL;
    if (!v25) {
      uint64_t v26 = v24;
    }
    *(void *)(a1 + 24) = v26;
    if ((unint64_t)(16 * v26) < 0x2000000001LL)
    {
      size_t v27 = *(void **)(a1 + 40);
      uint64_t v28 = (char *)realloc(v27, 16 * v26);
      if (v28)
      {
        uint64_t v23 = v28;
        *(void *)(a1 + 40) = v28;
        unint64_t v16 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 16);
        uint64_t v15 = v14 + a2;
        goto LABEL_20;
      }

      free(v27);
    }

    else
    {
      *__error() = 12;
    }

    *(void *)(a1 + 40) = 0LL;
    uint64_t v30 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c",  (uint64_t)"chunkAppendHole",  135,  59,  *v30,  "malloc",  v31,  v32,  v33);
    void *v22 = 0LL;
    *(void *)(a1 + 32) = 0LL;
    return 0xFFFFFFFFLL;
  }

  uint64_t result = 0LL;
  *__int16 v18 = v19 + a2;
LABEL_21:
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t loadAndDecodeHeader_Cpio(uint64_t *a1, unint64_t *a2)
{
  int v4 = (int *)a1[8];
  int v5 = *v4;
  int v6 = *((unsigned __int16 *)v4 + 2);
  BOOL v8 = v5 != 925906736 || v6 != 12592;
  value.tv_seCC_SHA1_CTX c = 0LL;
  value.tv_nseCC_SHA1_CTX c = 0LL;
  uint64_t v9 = *a1;
  if (AAHeaderClear((AAHeader)a1[11]) < 0)
  {
    unint64_t v29 = "clear header";
    __int16 v30 = 67;
LABEL_116:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStreamCPIO.c",  (uint64_t)"loadAndDecodeHeader_Cpio",  v30,  113,  0,  v29,  v14,  v15,  v193);
    return 0xFFFFFFFFLL;
  }

  if (v8) {
    unint64_t v16 = 76LL;
  }
  else {
    unint64_t v16 = 110LL;
  }
  if ((decodeStreamLoadHeader(a1, v16, v10, v11, v12, v13, v14, v15) & 0x80000000) != 0)
  {
    unint64_t v29 = "truncated stream";
    __int16 v30 = 73;
    goto LABEL_116;
  }

  uint64_t v17 = a1[8];
  if (v8)
  {
    unint64_t v18 = 0LL;
    unint64_t v19 = v17 + 65;
    unint64_t v20 = v17 + 63;
    uint64_t v21 = 4LL;
    uint64_t v22 = v17 + 59;
    do
    {
      uint64_t v23 = 0LL;
      unint64_t v24 = 0LL;
      unint64_t v25 = v20;
      uint64_t v26 = v21;
      do
      {
        unint64_t v27 = *(_BYTE *)(v22 + v23++) & 7 | (8 * v24);
        unint64_t v24 = v27;
      }

      while (v23 != 4);
      unint64_t v18 = v27 + (v18 << 12);
      unint64_t v20 = v25 + 4;
      v21 += 4LL;
      v22 += 4LL;
    }

    while (v25 + 4 <= v19);
    if (v25 >= v19)
    {
      size_t v28 = v18;
    }

    else
    {
      do
      {
        size_t v28 = *(_BYTE *)(v17 + 59 + v26++) & 7 | (8 * v18);
        unint64_t v18 = v28;
      }

      while (v26 != 6);
    }
  }

  else
  {
    uint64_t v31 = 0LL;
    size_t v28 = 0LL;
    do
    {
      int v32 = *(char *)(v17 + 94 + v31);
      v28 *= 16LL;
      char v33 = v32 - 48;
      if ((v32 - 48) <= 0x36)
      {
        if (((1LL << v33) & 0x3FF) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 48;
        }

        else if (((1LL << v33) & 0x7E0000) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 55;
        }

        else if (((1LL << v33) & 0x7E000000000000LL) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 87;
        }
      }

      ++v31;
    }

    while (v31 != 8);
  }

  unint64_t v34 = 0LL;
  if (v8)
  {
    uint64_t v35 = v17 + 65;
    unint64_t v36 = v17 + 76;
    uint64_t v37 = (char *)(v17 + 73);
    do
    {
      uint64_t v38 = 0LL;
      unint64_t v39 = 0LL;
      unint64_t v40 = v37;
      do
      {
        unint64_t v41 = *(_BYTE *)(v35 + v38++) & 7 | (8 * v39);
        unint64_t v39 = v41;
      }

      while (v38 != 8);
      unint64_t v34 = v41 + (v34 << 24);
      uint64_t v37 = v40 + 8;
      v35 += 8LL;
    }

    while ((unint64_t)(v40 + 8) <= v36);
    uint64_t v42 = v40 + 4;
    if ((unint64_t)(v40 + 4) <= v36)
    {
      do
      {
        uint64_t v44 = 0LL;
        unint64_t v45 = 0LL;
        do
        {
          unint64_t v46 = v40[v44++] & 7 | (8 * v45);
          unint64_t v45 = v46;
        }

        while (v44 != 4);
        unint64_t v34 = v46 + (v34 << 12);
        unint64_t v43 = v42;
        v40 += 4;
        v42 += 4;
      }

      while ((unint64_t)v42 <= v36);
    }

    else
    {
      unint64_t v43 = v40;
    }

    if ((unint64_t)v43 >= v36)
    {
      uint64_t v49 = v34;
    }

    else
    {
      uint64_t v47 = v17 - (void)v43 + 76;
      do
      {
        char v48 = *v43++;
        uint64_t v49 = v48 & 7 | (8 * v34);
        unint64_t v34 = v49;
        --v47;
      }

      while (v47);
    }
  }

  else
  {
    uint64_t v49 = 0LL;
    do
    {
      int v50 = *(char *)(v17 + 54 + v34);
      v49 *= 16LL;
      char v51 = v50 - 48;
      if ((v50 - 48) <= 0x36)
      {
        if (((1LL << v51) & 0x3FF) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 48;
        }

        else if (((1LL << v51) & 0x7E0000) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 55;
        }

        else if (((1LL << v51) & 0x7E000000000000LL) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 87;
        }
      }

      ++v34;
    }

    while (v34 != 8);
  }

  unint64_t v52 = 0LL;
  if (v8)
  {
    unint64_t v53 = v17 + 24;
    unint64_t v54 = v17 + 22;
    uint64_t v55 = v17 + 18;
    uint64_t v56 = 4LL;
    uint64_t v57 = v55;
    do
    {
      uint64_t v58 = 0LL;
      unint64_t v59 = 0LL;
      unint64_t v60 = v54;
      uint64_t v61 = v56;
      do
      {
        unint64_t v62 = *(_BYTE *)(v57 + v58++) & 7 | (8 * v59);
        unint64_t v59 = v62;
      }

      while (v58 != 4);
      unint64_t v52 = v62 + (v52 << 12);
      unint64_t v54 = v60 + 4;
      v56 += 4LL;
      v57 += 4LL;
    }

    while (v60 + 4 <= v53);
    if (v60 >= v53)
    {
      LOWORD(v63) = v52;
    }

    else
    {
      do
      {
        unint64_t v63 = *(_BYTE *)(v55 + v61++) & 7 | (8 * v52);
        unint64_t v52 = v63;
      }

      while (v61 != 6);
    }
  }

  else
  {
    unint64_t v63 = 0LL;
    uint64_t v64 = v17 + 14;
    do
    {
      int v65 = *(char *)(v64 + v52);
      v63 *= 16LL;
      char v66 = v65 - 48;
      if ((v65 - 48) <= 0x36)
      {
        if (((1LL << v66) & 0x3FF) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 48;
        }

        else if (((1LL << v66) & 0x7E0000) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 55;
        }

        else if (((1LL << v66) & 0x7E000000000000LL) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 87;
        }
      }

      ++v52;
    }

    while (v52 != 8);
  }

  unsigned int v67 = aaEntryTypeFromMode(v63);
  if (v28 >= 0x10000)
  {
    unint64_t v29 = "invalid c_namesize";
    __int16 v30 = 82;
    goto LABEL_116;
  }

  unsigned int v72 = v67;
  if (v8) {
    unint64_t v73 = v28 + v16;
  }
  else {
    unint64_t v73 = (v28 + v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  }
  unint64_t v74 = v73;
  if (v67 == 76)
  {
    if (v49 >= 0x10000)
    {
      unint64_t v29 = "invalid c_filesize";
      __int16 v30 = 89;
      goto LABEL_116;
    }

    if (v8) {
      unint64_t v74 = v49 + v73;
    }
    else {
      unint64_t v74 = (v49 + v73 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
  }

  if ((decodeStreamLoadHeader(a1, v74, v68, v69, v70, v71, v14, v15) & 0x80000000) != 0)
  {
    unint64_t v29 = "truncated stream";
    __int16 v30 = 95;
    goto LABEL_116;
  }

  if (v72) {
    BOOL v75 = 0;
  }
  else {
    BOOL v75 = v49 == 0;
  }
  if (v75 && v28 == 11)
  {
    __int16 v92 = (uint64_t *)(a1[8] + v16);
    uint64_t v93 = *v92;
    uint64_t v94 = *(uint64_t *)((char *)v92 + 3);
    if (v93 == 0x2152454C49415254LL && v94 == 0x21212152454C49LL) {
      return 1LL;
    }
LABEL_115:
    unint64_t v29 = "invalid cpio header";
    __int16 v30 = 101;
    goto LABEL_116;
  }

  if (!v72) {
    goto LABEL_115;
  }
  uint64_t v193 = a1[8];
  v77.uint64_t ikey = 5265748;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v77, v72) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 106;
    goto LABEL_116;
  }

  v78.uint64_t ikey = 5521744;
  if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v78, (const char *)(a1[8] + v16), v28) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 109;
    goto LABEL_116;
  }

  if (v72 == 76)
  {
    v79.uint64_t ikey = 4935244;
    if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v79, (const char *)(a1[8] + v73), v49) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 114;
      goto LABEL_116;
    }
  }

  v80.uint64_t ikey = 4476749;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v80, v63 & 0xFFF) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 118;
    goto LABEL_116;
  }

  if (v8)
  {
    unint64_t v81 = 0LL;
    unint64_t v82 = v193 + 30;
    unint64_t v83 = v193 + 28;
    uint64_t v84 = 4LL;
    uint64_t v85 = v193 + 24;
    do
    {
      uint64_t v86 = 0LL;
      unint64_t v87 = 0LL;
      unint64_t v88 = v83;
      uint64_t v89 = v84;
      do
      {
        unint64_t v90 = *(_BYTE *)(v85 + v86++) & 7 | (8 * v87);
        unint64_t v87 = v90;
      }

      while (v86 != 4);
      unint64_t v81 = v90 + (v81 << 12);
      unint64_t v83 = v88 + 4;
      v84 += 4LL;
      v85 += 4LL;
    }

    while (v88 + 4 <= v82);
    if (v88 >= v82)
    {
      uint64_t v91 = v81;
    }

    else
    {
      do
      {
        uint64_t v91 = *(_BYTE *)(v193 + 24 + v89++) & 7 | (8 * v81);
        unint64_t v81 = v91;
      }

      while (v89 != 6);
    }
  }

  else
  {
    uint64_t v97 = 0LL;
    uint64_t v91 = 0LL;
    do
    {
      int v98 = *(char *)(v193 + 22 + v97);
      v91 *= 16LL;
      char v99 = v98 - 48;
      if ((v98 - 48) <= 0x36)
      {
        if (((1LL << v99) & 0x3FF) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 48;
        }

        else if (((1LL << v99) & 0x7E0000) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 55;
        }

        else if (((1LL << v99) & 0x7E000000000000LL) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 87;
        }
      }

      ++v97;
    }

    while (v97 != 8);
  }

  v100.uint64_t ikey = 4475221;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v100, v91) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 122;
    goto LABEL_116;
  }

  if (v8)
  {
    unint64_t v101 = 0LL;
    unint64_t v102 = v193 + 36;
    unint64_t v103 = v193 + 34;
    uint64_t v104 = 4LL;
    uint64_t v105 = v193 + 30;
    do
    {
      uint64_t v106 = 0LL;
      unint64_t v107 = 0LL;
      unint64_t v108 = v103;
      uint64_t v109 = v104;
      do
      {
        unint64_t v110 = *(_BYTE *)(v105 + v106++) & 7 | (8 * v107);
        unint64_t v107 = v110;
      }

      while (v106 != 4);
      unint64_t v101 = v110 + (v101 << 12);
      unint64_t v103 = v108 + 4;
      v104 += 4LL;
      v105 += 4LL;
    }

    while (v108 + 4 <= v102);
    if (v108 >= v102)
    {
      uint64_t v111 = v101;
    }

    else
    {
      do
      {
        uint64_t v111 = *(_BYTE *)(v193 + 30 + v109++) & 7 | (8 * v101);
        unint64_t v101 = v111;
      }

      while (v109 != 6);
    }
  }

  else
  {
    uint64_t v112 = 0LL;
    uint64_t v111 = 0LL;
    do
    {
      int v113 = *(char *)(v193 + 30 + v112);
      v111 *= 16LL;
      char v114 = v113 - 48;
      if ((v113 - 48) <= 0x36)
      {
        if (((1LL << v114) & 0x3FF) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 48;
        }

        else if (((1LL << v114) & 0x7E0000) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 55;
        }

        else if (((1LL << v114) & 0x7E000000000000LL) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 87;
        }
      }

      ++v112;
    }

    while (v112 != 8);
  }

  v115.uint64_t ikey = 4475207;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v115, v111) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 126;
    goto LABEL_116;
  }

  unint64_t v116 = 0LL;
  if (v8)
  {
    uint64_t v117 = v193 + 48;
    unint64_t v118 = v193 + 59;
    __int128 v119 = (char *)(v193 + 56);
    do
    {
      uint64_t v120 = 0LL;
      unint64_t v121 = 0LL;
      __int128 v122 = v119;
      do
      {
        unint64_t v123 = *(_BYTE *)(v117 + v120++) & 7 | (8 * v121);
        unint64_t v121 = v123;
      }

      while (v120 != 8);
      unint64_t v116 = v123 + (v116 << 24);
      __int128 v119 = v122 + 8;
      v117 += 8LL;
    }

    while ((unint64_t)(v122 + 8) <= v118);
    int v124 = v122 + 4;
    if ((unint64_t)(v122 + 4) <= v118)
    {
      do
      {
        uint64_t v126 = 0LL;
        unint64_t v127 = 0LL;
        do
        {
          unint64_t v128 = v122[v126++] & 7 | (8 * v127);
          unint64_t v127 = v128;
        }

        while (v126 != 4);
        unint64_t v116 = v128 + (v116 << 12);
        __int128 v125 = v124;
        v122 += 4;
        v124 += 4;
      }

      while ((unint64_t)v124 <= v118);
    }

    else
    {
      __int128 v125 = v122;
    }

    if ((unint64_t)v125 >= v118)
    {
      __darwin_time_t v131 = v116;
    }

    else
    {
      uint64_t v129 = v193 - (void)v125 + 59;
      do
      {
        char v130 = *v125++;
        __darwin_time_t v131 = v130 & 7 | (8 * v116);
        unint64_t v116 = v131;
        --v129;
      }

      while (v129);
    }
  }

  else
  {
    __darwin_time_t v131 = 0LL;
    do
    {
      int v132 = *(char *)(v193 + 46 + v116);
      v131 *= 16LL;
      char v133 = v132 - 48;
      if ((v132 - 48) <= 0x36)
      {
        if (((1LL << v133) & 0x3FF) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 48;
        }

        else if (((1LL << v133) & 0x7E0000) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 55;
        }

        else if (((1LL << v133) & 0x7E000000000000LL) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 87;
        }
      }

      ++v116;
    }

    while (v116 != 8);
  }

  value.tv_seCC_SHA1_CTX c = v131;
  value.tv_nseCC_SHA1_CTX c = 0LL;
  v134.uint64_t ikey = 5067853;
  if (AAHeaderSetFieldTimespec((AAHeader)a1[11], 0xFFFFFFFF, v134, &value) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 131;
    goto LABEL_116;
  }

  if (v8)
  {
    unint64_t v135 = 0LL;
    uint64_t v136 = v193;
    unint64_t v137 = v193 + 18;
    unint64_t v138 = v193 + 16;
    uint64_t v139 = 4LL;
    uint64_t v140 = v193 + 12;
    do
    {
      uint64_t v141 = 0LL;
      unint64_t v142 = 0LL;
      unint64_t v143 = v138;
      uint64_t v144 = v139;
      do
      {
        unint64_t v145 = *(_BYTE *)(v140 + v141++) & 7 | (8 * v142);
        unint64_t v142 = v145;
      }

      while (v141 != 4);
      unint64_t v135 = v145 + (v135 << 12);
      unint64_t v138 = v143 + 4;
      v139 += 4LL;
      v140 += 4LL;
    }

    while (v143 + 4 <= v137);
    if (v143 >= v137)
    {
      uint64_t v146 = v135;
    }

    else
    {
      do
      {
        uint64_t v146 = *(_BYTE *)(v193 + 12 + v144++) & 7 | (8 * v135);
        unint64_t v135 = v146;
      }

      while (v144 != 6);
    }
  }

  else
  {
    uint64_t v147 = 0LL;
    uint64_t v146 = 0LL;
    uint64_t v136 = v193;
    do
    {
      int v148 = *(char *)(v193 + 6 + v147);
      v146 *= 16LL;
      char v149 = v148 - 48;
      if ((v148 - 48) <= 0x36)
      {
        if (((1LL << v149) & 0x3FF) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 48;
        }

        else if (((1LL << v149) & 0x7E0000) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 55;
        }

        else if (((1LL << v149) & 0x7E000000000000LL) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 87;
        }
      }

      ++v147;
    }

    while (v147 != 8);
  }

  if (v8)
  {
    unint64_t v150 = 0LL;
    unint64_t v151 = v136 + 12;
    unint64_t v152 = v136 + 10;
    uint64_t v153 = 4LL;
    uint64_t v154 = v136 + 6;
    do
    {
      uint64_t v155 = 0LL;
      unint64_t v156 = 0LL;
      unint64_t v157 = v152;
      uint64_t v158 = v153;
      do
      {
        unint64_t v159 = *(_BYTE *)(v154 + v155++) & 7 | (8 * v156);
        unint64_t v156 = v159;
      }

      while (v155 != 4);
      unint64_t v150 = v159 + (v150 << 12);
      unint64_t v152 = v157 + 4;
      v153 += 4LL;
      v154 += 4LL;
    }

    while (v157 + 4 <= v151);
    if (v157 >= v151)
    {
      unint64_t v160 = v150;
    }

    else
    {
      do
      {
        unint64_t v160 = *(_BYTE *)(v136 + 6 + v158++) & 7 | (8 * v150);
        unint64_t v150 = v160;
      }

      while (v158 != 6);
    }

    v146 |= v160 << 18;
    v166.uint64_t ikey = 5197385;
    if ((AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v166, v146) & 0x80000000) == 0)
    {
      uint64_t v163 = 0LL;
      unint64_t v167 = v193 + 42;
      unint64_t v168 = v193 + 40;
      uint64_t v169 = 4LL;
      uint64_t v170 = v193 + 36;
      do
      {
        uint64_t v171 = 0LL;
        unint64_t v172 = 0LL;
        unint64_t v173 = v168;
        uint64_t v174 = v169;
        do
        {
          unint64_t v175 = *(_BYTE *)(v170 + v171++) & 7 | (8 * v172);
          unint64_t v172 = v175;
        }

        while (v171 != 4);
        uint64_t v163 = v175 + (v163 << 12);
        unint64_t v168 = v173 + 4;
        v169 += 4LL;
        v170 += 4LL;
      }

      while (v173 + 4 <= v167);
      if (v173 < v167)
      {
        do
          uint64_t v163 = *(_BYTE *)(v193 + 36 + v174++) & 7 | (8 * v163);
        while (v174 != 6);
      }

      goto LABEL_229;
    }

LABEL_239:
    unint64_t v29 = "creating header";
    __int16 v30 = 145;
    goto LABEL_116;
  }

  v161.uint64_t ikey = 5197385;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v161, v146) < 0) {
    goto LABEL_239;
  }
  uint64_t v162 = 0LL;
  uint64_t v163 = 0LL;
  do
  {
    int v164 = *(char *)(v193 + 38 + v162);
    v163 *= 16LL;
    char v165 = v164 - 48;
    if ((v164 - 48) <= 0x36)
    {
      if (((1LL << v165) & 0x3FF) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 48;
      }

      else if (((1LL << v165) & 0x7E0000) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 55;
      }

      else if (((1LL << v165) & 0x7E000000000000LL) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 87;
      }
    }

    ++v162;
  }

  while (v162 != 8);
LABEL_229:
  v176.uint64_t ikey = 4934734;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v176, v163) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 149;
    goto LABEL_116;
  }

  if ((v9 & 0x8000000000000LL) != 0 || v163 < 2 || v72 != 70)
  {
    BOOL v181 = 0;
    if (v8 || (v72 & 0xFFFFFFFE) != 0x42) {
      goto LABEL_263;
    }
    uint64_t v182 = 0LL;
    uint64_t v183 = 0LL;
    do
    {
      int v184 = *(char *)(v193 + 78 + v182);
      v183 *= 16LL;
      char v185 = v184 - 48;
      if ((v184 - 48) <= 0x36)
      {
        if (((1LL << v185) & 0x3FF) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 48;
        }

        else if (((1LL << v185) & 0x7E0000) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 55;
        }

        else if (((1LL << v185) & 0x7E000000000000LL) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 87;
        }
      }

      ++v182;
    }

    while (v182 != 8);
    uint64_t v186 = 0LL;
    uint64_t v187 = 0LL;
    do
    {
      int v188 = *(char *)(v193 + 86 + v186);
      v187 *= 16LL;
      char v189 = v188 - 48;
      if ((v188 - 48) <= 0x36)
      {
        if (((1LL << v189) & 0x3FF) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 48;
        }

        else if (((1LL << v189) & 0x7E0000) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 55;
        }

        else if (((1LL << v189) & 0x7E000000000000LL) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 87;
        }
      }

      ++v186;
    }

    while (v186 != 8);
    v190.uint64_t ikey = 5653828;
    if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v190, v187 + (v183 << 24)) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 173;
      goto LABEL_116;
    }

        unsigned int v72 = v208 == v346;
        uint64_t v26 = v352;
        if (!v72)
        {
LABEL_279:
          unint64_t v213 = 544;
          uint64_t v214 = "invalid entry";
LABEL_228:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  v213,  120,  0,  v214,  v197,  v198,  v340);
          char v189 = 0LL;
          goto LABEL_229;
        }

        uint64_t v9 = v360;
        if ((aaHeaderInitWithEncodedData((uint64_t)v32, *(unsigned __int16 **)(v360 + 32), v346) & 0x80000000) != 0)
        {
          uint64_t v245 = 545;
          BOOL v246 = "invalid header";
LABEL_294:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  v245,  120,  0,  v246,  v220,  v221,  v340);
          char v189 = 0LL;
          goto LABEL_204;
        }

        uint64_t v222 = *v176;
        if (*v176 == 70)
        {
          v223.uint64_t ikey = 5521732;
          uint32_t KeyIndex = AAHeaderGetKeyIndex(v32, v223);
          if ((KeyIndex & 0x80000000) != 0)
          {
            unint64_t v173 = v354;
            if (*(void *)(v353 + 72 * v354 + 16) != -1LL
              || *(void *)(v353 + 72 * v354 + 24) != -1LL
              || *(void *)(v353 + 72 * v354 + 32) != -1LL)
            {
              goto LABEL_359;
            }

            uint64_t v211 = 553;
            int v212 = "DAT field is required";
LABEL_223:
            pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c",  (uint64_t)"workerCreateEntries",  v211,  120,  0,  v212,  v190,  v191,  v340);
            char v189 = 0LL;
LABEL_230:
            AAByteStreamClose(v189);
            goto LABEL_231;
          }

          if (AAHeaderGetFieldBlob(v32, KeyIndex, &v375, &v365) < 0)
          {
            uint64_t v245 = 549;
            BOOL v246 = "getting DAT field";
            goto LABEL_294;
          }

          __int16 v227 = *(void *)(v353 + 72 * v354 + 16);
          if (v227 != -1LL
            && !stateShouldCreateFileInCluster(v352, 0, v227, v354, v225, v226, v220, v221)
            || (uint64_t v228 = *(void *)(v353 + 72 * v354 + 24), v228 != -1LL)
            && !stateShouldCreateFileInCluster(v352, 1u, v228, v354, v225, v226, v220, v221)
            || (uint64_t v229 = *(void *)(v353 + 72 * v354 + 32), v229 != -1LL)
            && !stateShouldCreateFileInCluster(v352, 2u, v229, v354, v225, v226, v220, v221))
          {
            AAByteStreamClose(0LL);
            v347 = *(void **)(*(void *)(v352 + 1160) + 8 * v31);
            unsigned int EncodedSize = AAHeaderGetEncodedSize(v32);
            BOOL v247 = AAHeaderClone(v32);
            v248.uint64_t ikey = 5521732;
            uint64_t v249 = AAHeaderGetKeyIndex(v247, v248);
            if ((v249 & 0x80000000) == 0 && AAHeaderRemoveField(v247, v249) < 0)
            {
              uint64_t v254 = 293;
              __int16 v255 = "removing DAT field";
              goto LABEL_415;
            }

            key = v249;
            char v252 = AAHeaderGetEncodedSize(v247);
            PayloadSize = AAHeaderGetPayloadSize(v247);
            size_t __n = v252 + PayloadSize;
            if (__CFADD__(v252, PayloadSize))
            {
              uint64_t v254 = 298;
              __int16 v255 = "entry too large to defer";
              goto LABEL_415;
            }

            v288 = v252;
            unint64_t v289 = workerReserve((uint64_t)v347, __n);
            if (v289 < 0)
            {
              uint64_t v254 = 301;
              __int16 v255 = "allocating worker buf";
              goto LABEL_415;
            }

            unint64_t v290 = (void *)v347[4];
            EncodedData = AAHeaderGetEncodedData(v247);
            memcpy(v290, EncodedData, v252);
            uint32_t FieldCount = AAHeaderGetFieldCount(v351);
            if (FieldCount)
            {
              uint64_t v292 = 0;
              do
              {
                int FieldType = AAHeaderGetFieldType(v351, v292);
                uint64_t v294 = v292;
                uint64_t v295 = v292 != key || key <= -1;
                if (v295 && FieldType == 5)
                {
                  uint64_t offset = 0LL;
                  size[0] = 0LL;
                  if (AAHeaderGetFieldBlob(v351, v292, size, &offset) < 0)
                  {
                    uint64_t v254 = 313;
                    __int16 v255 = "getting blob field";
                    goto LABEL_415;
                  }

                  unint64_t v296 = size[0];
                  unint64_t v297 = *(void *)headera + EncodedSize + offset;
                  uint64_t offset = v297;
                  if (size[0] + v288 > v347[5])
                  {
                    uint64_t v254 = 315;
                    __int16 v255 = "invalid blob size";
                    goto LABEL_415;
                  }

                  uint64_t v298 = *(void *)v352;
                  if (!*(void *)(*(void *)v352 + 32LL)) {
                    goto LABEL_368;
                  }
                  v299 = 0LL;
                  if (size[0])
                  {
                    uint64_t v300 = v347[4] + v288;
                    do
                    {
                      v301 = (*(uint64_t (**)(void, size_t, uint64_t, uint64_t))(v298 + 32))( *(void *)v298,  v300,  v296,  v297);
                      if (v301 < 0) {
                        goto LABEL_368;
                      }
                      if (!v301) {
                        break;
                      }
                      v300 += v301;
                      v299 += v301;
                      v297 += v301;
                      v296 -= v301;
                    }

                    while (v296);
                    if (v299 < 0 || v299 != size[0])
                    {
LABEL_368:
                      uint64_t v254 = 319;
                      __int16 v255 = "reading blob";
                      goto LABEL_415;
                    }
                  }

                  v288 += v299;
                }

                uint64_t v292 = v294 + 1;
              }

              while (v294 + 1 != FieldCount);
            }

            if (v288 != __n)
            {
              uint64_t v254 = 322;
              __int16 v255 = "entry size mismatch";
              goto LABEL_415;
            }

            v302 = v347[264];
            unint64_t v152 = __CFADD__(v302, __n);
            int64x2_t v303 = v302 + __n;
            if (!v152 && (v303 & 0x8000000000000000LL) == 0)
            {
              v304 = v347 + 264;
              int v305 = (const void *)v347[4];
              v306 = v347[265];
              if (v306 >= v303)
              {
LABEL_396:
                v329 = v347[266];
                if (v305)
                {
                  memcpy((void *)(v329 + *v304), v305, __n);
                }

                else if (v329)
                {
                  memset_s((void *)(v329 + *v304), __n, 0, __n);
                }

                v332 = v353 + 72 * v354;
                v333 = *v304;
                *(void *)(v332 + 40) = *v304;
                *(void *)(v332 + 48) = __n;
                AAByteStream_impl *v304 = v333 + __n;
                if ((__n & 0x8000000000000000LL) == 0)
                {
                  unint64_t v173 = v354;
                  *(_DWORD *)(v353 + 72 * v354 + 56) = v31;
                  AAHeaderDestroy(v247);
                  uint64_t v9 = v360;
                  int v32 = v351;
                  uint64_t v26 = v352;
                  goto LABEL_236;
                }
              }

              else
              {
                do
                {
                  while (!v306)
                  {
                    v306 = 0x4000LL;
                    if (v303 <= 0x4000)
                    {
                      v308 = (void **)(v347 + 266);
                      v306 = 0x4000LL;
                      goto LABEL_394;
                    }
                  }

                  AAByteStream v307 = v306 >> 1;
                  if ((v306 & (v306 >> 1)) != 0) {
                    AAByteStream v307 = v306 & (v306 >> 1);
                  }
                  v306 += v307;
                }

                while (v306 < v303);
                v308 = (void **)(v347 + 266);
                if (v306 >= 0x2000000001LL)
                {
                  *__error() = 12;
                  goto LABEL_413;
                }

LABEL_262:
    BOOL v181 = 0;
    goto LABEL_263;
  }

  int v194 = 0;
  uint64_t v179 = decodeStreamHLCFromINO(a1, v146, v163, &v194, v177, v178, v14, v15);
  if (v179 == -1LL)
  {
    unint64_t v29 = "too many hard links or inconsistent nlink/ino data in archive";
    __int16 v30 = 156;
    goto LABEL_116;
  }

  v180.uint64_t ikey = 4410440;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v180, v179) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 157;
    goto LABEL_116;
  }

  if (v8) {
    goto LABEL_262;
  }
  if (!v194 && v49)
  {
    unint64_t v29 = "invalid newc encoding for hard links";
    __int16 v30 = 162;
    goto LABEL_116;
  }

  BOOL v181 = v194 == 0;
LABEL_263:
  if (v72 != 70 || v181)
  {
    if (v72 != 70)
    {
      uint64_t result = 0LL;
      *a2 = 0LL;
      return result;
    }
  }

  else
  {
    v191.uint64_t ikey = 5521732;
    if (AAHeaderSetFieldBlob((AAHeader)a1[11], 0xFFFFFFFF, v191, v49) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 179;
      goto LABEL_116;
    }
  }

  uint64_t result = 0LL;
  unint64_t v192 = (v49 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v8) {
    unint64_t v192 = v49;
  }
  *a2 = v192;
  return result;
}

uint64_t getBXDiffControls( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int8x16_t **a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8 = 0xFFFFFFFFLL;
  if (!a2 || !a4) {
    return v8;
  }
  uint64_t v10 = (void *)a6;
  if (a2 >= a4) {
    unint64_t v13 = a4;
  }
  else {
    unint64_t v13 = a2;
  }
  if (v13 >= 0x10000)
  {
    unint64_t v14 = a2 - a4;
    if (a2 < a4) {
      unint64_t v14 = a4 - a2;
    }
    uint64_t v15 = (unsigned __int8 *)a1;
    unint64_t v16 = (unsigned __int8 *)a3;
    do
    {
      int v18 = *v15++;
      int v17 = v18;
      int v19 = *v16++;
      if (v17 != v19) {
        ++v14;
      }
      --v13;
    }

    while (v13);
    if (v14 <= a4 / 0x64)
    {
      uint64_t v97 = (int8x16_t *)calloc(1uLL, 0x18uLL);
      if (v97)
      {
        *a5 = v97;
        void *v10 = 1LL;
        if (a2 <= a4)
        {
          uint64_t v8 = 0LL;
          v102.i64[0] = a2;
          v102.i64[1] = a4 - a2;
          *uint64_t v97 = vbslq_s8( (int8x16_t)vcltzq_s64(v102),  (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000LL), v102),  (int8x16_t)v102);
          v97[1].i64[0] = 0LL;
        }

        else
        {
          uint64_t v8 = 0LL;
          unint64_t v98 = 0x8000000000000000LL - a4;
          v97->i64[1] = 0LL;
          v97[1].i64[0] = 0LL;
          if ((a4 & 0x8000000000000000LL) == 0LL) {
            unint64_t v98 = a4;
          }
          v97->i64[0] = v98;
        }

        return v8;
      }

      char v99 = __error();
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c",  (uint64_t)"bxdiffFastPathControls",  101,  24,  *v99,  "calloc",  v100,  v101,  v106);
      uint64_t v95 = "building fast path controls";
      __int16 v96 = 311;
LABEL_121:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c",  (uint64_t)"getBXDiffControls",  v96,  24,  0,  v95,  v21,  v22,  v106);
      return 0xFFFFFFFFLL;
    }
  }

  uint64_t v20 = BXDiffMatchesCreate(a1, a2, a3, a4, a7, a6, (uint64_t)a7, a8);
  if (!v20)
  {
    uint64_t v95 = "creating diff match lookup object";
    __int16 v96 = 319;
    goto LABEL_121;
  }

  uint64_t v23 = (void **)v20;
  uint64_t v24 = BXDiffMatchesIBuf(v20);
  uint64_t v25 = BXDiffMatchesISize((uint64_t)v23);
  uint64_t v26 = BXDiffMatchesOBuf((uint64_t)v23);
  uint64_t v27 = BXDiffMatchesOSize((uint64_t)v23);
  size_t v28 = 0LL;
  uint64_t v118 = 0LL;
  if (!v25 || !v27) {
    goto LABEL_126;
  }
  if (v27 < 1)
  {
    unint64_t v34 = 0LL;
    uint64_t v94 = 0LL;
    goto LABEL_123;
  }

  uint64_t v116 = (uint64_t)v23;
  unint64_t v107 = v10;
  unint64_t v108 = a5;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  unint64_t v34 = 0LL;
  __ptr = 0LL;
  unint64_t v35 = 0LL;
  uint64_t v36 = v27;
  int v109 = 1;
  int64x2_t v110 = vdupq_n_s64(0x8000000000000000LL);
  uint64_t v117 = v27;
  do
  {
    uint64_t v114 = v32;
    unint64_t v115 = v35;
    v29 += v30;
    BOOL v113 = v29 < v27;
    if (v29 < v27)
    {
      unint64_t v111 = v34;
      uint64_t v45 = 0LL;
      uint64_t v37 = v29;
      do
      {
        uint64_t BestMatch = BXDiffMatchesGetBestMatch(v116, v29, &v118);
        uint64_t v39 = BestMatch + v29;
        if (BestMatch + v29 <= v36) {
          uint64_t v30 = BestMatch;
        }
        else {
          uint64_t v30 = v36 - v29;
        }
        if (v37 >= v30 + v29)
        {
          uint64_t v27 = v117;
        }

        else
        {
          if (v39 >= v36) {
            uint64_t v39 = v36;
          }
          unint64_t v40 = (unsigned __int8 *)(v26 + v37);
          uint64_t v41 = v39 - v37;
          uint64_t v42 = v33 + v37;
          uint64_t v27 = v117;
          do
          {
            ++v40;
            ++v42;
            --v41;
          }

          while (v41);
          uint64_t v37 = v39;
        }

        BOOL v43 = v30 != v45 || v30 == 0;
        if (!v43 || v30 > v45 + 8)
        {
          unint64_t v34 = v111;
          goto LABEL_47;
        }

        if (v29 + v33 < v25) {
          v45 -= *(unsigned __int8 *)(v24 + v29 + v33) == *(unsigned __int8 *)(v26 + v29);
        }
        ++v29;
      }

      while (v29 < v27);
      BOOL v113 = 0;
      uint64_t v29 = v27;
      unint64_t v34 = v111;
    }

    else
    {
      uint64_t v45 = 0LL;
LABEL_47:
      if (v30 == v45 && v29 != v27)
      {
        uint64_t v30 = v45;
        uint64_t v32 = v114;
        unint64_t v35 = v115;
        continue;
      }
    }

    uint64_t v46 = v29 - v31;
    uint64_t v47 = v25 - v114;
    if (v29 - v31 < v25 - v114) {
      uint64_t v47 = v29 - v31;
    }
    if (v47 < 1)
    {
      uint64_t v52 = 0LL;
    }

    else
    {
      uint64_t v48 = 0LL;
      int v49 = 0;
      unsigned __int8 v50 = 0;
      unint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      do
      {
        unint64_t v53 = v50 | (v51 << 8);
        unsigned __int8 v54 = *(_BYTE *)(v24 + v48 + v114) - *(_BYTE *)(v26 + v48 + v31);
        else {
          int v56 = 4;
        }
        BOOL v57 = __OFADD__(v56, v49);
        int v58 = v56 + v49;
        if ((v58 < 0) ^ v57 | (v58 == 0)) {
          uint64_t v59 = v52;
        }
        else {
          uint64_t v59 = v48 + 1;
        }
        int v60 = v58 & (v58 >> 31);
        v49 -= 4;
        ++v48;
        if (!v54)
        {
          uint64_t v52 = v59;
          int v49 = v60;
        }

        unint64_t v51 = v53;
        unsigned __int8 v50 = v54;
      }

      while (v48 != v47);
    }

    if (!v113) {
      goto LABEL_86;
    }
    if (v46 >= v118) {
      uint64_t v46 = v118;
    }
    if (v46 >= 1)
    {
      uint64_t v61 = 0LL;
      int v62 = 0;
      unsigned __int8 v63 = 0;
      unint64_t v64 = 0LL;
      uint64_t v65 = 0LL;
      char v66 = (char *)(v26 - 1 + v29);
      unsigned int v67 = (char *)(v24 - 1 + v118);
      do
      {
        ++v61;
        unint64_t v68 = v63 | (v64 << 8);
        BOOL v43 = (v64 & 0xFF000000FF0000LL) == 0;
        char v70 = *v67--;
        char v69 = v70;
        char v71 = *v66--;
        unsigned __int8 v72 = v69 - v71;
        else {
          int v74 = 4;
        }
        BOOL v57 = __OFADD__(v74, v62);
        int v75 = v74 + v62;
        if ((v75 < 0) ^ v57 | (v75 == 0)) {
          uint64_t v76 = v65;
        }
        else {
          uint64_t v76 = v61;
        }
        int v77 = v75 & (v75 >> 31);
        v62 -= 4;
        if (!v72)
        {
          uint64_t v65 = v76;
          int v62 = v77;
        }

        unint64_t v64 = v68;
        unsigned __int8 v63 = v72;
      }

      while (v46 != v61);
    }

    else
    {
LABEL_86:
      uint64_t v65 = 0LL;
    }

    uint64_t v78 = v52 + v31 - (v29 - v65);
    if (v52 + v31 > v29 - v65)
    {
      if (v78 < 1)
      {
        uint64_t v81 = 0LL;
      }

      else
      {
        uint64_t v79 = 0LL;
        uint64_t v80 = 0LL;
        uint64_t v81 = 0LL;
        do
        {
          int v82 = *(unsigned __int8 *)(v26 + v80 + v29 - v65);
          v79 -= v82 == *(unsigned __int8 *)(v24 + v118 - v65 + v80);
          int v83 = *(unsigned __int8 *)(v24 + v114 - (v31 - (v29 - v65)) + v80);
          if (v79 >= 0) {
            uint64_t v84 = v80 + 1;
          }
          else {
            uint64_t v84 = v81;
          }
          if (v79 < 0) {
            uint64_t v85 = v79 + 1;
          }
          else {
            uint64_t v85 = 0LL;
          }
          ++v80;
          if (v82 == v83)
          {
            uint64_t v81 = v84;
            uint64_t v79 = v85;
          }
        }

        while (v80 < v78);
      }

      uint64_t v52 = v29 - v65 - v31 + v81;
      v65 -= v81;
    }

    unint64_t v86 = v115;
    if (v34 >= v115)
    {
      v115 += 0x40000LL;
      __ptr = (int8x16_t *)reallocf(__ptr, 24 * (v86 + 0x40000));
      if (!__ptr)
      {
        unint64_t v87 = __error();
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c",  (uint64_t)"bxdiffControlsWithMatches",  255,  24,  *v87,  "malloc",  v88,  v89,  v106);
        __ptr = 0LL;
        int v109 = 0;
      }

      uint64_t v27 = v117;
    }

    uint64_t v90 = v52 + v31;
    uint64_t v31 = v29 - v65;
    v91.i64[0] = v52;
    v91.i64[1] = v29 - v65 - v90;
    __int16 v92 = (int8x16_t *)((char *)__ptr + 24 * v34);
    *__int16 v92 = vbslq_s8((int8x16_t)vcltzq_s64(v91), (int8x16_t)vsubq_s64(v110, v91), (int8x16_t)v91);
    uint64_t v93 = v118 - (v52 + v114 + v65);
    if (v93 < 0) {
      uint64_t v93 = 0x8000000000000000LL - v93;
    }
    v92[1].i64[0] = v93;
    ++v34;
    uint64_t v32 = v118 - v65;
    uint64_t v33 = v118 - v29;
    unint64_t v35 = v115;
  }

  while (v29 < v27);
  uint64_t v10 = v107;
  a5 = v108;
  if (!v109)
  {
    uint64_t v23 = (void **)v116;
    size_t v28 = __ptr;
LABEL_126:
    free(v28);
    *a5 = 0LL;
    void *v10 = 0LL;
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c",  (uint64_t)"getBXDiffControls",  324,  24,  0,  "building diff controls",  v103,  v104,  v106);
    goto LABEL_127;
  }

  uint64_t v94 = __ptr;
  if (__ptr) {
    uint64_t v94 = (int8x16_t *)reallocToFit(__ptr, 24 * v34);
  }
  uint64_t v23 = (void **)v116;
LABEL_123:
  *a5 = v94;
  void *v10 = v34;
LABEL_127:
  BXDiffMatchesDestroy(v23);
  if (*a5) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aaEntryYFPBlobInitWithPath(void *a1, char *a2, const char *a3)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  v55[0] = 0LL;
  v55[1] = 0LL;
  int v6 = (unsigned __int8 *)malloc(0x40000uLL);
  if (!v6)
  {
    int v26 = *__error();
    uint64_t v27 = "malloc";
    __int16 v28 = 43;
LABEL_28:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c",  (uint64_t)"aaEntryYFPBlobInitWithPath",  v28,  124,  v26,  v27,  v7,  v8,  v52);
    uint64_t v29 = 0LL;
    int v10 = -1;
LABEL_29:
    uint64_t v30 = 0xFFFFFFFFLL;
    goto LABEL_30;
  }

  if ((concatPath(v56, 0x800uLL, a2, a3) & 0x80000000) != 0)
  {
    char v52 = (char)a2;
    uint64_t v27 = "invalid path %s/%s";
    __int16 v28 = 46;
    int v26 = 0;
    goto LABEL_28;
  }

  int v9 = open(v56, 0x200000);
  int v10 = v9;
  if (v9 < 0)
  {
    uint64_t v32 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c",  (uint64_t)"aaEntryYFPBlobInitWithPath",  50,  124,  *v32,  "open: %s",  v33,  v34,  (char)v56);
    uint64_t v29 = 0LL;
    goto LABEL_29;
  }

  ssize_t v11 = read(v9, v6, 0x40000uLL);
  if (v11 < 0)
  {
    uint64_t v15 = 0LL;
LABEL_35:
    uint64_t v29 = v15;
    unint64_t v35 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c",  (uint64_t)"aaEntryYFPBlobInitWithPath",  56,  124,  *v35,  "read: %s",  v36,  v37,  (char)v56);
    goto LABEL_29;
  }

  ssize_t v12 = v11;
  unint64_t v13 = 0LL;
  size_t v14 = 0LL;
  uint64_t v15 = 0LL;
  unint64_t v16 = 0LL;
  unsigned int v17 = 0;
  unsigned __int8 v54 = v6;
  int v53 = v10;
  while (2)
  {
    if (v12)
    {
      for (uint64_t i = 0LL; i != v12; ++i)
      {
        uint64_t v19 = v6[i];
        unint64_t v16 = v19 + 0x202000202008008DLL * v16 + 0x516929CF586FB3BFLL * *((unsigned __int8 *)v55 + v17);
        *((_BYTE *)v55 + v17) = v19;
        if (v17 == 15) {
          unsigned int v17 = 0;
        }
        else {
          ++v17;
        }
        if (v16 >> 52) {
          BOOL v20 = 1;
        }
        else {
          BOOL v20 = (_DWORD)v16 == 0;
        }
        if (!v20)
        {
          if (v14 >= v13)
          {
            if (v13) {
              v13 *= 2LL;
            }
            else {
              unint64_t v13 = 256LL;
            }
            if (4 * v13 >= 0x2000000001LL)
            {
              *__error() = 12;
LABEL_38:
              uint64_t v38 = __error();
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c",  (uint64_t)"aaEntryYFPBlobInitWithPath",  79,  124,  *v38,  "malloc",  v39,  v40,  v52);
              uint64_t v29 = 0LL;
              uint64_t v30 = 0xFFFFFFFFLL;
              int v10 = v53;
              goto LABEL_30;
            }

            uint64_t v21 = v15;
            uint64_t v22 = realloc(v15, 4 * v13);
            if (!v22)
            {
              free(v21);
              int v6 = v54;
              goto LABEL_38;
            }

            uint64_t v15 = v22;
            int v6 = v54;
          }

          *((_DWORD *)v15 + v14++) = v16;
        }
      }

      int v10 = v53;
      uint64_t v23 = v6;
      uint64_t v24 = v15;
      ssize_t v25 = read(v53, v23, 0x40000uLL);
      uint64_t v15 = v24;
      int v6 = v54;
      ssize_t v12 = v25;
      if ((v25 & 0x8000000000000000LL) == 0) {
        continue;
      }
      goto LABEL_35;
    }

    break;
  }

  uint64_t v41 = v15;
  qsort(v15, v14, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_markers);
  if (v14)
  {
    uint64_t v44 = 0LL;
    uint64_t v45 = 0LL;
    uint64_t v29 = v41;
    do
    {
      int v46 = *((_DWORD *)v41 + v44);
      if (!v45 || v46 != *((_DWORD *)v41 + v45 - 1)) {
        *((_DWORD *)v41 + v45++) = v46;
      }
      ++v44;
    }

    while (v14 != v44);
    size_t v14 = 4 * v45;
    *a1 = 0LL;
    if (4 * v45 < 0)
    {
LABEL_66:
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c",  (uint64_t)"aaEntryYFPBlobInitWithPath",  98,  124,  0,  "malloc",  v42,  v43,  v52);
      uint64_t v30 = 0xFFFFFFFFLL;
      goto LABEL_67;
    }

    size_t v47 = a1[1];
    if (v47 < v14)
    {
      do
      {
        while (!v47)
        {
          size_t v47 = 0x4000LL;
          if (v14 <= 0x4000)
          {
            size_t v47 = 0x4000LL;
            goto LABEL_62;
          }
        }

        size_t v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0) {
          size_t v48 = v47 & (v47 >> 1);
        }
        v47 += v48;
      }

      while (v47 < v14);
      if (v47 >= 0x2000000001LL)
      {
        *__error() = 12;
        goto LABEL_65;
      }

uint64_t cmp_markers(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

off_t AAByteStreamProcess(AAByteStream istream, AAByteStream ostream)
{
  int v4 = (char *)malloc(0x40000uLL);
  if (v4)
  {
    int v5 = v4;
    ssize_t v6 = AAByteStreamRead(istream, v4, 0x40000uLL);
    if ((v6 & 0x8000000000000000LL) == 0)
    {
      unint64_t v7 = v6;
      off_t v8 = 0LL;
      while (2)
      {
        if (!v7)
        {
          free(v5);
          return v8;
        }

        unint64_t v9 = 0LL;
        v8 += v7;
        do
        {
          ssize_t v10 = AAByteStreamWrite(ostream, &v5[v9], v7 - v9);
          if (v10 < 0)
          {
            AAByteStreamCancel(istream);
            unint64_t v13 = "byte stream write error";
            __int16 v14 = 40;
            goto LABEL_14;
          }

          if (!v10)
          {
            unint64_t v13 = "byte stream truncated write";
            __int16 v14 = 42;
            goto LABEL_14;
          }

          v9 += v10;
        }

        while (v9 < v7);
        unint64_t v7 = AAByteStreamRead(istream, v5, 0x40000uLL);
        if ((v7 & 0x8000000000000000LL) == 0) {
          continue;
        }
        break;
      }
    }

    AAByteStreamCancel(ostream);
    unint64_t v13 = "byte stream read error";
    __int16 v14 = 26;
LABEL_14:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c",  (uint64_t)"AAByteStreamProcess",  v14,  58,  0,  v13,  v11,  v12,  v19);
    free(v5);
  }

  else
  {
    uint64_t v15 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c",  (uint64_t)"AAByteStreamProcess",  18,  58,  *v15,  "malloc",  v16,  v17,  v19);
  }

  return -1LL;
}

void *aaAssetDecryptionStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ssize_t v6 = malloc(0x518uLL);
  unint64_t v7 = v6;
  if (!v6)
  {
    __int16 v10 = 439;
LABEL_6:
    uint64_t v11 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"aaAssetDecryptionStreamOpen",  v10,  108,  *v11,  "malloc",  v12,  v13,  v15);
    closeProc_2((uint64_t)v7);
    return 0LL;
  }

  memset_s(v6, 0x518uLL, 0, 0x518uLL);
  *unint64_t v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  off_t v8 = malloc(0x38uLL);
  if (!v8)
  {
    __int16 v10 = 446;
    goto LABEL_6;
  }

  unint64_t v9 = v8;
  memset_s(v8, 0x38uLL, 0, 0x38uLL);
  void *v9 = v7;
  v9[1] = closeProc_2;
  v9[6] = closeWithStateProc_2;
  v9[2] = cancelProc_2;
  v9[3] = writeProc_1;
  return v9;
}

uint64_t closeProc_2(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 24));
    unint64_t v3 = (void *)(result + 1200);
    free(*(void **)(result + 1216));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[155]);
    memset_s(v1 + 153, 0x18uLL, 0, 0x18uLL);
    free(v1[158]);
    memset_s(v1 + 156, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x518uLL, 0, 0x518uLL);
    free(v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t closeWithStateProc_2(uint64_t result, void *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v5 = result;
    unsigned int v6 = atomic_load((unsigned int *)(result + 24));
    BOOL v7 = v6 == 0;
    memset(v47, 0, sizeof(v47));
    __int128 v46 = 0u;
    memset(v45, 0, sizeof(v45));
    uint64_t v8 = result + 240;
    aeaMagicInit(v45, (_DWORD *)(result + 240));
    aeaRootHeaderInit((unint64_t)v45 | 0xC, v8, v9, v10, v11, v12, v13, v14);
    *(void *)((char *)&v45[3] + 12) = *(void *)(v5 + 676);
    DWORD1(v45[4]) = *(_DWORD *)(v5 + 940);
    uint64_t v17 = (uint64_t *)(v5 + 1200);
    int v18 = (uint64_t *)(v5 + 1224);
    uint64_t v19 = *(void *)(v5 + 1224);
    *((void *)&v45[4] + 1) = *(void *)(v5 + 1200);
    *(void *)&__int128 v46 = v19;
    BOOL v20 = (uint64_t *)(v5 + 1248);
    *((void *)&v46 + 1) = *(void *)(v5 + 1248);
    *(void *)&v47[0] = *(void *)(v5 + 1272);
    *(_OWORD *)((char *)v47 + 8) = *(_OWORD *)(v5 + 1280);
    *((void *)&v47[1] + 1) = *(void *)(v5 + 1296);
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v21 = 0LL;
    uint64_t v22 = v45;
    uint64_t v23 = 128LL;
    while (1)
    {
      uint64_t v24 = ((uint64_t (*)(void, _OWORD *, uint64_t))a2[3])(*a2, v22, v23);
      if (v24 < 1) {
        break;
      }
      uint64_t v22 = (_OWORD *)((char *)v22 + v24);
      v21 += v24;
      v23 -= v24;
      if (!v23)
      {
        if (v21 < 0) {
          goto LABEL_51;
        }
        goto LABEL_9;
      }
    }

    if (v24 < 0) {
      goto LABEL_51;
    }
LABEL_9:
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v25 = *(unsigned int *)(v5 + 680);
    if ((_DWORD)v25)
    {
      uint64_t v26 = 0LL;
      uint64_t v27 = v5 + 684;
      while (1)
      {
        uint64_t v28 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v27, v25);
        if (v28 < 1) {
          break;
        }
        v27 += v28;
        v26 += v28;
        v25 -= v28;
        if (!v25)
        {
          if (v26 < 0) {
            goto LABEL_51;
          }
          goto LABEL_17;
        }
      }

      if (v28 < 0) {
        goto LABEL_51;
      }
LABEL_17:
      if (!a2[3]) {
        goto LABEL_51;
      }
    }

    uint64_t v29 = *(unsigned int *)(v5 + 940);
    if ((_DWORD)v29)
    {
      uint64_t v30 = 0LL;
      uint64_t v31 = v5 + 944;
      while (1)
      {
        uint64_t v32 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v31, v29);
        if (v32 < 1) {
          break;
        }
        v31 += v32;
        v30 += v32;
        v29 -= v32;
        if (!v29)
        {
          if ((v30 & 0x8000000000000000LL) == 0) {
            goto LABEL_25;
          }
          goto LABEL_51;
        }
      }

      if (v32 < 0) {
        goto LABEL_51;
      }
    }

uint64_t writeProc_1( uint64_t result, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v174 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (unsigned int *)(result + 24);
  uint64_t v11 = result;
  int v154 = 0;
  __int128 v12 = 0uLL;
  memset(v153, 0, sizeof(v153));
  int v152 = 0;
  memset(v151, 0, sizeof(v151));
  int v150 = 0;
  memset(v149, 0, sizeof(v149));
  int v148 = 0;
  __int128 v146 = 0u;
  __int128 v147 = 0u;
  __int128 v144 = 0u;
  __int128 v145 = 0u;
  __int128 v142 = 0u;
  __int128 v143 = 0u;
  __int128 v140 = 0u;
  __int128 v141 = 0u;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  __int128 v136 = 0u;
  __int128 v137 = 0u;
  __int128 v134 = 0u;
  __int128 v135 = 0u;
  *(_OWORD *)size_t __n = 0u;
  __int128 v133 = 0u;
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v129 = 0;
  memset(v128, 0, sizeof(v128));
  int v13 = *(_DWORD *)(result + 676);
  if (v13 == 5)
  {
    uint64_t v14 = 0LL;
    uint64_t v10 = 0LL;
    goto LABEL_188;
  }

  size_t v15 = a3;
  uint64_t v10 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v17 = (size_t *)(result + 1200);
  uint64_t v126 = (unsigned int *)(result + 32);
  __int128 v122 = (_DWORD *)(result + 680);
  uint64_t v116 = result + 940;
  __dst = (char *)(result + 944);
  __int128 v119 = (void *)(result + 1248);
  int v124 = (_DWORD *)(result + 416);
  uint64_t v117 = (size_t *)(result + 1224);
  uint64_t v121 = result + 312;
  uint64_t v123 = result + 240;
  unint64_t v127 = (size_t *)(result + 1200);
  while (2)
  {
    size_t v18 = *v17;
    switch(v13)
    {
      case 0:
        if (v18 <= 0xB)
        {
          size_t v19 = 12 - v18;
          goto LABEL_68;
        }

        uint64_t v64 = *(void *)(v11 + 1216);
        int v65 = *(_DWORD *)(v64 + 8);
        *(void *)&__s[0] = *(void *)v64;
        DWORD2(__s[0]) = v65;
        if ((aeaContainerParamsInitWithMagic((int *)v123, __s, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0
          && (aeaCryptoInit((char *)v126, (unsigned int *)v123) & 0x80000000) == 0)
        {
          uint64_t result = aeaContainerOffsetsInit(v121, (unsigned int *)v123, v126);
          if ((result & 0x80000000) == 0)
          {
            int v13 = 1;
            *(_DWORD *)(v11 + 676) = 1;
            __int128 v12 = 0uLL;
            goto LABEL_125;
          }
        }

        char v106 = "invalid AEA stream";
        __int16 v107 = 125;
        goto LABEL_186;
      case 1:
        size_t v20 = *(void *)(v11 + 376);
        if (v18 < v20) {
          goto LABEL_63;
        }
        if (v18 != v20)
        {
          char v106 = "invalid state";
          __int16 v107 = 138;
          goto LABEL_186;
        }

        uint64_t v21 = *(_DWORD **)(v11 + 1216);
        uint64_t v14 = aeaContextCreateWithPrologue(v21, *v17);
        if (!v14)
        {
          char v106 = "invalid AEA prologue";
          __int16 v107 = 140;
          goto LABEL_186;
        }

        uint64_t v22 = *(uint64_t (**)(void, uint64_t))(v11 + 16);
        if (v22 && (v22(*(void *)(v11 + 8), v14) & 0x80000000) != 0)
        {
          char v106 = "user callback returned an error";
          __int16 v107 = 145;
          goto LABEL_186;
        }

        if ((aeaContextUnlock(v14, v123, v122, v153, 1, 0) & 0x80000000) != 0
          || (aeaCryptoInit((char *)v126, (unsigned int *)v123) & 0x80000000) != 0
          || (uint64_t result = aeaContainerOffsetsInit(v121, (unsigned int *)v123, v126), (result & 0x80000000) != 0))
        {
          char v106 = "unlocking AEA";
          __int16 v107 = 151;
          goto LABEL_186;
        }

        *(_OWORD *)uint64_t v14 = *(_OWORD *)v123;
        __int128 v23 = *(_OWORD *)(v123 + 16);
        __int128 v24 = *(_OWORD *)(v123 + 32);
        __int128 v25 = *(_OWORD *)(v123 + 48);
        *(void *)(v14 + 64) = *(void *)(v123 + 64);
        *(_OWORD *)(v14 + 32) = v24;
        *(_OWORD *)(v14 + 48) = v25;
        *(_OWORD *)(v14 + 16) = v23;
        uint64_t v26 = *(uint64_t (**)(void, uint64_t))(v11 + 16);
        if (v26)
        {
          uint64_t result = v26(*(void *)(v11 + 8), v14);
          if ((result & 0x80000000) != 0)
          {
            char v106 = "user callback returned an error";
            __int16 v107 = 156;
            goto LABEL_186;
          }
        }

        uint64_t v27 = *(unsigned int *)(v11 + 44);
        memcpy(__dst, (char *)v21 + *(void *)(v11 + 368), *(unsigned int *)(v11 + 44));
        *(_DWORD *)(v11 + 940) = v27;
        uint64_t result = memset_s(&__dst[v27], 256 - v27, 0, 256 - v27);
        *(void *)(v11 + 1280) = 0LL;
        *(void *)(v11 + 1200) = 0LL;
        *(_DWORD *)(v11 + 1272) = 0;
        int v13 = 2;
LABEL_124:
        *(_DWORD *)(v11 + 676) = v13;
        __int128 v12 = 0uLL;
        uint64_t v17 = v127;
        goto LABEL_125;
      case 2:
        size_t v20 = *(void *)(v11 + 408);
        if (v18 < v20) {
          goto LABEL_63;
        }
        if (v18 != v20)
        {
          char v106 = "invalid state";
          __int16 v107 = 177;
          goto LABEL_186;
        }

        uint64_t v125 = v14;
        uint64_t v28 = __src;
        size_t v29 = v15;
        uint64_t v30 = *(char **)(v11 + 1216);
        uint64_t v31 = *(void *)(v11 + 392);
        int v32 = *(_DWORD *)(v11 + 1272);
        *(_OWORD *)((char *)&__s[15] + 4) = v12;
        *(_OWORD *)((char *)&__s[13] + 8) = v12;
        *(_OWORD *)((char *)&__s[14] + 8) = v12;
        *(_OWORD *)((char *)&__s[11] + 8) = v12;
        *(_OWORD *)((char *)&__s[12] + 8) = v12;
        *(_OWORD *)((char *)&__s[9] + 8) = v12;
        *(_OWORD *)((char *)&__s[10] + 8) = v12;
        *(_OWORD *)((char *)&__s[7] + 8) = v12;
        *(_OWORD *)((char *)&__s[8] + 8) = v12;
        *(_OWORD *)((char *)&__s[5] + 8) = v12;
        *(_OWORD *)((char *)&__s[6] + 8) = v12;
        *(_OWORD *)((char *)&__s[3] + 8) = v12;
        *(_OWORD *)((char *)&__s[4] + 8) = v12;
        *(_OWORD *)((char *)&__s[1] + 8) = v12;
        *(_OWORD *)((char *)&__s[2] + 8) = v12;
        *(_OWORD *)((char *)__s + 8) = v12;
        LODWORD(v172[16]) = 0;
        v172[15] = v12;
        v172[14] = v12;
        v172[13] = v12;
        v172[12] = v12;
        v172[11] = v12;
        v172[10] = v12;
        v172[9] = v12;
        v172[8] = v12;
        v172[7] = v12;
        v172[6] = v12;
        v172[5] = v12;
        v172[4] = v12;
        v172[3] = v12;
        size_t v172[2] = v12;
        v172[1] = v12;
        v172[0] = v12;
        WORD4(__s[0]) = 19267;
        *(void *)&__s[0] = 0x5F41454100000006LL;
        uint64_t result = memset_s((char *)__s + 10, 0xFAuLL, 0, 0xFAuLL);
        uint64_t v33 = LODWORD(__s[0]);
        if (LODWORD(__s[0]) >= 0xFD) {
          goto LABEL_224;
        }
        *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v32;
        LODWORD(__s[0]) = v33 + 4;
        memset_s((char *)__s + v33 + 8, 252 - v33, 0, 252 - v33);
        uint64_t v34 = *(uint64_t (**)(_DWORD *, void, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        if (!v34 || !*v122)
        {
          char v99 = __s;
LABEL_172:
          memset_s(v99, 0x104uLL, 0, 0x104uLL);
LABEL_173:
          uint64_t v100 = "decrypting cluster header";
          __int16 v101 = 195;
LABEL_174:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"writeProc",  v101,  108,  0,  v100,  v36,  v37,  v114);
          uint64_t v10 = -1LL;
          uint64_t v14 = v125;
          goto LABEL_188;
        }

        int v35 = v34(v124, *v126, v122, __s, v172);
        memset_s(__s, 0x104uLL, 0, 0x104uLL);
        if (v35 < 0) {
          goto LABEL_173;
        }
        memset((char *)v172 + 12, 0, 248);
        *(void *)((char *)v172 + 4) = 0x4B4548435F414541LL;
        LODWORD(v172[0]) = 8;
        memset_s((char *)v172 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(__s, 0, 260);
        uint64_t v38 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(v11 + 104);
        if (!v38 || !*v124)
        {
          char v99 = v172;
          goto LABEL_172;
        }

        int v39 = v38(v151, *(unsigned int *)(v11 + 36), v124, v172, __s);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v39 < 0) {
          goto LABEL_173;
        }
        uint64_t v40 = *(uint64_t (**)(char *, uint64_t, uint64_t, _OWORD *, char *, size_t))(v11 + 128);
        if (!v40) {
          goto LABEL_173;
        }
        if (*(_DWORD *)(v11 + 940) != *(_DWORD *)(v11 + 44)) {
          goto LABEL_173;
        }
        uint64_t result = v40(v30, v31, v116, v151, &v30[v31], v18 - v31);
        if ((result & 0x80000000) != 0) {
          goto LABEL_173;
        }
        *__int128 v119 = 0LL;
        if ((v18 & 0x8000000000000000LL) != 0) {
          goto LABEL_217;
        }
        unint64_t v41 = *(void *)(v11 + 1256);
        size_t v15 = v29;
        __srCC_SHA1_CTX c = v28;
        if (v41 >= v18) {
          goto LABEL_118;
        }
        do
        {
          while (!v41)
          {
            unint64_t v41 = 0x4000LL;
            size_t v43 = 0x4000LL;
            if (v18 <= 0x4000) {
              goto LABEL_116;
            }
          }

          unint64_t v42 = v41 >> 1;
          if ((v41 & (v41 >> 1)) != 0) {
            unint64_t v42 = v41 & (v41 >> 1);
          }
          v41 += v42;
        }

        while (v41 < v18);
        size_t v43 = v41;
        if (v41 >= 0x2000000001LL)
        {
          *__error() = 12;
LABEL_216:
          *__int128 v119 = 0LL;
          v119[1] = 0LL;
          v119[2] = 0LL;
LABEL_217:
          uint64_t v100 = "copy cluster header";
          __int16 v101 = 198;
          goto LABEL_174;
        }

LABEL_116:
        uint64_t v78 = *(void **)(v11 + 1264);
        uint64_t result = (uint64_t)realloc(v78, v43);
        if (!result)
        {
          free(v78);
          goto LABEL_216;
        }

        *(void *)(v11 + 1264) = result;
        *(void *)(v11 + 1256) = v43;
LABEL_118:
        uint64_t v79 = *(void *)(v11 + 1264);
        if (v30)
        {
          uint64_t result = (uint64_t)memcpy((void *)(v79 + *v119), v30, v18);
          uint64_t v14 = v125;
        }

        else
        {
          uint64_t v14 = v125;
          if (v79) {
            uint64_t result = memset_s((void *)(v79 + *v119), v18, 0, v18);
          }
        }

        *(void *)(v11 + 1248) += v18;
        uint64_t v80 = *(unsigned int *)(v11 + 44);
        if (v80 > 0x100)
        {
LABEL_224:
          __break(1u);
          return result;
        }

        memcpy(__dst, &v30[*(void *)(v11 + 392)], *(unsigned int *)(v11 + 44));
        *(_DWORD *)(v11 + 940) = v80;
        uint64_t result = memset_s(&__dst[v80], 256 - v80, 0, 256 - v80);
        *(void *)(v11 + 1200) = 0LL;
        *(_DWORD *)(v11 + 1276) = 0;
        int v13 = 3;
        goto LABEL_124;
      case 3:
        if (*(void *)(v11 + 1248) != *(void *)(v11 + 408))
        {
          char v106 = "invalid state";
          __int16 v107 = 213;
          goto LABEL_186;
        }

        size_t v118 = v15;
        unsigned int v44 = *(_DWORD *)(v11 + 1276);
        if (v44 >= *(_DWORD *)(v11 + 260) || (unint64_t v45 = *(void *)(v11 + 1280), v46 = *(void *)(v11 + 1288), v45 >= v46))
        {
          char v106 = "invalid state";
          __int16 v107 = 218;
          goto LABEL_186;
        }

        uint64_t v47 = *(unsigned int *)(v11 + 288);
        uint64_t v48 = (unsigned int *)(*(void *)(v11 + 1264) + *(void *)(v11 + 384) + ((_DWORD)v47 + 8) * v44);
        unint64_t v49 = *v48;
        size_t v20 = v48[1];
        if ((_DWORD)v49) {
          BOOL v50 = v20 > v49;
        }
        else {
          BOOL v50 = 1;
        }
        if (v50
          || v20 < v49 && !*(_DWORD *)(v11 + 264)
          || ((unsigned int v51 = *(_DWORD *)(v11 + 256), v45 + 1 != v46) ? (v52 = v49 != v51) : (v52 = 0),
              v49 <= v51 ? (BOOL v53 = !v52) : (BOOL v53 = 0),
              !v53))
        {
          unint64_t v108 = "invalid segment sizes";
          __int16 v109 = 229;
          goto LABEL_158;
        }

        if (v18 < v20)
        {
          size_t v15 = v118;
          uint64_t v17 = v127;
LABEL_63:
          size_t v19 = v20 - v18;
          if (v20 == v18) {
            goto LABEL_125;
          }
LABEL_68:
          if (!v15) {
            goto LABEL_188;
          }
          if (v19 >= v15) {
            size_t v57 = v15;
          }
          else {
            size_t v57 = v19;
          }
          unint64_t v58 = v18 + v57;
          if (__CFADD__(v18, v57) || (v58 & 0x8000000000000000LL) != 0) {
            goto LABEL_185;
          }
          unint64_t v59 = *(void *)(v11 + 1208);
          if (v59 < v58)
          {
            do
            {
              while (!v59)
              {
                unint64_t v59 = 0x4000LL;
                size_t v61 = 0x4000LL;
                if (v58 <= 0x4000) {
                  goto LABEL_83;
                }
              }

              unint64_t v60 = v59 >> 1;
              if ((v59 & (v59 >> 1)) != 0) {
                unint64_t v60 = v59 & (v59 >> 1);
              }
              v59 += v60;
            }

            while (v59 < v58);
            size_t v61 = v59;
            if (v59 >= 0x2000000001LL)
            {
              *__error() = 12;
            }

            else
            {
LABEL_83:
              int v62 = *(void **)(v11 + 1216);
              uint64_t result = (uint64_t)realloc(v62, v61);
              if (result)
              {
                *(void *)(v11 + 1216) = result;
                *(void *)(v11 + 1208) = v61;
                uint64_t v17 = v127;
                goto LABEL_85;
              }

              free(v62);
            }

            *unint64_t v127 = 0LL;
            v127[1] = 0LL;
            v127[2] = 0LL;
LABEL_185:
            char v106 = "malloc";
            __int16 v107 = 356;
            goto LABEL_186;
          }

LABEL_186:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"writeProc",  v107,  108,  0,  v106,  a7,  a8,  v114);
LABEL_187:
              uint64_t v10 = -1LL;
              goto LABEL_188;
            }

            free(v82);
          }

          size_t *v117 = 0LL;
          v117[1] = 0LL;
          v117[2] = 0LL;
          char v106 = "malloc";
          __int16 v107 = 254;
          goto LABEL_186;
        }

LABEL_140:
        if (*v74 != v49)
        {
          char v106 = "invalid raw size";
          __int16 v107 = 281;
          goto LABEL_186;
        }

        size_t v89 = v74[2];
        int v90 = *(_DWORD *)(v11 + 252);
        if (v90
          && ((aeaChecksum((uint64_t)__n, v90, (void *)v74[2], v49, v72, v73, a7, a8) & 0x80000000) != 0
           || LODWORD(__n[0]) != LODWORD(v149[0])
           || memcmp((char *)__n + 4, (char *)v149 + 4, LODWORD(__n[0]))))
        {
          char v106 = "segment checksum verification";
          __int16 v107 = 287;
          goto LABEL_186;
        }

        unint64_t v91 = 0LL;
        do
        {
          __int16 v92 = *(uint64_t (**)(void, size_t, unint64_t))(*(void *)v11 + 24LL);
          if (!v92 || (result = v92(**(void **)v11, v89 + v91, v49 - v91), __int128 v12 = 0uLL, result <= 0))
          {
            char v106 = "invalid raw stream";
            __int16 v107 = 294;
            goto LABEL_186;
          }

          v91 += result;
        }

        while (v91 < v49);
        *(void *)(v11 + 1200) = 0LL;
        *(void *)(v11 + 1224) = 0LL;
        int v93 = *(_DWORD *)(v11 + 1276) + 1;
        *(_DWORD *)(v11 + 1276) = v93;
        uint64_t v94 = *(void *)(v11 + 1280) + 1LL;
        *(void *)(v11 + 1280) = v94;
        *(_DWORD *)(v11 + 676) = 3;
        if (v94 != *(void *)(v11 + 1288))
        {
          uint64_t v17 = v127;
          if (v93 == *(_DWORD *)(v11 + 260))
          {
            ++*(_DWORD *)(v11 + 1272);
            int v13 = 2;
LABEL_154:
            *(_DWORD *)(v11 + 676) = v13;
          }

          else
          {
            int v13 = 3;
          }

          goto LABEL_125;
        }

        uint64_t v17 = v127;
        if (*(void *)(v11 + 1296) != *(void *)(v11 + 280))
        {
          int v13 = 4;
          goto LABEL_154;
        }

LABEL_223:
        *(_DWORD *)(v11 + 676) = 5;
LABEL_188:
        memset_s(v153, 0x104uLL, 0, 0x104uLL);
        memset_s(v151, 0x104uLL, 0, 0x104uLL);
        memset_s(v149, 0x104uLL, 0, 0x104uLL);
        memset_s(__n, 0x104uLL, 0, 0x104uLL);
        memset_s(v130, 0x104uLL, 0, 0x104uLL);
        memset_s(v128, 0x104uLL, 0, 0x104uLL);
        AEAContextDestroy((AEAContext)v14);
        if (v10 < 0)
        {
          do
          {
            if (__ldaxr(v8))
            {
              __clrex();
              return v10;
            }
          }

          while (__stlxr(1u, v8));
          uint64_t v105 = *(void (**)(void))(*(void *)v11 + 16LL);
          if (v105) {
            v105(**(void **)v11);
          }
        }

        return v10;
      case 4:
        unint64_t v54 = *(void *)(v11 + 1296);
        unint64_t v55 = *(void *)(v11 + 280);
        BOOL v56 = v55 >= v54;
        size_t v19 = v55 - v54;
        if (!v56)
        {
          char v106 = "invalid padding state";
          __int16 v107 = 321;
          goto LABEL_186;
        }

        if (v19) {
          goto LABEL_68;
        }
        uint64_t v95 = *(void *)(v11 + 1216);
        memset(__s, 0, 260);
        memset(v172, 0, 260);
        int v171 = 0;
        __int128 v170 = 0u;
        __int128 v169 = 0u;
        __int128 v168 = 0u;
        __int128 v167 = 0u;
        __int128 v166 = 0u;
        __int128 v165 = 0u;
        __int128 v164 = 0u;
        __int128 v163 = 0u;
        __int128 v162 = 0u;
        __int128 v161 = 0u;
        __int128 v160 = 0u;
        __int128 v159 = 0u;
        __int128 v158 = 0u;
        __int128 v157 = 0u;
        __int128 v156 = 0u;
        __int128 v155 = 0u;
        if (*(void *)(v11 + 208)
          && (*(_DWORD *)((char *)v172 + 7) = 1262571615,
              *(void *)&v172[0] = 0x5F41454100000007LL,
              memset_s((char *)v172 + 11, 0xF9uLL, 0, 0xF9uLL),
              (__int16 v96 = *(uint64_t (**)(_OWORD *, void))(v11 + 104)) != 0LL)
          && *v122)
        {
          uint64_t v97 = __dst;
          if ((v96(__s, *v126) & 0x80000000) == 0)
          {
            uint64_t v98 = (*(uint64_t (**)(_OWORD *))(v11 + 208))(__s);
            goto LABEL_179;
          }
        }

        else
        {
          uint64_t v97 = __dst;
        }

        uint64_t v98 = 0LL;
LABEL_179:
        memset_s(__s, 0x104uLL, 0, 0x104uLL);
        memset_s(v172, 0x104uLL, 0, 0x104uLL);
        if (v98)
        {
          int64x2_t v102 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(v11 + 216);
          BOOL v103 = !v102 || (v102(v98, v95, v18) & 0x80000000) != 0;
          memset(__s, 0, 260);
          int64x2_t v110 = *(uint64_t (**)(uint64_t, _OWORD *))(v11 + 224);
          if (!v110) {
            goto LABEL_206;
          }
          if (*(_DWORD *)(v11 + 940) != *(_DWORD *)(v11 + 44)) {
            goto LABEL_206;
          }
          if ((v110(v98, __s) & 0x80000000) != 0) {
            goto LABEL_206;
          }
          if (LODWORD(__s[0]) != *(_DWORD *)(v11 + 44)) {
            goto LABEL_206;
          }
          if (LODWORD(__s[0]) < 8) {
            goto LABEL_221;
          }
          uint64_t v111 = 0LL;
          uint64_t v112 = 0LL;
          do
          {
            v112 |= *(void *)((char *)__s + v111 + 4) ^ *(void *)&v97[v111];
            unint64_t v113 = v111 + 16;
            v111 += 8LL;
          }

          while (v113 <= LODWORD(__s[0]));
          if (!v112)
          {
LABEL_221:
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
            if (!v103)
            {
              *(void *)(v11 + 1200) = 0LL;
              goto LABEL_223;
            }
          }

          else
          {
LABEL_206:
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
          }

          char v106 = "corrupted padding";
          __int16 v107 = 337;
        }

        else
        {
          char v106 = "creating padding hash state";
          __int16 v107 = 334;
        }

        goto LABEL_186;
      default:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"writeProc",  346,  108,  0,  "invalid state %d",  a7,  a8,  v13);
        goto LABEL_187;
    }
  }

void **cancelProc_2(void **result)
{
  uint64_t v1 = (unsigned int *)(result + 3);
  do
  {
    if (__ldaxr(v1))
    {
      __clrex();
      return result;
    }
  }

  while (__stlxr(1u, v1));
  unint64_t v3 = (uint64_t (*)(void))(*result)[2];
  if (v3) {
    return (void **)v3(**result);
  }
  return result;
}

void (**aaAssetDecryptionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  *(void *)((char *)&__s[32] + 4) = *MEMORY[0x1895F89C0];
  uint64_t v5 = (void (**)(void))aaAssetDecryptionStreamOpen(a1, 0LL, 0LL);
  uint64_t v8 = v5;
  if (!v5) {
    return v8;
  }
  uint64_t v9 = *v5;
  memset(v81, 0, 32);
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v78 = 0u;
  memset(v77, 0, sizeof(v77));
  if (!*((void *)a2 + 2)) {
    goto LABEL_25;
  }
  uint64_t v10 = 0LL;
  uint64_t v11 = v77;
  uint64_t v12 = 128LL;
  do
  {
    uint64_t v13 = (*((uint64_t (**)(void, _OWORD *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
    if (v13 < 0) {
      goto LABEL_25;
    }
    if (!v13) {
      break;
    }
    uint64_t v11 = (_OWORD *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }

  while (v12);
  if (v10 != 128)
  {
LABEL_25:
    uint64_t v30 = "truncated state";
    __int16 v31 = 480;
    goto LABEL_26;
  }

  *((_DWORD *)v9 + 169) = HIDWORD(v78);
  *((void *)v9 + 159) = *(void *)&v81[0];
  *((_OWORD *)v9 + 80) = *(_OWORD *)((char *)v81 + 8);
  *((void *)v9 + 162) = *((void *)&v81[1] + 1);
  if ((aeaContainerParamsInitWithMagic((int *)v9 + 60, v77, v14, v15, v16, v17, v6, v7) & 0x80000000) != 0
    || (aeaContainerParamsInitWithRootHeader((uint64_t)v9 + 240, (unint64_t)v77 | 0xC, v18, v19, v20, v21, v6, v7) & 0x80000000) != 0
    || (uint64_t v22 = (_DWORD *)((char *)v9 + 32), (aeaCryptoInit((char *)v9 + 32, (unsigned int *)v9 + 60) & 0x80000000) != 0)
    || (aeaContainerOffsetsInit((uint64_t)v9 + 312, (unsigned int *)v9 + 60, (unsigned int *)v9 + 8) & 0x80000000) != 0)
  {
    uint64_t v30 = "invalid state";
    __int16 v31 = 493;
    goto LABEL_26;
  }

  if (*((_DWORD *)v9 + 169) >= 6u)
  {
    uint64_t v30 = "invalid state";
    __int16 v31 = 505;
    goto LABEL_26;
  }

  unint64_t v23 = *((void *)v9 + 160);
  if (v23 > *((void *)v9 + 161)
    || (uint64_t v24 = *((unsigned int *)v9 + 319), v25 = *((_DWORD *)v9 + 65), v24 > v25)
    || v24 + *((unsigned int *)v9 + 318) * (unint64_t)v25 != v23
    || (uint64_t v26 = v79, v79 > *v22)
    || DWORD1(v79) > *((_DWORD *)v9 + 11)
    || ((unint64_t v27 = *((unsigned int *)v9 + 64), v28 = *((void *)v9 + 51), v28 <= v27)
      ? (unint64_t v29 = *((unsigned int *)v9 + 64))
      : (unint64_t v29 = *((void *)v9 + 51)),
        *((void *)&v79 + 1) > v29 || (unint64_t)v80 > v27 || *((void *)&v80 + 1) > v28))
  {
    uint64_t v30 = "invalid state";
    __int16 v31 = 515;
LABEL_26:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c",  (uint64_t)"aaAssetDecryptionStreamOpenWithState",  v31,  108,  0,  v30,  v6,  v7,  v77[0]);
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0LL;
  }

  if (!*((void *)a2 + 2)) {
    goto LABEL_135;
  }
  if ((_DWORD)v79)
  {
    uint64_t v33 = 0LL;
    uint64_t v34 = (uint64_t)v9 + 684;
    do
    {
      uint64_t v35 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v34, v26);
      if (v35 < 0) {
        goto LABEL_135;
      }
      if (!v35) {
        break;
      }
      v34 += v35;
      v33 += v35;
      v26 -= v35;
    }

    while (v26);
    if (v33 < 0 || !*((void *)a2 + 2)) {
      goto LABEL_135;
    }
  }

  uint64_t v36 = DWORD1(v79);
  if (DWORD1(v79))
  {
    uint64_t v37 = 0LL;
    uint64_t v38 = (uint64_t)v9 + 944;
    do
    {
      uint64_t v39 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v38, v36);
      if (v39 < 0) {
        goto LABEL_135;
      }
      if (!v39) {
        break;
      }
      v38 += v39;
      v37 += v39;
      v36 -= v39;
    }

    while (v36);
    if (v37 < 0)
    {
LABEL_135:
      uint64_t v30 = "invalid state";
      __int16 v31 = 523;
      goto LABEL_26;
    }
  }

  size_t v40 = *((void *)&v79 + 1);
  if (!*((void *)&v79 + 1)) {
    goto LABEL_72;
  }
  uint64_t v41 = 0LL;
  unint64_t v42 = (unint64_t *)((char *)v9 + 1200);
  unint64_t v43 = *((void *)v9 + 150);
  unint64_t v44 = *((void *)v9 + 151);
  do
  {
    if (v43 == v44)
    {
      unint64_t v45 = v44 + 0x40000;
      if (v44 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v44)
          {
            unint64_t v44 = 0x4000LL;
            size_t v47 = 0x4000LL;
            if (v45 <= 0x4000) {
              goto LABEL_61;
            }
          }

          unint64_t v46 = v44 >> 1;
          if ((v44 & (v44 >> 1)) != 0) {
            unint64_t v46 = v44 & (v44 >> 1);
          }
          v44 += v46;
        }

        while (v44 < v45);
        size_t v47 = v44;
        if (v44 >= 0x2000000001LL)
        {
LABEL_133:
          *__error() = 12;
        }

        else
        {
LABEL_61:
          uint64_t v48 = (void *)*((void *)v9 + 152);
          unint64_t v49 = realloc(v48, v47);
          if (v49)
          {
            *((void *)v9 + 152) = v49;
            *((void *)v9 + 151) = v47;
            unint64_t v43 = *((void *)v9 + 150);
            goto LABEL_63;
          }

uint64_t *AEADecryptAndExtractAsyncStreamOpen( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8)
{
  if (stat(a1, &v34) || (v34.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"AEADecryptAndExtractAsyncStreamOpen",  804,  115,  0,  "Invalid/missing directory: %s",  v16,  v17,  (char)a1);
    uint64_t v21 = 0LL;
    uint64_t v19 = 0LL;
  }

  else
  {
    uint64_t v18 = malloc(0x9C8uLL);
    uint64_t v19 = (uint64_t)v18;
    if (v18)
    {
      memset_s(v18, 0x9C8uLL, 0, 0x9C8uLL);
      uint64_t v20 = (uint64_t *)malloc(0x38uLL);
      uint64_t v21 = v20;
      if (v20)
      {
        memset_s(v20, 0x38uLL, 0, 0x38uLL);
        *(void *)uint64_t v19 = a3;
        *(void *)(v19 + 8) = a4;
        *(void *)(v19 + 16) = a6;
        *(void *)(v19 + 24) = a5;
        *(void *)(v19 + 2128) = a7;
        *(_DWORD *)(v19 + 2136) = a8;
        *(_DWORD *)(v19 + 2120) = a7 >> 62;
        if (a2) {
          *(void *)(v19 + 2296) = AAByteRangeClone(a2);
        }
        if (realpath_DARWIN_EXTSN(a1, (char *)(v19 + 72)))
        {
          if ((concatPath((char *)(v19 + 1096), 0x400uLL, (char *)(v19 + 72), ".tmp_decrypt") & 0x80000000) != 0)
          {
            char v33 = v19 + 72;
            unsigned int v25 = "Path too long: %s";
            __int16 v26 = 822;
          }

          else if (stat((const char *)(v19 + 1096), &v34) || (v34.st_mode & 0xF000) == 0x4000)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2320), 0LL))
            {
              int v24 = *__error();
              unsigned int v25 = "pthread_mutex_init";
              __int16 v26 = 824;
LABEL_24:
              pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndEx tractAsyncStream.c",  (uint64_t)"AEADecryptAndExtractAsyncStreamOpen",  v26,  115,  v24,  v25,  v22,  v23,  v33);
              goto LABEL_14;
            }

            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2408), 0LL))
            {
              int v24 = *__error();
              unsigned int v25 = "pthread_mutex_init";
              __int16 v26 = 825;
              goto LABEL_24;
            }

            __int16 v31 = AEADecryptAsyncStreamOpen( v19,  (uint64_t)setupContext_0,  (uint64_t)verifySegment_0,  (uint64_t)processSegment_1,  a7,  a8);
            *(void *)(v19 + 48) = v31;
            if (v31)
            {
              AAArchiveStream v32 = AAExtractArchiveOutputStreamOpen(a1, (void *)v19, (AAEntryMessageProc)entryMessage, a7, a8);
              *(void *)(v19 + 64) = v32;
              if (v32)
              {
                *uint64_t v21 = v19;
                v21[1] = (uint64_t)extractToDirAsyncClose;
                v21[2] = (uint64_t)extractToDirAsyncGetRange;
                v21[3] = (uint64_t)extractToDirAsyncProcess;
                v21[4] = (uint64_t)extractToDirAsyncCancel;
                return v21;
              }

              unsigned int v25 = "creating extract stream";
              __int16 v26 = 832;
            }

            else
            {
              unsigned int v25 = "creating decrypt stream";
              __int16 v26 = 830;
            }
          }

          else
          {
            char v33 = v19 + 72;
            unsigned int v25 = "Invalid tmp dir: %s";
            __int16 v26 = 823;
          }
        }

        else
        {
          char v33 = (char)a1;
          unsigned int v25 = "Invalid directory: %s";
          __int16 v26 = 821;
        }

        int v24 = 0;
        goto LABEL_24;
      }

      int v24 = *__error();
      unsigned int v25 = "malloc";
      __int16 v26 = 810;
      goto LABEL_24;
    }

    unint64_t v28 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"AEADecryptAndExtractAsyncStreamOpen",  808,  115,  *v28,  "malloc",  v29,  v30,  v33);
    uint64_t v21 = 0LL;
  }

uint64_t setupContext_0(uint64_t a1, AEAContext context)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  memset(&v79, 0, sizeof(v79));
  int v4 = *(uint64_t (**)(void, AEAContext))(a1 + 8);
  if (v4 && (v4(*(void *)a1, context) & 0x80000000) != 0)
  {
    uint64_t v9 = "Client context callback returned an error";
    __int16 v10 = 459;
    goto LABEL_18;
  }

  if (*(_DWORD *)(a1 + 2140))
  {
    *(void *)(a1 + 2144) = AEAContextGetFieldUInt(context, 0xDu);
    uint64_t FieldUInt = AEAContextGetFieldUInt(context, 4u);
    *(void *)(a1 + 2152) = FieldUInt;
    size_t v8 = (FieldUInt + *(void *)(a1 + 2144) - 1) / FieldUInt;
    if (v8 >= 0xFFFFFFFF)
    {
      uint64_t v9 = "Too many segments";
      __int16 v10 = 470;
LABEL_18:
      int v21 = 0;
      goto LABEL_19;
    }

    *(_DWORD *)(a1 + 2384) = v8;
    if ((_DWORD)v8)
    {
      uint64_t v13 = calloc(v8, 0x10uLL);
      *(void *)(a1 + 2392) = v13;
      if (!v13)
      {
        int v21 = *__error();
        uint64_t v9 = "malloc";
        __int16 v10 = 476;
LABEL_19:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"setupContext",  v10,  115,  v21,  v9,  v5,  v6,  (char)v76);
        uint64_t v11 = 0LL;
LABEL_20:
        uint64_t v12 = 0xFFFFFFFFLL;
        goto LABEL_21;
      }

      size_t v14 = (*(_DWORD *)(a1 + 2384) + 1);
      *(_DWORD *)(a1 + 2160) = 0;
      *(_DWORD *)(a1 + 2164) = v14;
      uint64_t v15 = calloc(v14, 4uLL);
      *(void *)(a1 + 2168) = v15;
      if (!v15)
      {
        uint64_t v19 = "SharedArrayInit: malloc failed\n";
        __int16 v20 = 55;
        goto LABEL_17;
      }

      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 2176), 0LL))
      {
        uint64_t v19 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v20 = 56;
LABEL_17:
        pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Co mmon/SharedArray.h",  (uint64_t)"SharedArrayInit",  v20,  0,  v19,  v16,  v17,  v18,  (char)v76);
        uint64_t v9 = "SharedArrayInit";
        __int16 v10 = 479;
        goto LABEL_18;
      }

      if (pthread_cond_init((pthread_cond_t *)(a1 + 2240), 0LL))
      {
        uint64_t v19 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v20 = 57;
        goto LABEL_17;
      }

      if (AASharedBufferPipeOpen((AAByteStream *)(a1 + 32), (AAByteStream *)(a1 + 40), *(void *)(a1 + 2152)) < 0)
      {
        uint64_t v9 = "AASharedBufferPipeOpen";
        __int16 v10 = 482;
        goto LABEL_18;
      }

      AAArchiveStream v23 = AADecodeArchiveInputStreamOpen( *(AAByteStream *)(a1 + 40),  0LL,  0LL,  *(void *)(a1 + 2128) | 0x100LL,  *(_DWORD *)(a1 + 2136));
      *(void *)(a1 + 56) = v23;
      if (!v23)
      {
        uint64_t v9 = "open decoder stream";
        __int16 v10 = 486;
        goto LABEL_18;
      }

      if ((createThread((pthread_t *)(a1 + 2488), (uint64_t)loadThread, a1, 0LL) & 0x80000000) != 0)
      {
        uint64_t v9 = "createThread";
        __int16 v10 = 489;
        goto LABEL_18;
      }

      if ((createThread((pthread_t *)(a1 + 2496), (uint64_t)extractThread, a1, 0LL) & 0x80000000) != 0)
      {
        uint64_t v9 = "createThread";
        __int16 v10 = 490;
        goto LABEL_18;
      }
    }

    if (stat((const char *)(a1 + 1096), &v79))
    {
      if (mkdir((const char *)(a1 + 1096), 0x1C0u))
      {
        int v21 = *__error();
        LOBYTE(v76) = a1 + 72;
        uint64_t v9 = "mkdir: %s";
        __int16 v10 = 500;
        goto LABEL_19;
      }
    }

    else if ((v79.st_mode & 0xF000) != 0x4000)
    {
      LOBYTE(v76) = a1 + 72;
      uint64_t v9 = "Not a directory: %s";
      __int16 v10 = 496;
      goto LABEL_18;
    }

    buf_timespec size = 0LL;
    memset(&buf, 0, 128);
    memset(__s2, 0, sizeof(__s2));
    if (AEAContextGetFieldBlob(context, 0x12u, 0, 0x80uLL, (uint8_t *)&buf, &buf_size) < 0)
    {
      uint64_t v9 = "getting archive identifier";
      __int16 v10 = 511;
      goto LABEL_18;
    }

    if ((concatPath(__str, 0x400uLL, (char *)(a1 + 1096), "archive_id") & 0x80000000) != 0)
    {
      LOBYTE(v76) = a1 + 72;
      uint64_t v9 = "Name too long: %s";
      __int16 v10 = 513;
      goto LABEL_18;
    }

    if (stat(__str, &v79))
    {
      if ((storeFileContents(__str, (uint64_t)&buf, buf_size) & 0x80000000) != 0)
      {
        int v76 = __str;
        uint64_t v9 = "storing archive id: %s";
        __int16 v10 = 529;
        goto LABEL_18;
      }
    }

    else
    {
      if ((v79.st_mode & 0xF000) != 0x8000 || v79.st_size != buf_size)
      {
        uint64_t v9 = "Archive identifier size mismatch when resuming";
        __int16 v10 = 517;
        goto LABEL_18;
      }

      int v36 = open(__str, 0);
      if (v36 < 0)
      {
        int v21 = *__error();
        int v76 = __str;
        uint64_t v9 = "open: %s";
        __int16 v10 = 519;
        goto LABEL_19;
      }

      int v37 = v36;
      ssize_t v38 = read(v36, __s2, buf_size);
      close(v37);
      if (v38 != buf_size || memcmp(&buf, __s2, v38))
      {
        uint64_t v9 = "Archive identifier value mismatch when resuming";
        __int16 v10 = 523;
        goto LABEL_18;
      }
    }

    uint64_t v24 = *(void *)(a1 + 2296);
    if (!v24)
    {
      uint64_t v39 = AAByteRangeCreate();
      *(void *)(a1 + 2296) = v39;
      if (!v39)
      {
        uint64_t v9 = "AAByteRangeCreate";
        __int16 v10 = 537;
        goto LABEL_18;
      }

      if ((AAByteRangeAdd((uint64_t)v39, 0LL, *(void *)(a1 + 2144), v40, v41, v42, v5, v6) & 0x80000000) != 0)
      {
        uint64_t v9 = "AAByteRangeAdd";
        __int16 v10 = 538;
        goto LABEL_18;
      }

      uint64_t v24 = *(void *)(a1 + 2296);
    }

    uint64_t v25 = AAByteRangeSizeAtOffset(v24, 0x7FFFFFFFFFFFFFFFLL);
    *(void *)(a1 + 2304) = v25 - AAByteRangeSizeAtOffset(v24, 0x8000000000000000LL);
    Remainingint Range = loadRemainingRange(a1);
    if (RemainingRange)
    {
      uint64_t v11 = RemainingRange;
      uint64_t v27 = AAByteRangeFirst((uint64_t)RemainingRange, 0LL, __str, &buf);
      if ((v27 & 0x8000000000000000LL) == 0)
      {
        uint64_t v30 = v27;
        while (1)
        {
          uint64_t v31 = *(void *)__str;
          uint64_t v32 = *(void *)&buf.st_dev;
          if (*(uint64_t *)__str <= *(uint64_t *)&buf.st_dev)
          {
            uint64_t v34 = *(void *)(a1 + 2296);
            uint64_t v35 = AAByteRangeSizeAtOffset(v34, *(uint64_t *)&buf.st_dev);
            uint64_t v33 = v35 - AAByteRangeSizeAtOffset(v34, v31);
            uint64_t v32 = *(void *)&buf.st_dev;
            uint64_t v31 = *(void *)__str;
          }

          else
          {
            uint64_t v33 = -1LL;
          }

          if (v33 < v32 - v31) {
            break;
          }
          uint64_t v30 = AAByteRangeNext((uint64_t)v11, v30, __str, &buf);
          if (v30 < 0) {
            goto LABEL_43;
          }
        }

        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"setupContext",  553,  115,  0,  "Stored remaining range is not a subset of initial range",  v28,  v29,  (char)v76);
        goto LABEL_20;
      }

uint64_t verifySegment_0( uint64_t a1, size_t __size, unint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  int v38 = 0;
  memset(v37, 0, sizeof(v37));
  unint64_t v9 = *(void *)(a1 + 2152);
  unint64_t v10 = a3 / v9;
  if (a3 / v9 * v9 != a3 || v10 >= *(unsigned int *)(a1 + 2384))
  {
    char v36 = a3;
    size_t v14 = "Invalid segment offset: %llu, size: %zu";
    __int16 v15 = 639;
    int v16 = 0;
    goto LABEL_9;
  }

  if (*(_DWORD *)(*(void *)(a1 + 2392) + 16LL * (a3 / v9)) != 3)
  {
    if (__size < 0x2000000001LL)
    {
      int v21 = malloc(__size);
      if (v21)
      {
        uint64_t v12 = v21;
        if ((int)loadTempSegment(a1, v10, (uint64_t)v21, __size, v22, v23, v24, v25) < 1
          || aeaChecksum((uint64_t)v37, a4, v12, __size, v28, v29, v30, v31)
          || LODWORD(v37[0]) != a6
          || memcmp((char *)v37 + 4, a5, a6))
        {
          unlinkTempSegment(a1, v10, v26, v27, v28, v29, v30, v31);
          uint64_t v13 = 0LL;
          goto LABEL_11;
        }

        uint64_t v32 = (unsigned int *)(a1 + 2288);
        do
          unsigned int v33 = __ldaxr(v32);
        while (__stlxr(v33 + 1, v32));
        if (*(_DWORD *)(a1 + 2120) >= 2u) {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u: cached\n", v10);
        }
        if ((notifySegmentAvailable(a1, v10, __size) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"verifySegment",  664,  115,  0,  "pushSegmentData failed",  v34,  v35,  v36);
LABEL_10:
        uint64_t v13 = 0xFFFFFFFFLL;
        goto LABEL_11;
      }
    }

    else
    {
      *__error() = 12;
    }

    int v16 = *__error();
    size_t v14 = "malloc";
    __int16 v15 = 652;
LABEL_9:
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"verifySegment",  v15,  115,  v16,  v14,  a7,  a8,  v36);
    uint64_t v12 = 0LL;
    goto LABEL_10;
  }

  if (*(_DWORD *)(a1 + 2120) >= 2u) {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u: not needed\n", v10);
  }
  uint64_t v12 = 0LL;
LABEL_7:
  uint64_t v13 = 1LL;
LABEL_11:
  free(v12);
  return v13;
}

uint64_t processSegment_1( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  unint64_t v9 = *(void *)(a1 + 2152);
  unint64_t v10 = a3 / v9;
  if (a3 / v9 * v9 == a3 && v10 < *(unsigned int *)(a1 + 2384))
  {
    memset(&v35, 0, sizeof(v35));
    if ((getTempSegmentFilename(a1, v10, __str, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v26 = "getSegmentFile";
      __int16 v27 = 127;
    }

    else
    {
      if (stat(__str, &v35))
      {
        char v34 = 0x80;
        int v15 = open(__str, 1537);
        if ((v15 & 0x80000000) == 0)
        {
          int v16 = v15;
          if (!a2)
          {
LABEL_11:
            close(v16);
            int v21 = (unsigned int *)(a1 + 2288);
            do
              unsigned int v22 = __ldaxr(v21);
            while (__stlxr(v22 + 1, v21));
            if (*(_DWORD *)(a1 + 2120) >= 2u) {
              fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u: stored in cache\n", v10);
            }
            if ((notifySegmentAvailable(a1, v10, a2) & 0x80000000) == 0) {
              return 0LL;
            }
            uint64_t v29 = "pushSegmentData";
            __int16 v30 = 695;
            goto LABEL_23;
          }

          unint64_t v17 = 0LL;
          while (1)
          {
            ssize_t v18 = write(v16, (const void *)(a4 + v17), a2 - v17);
            if (v18 < 0)
            {
              int v31 = *__error();
              uint64_t v32 = "write";
              __int16 v33 = 135;
              goto LABEL_30;
            }

            if (!v18) {
              break;
            }
            v17 += v18;
            if (v17 >= a2) {
              goto LABEL_11;
            }
          }

          uint64_t v32 = "write returned 0";
          __int16 v33 = 136;
          int v31 = 0;
LABEL_30:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"storeTempSegment",  v33,  115,  v31,  v32,  v19,  v20,  128);
          close(v16);
LABEL_22:
          uint64_t v29 = "storeTempSegment";
          __int16 v30 = 690;
LABEL_23:
          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"processSegment",  v30,  115,  0,  v29,  v23,  v24,  v34);
          return 0xFFFFFFFFLL;
        }

        int v28 = *__error();
        uint64_t v26 = "tmp";
        __int16 v27 = 130;
LABEL_21:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"storeTempSegment",  v27,  115,  v28,  v26,  v13,  v14,  v34);
        goto LABEL_22;
      }

      uint64_t v26 = "segment already in cache";
      __int16 v27 = 128;
    }

    int v28 = 0;
    goto LABEL_21;
  }

  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"processSegment",  686,  115,  0,  "Invalid segment offset: %llu, size: %zu",  a7,  a8,  a3);
  return 0xFFFFFFFFLL;
}

uint64_t entryMessage( void *a1, uint64_t a2, uint64_t a3, AAHeader header, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = a3;
  int v10 = a2;
  uint64_t v12 = (uint64_t (*)(void, uint64_t, uint64_t, AAHeader))a1[3];
  if (!v12 || (uint64_t v13 = v12(*a1, a2, a3, header), !(_DWORD)v13))
  {
    switch(v10)
    {
      case 20:
        uint64_t v39 = -1LL;
        uint64_t value = -1LL;
        uint64_t v38 = -1LL;
        v15.uint64_t ikey = 5265748;
        uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v15);
        BOOL v19 = 0;
        if ((KeyIndex & 0x80000000) == 0)
        {
          unsigned int FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, &value);
          int v18 = FieldUInt <= 1 ? 1 : FieldUInt;
          if (v18 > 0) {
            BOOL v19 = 1;
          }
        }

        v26.uint64_t ikey = 5784649;
        uint32_t v27 = AAHeaderGetKeyIndex(header, v26);
        if ((v27 & 0x80000000) != 0
          || ((unsigned int v28 = AAHeaderGetFieldUInt(header, v27, &v39), v28 <= 1) ? (v29 = 1) : (v29 = v28), v29 <= 0))
        {
          BOOL v19 = 0;
        }

        v30.uint64_t ikey = 5915721;
        uint32_t v31 = AAHeaderGetKeyIndex(header, v30);
        if ((v31 & 0x80000000) != 0
          || ((unsigned int v32 = AAHeaderGetFieldUInt(header, v31, &v38), v32 <= 1) ? (v33 = 1) : (v33 = v32), !v19 || v33 <= 0))
        {
          uint64_t v24 = "Missing IDX,IDZ from archive decoder";
          __int16 v25 = 419;
        }

        else
        {
          uint64_t v34 = AAByteRangeOffsetAtSize(a1[287], v39);
          uint64_t v35 = AAByteRangeOffsetAtSize(a1[287], v38 + v39);
          uint64_t v24 = "retire segment";
          __int16 v25 = 428;
        }

        break;
      case 21:
        if (header)
        {
          uint64_t v20 = *(void *)header;
          uint64_t v21 = *((void *)header + 1);
          uint64_t v22 = AAByteRangeOffsetAtSize(a1[287], *(void *)header);
          uint64_t v23 = AAByteRangeOffsetAtSize(a1[287], v21 + v20);
          uint64_t v24 = "retire segment";
          __int16 v25 = 441;
        }

        else
        {
          uint64_t v24 = "data not expected to be NULL";
          __int16 v25 = 432;
        }

        break;
      case 22:
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"entryMessage",  407,  115,  0,  "Extraction failed: %s",  a7,  a8,  v9);
LABEL_37:
        uint64_t v14 = 0xFFFFFFFFLL;
LABEL_38:
        cancelStreams(a1);
        return v14;
      default:
        return 0LL;
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"entryMessage",  v25,  115,  0,  v24,  a7,  a8,  v37);
    goto LABEL_37;
  }

  uint64_t v14 = v13;
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_38;
  }
  return v14;
}

uint64_t extractToDirAsyncClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 2292));
    BOOL v3 = v2 == 0;
    if (*(void *)(result + 2488))
    {
      SharedArrayEnqueue((unsigned int *)(result + 2160), -1);
      joinThread(*(_opaque_pthread_t **)(v1 + 2488));
    }

    AAByteStreamClose(*(AAByteStream *)(v1 + 32));
    int v4 = *(_opaque_pthread_t **)(v1 + 2496);
    if (v4) {
      joinThread(v4);
    }
    AAByteStreamClose(*(AAByteStream *)(v1 + 40));
    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 64)) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"extractToDirAsyncClose",  725,  115,  0,  "extract stream reported errors",  v5,  v6,  v11.st_dev);
      BOOL v3 = 0;
    }

    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 56)) < 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"extractToDirAsyncClose",  726,  115,  0,  "decode stream reported errors",  v7,  v8,  v11.st_dev);
      BOOL v3 = 0;
    }

    if ((AAAsyncByteStreamClose(*(uint64_t (***)(void))(v1 + 48)) & 0x80000000) != 0)
    {
      pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"extractToDirAsyncClose",  727,  115,  0,  "decrypt stream reported errors",  v9,  v10,  v11.st_dev);
      BOOL v3 = 0;
    }

    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2320));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2408));
    free(*(void **)(v1 + 2392));
    if (*(_DWORD *)(v1 + 2384)
      && !pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2176))
      && !pthread_cond_destroy((pthread_cond_t *)(v1 + 2240)))
    {
      free(*(void **)(v1 + 2168));
    }

    AAByteRangeDestroy(*(void ***)(v1 + 2296));
    AAByteRangeDestroy(*(void ***)(v1 + 2472));
    free((void *)v1);
    if (v3) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t extractToDirAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = (unsigned int *)(a1 + 2312);
  if (atomic_load((unsigned int *)(a1 + 2312)))
  {
LABEL_2:
    while (!__ldaxr(v6))
    {
      if (!__stlxr(1u, v6)) {
        goto LABEL_6;
      }
    }

    __clrex();
LABEL_6:
    if (*(_DWORD *)(a1 + 2400) < *(_DWORD *)(a1 + 2384)) {
      return 0LL;
    }
    *a2 = 0LL;
    *a3 = 0LL;
    return 1LL;
  }

  uint64_t result = AAAsyncByteStreamGetRange(*(void **)(a1 + 48), a2, a3);
  if ((int)result >= 1)
  {
    if ((_DWORD)result != 1 || !*a2) {
      goto LABEL_2;
    }
    return 1LL;
  }

  return result;
}

uint64_t extractToDirAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(void *)(a1 + 48), a2, a3, a4);
}

uint64_t AEADecryptAndExtractChunkAsyncStreamOpen( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, unint64_t a9, unsigned int a10)
{
  AsyncStreamOpen = AEADecryptAndExtractAsyncStreamOpen(a1, a2, a3, a4, a5, a6, a9 | 0x200000000000000LL, a10);
  if (AsyncStreamOpen) {
    return aaCompositeChunkAsyncStreamOpen((uint64_t)AsyncStreamOpen, a7, a8, a9, a10);
  }
  pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"AEADecryptAndExtractChunkAsyncStreamOpen",  868,  115,  0,  "AEADecryptAndExtractAsyncStreamOpen",  v13,  v14,  v16);
  return 0LL;
}

uint64_t loadThread(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 2152);
  if (v2 >= 0x2000000001LL)
  {
    *__error() = 12;
LABEL_7:
    uint64_t v13 = __error();
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadThread",  331,  115,  *v13,  "malloc",  v14,  v15,  v43);
    int v4 = 0LL;
    goto LABEL_8;
  }

  BOOL v3 = (char *)malloc(v2);
  if (!v3) {
    goto LABEL_7;
  }
  int v4 = v3;
  uint64_t v5 = (pthread_mutex_t *)(a1 + 2176);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2176)))
  {
LABEL_5:
    uint64_t v9 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v10 = 91;
LABEL_6:
    pc_log_warning( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h",  (uint64_t)"SharedArrayPop",  v10,  0,  v9,  v6,  v7,  v8,  v43);
    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadThread",  336,  115,  0,  "SharedArrayDequeue",  v11,  v12,  v44);
  }

  else
  {
    unint64_t v17 = (unsigned int *)(a1 + 2288);
    while (1)
    {
      while (1)
      {
        int v18 = *(_DWORD *)(a1 + 2160);
        if (v18) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(a1 + 2240), v5))
        {
          uint64_t v9 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v10 = 94;
          goto LABEL_6;
        }
      }

      unsigned int v19 = v18 - 1;
      *(_DWORD *)(a1 + 2160) = v19;
      uint64_t v20 = *(unsigned int *)(*(void *)(a1 + 2168) + 4LL * v19);
      if (pthread_mutex_unlock(v5))
      {
        uint64_t v9 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v10 = 98;
        goto LABEL_6;
      }

      if ((_DWORD)v20 == -1) {
        goto LABEL_9;
      }
      if (v20 >= *(_DWORD *)(a1 + 2384))
      {
        pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadThread",  338,  115,  0,  "Invalid segment index: %u",  v7,  v8,  v20);
        goto LABEL_8;
      }

      if (*(_DWORD *)(a1 + 2120) >= 2u) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u: dequeue\n", v20);
      }
      unint64_t v22 = *(void *)(*(void *)(a1 + 2392) + 16 * v20 + 8);
      unint64_t v25 = *(void *)(a1 + 2152) * v20;
      uint64_t v26 = AAByteRangeFirst(*(void *)(a1 + 2296), v25, &v47, &v46);
      if (v26 < 0)
      {
        uint64_t v34 = 0LL;
      }

      else
      {
        uint64_t v33 = v26;
        int v45 = v20;
        uint64_t v34 = 0LL;
        unint64_t v35 = v25 + v22;
        int v36 = 1;
        do
        {
          if (v47 <= v25) {
            unint64_t v37 = v25;
          }
          else {
            unint64_t v37 = v47;
          }
          if (v35 >= v46) {
            unint64_t v38 = v46;
          }
          else {
            unint64_t v38 = v35;
          }
          if (v37 >= v38) {
            break;
          }
          while (1)
          {
            ssize_t v39 = AAByteStreamWrite(*(AAByteStream *)(a1 + 32), &v4[v37 - v25], v38 - v37);
            if (v39 < 0) {
              break;
            }
            v37 += v39;
            v34 += v39;
            if (v37 >= v38) {
              goto LABEL_31;
            }
          }

          pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadThread",  364,  115,  0,  "SharedBufferWrite",  v40,  v41,  v43);
          int v36 = 0;
LABEL_31:
          uint64_t v33 = AAByteRangeNext(*(void *)(a1 + 2296), v33, &v47, &v46);
        }

        while ((v33 & 0x8000000000000000LL) == 0);
        uint64_t v5 = (pthread_mutex_t *)(a1 + 2176);
        LODWORD(v20) = v45;
        if (!v36) {
          goto LABEL_8;
        }
      }

      if (*(_DWORD *)(a1 + 2120) >= 2u) {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Segment %u: %zu B processed\n", v20, v34);
      }
      unlinkTempSegment(a1, v20, v27, v28, v29, v30, v31, v32);
      do
        unsigned int v42 = __ldaxr(v17);
      while (__stlxr(v42 - 1, v17));
      if (pthread_mutex_lock(v5)) {
        goto LABEL_5;
      }
    }

    pc_log_error( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c",  (uint64_t)"loadThread",  344,  115,  0,  "loading segment: %u",  v23,  v24,  v20);
  }