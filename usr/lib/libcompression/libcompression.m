char *zero_coder_decode(int8x8_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  int8x8_t *v8;
  unint64_t v9;
  int8x8_t *v10;
  uint64_t v11;
  int8x8_t *v12;
  int v13;
  unsigned int v14;
  __int8 v15;
  __int8 v16;
  BOOL v17;
  if (!zero_coder_luts_ok) {
    zero_coder_init_luts();
  }
  v8 = (int8x8_t *)((char *)a1 + a2);
  v9 = (unint64_t)&a3[a4];
  if (a2 < 8 || a4 < 9)
  {
    v10 = a1;
  }

  else
  {
    v10 = a1;
    do
    {
      v11 = *a3;
      v12 = v10 + 2;
      *v10++ = vqtbl1_s8((int8x16_t)*(unint64_t *)(a3 + 1), *(int8x8_t *)&zero_coder_lut_read[8 * v11]);
      a3 += zero_coder_lut_popcount[v11] + 1;
    }

    while (v12 <= v8 && (unint64_t)(a3 + 9) <= v9);
  }

LABEL_10:
  if ((unint64_t)a3 < v9)
  {
    v13 = *a3++;
    v14 = v13 | 0x100;
    while (v10 != v8)
    {
      if ((v14 & 1) != 0)
      {
        v16 = *a3++;
        v15 = v16;
      }

      else
      {
        v15 = 0;
      }

      v10->i8[0] = v15;
      v10 = (int8x8_t *)((char *)v10 + 1);
      v17 = v14 > 3;
      v14 >>= 1;
      if (!v17) {
        goto LABEL_10;
      }
    }

    v10 = (int8x8_t *)((char *)a1 + a2);
  }

  return (char *)((char *)v10 - (char *)a1);
}

        *(void *)(result + 8 * v8) = v7;
        ++v6;
        v4 += 8LL;
        v5 += 8LL;
      }

      while (v6 != a2);
    }
  }

  return result;
}

    if ((v21 - 63) >= 2)
    {
      v25 = *v10;
    }

    else
    {
      v22 = *(void *)(a5 + 32);
      if (!v22)
      {
        v48 = 1;
LABEL_149:
        *(_DWORD *)(a5 + 752) = v48;
        return 2LL;
      }

      v23 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v23 >> 8;
      v24 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v26 + 1) = *v24;
      *(void *)&v26 = v23;
      v25 = v26 >> 8;
      *(void *)(a5 + 8) = v25;
      v21 -= 8;
      *(void *)(a5 + 24) = v24 + 1;
      *(void *)(a5 + 32) = v22 - 1;
    }

    *(_DWORD *)(a5 + 768) = (v25 >> v21) & 3;
    *(_DWORD *)(a5 + 16) = v21 + 2;
    *(_DWORD *)(a5 + 756) = 0;
LABEL_38:
    v55 = 0;
    v56 = a1 - 1;
    if (a1 != 1)
    {
      do
      {
        ++v55;
        v57 = v56 > 1;
        v56 >>= 1;
      }

      while (v57);
    }

    v58 = *(_DWORD *)(a5 + 756);
    v28 = *(unsigned int *)(a5 + 768);
    if (v58 <= v28)
    {
      v63 = *(_DWORD *)(a5 + 16);
      do
      {
        v64 = 64 - v63;
        if (64 - v63 >= v55)
        {
          v68 = *v10;
        }

        else
        {
          v65 = *(void *)(a5 + 32) - 1LL;
          do
          {
            if (v65 == -1)
            {
              *(_DWORD *)(a5 + 756) = v58;
              result = 2LL;
              *(_DWORD *)(a5 + 752) = 2;
              return result;
            }

            v66 = *(void *)(a5 + 8);
            *(void *)(a5 + 8) = v66 >> 8;
            v67 = *(unsigned __int8 **)(a5 + 24);
            *((void *)&v69 + 1) = *v67;
            *(void *)&v69 = v66;
            v68 = v69 >> 8;
            *(void *)(a5 + 8) = v68;
            v63 -= 8;
            *(_DWORD *)(a5 + 16) = v63;
            *(void *)(a5 + 24) = v67 + 1;
            *(void *)(a5 + 32) = v65--;
            v64 += 8;
          }

          while (v64 < v55);
        }

        v70 = (v68 >> v63) & ~(-1 << v55);
        v63 += v55;
        *(_DWORD *)(a5 + 16) = v63;
        if (v70 >= a2) {
          return 4294967292LL;
        }
        *(_WORD *)(a5 + 2LL * v58++ + 920) = v70;
      }

      while (v58 <= v28);
    }

    if (!(_DWORD)v28) {
      goto LABEL_109;
    }
    v59 = 0LL;
    do
    {
      v60 = a5 + 2 * v59++;
      v61 = *(unsigned __int16 *)(v60 + 920);
      v62 = v59;
      do
      {
        ++v62;
      }

      while (v62 <= v28);
    }

    while (v59 != v28);
LABEL_15:
    if ((_DWORD)v28 != 3) {
      goto LABEL_109;
    }
    v29 = *(_DWORD *)(a5 + 16);
    if (v29 != 64)
    {
      v33 = *v10;
      goto LABEL_108;
    }

    v30 = *(void *)(a5 + 32);
    if (v30)
    {
      v31 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v31 >> 8;
      v32 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v34 + 1) = *v32;
      *(void *)&v34 = v31;
      v33 = v34 >> 8;
      *(void *)(a5 + 8) = v33;
      *(void *)(a5 + 24) = v32 + 1;
      *(void *)(a5 + 32) = v30 - 1;
      v29 = 56;
LABEL_108:
      *(_DWORD *)(a5 + 16) = v29 + 1;
      LODWORD(v28) = ((v33 >> v29) & 1) + 3;
      *(_DWORD *)(a5 + 768) = v28;
LABEL_109:
      v105 = BrotliBuildSimpleHuffmanTable(__src, 8, (unsigned __int16 *)(a5 + 920), v28);
      if (a4) {
        *a4 = v105;
      }
      goto LABEL_157;
    }

    v48 = 3;
    goto LABEL_149;
  }

  v14 = (char *)a3 + v11;
  v15 = a4 - v11;
  *a1 = v8[3];
  if (v8[2] == 1297111641)
  {
    if (!*((_WORD *)v8 + 3))
    {
      v16 = *((unsigned __int16 *)v8 + 10);
      if (*((_WORD *)v8 + 10))
      {
        v17 = 0LL;
        v18 = 0;
        v19 = *((unsigned __int16 *)v8 + 9);
        while (!v19)
        {
LABEL_20:
          v18 += v9[12];
          if (v18 >= v16) {
            return v17;
          }
        }

        v20 = 0;
        while (1)
        {
          slice_width = get_slice_width(v9 + 9, v20);
          slice_height = get_slice_height((uint64_t)(v9 + 9), v18);
          rectangle_within_image = create_rectangle_within_image((uint64_t)a1, v20, v18, slice_width, slice_height);
          if (!rectangle_within_image) {
            break;
          }
          v24 = rectangle_within_image;
          v25 = yzip_image_decode(rectangle_within_image, a2, v14, v15);
          if (!v25)
          {
            free(v24);
            return 0LL;
          }

          v17 += v25;
          v26 = *(unsigned int *)v14;
          v14 += v26;
          v15 -= v26;
          free(v24);
          v20 += v9[11];
          v19 = v9[9];
          if (v20 >= v19)
          {
            v16 = v9[10];
            goto LABEL_20;
          }
        }
      }
    }

    return 0LL;
  }

  pool_size = get_pool_size((uint64_t)v8, 0);
  if ((yzip_codec_pool_init(a2, pool_size) & 0x80000000) != 0) {
    return 0LL;
  }
  decoder_list = yzip_jobs_create_decoder_list((uint64_t)a2, (uint64_t)a1, (uint64_t)v9, v14, v15);
  if (!decoder_list) {
    return 0LL;
  }
  v17 = yzip_jobs_decode((uint64_t)a2, decoder_list);
  if (v17 < 0) {
    return 0LL;
  }
  return v17;
}

_BYTE *zero_coder_encode(_BYTE *a1, uint64_t a2, int8x8_t *a3, uint64_t a4, double a5, int8x16_t a6)
{
  if (!zero_coder_luts_ok) {
    zero_coder_init_luts();
  }
  if (a2 < 9) {
    return 0LL;
  }
  unint64_t v10 = (unint64_t)a3 + a4;
  v11 = a1;
  while ((unint64_t)&a3[1] <= v10)
  {
    *(int8x8_t *)a6.i8 = *a3;
    int8x8_t v12 = vbic_s8((int8x8_t)0x8040201008040201LL, vceqz_s8(*a3));
    v12.i32[0] = vuzp1_s8( vorr_s8(vzip1_s8(v12, (int8x8_t)0x8040201008040201LL), vzip2_s8(v12, (int8x8_t)0x8040201008040201LL)),  (int8x8_t)0x8040201008040201LL).u32[0];
    _BYTE *v11 = v12.i8[0] | v12.i8[2] | ((unsigned __int16)(v12.i16[0] | v12.i16[1]) >> 8);
    uint64_t v13 = (v12.i8[0] | v12.i8[2] | ((unsigned __int16)(v12.i16[0] | v12.i16[1]) >> 8));
    *(int8x8_t *)(v11 + 1) = vqtbl1_s8(a6, *(int8x8_t *)&zero_coder_lut_write[8 * v13]);
    v11 += zero_coder_lut_popcount[v13] + 1;
    ++a3;
    if (v11 + 9 > &a1[a2]) {
      return 0LL;
    }
  }

  if ((unint64_t)a3 >= v10)
  {
    v17 = v11;
  }

  else
  {
    char v15 = 0;
    int v16 = 0;
    v17 = v11 + 1;
    int v18 = -1 << (a4 & 7);
    unsigned __int8 v19 = 1;
    v20 = a3;
    do
    {
      int v21 = v20->u8[0];
      if (v21)
      {
        *v17++ = v21;
        v18 |= 1 << v15;
      }

      char v15 = ++v16;
      v20 = (int8x8_t *)((char *)a3 + v19++);
    }

    while ((unint64_t)v20 < v10);
    _BYTE *v11 = v18;
  }

  return (_BYTE *)(v17 - a1);
}

__int16 zero_coder_init_luts@<H0>()
{
  zero_coder_luts_ok = 1;
  memset(zero_coder_lut_write, 128, sizeof(zero_coder_lut_write));
  memset(zero_coder_lut_read, 128, sizeof(zero_coder_lut_read));
  for (uint64_t i = 0LL; i != 256; ++i)
  {
    unsigned int v2 = 0;
    for (unsigned int j = 0; j != 8; ++j)
    {
      if (((i >> j) & 1) != 0)
      {
        zero_coder_lut_write[8 * i + v2] = j;
        zero_coder_lut_read[8 * i + j] = v2++;
      }
    }

    v0.i32[0] = i;
    int8x8_t v0 = vcnt_s8(v0);
    v0.i16[0] = vaddlv_u8((uint8x8_t)v0);
    zero_coder_lut_popcount[i] = v0.i8[0];
  }

  return v0.i16[0];
}

uint64_t BrotliBuildCodeLengthsHuffmanTable(uint64_t result, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v3 = 0LL;
  uint64_t v36 = *MEMORY[0x1895F89C0];
  int v4 = a3[1] - 1;
  int v5 = v4 + a3[2] + a3[3];
  v34[2] = v4 + a3[2];
  v34[3] = v5;
  int v6 = v5 + a3[4];
  int v7 = v6 + a3[5];
  v34[4] = v6;
  v34[5] = v7;
  v34[0] = 17;
  v34[1] = v4;
  uint64_t v8 = a2 + 17;
  do
  {
    uint64_t v9 = *(unsigned __int8 *)(v8 + v3);
    uint64_t v10 = (int)v34[v9];
    v35[v10] = v3 + 17;
    v34[v9] = v10 - 1;
    uint64_t v11 = *(unsigned __int8 *)(v8 + v3 - 1);
    uint64_t v12 = (int)v34[v11];
    v34[v11] = v12 - 1;
    uint64_t v13 = *(unsigned __int8 *)(v8 + v3 - 2);
    uint64_t v14 = (int)v34[v13];
    v35[v12] = v3 + 16;
    v35[v14] = v3 + 15;
    v34[v13] = v14 - 1;
    uint64_t v15 = *(unsigned __int8 *)(v8 + v3 - 3);
    uint64_t v16 = (int)v34[v15];
    v34[v15] = v16 - 1;
    uint64_t v17 = *(unsigned __int8 *)(v8 + v3 - 4);
    uint64_t v18 = (int)v34[v17];
    v35[v16] = v3 + 14;
    v35[v18] = v3 + 13;
    v34[v17] = v18 - 1;
    uint64_t v19 = *(unsigned __int8 *)(v8 + v3 - 5);
    uint64_t v20 = (int)v34[v19];
    v34[v19] = v20 - 1;
    v35[v20] = v3 + 12;
    v3 -= 6LL;
  }

  while (v3 != -18);
  if (v34[0])
  {
    unint64_t v21 = 0LL;
    LODWORD(v22) = 0;
    int v23 = 2;
    unint64_t v24 = 0x8000000000000000LL;
    for (uint64_t i = 1LL; i != 6; ++i)
    {
      int v26 = a3[i];
      if (a3[i])
      {
        uint64_t v27 = -v23;
        uint64_t v22 = (int)v22;
        do
        {
          int v28 = i | (v35[v22] << 16);
          unint64_t v29 = result - 4LL * v23 + 4 * __rbit64(v21);
          uint64_t v30 = 32LL;
          do
          {
            *(_DWORD *)(v29 + 4 * v30) = v28;
            BOOL v31 = __OFADD__(v30, v27);
            v30 += v27;
          }

          while (!((v30 < 0) ^ v31 | (v30 == 0)));
          ++v22;
          v21 += v24;
          --v26;
        }

        while (v26);
      }

      v23 *= 2;
      v24 >>= 1;
    }
  }

  else
  {
    uint64_t v32 = 0LL;
    int32x4_t v33 = vdupq_n_s32(v35[0] << 16);
    do
    {
      *(int32x4_t *)(result + v32) = v33;
      v32 += 16LL;
    }

    while (v32 != 128);
  }

  return result;
}

uint64_t BrotliBuildHuffmanTable(char *__src, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = -1LL;
  do
    int v9 = *(__int16 *)(a3 + 2 * v8--);
  while (v9 == -1);
  unint64_t v10 = 0LL;
  int v11 = v8 + 17;
  uint64_t v12 = 1LL;
  uint64_t v13 = (1 << a2);
  if (v11 >= a2) {
    int v14 = a2;
  }
  else {
    int v14 = v11;
  }
  if (v11 >= a2) {
    int v15 = 1 << a2;
  }
  else {
    int v15 = 1 << v11;
  }
  uint64_t v16 = v14;
  int v17 = 2;
  unint64_t v18 = 0x8000000000000000LL;
  do
  {
    int v19 = *(unsigned __int16 *)(a4 + 2 * v12);
    if (*(_WORD *)(a4 + 2 * v12))
    {
      int v20 = v12 - 16;
      do
      {
        int v20 = *(unsigned __int16 *)(a3 + 2LL * v20);
        unint64_t v21 = &__src[4 * __rbit64(v10)];
        int v22 = v15;
        do
        {
          *(_DWORD *)&v21[4 * (v22 - v17)] = v12 | (v20 << 16);
          v22 -= v17;
        }

        while (v22 > 0);
        v10 += v18;
        --v19;
      }

      while (v19);
    }

    v17 *= 2;
    v18 >>= 1;
  }

  while (v12++ < v16);
  if ((_DWORD)v13 != v15)
  {
    do
    {
      memcpy(&__src[4 * v15], __src, 4LL * v15);
      BOOL v24 = (_DWORD)v13 == 2 * v15;
      v15 *= 2;
    }

    while (!v24);
  }

  if (v11 > a2)
  {
    unint64_t v25 = 0LL;
    uint64_t v26 = a2;
    uint64_t v27 = v11;
    char v28 = a2 + 1;
    uint64_t v29 = a4 + 2LL * a2 + 2;
    unint64_t v30 = 0x8000000000000000LL;
    int v31 = 2;
    uint64_t v32 = __src;
    int v33 = 1 << a2;
    do
    {
      uint64_t v34 = v26 + 1;
      if (*(_WORD *)(a4 + 2 * (v26 + 1)))
      {
        int v35 = v26 - 15;
        do
        {
          if (!v25)
          {
            unsigned __int8 v36 = v26 + 1;
            if (v26 <= 13)
            {
              uint64_t v37 = 0LL;
              int v38 = 1 << (v34 - a2);
              while (1)
              {
                int v39 = v38 - *(unsigned __int16 *)(v29 + 2 * v37);
                if (v39 < 1) {
                  break;
                }
                int v38 = 2 * v39;
                ++v37;
                if (v26 + v37 >= 14)
                {
                  unsigned __int8 v36 = 15;
                  goto LABEL_30;
                }
              }

              unsigned __int8 v36 = v28 + v37;
            }

LABEL_30:
            v32 += 4 * v33;
            int v33 = 1 << (v36 - a2);
            uint64_t v13 = (v33 + v13);
            unint64_t v40 = __rbit64(v10);
            v10 += 0x8000000000000000LL >> (a2 - 1);
            *(_DWORD *)&__src[4 * v40] = v36 | (((((_DWORD)v32 - (_DWORD)__src) >> 2) - (_DWORD)v40) << 16);
          }

          int v35 = *(unsigned __int16 *)(a3 + 2LL * v35);
          v41 = &v32[4 * __rbit64(v25)];
          int v42 = v33;
          do
          {
            *(_DWORD *)&v41[4 * (v42 - v31)] = (v34 - a2) | (v35 << 16);
            v42 -= v31;
          }

          while (v42 > 0);
          v25 += v30;
          __int16 v43 = *(_WORD *)(a4 + 2 * v34) - 1;
          *(_WORD *)(a4 + 2 * v34) = v43;
        }

        while (v43);
      }

      v31 *= 2;
      v30 >>= 1;
      ++v28;
      v29 += 2LL;
      ++v26;
    }

    while (v34 < v27);
  }

  return v13;
}

          *(void *)(a1 + 24) = v1;
          *(void *)(a1 + 120) = (char *)v2 - *(void *)a1;
          *(void *)(a1 + 104) = v3;
          *(_DWORD *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 72) = v5;
          *(_DWORD *)(a1 + 88) = v6;
          *(_DWORD *)(a1 + 92) = v7;
          *(_DWORD *)(a1 + 96) = v8;
          *(_WORD *)(a1 + 124) = v9;
          *(_WORD *)(a1 + 126) = v10;
          *(_WORD *)(a1 + 128) = v11;
          *(void *)(a1 + 80) = v13;
          return -2LL;
        }

uint64_t BrotliBuildSimpleHuffmanTable(int *__src, char a2, unsigned __int16 *a3, int a4)
{
  unsigned int v5 = 1;
  uint64_t v6 = (1 << a2);
  switch(a4)
  {
    case 0:
      *__src = *a3 << 16;
      unsigned int v5 = 1;
      break;
    case 1:
      unsigned int v7 = a3[1];
      unsigned int v8 = *a3;
      if (v7 <= v8)
      {
        *__src = (v7 << 16) | 1;
        int v9 = (*a3 << 16) | 1;
      }

      else
      {
        *__src = (v8 << 16) | 1;
        int v9 = (a3[1] << 16) | 1;
      }

      __src[1] = v9;
      unsigned int v5 = 2;
      break;
    case 2:
      *__src = (*a3 << 16) | 1;
      __src[2] = (*a3 << 16) | 1;
      unsigned int v10 = a3[2];
      unsigned int v11 = a3[1];
      if (v10 > v11)
      {
        __src[1] = (v11 << 16) | 2;
        int v12 = (a3[2] << 16) | 2;
        goto LABEL_21;
      }

      __src[1] = (v10 << 16) | 2;
      int v19 = a3[1];
      goto LABEL_20;
    case 3:
      uint64_t v13 = 0LL;
      uint64_t v14 = 2LL;
      do
      {
        uint64_t v15 = v13++;
        unsigned __int16 v16 = a3[v15];
        uint64_t v17 = v14;
        do
        {
          unsigned int v18 = *(unsigned __int16 *)((char *)a3 + v17);
          if (v18 < v16)
          {
            *(unsigned __int16 *)((char *)a3 + v17) = v16;
            a3[v15] = v18;
            unsigned __int16 v16 = v18;
          }

          v17 += 2LL;
        }

        while (v17 != 8);
        v14 += 2LL;
      }

      while (v13 != 3);
      *__src = (*a3 << 16) | 2;
      __src[2] = (a3[1] << 16) | 2;
      __src[1] = (a3[2] << 16) | 2;
      int v19 = a3[3];
LABEL_20:
      int v12 = (v19 << 16) | 2;
LABEL_21:
      __src[3] = v12;
      unsigned int v5 = 4;
      break;
    case 4:
      unsigned int v20 = a3[3];
      unsigned int v21 = a3[2];
      if (v20 < v21)
      {
        a3[3] = v21;
        a3[2] = v20;
      }

      *__src = (*a3 << 16) | 1;
      __src[1] = (a3[1] << 16) | 2;
      __src[2] = (*a3 << 16) | 1;
      __src[3] = (a3[2] << 16) | 3;
      __src[4] = (*a3 << 16) | 1;
      __src[5] = (a3[1] << 16) | 2;
      __src[6] = (*a3 << 16) | 1;
      __src[7] = (a3[3] << 16) | 3;
      unsigned int v5 = 8;
      break;
    default:
      break;
  }

  while (v5 != (_DWORD)v6)
  {
    memcpy(&__src[v5], __src, 4LL * v5);
    v5 *= 2;
  }

  return v6;
}

const char *zlibVersion(void)
{
  return "1.2.5";
}

uLong zlibCompileFlags(void)
{
  return 169LL;
}

const char *__cdecl zError(int a1)
{
  return z_errmsg[2LL - a1];
}

void zcalloc(uint64_t a1, int a2, int a3)
{
  size_t v3 = (a3 * a2);
  int v4 = malloc(v3);
  bzero(v4, v3);
}

void zcfree(int a1, void *a2)
{
}

uint64_t lzvnDecode(uint64_t a1)
{
  v1 = *(char **)a1;
  unint64_t v2 = *(void *)(a1 + 8) - *(void *)a1;
  size_t v3 = *(_DWORD **)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 32) - (void)v3;
  if (*(void *)(a1 + 8) == *(void *)a1 || *(void *)(a1 + 32) == (void)v3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v10 = *(void *)(a1 + 48);
  unint64_t v9 = *(void *)(a1 + 56);
  unint64_t v8 = a1 + 48;
  if (!v10)
  {
    if (!v9) {
      return lzvnDecode_opc_tbl[*v1](a1, v8);
    }
    unint64_t v11 = *(void *)(a1 + 64);
    *(void *)unint64_t v8 = 0LL;
    *(void *)(a1 + 56) = 0LL;
    *(void *)(a1 + 64) = 0LL;
    goto LABEL_19;
  }

  unint64_t v11 = *(void *)(a1 + 64);
  *(void *)unint64_t v8 = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  if (v9)
  {
    if (v4 < 4 || v2 < 4)
    {
      unint64_t v13 = v10 - v4;
      if (v10 > v4)
      {
        if (v4)
        {
          unsigned int v21 = v1;
          int v22 = v3;
          unint64_t v23 = v4;
          do
          {
            char v24 = *v21++;
            *v22++ = v24;
            --v23;
          }

          while (v23);
        }

        *(void *)a1 = &v1[v4];
        *(void *)(a1 + 16) = (char *)v3 + v4;
        *(void *)(a1 + 48) = v13;
        *(void *)(a1 + 56) = v9;
        goto LABEL_40;
      }

      uint64_t v14 = v1;
      uint64_t v15 = v3;
      unint64_t v16 = v10;
      do
      {
        char v17 = *v14++;
        *v15++ = v17;
        --v16;
      }

      while (v16);
    }

    else
    {
      *size_t v3 = *(_DWORD *)v1;
    }

    size_t v3 = (_DWORD *)((char *)v3 + v10);
    v4 -= v10;
    v1 += v10;
LABEL_19:
    if (v4 < v9 + 7 || v11 < 8)
    {
      unint64_t v18 = v9 - v4;
      if (v9 > v4)
      {
        if (v4)
        {
          unint64_t v25 = v3;
          unint64_t v26 = v4;
          do
          {
            *unint64_t v25 = v25[-v11];
            ++v25;
            --v26;
          }

          while (v26);
        }

        *(void *)a1 = v1;
        *(void *)(a1 + 16) = (char *)v3 + v4;
        *(void *)(a1 + 48) = 0LL;
        *(void *)(a1 + 56) = v18;
        goto LABEL_40;
      }

      int v19 = v3;
      unint64_t v20 = v9;
      do
      {
        *int v19 = v19[-v11];
        ++v19;
        --v20;
      }

      while (v20);
    }

    else
    {
      for (unint64_t i = 0LL; i < v9; i += 8LL)
        *(void *)&v3[i / 4] = *(void *)((char *)&v3[i / 4] - v11);
    }

    return ((uint64_t (*)(void))lzvnDecode_opc_tbl[*v1])();
  }

  if (v2 <= v10) {
    return 0xFFFFFFFFLL;
  }
  if (v4 >= v10 + 7 && v2 >= v10 + 7)
  {
    for (unint64_t j = 0LL; j < v10; j += 8LL)
      *(void *)&v3[j / 4] = *(void *)&v1[j];
    goto LABEL_52;
  }

  unint64_t v28 = v10 - v4;
  if (v10 > v4)
  {
    if (v4)
    {
      uint64_t v34 = v1;
      int v35 = v3;
      unint64_t v36 = v4;
      do
      {
        char v37 = *v34++;
        *v35++ = v37;
        --v36;
      }

      while (v36);
    }

    *(void *)a1 = &v1[v4];
    *(void *)(a1 + 16) = (char *)v3 + v4;
    *(void *)(a1 + 48) = v28;
    *(void *)(a1 + 56) = 0LL;
LABEL_40:
    uint64_t v6 = 4294967294LL;
    *(void *)(a1 + 64) = v11;
    return v6;
  }

  uint64_t v29 = v1;
  unint64_t v30 = v3;
  unint64_t v31 = v10;
  do
  {
    unsigned int v32 = *v29++;
    unint64_t v8 = v32;
    *v30++ = v32;
    --v31;
  }

  while (v31);
LABEL_52:
  v1 += v10;
  return lzvnDecode_opc_tbl[*v1](a1, v8);
}

uint64_t lzvn_decode_buffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 <= a3 + a4 - 8) {
      __asm { BR              X17 }
    }

    __asm { BTI             j }

    return 0LL;
  }

  else
  {
    __asm { BTI             j }

    return 0LL;
  }
}

uint64_t lz4_encode_buffer(int32x4_t *a1, unint64_t a2, char *a3, unint64_t a4, char *__b)
{
  unsigned int v7 = a3;
  char v24 = a3;
  memset_pattern8(__b, &unk_181076880, 0x8000uLL);
  int v22 = a1;
  if (a4)
  {
    uint64_t v10 = (uint64_t)v7;
    unint64_t v11 = a1;
    while (1)
    {
      if (a2 < 0xC) {
        return 0LL;
      }
      unint64_t v12 = a4 >= 0x10000 ? 0x10000LL : a4;
      unint64_t v13 = (int32x4_t *)((char *)&v11->u64[1] + 4);
      unint64_t v23 = (int32x4_t *)((char *)&v11->u64[1] + 4);
      lz4_encode_2gb(&v23, a2 - 12, &v24, v10, v12, (uint64_t)__b, 0LL);
      if (v24 - v7 < v12) {
        break;
      }
      if (v23 == v13) {
        goto LABEL_12;
      }
      int v14 = (_DWORD)v23 - (_DWORD)v13;
      int64_t v15 = (char *)v23 - (char *)v11;
      v11->i32[0] = 825521762;
      v11->i32[1] = v12;
      v11->i32[2] = v14;
      unint64_t v11 = v23;
      unsigned int v7 = v24;
      a2 -= v15;
LABEL_15:
      if ((uint64_t)&v7[-v10] >= 1610612736)
      {
        for (uint64_t i = 0LL; i != 0x8000; i += 8LL)
        {
          unsigned int v19 = *(_DWORD *)&__b[i];
          if (v19 != 0x80000000)
          {
            if (v19 >> 30) {
              unsigned int v20 = v19 - 0x40000000;
            }
            else {
              unsigned int v20 = 0x80000000;
            }
            *(_DWORD *)&__b[i] = v20;
          }
        }

        v10 += 0x40000000LL;
      }

      a4 -= v12;
      if (!a4) {
        goto LABEL_27;
      }
    }

    unint64_t v23 = (int32x4_t *)((char *)&v11->u64[1] + 4);
    char v24 = &v7[v12];
LABEL_12:
    v11->i32[0] = 758412898;
    v11->i32[1] = v12;
    BOOL v16 = a2 - 8 >= v12;
    a2 = a2 - 8 - v12;
    if (!v16) {
      return 0LL;
    }
    char v17 = &v11->u64[1];
    unsigned int v7 = v24;
    memcpy(v17, &v24[-v12], v12);
    unint64_t v11 = (int32x4_t *)((char *)v17 + v12);
    goto LABEL_15;
  }

  unint64_t v11 = a1;
LABEL_27:
  if (a2 < 4) {
    return 0LL;
  }
  v11->i32[0] = 607417954;
  return (char *)v11 - (char *)v22 + 4;
}

uint64_t BrotliEncoderSetParameter(uint64_t a1, int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 8636)) {
    return 0LL;
  }
  switch(a2)
  {
    case 0:
      *(_DWORD *)a1 = a3;
      break;
    case 1:
      *(_DWORD *)(a1 + 4) = a3;
      break;
    case 2:
      *(_DWORD *)(a1 + 8) = a3;
      break;
    case 3:
      *(_DWORD *)(a1 + 12) = a3;
      break;
    case 4:
      if (a3 > 1) {
        return 0LL;
      }
      *(_DWORD *)(a1 + 32) = a3 != 0;
      break;
    case 5:
      *(void *)(a1 + 24) = a3;
      break;
    case 6:
      *(_DWORD *)(a1 + 36) = a3 != 0;
      break;
    case 7:
      *(_DWORD *)(a1 + 64) = a3;
      break;
    case 8:
      *(_DWORD *)(a1 + 68) = a3;
      break;
    case 9:
      if (a3 > 0x40000000) {
        return 0LL;
      }
      *(void *)(a1 + 16) = a3;
      break;
    default:
      return 0LL;
  }

  return 1LL;
}

char *BrotliEncoderCreateInstance( void *(*a1)(int a1, size_t __size), void (*a2)(int a1, void *a2), uint64_t a3)
{
  if ((unint64_t)a1 | (unint64_t)a2)
  {
    uint64_t v6 = 0LL;
    if (!a1 || !a2) {
      return v6;
    }
    unsigned int v7 = (char *)a1(a3, 8640LL);
  }

  else
  {
    unsigned int v7 = (char *)malloc(0x21C0uLL);
  }

  uint64_t v6 = v7;
  if (v7)
  {
    BrotliInitMemoryManager((uint64_t)(v7 + 144), a1, a2, a3);
    *((_DWORD *)v6 + 9) = 0;
    *(void *)uint64_t v6 = 0xB00000000LL;
    *((_DWORD *)v6 + 2) = 22;
    *(void *)(v6 + 12) = 0LL;
    *(_OWORD *)(v6 + 20) = 0u;
    BrotliInitEncoderDictionary((uint64_t)(v6 + 88));
    *((_OWORD *)v6 + 4) = xmmword_181076E20;
    *((void *)v6 + 10) = 67108860LL;
    *((void *)v6 + 281) = 0LL;
    *((_WORD *)v6 + 1218) = 0;
    *((_DWORD *)v6 + 2157) = 0;
    *((void *)v6 + 1079) = 0LL;
    *((_OWORD *)v6 + 142) = 0u;
    *((_OWORD *)v6 + 143) = 0u;
    *((_OWORD *)v6 + 144) = 0u;
    *((_OWORD *)v6 + 145) = 0u;
    *((_OWORD *)v6 + 146) = 0u;
    *((void *)v6 + 305) = 0LL;
    *((_OWORD *)v6 + 153) = 0u;
    *((_OWORD *)v6 + 478) = 0u;
    *((_OWORD *)v6 + 537) = 0u;
    *((_OWORD *)v6 + 536) = 0u;
    *((_OWORD *)v6 + 535) = 0u;
    *((_OWORD *)v6 + 147) = xmmword_181076E30;
    *((_OWORD *)v6 + 151) = *((_OWORD *)v6 + 147);
  }

  return v6;
}

uint64_t BrotliEncoderDestroyInstance(uint64_t result)
{
  if (result)
  {
    v1 = (unint64_t *)result;
    uint64_t v2 = result + 144;
    uint64_t v3 = *(void *)(result + 160);
    unsigned int v5 = *(uint64_t (**)(uint64_t, unint64_t *))(result + 152);
    if (*(_DWORD *)(result + 168))
    {
      BrotliWipeOutMemoryManager(result + 144);
    }

    else
    {
      BrotliFree(result + 144, *(void *)(result + 2448));
      v1[306] = 0LL;
      BrotliFree(v2, v1[288]);
      v1[288] = 0LL;
      BrotliFree(v2, v1[285]);
      v1[285] = 0LL;
      unint64_t v4 = v1[307];
      if (v4)
      {
        BrotliFree(v2, v4);
        v1[307] = 0LL;
      }

      BrotliFree(v2, v1[956]);
      v1[956] = 0LL;
      BrotliFree(v2, v1[1071]);
      v1[1071] = 0LL;
      BrotliFree(v2, v1[1072]);
      v1[1072] = 0LL;
    }

    return v5(v3, v1);
  }

  return result;
}

uint64_t BrotliEncoderMaxCompressedSize(unint64_t a1)
{
  unint64_t v1 = a1 + 4 * (a1 >> 14) + 6;
  if (v1 < a1) {
    unint64_t v1 = 0LL;
  }
  if (a1) {
    return v1;
  }
  else {
    return 2LL;
  }
}

uint64_t BrotliEncoderCompress( int a1, int a2, int a3, unint64_t a4, uint64_t *a5, unint64_t *a6, _BYTE *a7)
{
  unsigned int v7 = a7;
  unint64_t v8 = a6;
  uint64_t v236 = *MEMORY[0x1895F89C0];
  unint64_t v9 = *a6;
  if (!a4)
  {
    if (v9)
    {
      uint64_t result = 1LL;
      *a6 = 1LL;
      *a7 = 6;
      return result;
    }

    return 0LL;
  }

  unint64_t v10 = a4;
  unint64_t v11 = a4 + 4 * (a4 >> 14) + 6;
  if (v11 < a4) {
    unint64_t v11 = 0LL;
  }
  if (v9)
  {
    unint64_t v178 = v11;
    if (a1 != 10)
    {
      unint64_t v22 = *a6;
      uint64_t result = (uint64_t)BrotliEncoderCreateInstance(0LL, 0LL, 0LL);
      if (!result) {
        return result;
      }
      uint64_t v23 = result;
      v232[0] = v10;
      *(void *)&__int128 v206 = a5;
      *(void *)&v195[0] = *v8;
      *(void *)v229 = v7;
      *(void *)&v189[0] = 0LL;
      if (!*(_DWORD *)(result + 8636))
      {
        *(_DWORD *)(result + 4) = a1;
        *(_DWORD *)(result + 8) = a2;
        *(_DWORD *)uint64_t result = a3;
        *(void *)(result + 24) = v10;
        if (a2 >= 25) {
          *(_DWORD *)(result + 36) = 1;
        }
      }

      int v24 = BrotliEncoderCompressStream( result,  2,  v232,  (const void **)&v206,  (size_t *)v195,  (void **)v229,  (size_t *)v189);
      if (*(_DWORD *)(v23 + 8628) == 2 && !*(void *)(v23 + 8592)) {
        int v25 = v24;
      }
      else {
        int v25 = 0;
      }
      *unint64_t v8 = *(void *)&v189[0];
      BrotliEncoderDestroyInstance(v23);
      unint64_t v26 = v178;
      if (v25 && (!v178 || *v8 <= v178)) {
        return 1LL;
      }
      unint64_t v9 = v22;
      goto LABEL_321;
    }

    if (a2 <= 16) {
      int v15 = 16;
    }
    else {
      int v15 = a2;
    }
    if (v15 >= 30) {
      unsigned int v16 = 30;
    }
    else {
      unsigned int v16 = v15;
    }
    __int128 v234 = xmmword_181076E30;
    __int128 v235 = xmmword_181076E30;
    *(void *)&__int128 v206 = 0LL;
    *(void *)v229 = 0xB00000000LL;
    if (a4 >= 1LL << v16) {
      unint64_t v17 = 1LL << v16;
    }
    else {
      unint64_t v17 = a4;
    }
    if (v15 >= 23) {
      char v18 = 23;
    }
    else {
      char v18 = v15;
    }
    memset(&v229[12], 0, 28);
    BrotliInitEncoderDictionary((uint64_t)v231 + 8);
    __int128 v230 = xmmword_181076E20;
    *(void *)&v231[0] = 67108860LL;
    *(_DWORD *)&v229[8] = v16;
    char v177 = v16;
    if (v16 < 0x19)
    {
      unsigned int v19 = 24;
    }

    else
    {
      *(_DWORD *)&v229[36] = 1;
      unsigned int v19 = 30;
    }

    *(_DWORD *)&v229[4] = 10;
    int v27 = v16;
    unint64_t v8 = a6;
    if (v19 < v16)
    {
      *(_DWORD *)&v229[8] = v19;
      int v27 = v19;
    }

    if (v27 >= 18) {
      int v28 = 18;
    }
    else {
      int v28 = v27;
    }
    *(_DWORD *)&v229[12] = v28;
    ChooseDistanceParams(v229);
    char v29 = v229[12];
    BrotliInitMemoryManager((uint64_t)v232, 0LL, 0LL, 0LL);
    if (*(_DWORD *)&v229[36])
    {
      char v30 = 17;
      uint64_t v31 = 14LL;
    }

    else if (v16 == 16)
    {
      char v30 = 0;
      char v177 = 0;
      uint64_t v31 = 1LL;
    }

    else
    {
      if (v16 != 17)
      {
        char v30 = 2 * v16 - 33;
        uint64_t v174 = 4LL;
        char v177 = 0;
LABEL_45:
        int v32 = *(_DWORD *)&v229[4];
        if (*(int *)&v229[4] < 10)
        {
          if (*(_DWORD *)&v229[4] == 4)
          {
            if (*(void *)&v229[24] >= 0x100000uLL) {
              int v32 = 54;
            }
          }

          else if (*(int *)&v229[4] > 4)
          {
            if (*(int *)&v229[8] > 16)
            {
              if (*(_DWORD *)&v229[8] < 0x13u || *(void *)&v229[24] < 0x100000uLL)
              {
                if (*(_DWORD *)&v229[4] >= 9u) {
                  int v39 = 16;
                }
                else {
                  int v39 = 10;
                }
                if (*(_DWORD *)&v229[4] < 7u) {
                  int v40 = 14;
                }
                else {
                  int v40 = 15;
                }
                *(_DWORD *)&v229[40] = 5;
                *(_DWORD *)&v229[44] = v40;
                if (*(_DWORD *)&v229[4] >= 7u) {
                  int v41 = v39;
                }
                else {
                  int v41 = 4;
                }
                *(_DWORD *)&v229[48] = *(_DWORD *)&v229[4] - 1;
                *(_DWORD *)&v229[56] = v41;
                int v32 = 5;
              }

              else
              {
                *(void *)&v229[40] = 0xF00000006LL;
                *(_DWORD *)&v229[48] = *(_DWORD *)&v229[4] - 1;
                *(_DWORD *)&v229[52] = 5;
                if (*(_DWORD *)&v229[4] >= 9u) {
                  int v36 = 16;
                }
                else {
                  int v36 = 10;
                }
                if (*(_DWORD *)&v229[4] >= 7u) {
                  int v37 = v36;
                }
                else {
                  int v37 = 4;
                }
                *(_DWORD *)&v229[56] = v37;
                int v32 = 6;
              }

LABEL_48:
              if (*(int *)&v229[8] < 25)
              {
                int v33 = 0LL;
                switch(v32)
                {
                  case 2:
                  case 3:
                  case 4:
                  case 10:
                    goto LABEL_84;
                  case 5:
                  case 6:
LABEL_55:
                    uint64_t v34 = (4LL << v229[44] << v229[48]) + (2LL << v229[44]);
LABEL_83:
                    if (v34) {
LABEL_84:
                    }
                      int v33 = (_OWORD *)BrotliAllocate((uint64_t)v232);
                    else {
                      int v33 = 0LL;
                    }
                    break;
                  case 7:
                  case 8:
                  case 9:
                    break;
                  default:
                    switch(v32)
                    {
                      case '#':
                      case '(':
                      case ')':
                      case '*':
                        goto LABEL_84;
                      case '$':
                      case '%':
                      case '&':
                      case '\'':
                        goto LABEL_85;
                      default:
                        if (v32 == 54) {
                          goto LABEL_84;
                        }
                        break;
                    }

                    break;
                }
              }

              else
              {
                int v33 = 0LL;
                switch(v32)
                {
                  case 2:
                  case 4:
                  case 10:
                    goto LABEL_84;
                  case 3:
                    *(_DWORD *)&v229[40] = 35;
                    goto LABEL_84;
                  case 5:
                    goto LABEL_55;
                  case 6:
                    *(_DWORD *)&v229[40] = 65;
                    uint64_t v34 = (2LL << v229[44]) + 0x4000000 + (4LL << v229[44] << v229[48]);
                    goto LABEL_83;
                  case 7:
                  case 8:
                  case 9:
                    break;
                  default:
                    switch(v32)
                    {
                      case '#':
                      case '(':
                      case ')':
                      case '*':
                        goto LABEL_84;
                      case '$':
                      case '%':
                      case '&':
                      case '\'':
                        goto LABEL_85;
                      default:
                        if (v32 != 54) {
                          goto LABEL_85;
                        }
                        *(_DWORD *)&v229[40] = 55;
                        break;
                    }

                    goto LABEL_84;
                }
              }

        int v35 = *(_DWORD *)v29;
        char v29 = (uint64_t *)((char *)v29 + 4);
        *(_DWORD *)char v30 = v35;
        char v30 = (void *)((char *)v30 + 4);
        if ((v24 & 2) == 0)
        {
LABEL_40:
          if ((v24 & 1) == 0) {
            goto LABEL_42;
          }
LABEL_41:
          *(_BYTE *)char v30 = *(_BYTE *)v29;
          goto LABEL_42;
        }

LABEL_85:
              *(void *)&__int128 v206 = v33;
              if (!v233)
              {
                *(_OWORD *)&v207[8] = *(_OWORD *)&v229[40];
                *(_DWORD *)&v207[24] = *(_DWORD *)&v229[56];
                if (*(int *)&v229[40] <= 34)
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case 2:
                    case 3:
                    case 4:
                      goto LABEL_99;
                    case 5:
                      unint64_t v208 = 1LL << v207[12];
                      v209 = (void *)(1LL << v207[16]);
                      LODWORD(__b) = 32 - *(_DWORD *)&v207[12];
                      HIDWORD(__b) = (1LL << v207[16]) - 1;
                      v212 = &v206;
                      v213 = v33;
                      v214 = (_OWORD *)((char *)v33 + 2 * (1LL << v207[12]));
                      v211 = (__int128 *)__PAIR64__(*(unsigned int *)&v207[24], *(unsigned int *)&v207[16]);
                      break;
                    case 6:
                      LODWORD(__b) = 64 - *(_DWORD *)&v207[12];
                      v211 = (__int128 *)(0xFFFFFFFFFFFFFFFFLL >> (-8 * v207[20]));
                      unint64_t v208 = 1LL << v207[12];
                      v209 = (void *)(1LL << v207[16]);
                      HIDWORD(v212) = *(_DWORD *)&v207[16];
                      LODWORD(v212) = (1LL << v207[16]) - 1;
                      LODWORD(v213) = *(_DWORD *)&v207[24];
                      v214 = &v206;
                      *(void *)&__int128 v215 = v33;
                      *((void *)&v215 + 1) = (char *)v33 + 2 * (1LL << v207[12]);
                      break;
                    case 0xA:
                      v211 = v33 + 0x8000;
                      v209 = v33;
                      unint64_t v208 = ~(-1 << v229[8]);
                      LODWORD(__b) = (-1 << v229[8]) + 1;
                      break;
                    default:
                      break;
                  }
                }

                else if (*(int *)&v229[40] > 53)
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case '6':
LABEL_99:
                      unint64_t v208 = (unint64_t)&v206;
                      v209 = v33;
                      break;
                    case '7':
LABEL_101:
                      *(void *)&__int128 v219 = &v206;
                      v218 = v33;
                      __int128 v215 = v206;
                      __int128 v216 = *(_OWORD *)v207;
                      __int128 v217 = *(_OWORD *)&v207[16];
                      DWORD2(v219) = 1;
                      *(void *)&__int128 v220 = v229;
                      break;
                    case 'A':
                      v223 = &v206;
                      v222 = v33;
                      __int128 v219 = v206;
                      __int128 v220 = *(_OWORD *)v207;
                      __int128 v221 = *(_OWORD *)&v207[16];
                      int v224 = 1;
                      v225 = v229;
                      break;
                  }
                }

                else
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case '#':
                      goto LABEL_101;
                    case '(':
                    case ')':
                      v211 = &v206;
                      else {
                        int v38 = 8;
                      }
                      __b = v33;
                      v209 = (void *)(v38 << (v229[4] - 4));
                      break;
                    case '*':
                      v228 = &v206;
                      v227 = v33;
                      else {
                        int v42 = 8;
                      }
                      uint64_t v226 = (v42 << (v229[4] - 4));
                      break;
                    default:
                      break;
                  }
                }

                *(_DWORD *)&v207[28] = 0;
                if (*(int *)&v229[40] <= 34)
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case 2:
                      __int16 v43 = v209;
                      if (v17 > 0x800) {
                        goto LABEL_150;
                      }
                      v44 = a5;
                      unint64_t v45 = v17;
                      do
                      {
                        uint64_t v46 = *v44;
                        v44 = (uint64_t *)((char *)v44 + 1);
                        *(_DWORD *)((char *)v43 + (((0xBD1E35A7BD000000LL * v46) >> 46) & 0x3FFFC)) = 0;
                        --v45;
                      }

                      while (v45);
                      break;
                    case 3:
                      __int16 v43 = v209;
                      if (v17 > 0x800)
                      {
LABEL_150:
                        size_t v59 = 0x40000LL;
                        goto LABEL_180;
                      }

                      v47 = a5;
                      unint64_t v48 = v17;
                      do
                      {
                        uint64_t v49 = *v47;
                        v47 = (uint64_t *)((char *)v47 + 1);
                        unint64_t v50 = (0xBD1E35A7BD000000LL * v49) >> 48;
                        v43[v50] = 0;
                        v43[(unsigned __int16)(v50 + 8)] = 0;
                        --v48;
                      }

                      while (v48);
                      break;
                    case 4:
                      __int16 v43 = v209;
                      if (v17 > 0x1000)
                      {
                        size_t v59 = 0x80000LL;
                        goto LABEL_180;
                      }

                      uint64_t v51 = 0LL;
                      do
                      {
                        int v52 = 0;
                        unint64_t v53 = (0xBD1E35A7BD000000LL * *(uint64_t *)((char *)a5 + v51)) >> 47;
                        do
                        {
                          v43[((_DWORD)v53 + v52) & 0x1FFFF] = 0;
                          v52 += 8;
                        }

                        while (v52 != 32);
                        ++v51;
                      }

                      while (v51 != v17);
                      break;
                    case 5:
                      __int16 v43 = v213;
                      unint64_t v54 = v208;
                      if (v17 > v208 >> 6) {
                        goto LABEL_146;
                      }
                      char v55 = (char)__b;
                      v56 = a5;
                      unint64_t v57 = v17;
                      do
                      {
                        int v58 = *(_DWORD *)v56;
                        v56 = (uint64_t *)((char *)v56 + 1);
                        *((_WORD *)v43 + ((506832829 * v58) >> v55)) = 0;
                        --v57;
                      }

                      while (v57);
                      break;
                    case 6:
                      __int16 v43 = (_DWORD *)v215;
                      unint64_t v54 = v208;
                      if (v17 > v208 >> 6)
                      {
LABEL_146:
                        size_t v59 = 2 * v54;
                        goto LABEL_180;
                      }

                      unint64_t v84 = (unint64_t)v211;
                      char v85 = (char)__b;
                      v86 = a5;
                      unint64_t v87 = v17;
                      do
                      {
                        uint64_t v88 = *v86;
                        v86 = (uint64_t *)((char *)v86 + 1);
                        *((_WORD *)v43 + ((0x1FE35A7BD3579BD3LL * (v88 & v84)) >> v85)) = 0;
                        --v87;
                      }

                      while (v87);
                      break;
                    case 0xA:
                      uint64_t v60 = 0LL;
                      v61 = (char *)v209;
                      p_b = &__b;
                      float32x4_t v63 = vld1q_dup_f32((const float *)p_b);
                      do
                      {
                        *(float32x4_t *)&v61[v60] = v63;
                        v60 += 16LL;
                      }

                      while (v60 != 0x80000);
                      break;
                    default:
                      break;
                  }
                }

                else if (*(int *)&v229[40] > 53)
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case '6':
                      __int16 v43 = v209;
                      if (v17 > 0x8000)
                      {
                        size_t v59 = 0x400000LL;
LABEL_180:
                        bzero(v43, v59);
                      }

                      else
                      {
                        uint64_t v81 = 0LL;
                        do
                        {
                          int v82 = 0;
                          unint64_t v83 = (unint64_t)(0x35A7BD1E35A7BD00LL * *(uint64_t *)((char *)a5 + v81)) >> 44;
                          do
                          {
                            v43[((_DWORD)v83 + v82) & 0xFFFFF] = 0;
                            v82 += 8;
                          }

                          while (v82 != 32);
                          ++v81;
                        }

                        while (v81 != v17);
                      }

                      break;
                    case '7':
                      PrepareH55((uint64_t)&v208, 1, v17, (uint64_t)a5);
                      break;
                    case 'A':
                      PrepareH65((uint64_t)&v208, 1, v17, a5);
                      break;
                  }
                }

                else
                {
                  switch(*(_DWORD *)&v229[40])
                  {
                    case '#':
                      PrepareH35((uint64_t)&v208, 1, v17, a5);
                      break;
                    case '(':
                      char v169 = v30;
                      unint64_t v64 = v9;
                      v65 = __b;
                      v66 = (char *)__b + 0x20000;
                      if (v17 > 0x200) {
                        goto LABEL_163;
                      }
                      v67 = a5;
                      unint64_t v68 = v17;
                      do
                      {
                        int v69 = *(_DWORD *)v67;
                        v67 = (uint64_t *)((char *)v67 + 1);
                        unsigned int v70 = (506832829 * v69) >> 17;
                        v65[v70] = -858993460;
                        *(_WORD *)&v66[2 * v70] = -13108;
                        --v68;
                      }

                      while (v68);
                      goto LABEL_164;
                    case ')':
                      char v169 = v30;
                      unint64_t v64 = v9;
                      v65 = __b;
                      v66 = (char *)__b + 0x20000;
                      if (v17 > 0x200)
                      {
LABEL_163:
                        memset(v65, 204, 0x20000uLL);
                        bzero(v66, 0x10000uLL);
                      }

                      else
                      {
                        v71 = a5;
                        unint64_t v72 = v17;
                        do
                        {
                          int v73 = *(_DWORD *)v71;
                          v71 = (uint64_t *)((char *)v71 + 1);
                          unsigned int v74 = (506832829 * v73) >> 17;
                          v65[v74] = -858993460;
                          *(_WORD *)&v66[2 * v74] = -13108;
                          --v72;
                        }

                        while (v72);
                      }

            if (v76 >= 4)
            {
              uint64_t v81 = 135 * v76 - 30 * (__clz(v72) ^ 0x1F) + 1920;
              unint64_t v68 = v18 & 7;
              if (v65 < v81)
              {
                v56 = *(unsigned __int8 *)(a3 + v76 + v55);
                v65 = v81;
                v66 = v72;
                int v52 = v76;
              }
            }
          }

          int v69 = 0;
          v67 = 1LL;
        }

        while ((v70 & 1) != 0);
        *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v130 + (v53 & 8))) = v53;
        if (v65 < v31 + 175) {
          break;
        }
        ++v12;
        unsigned int v16 = a5;
        if (v50 <= 2)
        {
          unint64_t v83 = v11 + 9;
          ++v50;
          uint64_t v31 = v65;
          uint64_t v129 = v66;
          unint64_t v26 = v52;
          ++v11;
          if (v83 < v126) {
            continue;
          }
        }

        goto LABEL_114;
      }

      v66 = v129;
      int v52 = v26;
      unint64_t v53 = v11;
      unsigned int v16 = a5;
LABEL_114:
      unint64_t v87 = v128;
      if (v53 + v120 < v128) {
        unint64_t v87 = v53 + v120;
      }
      if (v66 > v87) {
        goto LABEL_117;
      }
      unint64_t v92 = *v123;
      if (v66 != v92) {
        break;
      }
      LOWORD(v88) = 0;
      LODWORD(v91) = 0;
      *(_DWORD *)uint64_t v124 = v12;
      *(_DWORD *)(v124 + 4) = v52;
LABEL_127:
      *(_WORD *)(v124 + 14) = v88;
      *(_DWORD *)(v124 + 8) = v91;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v97) = 22;
              }
              else {
                LOWORD(v97) = 23;
              }
            }

            else
            {
              LOWORD(v97) = 21;
            }
          }

          else
          {
            int v97 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          v98 = (__clz(v12 - 2) ^ 0x1F) - 1;
          int v97 = ((v12 - 2) >> v98) + 2 * v98 + 2;
        }
      }

      else
      {
        LOWORD(v97) = v12;
      }

      int v105 = (unint64_t)v52 >> 1;
      if (v105 > 4)
      {
        if (v105 > 0x42)
        {
          if (v105 > 0x422) {
            LOWORD(v106) = 23;
          }
          else {
            unint64_t v106 = (__clz(v52 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v107 = (int)v52 - 6LL;
          unint64_t v108 = (__clz(v107) ^ 0x1F) - 1;
          unint64_t v106 = (v107 >> v108) + 2 * v108 + 4;
        }
      }

      else
      {
        LOWORD(v106) = v52 - 2;
      }

      unint64_t v109 = v106 & 7 | (8 * (v97 & 7));
      if ((v88 & 0x3FF) != 0 || (unsigned __int16)v97 > 7u || (unsigned __int16)v106 > 0xFu)
      {
        v111 = 3 * ((unsigned __int16)v97 >> 3) + ((unsigned __int16)(v106 & 0xFFF8) >> 3);
        unint64_t v110 = ((((0x520D40u >> (2 * v111)) & 0xC0) + (v111 << 6)) | v109) + 64;
      }

      else
      {
        LOWORD(v110) = v109 | 0x40;
        if ((v106 & 0xFFF8) == 0) {
          LOWORD(v110) = v106 & 7 | (8 * (v97 & 7));
        }
      }

      *(_WORD *)(v124 + 12) = v110;
      *a11 += v12;
      v112 = v53 + 2;
      char v85 = v53 + v52;
      uint64_t v113 = v122;
      if (v53 + v52 < v122) {
        uint64_t v113 = v53 + v52;
      }
      if (v66 < v52 >> 2)
      {
        uint64_t v114 = v85 - 4 * v66;
        if (v112 > v114) {
          uint64_t v114 = v53 + 2;
        }
        if (v113 >= v114) {
          v112 = v114;
        }
        else {
          v112 = v113;
        }
      }

      uint64_t result = v121 + 2 * v52 + v53;
      v124 += 16LL;
      if (v112 >= v113)
      {
        unint64_t v12 = 0LL;
        a7 = v123;
        unint64_t v13 = v126;
      }

      else
      {
        a7 = v123;
        unint64_t v13 = v126;
        do
        {
          *(_DWORD *)(v17
                    + 4LL
                    * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v112 & a4))) >> 48) + (v112 & 8))) = v112;
          ++v112;
        }

        while (v113 != v112);
        unint64_t v12 = 0LL;
      }

LABEL_164:
                      bzero(v65 + 49152, 0x10000uLL);
                      LOWORD(v208) = 0;
                      unint64_t v9 = v64;
                      goto LABEL_178;
                    case '*':
                      char v169 = v30;
                      v75 = v227;
                      v76 = (char *)v227 + 0x20000;
                      if (v17 > 0x200)
                      {
                        memset(v227, 204, 0x20000uLL);
                        bzero(v76, 0x10000uLL);
                      }

                      else
                      {
                        v77 = a5;
                        unint64_t v78 = v17;
                        do
                        {
                          int v79 = *(_DWORD *)v77;
                          v77 = (uint64_t *)((char *)v77 + 1);
                          unsigned int v80 = (506832829 * v79) >> 17;
                          v75[v80] = -858993460;
                          *(_WORD *)&v76[2 * v80] = -13108;
                          --v78;
                        }

                        while (v78);
                      }

                      bzero(v75 + 49152, 0x10000uLL);
                      bzero(&v208, 0x400uLL);
LABEL_178:
                      char v30 = v169;
                      break;
                    default:
                      break;
                  }
                }

                *(void *)v207 = 0LL;
                *((void *)&v206 + 1) = 0LL;
                *(_DWORD *)&v207[28] = 1;
              }

              if (v233)
              {
LABEL_320:
                BrotliWipeOutMemoryManager((uint64_t)v232);
                unsigned int v7 = a7;
                unint64_t v26 = v178;
                goto LABEL_321;
              }

              unint64_t v89 = 1LL << (v18 + 1);
              if (*(_DWORD *)&v207[8] == 65)
              {
                unint64_t v95 = 0x7FFFFFFFFFFFFFFFLL;
                if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
                  unint64_t v95 = v17;
                }
                v90 = a7;
                if (v95 >= 0x20)
                {
                  uint64_t v96 = 0LL;
                  int v97 = 0;
                  do
                    int v97 = *((unsigned __int8 *)a5 + v96++) + v97 * HIDWORD(v217) + 1;
                  while (v96 != 32);
                  LODWORD(v216) = v97;
                }

                v98 = &v217;
                goto LABEL_208;
              }

              v90 = a7;
              if (*(_DWORD *)&v207[8] == 55)
              {
                unint64_t v99 = 0x7FFFFFFFFFFFFFFFLL;
                if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
                  unint64_t v99 = v17;
                }
                if (v99 < 0x20) {
                  goto LABEL_207;
                }
                unint64_t v100 = 0LL;
                int v93 = 0;
                do
                {
                  int v93 = *((unsigned __int8 *)a5 + v100) + v93 * HIDWORD(v213) + 1;
                  BOOL v94 = v100 >= 0x1C;
                  v100 += 4LL;
                }

                while (!v94);
              }

              else
              {
                if (*(_DWORD *)&v207[8] != 35)
                {
LABEL_209:
                  char v170 = v30;
                  unint64_t v172 = 0LL;
                  unint64_t v101 = 0LL;
                  uint64_t v167 = 0LL;
                  unint64_t v179 = v89 >> 3;
                  unint64_t v181 = 1LL << v29;
                  __dst = v90;
                  uint64_t v166 = 1LL << (v18 + 1);
                  unint64_t v173 = v9;
                  do
                  {
                    unint64_t v102 = v101 + v89;
                    if (v10 < v101 + v89) {
                      unint64_t v102 = v10;
                    }
                    unint64_t v183 = v102;
                    unint64_t v103 = v102 - v101;
                    unint64_t v205 = 0LL;
                    unint64_t v204 = 0LL;
                    unint64_t v104 = v101;
                    if (*(int *)&v229[4] < 10
                      || BrotliIsMostlyUTF8((uint64_t)a5, v101, 0x7FFFFFFFFFFFFFFFLL, v103, 0.75))
                    {
                      int v105 = 2;
                    }

                    else
                    {
                      int v105 = 3;
                    }

                    size_t v187 = 0LL;
                    unint64_t v184 = 0LL;
                    size_t v185 = 0LL;
                    unint64_t v106 = 0LL;
                    unint64_t v180 = v103 / 0xC + 16;
                    unsigned int v168 = v105;
                    v182 = &_kBrotliContextLookupTable[v105 << 9];
                    size_t v171 = v101;
                    while (v183 > v104)
                    {
                      __src = (void *)v106;
                      if (v183 - v104 >= v181) {
                        unint64_t v107 = v181;
                      }
                      else {
                        unint64_t v107 = v183 - v104;
                      }
                      if (v107 == -1LL) {
                        v188 = 0LL;
                      }
                      else {
                        v188 = (_DWORD *)BrotliAllocate((uint64_t)v232);
                      }
                      if (v233) {
                        goto LABEL_319;
                      }
                      BrotliInitZopfliNodes((uint64_t)v188, v107 + 1);
                      if (v104 >= 0x80 && v107 >= 3)
                      {
                        unint64_t v108 = v104 - 127;
                        unint64_t v109 = v107 + v104 - 127;
                        if (v104 < v109) {
                          unint64_t v109 = v104;
                        }
                        if (v108 < v109)
                        {
                          unint64_t v110 = v208;
                          v111 = v209;
                          v112 = v211;
                          do
                          {
                            uint64_t v113 = v108 & 0x7FFFFFFFFFFFFFFFLL;
                            uint64_t v114 = 15LL;
                            if (v104 - v108 > 0xF) {
                              uint64_t v114 = v104 - v108;
                            }
                            unsigned int v115 = (506832829 * *(_DWORD *)((char *)a5 + (v108 & 0x7FFFFFFFFFFFFFFFLL))) >> 15;
                            uint64_t v116 = v111[v115];
                            uint64_t v117 = 2 * (v108 & v110);
                            uint64_t v118 = v117 | 1;
                            v111[v115] = v108;
                            if (v108 != v116)
                            {
                              unint64_t v120 = 0LL;
                              unint64_t v121 = 0LL;
                              unint64_t v122 = v110 - v114;
                              v123 = (char *)a5 + v113;
                              uint64_t v124 = 64LL;
                              do
                              {
                                if (v108 - v116 > v122 || v124 == 0) {
                                  break;
                                }
                                if (v121 >= v120) {
                                  unint64_t v126 = v120;
                                }
                                else {
                                  unint64_t v126 = v121;
                                }
                                v127 = (unsigned __int8 *)a5 + v126 + v116;
                                unint64_t v128 = 128 - v126;
                                if (128 - v126 < 8)
                                {
                                  unint64_t v131 = 0LL;
LABEL_257:
                                  uint64_t v136 = v128 & 7;
                                  if (v136)
                                  {
                                    unint64_t v137 = v131 | v136;
                                    while (v123[v126 + v131] == *v127)
                                    {
                                      ++v127;
                                      ++v131;
                                      if (!--v136)
                                      {
                                        unint64_t v131 = v137;
                                        break;
                                      }
                                    }
                                  }
                                }

                                else
                                {
                                  uint64_t v129 = 0LL;
                                  unint64_t v130 = v128 >> 3;
                                  unint64_t v131 = v128 & 0xFFFFFFFFFFFFFFF8LL;
                                  while (1)
                                  {
                                    uint64_t v132 = *(void *)&v127[v129];
                                    uint64_t v133 = *(void *)&v123[v126 + v129];
                                    if (v132 != v133) {
                                      break;
                                    }
                                    v129 += 8LL;
                                    if (!--v130)
                                    {
                                      v127 += v128 & 0xFFFFFFFFFFFFFFF8LL;
                                      goto LABEL_257;
                                    }
                                  }

                                  unint64_t v131 = v129 + (__clz(__rbit64(v133 ^ v132)) >> 3);
                                }

                                unint64_t v134 = v131 + v126;
                                if (v134 >= 0x80)
                                {
                                  v138 = (_DWORD *)v112 + 2 * (v116 & v110);
                                  *((_DWORD *)v112 + v117) = *v138;
                                  int v119 = v138[1];
                                  goto LABEL_234;
                                }

                                uint64_t v135 = 2 * (v116 & v110);
                                if (*((unsigned __int8 *)a5 + v134 + v113) <= *((unsigned __int8 *)a5
                                                                                             + v134
                                                                                             + v116))
                                {
                                  *((_DWORD *)v112 + v118) = v116;
                                  unint64_t v120 = v134;
                                  uint64_t v118 = 2 * (v116 & v110);
                                }

                                else
                                {
                                  *((_DWORD *)v112 + v117) = v116;
                                  uint64_t v117 = v135 | 1;
                                  unint64_t v121 = v134;
                                  v135 |= 1uLL;
                                }

                                uint64_t v116 = *((unsigned int *)v112 + v135);
                                --v124;
                              }

                              while (v108 != v116);
                            }

                            *((_DWORD *)v112 + v117) = (_DWORD)__b;
                            int v119 = (int)__b;
LABEL_234:
                            *((_DWORD *)v112 + v118) = v119;
                            ++v108;
                          }

                          while (v108 != v109);
                        }
                      }

                      uint64_t v139 = BrotliZopfliComputeShortestPath( (uint64_t)v232,  v107,  v104,  (uint64_t)a5,  0x7FFFFFFFFFFFFFFFLL,  (uint64_t)v182,  (uint64_t)v229,  (uint64_t)&v235,  &v206,  v188);
                      if (v233) {
                        goto LABEL_319;
                      }
                      size_t v140 = v139 + v187;
                      if (v180 <= v139 + v187 + 1) {
                        unint64_t v141 = v140 + 1;
                      }
                      else {
                        unint64_t v141 = v180;
                      }
                      if (v184 == v141)
                      {
                        unint64_t v106 = (unint64_t)__src;
                      }

                      else
                      {
                        v142 = (void *)BrotliAllocate((uint64_t)v232);
                        if (v233) {
                          goto LABEL_319;
                        }
                        unint64_t v106 = (unint64_t)v142;
                        if (__src)
                        {
                          memcpy(v142, __src, 16 * v187);
                          BrotliFree((uint64_t)v232, (unint64_t)__src);
                        }

                        unint64_t v184 = v141;
                      }

                      BrotliZopfliCreateCommands( v107,  v104,  (uint64_t)v188,  (uint64_t)&v235,  &v205,  (uint64_t)v229,  v106 + 16 * v187,  &v204);
                      v185 += v107;
                      BrotliFree((uint64_t)v232, (unint64_t)v188);
                      if (v140 <= v179)
                      {
                        v104 += v107;
                        size_t v187 = v140;
                        if (v204 <= v179) {
                          continue;
                        }
                      }

                      goto LABEL_277;
                    }

                    size_t v140 = v187;
LABEL_277:
                    unint64_t v143 = v205;
                    if (v205)
                    {
                      unint64_t v144 = v106 + 16 * v140;
                      *(_DWORD *)unint64_t v144 = v205;
                      *(void *)(v144 + 4) = 0x8000000LL;
                      *(_WORD *)(v144 + 14) = 16;
                      unint64_t v145 = v174;
                      if (v143 > 5)
                      {
                        if (v143 > 0x81)
                        {
                          if (v143 > 0x841)
                          {
                            if (v143 >> 1 >= 0xC21)
                            {
                              if (v143 < 0x5842) {
                                LOWORD(v146) = 22;
                              }
                              else {
                                LOWORD(v146) = 23;
                              }
                            }

                            else
                            {
                              LOWORD(v146) = 21;
                            }
                          }

                          else
                          {
                            unsigned int v146 = (__clz(v143 - 66) ^ 0x1F) + 10;
                          }
                        }

                        else
                        {
                          unsigned int v147 = (__clz(v143 - 2) ^ 0x1F) - 1;
                          unsigned int v146 = ((v143 - 2) >> v147) + 2 * v147 + 2;
                        }
                      }

                      else
                      {
                        LOWORD(v146) = v143;
                      }

                      ++v140;
                      *(_WORD *)(v144 + 12) = ((((0x520D40u >> (6 * ((unsigned __int16)v146 >> 3))) & 0xC0)
                      v204 += v143;
                    }

                    else
                    {
                      unint64_t v145 = v174;
                    }

                    unint64_t v101 = v185 + v171;
                    BOOL v148 = v185 + v171 == v10;
                    unint64_t v203 = v145;
                    if (v185)
                    {
                      if (ShouldCompress((uint64_t)a5, 0xFFFFFFFF, v171, v185, v204, v140))
                      {
                        __int128 v192 = v231[1];
                        __int128 v193 = v231[2];
                        __int128 v194 = v231[3];
                        v189[2] = *(_OWORD *)&v229[32];
                        v189[3] = *(_OWORD *)&v229[48];
                        *(_OWORD *)v190 = v230;
                        __int128 v191 = v231[0];
                        v189[0] = *(_OWORD *)v229;
                        v189[1] = *(_OWORD *)&v229[16];
                        BrotliInitBlockSplit(v195);
                        BrotliInitBlockSplit(v196);
                        BrotliInitBlockSplit(v197);
                        __int128 v201 = 0u;
                        __int128 v202 = 0u;
                        __int128 v199 = 0u;
                        __int128 v200 = 0u;
                        __int128 v198 = 0u;
                        BrotliBuildMetaBlock( (uint64_t)v232,  (uint64_t)a5,  v171,  0x7FFFFFFFFFFFFFFFuLL,  v189,  BYTE4(v167),  v167,  v106,  v140,  v168,  (uint64_t *)v195);
                        if (v233) {
                          goto LABEL_319;
                        }
                        BrotliOptimizeHistograms(v190[3], v195);
                        v149 = (_BYTE *)BrotliAllocate((uint64_t)v232);
                        if (v233) {
                          goto LABEL_319;
                        }
                        v150 = v149;
                        _BYTE *v149 = v170;
                        v149[1] = v177;
                        BrotliStoreMetaBlock( (uint64_t)v232,  (uint64_t)a5,  v171,  v185,  0x7FFFFFFFFFFFFFFFLL,  BYTE4(v167),  v167,  v148,  (unsigned int *)v189,  v168,  v106,  v140,  (uint64_t)v195,  &v203,  (uint64_t)v149);
                        if (v233) {
                          goto LABEL_319;
                        }
                        if (v185 + 4 < v203 >> 3)
                        {
                          __int128 v235 = v234;
                          _BYTE *v150 = v170;
                          v150[1] = v177;
                          unint64_t v203 = v145;
                          BrotliStoreUncompressedMetaBlock( v148,  (uint64_t)a5,  v171,  0x7FFFFFFFFFFFFFFFLL,  v185,  (uint64_t *)&v203,  (uint64_t)v150);
                        }

                        BrotliDestroyBlockSplit((uint64_t)v232, (uint64_t)v195);
                        BrotliDestroyBlockSplit((uint64_t)v232, (uint64_t)v196);
                        BrotliDestroyBlockSplit((uint64_t)v232, (uint64_t)v197);
                        BrotliFree((uint64_t)v232, v198);
                        *(void *)&__int128 v198 = 0LL;
                        BrotliFree((uint64_t)v232, v199);
                        *(void *)&__int128 v199 = 0LL;
                        BrotliFree((uint64_t)v232, v200);
                        *(void *)&__int128 v200 = 0LL;
                        BrotliFree((uint64_t)v232, v201);
                        *(void *)&__int128 v201 = 0LL;
                        BrotliFree((uint64_t)v232, v202);
                      }

                      else
                      {
                        __int128 v235 = v234;
                        if (v185 == -16LL) {
                          v150 = 0LL;
                        }
                        else {
                          v150 = (_BYTE *)BrotliAllocate((uint64_t)v232);
                        }
                        if (v233)
                        {
LABEL_319:
                          unint64_t v8 = a6;
                          unint64_t v9 = v173;
                          goto LABEL_320;
                        }

                        _BYTE *v150 = v170;
                        v150[1] = v177;
                        BrotliStoreUncompressedMetaBlock( v148,  (uint64_t)a5,  v171,  0x7FFFFFFFFFFFFFFFLL,  v185,  (uint64_t *)&v203,  (uint64_t)v150);
                      }
                    }

                    else
                    {
                      v151 = (_BYTE *)BrotliAllocate((uint64_t)v232);
                      if (v233) {
                        goto LABEL_319;
                      }
                      v150 = v151;
                      _BYTE *v151 = v170;
                      v151[1] = v177;
                      int v152 = v203;
                      *(void *)&v151[v203 >> 3] = (3LL << (v203 & 7)) | v151[v203 >> 3];
                      unint64_t v203 = (v152 + 9) & 0xFFFFFFF8;
                    }

                    unsigned int v7 = a7;
                    char v153 = v203;
                    unint64_t v154 = v203 >> 3;
                    char v170 = v150[v203 >> 3];
                    if (v101 < v10)
                    {
                      LOBYTE(v167) = *((_BYTE *)a5 + v101 - 2);
                      BYTE4(v167) = *((_BYTE *)a5 + v101 - 1);
                    }

                    __int128 v234 = v235;
                    v172 += v154;
                    if (v172 <= v173)
                    {
                      memcpy(__dst, v150, v203 >> 3);
                      __dst += v154;
                    }

                    BrotliFree((uint64_t)v232, (unint64_t)v150);
                    BrotliFree((uint64_t)v232, v106);
                    unint64_t v9 = v173;
                    unint64_t v89 = v166;
                    if (v101 >= v10) {
                      break;
                    }
                    char v177 = 0;
                    uint64_t v174 = v153 & 7;
                  }

                  while (v172 <= v173);
                  unint64_t v8 = a6;
                  *a6 = v172;
                  if ((void)v206) {
                    BrotliFree((uint64_t)v232, v206);
                  }
                  unint64_t v26 = v178;
                  if (v172 <= v173 && (!v178 || *a6 <= v178)) {
                    return 1LL;
                  }
LABEL_321:
                  *unint64_t v8 = 0LL;
                  if (v26 - 1 < v9)
                  {
                    v155 = v8;
                    uint64_t v156 = 0LL;
                    *unsigned int v7 = 801;
                    uint64_t v157 = 2LL;
                    do
                    {
                      if (v10 >= 0x1000000) {
                        size_t v158 = 0x1000000LL;
                      }
                      else {
                        size_t v158 = v10;
                      }
                      else {
                        int v159 = 2;
                      }
                      int v160 = 8 * v158 - 8;
                      int v161 = v160 | (2 * v159);
                      int v162 = (1 << ((4 * v159) | 0x13)) | v161;
                      v163 = (char *)v7 + v157;
                      _BYTE *v163 = v161;
                      v163[1] = BYTE1(v160);
                      uint64_t v164 = v157 + 3;
                      v163[2] = BYTE2(v162);
                      if (v158 > 0x100000)
                      {
                        *((_BYTE *)v7 + v164) = HIBYTE(v162);
                        uint64_t v164 = v157 + 4;
                      }

                      memcpy((char *)v7 + v164, (char *)a5 + v156, v158);
                      uint64_t v157 = v164 + v158;
                      v156 += v158;
                      v10 -= v158;
                    }

                    while (v10);
                    *((_BYTE *)v7 + v157) = 3;
                    unint64_t *v155 = v157 + 1;
                    return 1LL;
                  }

                  return 0LL;
                }

                unint64_t v91 = 0x7FFFFFFFFFFFFFFFLL;
                if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
                  unint64_t v91 = v17;
                }
                if (v91 < 0x20) {
                  goto LABEL_207;
                }
                unint64_t v92 = 0LL;
                int v93 = 0;
                do
                {
                  int v93 = *((unsigned __int8 *)a5 + v92) + v93 * HIDWORD(v213) + 1;
                  BOOL v94 = v92 >= 0x1C;
                  v92 += 4LL;
                }

                while (!v94);
              }

              LODWORD(__b) = v93;
LABEL_207:
              v98 = (__int128 *)&v212;
LABEL_208:
              *(void *)v98 = 0LL;
              goto LABEL_209;
            }

            if (*(_DWORD *)&v229[4] < 9u) {
              int v35 = 41;
            }
            else {
              int v35 = 42;
            }
            if (*(_DWORD *)&v229[4] >= 7u) {
              int v32 = v35;
            }
            else {
              int v32 = 40;
            }
          }
        }

        else
        {
          int v32 = 10;
        }

        *(_DWORD *)&v229[40] = v32;
        goto LABEL_48;
      }

      char v177 = 0;
      char v30 = 1;
      uint64_t v31 = 7LL;
    }

    uint64_t v174 = v31;
    goto LABEL_45;
  }

  return 0LL;
}

    *(_DWORD *)size_t v158 = v170;
    *(_DWORD *)(v158 + 4) = v60 | (v108 << 25);
    unint64_t v120 = *(unsigned int *)(a5 + 68);
    unint64_t v121 = v120 + 16;
    if (v120 + 16 <= v118)
    {
      v123 = *(unsigned int *)(a5 + 64);
      uint64_t v124 = v118 - v120 + (4LL << v123) - 16;
      v125 = (__clz(v124) ^ 0x1F) - 1;
      unint64_t v126 = ((v124 >> v125) & 1 | 2) << v125;
      uint64_t v118 = ((v124 & ~(-1 << v123))
            + v121
            + ((((v124 >> v125) & 1 | (2 * (v125 - v123))) + 65534) << v123)) | ((v125 - v123) << 10);
      unint64_t v122 = (v124 - v126) >> v123;
    }

    else
    {
      LODWORD(v122) = 0;
    }

    *(_WORD *)(v158 + 14) = v118;
    *(_DWORD *)(v158 + 8) = v122;
    if (v170 > 5)
    {
      if (v170 > 0x81)
      {
        if (v170 > 0x841)
        {
          if (v170 >> 1 >= 0xC21)
          {
            if (v170 < 0x5842) {
              LOWORD(v127) = 22;
            }
            else {
              LOWORD(v127) = 23;
            }
          }

          else
          {
            LOWORD(v127) = 21;
          }
        }

        else
        {
          v127 = (__clz(v170 - 66) ^ 0x1F) + 10;
        }
      }

      else
      {
        unint64_t v128 = (__clz(v170 - 2) ^ 0x1F) - 1;
        v127 = ((v170 - 2) >> v128) + 2 * v128 + 2;
      }
    }

    else
    {
      LOWORD(v127) = v170;
    }

    v142 = v108 + (int)v60;
    if (v142 > 9)
    {
      if (v142 > 0x85)
      {
        else {
          LODWORD(v142) = (__clz(v142 - 70) ^ 0x1F) + 12;
        }
      }

      else
      {
        v142 -= 6LL;
        unint64_t v143 = (__clz(v142) ^ 0x1F) - 1;
        LODWORD(v142) = (v142 >> v143) + 2 * v143 + 4;
      }
    }

    else
    {
      LOWORD(v142) = v142 - 2;
    }

    unint64_t v144 = v142 & 7 | (8 * (v127 & 7));
    if ((v118 & 0x3FF) != 0 || (unsigned __int16)v127 > 7u || (unsigned __int16)v142 > 0xFu)
    {
      unsigned int v146 = 3 * ((unsigned __int16)v127 >> 3) + ((unsigned __int16)(v142 & 0xFFF8) >> 3);
      unint64_t v145 = ((((0x520D40u >> (2 * v146)) & 0xC0) + (v146 << 6)) | v144) + 64;
    }

    else
    {
      LOWORD(v145) = v144 | 0x40;
      if ((v142 & 0xFFF8) == 0) {
        LOWORD(v145) = v144;
      }
    }

    *(_WORD *)(v158 + 12) = v145;
    *a11 += v170;
    unsigned int v147 = v61 + 2;
    uint64_t v114 = v61 + v60;
    if (v61 + v60 >= v155) {
      BOOL v148 = v155;
    }
    else {
      BOOL v148 = v61 + v60;
    }
    if (v74 < v60 >> 2)
    {
      v149 = v114 - 4 * v74;
      if (v147 > v149) {
        v149 = v61 + 2;
      }
      if (v148 >= v149) {
        unsigned int v147 = v149;
      }
      else {
        unsigned int v147 = v148;
      }
    }

    unsigned int v16 = v154 + 2 * v60 + v61;
    v158 += 16LL;
    if (v147 >= v148)
    {
      unint64_t v12 = 0LL;
    }

    else
    {
      do
      {
        *(_DWORD *)(v17
                  + 4
        ++v147;
      }

      while (v148 != v147);
      unint64_t v12 = 0LL;
    }

uint64_t BrotliEncoderCompressStream( uint64_t a1, int a2, unint64_t *a3, const void **a4, size_t *a5, void **a6, size_t *a7)
{
  if (*(_DWORD *)(a1 + 168)) {
    return 0LL;
  }
  if (*(_DWORD *)(a1 + 8636)) {
    goto LABEL_50;
  }
  *(_DWORD *)(a1 + 2432) = -33554432;
  *(_DWORD *)(a1 + 8624) = -1;
  unsigned int v15 = *(_DWORD *)(a1 + 4) & ~(*(int *)(a1 + 4) >> 31);
  *(_DWORD *)(a1 + 4) = v15;
  if (v15 <= 2) {
    *(_DWORD *)(a1 + 36) = 0;
  }
  int v16 = *(_DWORD *)(a1 + 8);
  if (v16 < 10)
  {
    unsigned int v17 = 10;
LABEL_15:
    *(_DWORD *)(a1 + 8) = v17;
    int v16 = v17;
    goto LABEL_16;
  }

  if (*(_DWORD *)(a1 + 36)) {
    unsigned int v17 = 30;
  }
  else {
    unsigned int v17 = 24;
  }
  if (v16 > v17) {
    goto LABEL_15;
  }
LABEL_16:
  if (v15 >= 2)
  {
    if (v15 >= 4)
    {
      int v19 = *(_DWORD *)(a1 + 12);
      if (v19)
      {
        if (v19 <= 16) {
          int v20 = 16;
        }
        else {
          int v20 = *(_DWORD *)(a1 + 12);
        }
        if (v20 >= 24) {
          int v18 = 24;
        }
        else {
          int v18 = v20;
        }
      }

      else
      {
        int v18 = 16;
        if (v15 >= 9)
        {
          if (v16 >= 18) {
            int v21 = 18;
          }
          else {
            int v21 = v16;
          }
          if (v21 <= 16) {
            int v18 = 16;
          }
          else {
            int v18 = v21;
          }
        }
      }
    }

    else
    {
      int v18 = 14;
    }
  }

  else
  {
    int v18 = v16;
  }

  *(_DWORD *)(a1 + 12) = v18;
  ChooseDistanceParams((_DWORD *)a1);
  unint64_t v22 = *(void *)(a1 + 16);
  if (v22)
  {
    *(_BYTE *)(a1 + 2435) = 2;
    *(void *)&__int128 v23 = 0xF0000000FLL;
    *((void *)&v23 + 1) = 0xF0000000FLL;
    *(_OWORD *)(a1 + 2352) = v23;
    *(_OWORD *)(a1 + 2416) = *(_OWORD *)(a1 + 2352);
  }

  int v25 = *(_DWORD *)(a1 + 8);
  int v24 = *(_DWORD *)(a1 + 12);
  unsigned int v26 = *(_DWORD *)(a1 + 4);
  if (v25 <= v24) {
    char v27 = *(_DWORD *)(a1 + 12);
  }
  else {
    char v27 = *(_DWORD *)(a1 + 8);
  }
  int v28 = 1 << (v27 + 1);
  *(_DWORD *)(a1 + 2260) = v28 - 1;
  *(_DWORD *)(a1 + 2256) = v28;
  int v29 = 1 << v24;
  *(_DWORD *)(a1 + 2264) = v29;
  *(_DWORD *)(a1 + 2268) = v28 + v29;
  if (v25 <= 18) {
    int v30 = 18;
  }
  else {
    int v30 = v25;
  }
  if (v26 >= 2) {
    int v30 = v25;
  }
  if (v22)
  {
    unint64_t v31 = (1LL << v30) - 16;
    if (v22 >= v31) {
      unint64_t v22 = v31;
    }
    *(void *)(a1 + 16) = v22;
    if (v26) {
      goto LABEL_49;
    }
  }

  else
  {
    if (*(_DWORD *)(a1 + 36))
    {
      __int16 v43 = ((v30 & 0x3F) << 8) | 0x11;
      char v44 = 14;
    }

    else if (v30 == 16)
    {
      __int16 v43 = 0;
      char v44 = 1;
    }

    else if (v30 == 17)
    {
      char v44 = 7;
      __int16 v43 = 1;
    }

    else if (v30 < 18)
    {
      __int16 v43 = 16 * v30 - 127;
      char v44 = 7;
    }

    else
    {
      __int16 v43 = 2 * v30 - 33;
      char v44 = 4;
    }

    *(_WORD *)(a1 + 2432) = v43;
    *(_BYTE *)(a1 + 2434) = v44;
    if (v26) {
      goto LABEL_49;
    }
  }

  *(_OWORD *)(a1 + 7728) = xmmword_181076984;
  *(_OWORD *)(a1 + 7744) = unk_181076994;
  *(_OWORD *)(a1 + 7760) = xmmword_1810769A4;
  *(_OWORD *)(a1 + 7776) = unk_1810769B4;
  *(_OWORD *)(a1 + 7664) = InitCommandPrefixCodes_kDefaultCommandDepths;
  *(_OWORD *)(a1 + 7680) = unk_181076954;
  *(_OWORD *)(a1 + 7696) = xmmword_181076964;
  *(_OWORD *)(a1 + 7712) = unk_181076974;
  *(_OWORD *)(a1 + 7840) = unk_1810769F4;
  *(_OWORD *)(a1 + 7824) = xmmword_1810769E4;
  *(_OWORD *)(a1 + 7808) = unk_1810769D4;
  *(_OWORD *)(a1 + 7792) = InitCommandPrefixCodes_kDefaultCommandBits;
  *(_OWORD *)(a1 + 7904) = unk_181076A34;
  *(_OWORD *)(a1 + 7888) = xmmword_181076A24;
  *(_OWORD *)(a1 + 7872) = unk_181076A14;
  *(_OWORD *)(a1 + 7856) = xmmword_181076A04;
  *(_OWORD *)(a1 + 7968) = unk_181076A74;
  *(_OWORD *)(a1 + 7952) = xmmword_181076A64;
  *(_OWORD *)(a1 + 7936) = unk_181076A54;
  *(_OWORD *)(a1 + 7920) = xmmword_181076A44;
  *(_OWORD *)(a1 + 8032) = unk_181076AB4;
  *(_OWORD *)(a1 + 8016) = xmmword_181076AA4;
  *(_OWORD *)(a1 + 8000) = unk_181076A94;
  *(_OWORD *)(a1 + 7984) = xmmword_181076A84;
  strcpy((char *)(a1 + 8048), "\xFFw\xE7\xDE\xEA\x9EQ]\xDE\xC6pW\xBCX");
  strcpy( (char *)(a1 + 8064),  "XX\xD8\xD8X\xD5\xCB\x8C\xEA\xE0\xC3\x87\x1F\x83\xC1\x60\x1Cg\xB2\xAA\x06\x83\xC1\x600\x18T\x94");
  *(_BYTE *)(a1 + 8095) = InitCommandPrefixCodes_kDefaultCommandCode[47];
  *(_OWORD *)(a1 + 8089) = *(_OWORD *)"\x18T\x94F\xE1\xB0\xD0N\xB2\xF7\x04b";
  *(void *)(a1 + 8560) = 448LL;
LABEL_49:
  *(_DWORD *)(a1 + 8636) = 1;
LABEL_50:
  uint64_t v32 = *(unsigned int *)(a1 + 8624);
  if ((_DWORD)v32 != -1)
  {
    uint64_t result = 0LL;
    if (a2 != 3 || *a3 != v32) {
      return result;
    }
    goto LABEL_55;
  }

  if (a2 == 3)
  {
LABEL_55:
    if (!*(void *)(a1 + 24))
    {
      uint64_t v33 = 0x40000000LL;
      if (!((*(void *)(a1 + 2248) - *(void *)(a1 + 2344)) >> 30)) {
        uint64_t v33 = (*(_DWORD *)(a1 + 2248) - *(_DWORD *)(a1 + 2344));
      }
      *(void *)(a1 + 24) = v33;
    }

    if (*a3 > 0x1000000) {
      return 0LL;
    }
    int v34 = *(_DWORD *)(a1 + 8628);
    if (!v34)
    {
      *(_DWORD *)(a1 + 8624) = *a3;
      *(_DWORD *)(a1 + 8628) = 3;
LABEL_83:
      unint64_t v45 = (_WORD *)(a1 + 8608);
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if (*(void *)(a1 + 8592)) {
              return 1LL;
            }
            if (*(void *)(a1 + 2248) == *(void *)(a1 + 2336)) {
              break;
            }
            uint64_t result = EncodeData(a1, 0, 1, (unint64_t *)(a1 + 8592), (uint64_t *)(a1 + 8584), v46, v47, v48);
            if (!(_DWORD)result) {
              return result;
            }
          }

          if (*(_DWORD *)(a1 + 8628) == 3) {
            break;
          }
          size_t v53 = *(unsigned int *)(a1 + 8624);
          if (!(_DWORD)v53)
          {
            *(void *)(a1 + 8624) = 0xFFFFFFFFLL;
            return 1LL;
          }

          if (*a5)
          {
            if (v53 >= *a5) {
              size_t v54 = *a5;
            }
            else {
              size_t v54 = *(unsigned int *)(a1 + 8624);
            }
            memcpy(*a6, *a4, v54);
            *a4 = (char *)*a4 + v54;
            *a3 -= v54;
            *(_DWORD *)(a1 + 8624) -= v54;
            *a6 = (char *)*a6 + v54;
            *a5 -= v54;
          }

          else
          {
            else {
              size_t v55 = v53;
            }
            *(void *)(a1 + 8584) = v45;
            memcpy((void *)(a1 + 8608), *a4, v55);
            *a4 = (char *)*a4 + v55;
            *a3 -= v55;
            *(_DWORD *)(a1 + 8624) -= v55;
            *(void *)(a1 + 8592) = v55;
          }
        }

        *(void *)(a1 + 8584) = v45;
        uint64_t v49 = *(unsigned int *)(a1 + 8624);
        unint64_t v50 = *(unsigned __int8 *)(a1 + 2434);
        *unint64_t v45 = *(_WORD *)(a1 + 2432);
        *(_WORD *)(a1 + 2432) = 0;
        *(void *)((char *)v45 + (v50 >> 3)) = *((unsigned __int8 *)v45 + (v50 >> 3));
        *(_BYTE *)(a1 + 2434) = 0;
        *(void *)((char *)v45 + ((v50 + 1) >> 3)) = (3LL << ((v50 + 1) & 7)) | *((unsigned __int8 *)v45
                                                                                 + ((v50 + 1) >> 3));
        *(void *)((char *)v45 + ((v50 + 3) >> 3)) = *((unsigned __int8 *)v45 + ((v50 + 3) >> 3));
        unint64_t v51 = v50 + 4;
        if ((_DWORD)v49 == 1)
        {
          unsigned int v56 = 0;
        }

        else
        {
          if (!(_DWORD)v49)
          {
            *(void *)((char *)v45 + (v51 >> 3)) = *((unsigned __int8 *)v45 + (v51 >> 3));
            unint64_t v52 = v50 + 6;
            goto LABEL_106;
          }

          unsigned int v56 = ((__clz(v49 - 1) ^ 0x18) + 8) >> 3;
        }

        *(void *)((char *)v45 + (v51 >> 3)) = ((unint64_t)v56 << (v51 & 7)) | *((unsigned __int8 *)v45
                                                                                       + (v51 >> 3));
        unint64_t v57 = v50 + 6;
        *(void *)((char *)v45 + (v57 >> 3)) = ((v49 - 1) << (v57 & 7)) | *((unsigned __int8 *)v45 + (v57 >> 3));
        unint64_t v52 = v57 + 8 * v56;
LABEL_106:
        *(void *)(a1 + 8592) = (v52 + 7) >> 3;
        *(_DWORD *)(a1 + 8628) = 4;
      }
    }

    return 0LL;
  }

  int v35 = *(_DWORD *)(a1 + 8628);
  unsigned int v36 = *(_DWORD *)(a1 + 4);
  if (v36 < 2)
  {
    unint64_t v37 = 1LL << *(_DWORD *)(a1 + 8);
    unint64_t v38 = *a3;
    if (*a3 >= v37) {
      unint64_t v38 = 1LL << *(_DWORD *)(a1 + 8);
    }
    if (v38 >= 0x20000) {
      uint64_t v39 = 0x20000LL;
    }
    else {
      uint64_t v39 = v38;
    }
    __src = (void *)(a1 + 144);
    if (v36 != 1)
    {
      uint64_t v41 = 0LL;
      unint64_t v42 = 0LL;
      int v40 = 0LL;
      goto LABEL_197;
    }

    int v40 = *(unsigned int **)(a1 + 8568);
    if (v40 || v38 < 0x20000)
    {
      if (v40)
      {
        unint64_t v42 = 0LL;
        unint64_t v106 = 0LL;
        uint64_t v41 = *(void *)(a1 + 8576);
        goto LABEL_207;
      }

      if (!v39)
      {
        int v40 = 0LL;
        uint64_t v41 = 0LL;
LABEL_206:
        unint64_t v42 = v41;
        unint64_t v106 = (unint64_t)v40;
        if (*(_DWORD *)(a1 + 168)) {
          return 0LL;
        }
        goto LABEL_207;
      }
    }

    else
    {
      *(void *)(a1 + 8568) = BrotliAllocate(a1 + 144);
      uint64_t v41 = BrotliAllocate(a1 + 144);
      *(void *)(a1 + 8576) = v41;
      if (*(_DWORD *)(a1 + 168)) {
        return 0LL;
      }
      int v40 = *(unsigned int **)(a1 + 8568);
      if (v40)
      {
        unint64_t v42 = 0LL;
LABEL_197:
        unint64_t v106 = 0LL;
LABEL_207:
        unint64_t v122 = v106;
        unint64_t v123 = v42;
        uint64_t v124 = (char *)v41;
        v125 = v40;
        unint64_t v126 = v37;
        while (1)
        {
          if (*(void *)(a1 + 8592) || *(_DWORD *)(a1 + 8628) || (unint64_t v108 = *a3, !a2) && !v108)
          {
            BrotliFree((uint64_t)__src, v122);
            BrotliFree((uint64_t)__src, v123);
            if (*(_DWORD *)(a1 + 8628) == 1 && !*(void *)(a1 + 8592))
            {
LABEL_246:
              *(_DWORD *)(a1 + 8628) = 0;
              *(void *)(a1 + 8584) = 0LL;
            }

            return 1LL;
          }

          BOOL v109 = a2 == 2;
          unint64_t v110 = v37 >= v108 ? *a3 : v37;
          if (v108 <= v37)
          {
            BOOL v111 = a2 == 1;
          }

          else
          {
            BOOL v109 = 0;
            BOOL v111 = 0;
          }

          v135[0] = *(unsigned __int8 *)(a1 + 2434);
          if (v111 && v110 == 0) {
            break;
          }
          int v133 = v109;
          unint64_t v113 = 2 * v110 + 503;
          size_t v129 = *a5;
          size_t v131 = v113;
          if (v113 <= *a5)
          {
            unsigned int v115 = *a6;
          }

          else
          {
            uint64_t BrotliStorage = GetBrotliStorage(a1, v113);
            if (*(_DWORD *)(a1 + 168)) {
              return 0LL;
            }
            unsigned int v115 = (_BYTE *)BrotliStorage;
          }

          *unsigned int v115 = *(_BYTE *)(a1 + 2432);
          v115[1] = *(_BYTE *)(a1 + 2433);
          HashTable = GetHashTable(a1, *(_DWORD *)(a1 + 4), v110, &v134);
          if (*(_DWORD *)(a1 + 168)) {
            return 0LL;
          }
          uint64_t v118 = (char *)*a4;
          if (*(_DWORD *)(a1 + 4)) {
            BrotliCompressFragmentTwoPass( (uint64_t)__src,  v118,  v110,  v133,  v125,  v124,  (uint64_t)HashTable,  v134,  v135,  (uint64_t)v115);
          }
          else {
            BrotliCompressFragmentFast( (unint64_t)__src,  (unsigned __int8 *)v118,  v110,  v133,  (uint64_t)HashTable,  v134,  (unsigned __int8 *)(a1 + 7664),  a1 + 7792,  (unint64_t *)(a1 + 8560),  (_BYTE *)(a1 + 8048),  v135,  (uint64_t)v115);
          }
          if (*(_DWORD *)(a1 + 168)) {
            return 0LL;
          }
          if (v110)
          {
            *a4 = (char *)*a4 + v110;
            *a3 -= v110;
          }

          char v119 = v135[0];
          unint64_t v120 = v135[0] >> 3;
          if (v131 <= v129)
          {
            *a6 = (char *)*a6 + v120;
            *a5 -= v120;
            size_t v121 = *(void *)(a1 + 8600) + v120;
            *(void *)(a1 + 8600) = v121;
            if (a7) {
              *a7 = v121;
            }
          }

          else
          {
            *(void *)(a1 + 8584) = v115;
            *(void *)(a1 + 8592) = v120;
          }

          *(_WORD *)(a1 + 2432) = v115[v120];
          *(_BYTE *)(a1 + 2434) = v119 & 7;
          unint64_t v37 = v126;
          if ((v111 | v133) == 1)
          {
            if (v133) {
              int v116 = 2;
            }
            else {
              int v116 = 1;
            }
LABEL_243:
            *(_DWORD *)(a1 + 8628) = v116;
          }
        }

        int v116 = 1;
        goto LABEL_243;
      }
    }

    uint64_t v107 = BrotliAllocate((uint64_t)__src);
    uint64_t v41 = BrotliAllocate((uint64_t)__src);
    int v40 = (unsigned int *)v107;
    goto LABEL_206;
  }

  uint64_t v130 = a1 + 144;
  uint64_t v132 = (unint64_t *)(a1 + 8592);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v58 = *(void *)(a1 + 2248) - *(void *)(a1 + 2344);
        unint64_t v59 = 1LL << *(_DWORD *)(a1 + 12);
        BOOL v60 = v59 >= v58;
        unint64_t v61 = v59 - v58;
        if (!v60) {
          unint64_t v61 = 0LL;
        }
        unint64_t v62 = *(char *)(a1 + 2435);
        unint64_t v63 = v61 >= v62 ? *(char *)(a1 + 2435) : v61;
        size_t v64 = (v62 & 0x80000000) == 0LL ? v63 : v61;
        if (!v64 || !*a3) {
          break;
        }
        if (v64 >= *a3) {
          size_t v65 = *a3;
        }
        else {
          size_t v65 = v64;
        }
        v66 = (char *)*a4;
        unsigned int v67 = *(_DWORD *)(a1 + 2276);
        if (v67 || v65 >= *(unsigned int *)(a1 + 2264))
        {
          unsigned int v77 = *(_DWORD *)(a1 + 2268);
          if (*(_DWORD *)(a1 + 2272) >= v77) {
            goto LABEL_148;
          }
          __srca = (char *)*a4;
          unint64_t v78 = (_BYTE *)BrotliAllocate(v130);
          if (!*(_DWORD *)(a1 + 168))
          {
            int v79 = v78;
            unsigned int v80 = *(const void **)(a1 + 2280);
            if (v80)
            {
              memcpy(v78, v80, (*(_DWORD *)(a1 + 2272) + 2) + 7LL);
              BrotliFree(v130, *(void *)(a1 + 2280));
            }

            uint64_t v81 = 0LL;
            *(void *)(a1 + 2280) = v79;
            *(_DWORD *)(a1 + 2272) = v77;
            *(void *)(a1 + 2288) = v79 + 2;
            v79[1] = 0;
            *(_BYTE *)(*(void *)(a1 + 2288) - 2LL) = 0;
            do
              *(_BYTE *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2272) + v81++) = 0;
            while (v81 != 7);
            if (!*(_DWORD *)(a1 + 168))
            {
              *(_BYTE *)(*(void *)(a1 + 2288) + (*(_DWORD *)(a1 + 2256) - 2)) = 0;
              *(_BYTE *)(*(void *)(a1 + 2288) + (*(_DWORD *)(a1 + 2256) - 1)) = 0;
              *(_BYTE *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2256)) = -15;
              unsigned int v67 = *(_DWORD *)(a1 + 2276);
              v66 = __srca;
LABEL_148:
              uint64_t v82 = *(_DWORD *)(a1 + 2260) & v67;
              uint64_t v83 = *(unsigned int *)(a1 + 2264);
              size_t v84 = *(unsigned int *)(a1 + 2256);
              if (v82 < v83)
              {
                if (v65 >= v83 - v82) {
                  size_t v101 = v83 - v82;
                }
                else {
                  size_t v101 = v65;
                }
                unint64_t v102 = v66;
                memcpy((void *)(*(void *)(a1 + 2288) + v84 + v82), v66, v101);
                v66 = v102;
                size_t v84 = *(unsigned int *)(a1 + 2256);
              }

              char v85 = (void *)(*(void *)(a1 + 2288) + v82);
              if (v65 + v82 > v84)
              {
                else {
                  size_t v103 = v65;
                }
                unint64_t v104 = v66;
                memcpy(v85, v66, v103);
                char v85 = *(void **)(a1 + 2288);
                uint64_t v105 = *(unsigned int *)(a1 + 2256) - v82;
                v66 = &v104[v105];
                size_t v86 = v65 - v105;
              }

              else
              {
                size_t v86 = v65;
              }

              memcpy(v85, v66, v86);
              int v87 = *(_DWORD *)(a1 + 2276);
              *(_BYTE *)(*(void *)(a1 + 2288) - 2LL) = *(_BYTE *)(*(void *)(a1 + 2288)
                                                                  + (*(_DWORD *)(a1 + 2256) - 2));
              *(_BYTE *)(*(void *)(a1 + 2288) - 1LL) = *(_BYTE *)(*(void *)(a1 + 2288)
                                                                  + (*(_DWORD *)(a1 + 2256) - 1));
              if (v87 >= 0) {
                int v88 = (*(_DWORD *)(a1 + 2276) & 0x7FFFFFFF) + (v65 & 0x7FFFFFFF);
              }
              else {
                int v88 = ((*(_DWORD *)(a1 + 2276) & 0x7FFFFFFF) + (v65 & 0x7FFFFFFF)) | 0x80000000;
              }
              *(_DWORD *)(a1 + 2276) = v88;
LABEL_155:
              if (!*(_DWORD *)(a1 + 168))
              {
                *(void *)(a1 + 2248) += v65;
                uint64_t v89 = *(unsigned int *)(a1 + 2276);
                if (v89 <= *(_DWORD *)(a1 + 2260))
                {
                  v90 = (_DWORD *)(*(void *)(a1 + 2288) + v89);
                  *(_DWORD *)((char *)v90 + 3) = 0;
                  _DWORD *v90 = 0;
                }
              }
            }
          }
        }

        else
        {
          unint64_t v68 = *a4;
          *(_DWORD *)(a1 + 2276) = v65;
          int v69 = (_BYTE *)BrotliAllocate(v130);
          if (!*(_DWORD *)(a1 + 168))
          {
            unsigned int v70 = v69;
            v71 = *(const void **)(a1 + 2280);
            if (v71)
            {
              memcpy(v69, v71, (*(_DWORD *)(a1 + 2272) + 2) + 7LL);
              BrotliFree(v130, *(void *)(a1 + 2280));
            }

            uint64_t v72 = 0LL;
            *(void *)(a1 + 2280) = v70;
            *(_DWORD *)(a1 + 2272) = v65;
            *(void *)(a1 + 2288) = v70 + 2;
            v70[1] = 0;
            *(_BYTE *)(*(void *)(a1 + 2288) - 2LL) = 0;
            do
              *(_BYTE *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2272) + v72++) = 0;
            while (v72 != 7);
            if (!*(_DWORD *)(a1 + 168))
            {
              memcpy(*(void **)(a1 + 2288), v68, v65);
              goto LABEL_155;
            }
          }
        }

        *a4 = (char *)*a4 + v65;
        *a3 -= v65;
        int v91 = *(char *)(a1 + 2435);
        if (v91 >= 1) {
          *(_BYTE *)(a1 + 2435) = v91 - v65;
        }
      }

      if (*(unsigned __int8 *)(a1 + 2435) == 255)
      {
        int v76 = *(_DWORD *)(a1 + 8628);
        if (!v76) {
          goto LABEL_139;
        }
        if (v76 == 1 && !*v132)
        {
          *(_DWORD *)(a1 + 8628) = 0;
          *(void *)(a1 + 8584) = 0LL;
LABEL_139:
          *(_BYTE *)(a1 + 2435) = -2;
        }
      }
    }

    if (*v132) {
      return 1LL;
    }
    int v92 = *(_DWORD *)(a1 + 8628);
    if (v92)
    {
      if (v92 == 1) {
        goto LABEL_246;
      }
      return 1LL;
    }

    if (!a2 && v64) {
      return 1LL;
    }
    unint64_t v93 = *a3;
    if (*a3) {
      unsigned int v94 = 0;
    }
    else {
      unsigned int v94 = a2 == 2;
    }
    if (*a3) {
      BOOL v95 = 0;
    }
    else {
      BOOL v95 = a2 == 1;
    }
    if ((v94 & 1) == 0 && !*(_BYTE *)(a1 + 2435))
    {
      *(_BYTE *)(a1 + 2435) = -1;
      BOOL v95 = 1;
    }

    if (!*(void *)(a1 + 24))
    {
      uint64_t v96 = *(void *)(a1 + 2248) - *(void *)(a1 + 2344);
      unint64_t v97 = v96 | v93;
      uint64_t v99 = v96 + v93;
      unint64_t v98 = (v97 | v99) >> 30;
      uint64_t v99 = v99;
      if (v98) {
        uint64_t v99 = 0x40000000LL;
      }
      *(void *)(a1 + 24) = v99;
    }

    uint64_t result = EncodeData(a1, v94, v95, v132, (uint64_t *)(a1 + 8584), v73, v74, v75);
    if (!(_DWORD)result) {
      return result;
    }
    if ((v94 & 1) != 0 || v95)
    {
      if (v94) {
        int v100 = 2;
      }
      else {
        int v100 = 1;
      }
      *(_DWORD *)(a1 + 8628) = v100;
    }
  }

BOOL BrotliEncoderIsFinished(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8628) == 2 && *(void *)(a1 + 8592) == 0LL;
}

uint64_t InjectFlushOrPushOutput(uint64_t a1, size_t *a2, void **a3, size_t *a4)
{
  if (*(_DWORD *)(a1 + 8628) == 1 && (uint64_t v8 = *(unsigned __int8 *)(a1 + 2434), *(_BYTE *)(a1 + 2434)))
  {
    __int16 v9 = *(_WORD *)(a1 + 2432);
    *(_WORD *)(a1 + 2432) = 0;
    *(_BYTE *)(a1 + 2434) = 0;
    __int16 v10 = (6 << v8) | v9;
    uint64_t v11 = *(void *)(a1 + 8584);
    if (v11)
    {
      unint64_t v12 = (_BYTE *)(v11 + *(void *)(a1 + 8592));
    }

    else
    {
      unint64_t v12 = (_BYTE *)(a1 + 8608);
      *(void *)(a1 + 8584) = a1 + 8608;
    }

    *unint64_t v12 = v10;
    if (v8 >= 3)
    {
      v12[1] = HIBYTE(v10);
    }

    *(void *)(a1 + 8592) += (unint64_t)(v8 + 13) >> 3;
  }

  else
  {
    size_t v13 = *(void *)(a1 + 8592);
    if (!v13 || !*a2) {
      return 0LL;
    }
    if (v13 >= *a2) {
      size_t v14 = *a2;
    }
    else {
      size_t v14 = *(void *)(a1 + 8592);
    }
    memcpy(*a3, *(const void **)(a1 + 8584), v14);
    *a3 = (char *)*a3 + v14;
    *a2 -= v14;
    *(void *)(a1 + 8584) += v14;
    *(void *)(a1 + 8592) -= v14;
    size_t v15 = *(void *)(a1 + 8600) + v14;
    *(void *)(a1 + 8600) = v15;
    if (a4) {
      *a4 = v15;
    }
  }

  return 1LL;
}

uint64_t EncodeData( uint64_t a1, unsigned int a2, int a3, unint64_t *a4, uint64_t *a5, __n128 a6, __n128 a7, int32x4_t a8)
{
  uint64_t v8 = *(void *)(a1 + 2248);
  unint64_t v9 = *(void *)(a1 + 2344);
  unint64_t v10 = v8 - v9;
  if (v9 >> 30 >= 3) {
    unint64_t v11 = (((2 * (int)v9) >> 1) & 0xC0000000 | v9 & 0x3FFFFFFF) ^ 0x80000000;
  }
  else {
    unint64_t v11 = v9;
  }
  unsigned int v247 = v11;
  unsigned int v248 = v8 - v9;
  if (*(_DWORD *)(a1 + 8632)) {
    return 0LL;
  }
  unint64_t v12 = a5;
  size_t v13 = a4;
  int v14 = a3;
  unsigned int v15 = a2;
  if (a2) {
    *(_DWORD *)(a1 + 8632) = 1;
  }
  if (v10 > 1LL << *(_DWORD *)(a1 + 12)) {
    return 0LL;
  }
  uint64_t v18 = a1 + 144;
  int v19 = *(int **)(a1 + 2288);
  size_t v244 = *(unsigned int *)(a1 + 2260);
  unsigned int v20 = *(_DWORD *)(a1 + 4);
  if (v20 != 1) {
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 8568))
  {
    int v24 = *(int **)(a1 + 2288);
    uint64_t v25 = a1 + 144;
    *(void *)(a1 + 8568) = BrotliAllocate(a1 + 144);
    *(void *)(a1 + 8576) = BrotliAllocate(a1 + 144);
    if (*(_DWORD *)(a1 + 168)) {
      return 0LL;
    }
    unsigned int v20 = *(_DWORD *)(a1 + 4);
    uint64_t v18 = v25;
    int v19 = v24;
    unint64_t v12 = a5;
    size_t v13 = a4;
    int v14 = a3;
    unsigned int v15 = a2;
LABEL_13:
    if (v20 <= 1) {
      goto LABEL_14;
    }
    unint64_t v32 = (v10 >> 1) + *(void *)(a1 + 2312) + 1LL;
    if (v32 > *(void *)(a1 + 2296))
    {
      unint64_t v33 = v32 + (v10 >> 2) + 16;
      *(void *)(a1 + 2296) = v33;
      uint64_t v34 = v18;
      if (v33) {
        int v35 = (void *)BrotliAllocate(v18);
      }
      else {
        int v35 = 0LL;
      }
      if (*(_DWORD *)(a1 + 168)) {
        return 0LL;
      }
      unsigned int v36 = *(const void **)(a1 + 2304);
      if (v36)
      {
        memcpy(v35, v36, 16LL * *(void *)(a1 + 2312));
        BrotliFree(v34, *(void *)(a1 + 2304));
      }

      *(void *)(a1 + 2304) = v35;
      uint64_t v18 = v34;
    }

    v242 = (uint64_t *)(a1 + 2456);
    uint64_t v243 = v18;
    unint64_t v37 = v10;
    if (v15) {
      BOOL v38 = (_DWORD)v11 == 0;
    }
    else {
      BOOL v38 = 0;
    }
    int v39 = v38;
    if (*(void *)(a1 + 2456))
    {
      unint64_t v40 = v244;
      if (*(_DWORD *)(a1 + 2500)) {
        goto LABEL_154;
      }
      goto LABEL_119;
    }

    unsigned int v41 = *(_DWORD *)(a1 + 4);
    unint64_t v40 = v244;
    if ((int)v41 < 10)
    {
      if (v41 == 4)
      {
        if (*(void *)(a1 + 24) >= 0x100000uLL) {
          unsigned int v41 = 54;
        }
      }

      else if ((int)v41 > 4)
      {
        int v42 = *(_DWORD *)(a1 + 8);
        if (v42 > 16)
        {
          unsigned int v49 = v41 - 1;
          if (v42 < 0x13 || *(void *)(a1 + 24) < 0x100000uLL)
          {
            *(_DWORD *)(a1 + 48) = v49;
            if (v41 >= 9) {
              int v60 = 16;
            }
            else {
              int v60 = 10;
            }
            BOOL v61 = v41 >= 7;
            if (v41 < 7) {
              int v62 = 14;
            }
            else {
              int v62 = 15;
            }
            *(_DWORD *)(a1 + 40) = 5;
            *(_DWORD *)(a1 + 44) = v62;
            if (v61) {
              int v63 = v60;
            }
            else {
              int v63 = 4;
            }
            *(_DWORD *)(a1 + 56) = v63;
            unsigned int v41 = 5;
          }

          else
          {
            a6.n128_u64[0] = 0xF00000006LL;
            *(void *)(a1 + 40) = 0xF00000006LL;
            *(_DWORD *)(a1 + 48) = v49;
            *(_DWORD *)(a1 + 52) = 5;
            if (v41 >= 9) {
              int v50 = 16;
            }
            else {
              int v50 = 10;
            }
            if (v41 >= 7) {
              int v51 = v50;
            }
            else {
              int v51 = 4;
            }
            *(_DWORD *)(a1 + 56) = v51;
            unsigned int v41 = 6;
          }

          goto LABEL_54;
        }

        if (v41 < 9) {
          int v43 = 41;
        }
        else {
          int v43 = 42;
        }
        if (v41 >= 7) {
          unsigned int v41 = v43;
        }
        else {
          unsigned int v41 = 40;
        }
      }
    }

    else
    {
      unsigned int v41 = 10;
    }

    *(_DWORD *)(a1 + 40) = v41;
LABEL_54:
    int v44 = *(_DWORD *)(a1 + 8);
    v239 = (__n128 *)(a1 + 40);
    uint64_t v45 = 0LL;
    if (v44 < 25)
    {
      switch(v41)
      {
        case 2u:
        case 3u:
        case 4u:
          goto LABEL_83;
        case 5u:
        case 6u:
LABEL_58:
          uint64_t v46 = (4LL << *(_DWORD *)(a1 + 44) << *(_DWORD *)(a1 + 48)) + (2LL << *(_DWORD *)(a1 + 44));
          goto LABEL_82;
        case 7u:
        case 8u:
        case 9u:
          break;
        case 0xAu:
LABEL_65:
          uint64_t v48 = 1LL << v44;
          uint64_t v46 = 8 * v48 + 0x80000;
LABEL_82:
          if (v46)
          {
LABEL_83:
            unint64_t v52 = v37;
            int v53 = v39;
            uint64_t v45 = BrotliAllocate(v18);
            int v39 = v53;
            unint64_t v37 = v52;
            unint64_t v40 = v244;
          }

          else
          {
            uint64_t v45 = 0LL;
          }

          break;
        default:
          switch(v41)
          {
            case '#':
            case '(':
            case ')':
            case '*':
              goto LABEL_83;
            case '$':
            case '%':
            case '&':
            case '\'':
              goto LABEL_84;
            default:
              if (v41 == 54) {
                goto LABEL_83;
              }
              break;
          }

          break;
      }
    }

    else
    {
      switch(v41)
      {
        case 2u:
        case 4u:
          goto LABEL_83;
        case 3u:
          v239->n128_u32[0] = 35;
          goto LABEL_83;
        case 5u:
          goto LABEL_58;
        case 6u:
          *(_DWORD *)(a1 + 40) = 65;
          uint64_t v46 = (2LL << *(_DWORD *)(a1 + 44)) + 0x4000000 + (4LL << *(_DWORD *)(a1 + 44) << *(_DWORD *)(a1 + 48));
          goto LABEL_82;
        case 7u:
        case 8u:
        case 9u:
          break;
        case 0xAu:
          goto LABEL_65;
        default:
          switch(v41)
          {
            case '#':
            case '(':
            case ')':
            case '*':
              goto LABEL_83;
            case '$':
            case '%':
            case '&':
            case '\'':
              goto LABEL_84;
            default:
              if (v41 != 54) {
                goto LABEL_84;
              }
              v239->n128_u32[0] = 55;
              break;
          }

          goto LABEL_83;
      }
    }

LABEL_84:
    *(void *)(a1 + 2456) = v45;
    if (*(_DWORD *)(a1 + 168))
    {
LABEL_154:
      if (!*(_DWORD *)(a1 + 168))
      {
        int v83 = *(_DWORD *)(a1 + 2480);
        if (v83 <= 34)
        {
          switch(v83)
          {
            case 2:
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v106 = *(void *)(a1 + 2512);
                *(_DWORD *)(v106
                          + (((0xBD1E35A7BD000000LL * *(void *)((char *)v19 + ((v11 - 3) & v40))) >> 46) & 0x3FFFC)) = v11 - 3;
                *(_DWORD *)(v106
                          + (((0xBD1E35A7BD000000LL * *(void *)((char *)v19 + ((v11 - 2) & v40))) >> 46) & 0x3FFFC)) = v11 - 2;
                *(_DWORD *)(v106
                          + (((0xBD1E35A7BD000000LL * *(void *)((char *)v19 + ((v11 - 1) & v40))) >> 46) & 0x3FFFC)) = v11 - 1;
              }

              break;
            case 3:
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v136 = *(void *)(a1 + 2512);
                *(_DWORD *)(v136
                          + 4LL
                *(_DWORD *)(v136
                          + 4LL
                int v137 = v11 - 1;
                goto LABEL_308;
              }

              break;
            case 4:
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v136 = *(void *)(a1 + 2512);
                *(_DWORD *)(v136
                          + 4LL
                *(_DWORD *)(v136
                          + 4LL
                int v137 = v11 - 1;
                goto LABEL_308;
              }

              break;
            case 5:
              if (v37 >= 3 && v11 >= 3)
              {
                unsigned int v139 = (506832829 * *(int *)((char *)v19 + ((v11 - 3) & v40))) >> *(_DWORD *)(a1 + 2520);
                uint64_t v140 = *(void *)(a1 + 2544);
                unsigned int v141 = *(unsigned __int16 *)(v140 + 2LL * v139);
                uint64_t v142 = *(void *)(a1 + 2552);
                *(_DWORD *)(v142
                          + 4 * ((v139 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v141))) = v11 - 3;
                *(_WORD *)(v140 + 2LL * v139) = v141 + 1;
                unsigned int v143 = (506832829 * *(int *)((char *)v19 + ((v11 - 2) & v40))) >> *(_DWORD *)(a1 + 2520);
                unsigned int v144 = *(unsigned __int16 *)(v140 + 2LL * v143);
                *(_DWORD *)(v142
                          + 4 * ((v143 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v144))) = v11 - 2;
                *(_WORD *)(v140 + 2LL * v143) = v144 + 1;
                unsigned int v145 = (506832829 * *(int *)((char *)v19 + ((v11 - 1) & v40))) >> *(_DWORD *)(a1 + 2520);
                unsigned int v146 = *(unsigned __int16 *)(v140 + 2LL * v145);
                *(_DWORD *)(v142
                          + 4 * ((v145 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v146))) = v11 - 1;
                *(_WORD *)(v140 + 2LL * v145) = v146 + 1;
              }

              break;
            case 6:
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v147 = *(void *)(a1 + 2560);
                uint64_t v148 = *(void *)(a1 + 2568);
                unint64_t v149 = *(void *)(a1 + 2528);
                unint64_t v150 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 3) & v40)) & v149)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v151 = *(unsigned __int16 *)(v147 + 2LL * v150);
                *(_WORD *)(v147 + 2LL * v150) = v151 + 1;
                *(_DWORD *)(v148 + 4 * v152) = v11 - 3;
                unint64_t v153 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 2) & v40)) & v149)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v154 = *(unsigned __int16 *)(v147 + 2LL * v153);
                *(_WORD *)(v147 + 2LL * v153) = v154 + 1;
                *(_DWORD *)(v148 + 4 * v155) = v11 - 2;
                unint64_t v156 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 1) & v40)) & v149)) >> *(_DWORD *)(a1 + 2520);
                LODWORD(v149) = *(unsigned __int16 *)(v147 + 2LL * v156);
                *(_WORD *)(v147 + 2LL * v156) = v149 + 1;
                *(_DWORD *)(v148 + 4 * v157) = v11 - 1;
              }

              break;
            case 10:
              if (v37 >= 3 && v11 >= 0x80)
              {
                unint64_t v158 = v11 - 127;
                unint64_t v159 = v11 - 127 + v37;
                if (v11 < v159) {
                  unint64_t v159 = v11;
                }
                unint64_t v240 = v159;
                if (v158 < v159)
                {
                  uint64_t v160 = *(void *)(a1 + 2504);
                  uint64_t v238 = *(void *)(a1 + 2512);
                  uint64_t v161 = *(void *)(a1 + 2528);
                  do
                  {
                    uint64_t v162 = v11 - v158;
                    unint64_t v163 = v158 & v40;
                    if (v11 - v158 <= 0xF) {
                      uint64_t v162 = 15LL;
                    }
                    unsigned int v164 = (506832829 * *(int *)((char *)v19 + (v158 & v40))) >> 15;
                    uint64_t v165 = *(unsigned int *)(v238 + 4LL * v164);
                    uint64_t v166 = 2 * (v160 & v158);
                    uint64_t v167 = v166 | 1;
                    *(_DWORD *)(v238 + 4LL * v164) = v158;
                    if (v158 != v165)
                    {
                      unint64_t v169 = 0LL;
                      unint64_t v170 = 0LL;
                      unint64_t v171 = v160 - v162;
                      uint64_t v172 = 64LL;
                      do
                      {
                        if (v158 - v165 > v171 || v172 == 0) {
                          break;
                        }
                        unint64_t v174 = v165 & v40;
                        if (v170 >= v169) {
                          unint64_t v175 = v169;
                        }
                        else {
                          unint64_t v175 = v170;
                        }
                        v176 = (char *)v19 + v175 + v163;
                        char v177 = (unsigned __int8 *)v19 + v174 + v175;
                        unint64_t v178 = 128 - v175;
                        if (128 - v175 < 8)
                        {
                          unint64_t v181 = 0LL;
LABEL_269:
                          uint64_t v186 = v178 & 7;
                          if (v186)
                          {
                            unint64_t v187 = v181 | v186;
                            while (v176[v181] == *v177)
                            {
                              ++v177;
                              ++v181;
                              if (!--v186)
                              {
                                unint64_t v181 = v187;
                                break;
                              }
                            }
                          }
                        }

                        else
                        {
                          uint64_t v179 = 0LL;
                          unint64_t v180 = v178 >> 3;
                          unint64_t v181 = v178 & 0xFFFFFFFFFFFFFFF8LL;
                          while (1)
                          {
                            uint64_t v182 = *(void *)&v177[v179];
                            uint64_t v183 = *(void *)&v176[v179];
                            if (v182 != v183) {
                              break;
                            }
                            v179 += 8LL;
                            if (!--v180)
                            {
                              char v177 = (unsigned __int8 *)v19 + v174 + v175 + (v178 & 0xFFFFFFFFFFFFFFF8LL);
                              goto LABEL_269;
                            }
                          }

                          unint64_t v181 = v179 + (__clz(__rbit64(v183 ^ v182)) >> 3);
                        }

                        unint64_t v184 = v181 + v175;
                        if (v181 + v175 >= 0x80)
                        {
                          v188 = (int *)(v161 + 8 * (v165 & v160));
                          int v189 = *v188;
                          unsigned int v168 = v188 + 1;
                          *(_DWORD *)(v161 + 4 * v166) = v189;
                          unint64_t v40 = v244;
                          goto LABEL_246;
                        }

                        uint64_t v185 = 2 * (v165 & v160);
                        unint64_t v40 = v244;
                        if (*((unsigned __int8 *)v19 + v184 + v163) <= *((unsigned __int8 *)v19
                                                                                      + v184
                                                                                      + v174))
                        {
                          *(_DWORD *)(v161 + 4 * v167) = v165;
                          unint64_t v169 = v184;
                          uint64_t v167 = 2 * (v165 & v160);
                        }

                        else
                        {
                          *(_DWORD *)(v161 + 4 * v166) = v165;
                          uint64_t v166 = v185 | 1;
                          unint64_t v170 = v184;
                          v185 |= 1uLL;
                        }

                        uint64_t v165 = *(unsigned int *)(v161 + 4 * v185);
                        --v172;
                      }

                      while (v158 != v165);
                    }

                    *(_DWORD *)(v161 + 4 * v166) = *(_DWORD *)(a1 + 2520);
                    unsigned int v168 = (_DWORD *)(a1 + 2520);
LABEL_246:
                    *(_DWORD *)(v161 + 4 * v167) = *v168;
                    ++v158;
                  }

                  while (v158 != v240);
                }
              }

              break;
            default:
              break;
          }
        }

        else if (v83 > 53)
        {
          switch(v83)
          {
            case '6':
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v136 = *(void *)(a1 + 2512);
                *(_DWORD *)(v136
                          + 4LL
                          * (((((unint64_t)(0x35A7BD1E35A7BD00LL
                *(_DWORD *)(v136
                          + 4LL
                          * (((((unint64_t)(0x35A7BD1E35A7BD00LL
                int v137 = v11 - 1;
                uint64_t v138 = ((((unint64_t)(0x35A7BD1E35A7BD00LL
LABEL_308:
                *(_DWORD *)(v136 + 4 * v138) = v137;
              }

              break;
            case '7':
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v226 = *(void *)(a1 + 2512);
                *(_DWORD *)(v226
                          + 4LL
                          * (((((unint64_t)(0x35A7BD1E35A7BD00LL
                *(_DWORD *)(v226
                          + 4LL
                          * (((((unint64_t)(0x35A7BD1E35A7BD00LL
                *(_DWORD *)(v226
                          + 4LL
                          * (((((unint64_t)(0x35A7BD1E35A7BD00LL
              }

              unint64_t v227 = 4 - (v11 & 3);
              if ((v11 & 3) != 0) {
                uint64_t v228 = 4 - (v11 & 3);
              }
              else {
                uint64_t v228 = 0LL;
              }
              BOOL v61 = v37 >= v227;
              unint64_t v229 = v37 - v227;
              if (!v61) {
                unint64_t v229 = 0LL;
              }
              if ((v11 & 3) != 0) {
                unint64_t v230 = v229;
              }
              else {
                unint64_t v230 = v37;
              }
              unint64_t v195 = v228 + v11;
              unint64_t v231 = (v228 + v11) & v40;
              unint64_t v232 = v40 - v231;
              if (v230 < v40 - v231) {
                unint64_t v232 = v230;
              }
              if (v232 >= 0x20)
              {
                unint64_t v233 = 0LL;
                int v199 = 0;
                __int128 v234 = (char *)v19 + v231;
                do
                {
                  int v199 = v234[v233] + v199 * *(_DWORD *)(a1 + 2548) + 1;
                  BOOL v61 = v233 >= 0x1C;
                  v233 += 4LL;
                }

                while (!v61);
LABEL_326:
                *(_DWORD *)(a1 + 2520) = v199;
              }

LABEL_327:
              *(void *)(a1 + 2536) = v195;
              break;
            case 'A':
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v121 = *(void *)(a1 + 2560);
                uint64_t v122 = *(void *)(a1 + 2568);
                unint64_t v123 = *(void *)(a1 + 2528);
                unint64_t v124 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 3) & v40)) & v123)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v125 = *(unsigned __int16 *)(v121 + 2LL * v124);
                *(_WORD *)(v121 + 2LL * v124) = v125 + 1;
                *(_DWORD *)(v122 + 4 * v126) = v11 - 3;
                unint64_t v127 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 2) & v40)) & v123)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v128 = *(unsigned __int16 *)(v121 + 2LL * v127);
                *(_WORD *)(v121 + 2LL * v127) = v128 + 1;
                *(_DWORD *)(v122 + 4 * v129) = v11 - 2;
                unint64_t v130 = (0x1FE35A7BD3579BD3LL * (*(void *)((_BYTE *)v19 + ((v11 - 1) & v40)) & v123)) >> *(_DWORD *)(a1 + 2520);
                LODWORD(v123) = *(unsigned __int16 *)(v121 + 2LL * v130);
                *(_WORD *)(v121 + 2LL * v130) = v123 + 1;
                *(_DWORD *)(v122 + 4 * v131) = v11 - 1;
              }

              unint64_t v132 = v40 - (v40 & v11);
              if (v132 >= v37) {
                unint64_t v132 = v37;
              }
              if (v132 >= 0x20)
              {
                uint64_t v133 = 0LL;
                int v134 = 0;
                do
                  int v134 = *((unsigned __int8 *)v19 + (v40 & v11) + v133++) + v134 * *(_DWORD *)(a1 + 2604) + 1;
                while (v133 != 32);
                *(_DWORD *)(a1 + 2576) = v134;
              }

              *(void *)(a1 + 2592) = v11;
              break;
          }
        }

        else
        {
          switch(v83)
          {
            case '#':
              if (v37 >= 7 && v11 >= 3)
              {
                uint64_t v190 = *(void *)(a1 + 2512);
                *(_DWORD *)(v190
                          + 4LL
                *(_DWORD *)(v190
                          + 4LL
                *(_DWORD *)(v190
                          + 4LL
              }

              unint64_t v191 = 4 - (v11 & 3);
              if ((v11 & 3) != 0) {
                uint64_t v192 = 4 - (v11 & 3);
              }
              else {
                uint64_t v192 = 0LL;
              }
              BOOL v61 = v37 >= v191;
              unint64_t v193 = v37 - v191;
              if (!v61) {
                unint64_t v193 = 0LL;
              }
              if ((v11 & 3) != 0) {
                unint64_t v194 = v193;
              }
              else {
                unint64_t v194 = v37;
              }
              unint64_t v195 = v192 + v11;
              unint64_t v196 = (v192 + v11) & v40;
              unint64_t v197 = v40 - v196;
              if (v194 < v40 - v196) {
                unint64_t v197 = v194;
              }
              if (v197 < 0x20) {
                goto LABEL_327;
              }
              unint64_t v198 = 0LL;
              int v199 = 0;
              __int128 v200 = (char *)v19 + v196;
              do
              {
                int v199 = v200[v198] + v199 * *(_DWORD *)(a1 + 2548) + 1;
                BOOL v61 = v198 >= 0x1C;
                v198 += 4LL;
              }

              while (!v61);
              goto LABEL_326;
            case '(':
            case ')':
              if (v37 >= 3 && v11 >= 3)
              {
                uint64_t v84 = *(void *)(a1 + 2520);
                unsigned int v85 = (506832829 * *(int *)((char *)v19 + ((v11 - 3) & v40))) >> 17;
                uint64_t v86 = v84 + 2LL * v85;
                uint64_t v87 = *(unsigned __int16 *)(a1 + 2504);
                uint64_t v88 = v84 + 4 * v87;
                unsigned __int16 v89 = v87 + 1;
                *(_WORD *)(a1 + 2504) = v87 + 1;
                unint64_t v90 = v11 - 3 - *(unsigned int *)(v84 + 4LL * v85);
                *(_BYTE *)(v84 + (unsigned __int16)(v11 - 3) + 196608) = v85;
                __int16 v91 = -1;
                if (v90 >= 0xFFFF) {
                  LOWORD(v90) = -1;
                }
                *(_WORD *)(v88 + 0x40000) = v90;
                __int16 v92 = *(_WORD *)(v86 + 0x20000);
                *(_DWORD *)(v84 + 4LL * v85) = v11 - 3;
                *(_WORD *)(v88 + 262146) = v92;
                *(_WORD *)(v86 + 0x20000) = v87;
                uint64_t v93 = *(void *)(a1 + 2520);
                unsigned int v94 = (506832829 * *(int *)((char *)v19 + ((v11 - 2) & v40))) >> 17;
                uint64_t v95 = v93 + 2LL * v94;
                uint64_t v96 = v93 + 4LL * v89;
                *(_WORD *)(a1 + 2504) = v87 + 2;
                unint64_t v97 = v11 - 2 - *(unsigned int *)(v93 + 4LL * v94);
                *(_BYTE *)(v93 + (unsigned __int16)(v11 - 2) + 196608) = v94;
                if (v97 >= 0xFFFF) {
                  LOWORD(v97) = -1;
                }
                *(_WORD *)(v96 + 0x40000) = v97;
                __int16 v98 = *(_WORD *)(v95 + 0x20000);
                *(_DWORD *)(v93 + 4LL * v94) = v11 - 2;
                *(_WORD *)(v95 + 0x20000) = v89;
                *(_WORD *)(v96 + 262146) = v98;
                uint64_t v99 = *(void *)(a1 + 2520);
                unsigned int v100 = (506832829 * *(int *)((char *)v19 + ((v11 - 1) & v40))) >> 17;
                uint64_t v101 = v99 + 2LL * v100;
                uint64_t v102 = *(unsigned __int16 *)(a1 + 2504);
                uint64_t v103 = v99 + 4 * v102;
                *(_WORD *)(a1 + 2504) = v102 + 1;
                uint64_t v104 = *(unsigned int *)(v99 + 4LL * v100);
                *(_BYTE *)(v99 + (unsigned __int16)(v11 - 1) + 196608) = v100;
                __int16 v105 = *(_WORD *)(v101 + 0x20000);
                if (v11 - 1 - v104 < 0xFFFF) {
                  __int16 v91 = v11 - 1 - v104;
                }
                *(_WORD *)(v103 + 0x40000) = v91;
                *(_WORD *)(v103 + 262146) = v105;
                *(_DWORD *)(v99 + 4LL * v100) = v11 - 1;
                *(_WORD *)(v101 + 0x20000) = v102;
              }

              break;
            case '*':
              if (v37 >= 3 && v11 >= 3)
              {
                uint64_t v201 = a1 + 2504;
                uint64_t v202 = *(void *)(a1 + 3536);
                unsigned int v203 = (506832829 * *(int *)((char *)v19 + ((v11 - 3) & v40))) >> 17;
                uint64_t v204 = v202 + 2LL * v203;
                __int16 v205 = *(_WORD *)(a1 + 2504 + 2LL * (v203 & 0x1FF));
                *(_WORD *)(a1 + 2504 + 2LL * (v203 & 0x1FF)) = v205 + 1;
                uint64_t v206 = v205 & 0x1FF;
                unint64_t v207 = v11 - 3 - *(unsigned int *)(v202 + 4LL * v203);
                *(_BYTE *)(v202 + (unsigned __int16)(v11 - 3) + 196608) = v203;
                if (v207 >= 0xFFFF) {
                  __int16 v208 = -1;
                }
                else {
                  __int16 v208 = v207;
                }
                v209 = (__int16 *)(v202 + ((unint64_t)(v203 & 0x1FF) << 11) + 4 * v206 + 0x40000);
                __int16 *v209 = v208;
                v209[1] = *(_WORD *)(v204 + 0x20000);
                *(_DWORD *)(v202 + 4LL * v203) = v11 - 3;
                *(_WORD *)(v204 + 0x20000) = v206;
                uint64_t v210 = *(void *)(a1 + 3536);
                unsigned int v211 = (506832829 * *(int *)((char *)v19 + ((v11 - 2) & v40))) >> 17;
                uint64_t v212 = v210 + 2LL * v211;
                __int16 v213 = *(_WORD *)(v201 + 2LL * (v211 & 0x1FF));
                *(_WORD *)(v201 + 2LL * (v211 & 0x1FF)) = v213 + 1;
                uint64_t v214 = v213 & 0x1FF;
                unint64_t v215 = v11 - 2 - *(unsigned int *)(v210 + 4LL * v211);
                *(_BYTE *)(v210 + (unsigned __int16)(v11 - 2) + 196608) = v211;
                if (v215 >= 0xFFFF) {
                  __int16 v216 = -1;
                }
                else {
                  __int16 v216 = v215;
                }
                unint64_t v217 = v210 + ((unint64_t)(v211 & 0x1FF) << 11) + 4 * v214 + 0x40000;
                *(_WORD *)unint64_t v217 = v216;
                *(_WORD *)(v217 + 2) = *(_WORD *)(v212 + 0x20000);
                *(_DWORD *)(v210 + 4LL * v211) = v11 - 2;
                *(_WORD *)(v212 + 0x20000) = v214;
                uint64_t v218 = *(void *)(a1 + 3536);
                unsigned int v219 = (506832829 * *(int *)((char *)v19 + ((v11 - 1) & v40))) >> 17;
                uint64_t v220 = v218 + 2LL * v219;
                LOWORD(v217) = *(_WORD *)(v201 + 2LL * (v219 & 0x1FF));
                *(_WORD *)(v201 + 2LL * (v219 & 0x1FF)) = v217 + 1;
                unint64_t v221 = v217 & 0x1FF;
                unint64_t v222 = v11 - 1 - *(unsigned int *)(v218 + 4LL * v219);
                *(_BYTE *)(v218 + (unsigned __int16)(v11 - 1) + 196608) = v219;
                if (v222 >= 0xFFFF) {
                  __int16 v223 = -1;
                }
                else {
                  __int16 v223 = v222;
                }
                __int16 v224 = *(_WORD *)(v220 + 0x20000);
                v225 = (__int16 *)(v218 + ((unint64_t)(v219 & 0x1FF) << 11) + 4 * v221 + 0x40000);
                __int16 *v225 = v223;
                v225[1] = v224;
                *(_DWORD *)(v218 + 4LL * v219) = v11 - 1;
                *(_WORD *)(v220 + 0x20000) = v221;
              }

              break;
            default:
              break;
          }
        }
      }

      unint64_t v79 = *(void *)(a1 + 2336);
      if (v79 > 0xBFFFFFFF) {
        uint64_t v80 = (((2 * (int)v79) >> 1) & 0xC0000000 | v79 & 0x3FFFFFFF) ^ 0x80000000;
      }
      else {
        uint64_t v80 = v79;
      }
      else {
        unsigned int v81 = 3;
      }
      if (*(_DWORD *)(a1 + 168)) {
        return 0LL;
      }
      if (*(void *)(a1 + 2312) && !*(void *)(a1 + 2328)) {
        ExtendLastCommand(a1, &v248, &v247);
      }
      int v82 = *(_DWORD *)(a1 + 4);
      if (v82 == 11)
      {
        BrotliCreateHqZopfliBackwardReferences( v243,  v248,  v247,  (uint64_t)v19,  v40,  (uint64_t)&_kBrotliContextLookupTable[512 * v81],  a1,  (uint64_t)v242,  (__int128 *)(a1 + 2352),  (void *)(a1 + 2328),  *(void *)(a1 + 2304) + 16LL * *(void *)(a1 + 2312),  (uint64_t *)(a1 + 2312),  (void *)(a1 + 2320));
      }

      else
      {
        if (v82 != 10)
        {
          BrotliCreateBackwardReferences( v248,  v247,  (uint64_t)v19,  v40,  a6.n128_f64[0],  a7.n128_f64[0],  a8,  (uint64_t)&_kBrotliContextLookupTable[512 * v81],  a1,  (uint64_t)v242,  (int *)(a1 + 2352),  (unint64_t *)(a1 + 2328),  (_DWORD *)(*(void *)(a1 + 2304) + 16LL * *(void *)(a1 + 2312)),  (void *)(a1 + 2312),  (void *)(a1 + 2320));
          goto LABEL_189;
        }

        BrotliCreateZopfliBackwardReferences( v243,  v248,  v247,  (uint64_t)v19,  v40,  (uint64_t)&_kBrotliContextLookupTable[512 * v81],  a1,  v242,  a1 + 2352,  (void *)(a1 + 2328),  *(void *)(a1 + 2304) + 16LL * *(void *)(a1 + 2312),  (void *)(a1 + 2312),  (void *)(a1 + 2320));
      }

      if (*(_DWORD *)(a1 + 168)) {
        return 0LL;
      }
LABEL_189:
      int v107 = *(_DWORD *)(a1 + 8);
      int v108 = *(_DWORD *)(a1 + 12);
      if (v107 <= v108) {
        int v107 = *(_DWORD *)(a1 + 12);
      }
      if (v107 >= 23) {
        char v109 = 23;
      }
      else {
        char v109 = v107;
      }
      uint64_t v110 = *(void *)(a1 + 2248);
      uint64_t v111 = *(void *)(a1 + 2336);
      BOOL v112 = *(int *)(a1 + 4) <= 3 && *(void *)(a1 + 2312) + *(void *)(a1 + 2320) > 0x2FFEuLL;
      uint64_t v113 = v110 - v111;
      if (v14 | v15
        || v112
        || (unint64_t v114 = 1LL << (v109 + 1), v113 + (1LL << v108) > v114)
        || *(void *)(a1 + 2320) >= v114 >> 3
        || *(void *)(a1 + 2312) >= v114 >> 3)
      {
        unint64_t v115 = *(void *)(a1 + 2328);
        if (v115)
        {
          uint64_t v116 = *(void *)(a1 + 2304);
          uint64_t v117 = *(void *)(a1 + 2312);
          *(void *)(a1 + 2312) = v117 + 1;
          uint64_t v118 = v116 + 16 * v117;
          *(_DWORD *)uint64_t v118 = v115;
          *(void *)(v118 + 4) = 0x8000000LL;
          *(_WORD *)(v118 + 14) = 16;
          char v119 = (_WORD *)(v118 + 12);
          if (v115 > 5)
          {
            if (v115 > 0x81)
            {
              if (v115 > 0x841)
              {
                if (v115 >> 1 >= 0xC21)
                {
                  if (v115 < 0x5842) {
                    LOWORD(v120) = 22;
                  }
                  else {
                    LOWORD(v120) = 23;
                  }
                }

                else
                {
                  LOWORD(v120) = 21;
                }
              }

              else
              {
                unsigned int v120 = (__clz(v115 - 66) ^ 0x1F) + 10;
              }
            }

            else
            {
              unsigned int v135 = (__clz(v115 - 2) ^ 0x1F) - 1;
              unsigned int v120 = ((v115 - 2) >> v135) + 2 * v135 + 2;
            }
          }

          else
          {
            LOWORD(v120) = v115;
          }

          *(void *)(a1 + 2320) += v115;
          *(void *)(a1 + 2328) = 0LL;
        }

        if (v15 || v110 != v111)
        {
          uint64_t BrotliStorage = (char *)GetBrotliStorage(a1, (2 * v113 + 503));
          unint64_t v246 = *(unsigned __int8 *)(a1 + 2434);
          if (!*(_DWORD *)(a1 + 168))
          {
            uint64_t v29 = (uint64_t)BrotliStorage;
            *uint64_t BrotliStorage = *(_BYTE *)(a1 + 2432);
            BrotliStorage[1] = *(_BYTE *)(a1 + 2433);
            WriteMetaBlockInternal( v243,  (uint64_t)v19,  v244,  *(void *)(a1 + 2336),  v113,  v15,  v81,  a1,  *(_WORD *)(a1 + 2436),  HIBYTE(*(_WORD *)(a1 + 2436)),  *(void *)(a1 + 2320),  *(void *)(a1 + 2312),  *(unsigned int **)(a1 + 2304),  (_OWORD *)(a1 + 2416),  (_OWORD *)(a1 + 2352),  (uint64_t *)&v246,  BrotliStorage);
            if (!*(_DWORD *)(a1 + 168))
            {
              char v236 = v246;
              unint64_t v26 = v246 >> 3;
              *(_WORD *)(a1 + 2432) = *(unsigned __int8 *)(v29 + (v246 >> 3));
              *(_BYTE *)(a1 + 2434) = v236 & 7;
              *(void *)(a1 + 2336) = *(void *)(a1 + 2248);
              if (UpdateLastProcessedPos(a1)) {
                *(_DWORD *)(a1 + 2500) = 0;
              }
              uint64_t v237 = *(void *)(a1 + 2336);
              if (v237)
              {
                *(_BYTE *)(a1 + 2436) = *((_BYTE *)v19 + (((_DWORD)v237 - 1) & v244));
                if (v237 != 1) {
                  *(_BYTE *)(a1 + 2437) = *((_BYTE *)v19 + (((_DWORD)v237 - 2) & v244));
                }
              }

              *(void *)(a1 + 2312) = 0LL;
              *(void *)(a1 + 2320) = 0LL;
              *(_OWORD *)(a1 + 2416) = *(_OWORD *)(a1 + 2352);
              goto LABEL_64;
            }
          }

          return 0LL;
        }
      }

      else if (UpdateLastProcessedPos(a1))
      {
        *(_DWORD *)(a1 + 2500) = 0;
      }

      *size_t v13 = 0LL;
      return 1LL;
    }

    a6 = *v239;
    *(__n128 *)(a1 + 2480) = *v239;
    *(_DWORD *)(a1 + 2496) = *(_DWORD *)(a1 + 56);
    int v54 = *(_DWORD *)(a1 + 2480);
    if (v54 <= 34)
    {
      switch(v54)
      {
        case 2:
        case 3:
        case 4:
          goto LABEL_99;
        case 5:
          unint64_t v57 = v40;
          unint64_t v58 = v37;
          int v59 = v39;
          InitializeH5(v242, a1 + 2504);
          goto LABEL_112;
        case 6:
          unint64_t v57 = v40;
          unint64_t v58 = v37;
          int v59 = v39;
          InitializeH6(v242, a1 + 2504);
LABEL_112:
          int v39 = v59;
          unint64_t v37 = v58;
          unint64_t v40 = v57;
          break;
        case 10:
          *(void *)(a1 + 2512) = v45;
          *(void *)(a1 + 2528) = v45 + 0x80000;
          int v64 = -1 << *(_DWORD *)(a1 + 8);
          *(void *)(a1 + 2504) = ~v64;
          *(_DWORD *)(a1 + 2520) = v64 + 1;
          break;
        default:
          break;
      }
    }

    else if (v54 > 53)
    {
      switch(v54)
      {
        case '6':
LABEL_99:
          *(void *)(a1 + 2504) = v242;
          *(void *)(a1 + 2512) = v45;
          break;
        case '7':
LABEL_100:
          *(void *)(a1 + 2616) = v242;
          *(void *)(a1 + 2608) = v45;
          a7 = *(__n128 *)(a1 + 2472);
          *(_OWORD *)(a1 + 2560) = *(_OWORD *)v242;
          *(__n128 *)(a1 + 2576) = a7;
          a6 = *(__n128 *)(a1 + 2488);
          *(__n128 *)(a1 + 2592) = a6;
          *(_DWORD *)(a1 + 2624) = 1;
          *(void *)(a1 + 2632) = a1;
          break;
        case 'A':
          *(void *)(a1 + 2672) = v242;
          *(void *)(a1 + 2664) = v45;
          a7 = *(__n128 *)(a1 + 2472);
          *(_OWORD *)(a1 + 2616) = *(_OWORD *)v242;
          *(__n128 *)(a1 + 2632) = a7;
          a6 = *(__n128 *)(a1 + 2488);
          *(__n128 *)(a1 + 2648) = a6;
          *(_DWORD *)(a1 + 2680) = 1;
          *(void *)(a1 + 2688) = a1;
          break;
      }
    }

    else
    {
      switch(v54)
      {
        case '#':
          goto LABEL_100;
        case '(':
        case ')':
          *(void *)(a1 + 2528) = v242;
          *(void *)(a1 + 2520) = v45;
          int v55 = *(_DWORD *)(a1 + 4);
          if (v55 >= 7) {
            int v56 = 7;
          }
          else {
            int v56 = 8;
          }
          *(void *)(a1 + 2512) = (v56 << (v55 - 4));
          break;
        case '*':
          *(void *)(a1 + 3544) = v242;
          *(void *)(a1 + 3536) = v45;
          int v65 = *(_DWORD *)(a1 + 4);
          if (v65 >= 7) {
            int v66 = 7;
          }
          else {
            int v66 = 8;
          }
          *(void *)(a1 + 3528) = (v66 << (v65 - 4));
          break;
        default:
          break;
      }
    }

    *(_DWORD *)(a1 + 2500) = 0;
LABEL_119:
    int v67 = *(_DWORD *)(a1 + 2480);
    if (v67 <= 34)
    {
      switch(v67)
      {
        case 2:
          unint64_t v68 = *(_DWORD **)(a1 + 2512);
          if (v37 > 0x800 || !v39) {
            goto LABEL_146;
          }
          if (!v37) {
            goto LABEL_152;
          }
          int v69 = v19;
          unint64_t v70 = v37;
          do
          {
            uint64_t v71 = *(void *)v69;
            int v69 = (int *)((char *)v69 + 1);
            *(_DWORD *)((char *)v68 + (((0xBD1E35A7BD000000LL * v71) >> 46) & 0x3FFFC)) = 0;
            --v70;
          }

          while (v70);
          break;
        case 3:
          unint64_t v68 = *(_DWORD **)(a1 + 2512);
          if (v37 <= 0x800 && v39)
          {
            if (!v37) {
              goto LABEL_152;
            }
            uint64_t v72 = v19;
            unint64_t v73 = v37;
            do
            {
              uint64_t v74 = *(void *)v72;
              uint64_t v72 = (int *)((char *)v72 + 1);
              unint64_t v75 = (0xBD1E35A7BD000000LL * v74) >> 48;
              v68[v75] = 0;
              v68[(unsigned __int16)(v75 + 8)] = 0;
              --v73;
            }

            while (v73);
          }

          else
          {
LABEL_146:
            bzero(v68, 0x40000uLL);
          }

          break;
        case 4:
          PrepareH4(a1 + 2504, v39, v37, (uint64_t)v19);
          break;
        case 5:
          PrepareH5((unint64_t *)(a1 + 2504), v39, v37, v19);
          break;
        case 6:
          PrepareH6((unint64_t *)(a1 + 2504), v39, v37, (uint64_t *)v19);
          break;
        case 10:
          uint64_t v76 = 0LL;
          uint64_t v77 = *(void *)(a1 + 2512);
          unint64_t v78 = (const float *)(a1 + 2520);
          a6 = (__n128)vld1q_dup_f32(v78);
          do
          {
            *(__n128 *)(v77 + v76) = a6;
            v76 += 16LL;
          }

          while (v76 != 0x80000);
          break;
        default:
          break;
      }
    }

    else if (v67 > 53)
    {
      switch(v67)
      {
        case '6':
          PrepareH54(a1 + 2504, v39, v37, (uint64_t)v19);
          break;
        case '7':
          PrepareH55(a1 + 2504, v39, v37, (uint64_t)v19);
          break;
        case 'A':
          PrepareH65(a1 + 2504, v39, v37, (uint64_t *)v19);
          break;
      }
    }

    else
    {
      switch(v67)
      {
        case '#':
          PrepareH35(a1 + 2504, v39, v37, (uint64_t *)v19);
          break;
        case '(':
        case ')':
          PrepareH40(a1 + 2504, v39, v37, v19);
          break;
        case '*':
          PrepareH42((void **)(a1 + 2504), v39, v37, v19);
          break;
        default:
          break;
      }
    }

    if (!(_DWORD)v11)
    {
LABEL_152:
      *(void *)(a1 + 2472) = 0LL;
      *(void *)(a1 + 2464) = 0LL;
    }

    *(_DWORD *)(a1 + 2500) = 1;
    goto LABEL_154;
  }

LABEL_14:
  unint64_t v246 = *(unsigned __int8 *)(a1 + 2434);
  if (v15 || v8 != v9)
  {
    unint64_t v27 = v18;
    int v28 = (_BYTE *)GetBrotliStorage(a1, (2 * v10 + 503));
    if (!*(_DWORD *)(a1 + 168))
    {
      uint64_t v29 = (uint64_t)v28;
      *int v28 = *(_BYTE *)(a1 + 2432);
      v28[1] = *(_BYTE *)(a1 + 2433);
      HashTable = GetHashTable(a1, *(_DWORD *)(a1 + 4), v10, &v245);
      if (!*(_DWORD *)(a1 + 168))
      {
        unint64_t v31 = (char *)v19 + (v244 & v11);
        if (*(_DWORD *)(a1 + 4)) {
          BrotliCompressFragmentTwoPass( v27,  v31,  v10,  v15,  *(unsigned int **)(a1 + 8568),  *(char **)(a1 + 8576),  (uint64_t)HashTable,  v245,  &v246,  v29);
        }
        else {
          BrotliCompressFragmentFast( v27,  (unsigned __int8 *)v31,  v10,  v15,  (uint64_t)HashTable,  v245,  (unsigned __int8 *)(a1 + 7664),  a1 + 7792,  (unint64_t *)(a1 + 8560),  (_BYTE *)(a1 + 8048),  &v246,  v29);
        }
        if (!*(_DWORD *)(a1 + 168))
        {
          char v47 = v246;
          unint64_t v26 = v246 >> 3;
          *(_WORD *)(a1 + 2432) = *(unsigned __int8 *)(v29 + (v246 >> 3));
          *(_BYTE *)(a1 + 2434) = v47 & 7;
          UpdateLastProcessedPos(a1);
LABEL_64:
          *unint64_t v12 = v29;
          goto LABEL_17;
        }
      }
    }

    return 0LL;
  }

  unint64_t v26 = 0LL;
LABEL_17:
  *size_t v13 = v26;
  return 1LL;
}

BOOL BrotliEncoderHasMoreOutput(uint64_t a1)
{
  return *(void *)(a1 + 8592) != 0LL;
}

uint64_t BrotliEncoderTakeOutput(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 8592);
  if (*a2 >= v2) {
    unint64_t v3 = *(void *)(a1 + 8592);
  }
  else {
    unint64_t v3 = *a2;
  }
  if (!*a2) {
    unint64_t v3 = *(void *)(a1 + 8592);
  }
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 8584);
    *(void *)(a1 + 8584) = v4 + v3;
    *(void *)(a1 + 8592) = v2 - v3;
    *(void *)(a1 + 8600) += v3;
    if (*(_DWORD *)(a1 + 8628) == 1 && v2 == v3)
    {
      *(_DWORD *)(a1 + 8628) = 0;
      *(void *)(a1 + 8584) = 0LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *a2 = v3;
  return v4;
}

uint64_t BrotliEncoderVersion()
{
  return 16777225LL;
}

uint64_t ChooseDistanceParams(_DWORD *a1)
{
  if ((int)a1[1] < 4
    || (*a1 != 2 ? (v1 = a1[16], unsigned int v2 = a1[17]) : (v1 = 1, unsigned int v2 = 12), v1 > 3 || v2 > 0x78 || ((v2 >> v1) & 0xF) << v1 != v2))
  {
    unsigned int v2 = 0;
    unsigned int v1 = 0;
  }

  return BrotliInitDistanceParams((uint64_t)a1, v1, v2);
}

BOOL ShouldCompress( uint64_t a1, unsigned int a2, int a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (a4 < 3) {
    return 0LL;
  }
  bzero(v25, 0x400uLL);
  if (a4 + 12 >= 0xD)
  {
    unint64_t v11 = (a4 + 12) / 0xD;
    do
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + (a3 & a2));
      ++v25[v12];
      a3 += 13;
      --v11;
    }

    while (v11);
  }

  uint64_t v13 = 0LL;
  unint64_t v14 = 0LL;
  double v15 = 0.0;
  double v16 = (double)a4 * 7.92 / 13.0;
  do
  {
    unsigned int v17 = &v25[v13];
    uint64_t v18 = *v17;
    else {
      double v19 = kBrotliLog2Table[v18];
    }
    uint64_t v20 = v17[1];
    else {
      double v21 = kBrotliLog2Table[v20];
    }
    v13 += 2LL;
    v14 += v18 + v20;
    double v15 = v15 - (double)v18 * v19 - (double)v20 * v21;
  }

  while ((unint64_t)(v13 - 2) < 0xFE);
  double v22 = (double)v14;
  if (v14)
  {
    if (v14 > 0xFF) {
      double v23 = log2((double)v14);
    }
    else {
      double v23 = kBrotliLog2Table[v14];
    }
    double v15 = v15 + v22 * v23;
  }

  double v24 = v15 >= v22 ? v15 : (double)v14;
  return v24 <= v16;
}

uint64_t *InitializeH5(uint64_t *result, uint64_t a2)
{
  int v2 = *((_DWORD *)result + 7);
  int v3 = *((_DWORD *)result + 8);
  int v4 = 32 - v2;
  uint64_t v5 = 1LL << v2;
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = 1LL << v3;
  *(_DWORD *)(a2 + 16) = v4;
  *(_DWORD *)(a2 + 20) = (1LL << v3) - 1;
  uint64_t v6 = *result;
  *(void *)(a2 + 32) = result;
  *(void *)(a2 + 40) = v6;
  *(void *)(a2 + 48) = v6 + 2 * v5;
  LODWORD(v6) = *((_DWORD *)result + 10);
  *(_DWORD *)(a2 + 24) = v3;
  *(_DWORD *)(a2 + 28) = v6;
  return result;
}

uint64_t *InitializeH6(uint64_t *result, uint64_t a2)
{
  int v2 = *((_DWORD *)result + 7);
  int v3 = *((_DWORD *)result + 8);
  *(_DWORD *)(a2 + 16) = 64 - v2;
  int v4 = *((_DWORD *)result + 10);
  *(void *)(a2 + 24) = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *((_BYTE *)result + 36));
  uint64_t v5 = 1LL << v2;
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = 1LL << v3;
  *(_DWORD *)(a2 + 32) = (1LL << v3) - 1;
  *(_DWORD *)(a2 + 36) = v3;
  *(_DWORD *)(a2 + 40) = v4;
  uint64_t v6 = *result;
  *(void *)(a2 + 48) = result;
  *(void *)(a2 + 56) = v6;
  *(void *)(a2 + 64) = v6 + 2 * v5;
  return result;
}

void PrepareH4(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD **)(a1 + 8);
  if (a2 && a3 <= 0x1000)
  {
    if (a3)
    {
      for (uint64_t i = 0LL; i != a3; ++i)
      {
        int v6 = 0;
        unint64_t v7 = (0xBD1E35A7BD000000LL * *(void *)(a4 + i)) >> 47;
        do
        {
          v4[((_DWORD)v7 + v6) & 0x1FFFF] = 0;
          v6 += 8;
        }

        while (v6 != 32);
      }
    }
  }

  else
  {
    bzero(v4, 0x80000uLL);
  }

void PrepareH5(unint64_t *a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = (_WORD *)a1[5];
  unint64_t v6 = *a1;
  if (a2 && v6 >> 6 >= a3)
  {
    if (a3)
    {
      int v7 = *((_DWORD *)a1 + 4);
      do
      {
        int v8 = *a4;
        a4 = (int *)((char *)a4 + 1);
        v5[(506832829 * v8) >> v7] = 0;
        --a3;
      }

      while (a3);
    }
  }

  else
  {
    bzero(v5, 2 * v6);
  }

void PrepareH6(unint64_t *a1, int a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v5 = (_WORD *)a1[7];
  unint64_t v6 = *a1;
  if (a2 && v6 >> 6 >= a3)
  {
    if (a3)
    {
      unint64_t v7 = a1[3];
      int v8 = *((_DWORD *)a1 + 4);
      do
      {
        uint64_t v9 = *a4;
        a4 = (uint64_t *)((char *)a4 + 1);
        v5[((0x1FE35A7BD3579BD3LL * (v9 & v7)) >> v8)] = 0;
        --a3;
      }

      while (a3);
    }
  }

  else
  {
    bzero(v5, 2 * v6);
  }

void PrepareH40(uint64_t a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (a2 && a3 <= 0x200)
  {
    for (; a3; --a3)
    {
      int v6 = *a4;
      a4 = (int *)((char *)a4 + 1);
      unsigned int v7 = (506832829 * v6) >> 17;
      *(_DWORD *)(v5 + 4LL * v7) = -858993460;
      *(_WORD *)(v5 + 0x20000 + 2LL * v7) = -13108;
    }
  }

  else
  {
    memset(*(void **)(a1 + 16), 204, 0x20000uLL);
    bzero((void *)(v5 + 0x20000), 0x10000uLL);
  }

  bzero((void *)(v5 + 196608), 0x10000uLL);
  *(_WORD *)a1 = 0;
}

void PrepareH42(void **a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = a1[129];
  if (a2 && a3 <= 0x200)
  {
    for (; a3; --a3)
    {
      int v6 = *a4;
      a4 = (int *)((char *)a4 + 1);
      unsigned int v7 = (506832829 * v6) >> 17;
      v5[v7] = -858993460;
      *((_WORD *)v5 + v7 + 0x10000) = -13108;
    }
  }

  else
  {
    memset(a1[129], 204, 0x20000uLL);
    bzero(v5 + 0x8000, 0x10000uLL);
  }

  bzero(v5 + 49152, 0x10000uLL);
  bzero(a1, 0x400uLL);
}

void PrepareH54(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD **)(a1 + 8);
  if (a2 && a3 <= 0x8000)
  {
    if (a3)
    {
      for (uint64_t i = 0LL; i != a3; ++i)
      {
        int v6 = 0;
        unint64_t v7 = (unint64_t)(0x35A7BD1E35A7BD00LL * *(void *)(a4 + i)) >> 44;
        do
        {
          v4[((_DWORD)v7 + v6) & 0xFFFFF] = 0;
          v6 += 8;
        }

        while (v6 != 32);
      }
    }
  }

  else
  {
    bzero(v4, 0x400000uLL);
  }

void PrepareH35(uint64_t a1, int a2, unint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 0;
    int v8 = *(void ***)(a1 + 112);
    uint64_t v9 = (void *)(*(void *)(a1 + 104) + 0x40000LL);
    *(void *)(a1 + 56) = v9;
    unint64_t v10 = *v8;
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 44) = 0x16C4362100010DCDLL;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = 0LL;
    memset(v9, 255, 0x4000000uLL);
    if (!a2) {
      goto LABEL_10;
    }
  }

  else
  {
    unint64_t v10 = *(void **)(a1 + 8);
    if (!a2)
    {
LABEL_10:
      bzero(v10, 0x40000uLL);
      goto LABEL_11;
    }
  }

  if (a3 > 0x800) {
    goto LABEL_10;
  }
  if (!a3) {
    return;
  }
  unint64_t v11 = a4;
  unint64_t v12 = a3;
  do
  {
    uint64_t v13 = *v11;
    unint64_t v11 = (uint64_t *)((char *)v11 + 1);
    unint64_t v14 = (0xBD1E35A7BD000000LL * v13) >> 48;
    *((_DWORD *)v10 + v14) = 0;
    *((_DWORD *)v10 + (unsigned __int16)(v14 + 8)) = 0;
    --v12;
  }

  while (v12);
LABEL_11:
  if (a3 >= 0x20)
  {
    unint64_t v15 = 0LL;
    int v16 = 0;
    do
    {
      int v16 = *((unsigned __int8 *)a4 + v15) + v16 * *(_DWORD *)(a1 + 44) + 1;
      BOOL v17 = v15 >= 0x1C;
      v15 += 4LL;
    }

    while (!v17);
    *(_DWORD *)(a1 + 16) = v16;
  }

void PrepareH55(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 0;
    int v8 = *(uint64_t **)(a1 + 112);
    uint64_t v9 = (void *)(*(void *)(a1 + 104) + 0x400000LL);
    *(void *)(a1 + 56) = v9;
    uint64_t v10 = *v8;
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 44) = 0x16C4362100010DCDLL;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = 0LL;
    memset(v9, 255, 0x4000000uLL);
  }

  PrepareH54(a1, a2, a3, a4);
  if (a3 >= 0x20)
  {
    unint64_t v11 = 0LL;
    int v12 = 0;
    do
    {
      int v12 = *(unsigned __int8 *)(a4 + v11) + v12 * *(_DWORD *)(a1 + 44) + 1;
      BOOL v13 = v11 >= 0x1C;
      v11 += 4LL;
    }

    while (!v13);
    *(_DWORD *)(a1 + 16) = v12;
  }

void PrepareH65(uint64_t a1, int a2, unint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a1 + 176))
  {
    int v8 = *(uint64_t **)(a1 + 168);
    uint64_t v9 = (void *)(*(void *)(a1 + 160)
                + (2LL << *(_DWORD *)(*(void *)(a1 + 184) + 44LL))
                + (4LL << *(_DWORD *)(*(void *)(a1 + 184) + 44LL) << *(_DWORD *)(*(void *)(a1 + 184) + 48LL)));
    int v10 = *((_DWORD *)v8 + 7);
    int v11 = *((_DWORD *)v8 + 8);
    *(_DWORD *)(a1 + 16) = 64 - v10;
    int v12 = *((_DWORD *)v8 + 10);
    unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *((_BYTE *)v8 + 36));
    *(_DWORD *)(a1 + 176) = 0;
    *(void *)(a1 + 112) = v9;
    *(void *)(a1 + 24) = v13;
    uint64_t v14 = 1LL << v10;
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = 1LL << v11;
    *(_DWORD *)(a1 + 32) = (1LL << v11) - 1;
    *(_DWORD *)(a1 + 36) = v11;
    *(_DWORD *)(a1 + 40) = v12;
    uint64_t v15 = *v8;
    *(void *)(a1 + 48) = v8;
    *(void *)(a1 + 56) = v15;
    *(void *)(a1 + 64) = v15 + 2 * v14;
    *(_DWORD *)(a1 + 72) = 0;
    *(void *)(a1 + 100) = 0xF1EBF08100010DCDLL;
    *(void *)(a1 + 80) = v9;
    *(void *)(a1 + 88) = 0LL;
    memset(v9, 255, 0x4000000uLL);
  }

  PrepareH6((unint64_t *)a1, a2, a3, a4);
  if (a3 >= 0x20)
  {
    uint64_t v16 = 0LL;
    int v17 = 0;
    do
      int v17 = *((unsigned __int8 *)a4 + v16++) + v17 * *(_DWORD *)(a1 + 100) + 1;
    while (v16 != 32);
    *(_DWORD *)(a1 + 72) = v17;
  }

uint64_t GetBrotliStorage(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 2440) >= a2) {
    return *(void *)(a1 + 2448);
  }
  BrotliFree(a1 + 144, *(void *)(a1 + 2448));
  *(void *)(a1 + 2448) = 0LL;
  uint64_t v4 = BrotliAllocate(a1 + 144);
  uint64_t result = 0LL;
  *(void *)(a1 + 2448) = v4;
  if (!*(_DWORD *)(a1 + 168))
  {
    *(void *)(a1 + 2440) = a2;
    return v4;
  }

  return result;
}

void *GetHashTable(uint64_t a1, int a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v6 = 0x20000LL;
  if (!a2) {
    unint64_t v6 = 0x8000LL;
  }
  if (v6 >= a3) {
    unint64_t v7 = a3;
  }
  else {
    unint64_t v7 = v6;
  }
  uint64_t v8 = 256LL;
  do
  {
    unint64_t v9 = v8;
    v8 *= 2LL;
  }

  while (v9 < v7);
  if ((v9 & 0xAAA00) == 0 && a2 == 0) {
    unint64_t v11 = v8;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11 <= 0x400)
  {
    int v12 = (void *)(a1 + 3552);
LABEL_20:
    *a4 = v11;
    bzero(v12, 4 * v11);
    return v12;
  }

  if (v11 <= *(void *)(a1 + 7656))
  {
    int v12 = *(void **)(a1 + 7648);
    goto LABEL_20;
  }

  *(void *)(a1 + 7656) = v11;
  BrotliFree(a1 + 144, *(void *)(a1 + 7648));
  *(void *)(a1 + 7648) = 0LL;
  uint64_t v13 = BrotliAllocate(a1 + 144);
  int v12 = 0LL;
  *(void *)(a1 + 7648) = v13;
  if (!*(_DWORD *)(a1 + 168))
  {
    int v12 = (void *)v13;
    goto LABEL_20;
  }

  return v12;
}

BOOL UpdateLastProcessedPos(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 2344);
  if (v1 >> 30 >= 3) {
    LODWORD(v1) = (((2 * (int)v1) >> 1) & 0xC0000000 | v1 & 0x3FFFFFFF) ^ 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 2248);
  unsigned int v3 = (((2 * (int)v2) >> 1) & 0xC0000000 | v2 & 0x3FFFFFFF) ^ 0x80000000;
  if (v2 <= 0xBFFFFFFF) {
    unsigned int v3 = *(void *)(a1 + 2248);
  }
  *(void *)(a1 + 2344) = v2;
  return v3 < v1;
}

uint64_t ExtendLastCommand(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(result + 2304);
  uint64_t v4 = *(void *)(result + 2312) - 1LL;
  uint64_t v5 = (unsigned int *)(v3 + 16 * v4);
  unint64_t v6 = v5 + 1;
  unsigned int v7 = v5[1];
  uint64_t v8 = v7 & 0x1FFFFFF;
  else {
    unint64_t v9 = *(void *)(result + 2344) - v8;
  }
  unint64_t v10 = *(int *)(result + 2352);
  unsigned int v11 = *((unsigned __int16 *)v5 + 7);
  unsigned int v12 = v11 & 0x3FF;
  int v13 = *(_DWORD *)(result + 68);
  if (v12 >= v13 + 16) {
    unsigned int v12 = v13
  }
        + 16
        + ((v12 - v13 - 16) & ~(-1 << *(_DWORD *)(result + 64)))
        + ((v5[2] + ((((v12 - v13 - 16) >> *(_DWORD *)(result + 64)) & 1 | 2) << (v11 >> 10)) - 4) << *(_DWORD *)(result + 64));
  if (v12 < 0x10 || v12 - 15 == v10)
  {
    if (v9 >= v10 && *a2)
    {
      uint64_t v15 = *(void *)(result + 2288);
      uint64_t v16 = *(unsigned int *)(result + 2260);
      uint64_t v17 = *a3;
      while (1)
      {
        int v18 = *(unsigned __int8 *)(v15 + (v17 & v16));
        uint64_t result = *(unsigned __int8 *)(v15 + (((_DWORD)v17 - (_DWORD)v10) & v16));
        unsigned int v7 = *v6;
        if (v18 != (_DWORD)result) {
          break;
        }
        *unint64_t v6 = v7 + 1;
        --*a2;
        uint64_t v17 = (*a3 + 1);
        *a3 = v17;
        if (!*a2)
        {
          unsigned int v7 = *v6;
          break;
        }
      }

      LODWORD(v8) = v7 & 0x1FFFFFF;
    }

    unint64_t v19 = *v5;
    uint64_t v20 = v8 + (v7 >> 25);
    int v21 = v11 & 0x3FF;
    if (v19 > 5)
    {
      if (v19 > 0x81)
      {
        if (v19 > 0x841)
        {
          if (v19 >> 1 >= 0xC21)
          {
            else {
              LOWORD(v19) = 23;
            }
          }

          else
          {
            LOWORD(v19) = 21;
          }
        }

        else
        {
          LODWORD(v19) = (__clz(v19 - 66) ^ 0x1F) + 10;
        }
      }

      else
      {
        v19 -= 2LL;
        unsigned int v22 = (__clz(v19) ^ 0x1F) - 1;
        LODWORD(v19) = (v19 >> v22) + 2 * v22 + 2;
      }
    }

    uint64_t v23 = v3 + 16 * v4;
    if (v20 > 9)
    {
      unsigned int v25 = (__clz(v20 - 70) ^ 0x1F) + 12;
      else {
        __int16 v26 = 23;
      }
      unsigned int v27 = (__clz(v20 - 6) ^ 0x1F) - 1;
      else {
        unsigned __int16 v24 = v26;
      }
    }

    else
    {
      unsigned __int16 v24 = v8 + (v7 >> 25) - 2;
    }

    int v28 = (_WORD *)(v23 + 12);
    unsigned int v29 = v24 & 7 | (8 * (v19 & 7));
    if (v21 || (unsigned __int16)v19 > 7u || v24 > 0xFu)
    {
      int v30 = 3 * ((unsigned __int16)v19 >> 3) + ((unsigned __int16)(v24 & 0xFFF8) >> 3);
      unsigned int v29 = ((((0x520D40u >> (2 * v30)) & 0xC0) + (v30 << 6)) | v29) + 64;
    }

    else if ((v24 & 0xFFF8) != 0)
    {
      LOWORD(v29) = v29 | 0x40;
    }

    *int v28 = v29;
  }

  return result;
}

void WriteMetaBlockInternal( uint64_t a1, uint64_t a2, size_t a3, unint64_t a4, size_t a5, unsigned int a6, unsigned int a7, uint64_t a8, unsigned __int8 a9, unsigned __int8 a10, unint64_t a11, unint64_t a12, unsigned int *a13, _OWORD *a14, _OWORD *a15, uint64_t *a16, char *a17)
{
  if (a4 >> 30 < 3) {
    unsigned int v38 = a4;
  }
  else {
    unsigned int v38 = (((2 * (int)a4) >> 1) & 0xC0000000 | a4 & 0x3FFFFFFF) ^ 0x80000000;
  }
  __int128 v22 = *(_OWORD *)(a8 + 112);
  __int128 v52 = *(_OWORD *)(a8 + 96);
  __int128 v53 = v22;
  __int128 v54 = *(_OWORD *)(a8 + 128);
  __int128 v23 = *(_OWORD *)(a8 + 48);
  v49[2] = *(_OWORD *)(a8 + 32);
  v49[3] = v23;
  __int128 v24 = *(_OWORD *)(a8 + 80);
  __int128 v50 = *(_OWORD *)(a8 + 64);
  __int128 v51 = v24;
  __int128 v25 = *(_OWORD *)(a8 + 16);
  v49[0] = *(_OWORD *)a8;
  v49[1] = v25;
  if (!a5)
  {
    uint64_t v27 = *a16;
    *(void *)&a17[(unint64_t)*a16 >> 3] = (3LL << (*a16 & 7)) | a17[(unint64_t)*a16 >> 3];
    *a16 = ((_DWORD)v27 + 9) & 0xFFFFFFF8;
    return;
  }

  if (!ShouldCompress(a2, a3, a4, a5, a11, a12))
  {
    *a15 = *a14;
    BrotliStoreUncompressedMetaBlock(a6, a2, v38, a3, a5, a16, (uint64_t)a17);
    return;
  }

  int v26 = *(_DWORD *)(a8 + 4);
  char v35 = a17[1];
  uint64_t v34 = *(unsigned __int8 *)a16;
  char v33 = *a17;
  if (v26 <= 2)
  {
    BrotliStoreMetaBlockFast(a1, a2, v38, a5, a3, a6, a8, (uint64_t)a13, a12, (unint64_t *)a16, (uint64_t)a17);
    goto LABEL_12;
  }

  if (v26 == 3)
  {
    BrotliStoreMetaBlockTrivial(a1, a2, v38, a5, a3, a6, a8, (uint64_t)a13, a12, (unint64_t *)a16, (uint64_t)a17);
LABEL_12:
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    goto LABEL_13;
  }

  BrotliInitBlockSplit(v41);
  BrotliInitBlockSplit(v42);
  BrotliInitBlockSplit(v43);
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v44 = 0u;
  int v28 = *(_DWORD *)(a8 + 4);
  if (v28 > 9)
  {
    BrotliBuildMetaBlock(a1, a2, v38, a3, v49, a9, a10, (uint64_t)a13, a12, a7, v41);
  }

  else
  {
    uint64_t v29 = 0LL;
    int v30 = &_kBrotliContextLookupTable[512 * a7];
    unint64_t v31 = 1LL;
    uint64_t v39 = 0LL;
    unint64_t v40 = 1LL;
    uint64_t v32 = v38;
    if (!*(_DWORD *)(a8 + 32))
    {
      DecideOverLiteralContextModeling(a2, v38, a5, a3, v28, *(void *)(a8 + 24), (uint64_t *)&v40, &v39);
      uint64_t v32 = v38;
      int v30 = &_kBrotliContextLookupTable[512 * a7];
      uint64_t v29 = v39;
      unint64_t v31 = v40;
    }

    BrotliBuildMetaBlockGreedy(a1, a2, v32, a3, a9, a10, (uint64_t)v30, v31, v29, a13, a12, (uint64_t)v41);
  }

  if (!*(_DWORD *)(a1 + 24))
  {
    BrotliStoreMetaBlock( a1,  a2,  v38,  a5,  a3,  a9,  a10,  a6,  (unsigned int *)v49,  a7,  (uint64_t)a13,  a12,  (uint64_t)v41,  (unint64_t *)a16,  (uint64_t)a17);
    if (!*(_DWORD *)(a1 + 24))
    {
      BrotliDestroyBlockSplit(a1, (uint64_t)v41);
      BrotliDestroyBlockSplit(a1, (uint64_t)v42);
      BrotliDestroyBlockSplit(a1, (uint64_t)v43);
      BrotliFree(a1, v44);
      *(void *)&__int128 v44 = 0LL;
      BrotliFree(a1, v45);
      *(void *)&__int128 v45 = 0LL;
      BrotliFree(a1, v46);
      *(void *)&__int128 v46 = 0LL;
      BrotliFree(a1, v47);
      *(void *)&__int128 v47 = 0LL;
      BrotliFree(a1, v48);
LABEL_13:
      if (a5 + 4 < (unint64_t)*a16 >> 3)
      {
        *a15 = *a14;
        *a17 = v33;
        a17[1] = v35;
        *a16 = v34;
        BrotliStoreUncompressedMetaBlock(a6, a2, v38, a3, a5, a16, (uint64_t)a17);
      }
    }
  }

void DecideOverLiteralContextModeling( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, unint64_t a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v121 = *MEMORY[0x1895F89C0];
  if (a3 >= 0x40 && a5 >= 5)
  {
    uint64_t v9 = a2;
    unint64_t v11 = a3 + a2;
    if (a6 >> 20)
    {
      __int128 v118 = 0u;
      __int128 v117 = 0u;
      __int128 v116 = 0u;
      __int128 v115 = 0u;
      __int128 v114 = 0u;
      __int128 v113 = 0u;
      __int128 v112 = 0u;
      __int128 v111 = 0u;
      bzero(v109, 0x680uLL);
      unint64_t v13 = v9 + 64;
      if (v9 + 64 <= v11)
      {
        unsigned int v108 = 0;
        uint64_t v14 = v9;
        do
        {
          if (v14 + 2 < v13)
          {
            unint64_t v15 = *(unsigned __int8 *)(a1 + ((v14 + 1) & a4));
            unint64_t v16 = *(unsigned __int8 *)(a1 + (v14 & a4));
            for (uint64_t i = 2LL; i != 64; ++i)
            {
              unint64_t v18 = v15;
              unint64_t v15 = *(unsigned __int8 *)(a1 + ((v14 + i) & a4));
              uint64_t v19 = ShouldUseComplexStaticContextMap_kStaticContextMapComplexUTF8[4
                                                                                * (*((_BYTE *)&_kBrotliContextLookupTable + v16 + 1280) | *((_BYTE *)&_kBrotliContextLookupTable + v18 + 1024))];
              uint64_t v20 = (v15 >> 1) & 0x7C;
              ++*(_DWORD *)((char *)&v111 + v20);
              int v21 = &v109[8 * v19];
              unint64_t v16 = v18;
              ++*(_DWORD *)((char *)v21 + v20);
            }

            v108 += 62;
          }

          v14 += 4096LL;
          v13 += 4096LL;
        }

        while (v13 <= v11);
      }

      else
      {
        unsigned int v108 = 0;
      }

      unint64_t v104 = v11;
      uint64_t v22 = 0LL;
      unint64_t v23 = 0LL;
      double v24 = 0.0;
      do
      {
        __int128 v25 = (unsigned int *)&v111 + v22;
        uint64_t v26 = *v25;
        else {
          double v27 = kBrotliLog2Table[v26];
        }
        uint64_t v28 = v25[1];
        else {
          double v29 = kBrotliLog2Table[v28];
        }
        v22 += 2LL;
        v23 += v26 + v28;
        double v24 = v24 - (double)v26 * v27 - (double)v28 * v29;
      }

      while ((unint64_t)(v22 - 2) < 0x1E);
      if (v23)
      {
        if (v23 > 0xFF) {
          double v30 = log2((double)v23);
        }
        else {
          double v30 = kBrotliLog2Table[v23];
        }
        double v24 = v24 + (double)v23 * v30;
      }

      uint64_t v31 = 0LL;
      double v32 = 0.0;
      char v33 = v109;
      do
      {
        uint64_t v34 = 0LL;
        unint64_t v35 = 0LL;
        double v36 = 0.0;
        do
        {
          unint64_t v37 = (unsigned int *)v33 + v34;
          uint64_t v38 = *v37;
          else {
            double v39 = kBrotliLog2Table[v38];
          }
          uint64_t v40 = v37[1];
          else {
            double v41 = kBrotliLog2Table[v40];
          }
          v34 += 2LL;
          v35 += v38 + v40;
          double v36 = v36 - (double)v38 * v39 - (double)v40 * v41;
        }

        while ((unint64_t)(v34 - 2) < 0x1E);
        if (v35)
        {
          if (v35 > 0xFF) {
            double v42 = log2((double)v35);
          }
          else {
            double v42 = kBrotliLog2Table[v35];
          }
          double v36 = v36 + (double)v35 * v42;
        }

        double v32 = v32 + v36;
        ++v31;
        v33 += 8;
      }

      while (v31 != 13);
      double v43 = 1.0 / (double)v108;
      if (v43 * v32 <= 3.0 && v43 * v24 - v43 * v32 >= 0.2)
      {
        *a7 = 13LL;
        uint64_t v102 = (uint64_t)ShouldUseComplexStaticContextMap_kStaticContextMapComplexUTF8;
        goto LABEL_121;
      }

      unint64_t v12 = v9 + 64;
      unint64_t v11 = v104;
    }

    else
    {
      unint64_t v12 = a2 + 64;
    }

    int v110 = 0;
    memset(v109, 0, sizeof(v109));
    if (v12 <= v11)
    {
      uint64_t v44 = v12 - v9;
      do
      {
        if (v9 + 1 < v12)
        {
          int v45 = *(_DWORD *)((char *)&DecideOverLiteralContextModeling_lut
                          + (((unint64_t)*(unsigned __int8 *)(a1 + (v9 & a4)) >> 4) & 0xC));
          uint64_t v46 = 1LL;
          do
          {
            int v47 = 3 * v45;
            int v45 = *(_DWORD *)((char *)&DecideOverLiteralContextModeling_lut
                            + (((unint64_t)*(unsigned __int8 *)(a1 + ((v9 + v46) & a4)) >> 4) & 0xC));
            ++*((_DWORD *)v109 + v45 + v47);
            ++v46;
          }

          while (v44 != v46);
        }

        v9 += 4096LL;
        v12 += 4096LL;
      }

      while (v12 <= v11);
    }

    unint64_t v48 = 0LL;
    int v120 = 0;
    uint64_t v119 = 0LL;
    __int128 v111 = 0uLL;
    *(void *)&__int128 v112 = 0LL;
    do
    {
      int v49 = *((_DWORD *)v109 + v48);
      *((_DWORD *)&v119 + v48 % 3u) += v49;
      unint64_t v50 = v48 - 6;
      if (v48 < 6) {
        unint64_t v50 = v48;
      }
      *((_DWORD *)&v111 + v50) += v49;
      ++v48;
    }

    while (v48 != 9);
    uint64_t v51 = 0LL;
    uint64_t v52 = 0LL;
    char v53 = 1;
    double v54 = 0.0;
    while (1)
    {
      uint64_t v55 = *((unsigned int *)&v119 + v52);
      double v56 = v55 > 0xFF ? log2((double)v55) : kBrotliLog2Table[v55];
      unint64_t v57 = v51 + v55;
      double v58 = v54 - (double)v55 * v56;
      if ((v53 & 1) == 0) {
        break;
      }
      uint64_t v59 = *((unsigned int *)&v119 + (v52 | 1));
      else {
        double v60 = kBrotliLog2Table[v59];
      }
      char v53 = 0;
      uint64_t v51 = v57 + v59;
      double v54 = v58 - (double)v59 * v60;
      uint64_t v52 = 2LL;
    }

    if (v57)
    {
      if (v57 > 0xFF) {
        double v61 = log2((double)v57);
      }
      else {
        double v61 = kBrotliLog2Table[v57];
      }
      double v58 = v58 + (double)v57 * v61;
    }

    uint64_t v62 = 0LL;
    uint64_t v63 = 0LL;
    char v64 = 1;
    double v65 = 0.0;
    while (1)
    {
      uint64_t v66 = *((unsigned int *)&v111 + v63);
      double v67 = v66 > 0xFF ? log2((double)v66) : kBrotliLog2Table[v66];
      unint64_t v68 = v62 + v66;
      double v69 = v65 - (double)v66 * v67;
      if ((v64 & 1) == 0) {
        break;
      }
      uint64_t v70 = *((unsigned int *)&v111 + (v63 | 1));
      else {
        double v71 = kBrotliLog2Table[v70];
      }
      char v64 = 0;
      uint64_t v62 = v68 + v70;
      double v65 = v69 - (double)v70 * v71;
      uint64_t v63 = 2LL;
    }

    if (v68)
    {
      if (v68 > 0xFF) {
        double v72 = log2((double)v68);
      }
      else {
        double v72 = kBrotliLog2Table[v68];
      }
      double v69 = v69 + (double)v68 * v72;
    }

    uint64_t v73 = 0LL;
    uint64_t v74 = 0LL;
    double v75 = 0.0;
    while (1)
    {
      uint64_t v76 = (char *)&v111 + 4 * v73;
      uint64_t v77 = *((unsigned int *)v76 + 3);
      double v78 = v77 > 0xFF ? log2((double)v77) : kBrotliLog2Table[v77];
      unint64_t v79 = v74 + v77;
      double v80 = v75 - (double)v77 * v78;
      uint64_t v81 = *((unsigned int *)v76 + 4);
      else {
        double v82 = kBrotliLog2Table[v81];
      }
      uint64_t v74 = v79 + v81;
      double v75 = v80 - (double)v81 * v82;
      v73 += 2LL;
    }

    if (v79)
    {
      if (v79 > 0xFF) {
        double v83 = log2((double)v79);
      }
      else {
        double v83 = kBrotliLog2Table[v79];
      }
      double v80 = v80 + (double)v79 * v83;
    }

    uint64_t v84 = 0LL;
    double v85 = 0.0;
    do
    {
      uint64_t v86 = 0LL;
      uint64_t v87 = 0LL;
      uint64_t v88 = (char *)v109 + 12 * v84;
      char v89 = 1;
      double v90 = 0.0;
      while (1)
      {
        uint64_t v91 = *(unsigned int *)&v88[4 * v87];
        double v92 = v91 > 0xFF ? log2((double)v91) : kBrotliLog2Table[v91];
        unint64_t v93 = v86 + v91;
        double v94 = v90 - (double)v91 * v92;
        if ((v89 & 1) == 0) {
          break;
        }
        uint64_t v95 = *(unsigned int *)&v88[4 * (v87 | 1)];
        else {
          double v96 = kBrotliLog2Table[v95];
        }
        char v89 = 0;
        uint64_t v86 = v93 + v95;
        double v90 = v94 - (double)v95 * v96;
        uint64_t v87 = 2LL;
      }

      if (v93)
      {
        if (v93 > 0xFF) {
          double v97 = log2((double)v93);
        }
        else {
          double v97 = kBrotliLog2Table[v93];
        }
        double v94 = v94 + (double)v93 * v97;
      }

      double v85 = v85 + v94;
      ++v84;
    }

    while (v84 != 3);
    double v98 = 1.0 / (double)(HIDWORD(v119) + v119 + v120);
    double v99 = v58 * v98;
    double v100 = (v69 + v80) * v98;
    double v101 = v85 * v98;
    if (a5 < 7) {
      double v101 = v99 * 10.0;
    }
    if (v99 - v100 < 0.2 && v99 - v101 < 0.2)
    {
      uint64_t v102 = 1LL;
      uint64_t v103 = a7;
LABEL_122:
      *uint64_t v103 = v102;
      return;
    }

    if (v100 - v101 >= 0.02)
    {
      *a7 = 3LL;
      uint64_t v102 = (uint64_t)&ChooseContextMap_kStaticContextMapContinuation;
    }

    else
    {
      *a7 = 2LL;
      uint64_t v102 = (uint64_t)&ChooseContextMap_kStaticContextMapSimpleUTF8;
    }

LABEL_121:
    uint64_t v103 = a8;
    goto LABEL_122;
  }

uint64_t lzx_huffman_tree_compute_lookup_from_code_len(unsigned __int8 *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *((void *)a1 + 16446);
  bzero(v27, 0x3E0uLL);
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  int v3 = 0;
  uint64_t v4 = v2;
  uint64_t v5 = a1;
  do
  {
    unsigned int v7 = *v5++;
    unsigned int v6 = v7;
    ++*((_DWORD *)v25 + v7);
    --v4;
  }

  while (v4);
  if (!v3)
  {
LABEL_21:
    memset_pattern16(a1 + 496, &unk_181076E40, 0x20000uLL);
    return 0LL;
  }

  int v8 = 0;
  int v24 = 0;
  memset(v23, 0, sizeof(v23));
  for (uint64_t i = 4LL; i != 68; i += 4LL)
  {
    *(_DWORD *)((char *)v23 + i) = 2 * v8;
    int v8 = *(_DWORD *)((char *)v25 + i) + 2 * v8;
  }

  if (v8 == 0x10000)
  {
    unint64_t v10 = v27;
    uint64_t v11 = v2;
    unint64_t v12 = a1;
    do
    {
      unsigned int v14 = *v12++;
      unsigned int v13 = v14;
      if (v14)
      {
        unsigned int v15 = *((_DWORD *)v23 + v13);
        *((_DWORD *)v23 + v13) = v15 + 1;
        if (v15 >> v13) {
          return 0xFFFFFFFFLL;
        }
        *unint64_t v10 = v15 << (16 - v13);
      }

      ++v10;
      --v11;
    }

    while (v11);
    bzero(a1 + 496, 0x20000uLL);
    uint64_t v16 = 0LL;
    do
    {
      __int16 v17 = a1[v16];
      if (a1[v16])
      {
        __int16 v18 = v17 | (32 * v16);
        char v19 = 16 - v17;
        unint64_t v20 = (unsigned __int16)v27[v16];
        unint64_t v21 = ((1 << v19) + v20);
        do
          *(_WORD *)&a1[2 * v20++ + 496] = v18;
        while (v20 < v21);
      }

      ++v16;
    }

    while (v16 != v2);
    return 0LL;
  }

  return 0xFFFFFFFFLL;
}

uint64_t lzx_huffman_tree_read_code(_WORD *a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a2 + 24);
  if (v3 <= 48)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    unint64_t v5 = *(void *)a2 + 2LL;
    int v6 = 48 - v3;
    while (v5 <= v4)
    {
      uint64_t v7 = *(unsigned __int16 *)(v5 - 2);
      *(void *)a2 = v5;
      int v8 = v3 + 16;
      uint64_t v9 = (v7 << v6) | *(void *)(a2 + 16);
      *(_DWORD *)(a2 + 24) = v3 + 16;
      *(void *)(a2 + 16) = v9;
      v5 += 2LL;
      v6 -= 16;
      BOOL v10 = v3 < 33;
      v3 += 16;
      if (!v10) {
        goto LABEL_7;
      }
    }
  }

  int v8 = v3;
LABEL_7:
  unint64_t v11 = *(void *)(a2 + 16);
  unint64_t v12 = *(unsigned __int16 *)(a3 + 2 * HIWORD(v11) + 496);
  *a1 = *(_WORD *)(a3 + 2 * HIWORD(v11) + 496) >> 5;
  if (*(void *)(a3 + 131568) <= v12 >> 5) {
    return 0xFFFFFFFFLL;
  }
  int v13 = v12 & 0x1F;
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  if (v8 <= 48)
  {
    unint64_t v14 = *(void *)(a2 + 8);
    unint64_t v15 = *(void *)a2 + 2LL;
    int v16 = 48 - v8;
    while (v15 <= v14)
    {
      uint64_t v17 = *(unsigned __int16 *)(v15 - 2);
      *(void *)a2 = v15;
      int v18 = v8 + 16;
      v11 |= v17 << v16;
      *(_DWORD *)(a2 + 24) = v8 + 16;
      *(void *)(a2 + 16) = v11;
      v15 += 2LL;
      v16 -= 16;
      BOOL v10 = v8 < 33;
      v8 += 16;
      if (!v10) {
        goto LABEL_15;
      }
    }
  }

  int v18 = v8;
LABEL_15:
  if (v18 < v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a2 + 16) = v11 << v13;
  *(_DWORD *)(a2 + 24) = v18 - v13;
  return result;
}

uint64_t lzx_huffman_tree_update_tree_using_pre_tree_encoding( uint64_t a1, uint64_t a2, size_t a3, uint64_t a4, void *a5)
{
  size_t v11 = a4 + a3;
  while (a3 < v11)
  {
    if (v43 > 0x10u)
    {
      switch(v43)
      {
        case 0x13u:
          int v21 = *(_DWORD *)(a2 + 24);
          if (v21 > 48)
          {
            int v26 = *(_DWORD *)(a2 + 24);
          }

          else
          {
            unint64_t v22 = *(void *)(a2 + 8);
            unint64_t v23 = *(void *)a2 + 2LL;
            int v24 = 48 - v21;
            while (v23 <= v22)
            {
              uint64_t v25 = *(unsigned __int16 *)(v23 - 2);
              *(void *)a2 = v23;
              int v26 = v21 + 16;
              uint64_t v27 = (v25 << v24) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v21 + 16;
              *(void *)(a2 + 16) = v27;
              v23 += 2LL;
              v24 -= 16;
              BOOL v20 = v21 < 33;
              v21 += 16;
              if (!v20) {
                goto LABEL_33;
              }
            }

            int v26 = v21;
            if (v21 < 1) {
              return 0xFFFFFFFFLL;
            }
          }

LABEL_33:
          unint64_t v37 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 2 * v37;
          *(_DWORD *)(a2 + 24) = v26 - 1;
          size_t v38 = (v37 >> 63) | 4;
          unsigned int v39 = *(unsigned __int8 *)(a1 + a3);
          memset((void *)(a1 + a3), v39 - v42, v38);
          a3 += v38;
          break;
        case 0x12u:
          int v28 = *(_DWORD *)(a2 + 24);
          if (v28 > 48)
          {
            int v33 = *(_DWORD *)(a2 + 24);
          }

          else
          {
            unint64_t v29 = *(void *)(a2 + 8);
            unint64_t v30 = *(void *)a2 + 2LL;
            int v31 = 48 - v28;
            while (v30 <= v29)
            {
              uint64_t v32 = *(unsigned __int16 *)(v30 - 2);
              *(void *)a2 = v30;
              int v33 = v28 + 16;
              uint64_t v34 = (v32 << v31) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v28 + 16;
              *(void *)(a2 + 16) = v34;
              v30 += 2LL;
              v31 -= 16;
              BOOL v20 = v28 < 33;
              v28 += 16;
              if (!v20) {
                goto LABEL_40;
              }
            }

            int v33 = v28;
            if (v28 < 5) {
              return 0xFFFFFFFFLL;
            }
          }

LABEL_40:
          unint64_t v40 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 32 * v40;
          *(_DWORD *)(a2 + 24) = v33 - 5;
          size_t v36 = (v40 >> 59) + 20;
          goto LABEL_41;
        case 0x11u:
          int v13 = *(_DWORD *)(a2 + 24);
          if (v13 > 48)
          {
            int v18 = *(_DWORD *)(a2 + 24);
          }

          else
          {
            unint64_t v14 = *(void *)(a2 + 8);
            unint64_t v15 = *(void *)a2 + 2LL;
            int v16 = 48 - v13;
            while (v15 <= v14)
            {
              uint64_t v17 = *(unsigned __int16 *)(v15 - 2);
              *(void *)a2 = v15;
              int v18 = v13 + 16;
              uint64_t v19 = (v17 << v16) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v13 + 16;
              *(void *)(a2 + 16) = v19;
              v15 += 2LL;
              v16 -= 16;
              BOOL v20 = v13 < 33;
              v13 += 16;
              if (!v20) {
                goto LABEL_31;
              }
            }

            int v18 = v13;
            if (v13 < 4) {
              return 0xFFFFFFFFLL;
            }
          }

                    if (v32 > v27)
                    {
                      *(_WORD *)unint64_t v23 = v32;
                      *((_WORD *)v23 + 1) = v26;
                      if ((_DWORD)v32 == 31)
                      {
                        uint64_t v27 = 31;
                        break;
                      }

                      uint64_t v27 = (unsigned __int16)v32;
                    }

                    uint64_t v25 = *(_DWORD *)&v97[4 * (v25 & 0x3FFF)];
                    int v26 = v21 - v25;
                  }
                }

                if (v21 >= 0x1F)
                {
                  unint64_t v35 = (-1640531535 * *(_DWORD *)&a3[(v21 - 31)]) >> 18;
                  *(_DWORD *)&v97[4 * (((_DWORD)v21 - 31) & 0x3FFF)] = *((_DWORD *)v10 + v35);
                  *((_DWORD *)v10 + v35) = v21 - 31;
                }
              }

              ++v21;
              --v22;
            }

            while (v21 != v20);
          }

          size_t v36 = 0;
          unint64_t v37 = 128LL;
          size_t v38 = v95;
LABEL_54:
          unsigned int v39 = v38;
          while (v36 < v37)
          {
            uint64_t result = (unint64_t)memset(v13, 255, (16 * v17 + 496));
            unint64_t v40 = 0;
            size_t v41 = 0LL;
            *(void *)int v13 = 0x8000000000000000LL;
            v13[4] = 7936;
            while (1)
            {
              unsigned __int16 v42 = &v13[8 * v41];
              unsigned __int16 v43 = *((_DWORD *)v42 + 1);
              if (v40 > v43)
              {
                *(_DWORD *)unsigned __int16 v42 = v43;
                *((_BYTE *)v42 + 8) = *((_BYTE *)v42 + 9);
                *((_BYTE *)v42 + 10) = 0;
                v42[6] = 0;
                unint64_t v40 = v43;
              }

              if (v41 == v17) {
                break;
              }
              uint64_t v44 = &v13[8 * v41];
              int v47 = *((unsigned __int8 *)v44 + 9);
              int v45 = (char *)v44 + 9;
              uint64_t v46 = v47;
              if (v47 != 31)
              {
                unint64_t v48 = v43 + 4;
                if (*((_DWORD *)v42 + 5) > v48)
                {
                  *((_DWORD *)v42 + 5) = v48;
                  *((_BYTE *)v42 + 25) = v46 + 1;
                }
              }

              int v49 = v39 + 136 + v40;
              unint64_t v50 = 31;
              do
              {
                uint64_t v51 = &v42[8 * v50];
                char v53 = *((_DWORD *)v51 + 1);
                uint64_t v52 = (unsigned int *)(v51 + 2);
                uint64_t result = v53;
                if (v53 <= v49) {
                  break;
                }
                *uint64_t v52 = v49;
                HIBYTE(v42[8 * v50 + 4]) = v50;
                v49 -= 4;
                --v50;
              }

              while (v50);
              double v54 = *((_DWORD *)v42 + 1) + v39;
              uint64_t v55 = *(unsigned __int16 *)&v14[4 * v41];
              double v56 = &v42[8 * v55];
              unint64_t v57 = *(_DWORD *)v56;
              if (*(_DWORD *)v56 > v54)
              {
                *(_DWORD *)double v56 = v54;
                *((_BYTE *)v56 + 8) = *v45;
                *((_BYTE *)v56 + 10) = v55;
                v56[6] = *(_WORD *)&v14[4 * v41 + 2];
                unint64_t v40 = *(_DWORD *)v42;
                unint64_t v57 = v54;
              }

              double v58 = v39 + 12 + v40;
              if (v57 > v58)
              {
                *(_DWORD *)double v56 = v58;
                uint64_t v59 = &v42[8 * v55];
                *((_BYTE *)v59 + 8) = 0;
                *((_BYTE *)v59 + 10) = v55;
                v59[6] = *(_WORD *)&v14[4 * v41 + 2];
              }

              ++v41;
              unint64_t v40 = *(_DWORD *)&v13[8 * v41];
            }

            double v60 = 0;
            double v61 = 0;
            uint64_t v62 = v17;
            do
            {
              if (v62 > 0x1000) {
                goto LABEL_93;
              }
              uint64_t v63 = &v13[8 * v62];
              char v64 = *((unsigned __int8 *)v63 + 8);
              v61 += v64 + 3;
              v60 += a6;
              v62 -= v64 + *((unsigned __int8 *)v63 + 10);
            }

            while (v62);
            if (v60 <= v90 + (int)v17)
            {
              uint64_t result = (unint64_t)memcpy(__dst, v13, (16 * v17 + 16));
              *(_DWORD *)double v98 = v61;
              goto LABEL_79;
            }

            size_t v36 = v39 + 1;
            if ((_DWORD)v39 == *((_DWORD *)v98 + 1))
            {
              unsigned int v39 = (2 * (_DWORD)v39) | 1u;
            }

            unsigned int v39 = v37;
LABEL_79:
            size_t v38 = (v39 + v36) >> 1;
            unint64_t v37 = v39;
            goto LABEL_54;
          }

          *((_DWORD *)v98 + 1) = v36;
          *((_DWORD *)v98 + 2) = v36 ^ 0xE11CCA;
          if (v36 == 128) {
            break;
          }
          double v65 = *(unsigned int *)v98;
          uint64_t v66 = v89 - v9;
          BOOL v10 = __b;
          if (v65 >= (int)v17 + 2)
          {
            *(_WORD *)uint64_t v9 = 0;
            uint64_t v86 = v9 + 2;
            double v85 = __src;
            uint64_t result = (unint64_t)memcpy(v86, __src, v17);
            unsigned int v12 = v98;
            uint64_t v9 = &v86[v17];
          }

          else
          {
            if (v66 < v65 + 1) {
              return 0LL;
            }
            double v67 = &__dst[16 * v17];
            unint64_t v68 = *(void *)v67;
            double v69 = v67[8];
            uint64_t v70 = v67[9];
            double v71 = v67[10];
            double v99 = *(_DWORD *)(v67 + 11);
            double v100 = v67[15];
            double v72 = v17;
            do
            {
              v72 -= v69 + v71;
              uint64_t v73 = &__dst[16 * v72];
              uint64_t v74 = *(void *)v73;
              double v75 = v73[8];
              uint64_t v76 = v73[9];
              uint64_t v77 = v73[10];
              double v78 = *(_DWORD *)(v73 + 11);
              unint64_t v79 = v73[15];
              *(void *)uint64_t v73 = v68;
              v73[8] = v69;
              v73[9] = v70;
              v73[10] = v71;
              *(_DWORD *)(v73 + 11) = v99;
              v73[15] = v100;
              double v100 = v79;
              double v99 = v78;
              double v69 = v75;
              uint64_t v70 = v76;
              double v71 = v77;
              unint64_t v68 = v74;
            }

            while (v72);
            double v80 = 0;
            do
            {
              uint64_t v81 = &__dst[16 * v80];
              double v82 = v81[8];
              *(_DWORD *)uint64_t v9 = v82 + 32 * v81[10] + (*((unsigned __int16 *)v81 + 6) << 10);
              double v83 = v9 + 3;
              uint64_t result = (unint64_t)memcpy(v83, &__src[v80], v82);
              uint64_t v84 = v81[8];
              uint64_t v9 = &v83[v84];
              v80 += v84 + v81[10];
            }

            while (v80 < v17);
            unsigned int v12 = v98;
            double v85 = __src;
            BOOL v10 = __b;
          }

          int v16 = &v85[v17];
          unint64_t v15 = v94 - v17;
          if (v94 == (_DWORD)v17) {
            return v9 - v87;
          }
        }

              *(void *)(v21 + 8 * v38) = v37;
              ++v36;
              v35 += 8LL;
            }

            while (v36 != v27);
          }

          ++v33;
        }

        while (v33 != 6);
      }

      else if (v26 >> 33)
      {
        int v28 = 0LL;
        if (v27 <= 2) {
          uint64_t v27 = 2LL;
        }
        for (uint64_t i = 1LL; i != v27; ++i)
        {
          unint64_t v30 = *(void *)(v21 + 8 * i);
          int v31 = v28;
          uint64_t v32 = i;
          do
          {
            *(void *)(v21 + 8 * v32) = *(void *)(v21 + v31);
            v31 -= 8LL;
            --v32;
          }

          while (v32);
          *(void *)(v21 + 8 * v32) = v30;
          v28 += 8LL;
        }
      }

      size_t v41 = (unint64_t)(v24 - v21) >> 3;
      *(void *)int v24 = -1LL;
      *(void *)(v24 + 8) = -1LL;
      if ((int)v41 >= 2)
      {
        unsigned __int16 v42 = 0;
        unsigned __int16 v43 = v41 + 1;
        uint64_t v44 = (void *)(v24 + 16);
        int v45 = v41 + 1;
        do
        {
          uint64_t v46 = *(_DWORD *)(v21 + 8LL * v42);
          int v47 = *(_DWORD *)(v21 + 8LL * v43);
          unint64_t v48 = v46 > v47;
          if (v46 > v47) {
            int v49 = v42;
          }
          else {
            int v49 = v42 + 1;
          }
          if (v48) {
            unint64_t v50 = v43 + 1;
          }
          else {
            unint64_t v50 = v43;
          }
          if (v48) {
            uint64_t v51 = v43;
          }
          else {
            uint64_t v51 = v42;
          }
          uint64_t v52 = *(_DWORD *)(v21 + 8LL * v49);
          char v53 = *(_DWORD *)(v21 + 8LL * v50);
          double v54 = v52 > v53;
          if (v52 > v53) {
            unsigned __int16 v42 = v49;
          }
          else {
            unsigned __int16 v42 = v49 + 1;
          }
          if (v54) {
            unsigned __int16 v43 = v50 + 1;
          }
          else {
            unsigned __int16 v43 = v50;
          }
          if (v54) {
            int v49 = v50;
          }
          *((_DWORD *)v44 - 2) = *(_DWORD *)(v21 + 8LL * v49) + *(_DWORD *)(v21 + 8LL * v51);
          *((_WORD *)v44 - 2) = v51;
          *((_WORD *)v44 - 1) = v49;
          *v44++ = -1LL;
          --v45;
        }

        while (v45 > 2);
      }

      v22 *= 2;
    }

    while (!BrotliSetDepth(2 * (int)v41 - 1, v21, (uint64_t)a5, 14));
    BrotliFree(v89, v21);
    uint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols(a5, v15, v88);
    if (v14 <= 4)
    {
      uint64_t v55 = 0LL;
      double v56 = *a7;
      *(void *)(a8 + (*a7 >> 3)) = (1LL << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
      *a7 = v56 + 2;
      *(void *)(a8 + ((v56 + 2) >> 3)) = (v18 << ((v56 + 2) & 7)) | *(unsigned __int8 *)(a8 + ((v56 + 2) >> 3));
      unint64_t v57 = v56 + 4;
      *a7 = v57;
      double v58 = (char *)&v90 + 8;
      do
      {
        uint64_t v59 = v55 + 1;
        if (v55 + 1 < v14)
        {
          double v60 = *((void *)&v90 + v55);
          double v61 = (uint64_t *)v58;
          uint64_t v62 = v18;
          do
          {
            uint64_t v63 = *v61;
            uint64_t result = a5[v60];
            if (a5[*v61] < result)
            {
              char *v61 = v60;
              *((void *)&v90 + v55) = v63;
              double v60 = v63;
            }

            ++v61;
            --v62;
          }

          while (v62);
        }

        --v18;
        v58 += 8;
        ++v55;
      }

      while (v59 != v14);
      char v64 = v57 >> 3;
      if (v14 == 3)
      {
        unint64_t v79 = *((void *)&v90 + 1);
        *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
        double v80 = v57 + a4;
        *a7 = v80;
        *(void *)(a8 + (v80 >> 3)) = (v79 << (v80 & 7)) | *(unsigned __int8 *)(a8 + (v80 >> 3));
        uint64_t v66 = v80 + a4;
        *a7 = v66;
        *(void *)(a8 + (v66 >> 3)) = ((void)v91 << (v66 & 7)) | *(unsigned __int8 *)(a8 + (v66 >> 3));
      }

      else
      {
        if (v14 != 2)
        {
          double v82 = v90;
          *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
          double v83 = v57 + a4;
          *a7 = v83;
          *(void *)(a8 + (v83 >> 3)) = (*((void *)&v82 + 1) << (v83 & 7)) | *(unsigned __int8 *)(a8 + (v83 >> 3));
          uint64_t v84 = v83 + a4;
          *a7 = v84;
          double v85 = *((void *)&v91 + 1);
          *(void *)(a8 + (v84 >> 3)) = ((void)v91 << (v84 & 7)) | *(unsigned __int8 *)(a8 + (v84 >> 3));
          uint64_t v86 = v84 + a4;
          *a7 = v86;
          *(void *)(a8 + (v86 >> 3)) = (v85 << (v86 & 7)) | *(unsigned __int8 *)(a8 + (v86 >> 3));
          uint64_t v87 = v86 + a4;
          *a7 = v87;
          *(void *)(a8 + (v87 >> 3)) = ((unint64_t)(a5[v82] == 1) << (v87 & 7)) | *(unsigned __int8 *)(a8 + (v87 >> 3));
          uint64_t v81 = v87 + 1;
          goto LABEL_101;
        }

        double v65 = *((void *)&v90 + 1);
        *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
        uint64_t v66 = v57 + a4;
        *a7 = v66;
        *(void *)(a8 + (v66 >> 3)) = (v65 << (v66 & 7)) | *(unsigned __int8 *)(a8 + (v66 >> 3));
      }

      uint64_t v81 = v66 + a4;
LABEL_101:
      *a7 = v81;
      return result;
    }

    double v67 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (0xFF55555554LL << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    unint64_t v68 = v67 + 40;
    *a7 = v68;
    if (!v15) {
      return result;
    }
    double v69 = 0LL;
    uint64_t v70 = 8LL;
    while (1)
    {
      double v71 = a5[v69];
      if (v69 + 1 >= v15)
      {
        ++v69;
        uint64_t result = 1LL;
        if (!(_DWORD)v71) {
          goto LABEL_94;
        }
      }

      else
      {
        double v72 = 0LL;
        uint64_t result = v15 - v69;
        while (a5[v69 + 1 + v72] == (_DWORD)v71)
        {
          if (v15 - v69 - 1 == ++v72) {
            goto LABEL_93;
          }
        }

        uint64_t result = v72 + 1;
LABEL_93:
        v69 += result;
        if (!(_DWORD)v71)
        {
LABEL_94:
          double v78 = kZeroRepsDepth[result];
          uint64_t result = (kZeroRepsBits[result] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
          *(void *)(a8 + (v68 >> 3)) = result;
          v68 += v78;
          goto LABEL_95;
        }
      }

      if ((_DWORD)v70 != (_DWORD)v71)
      {
        uint64_t v73 = kCodeLengthDepth[v71];
        *(void *)(a8 + (v68 >> 3)) = ((unint64_t)kCodeLengthBits[v71] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
        v68 += v73;
        *a7 = v68;
        --result;
      }

      if (result > 2) {
        break;
      }
      if (result)
      {
        uint64_t v74 = kCodeLengthDepth[v71];
        double v75 = kCodeLengthBits[v71];
        do
        {
          *(void *)(a8 + (v68 >> 3)) = (v75 << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
          v68 += v74;
          --result;
        }

        while (result);
        goto LABEL_91;
      }

LABEL_31:
          unint64_t v35 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 16 * v35;
          *(_DWORD *)(a2 + 24) = v18 - 4;
          size_t v36 = (v35 >> 60) + 4;
LABEL_41:
          size_t v41 = v36 + a3;
          if (v36 + a3 > v11) {
            return 0xFFFFFFFFLL;
          }
          bzero((void *)(a1 + a3), v36);
          a3 = v41;
          break;
      }
    }

    else
    {
      unsigned int v12 = *(unsigned __int8 *)(a1 + a3);
      *(_BYTE *)(a1 + a3++) = v12 - v43;
    }
  }

  if (a3 == v11) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t lzx_huffman_create_pre_tree(void *a1, uint64_t a2)
{
  unint64_t v4 = 0LL;
  a1[16446] = 20LL;
  while (1)
  {
    int v5 = *(_DWORD *)(a2 + 24);
    if (v5 <= 48) {
      break;
    }
    int v10 = *(_DWORD *)(a2 + 24);
LABEL_9:
    unint64_t v13 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 16 * v13;
    *(_DWORD *)(a2 + 24) = v10 - 4;
    *((_BYTE *)a1 + v4++) = v13 >> 60;
    if (v4 >= a1[16446])
    {
      lzx_huffman_tree_compute_lookup_from_code_len((unsigned __int8 *)a1);
      return 0LL;
    }
  }

  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)a2 + 2LL;
  int v8 = 48 - v5;
  while (v7 <= v6)
  {
    uint64_t v9 = *(unsigned __int16 *)(v7 - 2);
    *(void *)a2 = v7;
    int v10 = v5 + 16;
    uint64_t v11 = (v9 << v8) | *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v5 + 16;
    *(void *)(a2 + 16) = v11;
    v7 += 2LL;
    v8 -= 16;
    BOOL v12 = v5 < 33;
    v5 += 16;
    if (!v12) {
      goto LABEL_9;
    }
  }

  int v10 = v5;
  if (v5 >= 4) {
    goto LABEL_9;
  }
  return 0xFFFFFFFFLL;
}

unint64_t BrotliCompressFragmentFast( unint64_t result, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned int a6, unsigned __int8 *a7, uint64_t a8, unint64_t *a9, _BYTE *a10, unint64_t *a11, uint64_t a12)
{
  unint64_t v12 = *a11;
  if (!a3) {
    goto LABEL_11;
  }
  switch(__clz(a6) ^ 0x1F)
  {
    case 9u:
      uint64_t result = BrotliCompressFragmentFastImpl9(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xBu:
      uint64_t result = BrotliCompressFragmentFastImpl11(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xDu:
      uint64_t result = BrotliCompressFragmentFastImpl13(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xFu:
      uint64_t result = BrotliCompressFragmentFastImpl15(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    default:
      break;
  }

  if (*a11 - v12 > 8 * a3 + 31) {
    uint64_t result = (unint64_t)EmitUncompressedMetaBlock(a2, (uint64_t)&a2[a3], v12, a11, a12);
  }
  if (a4)
  {
    unint64_t v12 = *a11;
LABEL_11:
    *(void *)(a12 + (v12 >> 3)) = (1LL << (v12 & 7)) | *(unsigned __int8 *)(a12 + (v12 >> 3));
    *a11 = v12 + 1;
    *(void *)(a12 + ((v12 + 1) >> 3)) = (1LL << ((v12 + 1) & 7)) | *(unsigned __int8 *)(a12 + ((v12 + 1) >> 3));
    *a11 = ((_DWORD)v12 + 9) & 0xFFFFFFF8;
  }

  return result;
}

unint64_t BrotliCompressFragmentFastImpl9( unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, _BYTE *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v205 = *MEMORY[0x1895F89C0];
  unint64_t v197 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304LL;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v193 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v203, (uint64_t)v202, a10, a11);
  unint64_t v191 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v190 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0LL;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8LL;
    }

    while (v21 < *a8);
    v18 += v20;
  }

  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
  while (2)
  {
    unint64_t v198 = v14;
    unint64_t v200 = v14;
    unint64_t v23 = v22;
    uint64_t v192 = v22;
    while (2)
    {
      unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
      unint64_t v24 = (unint64_t)&v22[v200];
      uint64_t v201 = &v22[v200];
      if (v200 < 0x10)
      {
        unint64_t v22 = v23;
        unint64_t v26 = v197;
        goto LABEL_100;
      }

      uint64_t v25 = v200 - 5;
      unint64_t v26 = v197;
      if (v200 - 5 >= v197 - 16) {
        uint64_t v25 = v197 - 16;
      }
      if (v25 < 2)
      {
LABEL_99:
        unint64_t v22 = v23;
        goto LABEL_100;
      }

      unint64_t v27 = (unint64_t)&v22[v25];
      int v28 = v22 + 2;
      int v29 = -1;
      unint64_t v194 = v22;
      do
      {
        uint64_t v31 = *(void *)++v22;
        uint64_t v30 = v31;
        for (unsigned int i = 33; ; ++i)
        {
          int v33 = v28;
          unint64_t v34 = (unint64_t)(0x1E35A7BD000000LL * v30) >> 55;
          uint64_t v30 = *(void *)v33;
          unint64_t v35 = &v22[-v29];
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
            break;
          }
          unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
          *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
            goto LABEL_24;
          }
LABEL_28:
          int v28 = &v33[i >> 5];
          unint64_t v22 = v33;
        }

        *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
LABEL_24:
        int v37 = (_DWORD)v22 - (_DWORD)v35;
        if (v22 - v35 > 262128) {
          goto LABEL_28;
        }
        size_t v38 = v35 + 5;
        unsigned int v39 = v22 + 5;
        unint64_t v40 = v24 - (void)v22 - 5;
        if (v40 < 8)
        {
          unint64_t v43 = 0LL;
LABEL_89:
          unint64_t v144 = v40 & 7;
          if (v144)
          {
            unint64_t v145 = v43 | v144;
            while (v38[v43] == *v39)
            {
              ++v39;
              ++v43;
              if (!--v144)
              {
                unint64_t v43 = v145;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v41 = 0LL;
          unint64_t v42 = v40 >> 3;
          unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v44 = *(void *)&v39[v41];
            uint64_t v45 = *(void *)&v38[v41];
            if (v44 != v45) {
              break;
            }
            v41 += 8LL;
            if (!--v42)
            {
              v39 += v40 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_89;
            }
          }

          unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }

        unint64_t v46 = v22 - v23;
        if ((unint64_t)(v22 - v23) >> 1 > 0xC20)
        {
          if (50 * (v23 - v192) > v46 || v190 < 0x3D5)
          {
            if (v46 > 0x5841)
            {
              uint64_t v149 = a6[63];
              unint64_t v150 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v151 = v150 + v149;
              *a10 = v151;
              *(void *)(a11 + (v151 >> 3)) = ((v46 - 22594) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
              unint64_t v50 = v151 + 24;
              *a10 = v50;
              uint64_t v51 = &__dst[63];
            }

            else
            {
              uint64_t v146 = a6[62];
              unint64_t v147 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v148 = v147 + v146;
              *a10 = v148;
              *(void *)(a11 + (v148 >> 3)) = ((v46 - 6210) << (v148 & 7)) | *(unsigned __int8 *)(a11 + (v148 >> 3));
              unint64_t v50 = v148 + 14;
              *a10 = v50;
              uint64_t v51 = &__dst[62];
            }

            goto LABEL_44;
          }

          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, (uint64_t)v22, v193, a10, a11);
          unint64_t v160 = &v194[v197] - v22;
          if (v160) {
            goto LABEL_125;
          }
          goto LABEL_141;
        }

        if (v46 > 5)
        {
          if (v46 > 0x81)
          {
            if (v46 > 0x841)
            {
              uint64_t v62 = a6[61];
              unint64_t v63 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v64 = v63 + v62;
              *a10 = v64;
              *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
              unint64_t v50 = v64 + 12;
              *a10 = v50;
              uint64_t v51 = &__dst[61];
            }

            else
            {
              uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
              uint64_t v59 = a6[v58 + 50];
              unint64_t v60 = *a10;
              unint64_t v24 = (unint64_t)v201;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v61 = v60 + v59;
              *a10 = v61;
              unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
              *(void *)(a11 + (v61 >> 3)) = (((-1LL << v58) + v46 - 66) << (v61 & 7)) | result;
              unint64_t v50 = v61 + v58;
              *a10 = v61 + v58;
              uint64_t v51 = &__dst[v58 + 50];
            }
          }

          else
          {
            uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
            unint64_t v53 = (v46 - 2) >> v52;
            uint64_t v54 = (2 * v52) + v53 + 42;
            uint64_t v55 = a6[v54];
            unint64_t v56 = *a10;
            unint64_t v24 = (unint64_t)v201;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v57 = v56 + v55;
            *a10 = v57;
            unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
            *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
            unint64_t v50 = v57 + v52;
            *a10 = v57 + v52;
            uint64_t v51 = &__dst[v54];
          }
        }

        else
        {
          uint64_t v47 = a6[v46 + 40];
          unint64_t v48 = *a10;
          unint64_t v49 = *a10 >> 3;
          unint64_t result = *(unsigned __int8 *)(a11 + v49);
          *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(_BYTE *)a10 & 7)) | result;
          unint64_t v50 = v48 + v47;
          *a10 = v50;
          uint64_t v51 = &__dst[v46 + 40];
        }

LABEL_44:
        ++*v51;
        if (v22 != v23)
        {
          if (v46 <= 1) {
            unint64_t v46 = 1LL;
          }
          do
          {
            int v65 = *v23++;
            uint64_t v66 = v203[v65];
            unint64_t result = v50 & 7;
            *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v202[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
            v50 += v66;
            *a10 = v50;
            --v46;
          }

          while (v46);
        }

        if (v29 == v37)
        {
          uint64_t v67 = a6[64];
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v68 = v50 + v67;
          double v69 = &__dst[64];
        }

        else
        {
          unint64_t v70 = v37 + 3LL;
          unsigned int v71 = __clz(v70) ^ 0x1F;
          uint64_t v72 = v71 - 1;
          uint64_t v73 = ((v70 >> (v71 - 1)) & 1 | 2) << (v71 - 1);
          uint64_t v74 = ((2 * v71 - 4) & 0xFFFFFFFE | (v70 >> (v71 - 1)) & 1) + 80;
          uint64_t v75 = a6[v74];
          unint64_t result = v50 >> 3;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v74) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v76 = v50 + v75;
          *a10 = v76;
          *(void *)(a11 + (v76 >> 3)) = ((v70 - v73) << (v76 & 7)) | *(unsigned __int8 *)(a11 + (v76 >> 3));
          unint64_t v68 = v76 + v72;
          double v69 = &__dst[v74];
          int v29 = v37;
        }

        unint64_t v77 = v43 + 5;
        ++*v69;
        *a10 = v68;
        if (v43 + 5 > 0xB)
        {
          if (v77 > 0x47)
          {
            if (v77 > 0x87)
            {
              if (v77 > 0x847)
              {
                uint64_t v98 = a6[39];
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
                unint64_t v99 = v68 + v98;
                *a10 = v99;
                char v100 = v99 & 7;
                *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
                unint64_t v101 = v99 + 24;
                *a10 = v99 + 24;
                uint64_t v102 = a6[64];
                *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
                *a10 = v101 + v102;
                ++__dst[39];
              }

              else
              {
                unint64_t v92 = v43 - 67;
                uint64_t v93 = __clz(v92) ^ 0x1F;
                uint64_t v94 = a6[v93 + 28];
                unint64_t result = *(unsigned __int8 *)(a11 + (v68 >> 3));
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v68 & 7)) | result;
                unint64_t v95 = v68 + v94;
                *a10 = v95;
                *(void *)(a11 + (v95 >> 3)) = (((-1LL << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
                unint64_t v96 = v95 + v93;
                *a10 = v95 + v93;
                uint64_t v97 = a6[64];
                *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
                *a10 = v96 + v97;
                ++__dst[v93 + 28];
              }
            }

            else
            {
              unint64_t v86 = v43 - 3;
              uint64_t v87 = (v86 >> 5) + 30;
              uint64_t v88 = a6[v87];
              unint64_t result = v68 & 7;
              *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
              unint64_t v89 = v68 + v88;
              *a10 = v89;
              *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
              unint64_t v90 = v89 + 5;
              *a10 = v89 + 5;
              uint64_t v91 = a6[64];
              *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
              *a10 = v90 + v91;
              ++__dst[v87];
            }

            double v80 = &__dst[64];
          }

          else
          {
            unint64_t v81 = v43 - 3;
            uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
            uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
            uint64_t v84 = a6[v83];
            unint64_t result = v68 >> 3;
            *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
            unint64_t v85 = v68 + v84;
            *a10 = v85;
            *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
            *a10 = v85 + v82;
            double v80 = &__dst[v83];
          }
        }

        else
        {
          unint64_t v78 = v43 + 1;
          uint64_t v79 = a6[v78];
          *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
          *a10 = v68 + v79;
          double v80 = &__dst[v78];
        }

        v22 += v77;
        ++*v80;
        while (1)
        {
          unint64_t v103 = *(void *)(v22 - 3);
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * v103) >> 53) & 0x7FC)) = (_DWORD)v22 - (_DWORD)a2 - 3;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 8)) >> 53) & 0x7FC)) = (_DWORD)v22 - (_DWORD)a2 - 2;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 16)) >> 53) & 0x7FC)) = (_DWORD)v22 - (_DWORD)a2 - 1;
          unint64_t v104 = ((0x1E35A7BD000000LL * (v103 >> 24)) >> 53) & 0x7FC;
          uint64_t v105 = *(int *)(a5 + v104);
          *(_DWORD *)(a5 + v104) = (_DWORD)v22 - (_DWORD)a2;
          uint64_t v106 = &a2[v105];
          if (*(_DWORD *)v22 != *(_DWORD *)&a2[v105] || v22[4] != v106[4]) {
            break;
          }
          int v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v24 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0LL;
LABEL_81:
            unint64_t v142 = v109 & 7;
            if (v142)
            {
              unint64_t v143 = v112 | v142;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v142)
                {
                  unint64_t v112 = v143;
                  break;
                }
              }
            }
          }

          else
          {
            uint64_t v110 = 0LL;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8LL;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8LL;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_81;
              }
            }

            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }

          uint64_t v114 = v22 - v106;
          if (v114 > 262128) {
            break;
          }
          unint64_t v115 = v112 + 5;
          if (v112 + 5 > 9)
          {
            if (v115 > 0x85)
            {
              if (v115 > 0x845)
              {
                uint64_t v132 = a6[39];
                unint64_t v133 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v134 = v133 + v132;
                *a10 = v134;
                *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                unint64_t v119 = v134 + 24;
                *a10 = v134 + 24;
                int v120 = &__dst[39];
              }

              else
              {
                unint64_t v127 = v112 - 65;
                uint64_t v128 = __clz(v127) ^ 0x1F;
                uint64_t v129 = a6[v128 + 28];
                unint64_t v130 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v131 = v130 + v129;
                *a10 = v131;
                *(void *)(a11 + (v131 >> 3)) = (((-1LL << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                unint64_t v119 = v131 + v128;
                *a10 = v131 + v128;
                int v120 = &__dst[v128 + 28];
              }
            }

            else
            {
              unint64_t v121 = v112 - 1;
              uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
              uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
              uint64_t v124 = a6[v123];
              unint64_t v125 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v126 = v125 + v124;
              *a10 = v126;
              *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
              unint64_t v119 = v126 + v122;
              *a10 = v126 + v122;
              int v120 = &__dst[v123];
            }
          }

          else
          {
            unint64_t v116 = v112 + 19;
            uint64_t v117 = a6[v112 + 19];
            unint64_t v118 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v119 = v118 + v117;
            *a10 = v119;
            int v120 = &__dst[v116];
          }

          v22 += v115;
          ++*v120;
          unint64_t v135 = (int)v114 + 3LL;
          unsigned int v136 = __clz(v135) ^ 0x1F;
          uint64_t v137 = v136 - 1;
          uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
          uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
          uint64_t v140 = a6[v139];
          unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
          *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
          unint64_t v141 = v119 + v140;
          *a10 = v141;
          *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
          *a10 = v141 + v137;
          ++__dst[v139];
          int v29 = v114;
        }

        int v28 = v22 + 2;
        unint64_t v23 = v22;
      }

      while ((unint64_t)(v22 + 2) <= v27);
LABEL_100:
      unint64_t v152 = v26 - v200;
      if (v152 >= 0x10000) {
        unint64_t v153 = 0x10000LL;
      }
      else {
        unint64_t v153 = v152;
      }
      unint64_t v197 = v152;
      if (v152)
      {
        unint64_t v154 = v153 + v198;
        if (v153 + v198 <= 0x100000)
        {
          unint64_t v200 = v153;
          unint64_t result = ShouldMergeBlock(v24, v153, (uint64_t)v203);
          unint64_t v24 = (unint64_t)v201;
          if ((_DWORD)result)
          {
            unint64_t v198 = v154;
            UpdateBits((v154 - 1), v193 + 3, a11);
            unint64_t v23 = v22;
            unint64_t v22 = v201;
            continue;
          }
        }
      }

      break;
    }

    if ((unint64_t)v22 >= v24)
    {
      unint64_t v22 = (unsigned __int8 *)v24;
      goto LABEL_113;
    }

    unint64_t v155 = v24 - (void)v22;
    if ((v24 - (unint64_t)v22) >> 1 > 0xC20)
    {
      unint64_t result = (unint64_t)v192;
      if (50 * (v22 - v192) > v155 || v190 < 0x3D5)
      {
        if (v155 > 0x5841)
        {
          uint64_t v183 = a6[63];
          unint64_t v184 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v185 = v184 + v183;
          *a10 = v185;
          *(void *)(a11 + (v185 >> 3)) = ((v155 - 22594) << (v185 & 7)) | *(unsigned __int8 *)(a11 + (v185 >> 3));
          unint64_t v181 = v185 + 24;
          uint64_t v182 = &__dst[63];
        }

        else
        {
          uint64_t v178 = a6[62];
          unint64_t v179 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v180 = v179 + v178;
          *a10 = v180;
          *(void *)(a11 + (v180 >> 3)) = ((v155 - 6210) << (v180 & 7)) | *(unsigned __int8 *)(a11 + (v180 >> 3));
          unint64_t v181 = v180 + 14;
          uint64_t v182 = &__dst[62];
        }

        unint64_t v160 = v197;
        ++*v182;
        *a10 = v181;
        do
        {
          int v186 = *v22++;
          uint64_t v187 = v203[v186];
          *(void *)(a11 + (v181 >> 3)) = ((unint64_t)(unsigned __int16)v202[v186] << (v181 & 7)) | *(unsigned __int8 *)(a11 + (v181 >> 3));
          v181 += v187;
          *a10 = v181;
          --v155;
        }

        while (v155);
        goto LABEL_124;
      }

      unint64_t v22 = (unsigned __int8 *)v24;
      unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, v24, v193, a10, a11);
LABEL_113:
      unint64_t v160 = v197;
      if (v197) {
        goto LABEL_125;
      }
      goto LABEL_141;
    }

    if (v155 > 5)
    {
      unint64_t v160 = v197;
      if (v155 > 0x81)
      {
        if (v155 > 0x841)
        {
          uint64_t v171 = a6[61];
          unint64_t v172 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v173 = v172 + v171;
          *a10 = v173;
          *(void *)(a11 + (v173 >> 3)) = ((v155 - 2114) << (v173 & 7)) | *(unsigned __int8 *)(a11 + (v173 >> 3));
          unint64_t v158 = v173 + 12;
          *a10 = v158;
          unint64_t v159 = &__dst[61];
        }

        else
        {
          uint64_t v167 = __clz(v155 - 66) ^ 0x1F;
          uint64_t v168 = a6[v167 + 50];
          unint64_t v169 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v167 + 50)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v170 = v169 + v168;
          *a10 = v170;
          *(void *)(a11 + (v170 >> 3)) = (((-1LL << v167) + v155 - 66) << (v170 & 7)) | *(unsigned __int8 *)(a11 + (v170 >> 3));
          unint64_t v158 = v170 + v167;
          *a10 = v170 + v167;
          unint64_t v159 = &__dst[v167 + 50];
        }
      }

      else
      {
        uint64_t v161 = (__clz(v155 - 2) ^ 0x1F) - 1;
        unint64_t v162 = (v155 - 2) >> v161;
        uint64_t v163 = (2 * v161) + v162 + 42;
        uint64_t v164 = a6[v163];
        unint64_t v165 = *a10;
        unint64_t result = *a10 & 7;
        *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v163) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
        unint64_t v166 = v165 + v164;
        *a10 = v166;
        *(void *)(a11 + (v166 >> 3)) = ((v155 - 2 - (v162 << v161)) << (v166 & 7)) | *(unsigned __int8 *)(a11 + (v166 >> 3));
        unint64_t v158 = v166 + v161;
        *a10 = v166 + v161;
        unint64_t v159 = &__dst[v163];
      }
    }

    else
    {
      uint64_t v156 = a6[v155 + 40];
      unint64_t v157 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v155 + 40)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v158 = v157 + v156;
      *a10 = v158;
      unint64_t v159 = &__dst[v155 + 40];
      unint64_t v160 = v197;
    }

    ++*v159;
    if ((unsigned __int8 *)v24 != v22)
    {
      if (v155 <= 1) {
        unint64_t v155 = 1LL;
      }
      do
      {
        int v174 = *v22++;
        uint64_t v175 = v203[v174];
        *(void *)(a11 + (v158 >> 3)) = ((unint64_t)(unsigned __int16)v202[v174] << (v158 & 7)) | *(unsigned __int8 *)(a11 + (v158 >> 3));
        v158 += v175;
        *a10 = v158;
        --v155;
      }

      while (v155);
    }

        ++*v51;
        if (v22 != v23)
        {
          if (v46 <= 1) {
            unint64_t v46 = 1LL;
          }
          do
          {
            int v65 = *v23++;
            uint64_t v66 = v203[v65];
            unint64_t result = v50 & 7;
            *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v202[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
            v50 += v66;
            *a10 = v50;
            --v46;
          }

          while (v46);
        }

        if (v29 == v37)
        {
          uint64_t v67 = a6[64];
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v68 = v50 + v67;
          double v69 = &__dst[64];
        }

        else
        {
          unint64_t v70 = v37 + 3LL;
          unsigned int v71 = __clz(v70) ^ 0x1F;
          uint64_t v72 = v71 - 1;
          uint64_t v73 = ((v70 >> (v71 - 1)) & 1 | 2) << (v71 - 1);
          uint64_t v74 = ((2 * v71 - 4) & 0xFFFFFFFE | (v70 >> (v71 - 1)) & 1) + 80;
          uint64_t v75 = a6[v74];
          unint64_t result = v50 >> 3;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v74) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v76 = v50 + v75;
          *a10 = v76;
          *(void *)(a11 + (v76 >> 3)) = ((v70 - v73) << (v76 & 7)) | *(unsigned __int8 *)(a11 + (v76 >> 3));
          unint64_t v68 = v76 + v72;
          double v69 = &__dst[v74];
          int v29 = v37;
        }

        unint64_t v77 = v43 + 5;
        ++*v69;
        *a10 = v68;
        if (v43 + 5 > 0xB)
        {
          if (v77 > 0x47)
          {
            if (v77 > 0x87)
            {
              if (v77 > 0x847)
              {
                uint64_t v98 = a6[39];
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
                unint64_t v99 = v68 + v98;
                *a10 = v99;
                char v100 = v99 & 7;
                *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
                unint64_t v101 = v99 + 24;
                *a10 = v99 + 24;
                uint64_t v102 = a6[64];
                *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
                *a10 = v101 + v102;
                ++__dst[39];
              }

              else
              {
                unint64_t v92 = v43 - 67;
                uint64_t v93 = __clz(v92) ^ 0x1F;
                uint64_t v94 = a6[v93 + 28];
                unint64_t result = *(unsigned __int8 *)(a11 + (v68 >> 3));
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v68 & 7)) | result;
                unint64_t v95 = v68 + v94;
                *a10 = v95;
                *(void *)(a11 + (v95 >> 3)) = (((-1LL << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
                unint64_t v96 = v95 + v93;
                *a10 = v95 + v93;
                uint64_t v97 = a6[64];
                *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
                *a10 = v96 + v97;
                ++__dst[v93 + 28];
              }
            }

            else
            {
              unint64_t v86 = v43 - 3;
              uint64_t v87 = (v86 >> 5) + 30;
              uint64_t v88 = a6[v87];
              unint64_t result = v68 & 7;
              *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
              unint64_t v89 = v68 + v88;
              *a10 = v89;
              *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
              unint64_t v90 = v89 + 5;
              *a10 = v89 + 5;
              uint64_t v91 = a6[64];
              *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
              *a10 = v90 + v91;
              ++__dst[v87];
            }

            double v80 = &__dst[64];
          }

          else
          {
            unint64_t v81 = v43 - 3;
            uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
            uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
            uint64_t v84 = a6[v83];
            unint64_t result = v68 >> 3;
            *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
            unint64_t v85 = v68 + v84;
            *a10 = v85;
            *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
            *a10 = v85 + v82;
            double v80 = &__dst[v83];
          }
        }

        else
        {
          unint64_t v78 = v43 + 1;
          uint64_t v79 = a6[v78];
          *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
          *a10 = v68 + v79;
          double v80 = &__dst[v78];
        }

        v22 += v77;
        ++*v80;
        while (1)
        {
          unint64_t v103 = *(void *)(v22 - 3);
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * v103) >> 51) & 0x1FFC)) = (_DWORD)v22 - (_DWORD)a2 - 3;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 8)) >> 51) & 0x1FFC)) = (_DWORD)v22 - (_DWORD)a2 - 2;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 16)) >> 51) & 0x1FFC)) = (_DWORD)v22 - (_DWORD)a2 - 1;
          unint64_t v104 = ((0x1E35A7BD000000LL * (v103 >> 24)) >> 51) & 0x1FFC;
          uint64_t v105 = *(int *)(a5 + v104);
          *(_DWORD *)(a5 + v104) = (_DWORD)v22 - (_DWORD)a2;
          uint64_t v106 = &a2[v105];
          if (*(_DWORD *)v22 != *(_DWORD *)&a2[v105] || v22[4] != v106[4]) {
            break;
          }
          int v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v24 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0LL;
LABEL_81:
            unint64_t v142 = v109 & 7;
            if (v142)
            {
              unint64_t v143 = v112 | v142;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v142)
                {
                  unint64_t v112 = v143;
                  break;
                }
              }
            }
          }

          else
          {
            uint64_t v110 = 0LL;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8LL;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8LL;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_81;
              }
            }

            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }

          uint64_t v114 = v22 - v106;
          if (v114 > 262128) {
            break;
          }
          unint64_t v115 = v112 + 5;
          if (v112 + 5 > 9)
          {
            if (v115 > 0x85)
            {
              if (v115 > 0x845)
              {
                uint64_t v132 = a6[39];
                unint64_t v133 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v134 = v133 + v132;
                *a10 = v134;
                *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                unint64_t v119 = v134 + 24;
                *a10 = v134 + 24;
                int v120 = &__dst[39];
              }

              else
              {
                unint64_t v127 = v112 - 65;
                uint64_t v128 = __clz(v127) ^ 0x1F;
                uint64_t v129 = a6[v128 + 28];
                unint64_t v130 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v131 = v130 + v129;
                *a10 = v131;
                *(void *)(a11 + (v131 >> 3)) = (((-1LL << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                unint64_t v119 = v131 + v128;
                *a10 = v131 + v128;
                int v120 = &__dst[v128 + 28];
              }
            }

            else
            {
              unint64_t v121 = v112 - 1;
              uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
              uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
              uint64_t v124 = a6[v123];
              unint64_t v125 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v126 = v125 + v124;
              *a10 = v126;
              *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
              unint64_t v119 = v126 + v122;
              *a10 = v126 + v122;
              int v120 = &__dst[v123];
            }
          }

          else
          {
            unint64_t v116 = v112 + 19;
            uint64_t v117 = a6[v112 + 19];
            unint64_t v118 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v119 = v118 + v117;
            *a10 = v119;
            int v120 = &__dst[v116];
          }

          v22 += v115;
          ++*v120;
          unint64_t v135 = (int)v114 + 3LL;
          unsigned int v136 = __clz(v135) ^ 0x1F;
          uint64_t v137 = v136 - 1;
          uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
          uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
          uint64_t v140 = a6[v139];
          unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
          *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
          unint64_t v141 = v119 + v140;
          *a10 = v141;
          *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
          *a10 = v141 + v137;
          ++__dst[v139];
          int v29 = v114;
        }

        int v28 = v22 + 2;
        unint64_t v23 = v22;
      }

      while ((unint64_t)(v22 + 2) <= v27);
LABEL_100:
      unint64_t v152 = v26 - v200;
      if (v152 >= 0x10000) {
        unint64_t v153 = 0x10000LL;
      }
      else {
        unint64_t v153 = v152;
      }
      unint64_t v197 = v152;
      if (v152)
      {
        unint64_t v154 = v153 + v198;
        if (v153 + v198 <= 0x100000)
        {
          unint64_t v200 = v153;
          unint64_t result = ShouldMergeBlock(v24, v153, (uint64_t)v203);
          unint64_t v24 = (unint64_t)v201;
          if ((_DWORD)result)
          {
            unint64_t v198 = v154;
            UpdateBits((v154 - 1), v193 + 3, a11);
            unint64_t v23 = v22;
            unint64_t v22 = v201;
            continue;
          }
        }
      }

      break;
    }

    if ((unint64_t)v22 >= v24)
    {
      unint64_t v22 = (unsigned __int8 *)v24;
      goto LABEL_113;
    }

    unint64_t v155 = v24 - (void)v22;
    if ((v24 - (unint64_t)v22) >> 1 > 0xC20)
    {
      unint64_t result = (unint64_t)v192;
      if (50 * (v22 - v192) > v155 || v190 < 0x3D5)
      {
        if (v155 > 0x5841)
        {
          uint64_t v183 = a6[63];
          unint64_t v184 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v185 = v184 + v183;
          *a10 = v185;
          *(void *)(a11 + (v185 >> 3)) = ((v155 - 22594) << (v185 & 7)) | *(unsigned __int8 *)(a11 + (v185 >> 3));
          unint64_t v181 = v185 + 24;
          uint64_t v182 = &__dst[63];
        }

        else
        {
          uint64_t v178 = a6[62];
          unint64_t v179 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v180 = v179 + v178;
          *a10 = v180;
          *(void *)(a11 + (v180 >> 3)) = ((v155 - 6210) << (v180 & 7)) | *(unsigned __int8 *)(a11 + (v180 >> 3));
          unint64_t v181 = v180 + 14;
          uint64_t v182 = &__dst[62];
        }

        unint64_t v160 = v197;
        ++*v182;
        *a10 = v181;
        do
        {
          int v186 = *v22++;
          uint64_t v187 = v203[v186];
          *(void *)(a11 + (v181 >> 3)) = ((unint64_t)(unsigned __int16)v202[v186] << (v181 & 7)) | *(unsigned __int8 *)(a11 + (v181 >> 3));
          v181 += v187;
          *a10 = v181;
          --v155;
        }

        while (v155);
        goto LABEL_124;
      }

      unint64_t v22 = (unsigned __int8 *)v24;
      unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, v24, v193, a10, a11);
LABEL_113:
      unint64_t v160 = v197;
      if (v197) {
        goto LABEL_125;
      }
      goto LABEL_141;
    }

    if (v155 > 5)
    {
      unint64_t v160 = v197;
      if (v155 > 0x81)
      {
        if (v155 > 0x841)
        {
          uint64_t v171 = a6[61];
          unint64_t v172 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v173 = v172 + v171;
          *a10 = v173;
          *(void *)(a11 + (v173 >> 3)) = ((v155 - 2114) << (v173 & 7)) | *(unsigned __int8 *)(a11 + (v173 >> 3));
          unint64_t v158 = v173 + 12;
          *a10 = v158;
          unint64_t v159 = &__dst[61];
        }

        else
        {
          uint64_t v167 = __clz(v155 - 66) ^ 0x1F;
          uint64_t v168 = a6[v167 + 50];
          unint64_t v169 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v167 + 50)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v170 = v169 + v168;
          *a10 = v170;
          *(void *)(a11 + (v170 >> 3)) = (((-1LL << v167) + v155 - 66) << (v170 & 7)) | *(unsigned __int8 *)(a11 + (v170 >> 3));
          unint64_t v158 = v170 + v167;
          *a10 = v170 + v167;
          unint64_t v159 = &__dst[v167 + 50];
        }
      }

      else
      {
        uint64_t v161 = (__clz(v155 - 2) ^ 0x1F) - 1;
        unint64_t v162 = (v155 - 2) >> v161;
        uint64_t v163 = (2 * v161) + v162 + 42;
        uint64_t v164 = a6[v163];
        unint64_t v165 = *a10;
        unint64_t result = *a10 & 7;
        *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v163) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
        unint64_t v166 = v165 + v164;
        *a10 = v166;
        *(void *)(a11 + (v166 >> 3)) = ((v155 - 2 - (v162 << v161)) << (v166 & 7)) | *(unsigned __int8 *)(a11 + (v166 >> 3));
        unint64_t v158 = v166 + v161;
        *a10 = v166 + v161;
        unint64_t v159 = &__dst[v163];
      }
    }

    else
    {
      uint64_t v156 = a6[v155 + 40];
      unint64_t v157 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v155 + 40)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v158 = v157 + v156;
      *a10 = v158;
      unint64_t v159 = &__dst[v155 + 40];
      unint64_t v160 = v197;
    }

    ++*v159;
    if ((unsigned __int8 *)v24 != v22)
    {
      if (v155 <= 1) {
        unint64_t v155 = 1LL;
      }
      do
      {
        int v174 = *v22++;
        uint64_t v175 = v203[v174];
        *(void *)(a11 + (v158 >> 3)) = ((unint64_t)(unsigned __int16)v202[v174] << (v158 & 7)) | *(unsigned __int8 *)(a11 + (v158 >> 3));
        v158 += v175;
        *a10 = v158;
        --v155;
      }

      while (v155);
    }

        ++*v51;
        if (v22 != v23)
        {
          if (v46 <= 1) {
            unint64_t v46 = 1LL;
          }
          do
          {
            int v65 = *v23++;
            uint64_t v66 = v203[v65];
            unint64_t result = v50 & 7;
            *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v202[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
            v50 += v66;
            *a10 = v50;
            --v46;
          }

          while (v46);
        }

        if (v29 == v37)
        {
          uint64_t v67 = a6[64];
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v68 = v50 + v67;
          double v69 = &__dst[64];
        }

        else
        {
          unint64_t v70 = v37 + 3LL;
          unsigned int v71 = __clz(v70) ^ 0x1F;
          uint64_t v72 = v71 - 1;
          uint64_t v73 = ((v70 >> (v71 - 1)) & 1 | 2) << (v71 - 1);
          uint64_t v74 = ((2 * v71 - 4) & 0xFFFFFFFE | (v70 >> (v71 - 1)) & 1) + 80;
          uint64_t v75 = a6[v74];
          unint64_t result = v50 >> 3;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v74) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v76 = v50 + v75;
          *a10 = v76;
          *(void *)(a11 + (v76 >> 3)) = ((v70 - v73) << (v76 & 7)) | *(unsigned __int8 *)(a11 + (v76 >> 3));
          unint64_t v68 = v76 + v72;
          double v69 = &__dst[v74];
          int v29 = v37;
        }

        unint64_t v77 = v43 + 5;
        ++*v69;
        *a10 = v68;
        if (v43 + 5 > 0xB)
        {
          if (v77 > 0x47)
          {
            if (v77 > 0x87)
            {
              if (v77 > 0x847)
              {
                uint64_t v98 = a6[39];
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
                unint64_t v99 = v68 + v98;
                *a10 = v99;
                char v100 = v99 & 7;
                *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
                unint64_t v101 = v99 + 24;
                *a10 = v99 + 24;
                uint64_t v102 = a6[64];
                *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
                *a10 = v101 + v102;
                ++__dst[39];
              }

              else
              {
                unint64_t v92 = v43 - 67;
                uint64_t v93 = __clz(v92) ^ 0x1F;
                uint64_t v94 = a6[v93 + 28];
                unint64_t result = *(unsigned __int8 *)(a11 + (v68 >> 3));
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v68 & 7)) | result;
                unint64_t v95 = v68 + v94;
                *a10 = v95;
                *(void *)(a11 + (v95 >> 3)) = (((-1LL << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
                unint64_t v96 = v95 + v93;
                *a10 = v95 + v93;
                uint64_t v97 = a6[64];
                *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
                *a10 = v96 + v97;
                ++__dst[v93 + 28];
              }
            }

            else
            {
              unint64_t v86 = v43 - 3;
              uint64_t v87 = (v86 >> 5) + 30;
              uint64_t v88 = a6[v87];
              unint64_t result = v68 & 7;
              *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
              unint64_t v89 = v68 + v88;
              *a10 = v89;
              *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
              unint64_t v90 = v89 + 5;
              *a10 = v89 + 5;
              uint64_t v91 = a6[64];
              *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
              *a10 = v90 + v91;
              ++__dst[v87];
            }

            double v80 = &__dst[64];
          }

          else
          {
            unint64_t v81 = v43 - 3;
            uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
            uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
            uint64_t v84 = a6[v83];
            unint64_t result = v68 >> 3;
            *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
            unint64_t v85 = v68 + v84;
            *a10 = v85;
            *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
            *a10 = v85 + v82;
            double v80 = &__dst[v83];
          }
        }

        else
        {
          unint64_t v78 = v43 + 1;
          uint64_t v79 = a6[v78];
          *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
          *a10 = v68 + v79;
          double v80 = &__dst[v78];
        }

        v22 += v77;
        ++*v80;
        while (1)
        {
          unint64_t v103 = *(void *)(v22 - 3);
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * v103) >> 49) & 0x7FFC)) = (_DWORD)v22 - (_DWORD)a2 - 3;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 8)) >> 49) & 0x7FFC)) = (_DWORD)v22 - (_DWORD)a2 - 2;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 16)) >> 49) & 0x7FFC)) = (_DWORD)v22 - (_DWORD)a2 - 1;
          unint64_t v104 = ((0x1E35A7BD000000LL * (v103 >> 24)) >> 49) & 0x7FFC;
          uint64_t v105 = *(int *)(a5 + v104);
          *(_DWORD *)(a5 + v104) = (_DWORD)v22 - (_DWORD)a2;
          uint64_t v106 = &a2[v105];
          if (*(_DWORD *)v22 != *(_DWORD *)&a2[v105] || v22[4] != v106[4]) {
            break;
          }
          int v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v24 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0LL;
LABEL_81:
            unint64_t v142 = v109 & 7;
            if (v142)
            {
              unint64_t v143 = v112 | v142;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v142)
                {
                  unint64_t v112 = v143;
                  break;
                }
              }
            }
          }

          else
          {
            uint64_t v110 = 0LL;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8LL;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8LL;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_81;
              }
            }

            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }

          uint64_t v114 = v22 - v106;
          if (v114 > 262128) {
            break;
          }
          unint64_t v115 = v112 + 5;
          if (v112 + 5 > 9)
          {
            if (v115 > 0x85)
            {
              if (v115 > 0x845)
              {
                uint64_t v132 = a6[39];
                unint64_t v133 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v134 = v133 + v132;
                *a10 = v134;
                *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                unint64_t v119 = v134 + 24;
                *a10 = v134 + 24;
                int v120 = &__dst[39];
              }

              else
              {
                unint64_t v127 = v112 - 65;
                uint64_t v128 = __clz(v127) ^ 0x1F;
                uint64_t v129 = a6[v128 + 28];
                unint64_t v130 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v131 = v130 + v129;
                *a10 = v131;
                *(void *)(a11 + (v131 >> 3)) = (((-1LL << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                unint64_t v119 = v131 + v128;
                *a10 = v131 + v128;
                int v120 = &__dst[v128 + 28];
              }
            }

            else
            {
              unint64_t v121 = v112 - 1;
              uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
              uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
              uint64_t v124 = a6[v123];
              unint64_t v125 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v126 = v125 + v124;
              *a10 = v126;
              *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
              unint64_t v119 = v126 + v122;
              *a10 = v126 + v122;
              int v120 = &__dst[v123];
            }
          }

          else
          {
            unint64_t v116 = v112 + 19;
            uint64_t v117 = a6[v112 + 19];
            unint64_t v118 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v119 = v118 + v117;
            *a10 = v119;
            int v120 = &__dst[v116];
          }

          v22 += v115;
          ++*v120;
          unint64_t v135 = (int)v114 + 3LL;
          unsigned int v136 = __clz(v135) ^ 0x1F;
          uint64_t v137 = v136 - 1;
          uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
          uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
          uint64_t v140 = a6[v139];
          unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
          *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
          unint64_t v141 = v119 + v140;
          *a10 = v141;
          *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
          *a10 = v141 + v137;
          ++__dst[v139];
          int v29 = v114;
        }

        int v28 = v22 + 2;
        unint64_t v23 = v22;
      }

      while ((unint64_t)(v22 + 2) <= v27);
LABEL_100:
      unint64_t v152 = v26 - v200;
      if (v152 >= 0x10000) {
        unint64_t v153 = 0x10000LL;
      }
      else {
        unint64_t v153 = v152;
      }
      unint64_t v197 = v152;
      if (v152)
      {
        unint64_t v154 = v153 + v198;
        if (v153 + v198 <= 0x100000)
        {
          unint64_t v200 = v153;
          unint64_t result = ShouldMergeBlock(v24, v153, (uint64_t)v203);
          unint64_t v24 = (unint64_t)v201;
          if ((_DWORD)result)
          {
            unint64_t v198 = v154;
            UpdateBits((v154 - 1), v193 + 3, a11);
            unint64_t v23 = v22;
            unint64_t v22 = v201;
            continue;
          }
        }
      }

      break;
    }

    if ((unint64_t)v22 >= v24)
    {
      unint64_t v22 = (unsigned __int8 *)v24;
      goto LABEL_113;
    }

    unint64_t v155 = v24 - (void)v22;
    if ((v24 - (unint64_t)v22) >> 1 > 0xC20)
    {
      unint64_t result = (unint64_t)v192;
      if (50 * (v22 - v192) > v155 || v190 < 0x3D5)
      {
        if (v155 > 0x5841)
        {
          uint64_t v183 = a6[63];
          unint64_t v184 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v185 = v184 + v183;
          *a10 = v185;
          *(void *)(a11 + (v185 >> 3)) = ((v155 - 22594) << (v185 & 7)) | *(unsigned __int8 *)(a11 + (v185 >> 3));
          unint64_t v181 = v185 + 24;
          uint64_t v182 = &__dst[63];
        }

        else
        {
          uint64_t v178 = a6[62];
          unint64_t v179 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v180 = v179 + v178;
          *a10 = v180;
          *(void *)(a11 + (v180 >> 3)) = ((v155 - 6210) << (v180 & 7)) | *(unsigned __int8 *)(a11 + (v180 >> 3));
          unint64_t v181 = v180 + 14;
          uint64_t v182 = &__dst[62];
        }

        unint64_t v160 = v197;
        ++*v182;
        *a10 = v181;
        do
        {
          int v186 = *v22++;
          uint64_t v187 = v203[v186];
          *(void *)(a11 + (v181 >> 3)) = ((unint64_t)(unsigned __int16)v202[v186] << (v181 & 7)) | *(unsigned __int8 *)(a11 + (v181 >> 3));
          v181 += v187;
          *a10 = v181;
          --v155;
        }

        while (v155);
        goto LABEL_124;
      }

      unint64_t v22 = (unsigned __int8 *)v24;
      unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, v24, v193, a10, a11);
LABEL_113:
      unint64_t v160 = v197;
      if (v197) {
        goto LABEL_125;
      }
      goto LABEL_141;
    }

    if (v155 > 5)
    {
      unint64_t v160 = v197;
      if (v155 > 0x81)
      {
        if (v155 > 0x841)
        {
          uint64_t v171 = a6[61];
          unint64_t v172 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v173 = v172 + v171;
          *a10 = v173;
          *(void *)(a11 + (v173 >> 3)) = ((v155 - 2114) << (v173 & 7)) | *(unsigned __int8 *)(a11 + (v173 >> 3));
          unint64_t v158 = v173 + 12;
          *a10 = v158;
          unint64_t v159 = &__dst[61];
        }

        else
        {
          uint64_t v167 = __clz(v155 - 66) ^ 0x1F;
          uint64_t v168 = a6[v167 + 50];
          unint64_t v169 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v167 + 50)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v170 = v169 + v168;
          *a10 = v170;
          *(void *)(a11 + (v170 >> 3)) = (((-1LL << v167) + v155 - 66) << (v170 & 7)) | *(unsigned __int8 *)(a11 + (v170 >> 3));
          unint64_t v158 = v170 + v167;
          *a10 = v170 + v167;
          unint64_t v159 = &__dst[v167 + 50];
        }
      }

      else
      {
        uint64_t v161 = (__clz(v155 - 2) ^ 0x1F) - 1;
        unint64_t v162 = (v155 - 2) >> v161;
        uint64_t v163 = (2 * v161) + v162 + 42;
        uint64_t v164 = a6[v163];
        unint64_t v165 = *a10;
        unint64_t result = *a10 & 7;
        *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v163) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
        unint64_t v166 = v165 + v164;
        *a10 = v166;
        *(void *)(a11 + (v166 >> 3)) = ((v155 - 2 - (v162 << v161)) << (v166 & 7)) | *(unsigned __int8 *)(a11 + (v166 >> 3));
        unint64_t v158 = v166 + v161;
        *a10 = v166 + v161;
        unint64_t v159 = &__dst[v163];
      }
    }

    else
    {
      uint64_t v156 = a6[v155 + 40];
      unint64_t v157 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v155 + 40)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v158 = v157 + v156;
      *a10 = v158;
      unint64_t v159 = &__dst[v155 + 40];
      unint64_t v160 = v197;
    }

    ++*v159;
    if ((unsigned __int8 *)v24 != v22)
    {
      if (v155 <= 1) {
        unint64_t v155 = 1LL;
      }
      do
      {
        int v174 = *v22++;
        uint64_t v175 = v203[v174];
        *(void *)(a11 + (v158 >> 3)) = ((unint64_t)(unsigned __int16)v202[v174] << (v158 & 7)) | *(unsigned __int8 *)(a11 + (v158 >> 3));
        v158 += v175;
        *a10 = v158;
        --v155;
      }

      while (v155);
    }

        ++*v51;
        if (v22 != v23)
        {
          if (v46 <= 1) {
            unint64_t v46 = 1LL;
          }
          do
          {
            int v65 = *v23++;
            uint64_t v66 = v203[v65];
            unint64_t result = v50 & 7;
            *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v202[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
            v50 += v66;
            *a10 = v50;
            --v46;
          }

          while (v46);
        }

        if (v29 == v37)
        {
          uint64_t v67 = a6[64];
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v68 = v50 + v67;
          double v69 = &__dst[64];
        }

        else
        {
          unint64_t v70 = v37 + 3LL;
          unsigned int v71 = __clz(v70) ^ 0x1F;
          uint64_t v72 = v71 - 1;
          uint64_t v73 = ((v70 >> (v71 - 1)) & 1 | 2) << (v71 - 1);
          uint64_t v74 = ((2 * v71 - 4) & 0xFFFFFFFE | (v70 >> (v71 - 1)) & 1) + 80;
          uint64_t v75 = a6[v74];
          unint64_t result = v50 >> 3;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v74) << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          unint64_t v76 = v50 + v75;
          *a10 = v76;
          *(void *)(a11 + (v76 >> 3)) = ((v70 - v73) << (v76 & 7)) | *(unsigned __int8 *)(a11 + (v76 >> 3));
          unint64_t v68 = v76 + v72;
          double v69 = &__dst[v74];
          int v29 = v37;
        }

        unint64_t v77 = v43 + 5;
        ++*v69;
        *a10 = v68;
        if (v43 + 5 > 0xB)
        {
          if (v77 > 0x47)
          {
            if (v77 > 0x87)
            {
              if (v77 > 0x847)
              {
                uint64_t v98 = a6[39];
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
                unint64_t v99 = v68 + v98;
                *a10 = v99;
                char v100 = v99 & 7;
                *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
                unint64_t v101 = v99 + 24;
                *a10 = v99 + 24;
                uint64_t v102 = a6[64];
                *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
                *a10 = v101 + v102;
                ++__dst[39];
              }

              else
              {
                unint64_t v92 = v43 - 67;
                uint64_t v93 = __clz(v92) ^ 0x1F;
                uint64_t v94 = a6[v93 + 28];
                unint64_t result = *(unsigned __int8 *)(a11 + (v68 >> 3));
                *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v68 & 7)) | result;
                unint64_t v95 = v68 + v94;
                *a10 = v95;
                *(void *)(a11 + (v95 >> 3)) = (((-1LL << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
                unint64_t v96 = v95 + v93;
                *a10 = v95 + v93;
                uint64_t v97 = a6[64];
                *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
                *a10 = v96 + v97;
                ++__dst[v93 + 28];
              }
            }

            else
            {
              unint64_t v86 = v43 - 3;
              uint64_t v87 = (v86 >> 5) + 30;
              uint64_t v88 = a6[v87];
              unint64_t result = v68 & 7;
              *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
              unint64_t v89 = v68 + v88;
              *a10 = v89;
              *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
              unint64_t v90 = v89 + 5;
              *a10 = v89 + 5;
              uint64_t v91 = a6[64];
              *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
              *a10 = v90 + v91;
              ++__dst[v87];
            }

            double v80 = &__dst[64];
          }

          else
          {
            unint64_t v81 = v43 - 3;
            uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
            uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
            uint64_t v84 = a6[v83];
            unint64_t result = v68 >> 3;
            *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
            unint64_t v85 = v68 + v84;
            *a10 = v85;
            *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
            *a10 = v85 + v82;
            double v80 = &__dst[v83];
          }
        }

        else
        {
          unint64_t v78 = v43 + 1;
          uint64_t v79 = a6[v78];
          *(void *)(a11 + (v68 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v68 & 7)) | *(unsigned __int8 *)(a11 + (v68 >> 3));
          *a10 = v68 + v79;
          double v80 = &__dst[v78];
        }

        v22 += v77;
        ++*v80;
        while (1)
        {
          unint64_t v103 = *(void *)(v22 - 3);
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * v103) >> 47) & 0x1FFFC)) = (_DWORD)v22 - (_DWORD)a2 - 3;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 8)) >> 47) & 0x1FFFC)) = (_DWORD)v22 - (_DWORD)a2 - 2;
          *(_DWORD *)(a5 + (((0x1E35A7BD000000LL * (v103 >> 16)) >> 47) & 0x1FFFC)) = (_DWORD)v22 - (_DWORD)a2 - 1;
          unint64_t v104 = ((0x1E35A7BD000000LL * (v103 >> 24)) >> 47) & 0x1FFFC;
          uint64_t v105 = *(int *)(a5 + v104);
          *(_DWORD *)(a5 + v104) = (_DWORD)v22 - (_DWORD)a2;
          uint64_t v106 = &a2[v105];
          if (*(_DWORD *)v22 != *(_DWORD *)&a2[v105] || v22[4] != v106[4]) {
            break;
          }
          int v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v24 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0LL;
LABEL_81:
            unint64_t v142 = v109 & 7;
            if (v142)
            {
              unint64_t v143 = v112 | v142;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v142)
                {
                  unint64_t v112 = v143;
                  break;
                }
              }
            }
          }

          else
          {
            uint64_t v110 = 0LL;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8LL;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8LL;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_81;
              }
            }

            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }

          uint64_t v114 = v22 - v106;
          if (v114 > 262128) {
            break;
          }
          unint64_t v115 = v112 + 5;
          if (v112 + 5 > 9)
          {
            if (v115 > 0x85)
            {
              if (v115 > 0x845)
              {
                uint64_t v132 = a6[39];
                unint64_t v133 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v134 = v133 + v132;
                *a10 = v134;
                *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                unint64_t v119 = v134 + 24;
                *a10 = v134 + 24;
                int v120 = &__dst[39];
              }

              else
              {
                unint64_t v127 = v112 - 65;
                uint64_t v128 = __clz(v127) ^ 0x1F;
                uint64_t v129 = a6[v128 + 28];
                unint64_t v130 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v131 = v130 + v129;
                *a10 = v131;
                *(void *)(a11 + (v131 >> 3)) = (((-1LL << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                unint64_t v119 = v131 + v128;
                *a10 = v131 + v128;
                int v120 = &__dst[v128 + 28];
              }
            }

            else
            {
              unint64_t v121 = v112 - 1;
              uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
              uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
              uint64_t v124 = a6[v123];
              unint64_t v125 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v126 = v125 + v124;
              *a10 = v126;
              *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
              unint64_t v119 = v126 + v122;
              *a10 = v126 + v122;
              int v120 = &__dst[v123];
            }
          }

          else
          {
            unint64_t v116 = v112 + 19;
            uint64_t v117 = a6[v112 + 19];
            unint64_t v118 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v119 = v118 + v117;
            *a10 = v119;
            int v120 = &__dst[v116];
          }

          v22 += v115;
          ++*v120;
          unint64_t v135 = (int)v114 + 3LL;
          unsigned int v136 = __clz(v135) ^ 0x1F;
          uint64_t v137 = v136 - 1;
          uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
          uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
          uint64_t v140 = a6[v139];
          unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
          *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
          unint64_t v141 = v119 + v140;
          *a10 = v141;
          *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
          *a10 = v141 + v137;
          ++__dst[v139];
          int v29 = v114;
        }

        int v28 = v22 + 2;
        unint64_t v23 = v22;
      }

      while ((unint64_t)(v22 + 2) <= v27);
LABEL_100:
      unint64_t v152 = v26 - v200;
      if (v152 >= 0x10000) {
        unint64_t v153 = 0x10000LL;
      }
      else {
        unint64_t v153 = v152;
      }
      unint64_t v197 = v152;
      if (v152)
      {
        unint64_t v154 = v153 + v198;
        if (v153 + v198 <= 0x100000)
        {
          unint64_t v200 = v153;
          unint64_t result = ShouldMergeBlock(v24, v153, (uint64_t)v203);
          unint64_t v24 = (unint64_t)v201;
          if ((_DWORD)result)
          {
            unint64_t v198 = v154;
            UpdateBits((v154 - 1), v193 + 3, a11);
            unint64_t v23 = v22;
            unint64_t v22 = v201;
            continue;
          }
        }
      }

      break;
    }

    if ((unint64_t)v22 >= v24)
    {
      unint64_t v22 = (unsigned __int8 *)v24;
      goto LABEL_113;
    }

    unint64_t v155 = v24 - (void)v22;
    if ((v24 - (unint64_t)v22) >> 1 > 0xC20)
    {
      unint64_t result = (unint64_t)v192;
      if (50 * (v22 - v192) > v155 || v190 < 0x3D5)
      {
        if (v155 > 0x5841)
        {
          uint64_t v183 = a6[63];
          unint64_t v184 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v185 = v184 + v183;
          *a10 = v185;
          *(void *)(a11 + (v185 >> 3)) = ((v155 - 22594) << (v185 & 7)) | *(unsigned __int8 *)(a11 + (v185 >> 3));
          unint64_t v181 = v185 + 24;
          uint64_t v182 = &__dst[63];
        }

        else
        {
          uint64_t v178 = a6[62];
          unint64_t v179 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v180 = v179 + v178;
          *a10 = v180;
          *(void *)(a11 + (v180 >> 3)) = ((v155 - 6210) << (v180 & 7)) | *(unsigned __int8 *)(a11 + (v180 >> 3));
          unint64_t v181 = v180 + 14;
          uint64_t v182 = &__dst[62];
        }

        unint64_t v160 = v197;
        ++*v182;
        *a10 = v181;
        do
        {
          int v186 = *v22++;
          uint64_t v187 = v203[v186];
          *(void *)(a11 + (v181 >> 3)) = ((unint64_t)(unsigned __int16)v202[v186] << (v181 & 7)) | *(unsigned __int8 *)(a11 + (v181 >> 3));
          v181 += v187;
          *a10 = v181;
          --v155;
        }

        while (v155);
        goto LABEL_124;
      }

      unint64_t v22 = (unsigned __int8 *)v24;
      unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, v24, v193, a10, a11);
LABEL_113:
      unint64_t v160 = v197;
      if (v197) {
        goto LABEL_125;
      }
      goto LABEL_141;
    }

    if (v155 > 5)
    {
      unint64_t v160 = v197;
      if (v155 > 0x81)
      {
        if (v155 > 0x841)
        {
          uint64_t v171 = a6[61];
          unint64_t v172 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v173 = v172 + v171;
          *a10 = v173;
          *(void *)(a11 + (v173 >> 3)) = ((v155 - 2114) << (v173 & 7)) | *(unsigned __int8 *)(a11 + (v173 >> 3));
          unint64_t v158 = v173 + 12;
          *a10 = v158;
          unint64_t v159 = &__dst[61];
        }

        else
        {
          uint64_t v167 = __clz(v155 - 66) ^ 0x1F;
          uint64_t v168 = a6[v167 + 50];
          unint64_t v169 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v167 + 50)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v170 = v169 + v168;
          *a10 = v170;
          *(void *)(a11 + (v170 >> 3)) = (((-1LL << v167) + v155 - 66) << (v170 & 7)) | *(unsigned __int8 *)(a11 + (v170 >> 3));
          unint64_t v158 = v170 + v167;
          *a10 = v170 + v167;
          unint64_t v159 = &__dst[v167 + 50];
        }
      }

      else
      {
        uint64_t v161 = (__clz(v155 - 2) ^ 0x1F) - 1;
        unint64_t v162 = (v155 - 2) >> v161;
        uint64_t v163 = (2 * v161) + v162 + 42;
        uint64_t v164 = a6[v163];
        unint64_t v165 = *a10;
        unint64_t result = *a10 & 7;
        *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v163) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
        unint64_t v166 = v165 + v164;
        *a10 = v166;
        *(void *)(a11 + (v166 >> 3)) = ((v155 - 2 - (v162 << v161)) << (v166 & 7)) | *(unsigned __int8 *)(a11 + (v166 >> 3));
        unint64_t v158 = v166 + v161;
        *a10 = v166 + v161;
        unint64_t v159 = &__dst[v163];
      }
    }

    else
    {
      uint64_t v156 = a6[v155 + 40];
      unint64_t v157 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v155 + 40)) << (*(_BYTE *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v158 = v157 + v156;
      *a10 = v158;
      unint64_t v159 = &__dst[v155 + 40];
      unint64_t v160 = v197;
    }

    ++*v159;
    if ((unsigned __int8 *)v24 != v22)
    {
      if (v155 <= 1) {
        unint64_t v155 = 1LL;
      }
      do
      {
        int v174 = *v22++;
        uint64_t v175 = v203[v174];
        *(void *)(a11 + (v158 >> 3)) = ((unint64_t)(unsigned __int16)v202[v174] << (v158 & 7)) | *(unsigned __int8 *)(a11 + (v158 >> 3));
        v158 += v175;
        *a10 = v158;
        --v155;
      }

      while (v155);
    }

    if (v33 < v31)
    {
      unint64_t v18 = result + 1;
      *(_BYTE *)(a1 + result) = *(_BYTE *)(a3 + v12++);
      goto LABEL_69;
    }

    unint64_t v27 = (v39 - v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    int v28 = v27 + 4;
    int v29 = *(_DWORD *)&v17[v27];
    uint64_t v30 = v28 + v16;
    if (v28 + v16 + 12 > a4) {
      return 0LL;
    }
    uint64_t v31 = (int *)(a3 + v30);
    uint64_t v32 = *v31;
    else {
      return 0LL;
    }
  }

  return result;
}

LABEL_124:
    unint64_t v22 = (unsigned __int8 *)v24;
    if (!v160)
    {
LABEL_141:
      if (!a4)
      {
        *a9 = 0;
        *a8 = 0LL;
        return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
      }

      return result;
    }

    unint64_t v22 = (unsigned __int8 *)v24;
    if (!v160)
    {
LABEL_141:
      if (!a4)
      {
        *a9 = 0;
        *a8 = 0LL;
        return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
      }

      return result;
    }

    unint64_t v22 = (unsigned __int8 *)v24;
    if (!v160)
    {
LABEL_141:
      if (!a4)
      {
        *a9 = 0;
        *a8 = 0LL;
        return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
      }

      return result;
    }

    unint64_t v22 = (unsigned __int8 *)v24;
    if (!v160)
    {
LABEL_141:
      if (!a4)
      {
        *a9 = 0;
        *a8 = 0LL;
        return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
      }

      return result;
    }

LABEL_125:
    if (v160 >= 0x18000) {
      unint64_t v176 = 98304LL;
    }
    else {
      unint64_t v176 = v160;
    }
    unint64_t v197 = v160;
    unint64_t v199 = v176;
    unint64_t v193 = *a10;
    BrotliStoreMetaBlockHeader(v176, 0, a10, a11);
    unint64_t v177 = *a10;
    *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
    *a10 = v177 + 13;
    unint64_t result = BuildAndStoreLiteralPrefixCode(v191, v22, v199, v203, (uint64_t)v202, a10, a11);
    unint64_t v14 = v199;
    if (!*(_DWORD *)(v191 + 24))
    {
      unint64_t v190 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      continue;
    }

    return result;
  }

    if (v160 >= 0x18000) {
      unint64_t v176 = 98304LL;
    }
    else {
      unint64_t v176 = v160;
    }
    unint64_t v197 = v160;
    unint64_t v199 = v176;
    unint64_t v193 = *a10;
    BrotliStoreMetaBlockHeader(v176, 0, a10, a11);
    unint64_t v177 = *a10;
    *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
    *a10 = v177 + 13;
    unint64_t result = BuildAndStoreLiteralPrefixCode(v191, v22, v199, v203, (uint64_t)v202, a10, a11);
    unint64_t v14 = v199;
    if (!*(_DWORD *)(v191 + 24))
    {
      unint64_t v190 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      continue;
    }

    return result;
  }

    if (v160 >= 0x18000) {
      unint64_t v176 = 98304LL;
    }
    else {
      unint64_t v176 = v160;
    }
    unint64_t v197 = v160;
    unint64_t v199 = v176;
    unint64_t v193 = *a10;
    BrotliStoreMetaBlockHeader(v176, 0, a10, a11);
    unint64_t v177 = *a10;
    *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
    *a10 = v177 + 13;
    unint64_t result = BuildAndStoreLiteralPrefixCode(v191, v22, v199, v203, (uint64_t)v202, a10, a11);
    unint64_t v14 = v199;
    if (!*(_DWORD *)(v191 + 24))
    {
      unint64_t v190 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      continue;
    }

    return result;
  }

    if (v160 >= 0x18000) {
      unint64_t v176 = 98304LL;
    }
    else {
      unint64_t v176 = v160;
    }
    unint64_t v197 = v160;
    unint64_t v199 = v176;
    unint64_t v193 = *a10;
    BrotliStoreMetaBlockHeader(v176, 0, a10, a11);
    unint64_t v177 = *a10;
    *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
    *a10 = v177 + 13;
    unint64_t result = BuildAndStoreLiteralPrefixCode(v191, v22, v199, v203, (uint64_t)v202, a10, a11);
    unint64_t v14 = v199;
    if (!*(_DWORD *)(v191 + 24))
    {
      unint64_t v190 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      continue;
    }

    return result;
  }

unint64_t BrotliCompressFragmentFastImpl11( unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, _BYTE *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v205 = *MEMORY[0x1895F89C0];
  unint64_t v197 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304LL;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v193 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v203, (uint64_t)v202, a10, a11);
  unint64_t v191 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v190 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0LL;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8LL;
    }

    while (v21 < *a8);
    v18 += v20;
  }

  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
  while (2)
  {
    unint64_t v198 = v14;
    unint64_t v200 = v14;
    unint64_t v23 = v22;
    uint64_t v192 = v22;
    while (2)
    {
      unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
      unint64_t v24 = (unint64_t)&v22[v200];
      uint64_t v201 = &v22[v200];
      if (v200 < 0x10)
      {
        unint64_t v22 = v23;
        unint64_t v26 = v197;
        goto LABEL_100;
      }

      uint64_t v25 = v200 - 5;
      unint64_t v26 = v197;
      if (v200 - 5 >= v197 - 16) {
        uint64_t v25 = v197 - 16;
      }
      if (v25 < 2)
      {
LABEL_99:
        unint64_t v22 = v23;
        goto LABEL_100;
      }

      unint64_t v27 = (unint64_t)&v22[v25];
      int v28 = v22 + 2;
      int v29 = -1;
      unint64_t v194 = v22;
      do
      {
        uint64_t v31 = *(void *)++v22;
        uint64_t v30 = v31;
        for (unsigned int i = 33; ; ++i)
        {
          int v33 = v28;
          unint64_t v34 = (unint64_t)(0x1E35A7BD000000LL * v30) >> 53;
          uint64_t v30 = *(void *)v33;
          unint64_t v35 = &v22[-v29];
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
            break;
          }
          unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
          *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
            goto LABEL_24;
          }
LABEL_28:
          int v28 = &v33[i >> 5];
          unint64_t v22 = v33;
        }

        *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
LABEL_24:
        int v37 = (_DWORD)v22 - (_DWORD)v35;
        if (v22 - v35 > 262128) {
          goto LABEL_28;
        }
        size_t v38 = v35 + 5;
        unsigned int v39 = v22 + 5;
        unint64_t v40 = v24 - (void)v22 - 5;
        if (v40 < 8)
        {
          unint64_t v43 = 0LL;
LABEL_89:
          unint64_t v144 = v40 & 7;
          if (v144)
          {
            unint64_t v145 = v43 | v144;
            while (v38[v43] == *v39)
            {
              ++v39;
              ++v43;
              if (!--v144)
              {
                unint64_t v43 = v145;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v41 = 0LL;
          unint64_t v42 = v40 >> 3;
          unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v44 = *(void *)&v39[v41];
            uint64_t v45 = *(void *)&v38[v41];
            if (v44 != v45) {
              break;
            }
            v41 += 8LL;
            if (!--v42)
            {
              v39 += v40 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_89;
            }
          }

          unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }

        unint64_t v46 = v22 - v23;
        if ((unint64_t)(v22 - v23) >> 1 > 0xC20)
        {
          if (50 * (v23 - v192) > v46 || v190 < 0x3D5)
          {
            if (v46 > 0x5841)
            {
              uint64_t v149 = a6[63];
              unint64_t v150 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v151 = v150 + v149;
              *a10 = v151;
              *(void *)(a11 + (v151 >> 3)) = ((v46 - 22594) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
              unint64_t v50 = v151 + 24;
              *a10 = v50;
              uint64_t v51 = &__dst[63];
            }

            else
            {
              uint64_t v146 = a6[62];
              unint64_t v147 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v148 = v147 + v146;
              *a10 = v148;
              *(void *)(a11 + (v148 >> 3)) = ((v46 - 6210) << (v148 & 7)) | *(unsigned __int8 *)(a11 + (v148 >> 3));
              unint64_t v50 = v148 + 14;
              *a10 = v50;
              uint64_t v51 = &__dst[62];
            }

            goto LABEL_44;
          }

          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, (uint64_t)v22, v193, a10, a11);
          unint64_t v160 = &v194[v197] - v22;
          if (v160) {
            goto LABEL_125;
          }
          goto LABEL_141;
        }

        if (v46 > 5)
        {
          if (v46 > 0x81)
          {
            if (v46 > 0x841)
            {
              uint64_t v62 = a6[61];
              unint64_t v63 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v64 = v63 + v62;
              *a10 = v64;
              *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
              unint64_t v50 = v64 + 12;
              *a10 = v50;
              uint64_t v51 = &__dst[61];
            }

            else
            {
              uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
              uint64_t v59 = a6[v58 + 50];
              unint64_t v60 = *a10;
              unint64_t v24 = (unint64_t)v201;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v61 = v60 + v59;
              *a10 = v61;
              unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
              *(void *)(a11 + (v61 >> 3)) = (((-1LL << v58) + v46 - 66) << (v61 & 7)) | result;
              unint64_t v50 = v61 + v58;
              *a10 = v61 + v58;
              uint64_t v51 = &__dst[v58 + 50];
            }
          }

          else
          {
            uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
            unint64_t v53 = (v46 - 2) >> v52;
            uint64_t v54 = (2 * v52) + v53 + 42;
            uint64_t v55 = a6[v54];
            unint64_t v56 = *a10;
            unint64_t v24 = (unint64_t)v201;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v57 = v56 + v55;
            *a10 = v57;
            unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
            *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
            unint64_t v50 = v57 + v52;
            *a10 = v57 + v52;
            uint64_t v51 = &__dst[v54];
          }
        }

        else
        {
          uint64_t v47 = a6[v46 + 40];
          unint64_t v48 = *a10;
          unint64_t v49 = *a10 >> 3;
          unint64_t result = *(unsigned __int8 *)(a11 + v49);
          *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(_BYTE *)a10 & 7)) | result;
          unint64_t v50 = v48 + v47;
          *a10 = v50;
          uint64_t v51 = &__dst[v46 + 40];
        }

unint64_t BrotliCompressFragmentFastImpl13( unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, _BYTE *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v205 = *MEMORY[0x1895F89C0];
  unint64_t v197 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304LL;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v193 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v203, (uint64_t)v202, a10, a11);
  unint64_t v191 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v190 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0LL;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8LL;
    }

    while (v21 < *a8);
    v18 += v20;
  }

  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
  while (2)
  {
    unint64_t v198 = v14;
    unint64_t v200 = v14;
    unint64_t v23 = v22;
    uint64_t v192 = v22;
    while (2)
    {
      unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
      unint64_t v24 = (unint64_t)&v22[v200];
      uint64_t v201 = &v22[v200];
      if (v200 < 0x10)
      {
        unint64_t v22 = v23;
        unint64_t v26 = v197;
        goto LABEL_100;
      }

      uint64_t v25 = v200 - 5;
      unint64_t v26 = v197;
      if (v200 - 5 >= v197 - 16) {
        uint64_t v25 = v197 - 16;
      }
      if (v25 < 2)
      {
LABEL_99:
        unint64_t v22 = v23;
        goto LABEL_100;
      }

      unint64_t v27 = (unint64_t)&v22[v25];
      int v28 = v22 + 2;
      int v29 = -1;
      unint64_t v194 = v22;
      do
      {
        uint64_t v31 = *(void *)++v22;
        uint64_t v30 = v31;
        for (unsigned int i = 33; ; ++i)
        {
          int v33 = v28;
          unint64_t v34 = (unint64_t)(0x1E35A7BD000000LL * v30) >> 51;
          uint64_t v30 = *(void *)v33;
          unint64_t v35 = &v22[-v29];
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
            break;
          }
          unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
          *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
            goto LABEL_24;
          }
LABEL_28:
          int v28 = &v33[i >> 5];
          unint64_t v22 = v33;
        }

        *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
LABEL_24:
        int v37 = (_DWORD)v22 - (_DWORD)v35;
        if (v22 - v35 > 262128) {
          goto LABEL_28;
        }
        size_t v38 = v35 + 5;
        unsigned int v39 = v22 + 5;
        unint64_t v40 = v24 - (void)v22 - 5;
        if (v40 < 8)
        {
          unint64_t v43 = 0LL;
LABEL_89:
          unint64_t v144 = v40 & 7;
          if (v144)
          {
            unint64_t v145 = v43 | v144;
            while (v38[v43] == *v39)
            {
              ++v39;
              ++v43;
              if (!--v144)
              {
                unint64_t v43 = v145;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v41 = 0LL;
          unint64_t v42 = v40 >> 3;
          unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v44 = *(void *)&v39[v41];
            uint64_t v45 = *(void *)&v38[v41];
            if (v44 != v45) {
              break;
            }
            v41 += 8LL;
            if (!--v42)
            {
              v39 += v40 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_89;
            }
          }

          unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }

        unint64_t v46 = v22 - v23;
        if ((unint64_t)(v22 - v23) >> 1 > 0xC20)
        {
          if (50 * (v23 - v192) > v46 || v190 < 0x3D5)
          {
            if (v46 > 0x5841)
            {
              uint64_t v149 = a6[63];
              unint64_t v150 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v151 = v150 + v149;
              *a10 = v151;
              *(void *)(a11 + (v151 >> 3)) = ((v46 - 22594) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
              unint64_t v50 = v151 + 24;
              *a10 = v50;
              uint64_t v51 = &__dst[63];
            }

            else
            {
              uint64_t v146 = a6[62];
              unint64_t v147 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v148 = v147 + v146;
              *a10 = v148;
              *(void *)(a11 + (v148 >> 3)) = ((v46 - 6210) << (v148 & 7)) | *(unsigned __int8 *)(a11 + (v148 >> 3));
              unint64_t v50 = v148 + 14;
              *a10 = v50;
              uint64_t v51 = &__dst[62];
            }

            goto LABEL_44;
          }

          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, (uint64_t)v22, v193, a10, a11);
          unint64_t v160 = &v194[v197] - v22;
          if (v160) {
            goto LABEL_125;
          }
          goto LABEL_141;
        }

        if (v46 > 5)
        {
          if (v46 > 0x81)
          {
            if (v46 > 0x841)
            {
              uint64_t v62 = a6[61];
              unint64_t v63 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v64 = v63 + v62;
              *a10 = v64;
              *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
              unint64_t v50 = v64 + 12;
              *a10 = v50;
              uint64_t v51 = &__dst[61];
            }

            else
            {
              uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
              uint64_t v59 = a6[v58 + 50];
              unint64_t v60 = *a10;
              unint64_t v24 = (unint64_t)v201;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v61 = v60 + v59;
              *a10 = v61;
              unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
              *(void *)(a11 + (v61 >> 3)) = (((-1LL << v58) + v46 - 66) << (v61 & 7)) | result;
              unint64_t v50 = v61 + v58;
              *a10 = v61 + v58;
              uint64_t v51 = &__dst[v58 + 50];
            }
          }

          else
          {
            uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
            unint64_t v53 = (v46 - 2) >> v52;
            uint64_t v54 = (2 * v52) + v53 + 42;
            uint64_t v55 = a6[v54];
            unint64_t v56 = *a10;
            unint64_t v24 = (unint64_t)v201;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v57 = v56 + v55;
            *a10 = v57;
            unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
            *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
            unint64_t v50 = v57 + v52;
            *a10 = v57 + v52;
            uint64_t v51 = &__dst[v54];
          }
        }

        else
        {
          uint64_t v47 = a6[v46 + 40];
          unint64_t v48 = *a10;
          unint64_t v49 = *a10 >> 3;
          unint64_t result = *(unsigned __int8 *)(a11 + v49);
          *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(_BYTE *)a10 & 7)) | result;
          unint64_t v50 = v48 + v47;
          *a10 = v50;
          uint64_t v51 = &__dst[v46 + 40];
        }

unint64_t BrotliCompressFragmentFastImpl15( unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, _BYTE *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v205 = *MEMORY[0x1895F89C0];
  unint64_t v197 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304LL;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v193 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v203, (uint64_t)v202, a10, a11);
  unint64_t v191 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v190 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0LL;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8LL;
    }

    while (v21 < *a8);
    v18 += v20;
  }

  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
  while (2)
  {
    unint64_t v198 = v14;
    unint64_t v200 = v14;
    unint64_t v23 = v22;
    uint64_t v192 = v22;
    while (2)
    {
      unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
      unint64_t v24 = (unint64_t)&v22[v200];
      uint64_t v201 = &v22[v200];
      if (v200 < 0x10)
      {
        unint64_t v22 = v23;
        unint64_t v26 = v197;
        goto LABEL_100;
      }

      uint64_t v25 = v200 - 5;
      unint64_t v26 = v197;
      if (v200 - 5 >= v197 - 16) {
        uint64_t v25 = v197 - 16;
      }
      if (v25 < 2)
      {
LABEL_99:
        unint64_t v22 = v23;
        goto LABEL_100;
      }

      unint64_t v27 = (unint64_t)&v22[v25];
      int v28 = v22 + 2;
      int v29 = -1;
      unint64_t v194 = v22;
      do
      {
        uint64_t v31 = *(void *)++v22;
        uint64_t v30 = v31;
        for (unsigned int i = 33; ; ++i)
        {
          int v33 = v28;
          unint64_t v34 = (unint64_t)(0x1E35A7BD000000LL * v30) >> 49;
          uint64_t v30 = *(void *)v33;
          unint64_t v35 = &v22[-v29];
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
            break;
          }
          unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
          *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
          if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
            goto LABEL_24;
          }
LABEL_28:
          int v28 = &v33[i >> 5];
          unint64_t v22 = v33;
        }

        *(_DWORD *)(a5 + 4 * v34) = (_DWORD)v22 - (_DWORD)a2;
LABEL_24:
        int v37 = (_DWORD)v22 - (_DWORD)v35;
        if (v22 - v35 > 262128) {
          goto LABEL_28;
        }
        size_t v38 = v35 + 5;
        unsigned int v39 = v22 + 5;
        unint64_t v40 = v24 - (void)v22 - 5;
        if (v40 < 8)
        {
          unint64_t v43 = 0LL;
LABEL_89:
          unint64_t v144 = v40 & 7;
          if (v144)
          {
            unint64_t v145 = v43 | v144;
            while (v38[v43] == *v39)
            {
              ++v39;
              ++v43;
              if (!--v144)
              {
                unint64_t v43 = v145;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v41 = 0LL;
          unint64_t v42 = v40 >> 3;
          unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v44 = *(void *)&v39[v41];
            uint64_t v45 = *(void *)&v38[v41];
            if (v44 != v45) {
              break;
            }
            v41 += 8LL;
            if (!--v42)
            {
              v39 += v40 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_89;
            }
          }

          unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }

        unint64_t v46 = v22 - v23;
        if ((unint64_t)(v22 - v23) >> 1 > 0xC20)
        {
          if (50 * (v23 - v192) > v46 || v190 < 0x3D5)
          {
            if (v46 > 0x5841)
            {
              uint64_t v149 = a6[63];
              unint64_t v150 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v151 = v150 + v149;
              *a10 = v151;
              *(void *)(a11 + (v151 >> 3)) = ((v46 - 22594) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
              unint64_t v50 = v151 + 24;
              *a10 = v50;
              uint64_t v51 = &__dst[63];
            }

            else
            {
              uint64_t v146 = a6[62];
              unint64_t v147 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v148 = v147 + v146;
              *a10 = v148;
              *(void *)(a11 + (v148 >> 3)) = ((v46 - 6210) << (v148 & 7)) | *(unsigned __int8 *)(a11 + (v148 >> 3));
              unint64_t v50 = v148 + 14;
              *a10 = v50;
              uint64_t v51 = &__dst[62];
            }

            goto LABEL_44;
          }

          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v192, (uint64_t)v22, v193, a10, a11);
          unint64_t v160 = &v194[v197] - v22;
          if (v160) {
            goto LABEL_125;
          }
          goto LABEL_141;
        }

        if (v46 > 5)
        {
          if (v46 > 0x81)
          {
            if (v46 > 0x841)
            {
              uint64_t v62 = a6[61];
              unint64_t v63 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v64 = v63 + v62;
              *a10 = v64;
              *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
              unint64_t v50 = v64 + 12;
              *a10 = v50;
              uint64_t v51 = &__dst[61];
            }

            else
            {
              uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
              uint64_t v59 = a6[v58 + 50];
              unint64_t v60 = *a10;
              unint64_t v24 = (unint64_t)v201;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v61 = v60 + v59;
              *a10 = v61;
              unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
              *(void *)(a11 + (v61 >> 3)) = (((-1LL << v58) + v46 - 66) << (v61 & 7)) | result;
              unint64_t v50 = v61 + v58;
              *a10 = v61 + v58;
              uint64_t v51 = &__dst[v58 + 50];
            }
          }

          else
          {
            uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
            unint64_t v53 = (v46 - 2) >> v52;
            uint64_t v54 = (2 * v52) + v53 + 42;
            uint64_t v55 = a6[v54];
            unint64_t v56 = *a10;
            unint64_t v24 = (unint64_t)v201;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v57 = v56 + v55;
            *a10 = v57;
            unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
            *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
            unint64_t v50 = v57 + v52;
            *a10 = v57 + v52;
            uint64_t v51 = &__dst[v54];
          }
        }

        else
        {
          uint64_t v47 = a6[v46 + 40];
          unint64_t v48 = *a10;
          unint64_t v49 = *a10 >> 3;
          unint64_t result = *(unsigned __int8 *)(a11 + v49);
          *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(_BYTE *)a10 & 7)) | result;
          unint64_t v50 = v48 + v47;
          *a10 = v50;
          uint64_t v51 = &__dst[v46 + 40];
        }

void *EmitUncompressedMetaBlock( const void *a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  size_t v8 = a2 - (void)a1;
  *(_BYTE *)(a5 + (a3 >> 3)) &= ~(-1 << (a3 & 7));
  *a4 = a3;
  BrotliStoreMetaBlockHeader(a2 - (void)a1, 1u, a4, a5);
  unint64_t v9 = (*(_DWORD *)a4 + 7) & 0xFFFFFFF8;
  *a4 = v9;
  unint64_t result = memcpy((void *)(a5 + (v9 >> 3)), a1, v8);
  unint64_t v11 = *a4 + 8 * v8;
  *a4 = v11;
  *(_BYTE *)(a5 + (v11 >> 3)) = 0;
  return result;
}

unint64_t BrotliStoreMetaBlockHeader( unint64_t result, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = *(unsigned __int8 *)(a4 + (*a3 >> 3));
  *a3 = v4 + 1;
  uint64_t v5 = 5LL;
  if (result >= 0x100001) {
    uint64_t v5 = 6LL;
  }
  if (result <= 0x10000) {
    uint64_t v5 = 4LL;
  }
  *(void *)(a4 + ((v4 + 1) >> 3)) = ((v5 - 4) << ((v4 + 1) & 7)) | *(unsigned __int8 *)(a4 + ((v4 + 1) >> 3));
  unint64_t v6 = v4 + 3;
  *a3 = v6;
  *(void *)(a4 + (v6 >> 3)) = ((result - 1) << (v6 & 7)) | *(unsigned __int8 *)(a4 + (v6 >> 3));
  unint64_t v7 = v6 + 4 * v5;
  *a3 = v7;
  *(void *)(a4 + (v7 >> 3)) = ((unint64_t)a2 << (v7 & 7)) | *(unsigned __int8 *)(a4 + (v7 >> 3));
  *a3 = v7 + 1;
  return result;
}

unint64_t BuildAndStoreLiteralPrefixCode( unint64_t a1, unsigned __int8 *a2, unint64_t a3, _BYTE *a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  bzero(v35, 0x400uLL);
  if (a3 >= 0x8000)
  {
    unint64_t v23 = 0LL;
    do
    {
      ++v35[a2[v23]];
      v23 += 29LL;
    }

    while (v23 < a3);
    uint64_t v24 = 0LL;
    uint64_t v25 = ((a3 + 28) * (unsigned __int128)0x1A7B9611A7B9611BuLL) >> 64;
    int64x2_t v17 = 0uLL;
    int64x2_t v18 = (int64x2_t)((v25 + ((a3 + 28 - v25) >> 1)) >> 4);
    v26.i64[0] = 0xB0000000BLL;
    v26.i64[1] = 0xB0000000BLL;
    do
    {
      int32x4_t v27 = *(int32x4_t *)&v35[v24];
      int32x4_t v28 = (int32x4_t)vminq_u32((uint32x4_t)v27, v26);
      unsigned __int128 v29 = *(_OWORD *)&vaddq_s32(v28, v28) | __PAIR128__(0x100000001LL, 0x100000001LL);
      *(int32x4_t *)&v35[v24] = vaddq_s32((int32x4_t)v29, v27);
      int64x2_t v17 = (int64x2_t)vaddw_high_u32((uint64x2_t)v17, (uint32x4_t)v29);
      int64x2_t v18 = (int64x2_t)vaddw_u32((uint64x2_t)v18, *(uint32x2_t *)&v29);
      v24 += 4LL;
    }

    while (v24 != 256);
  }

  else
  {
    if (a3)
    {
      unint64_t v14 = a3;
      do
      {
        int v15 = *a2++;
        ++v35[v15];
        --v14;
      }

      while (v14);
    }

    uint64_t v16 = 0LL;
    int64x2_t v17 = 0uLL;
    int64x2_t v18 = (int64x2_t)a3;
    v19.i64[0] = 0xB0000000BLL;
    v19.i64[1] = 0xB0000000BLL;
    do
    {
      int32x4_t v20 = *(int32x4_t *)&v35[v16];
      int32x4_t v21 = (int32x4_t)vminq_u32((uint32x4_t)v20, v19);
      int32x4_t v22 = vaddq_s32(v21, v21);
      *(int32x4_t *)&v35[v16] = vaddq_s32(v22, v20);
      int64x2_t v17 = (int64x2_t)vaddw_high_u32((uint64x2_t)v17, (uint32x4_t)v22);
      int64x2_t v18 = (int64x2_t)vaddw_u32((uint64x2_t)v18, *(uint32x2_t *)v22.i8);
      v16 += 4LL;
    }

    while (v16 != 256);
  }

  unint64_t v30 = vaddvq_s64(vaddq_s64(v18, v17));
  BrotliBuildAndStoreHuffmanTreeFast(a1, (uint64_t)v35, v30, 8LL, a4, a5, a6, a7);
  if (*(_DWORD *)(a1 + 24)) {
    return 0LL;
  }
  uint64_t v32 = 0LL;
  for (uint64_t i = 0LL; i != 256; ++i)
  {
    int v34 = v35[i];
    if (v34) {
      v32 += v34 * a4[i];
    }
  }

  return 125 * v32 / v30;
}

BOOL ShouldMergeBlock(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v16[256] = *MEMORY[0x1895F89C0];
  bzero(v16, 0x800uLL);
  unint64_t v7 = 0LL;
  if (!a2) {
    goto LABEL_4;
  }
  do
  {
    ++v16[*(unsigned __int8 *)(a1 + v7)];
    v7 += 43LL;
  }

  while (v7 < a2);
  unint64_t v7 = (a2 + 42) / 0x2B;
  if ((a2 + 42) >> 8 > 0x2A)
  {
    double v9 = (double)v7;
    double v8 = log2((double)v7);
  }

  else
  {
LABEL_4:
    double v8 = kBrotliLog2Table[v7];
    double v9 = (double)v7;
  }

  uint64_t v10 = 0LL;
  double v11 = (v8 + 0.5) * v9 + 200.0;
  do
  {
    unint64_t v12 = v16[v10];
    double v13 = (double)v12;
    LOBYTE(v3) = *(_BYTE *)(a3 + v10);
    if (v12 > 0xFF) {
      double v14 = log2((double)v12);
    }
    else {
      double v14 = kBrotliLog2Table[v12];
    }
    double v11 = v11 - v13 * (v14 + (double)v3);
    ++v10;
  }

  while (v10 != 256);
  return v11 >= 0.0;
}

uint64_t UpdateBits(uint64_t result, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = 20LL;
  do
  {
    unint64_t v4 = 8 - (a2 & 7);
    if (v3 < v4) {
      unint64_t v4 = v3;
    }
    *(_BYTE *)(a3 + (a2 >> 3)) = ((-1 << (v4 + (a2 & 7))) | ~(-1 << (a2 & 7))) & *(_BYTE *)(a3 + (a2 >> 3)) | ((result & ~(-1 << v4)) << (a2 & 7));
    unint64_t result = result >> v4;
    a2 += v4;
    v3 -= v4;
  }

  while (v3);
  return result;
}

unint64_t BuildAndStoreCommandPrefixCode( uint64_t a1, uint64_t a2, _OWORD *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  bzero(v34, 0x280uLL);
  BrotliCreateHuffmanTree(a1, 64LL, 15, (uint64_t)v35, a2);
  BrotliCreateHuffmanTree(a1 + 256, 64LL, 14, (uint64_t)v35, a2 + 64);
  *(_OWORD *)unint64_t v30 = *(_OWORD *)a2;
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)&v30[16] = *(void *)(a2 + 16);
  *(void *)&__int128 v31 = v11;
  uint64_t v13 = *(void *)(a2 + 48);
  *((void *)&v31 + 1) = v10;
  *(void *)&__int128 v32 = v13;
  int v15 = (char *)(a2 + 56);
  uint64_t v14 = *(void *)(a2 + 56);
  *((void *)&v32 + 1) = v12;
  uint64_t v33 = v14;
  BrotliConvertBitDepthsToSymbols(v30, 64LL, (uint64_t)v29);
  __int128 v16 = v29[1];
  *a3 = v29[0];
  a3[1] = v16;
  __int128 v17 = v29[3];
  __int128 v18 = v29[4];
  __int128 v19 = v29[5];
  a3[2] = v29[2];
  a3[3] = v18;
  __int128 v20 = v29[7];
  a3[4] = v29[6];
  a3[5] = v17;
  a3[6] = v19;
  a3[7] = v20;
  BrotliConvertBitDepthsToSymbols((unsigned __int8 *)(a2 + 64), 64LL, (uint64_t)(a3 + 8));
  __int128 v32 = 0u;
  __int128 v31 = 0u;
  *(_OWORD *)&v30[8] = 0u;
  uint64_t v21 = *(void *)a2;
  uint64_t v22 = *(void *)(a2 + 8);
  uint64_t v33 = 0LL;
  v34[0] = v22;
  *(void *)unint64_t v30 = v21;
  uint64_t v23 = *(void *)(a2 + 24);
  v34[8] = *(void *)(a2 + 16);
  uint64_t v24 = *(void *)(a2 + 32);
  uint64_t v25 = 256LL;
  v34[16] = v23;
  v34[40] = v24;
  do
  {
    uint32x4_t v26 = &v30[v25];
    *(v26 - 128) = *(v15 - 16);
    *uint32x4_t v26 = *(v15 - 8);
    char v27 = *v15++;
    v26[192] = v27;
    v25 += 8LL;
  }

  while (v25 != 320);
  BrotliStoreHuffmanTree((uint64_t)v30, 0x2C0uLL, (uint64_t)v35, a4, a5);
  return BrotliStoreHuffmanTree(a2 + 64, 0x40uLL, (uint64_t)v35, a4, a5);
}

uint64_t lzvn_decode_scratch_size()
{
  return 0LL;
}

uint64_t BrotliInitMemoryManager( uint64_t result, void *(*a2)(int a1, size_t __size), void (*a3)(int a1, void *a2), uint64_t a4)
{
  unint64_t v4 = BrotliDefaultAllocFunc;
  if (a2) {
    unint64_t v4 = a2;
  }
  uint64_t v5 = BrotliDefaultFreeFunc;
  if (a2) {
    uint64_t v5 = a3;
  }
  *(void *)unint64_t result = v4;
  *(void *)(result + 8) = v5;
  if (a2) {
    uint64_t v6 = a4;
  }
  else {
    uint64_t v6 = 0LL;
  }
  *(void *)(result + 16) = v6;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 40) = 0LL;
  *(void *)(result + 48) = 0LL;
  *(void *)(result + 32) = 0LL;
  return result;
}

uint64_t BrotliAllocate(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))a1)(*(void *)(a1 + 16));
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3 == 64)
    {
      CollectGarbagePointers((unint64_t *)a1);
      uint64_t v3 = *(void *)(a1 + 40);
    }

    *(void *)(a1 + 40) = v3 + 1;
    *(void *)(a1 + 8 * v3 + 1080) = v2;
  }

  else
  {
    *(_DWORD *)(a1 + 24) = 1;
  }

  return v2;
}

uint64_t CollectGarbagePointers(unint64_t *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 7);
  uint64_t v3 = a1 + 135;
  SortPointers((uint64_t)(a1 + 135), a1[5]);
  SortPointers((uint64_t)(a1 + 199), a1[6]);
  uint64_t result = Annihilate((uint64_t)v3, a1[5], (uint64_t)(a1 + 199), a1[6]);
  unint64_t v5 = a1[6];
  unint64_t v6 = a1[5] - result;
  a1[5] = v6;
  a1[6] = v5 - result;
  if (v5 != result)
  {
    uint64_t result = Annihilate(v2, a1[4], (uint64_t)(a1 + 199), v5 - result);
    unint64_t v6 = a1[5];
    a1[4] -= result;
    a1[6] -= result;
  }

  if (v6)
  {
    memcpy((void *)(v2 + 8 * a1[4]), v3, 8 * v6);
    unint64_t v7 = a1[4] + a1[5];
    a1[4] = v7;
    a1[5] = 0LL;
    return SortPointers(v2, v7);
  }

  return result;
}

uint64_t BrotliFree(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (unint64_t *)result;
    uint64_t result = (*(uint64_t (**)(void))(result + 8))(*(void *)(result + 16));
    unint64_t v4 = v3[6];
    if (v4 == 64)
    {
      uint64_t result = CollectGarbagePointers(v3);
      unint64_t v4 = v3[6];
    }

    v3[6] = v4 + 1;
    v3[v4 + 199] = a2;
  }

  return result;
}

uint64_t BrotliWipeOutMemoryManager(uint64_t a1)
{
  uint64_t result = CollectGarbagePointers((unint64_t *)a1);
  if (*(void *)(a1 + 32))
  {
    unint64_t v3 = 0LL;
    do
      uint64_t result = (*(uint64_t (**)(void, void))(a1 + 8))( *(void *)(a1 + 16),  *(void *)(a1 + 56 + 8 * v3++));
    while (v3 < *(void *)(a1 + 32));
  }

  *(void *)(a1 + 32) = 0LL;
  return result;
}

uint64_t SortPointers(uint64_t result, unint64_t a2)
{
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    unint64_t v3 = SortPointers_gaps[i];
    if (v3 < a2)
    {
      uint64_t v4 = result + 8 * v3;
      uint64_t v5 = result;
      unint64_t v6 = SortPointers_gaps[i];
      do
      {
        unint64_t v7 = *(void *)(result + 8 * v6);
        unint64_t v8 = v6;
        if (v6 >= v3)
        {
          uint64_t v9 = 0LL;
          while (1)
          {
            unint64_t v10 = *(void *)(v5 + 8 * v9);
            if (v7 >= v10) {
              break;
            }
            *(void *)(v4 + 8 * v9) = v10;
            v9 -= v3;
            unint64_t v8 = v6 + v9;
            if (v6 + v9 < v3) {
              goto LABEL_10;
            }
          }

          unint64_t v8 = v6 + v9;
        }

uint64_t Annihilate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t result = 0LL;
  if (a2 && a4)
  {
    uint64_t result = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
    unint64_t v5 = 0LL;
    do
    {
      unint64_t v10 = *(void *)(a1 + 8 * v5);
      unint64_t v11 = *(void *)(a3 + 8 * v6);
      if (v10 == v11)
      {
        ++v5;
        ++v6;
        ++result;
      }

      else if (v10 >= v11)
      {
        ++v6;
        *(void *)(a3 + 8 * v8++) = v11;
      }

      else
      {
        ++v5;
        *(void *)(a1 + 8 * v7++) = v10;
      }
    }

    while (v5 < a2 && v6 < a4);
  }

  unint64_t v12 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v13 = (void *)(a1 + 8 * v7);
    uint64_t v14 = (uint64_t *)(a1 + 8 * v5);
    do
    {
      uint64_t v15 = *v14++;
      *v13++ = v15;
      --v12;
    }

    while (v12);
  }

  unint64_t v16 = a4 - v6;
  if (a4 > v6)
  {
    __int128 v17 = (void *)(a3 + 8 * v8);
    __int128 v18 = (uint64_t *)(a3 + 8 * v6);
    do
    {
      uint64_t v19 = *v18++;
      *v17++ = v19;
      --v16;
    }

    while (v16);
  }

  return result;
}

uint64_t cosl_model_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  char v3 = 1;
  do
  {
    char v4 = v3;
    if (a3)
    {
      uint64_t v5 = 0LL;
      unsigned int v6 = 0;
      unsigned int v7 = 0;
      int v8 = 0;
      unsigned int v9 = 0;
      uint64_t v10 = *(void *)(result + 0x80000);
      unsigned int v11 = 32;
      int v12 = 32 - *(_DWORD *)(result + 524296);
      do
      {
        unsigned int v13 = v11 << 8;
        unsigned int v11 = *(unsigned __int8 *)(a2 + v5);
        uint64_t v14 = result + 8LL * v13;
        uint64_t v15 = v10 + 8LL * (v9 >> v12);
        uint64_t v16 = v10 + 8LL * (v7 >> v12);
        unsigned int v17 = 1;
        int v18 = 7;
        uint64_t v19 = v10 + 8LL * (v6 >> v12);
        do
        {
          int v20 = (v11 >> v18) & 1;
          uint64_t v21 = v17;
          uint64_t v22 = (unsigned int *)(v14 + 8LL * v17);
          if ((v4 & 1) != 0)
          {
            uint64_t v23 = v14 + 8 * v21;
            unsigned int v26 = *(_DWORD *)(v23 + 4);
            uint64_t v24 = (_DWORD *)(v23 + 4);
            unsigned int v25 = v26;
            unsigned int v27 = *v22;
            if (v26 >= 0xFFFF0000)
            {
              v25 -= v25 >> 1;
              unsigned int v27 = v27 - (v27 >> 1) - (v27 - (v27 >> 1) == v25);
            }

            *uint64_t v22 = v27 + v20;
            *uint64_t v24 = v25 + 1;
            int32x4_t v28 = (int *)(v15 + 8 * v21);
            unsigned int v29 = v28[1];
            unsigned int v30 = v29 - (v29 >> 1);
            int v31 = *v28 - (*v28 >> 1) - (*v28 - (*v28 >> 1) == v30);
            if (v29 < 0xFFFF0000)
            {
              unsigned int v30 = v28[1];
              int v31 = *v28;
            }

            *int32x4_t v28 = v31 + v20;
            v28[1] = v30 + 1;
            __int128 v32 = (unsigned int *)(v16 + 8 * v21);
            unsigned int v33 = v32[1];
            unsigned int v34 = *v32;
            unsigned int v35 = v33 - (v33 >> 1);
            BOOL v36 = __CFADD__(v33, 0x10000);
            if (v33 >= 0xFFFF0000) {
              v33 -= v33 >> 1;
            }
            if (v36) {
              unsigned int v34 = v34 - (v34 >> 1) - (v34 - (v34 >> 1) == v35);
            }
            *__int128 v32 = v34 + v20;
            v32[1] = v33 + 1;
            int v37 = (unsigned int *)(v19 + 8 * v21);
            unsigned int v39 = v37 + 1;
            unsigned int v38 = v37[1];
            if (v38 >= 0xFFFF0000) {
              unsigned int v40 = *v37 - (*v37 >> 1) - (*v37 - (*v37 >> 1) == v38 - (v38 >> 1));
            }
            else {
              unsigned int v40 = *v37;
            }
            if (v38 >= 0xFFFF0000) {
              unsigned int v41 = v38 - (v38 >> 1);
            }
            else {
              unsigned int v41 = v37[1];
            }
          }

          else
          {
            unint64_t v42 = *(unsigned int *)(v14 + 8 * v21 + 4);
            int v37 = (unsigned int *)(result
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*v22 << 16)
                                                                                          + (v42 >> 1))
                                                                                         / v42) >> 10] << 15)
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*(unsigned int *)(v15 + 8 * v21) << 16)
                                                                                          + ((unint64_t)*(unsigned int *)(v15 + 8 * v21 + 4) >> 1))
                                                                                         / *(unsigned int *)(v15 + 8 * v21 + 4)) >> 10] << 11)
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*(unsigned int *)(v16 + 8 * v21) << 16)
                                                                                          + ((unint64_t)*(unsigned int *)(v16 + 8 * v21 + 4) >> 1))
                                                                                         / *(unsigned int *)(v16 + 8 * v21 + 4)) >> 10] << 7)
                                 + 8LL
                                 * counter_get_quantizer[((((unint64_t)*(unsigned int *)(v19 + 8 * v21) << 16)
                                                                       + ((unint64_t)*(unsigned int *)(v19 + 8 * v21 + 4) >> 1))
                                                                      / *(unsigned int *)(v19 + 8 * v21 + 4)) >> 10]
                                 + 524320);
            unsigned int v39 = v37 + 1;
            unsigned int v41 = v37[1];
            unsigned int v40 = *v37;
            if (v41 >= 0xFFFF0000)
            {
              v41 -= v41 >> 1;
              unsigned int v40 = v40 - (v40 >> 1) - (v40 - (v40 >> 1) == v41);
            }
          }

          *int v37 = v40 + v20;
          *unsigned int v39 = v41 + 1;
          unsigned int v17 = v20 | (2 * v21);
          --v18;
        }

        while (v18 != -1);
        if (v11 - 65 >= 0x1A) {
          unsigned __int8 v43 = v11;
        }
        else {
          unsigned __int8 v43 = v11 + 32;
        }
        BOOL v44 = ((v43 & 0xDF) - 91) >= 0xE6u || (char)v43 <= -1;
        int v45 = -1640531535 * (v6 + v43);
        if (v44) {
          unsigned int v6 = v45;
        }
        else {
          unsigned int v6 = 0;
        }
        unsigned int v7 = -1640531535 * (v8 + v11);
        int v8 = -1640531535 * (v9 + v11);
        unsigned int v9 = -1640531535 * (v13 | v11);
        ++v5;
      }

      while (v5 != a3);
    }

    char v3 = 0;
  }

  while ((v4 & 1) != 0);
  return result;
}

unint64_t cosl_codec_encode( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!a5) {
    return 0LL;
  }
  int v5 = 0;
  unint64_t v6 = 0LL;
  unint64_t v7 = 1LL;
  do
  {
    unint64_t v8 = v6;
    unint64_t v6 = v7;
    v7 += v8;
    ++v5;
  }

  while (a5 - v6 >= v7);
  unint64_t v9 = 1LL << v5;
  if (v5)
  {
    unsigned int v10 = v5 - 1;
    unint64_t v11 = a5;
    do
    {
      uint64_t v12 = 1LL << v10;
      if (v11 >= v7) {
        unint64_t v13 = v7;
      }
      else {
        unint64_t v13 = 0LL;
      }
      if (v11 < v7) {
        uint64_t v12 = 0LL;
      }
      v11 -= v13;
      v9 |= v12;
      unint64_t v14 = v7 - v6;
      unint64_t v7 = v6;
      unint64_t v6 = v14;
    }

    while ((unint64_t)v10--);
  }

  int v16 = 0;
  unint64_t v17 = 0LL;
  unint64_t v18 = a5 + ((73 - __clz(v9)) >> 3);
  unint64_t v19 = 1LL;
  do
  {
    unint64_t v20 = v17;
    unint64_t v17 = v19;
    v19 += v20;
    ++v16;
  }

  while (a5 - v17 >= v19);
  unint64_t v21 = 1LL << v16;
  if (!v16) {
    goto LABEL_23;
  }
  unsigned int v22 = v16 - 1;
  unint64_t v23 = a5;
  do
  {
    uint64_t v24 = 1LL << v22;
    if (v23 >= v19) {
      unint64_t v25 = v19;
    }
    else {
      unint64_t v25 = 0LL;
    }
    if (v23 < v19) {
      uint64_t v24 = 0LL;
    }
    v23 -= v25;
    v21 |= v24;
    unint64_t v26 = v19 - v17;
    unint64_t v19 = v17;
    unint64_t v17 = v26;
  }

  while ((unint64_t)v22--);
  if (!v21)
  {
    unint64_t v29 = 0LL;
    unsigned int v28 = 0;
    int v30 = -1;
  }

  else
  {
LABEL_23:
    unsigned int v28 = 0;
    unint64_t v29 = 0LL;
    int v30 = -1;
    do
    {
      int v31 = v28 + ((v30 - v28) >> 1);
      if ((v21 & 1) != 0) {
        int v32 = v28;
      }
      else {
        int v32 = v31 + 1;
      }
      if ((v21 & 1) == 0) {
        int v31 = v30;
      }
      if ((v31 ^ v32) >> 24)
      {
        unsigned int v28 = v32;
        int v30 = v31;
      }

      else
      {
        do
        {
          unsigned int v28 = v32 << 8;
          if (v29 >= a3) {
            unint64_t v33 = 0LL;
          }
          else {
            unint64_t v33 = v29;
          }
          *(_BYTE *)(a2 + v33) = HIBYTE(v32);
          int v30 = (v31 << 8) | 0xFF;
          ++v29;
          unsigned int v34 = ((v31 << 8) ^ (v32 << 8)) >> 24;
          int v31 = v30;
          v32 <<= 8;
        }

        while (!v34);
      }

      BOOL v61 = v21 > 1;
      v21 >>= 1;
    }

    while (v61);
  }

  unsigned int v36 = v28 + ((v30 - v28) >> 1);
  if ((v36 ^ v28) >> 24)
  {
    unsigned int v37 = v28;
    unsigned int v39 = v36;
  }

  else
  {
    do
    {
      unsigned int v37 = v28 << 8;
      if (v29 >= a3) {
        unint64_t v38 = 0LL;
      }
      else {
        unint64_t v38 = v29;
      }
      *(_BYTE *)(a2 + v38) = HIBYTE(v28);
      unsigned int v39 = (v36 << 8) | 0xFF;
      ++v29;
      unsigned int v40 = ((v36 << 8) ^ (v28 << 8)) >> 24;
      unsigned int v36 = v39;
      v28 <<= 8;
    }

    while (!v40);
  }

  uint64_t v41 = 0LL;
  unsigned int v42 = 0;
  unsigned int v43 = 0;
  int v44 = 0;
  unsigned int v45 = 0;
  if (a5 <= 1) {
    uint64_t v46 = 1LL;
  }
  else {
    uint64_t v46 = a5;
  }
  unsigned int v47 = 32;
  do
  {
    unsigned int v48 = v47 << 8;
    unsigned int v47 = *(unsigned __int8 *)(a4 + v41);
    int v49 = -*(_DWORD *)(a1 + 16);
    unsigned int v50 = v45 >> v49;
    unsigned int v51 = v43 >> v49;
    unsigned int v52 = v42 >> v49;
    int v53 = 1;
    int v54 = 8;
    do
    {
      --v54;
      uint64_t v55 = *(void *)(a1 + 8);
      if (((v47 >> v54) & 1) != 0) {
        unsigned int v56 = v37;
      }
      else {
        unsigned int v56 = v37
      }
            + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                   + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                             + ((unint64_t)(v53 + v48) >> 1)) >> (4 * (v53 & 1))) & 0xF) << 12)
                                   + ((unint64_t)((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v50) >> 1)) >> (4 * ((v53 + v50) & 1))) & 0xF) << 8)
                                   + 16LL
                                   * ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v51) >> 1)) >> (4 * ((v53 + v51) & 1))) & 0xF)
                                   + ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v52) >> 1)) >> (4 * ((v53 + v52) & 1))) & 0xFLL))
      if (((v47 >> v54) & 1) != 0) {
        unsigned int v57 = v37
      }
            + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                   + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                             + ((unint64_t)(v53 + v48) >> 1)) >> (4 * (v53 & 1))) & 0xF) << 12)
                                   + ((unint64_t)((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v50) >> 1)) >> (4 * ((v53 + v50) & 1))) & 0xF) << 8)
                                   + 16LL
                                   * ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v51) >> 1)) >> (4 * ((v53 + v51) & 1))) & 0xF)
      else {
        unsigned int v57 = v39;
      }
      if ((v57 ^ v56) >> 24)
      {
        unsigned int v37 = v56;
        unsigned int v39 = v57;
      }

      else
      {
        do
        {
          unsigned int v37 = v56 << 8;
          if (v29 >= a3) {
            unint64_t v58 = 0LL;
          }
          else {
            unint64_t v58 = v29;
          }
          *(_BYTE *)(a2 + v58) = HIBYTE(v56);
          unsigned int v39 = (v57 << 8) | 0xFF;
          ++v29;
          unsigned int v59 = ((v57 << 8) ^ (v56 << 8)) >> 24;
          unsigned int v57 = v39;
          v56 <<= 8;
        }

        while (!v59);
      }

      int v53 = (v47 >> v54) & 1 | (2 * v53);
    }

    while (v54);
    if (v47 - 65 >= 0x1A) {
      unsigned __int8 v60 = v47;
    }
    else {
      unsigned __int8 v60 = v47 + 32;
    }
    BOOL v61 = ((v60 & 0xDF) - 91) >= 0xE6u || (char)v60 <= -1;
    int v62 = -1640531535 * (v42 + v60);
    if (v61) {
      unsigned int v42 = v62;
    }
    else {
      unsigned int v42 = 0;
    }
    unsigned int v43 = -1640531535 * (v44 + v47);
    int v44 = -1640531535 * (v45 + v47);
    unsigned int v45 = -1640531535 * (v48 | v47);
    ++v41;
  }

  while (v41 != v46);
  while (1)
  {
    int v68 = HIBYTE(v37) + 1;
    if (v68 != HIBYTE(v39)) {
      break;
    }
    int v63 = v37 | 0xFFFFFF;
    unsigned int v64 = (v37 | 0xFFFFFF) - v37;
    if ((v39 & 0xFFFFFF) <= v64) {
      unsigned int v65 = v37;
    }
    else {
      unsigned int v65 = v39 & 0xFF000000;
    }
    if ((v39 & 0xFFFFFF) > v64) {
      int v63 = v39;
    }
    if ((v63 ^ v65) >> 24)
    {
      unsigned int v37 = v65;
      unsigned int v39 = v63;
    }

    else
    {
      do
      {
        unsigned int v37 = v65 << 8;
        if (v29 >= a3) {
          unint64_t v66 = 0LL;
        }
        else {
          unint64_t v66 = v29;
        }
        *(_BYTE *)(a2 + v66) = HIBYTE(v65);
        unsigned int v39 = (v63 << 8) | 0xFF;
        ++v29;
        unsigned int v67 = ((v63 << 8) ^ (v65 << 8)) >> 24;
        int v63 = v39;
        v65 <<= 8;
      }

      while (!v67);
    }
  }

  if (v29 >= a3) {
    unint64_t v69 = 0LL;
  }
  else {
    unint64_t v69 = v29;
  }
  *(_BYTE *)(a2 + v69) = v68;
  if (v29 + 1 <= a3) {
    unint64_t result = v29 + 1;
  }
  else {
    unint64_t result = 0LL;
  }
  if (result > v18)
  {
    int v70 = 0;
    unint64_t v71 = 0LL;
    unint64_t v72 = 1LL;
    do
    {
      unint64_t v73 = v71;
      unint64_t v71 = v72;
      v72 += v73;
      ++v70;
    }

    while (a5 - v71 >= v72);
    unint64_t v74 = 1LL << v70;
    if (!v70) {
      goto LABEL_108;
    }
    unsigned int v75 = v70 - 1;
    do
    {
      uint64_t v76 = 1LL << v75;
      if (a5 >= v72) {
        unint64_t v77 = v72;
      }
      else {
        unint64_t v77 = 0LL;
      }
      if (a5 < v72) {
        uint64_t v76 = 0LL;
      }
      a5 -= v77;
      v74 |= v76;
      unint64_t v78 = v72 - v71;
      unint64_t v72 = v71;
      unint64_t v71 = v78;
    }

    while ((unint64_t)v75--);
    if (!v74)
    {
      unint64_t v81 = 0LL;
      unsigned int v80 = 0;
      int v82 = -1;
    }

    else
    {
LABEL_108:
      unsigned int v80 = 0;
      unint64_t v81 = 0LL;
      int v82 = -1;
      do
      {
        if ((v74 & 1) != 0) {
          unsigned int v83 = v80;
        }
        else {
          unsigned int v83 = v80 + ((v82 - v80) >> 1) + 1;
        }
        if ((v74 & 1) != 0) {
          int v84 = v80 + ((v82 - v80) >> 1);
        }
        else {
          int v84 = v82;
        }
        if ((v84 ^ v83) >> 24)
        {
          unsigned int v80 = v83;
          int v82 = v84;
        }

        else
        {
          do
          {
            unsigned int v80 = v83 << 8;
            if (v81 >= a3) {
              unint64_t v85 = 0LL;
            }
            else {
              unint64_t v85 = v81;
            }
            *(_BYTE *)(a2 + v85) = HIBYTE(v83);
            int v82 = (v84 << 8) | 0xFF;
            ++v81;
            unsigned int v86 = ((v84 << 8) ^ (v83 << 8)) >> 24;
            int v84 = v82;
            v83 <<= 8;
          }

          while (!v86);
        }

        BOOL v61 = v74 > 1;
        v74 >>= 1;
      }

      while (v61);
    }

    unsigned int v87 = v80 + ((v82 - v80) >> 1) + 1;
    if ((v82 ^ v87) >> 24)
    {
      unsigned int v90 = v82;
      unsigned int v88 = v87;
    }

    else
    {
      do
      {
        unsigned int v88 = v87 << 8;
        if (v81 >= a3) {
          unint64_t v89 = 0LL;
        }
        else {
          unint64_t v89 = v81;
        }
        *(_BYTE *)(a2 + v89) = HIBYTE(v87);
        unsigned int v90 = (v82 << 8) | 0xFF;
        ++v81;
        unsigned int v91 = ((v82 << 8) ^ (v87 << 8)) >> 24;
        int v82 = v90;
        v87 <<= 8;
      }

      while (!v91);
    }

    for (uint64_t i = 0LL; i != v46; ++i)
    {
      unsigned int v93 = *(unsigned __int8 *)(a4 + i) | 0x100;
      do
      {
        if ((v93 & 0x80) != 0) {
          unsigned int v94 = v88;
        }
        else {
          unsigned int v94 = v88 + ((v90 - v88) >> 1) + 1;
        }
        if ((v93 & 0x80) != 0) {
          unsigned int v95 = v88 + ((v90 - v88) >> 1);
        }
        else {
          unsigned int v95 = v90;
        }
        if ((v95 ^ v94) >> 24)
        {
          unsigned int v88 = v94;
          unsigned int v90 = v95;
        }

        else
        {
          do
          {
            unsigned int v88 = v94 << 8;
            if (v81 >= a3) {
              unint64_t v96 = 0LL;
            }
            else {
              unint64_t v96 = v81;
            }
            *(_BYTE *)(a2 + v96) = HIBYTE(v94);
            unsigned int v90 = (v95 << 8) | 0xFF;
            ++v81;
            unsigned int v97 = ((v95 << 8) ^ (v94 << 8)) >> 24;
            unsigned int v95 = v90;
            v94 <<= 8;
          }

          while (!v97);
        }

        BOOL v98 = v93 >= 0x8000;
        v93 *= 2;
      }

      while (!v98);
    }

    while (1)
    {
      int v104 = HIBYTE(v88) + 1;
      if (v104 != HIBYTE(v90)) {
        break;
      }
      int v99 = v88 | 0xFFFFFF;
      unsigned int v100 = (v88 | 0xFFFFFF) - v88;
      if ((v90 & 0xFFFFFF) <= v100) {
        unsigned int v101 = v88;
      }
      else {
        unsigned int v101 = v90 & 0xFF000000;
      }
      if ((v90 & 0xFFFFFF) > v100) {
        int v99 = v90;
      }
      if ((v99 ^ v101) >> 24)
      {
        unsigned int v88 = v101;
        unsigned int v90 = v99;
      }

      else
      {
        do
        {
          unsigned int v88 = v101 << 8;
          if (v81 >= a3) {
            unint64_t v102 = 0LL;
          }
          else {
            unint64_t v102 = v81;
          }
          *(_BYTE *)(a2 + v102) = HIBYTE(v101);
          unsigned int v90 = (v99 << 8) | 0xFF;
          ++v81;
          unsigned int v103 = ((v99 << 8) ^ (v101 << 8)) >> 24;
          int v99 = v90;
          v101 <<= 8;
        }

        while (!v103);
      }
    }

    if (v81 >= a3) {
      unint64_t v105 = 0LL;
    }
    else {
      unint64_t v105 = v81;
    }
    *(_BYTE *)(a2 + v105) = v104;
    if (v81 + 1 <= a3) {
      return v81 + 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t cosl_codec_get_decoded_size(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0LL;
  unint64_t v4 = 0LL;
  unsigned int v5 = 0;
  unsigned int v6 = 0;
  int v7 = 0;
  unint64_t v8 = 0LL;
  do
  {
    if ((v6 ^ v7) >> 24)
    {
      int v9 = v7;
      int v11 = v6;
    }

    else
    {
      do
      {
        int v9 = v7 << 8;
        unsigned int v10 = v6 << 8;
        int v11 = (v6 << 8) | 0xFF;
        if (v8 >= a3) {
          unint64_t v12 = 0LL;
        }
        else {
          unint64_t v12 = v8;
        }
        unsigned int v5 = *(unsigned __int8 *)(a2 + v12) | (v5 << 8);
        ++v8;
        unsigned int v13 = (v10 ^ (v7 << 8)) >> 24;
        unsigned int v6 = v11;
        v7 <<= 8;
      }

      while (!v13);
    }

    unsigned int v14 = v9 + ((v11 - v9) >> 1);
    v4 |= (unint64_t)(v5 <= v14) << v3;
    if ((2 * v4) >> v3 == 3) {
      break;
    }
    unsigned int v6 = v5 > v14 ? v11 : v9 + ((v11 - v9) >> 1);
    int v7 = v5 > v14 ? v14 + 1 : v9;
    ++v3;
  }

  while (v3 != 64);
  if (v4 < 2) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v16 = 1LL;
  uint64_t v17 = 2LL;
  do
  {
    uint64_t v18 = v17;
    result += ((uint64_t)(v4 << 63) >> 63) & v16;
    v17 += v16;
    uint64_t v16 = v18;
    BOOL v19 = v4 > 3;
    v4 >>= 1;
  }

  while (v19);
  return result;
}

unint64_t cosl_codec_decode( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  unint64_t v7 = 0LL;
  unsigned int v8 = 0;
  unsigned int v9 = 0;
  unsigned int v10 = 0;
  do
  {
    if ((v9 ^ v10) >> 24)
    {
      unsigned int v11 = v10;
      int v13 = v9;
    }

    else
    {
      do
      {
        unsigned int v11 = v10 << 8;
        unsigned int v12 = v9 << 8;
        int v13 = (v9 << 8) | 0xFF;
        if (v7 >= a5) {
          unint64_t v14 = 0LL;
        }
        else {
          unint64_t v14 = v7;
        }
        unsigned int v8 = *(unsigned __int8 *)(a4 + v14) | (v8 << 8);
        ++v7;
        unsigned int v15 = (v12 ^ (v10 << 8)) >> 24;
        unsigned int v9 = v13;
        v10 <<= 8;
      }

      while (!v15);
    }

    unsigned int v9 = v11 + ((v13 - v11) >> 1);
    uint64_t v16 = v8 <= v9;
    if (v8 > v9) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = v11;
    }
    if (v8 > v9) {
      unsigned int v9 = v13;
    }
    v6 |= v16 << v5;
    if ((2 * v6) >> v5 == 3) {
      break;
    }
    ++v5;
  }

  while (v5 != 64);
  if (v6 < 2)
  {
    unint64_t v17 = 0LL;
  }

  else
  {
    unint64_t v17 = 0LL;
    uint64_t v18 = 1LL;
    uint64_t v19 = 2LL;
    do
    {
      uint64_t v20 = v19;
      v17 += ((uint64_t)(v6 << 63) >> 63) & v18;
      v19 += v18;
      uint64_t v18 = v20;
      BOOL v58 = v6 > 3;
      v6 >>= 1;
    }

    while (v58);
  }

  if (v17 >= a3) {
    unint64_t v21 = a3;
  }
  else {
    unint64_t v21 = v17;
  }
  if ((v9 ^ v10) >> 24)
  {
    unsigned int v22 = v10;
    unsigned int v24 = v9;
  }

  else
  {
    do
    {
      unsigned int v22 = v10 << 8;
      unsigned int v23 = v9 << 8;
      unsigned int v24 = (v9 << 8) | 0xFF;
      if (v7 >= a5) {
        unint64_t v25 = 0LL;
      }
      else {
        unint64_t v25 = v7;
      }
      unsigned int v8 = *(unsigned __int8 *)(a4 + v25) | (v8 << 8);
      ++v7;
      unsigned int v26 = (v23 ^ (v10 << 8)) >> 24;
      unsigned int v9 = v24;
      v10 <<= 8;
    }

    while (!v26);
  }

  unsigned int v27 = v22 + ((v24 - v22) >> 1);
  if (v8 <= v27)
  {
    if (v21)
    {
      uint64_t v37 = 0LL;
      unsigned int v38 = 0;
      unsigned int v39 = 0;
      int v40 = 0;
      unsigned int v41 = 0;
      int v42 = 32;
      do
      {
        int v43 = v42 << 8;
        int v44 = -*(_DWORD *)(a1 + 16);
        unsigned int v45 = v41 >> v44;
        unsigned int v46 = v39 >> v44;
        unsigned int v47 = v38 >> v44;
        int v49 = 8;
        int v50 = 1;
        do
        {
          if ((v27 ^ v22) >> 24)
          {
            unsigned int v51 = v22;
            int v53 = v27;
          }

          else
          {
            do
            {
              unsigned int v51 = v22 << 8;
              unsigned int v52 = v27 << 8;
              int v53 = (v27 << 8) | 0xFF;
              if (v7 >= a5) {
                unint64_t v54 = 0LL;
              }
              else {
                unint64_t v54 = v7;
              }
              unsigned int v8 = *(unsigned __int8 *)(a4 + v54) | (v8 << 8);
              ++v7;
              unsigned int v55 = (v52 ^ (v22 << 8)) >> 24;
              unsigned int v27 = v53;
              v22 <<= 8;
            }

            while (!v55);
          }

          uint64_t v48 = *(void *)(a1 + 8);
          unsigned int v27 = v51
              + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                     + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                               + ((unint64_t)(v50 + v43) >> 1)) >> (4 * (v50 & 1))) & 0xF) << 12)
                                     + ((unint64_t)((*(unsigned __int8 *)(v48
                                                                               + ((unint64_t)(v50 + v45) >> 1)) >> (4 * ((v50 + v45) & 1))) & 0xF) << 8)
                                     + 16LL
                                     * ((*(unsigned __int8 *)(v48 + ((unint64_t)(v50 + v46) >> 1)) >> (4 * ((v50 + v46) & 1))) & 0xF)
          BOOL v56 = v8 <= v27;
          if (v8 > v27) {
            unsigned int v22 = v27 + 1;
          }
          else {
            unsigned int v22 = v51;
          }
          if (v8 > v27) {
            unsigned int v27 = v53;
          }
          int v50 = v56 | (2 * v50);
          --v49;
        }

        while (v49);
        else {
          unsigned __int8 v57 = v50 + 32;
        }
        BOOL v58 = ((v57 & 0xDF) - 91) >= 0xE6u || (char)v57 <= -1;
        unsigned int v38 = -1640531535 * (v38 + v57);
        if (!v58) {
          unsigned int v38 = 0;
        }
        int v42 = v50;
        unsigned int v39 = -1640531535 * (v40 + v50);
        int v40 = -1640531535 * (v41 + v50);
        unsigned int v41 = -1640531535 * (v50 | v43);
        *(_BYTE *)(a2 + v37++) = v50;
      }

      while (v37 != v21);
    }
  }

  else if (v21)
  {
    uint64_t v28 = 0LL;
    unsigned int v29 = v27 + 1;
    do
    {
      for (unsigned int i = 1; i < 0x100; unsigned int i = v36 | (2 * i))
      {
        if ((v24 ^ v29) >> 24)
        {
          unsigned int v31 = v29;
          int v33 = v24;
        }

        else
        {
          do
          {
            unsigned int v31 = v29 << 8;
            unsigned int v32 = v24 << 8;
            int v33 = (v24 << 8) | 0xFF;
            if (v7 >= a5) {
              unint64_t v34 = 0LL;
            }
            else {
              unint64_t v34 = v7;
            }
            unsigned int v8 = *(unsigned __int8 *)(a4 + v34) | (v8 << 8);
            ++v7;
            unsigned int v35 = (v32 ^ (v29 << 8)) >> 24;
            unsigned int v24 = v33;
            v29 <<= 8;
          }

          while (!v35);
        }

        unsigned int v24 = v31 + ((v33 - v31) >> 1);
        BOOL v36 = v8 <= v24;
        if (v8 > v24) {
          unsigned int v29 = v24 + 1;
        }
        else {
          unsigned int v29 = v31;
        }
        if (v8 > v24) {
          unsigned int v24 = v33;
        }
      }

      *(_BYTE *)(a2 + v28++) = i;
    }

    while (v28 != v21);
  }

  return v21;
}

void *cosl_model_create(unsigned int a1)
{
  if (a1 > 5) {
    return 0LL;
  }
  uint64_t v3 = calloc(1uLL, 0x100028uLL);
  unint64_t v1 = v3;
  if (!v3)
  {
    cosl_model_destroy(0LL);
    return v1;
  }

  unint64_t v4 = v3 + 0x10000;
  *((_BYTE *)v3 + 1048608) = a1;
  uint64_t v5 = (0x40000 << a1) | 0x100u;
  unint64_t v6 = malloc(8 * v5);
  if (v6)
  {
    *unint64_t v4 = v6;
    v1[65537] = a1 + 18;
    v1[65538] = v5;
    v1[65539] = 64LL;
    goto LABEL_9;
  }

  uint64_t v5 = v1[65538];
  if (v5)
  {
    unint64_t v6 = (void *)*v4;
    do
    {
LABEL_9:
      *v6++ = 0x200000001LL;
      --v5;
    }

    while (v5);
  }

  for (uint64_t i = 0LL; i != 0x10000; i += 4LL)
  {
    unsigned int v8 = &v1[i];
    *unsigned int v8 = xmmword_1810770F0;
    v8[1] = xmmword_1810770F0;
  }

  for (uint64_t j = 0LL; j != 0x10000; j += 4LL)
  {
    unsigned int v10 = &v1[j + 65540];
    *unsigned int v10 = xmmword_1810770F0;
    v10[1] = xmmword_1810770F0;
  }

  return v1;
}

void cosl_model_destroy(void **a1)
{
  if (a1)
  {
    free(a1[0x10000]);
    free(a1);
  }

uint64_t cosl_model_save_codec(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3 = (void *)(a1 + 0x80000);
  uint64_t __ptr = 0x100000000000LL;
  unint64_t v4 = *(void *)(a1 + 524312) * *(void *)(a1 + 524304);
  if (v4 < 8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = malloc(v4 >> 3);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = v8;
  unsigned int v10 = fopen(a2, "wb");
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = v10;
  LODWORD(__ptr) = a3;
  HIWORD(__ptr) = *(unsigned __int8 *)(a1 + 1048608);
  if (fwrite(&__ptr, 1uLL, 8uLL, v10) != 8) {
    goto LABEL_19;
  }
  unint64_t v12 = v3[2];
  if (v12)
  {
    unint64_t v13 = 0LL;
    unint64_t v14 = (unsigned int *)(*v3 + 8LL);
    unsigned int v15 = v9;
    do
    {
      unsigned __int8 v16 = counter_get_quantizer[((((unint64_t)*(v14 - 2) << 16)
      uint64_t v17 = *v14;
      unint64_t v18 = v14[1];
      v14 += 4;
      *v15++ = v16 + 16 * counter_get_quantizer[(((v17 << 16) + (v18 >> 1)) / v18) >> 10];
      v13 += 2LL;
    }

    while (v13 < v12);
  }

  if (fwrite(v9, 1uLL, v12 >> 1, v11) != v12 >> 1) {
    goto LABEL_19;
  }
  uint64_t v19 = (unsigned int *)(a1 + 8);
  unint64_t v20 = -2LL;
  unint64_t v21 = v9;
  do
  {
    unsigned __int8 v22 = counter_get_quantizer[((((unint64_t)*(v19 - 2) << 16)
    uint64_t v23 = *v19;
    unint64_t v24 = v19[1];
    v19 += 4;
    *v21++ = v22 + 16 * counter_get_quantizer[(((v23 << 16) + (v24 >> 1)) / v24) >> 10];
    v20 += 2LL;
  }

  while (v20 < 0xFFFE);
  if (fwrite(v9, 1uLL, 0x8000uLL, v11) == 0x8000)
  {
    uint64_t v25 = 0LL;
    unsigned int v26 = (const float *)(a1 + 524320);
    v27.i64[0] = 0x100000001LL;
    v27.i64[1] = 0x100000001LL;
    v28.i64[0] = 0xFF000000FFLL;
    v28.i64[1] = 0xFF000000FFLL;
    do
    {
      unsigned int v29 = v26;
      float32x4x2_t v53 = vld2q_f32(v29);
      v29 += 8;
      int v30 = v26 + 16;
      float32x4x2_t v54 = vld2q_f32(v30);
      unsigned int v31 = v26 + 24;
      float32x4x2_t v55 = vld2q_f32(v31);
      float32x4x2_t v56 = vld2q_f32(v29);
      uint64x2_t v32 = vshll_high_n_u32((uint32x4_t)v56.val[0], 8uLL);
      uint32x4_t v33 = vshrq_n_u32((uint32x4_t)v53.val[1], 1uLL);
      uint32x4_t v34 = vshrq_n_u32((uint32x4_t)v55.val[1], 1uLL);
      uint32x4_t v35 = vshrq_n_u32((uint32x4_t)v54.val[1], 1uLL);
      uint64x2_t v36 = vshll_n_u32(*(uint32x2_t *)v56.val[0].f32, 8uLL);
      int32x4_t v37 = (int32x4_t)vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v53.val[0], 8uLL), v33);
      uint64x2_t v38 = vaddw_u32(vshll_n_u32(*(uint32x2_t *)v55.val[0].f32, 8uLL), *(uint32x2_t *)v34.i8);
      uint64x2_t v39 = vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v55.val[0], 8uLL), v34);
      int32x4_t v40 = (int32x4_t)vaddw_u32(vshll_n_u32(*(uint32x2_t *)v54.val[0].f32, 8uLL), *(uint32x2_t *)v35.i8);
      uint64x2_t v41 = vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v54.val[0], 8uLL), v35);
      uint32x4_t v42 = vshrq_n_u32((uint32x4_t)v56.val[1], 1uLL);
      v43.i64[0] = v53.val[1].u32[2];
      v43.i64[1] = v53.val[1].u32[3];
      int32x4_t v44 = (int32x4_t)v43;
      v43.i64[0] = v56.val[1].u32[0];
      v43.i64[1] = v56.val[1].u32[1];
      float32x4_t v45 = v43;
      v43.i64[0] = v56.val[1].u32[2];
      v43.i64[1] = v56.val[1].u32[3];
      v56.val[0] = v43;
      v43.i64[0] = v55.val[1].u32[0];
      v43.i64[1] = v55.val[1].u32[1];
      v56.val[1] = v43;
      v43.i64[0] = v55.val[1].u32[2];
      v43.i64[1] = v55.val[1].u32[3];
      v55.val[1] = (float32x4_t)vaddw_u32(v36, *(uint32x2_t *)v42.i8);
      uint64x2_t v46 = vaddw_high_u32(v32, v42);
      unint64_t v47 = v40.i64[1] / (unint64_t)v54.val[1].u32[1];
      unint64_t v48 = v40.i64[0] / (unint64_t)v54.val[1].u32[0];
      v40.i64[0] = v41.i64[0] / (unint64_t)v54.val[1].u32[2];
      v54.val[0].i64[0] = v48;
      v54.val[1].i64[0] = v39.i64[0] / (unint64_t)v43.i64[0];
      v55.val[0].i64[0] = v38.i64[0] / (unint64_t)v56.val[1].i64[0];
      v40.i64[1] = v41.i64[1] / (unint64_t)v54.val[1].u32[3];
      v54.val[0].i64[1] = v47;
      v54.val[1].i64[1] = v39.i64[1] / (unint64_t)v43.i64[1];
      v37.i64[0] /= (unint64_t)v44.i64[0];
      v55.val[0].i64[1] = v38.i64[1] / (unint64_t)v56.val[1].i64[1];
      uint64x2_t v49 = vaddw_u32(vshll_n_u32(*(uint32x2_t *)v53.val[0].f32, 8uLL), *(uint32x2_t *)v33.i8);
      v43.i64[0] = v53.val[1].u32[0];
      v43.i64[1] = v53.val[1].u32[1];
      v37.i64[1] /= (unint64_t)v44.i64[1];
      v53.val[1].i64[0] = v46.i64[0] / (unint64_t)v56.val[0].i64[0];
      v53.val[1].i64[1] = v46.i64[1] / (unint64_t)v56.val[0].i64[1];
      v44.i64[0] = v55.val[1].i64[0] / (unint64_t)v45.i64[0];
      v44.i64[1] = v55.val[1].i64[1] / (unint64_t)v45.i64[1];
      v53.val[0].i64[0] = v49.i64[0] / (unint64_t)v43.i64[0];
      v53.val[0].i64[1] = v49.i64[1] / (unint64_t)v43.i64[1];
      *(int8x16_t *)&v9[v25] = vuzp1q_s8( (int8x16_t)vuzp1q_s16( (int16x8_t)vminq_u32( vmaxq_u32( (uint32x4_t)vuzp1q_s32((int32x4_t)v53.val[0], v37),  v27),  v28),  (int16x8_t)vminq_u32( vmaxq_u32( (uint32x4_t)vuzp1q_s32(v44, (int32x4_t)v53.val[1]),  v27),  v28)),  (int8x16_t)vuzp1q_s16( (int16x8_t)vminq_u32( vmaxq_u32( (uint32x4_t)vuzp1q_s32((int32x4_t)v54.val[0], v40),  v27),  v28),  (int16x8_t)vminq_u32( vmaxq_u32( (uint32x4_t)vuzp1q_s32( (int32x4_t)v55.val[0],  (int32x4_t)v54.val[1]),  v27),  v28)));
      v25 += 16LL;
      v26 += 32;
    }

    while (v25 != 0x10000);
    if (fwrite(v9, 1uLL, 0x10000uLL, v11) == 0x10000) {
      uint64_t v50 = 0LL;
    }
    else {
      uint64_t v50 = 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_19:
    uint64_t v50 = 0xFFFFFFFFLL;
  }

  free(v9);
  fclose(v11);
  return v50;
}

char **cosl_codec_map(const char *a1)
{
  uint64_t v2 = (char **)calloc(1uLL, 0x50uLL);
  uint64_t v3 = v2;
  if (!v2) {
    goto LABEL_3;
  }
  *((_DWORD *)v2 + 18) = -1;
  if (stat(a1, &v14)) {
    goto LABEL_3;
  }
  v3[8] = (char *)v14.st_size;
  int v5 = open(a1, 0);
  *((_DWORD *)v3 + 18) = v5;
  if (v5 < 0) {
    goto LABEL_3;
  }
  unint64_t v6 = (char *)mmap(0LL, (size_t)v3[8], 1, 2, v5, 0LL);
  v3[7] = v6;
  if (v6 == (char *)-1LL)
  {
    v3[7] = 0LL;
LABEL_3:
    cosl_codec_unmap(v3);
    return 0LL;
  }

  uint64_t v7 = (uint64_t)v3[8];
  v3[6] = v6;
  if (v7 < 8) {
    goto LABEL_3;
  }
  if (*((_WORD *)v6 + 2) != 4096) {
    goto LABEL_3;
  }
  unint64_t v8 = *((unsigned __int16 *)v6 + 3);
  if (v8 > 5) {
    goto LABEL_3;
  }
  unsigned int v9 = &v6[v7];
  unsigned int v10 = v6 + 8;
  unint64_t v11 = (0x40000LL << v8) | 0x100;
  if (v7 >= v11 >> 1)
  {
    unint64_t v12 = v11 >> 1;
    v3[1] = v10;
    v3[2] = (char *)(v8 + 18);
    v3[3] = (char *)v11;
    v3[4] = (char *)4;
  }

  else
  {
    unint64_t v12 = 0LL;
  }

  unint64_t v13 = &v10[v12];
  *uint64_t v3 = v13;
  v3[5] = v13 + 0x8000;
  if (v13 + 98304 != v9) {
    goto LABEL_3;
  }
  return v3;
}

void cosl_codec_unmap(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 18);
    if ((v2 & 0x80000000) == 0)
    {
      if (*((void *)a1 + 7))
      {
        munmap(*((void **)a1 + 7), *((void *)a1 + 8));
        *((void *)a1 + 7) = 0LL;
        int v2 = *((_DWORD *)a1 + 18);
      }

      close(v2);
    }
  }

  free(a1);
}

uint64_t cosl_codec_get_id(uint64_t a1)
{
  return **(unsigned int **)(a1 + 48);
}

int32x4_t **lz4_encode_2gb( int32x4_t **result, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v7 = vdupq_n_s32(0xFFFFFFFF);
  unint64_t v8 = *result;
  unsigned int v9 = *a3;
  uint64_t v10 = (uint64_t)(*result)[-8].i64 + a2;
  uint64_t v11 = (uint64_t)&v9[a5 - 128];
  if (v11 >= (uint64_t)v9)
  {
    do
    {
      unint64_t v12 = v9;
      unint64_t v13 = &v9[-a4];
      while (1)
      {
        unint64_t v14 = *v12;
        unsigned int v15 = (int *)(a6 + 8LL * ((-1640531535 * *v12) >> 20));
        int v16 = *v15;
        int v17 = v15[1];
        *unsigned int v15 = (int)v13;
        v15[1] = v14;
        unint64_t v18 = v14 >> 8;
        uint64_t v19 = (int *)(a6 + 8LL * ((-1640531535 * (v14 >> 8)) >> 20));
        int v20 = *v19;
        int v21 = v19[1];
        *uint64_t v19 = (_DWORD)v13 + 1;
        v19[1] = v14 >> 8;
        if ((_DWORD)v14 == v17)
        {
          uint64_t v22 = ((_DWORD)v13 - v16);
        }

        unint64_t v12 = (void *)((char *)v12 + 1);
        unint64_t v24 = v13 + 1;
        unint64_t v25 = v14 >> 16;
        unsigned int v26 = (int *)(a6 + 8LL * ((-1640531535 * v25) >> 20));
        int v27 = *v26;
        int v28 = v26[1];
        *unsigned int v26 = (_DWORD)v24 + 1;
        v26[1] = v25;
        if ((_DWORD)v18 == v21)
        {
          uint64_t v22 = ((_DWORD)v24 - v20);
        }

        unint64_t v12 = (void *)((char *)v12 + 1);
        int v30 = v24 + 1;
        unint64_t v31 = v25 >> 8;
        uint64x2_t v32 = (int *)(a6 + 8LL * ((-1640531535 * (v25 >> 8)) >> 20));
        int v33 = *v32;
        int v34 = v32[1];
        *uint64x2_t v32 = (_DWORD)v30 + 1;
        v32[1] = v25 >> 8;
        if ((_DWORD)v25 == v28)
        {
          uint64_t v22 = ((_DWORD)v30 - v27);
        }

        unint64_t v12 = (void *)((char *)v12 + 1);
        uint64x2_t v36 = v30 + 1;
        unint64_t v37 = v25 >> 16;
        uint64x2_t v38 = (int *)(a6 + 8LL * ((-1640531535 * v37) >> 20));
        int v39 = *v38;
        int v40 = v38[1];
        *uint64x2_t v38 = (_DWORD)v36 + 1;
        v38[1] = v37;
        if ((_DWORD)v31 == v34)
        {
          uint64_t v22 = ((_DWORD)v36 - v33);
        }

        unint64_t v12 = (void *)((char *)v12 + 1);
        uint32x4_t v42 = v36 + 1;
        if ((_DWORD)v37 == v40)
        {
          uint64_t v22 = ((_DWORD)v42 - v39);
        }

        unint64_t v12 = (void *)((char *)v12 + 1);
        unint64_t v13 = v42 + 1;
      }

      int32x4_t v44 = (char *)v12 + 4;
      float32x4_t v45 = (void *)((char *)v12 - v22 + 4);
      while (1)
      {
        uint64_t v47 = *(void *)v44;
        v44 += 8;
        uint64_t v46 = v47;
        uint64_t v49 = *v45++;
        uint64_t v48 = v49;
        if (v46 != v49) {
          break;
        }
      }

      int32x4_t v44 = &v44[(__clz(__rbit64(v46 ^ v48)) >> 3) - 8];
LABEL_38:
      uint64_t v50 = (char *)v12 - v22;
      while (1)
      {
        BOOL v51 = (uint64_t)v12 <= (uint64_t)v9 || (uint64_t)v50 <= a4;
        if (v51) {
          break;
        }
        int v53 = *((unsigned __int8 *)v12 - 1);
        unint64_t v12 = (void *)((char *)v12 - 1);
        int v52 = v53;
        int v54 = *--v50;
        if (v52 != v54)
        {
          unint64_t v12 = (void *)((char *)v12 + 1);
          break;
        }
      }

      unint64_t v55 = v44 - (char *)v12 - 4;
      uint64_t v56 = (char *)v12 - v9;
      unint64_t v57 = (char *)v12 - v9 + 3;
      unint64_t v58 = v10 - (void)v8 - v57;
      __int8 v59 = (v55 & 0xF) + 16 * v56;
      unsigned __int8 v60 = (int32x4_t *)&v8->i8[1];
      if ((unint64_t)v56 >= 0xF)
      {
        v59 |= 0xF0u;
        unint64_t v61 = v56 - 15;
        BOOL v62 = v58-- != 0;
        if (!v62) {
          goto LABEL_92;
        }
        if (v61 >= 0xFF)
        {
          unint64_t v63 = v61 / 0xFFuLL;
          BOOL v62 = v58 >= v63;
          v58 -= v63;
          if (!v62) {
            goto LABEL_92;
          }
          LOBYTE(v61) = v61 + v63;
          do
          {
            *v60++ = v7;
            BOOL v51 = v63 > 0x10;
            v63 -= 16LL;
          }

          while (v51);
          unsigned __int8 v60 = (int32x4_t *)((char *)v60 + v63);
        }

        v60->i8[0] = v61;
        unsigned __int8 v60 = (int32x4_t *)((char *)v60 + 1);
      }

      do
      {
        int32x4_t v64 = *(int32x4_t *)v9;
        v9 += 16;
        *v60++ = v64;
        BOOL v51 = v56 <= 16;
        v56 -= 16LL;
      }

      while (!v51);
      unsigned int v65 = (__int16 *)((char *)v60->i16 + v56);
      _WORD *v65 = v22;
      unint64_t v66 = (int32x4_t *)(v65 + 1);
      if (v55 >= 0xF)
      {
        v59 |= 0xFu;
        unint64_t v67 = v44 - (char *)v12 - 19;
        BOOL v62 = v58 != 0;
        unint64_t v68 = v58 - 1;
        if (!v62) {
          goto LABEL_92;
        }
        if (v67 >= 0xFF)
        {
          unint64_t v69 = v67 / 0xFFuLL;
          if (v68 < v69) {
            goto LABEL_92;
          }
          LOBYTE(v67) = v67 + v69;
          do
          {
            *v66++ = v7;
            BOOL v51 = v69 > 0x10;
            v69 -= 16LL;
          }

          while (v51);
          unint64_t v66 = (int32x4_t *)((char *)v66 + v69);
        }

        v66->i8[0] = v67;
        unint64_t v66 = (int32x4_t *)((char *)v66 + 1);
      }

      v8->i8[0] = v59;
      unint64_t v8 = v66;
      unsigned int v9 = v44;
    }

    while ((uint64_t)v44 < v11 && (uint64_t)v66 < v10);
  }

LABEL_74:
  if (a7) {
    goto LABEL_92;
  }
  unint64_t v71 = (char *)(v11 + 128);
  uint64_t v72 = v71 - v9;
  if (v71 == v9) {
    goto LABEL_92;
  }
  uint64_t v73 = v10 + 128 - (void)v8 - 1;
  BOOL v51 = v73 <= v72;
  uint64_t v74 = v73 - v72;
  if (v51) {
    goto LABEL_92;
  }
  if (v72 < 15)
  {
    v8->i8[0] = 16 * v72;
    unint64_t v8 = (int32x4_t *)((char *)v8 + 1);
    do
    {
LABEL_91:
      __int8 v81 = *v9++;
      v8->i8[0] = v81;
      unint64_t v8 = (int32x4_t *)((char *)v8 + 1);
    }

    while (v9 < v71);
    goto LABEL_92;
  }

  uint64_t v75 = v74 - 1;
  if (v75 >= 0)
  {
    v8->i8[0] = -16;
    uint64_t v76 = (int32x4_t *)&v8->i8[1];
    unsigned int v77 = v72 - 15;
    if ((unint64_t)(v72 - 15) >= 0xFF)
    {
      int64_t v78 = v77 / 0xFFuLL;
      if (v75 - v78 < 0)
      {
        unint64_t v8 = (int32x4_t *)((char *)v76 - 1);
        goto LABEL_92;
      }

      LOBYTE(v77) = v77 + v78;
      do
      {
        *v76++ = v7;
        BOOL v51 = v78 <= 16;
        v78 -= 16LL;
      }

      while (!v51);
      uint64_t v76 = (int32x4_t *)((char *)v76 + v78);
    }

    v76->i8[0] = v77;
    unint64_t v8 = (int32x4_t *)&v76->i8[1];
    uint64_t v79 = (unint64_t)v72 >> 4;
    do
    {
      int32x4_t v80 = *(int32x4_t *)v9;
      v9 += 16;
      *v8++ = v80;
      BOOL v51 = v79-- <= 1;
    }

    while (!v51);
    if (v9 < v71) {
      goto LABEL_91;
    }
  }

LABEL_92:
  *uint64_t result = v8;
  *a3 = v9;
  return result;
}

void *BrotliGetDictionary()
{
  return &kBrotliDictionary;
}

uint64_t BrotliBuildHistogramsWithContext( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, unsigned __int8 a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  unint64_t v14 = *(unsigned int **)(a3 + 24);
  if (v14) {
    uint64_t v15 = *v14;
  }
  else {
    uint64_t v15 = 0LL;
  }
  int v16 = *(unsigned int **)(a4 + 24);
  uint64_t v47 = v16;
  if (v16) {
    uint64_t v17 = *v16;
  }
  else {
    uint64_t v17 = 0LL;
  }
  unint64_t v18 = *(unsigned int **)(a5 + 24);
  int32x4_t v44 = v18;
  if (v18)
  {
    uint64_t v19 = *v18;
    if (!a2) {
      return result;
    }
  }

  else
  {
    uint64_t v19 = 0LL;
    if (!a2) {
      return result;
    }
  }

  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = a10;
  uint64_t v27 = a9;
  uint64_t v46 = 0LL;
  do
  {
    if (!v17)
    {
      ++v24;
      uint64_t v23 = *(unsigned __int8 *)(*(void *)(a4 + 16) + v24);
      uint64_t v17 = v47[v24];
    }

    int v28 = (unsigned int *)(result + 16 * v20);
    uint64_t v29 = a13 + 2832 * v23;
    unsigned int v30 = *((unsigned __int16 *)v28 + 6);
    ++*(_DWORD *)(v29 + 4LL * *((unsigned __int16 *)v28 + 6));
    ++*(void *)(v29 + 2816);
    uint64_t v31 = *v28;
    if ((_DWORD)v31)
    {
      do
      {
        uint64_t v32 = v27;
        if (!v15)
        {
          ++v21;
          uint64_t v25 = *(unsigned __int8 *)(*(void *)(a3 + 16) + v21);
          uint64_t v15 = v14[v21];
        }

        uint64_t v33 = v25;
        if (a11)
        {
          int v34 = (char *)&_kBrotliContextLookupTable + (*(_DWORD *)(a11 + 4 * v25) << 9);
          uint64_t v33 = (v25 << 6) + (v34[v26 + 256] | v34[v32]);
        }

        uint64_t v35 = a12 + 1040 * v33;
        --v15;
        ++*(_DWORD *)(v35 + 4LL * *(unsigned __int8 *)(a6 + (a7 & a8)));
        ++*(void *)(v35 + 1024);
        uint64_t v27 = *(unsigned __int8 *)(a6 + (a7++ & a8));
        uint64_t v26 = v32;
        --v31;
      }

      while (v31);
    }

    else
    {
      uint64_t v32 = v26;
    }

    uint64_t v36 = *(_DWORD *)(result + 16 * v20 + 4) & 0x1FFFFFF;
    a7 += v36;
    if ((_DWORD)v36)
    {
      uint64_t v32 = *(unsigned __int8 *)(a6 + ((a7 - 2) & a8));
      uint64_t v27 = *(unsigned __int8 *)(a6 + ((a7 - 1) & a8));
      if (v30 >= 0x80)
      {
        if (!v19)
        {
          uint64_t v22 = *(unsigned __int8 *)(*(void *)(a5 + 16) + ++v46);
          uint64_t v19 = v44[v46];
        }

        --v19;
        unsigned int v37 = v30 >> 6;
        BOOL v40 = v30 >> 6 != 2 && v37 != 4 && v37 != 7 || (v30 & 7) >= 3;
        uint64_t v41 = 3LL;
        if (!v40) {
          uint64_t v41 = v30 & 7;
        }
        uint64_t v42 = a14 + 2192 * (v41 | (4 * v22));
        uint64_t v43 = *(_WORD *)(result + 16 * v20 + 14) & 0x3FF;
        ++*(_DWORD *)(v42 + 4 * v43);
        ++*(void *)(v42 + 2176);
      }
    }

    --v17;
    ++v20;
    uint64_t v26 = v32;
  }

  while (v20 != a2);
  return result;
}

uint64_t thread_pool_send_task(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = v4 + 1;
  uint64_t v5 = *(void *)(a1 + 280);
  uint64_t v6 = (int)(v4 % (2LL * *(void *)(a1 + 272)));
  int32x4_t v7 = (pthread_mutex_t *)(a1 + 16);
  unint64_t v8 = (pthread_cond_t *)(a1 + 80);
  if (!v5) {
    goto LABEL_3;
  }
LABEL_2:
  uint64_t v9 = *(void *)(a1 + 264);
  if (*(void *)(v9 + 8 * v6))
  {
LABEL_3:
    while (!pthread_mutex_lock(v7))
    {
      while (1)
      {
        int v10 = *(_DWORD *)(a1 + 8);
        if (v10 > 0) {
          break;
        }
        if (pthread_cond_wait(v8, v7)) {
          return 0xFFFFFFFFLL;
        }
      }

      *(_DWORD *)(a1 + 8) = v10 - 1;
      if (pthread_mutex_unlock(v7)) {
        break;
      }
      uint64_t v5 = *(void *)(a1 + 280) + 1LL;
      *(void *)(a1 + 280) = v5;
      if (v5) {
        goto LABEL_2;
      }
    }

    return 0xFFFFFFFFLL;
  }

  *(void *)(a1 + 280) = v5 - 1;
  *(void *)(v9 + 8 * v6) = a2;
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 136))) {
    return 0xFFFFFFFFLL;
  }
  int v11 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = v11 + 1;
  if (!v11)
  {
    if (pthread_cond_broadcast((pthread_cond_t *)(a1 + 200))) {
      return 0xFFFFFFFFLL;
    }
  }

  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 136));
  if ((_DWORD)result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t thread_pool_sync(uint64_t a1)
{
  if (*(void *)(a1 + 280) >= *(void *)(a1 + 272))
  {
    int v4 = 1;
  }

  else
  {
    int v2 = (pthread_mutex_t *)(a1 + 16);
    uint64_t v3 = (pthread_cond_t *)(a1 + 80);
    int v4 = 1;
    do
    {
      if (pthread_mutex_lock(v2)) {
        goto LABEL_8;
      }
      while (1)
      {
        int v5 = *(_DWORD *)(a1 + 8);
        if (v5 > 0) {
          break;
        }
        if (pthread_cond_wait(v3, v2)) {
          goto LABEL_8;
        }
      }

      *(_DWORD *)(a1 + 8) = v5 - 1;
      if (pthread_mutex_unlock(v2)) {
LABEL_8:
      }
        int v4 = 0;
      unint64_t v6 = *(void *)(a1 + 272);
      unint64_t v7 = *(void *)(a1 + 280) + 1LL;
      *(void *)(a1 + 280) = v7;
    }

    while (v7 < v6);
  }

  if (v4) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

int64x2_t *thread_pool_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (int64x2_t *)calloc(1uLL, 0x138uLL);
  if (v6)
  {
    v6->i64[0] = (uint64_t)malloc(8 * a3);
    unint64_t v7 = calloc(1uLL, 16 * a3);
    v6[16].i64[1] = (uint64_t)v7;
    if (v6->i64[0] && v7 != 0LL)
    {
      v6->i32[2] = 0;
      if (!pthread_mutex_init((pthread_mutex_t *)&v6[1], 0LL) && !pthread_cond_init((pthread_cond_t *)&v6[5], 0LL))
      {
        v6[8].i32[0] = 0;
        if (!pthread_mutex_init((pthread_mutex_t *)&v6[8].u64[1], 0LL)
          && !pthread_cond_init((pthread_cond_t *)&v6[12].u64[1], 0LL))
        {
          v6[15].i64[1] = a2;
          v6[16].i64[0] = a1;
          if (!a3) {
            return v6;
          }
          uint64_t v10 = 0LL;
          int64x2_t v11 = vdupq_n_s64(1uLL);
          while ((create_thread((pthread_t *)(v6->i64[0] + v10), (void *(__cdecl *)(void *))thread_pool_entry, v6, 0LL) & 0x80000000) == 0)
          {
            v6[17] = vaddq_s64(v6[17], v11);
            v10 += 8LL;
            if (!--a3) {
              return v6;
            }
          }
        }
      }
    }
  }

  thread_pool_destroy((uint64_t)v6);
  return 0LL;
}

uint64_t thread_pool_entry(uint64_t a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 136);
  uint64_t v3 = (pthread_cond_t *)(a1 + 200);
  int v4 = (unint64_t *)(a1 + 296);
  int v5 = (unsigned int *)(a1 + 304);
  unint64_t v6 = (pthread_mutex_t *)(a1 + 16);
  unint64_t v7 = (pthread_cond_t *)(a1 + 80);
  do
  {
    if (pthread_mutex_lock(v2)) {
      break;
    }
    while (1)
    {
      int v8 = *(_DWORD *)(a1 + 128);
      if (v8 > 0) {
        break;
      }
      if (pthread_cond_wait(v3, v2)) {
        return a1;
      }
    }

    *(_DWORD *)(a1 + 128) = v8 - 1;
    if (pthread_mutex_unlock(v2)) {
      break;
    }
    do
      unint64_t v9 = __ldaxr(v4);
    while (__stlxr(v9 + 1, v4));
    uint64_t v10 = *(void *)(a1 + 264);
    unint64_t v11 = v9 % (2LL * *(void *)(a1 + 272));
    *(void *)(v10 + 8LL * (int)v11) = 0LL;
    if (((*(uint64_t (**)(void))(a1 + 248))(*(void *)(a1 + 256)) & 0x80000000) != 0)
    {
      do
        unsigned int v12 = __ldxr(v5);
      while (__stxr(v12 + 1, v5));
    }

    if (pthread_mutex_lock(v6)) {
      break;
    }
    int v13 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v13 + 1;
    if (!v13)
    {
      if (pthread_cond_broadcast(v7)) {
        break;
      }
    }
  }

  while (!pthread_mutex_unlock(v6));
  return a1;
}

uint64_t thread_pool_destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 272))
    {
      unint64_t v2 = 0LL;
      do
      {
        thread_pool_send_task(v1, 0LL);
        ++v2;
        unint64_t v3 = *(void *)(v1 + 272);
      }

      while (v2 < v3);
      if (v3)
      {
        unint64_t v4 = 0LL;
        do
          join_thread(*(_opaque_pthread_t **)(*(void *)v1 + 8 * v4++));
        while (v4 < *(void *)(v1 + 272));
      }
    }

    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 16))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 80));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 136))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 200));
    }
    unsigned int v5 = atomic_load((unsigned int *)(v1 + 304));
    free(*(void **)v1);
    free(*(void **)(v1 + 264));
    free((void *)v1);
    if (v5) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t lzvnStreamDecodeStateSize()
{
  return 524544LL;
}

uint64_t lzvnStreamDecodeInit(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unint64_t v4 = *(_DWORD **)(a1 + 32);
  }

  else
  {
    unint64_t v4 = 0LL;
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  unsigned int v5 = realloc_stream_state(v4, 1, a2, 0x80100u, 0x80078u);
  *(void *)(a1 + 32) = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = v5;
  uint64_t result = 0LL;
  v6[2] = v6 + 32;
  v6[3] = v6 + 32800;
  v6[6] = v6 + 32;
  v6[7] = v6 + 32;
  v6[8] = v6 + 32800;
  v6[9] = v6 + 32800;
  v6[10] = v6 + 65568;
  v6[11] = v6 + 32800;
  return result;
}

uint64_t lzvnStreamDecode(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ((a2 & 1) != 0) {
    *(_DWORD *)(v3 + 32) = 1;
  }
  int v4 = 1;
  do
  {
    if (*(_DWORD *)(v3 + 36))
    {
      int64_t v5 = 0LL;
    }

    else
    {
      unint64_t v6 = *(void **)(v3 + 56);
      unint64_t v7 = *(void *)(a1 + 24);
      if (v7 >= *(void *)(v3 + 16) - (void)v6 + 0x40000LL) {
        int64_t v5 = *(void *)(v3 + 16) - (void)v6 + 0x40000LL;
      }
      else {
        int64_t v5 = *(void *)(a1 + 24);
      }
      if (v5 >= 1)
      {
        memcpy(v6, *(const void **)(a1 + 16), v5);
        *(void *)(v3 + 56) += v5;
        unint64_t v7 = *(void *)(a1 + 24) - v5;
        *(void *)(a1 + 16) += v5;
        *(void *)(a1 + 24) = v7;
      }

      if (!v7 && *(_DWORD *)(v3 + 32)) {
        *(_DWORD *)(v3 + 36) = 1;
      }
    }

    unint64_t v8 = *(void *)(v3 + 88);
    if (v8 >= *(void *)(v3 + 24) + 0x20000LL)
    {
      unint64_t v9 = *(_BYTE **)(v3 + 64);
      unint64_t v10 = *(void *)(v3 + 72);
      unint64_t v11 = v8 >= (unint64_t)(v9 - 0x10000) ? v9 - 0x10000 : *(char **)(v3 + 88);
      if ((unint64_t)v11 > v10)
      {
        if (v9 != v11)
        {
          memmove(*(void **)(v3 + 72), v11, v9 - v11);
          unint64_t v8 = *(void *)(v3 + 88);
          unint64_t v9 = *(_BYTE **)(v3 + 64);
        }

        *(void *)(v3 + 88) = v8 + v10 - (void)v11;
        *(void *)(v3 + 64) = &v9[v10 - (void)v11];
      }
    }

    if (*(_DWORD *)(v3 + 40) || *(void *)(v3 + 64) >= *(void *)(v3 + 80))
    {
      int v12 = 0;
    }

    else
    {
      int v12 = lzvnDecode(v3 + 48);
      if (v12 == -3) {
        int v4 = 0;
      }
      if (*(_DWORD *)(v3 + 128)) {
        *(_DWORD *)(v3 + 40) = 1;
      }
    }

    if (*(_DWORD *)(v3 + 44)) {
      goto LABEL_44;
    }
    int v13 = *(const void **)(v3 + 88);
    if (*(void *)(a1 + 8) >= *(void *)(v3 + 64) - (void)v13) {
      int64_t v14 = *(void *)(v3 + 64) - (void)v13;
    }
    else {
      int64_t v14 = *(void *)(a1 + 8);
    }
    if (v14 >= 1)
    {
      memcpy(*(void **)a1, v13, v14);
      int v13 = (const void *)(*(void *)(v3 + 88) + v14);
      *(void *)(v3 + 88) = v13;
      int64_t v15 = *(void *)(a1 + 8) - v14;
      *(void *)a1 += v14;
      *(void *)(a1 + 8) = v15;
    }

    if (*(_DWORD *)(v3 + 40) && v13 == *(const void **)(v3 + 64))
    {
      *(_DWORD *)(v3 + 44) = 1;
      if (v4) {
        return *(_DWORD *)(v3 + 44) != 0;
      }
      return 0xFFFFFFFFLL;
    }

    if (*(_DWORD *)(v3 + 44)) {
      goto LABEL_44;
    }
    int v16 = *(char **)(v3 + 48);
    uint64_t v17 = *(char **)(v3 + 16);
    if (v16 >= v17 + 0x20000)
    {
      uint64_t v18 = *(void *)(v3 + 56);
      uint64_t v19 = v18 - (void)v16;
      if (v18 - (uint64_t)v16 >= 1)
      {
        memmove(v17, v16, v18 - (void)v16);
        uint64_t v17 = *(char **)(v3 + 16);
      }

      *(void *)(v3 + 48) = v17;
      *(void *)(v3 + 56) = &v17[v19];
    }
  }

  while (v14 | v5);
  if (v12 != -1)
  {
LABEL_44:
    if (v4) {
      return *(_DWORD *)(v3 + 44) != 0;
    }
    return 0xFFFFFFFFLL;
  }

  uint64_t result = 0xFFFFFFFFLL;
  if (!*(_DWORD *)(v3 + 36) && v4) {
    return *(_DWORD *)(v3 + 44) != 0;
  }
  return result;
}

uint64_t touchpadCodecDecodeImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v6 = *(unsigned int *)(a1 + 664);
  uint64_t v77 = *(unsigned int *)(a1 + 668);
  uint64_t v91 = 0LL;
  unint64_t v92 = 0LL;
  uint64_t v88 = a4;
  unint64_t v89 = a5;
  unint64_t v90 = 0LL;
  unsigned __int8 v75 = v84;
  if ((v84 & 1) != 0)
  {
    if (*(_DWORD *)(a1 + 664) != v85 || *(_DWORD *)(a1 + 668) != v86 || v87 != *(_BYTE *)(a1 + 672)) {
      return 0LL;
    }
    codecResetModel(a1);
  }

  if ((_DWORD)v77)
  {
    unsigned int v7 = 0;
    uint64_t v8 = 0LL;
    unint64_t v9 = v90;
    uint64_t v10 = v91;
    uint64_t v74 = *(void *)(a1 + 632);
    unsigned int v11 = v92;
    int v12 = HIDWORD(v92);
    while (1)
    {
      uint64_t v13 = -(uint64_t)v6;
      if ((v75 & (v8 != 0)) == 0) {
        uint64_t v13 = 0LL;
      }
      unsigned int v79 = v7;
      uint64_t v78 = v8;
      if ((_DWORD)v6) {
        break;
      }
LABEL_99:
      uint64_t v8 = v78 + 1;
      a2 += a3;
      unsigned int v7 = v79 + v6;
      if (v78 + 1 == v77) {
        goto LABEL_102;
      }
    }

    uint64_t v14 = 0LL;
    int v15 = *(__int16 *)(v74 + 2LL * (v6 * v8) + 2 * v13);
    unint64_t v16 = v89;
    uint64_t v81 = v88;
    uint64_t v82 = v74 + 2LL * v7;
    uint64_t v80 = v82 + 2 * v13;
    int v17 = v15;
    int v18 = v15;
    uint64_t v19 = v10;
    while (1)
    {
      int v20 = v15;
      uint64_t v21 = v14 + 1;
      if (v14 + 1 < v6) {
        int v15 = *(__int16 *)(v80 + 2 * v14 + 2);
      }
      int v22 = v17 - v18;
      if (v17 - v18 <= -2) {
        int v23 = -2;
      }
      else {
        int v23 = 0;
      }
      if (v22 > 1) {
        int v23 = 2;
      }
      if (v22 < -40) {
        int v23 = -1;
      }
      if (v22 > 40) {
        int v23 = 1;
      }
      int v24 = 25 * v23;
      int v25 = v18 - v20;
      if (v25 <= -2) {
        int v26 = -2;
      }
      else {
        int v26 = 0;
      }
      if (v25 > 1) {
        int v26 = 2;
      }
      if (v25 < -40) {
        int v26 = -1;
      }
      if (v25 <= 40) {
        int v27 = v26;
      }
      else {
        int v27 = 1;
      }
      int v28 = 5 * v27 + v24;
      int v29 = v20 - v15;
      if (v20 - v15 <= -2) {
        int v30 = -2;
      }
      else {
        int v30 = 0;
      }
      if (v29 > 1) {
        int v30 = 2;
      }
      if (v29 < -40) {
        int v30 = -1;
      }
      if (v29 <= 40) {
        int v31 = v30;
      }
      else {
        int v31 = 1;
      }
      int v32 = v28 + v31;
      int v33 = v22 + v20;
      if (v22 + v20 <= v17) {
        int v34 = v17;
      }
      else {
        int v34 = v22 + v20;
      }
      if (v33 < v17) {
        int v17 = v33;
      }
      if (v34 >= v20) {
        int v35 = v20;
      }
      else {
        int v35 = v34;
      }
      if (v17 <= v35) {
        __int16 v36 = v35;
      }
      else {
        __int16 v36 = v17;
      }
      if (v32 >= 0) {
        unsigned int v37 = v32;
      }
      else {
        unsigned int v37 = -v32;
      }
      if (v12 <= 15)
      {
        unint64_t v38 = v9 + 1;
        unint64_t v90 = v9 + 1;
        if (v9 < v16)
        {
          uint64_t v10 = v19 + 1;
          uint64_t v91 = v19 + 1;
          v11 |= *(unsigned __int8 *)(v81 + v19) << v12;
          v12 += 8;
          unint64_t v92 = __PAIR64__(v12, v11);
          ++v19;
        }

        v9 += 2LL;
        unint64_t v90 = v9;
        if (v38 < v16)
        {
          uint64_t v10 = v19 + 1;
          uint64_t v91 = v19 + 1;
          v11 |= *(unsigned __int8 *)(v81 + v19) << v12;
          v12 += 8;
          ++v19;
        }
      }

      uint64_t v39 = a1 + 10LL * v37;
      int v40 = *(unsigned __int8 *)(v39 + 8);
      unsigned int v41 = __clz(__rbit32((unsigned __int16)v11 | 0x10000));
      if (v41 > 0xF)
      {
        unsigned int v46 = HIWORD(v11);
        int v47 = v12 - 16;
        LODWORD(v92) = HIWORD(v11);
        HIDWORD(v92) = v12 - 16;
        if (v12 <= 31)
        {
          unint64_t v48 = v9 + 1;
          unint64_t v90 = v9 + 1;
          if (v9 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v91 = v19 + 1;
            v46 |= *(unsigned __int8 *)(v81 + v19) << v47;
            int v47 = v12 - 8;
            LODWORD(v92) = v46;
            HIDWORD(v92) = v12 - 8;
            ++v19;
          }

          v9 += 2LL;
          unint64_t v90 = v9;
          if (v48 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v91 = v19 + 1;
            v46 |= *(unsigned __int8 *)(v81 + v19) << v47;
            v47 += 8;
            ++v19;
          }
        }

        unsigned int v11 = HIWORD(v46);
        int v12 = v47 - 16;
        LODWORD(v92) = HIWORD(v46);
        HIDWORD(v92) = v47 - 16;
      }

      else
      {
        unsigned int v42 = v11 >> (v41 + 1);
        int v43 = v12 - (v41 + 1);
        unint64_t v92 = __PAIR64__(v43, v42);
        if (v43 <= 15)
        {
          unint64_t v44 = v9 + 1;
          unint64_t v90 = v9 + 1;
          if (v9 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v91 = v19 + 1;
            v42 |= *(unsigned __int8 *)(v81 + v19) << v43;
            v43 += 8;
            unint64_t v92 = __PAIR64__(v43, v42);
            ++v19;
          }

          v9 += 2LL;
          unint64_t v90 = v9;
          if (v44 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v91 = v19 + 1;
            v42 |= *(unsigned __int8 *)(v81 + v19) << v43;
            v43 += 8;
            ++v19;
          }
        }

        int v45 = v42 & ((-1 << v40) ^ 0xFFFF);
        unsigned int v11 = v42 >> v40;
        int v12 = v43 - v40;
        unint64_t v92 = __PAIR64__(v12, v11);
        unsigned int v46 = v45 + (v41 << v40);
      }

      int v49 = *(_DWORD *)(v39 + 4);
      int v50 = ((unsigned __int16)v46 >> 1) ^ -(v46 & 1);
      int v51 = *(_DWORD *)v39;
      uint64_t v52 = a1 + 10LL * v37;
      char v54 = *(_BYTE *)(v52 + 9);
      int v53 = (_BYTE *)(v52 + 9);
      unsigned __int8 v55 = v54 + 1;
      *int v53 = v54 + 1;
      if (v50 >= 0) {
        int v56 = v50;
      }
      else {
        int v56 = -v50;
      }
      if (v50 <= 0)
      {
        if ((v50 & 0x80000000) == 0) {
          goto LABEL_83;
        }
        int v57 = -1;
      }

      else
      {
        int v57 = 1;
      }

      *(_DWORD *)(v39 + 4) = v49 + v57;
LABEL_83:
      int v58 = v56 + v51;
      int v59 = v55;
      int v60 = v55 << v40;
      int v62 = v60 >= 2 * v58 && v40 != 0;
      int v63 = v62 << 31 >> 31;
      if (v60 >= v58) {
        char v64 = v63;
      }
      else {
        char v64 = 1;
      }
      *(_DWORD *)uint64_t v39 = v58;
      *(_BYTE *)(v39 + 8) = v40 + v64;
      if (v59 == 64)
      {
        *int v53 = 32;
        *(_DWORD *)uint64_t v39 = v58 - (v58 >> 1);
      }

      int v65 = (__int16)(v50 + ((v49 + 8) >> 4));
      if (v32 < 0) {
        int v65 = -v65;
      }
      __int16 v66 = v65 + v36;
      *(_WORD *)(a2 + 2 * v14) = v65 + v36;
      int v17 = (__int16)(v65 + v36);
      *(_WORD *)(v82 + 2 * v14++) = v66;
      int v18 = v20;
      if (v6 == v21) {
        goto LABEL_99;
      }
    }
  }

  int v12 = HIDWORD(v92);
LABEL_102:
  if (v12 <= 15)
  {
    unint64_t v67 = v90;
    unint64_t v68 = ++v90;
    if (v67 < v89)
    {
      uint64_t v69 = v91++;
      int v70 = *(unsigned __int8 *)(v88 + v69) << v12;
      v12 += 8;
      LODWORD(v92) = v70 | v92;
      HIDWORD(v92) = v12;
    }

    unint64_t v90 = v67 + 2;
    if (v68 < v89)
    {
      uint64_t v71 = v91++;
      LODWORD(v92) = v92 | (*(unsigned __int8 *)(v88 + v71) << v12);
      v12 += 8;
    }
  }

  int v72 = v92 & 0xFFF;
  LODWORD(v92) = v92 >> 12;
  HIDWORD(v92) = v12 - 12;
  return 0LL;
}

uint64_t zlib_encode_scratch_size()
{
  return 270336LL;
}

Bytef *zlib_encode_buffer( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if ((a4 | a2) >> 32) {
    return 0LL;
  }
  int v9 = a4;
  int v11 = a2;
  v20[0] = a5;
  v20[1] = 270336LL;
  uint64_t v13 = zlib_malloc(v20, 1u, 0x70u);
  uint64_t v14 = (z_stream *)v13;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(_OWORD *)(v13 + 8) = 0u;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 88) = 0u;
  *(void *)(v13 + 104) = 0LL;
  *(void *)(v13 + 64) = zlib_malloc;
  *(void *)(v13 + 72) = zlib_free;
  *(void *)(v13 + 80) = v20;
  *(_DWORD *)(v13 + 8) = v9;
  *(void *)uint64_t v13 = a3;
  *(_DWORD *)(v13 + 32) = v11;
  if (a7) {
    int v15 = 15;
  }
  else {
    int v15 = -15;
  }
  *(void *)(v13 + 24) = a1;
  int v16 = deflateInit2_((z_streamp)v13, a6, 8, v15, 8, 0, "1.2.5", 112);
  uint64_t result = 0LL;
  if (!v16)
  {
    int v18 = deflate(v14, 4);
    int v19 = deflateEnd(v14);
    uint64_t result = 0LL;
    if (!v19 && v18 == 1) {
      return &v14->next_out[-a1];
    }
  }

  return result;
}

double BrotliInitBlockSplit(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t BrotliDestroyBlockSplit(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 16) = 0LL;
  uint64_t result = BrotliFree(a1, *(void *)(a2 + 24));
  *(void *)(a2 + 24) = 0LL;
  return result;
}

uint64_t BrotliSplitBlock( uint64_t result, uint64_t a2, size_t a3, uint64_t a4, size_t a5, size_t a6, int *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  size_t v11 = a3;
  int v12 = (_DWORD *)result;
  uint64_t v620 = *MEMORY[0x1895F89C0];
  uint64_t v543 = result;
  if (!a3)
  {
    int v20 = (_DWORD *)(result + 24);
    if (*(_DWORD *)(result + 24)) {
      return result;
    }
    v551 = 0LL;
    goto LABEL_28;
  }

  size_t v16 = 0LL;
  int v17 = (unsigned int *)a2;
  size_t v18 = a3;
  do
  {
    unsigned int v19 = *v17;
    v17 += 4;
    v16 += v19;
    --v18;
  }

  while (v18);
  if (v16)
  {
    uint64_t result = BrotliAllocate(result);
    v551 = (char *)result;
  }

  else
  {
    v551 = 0LL;
  }

  int v22 = v12[6];
  uint64_t v21 = v12 + 6;
  if (v22) {
    return result;
  }
  v504 = a7;
  v534 = v21;
  size_t v23 = v11;
  uint64_t v24 = 0LL;
  size_t v25 = a6 + 1;
  int v26 = (int *)(a2 + 4);
  size_t v518 = v23;
  do
  {
    size_t v27 = a5 & a6;
    size_t v28 = *(v26 - 1);
    if (v27 + v28 > a6)
    {
      uint64_t v29 = v25 - v27;
      uint64_t result = (uint64_t)memcpy(&v551[v24], (const void *)(a4 + v27), v25 - v27);
      size_t v27 = 0LL;
      v24 += v29;
      v28 -= v29;
    }

    if (v28)
    {
      uint64_t result = (uint64_t)memcpy(&v551[v24], (const void *)(a4 + v27), v28);
      v24 += v28;
    }

    int v30 = *v26;
    v26 += 4;
    a5 = v28 + v27 + (v30 & 0x1FFFFFF);
    --v23;
  }

  while (v23);
  if (v16 >> 7 <= 0x1A8) {
    unint64_t v31 = (unsigned __int16)v16 / 0x220u + 1;
  }
  else {
    unint64_t v31 = 100LL;
  }
  if (!v16)
  {
    int v20 = v534;
    a7 = v504;
    size_t v11 = v518;
LABEL_28:
    *(void *)a8 = 1LL;
    goto LABEL_29;
  }

  a7 = v504;
  size_t v11 = v518;
  if (v16 > 0x7F)
  {
    uint64_t result = BrotliAllocate(v543);
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    unsigned int v41 = (_DWORD *)result;
    uint64_t v42 = 0LL;
    do
    {
      bzero(&v41[v42], 0x408uLL);
      *(void *)&v41[v42 + 258] = 0x7FF0000000000000LL;
      v42 += 260LL;
    }

    while (260 * v31 != v42);
    uint64_t v43 = 0LL;
    LODWORD(v44) = 7;
    do
    {
      size_t v45 = v43 * v16 / v31;
      if (v43)
      {
        unint64_t v44 = (16807 * v44);
        v45 += v44 % (v16 / v31);
      }

      uint64_t v46 = 0LL;
      if (v45 + 70 >= v16) {
        size_t v47 = v16 - 71;
      }
      else {
        size_t v47 = v45;
      }
      unint64_t v48 = &v41[260 * v43];
      int v49 = &v551[v47];
      *((void *)v48 + 128) += 70LL;
      do
        ++v48[v49[v46++]];
      while (v46 != 70);
      ++v43;
    }

    while (v43 != v31);
    unint64_t v50 = v31 + 2 * v16 / 0x46 + 99 - (v31 + 2 * v16 / 0x46 + 99) % v31;
    if (v50)
    {
      unint64_t v51 = 0LL;
      if (v50 <= 1) {
        unint64_t v52 = 1LL;
      }
      else {
        unint64_t v52 = v31 + 2 * v16 / 0x46 + 99 - (v31 + 2 * v16 / 0x46 + 99) % v31;
      }
      LODWORD(v53) = 7;
      do
      {
        bzero(v555, 0x408uLL);
        unint64_t v53 = (16807 * v53);
        char v54 = &v551[v53 % (v16 - 69)];
        uint64_t v55 = -70LL;
        do
        {
          unsigned int v56 = *v54++;
          ++*((_DWORD *)v555 + v56);
          BOOL v57 = __CFADD__(v55++, 1LL);
        }

        while (!v57);
        uint64_t v58 = 0LL;
        uint64_t v59 = 0LL;
        int v60 = &v41[260 * (v51 % v31)];
        *((void *)v60 + 128) += 70LL;
        do
        {
          *(int32x4_t *)&v60[v59] = vaddq_s32(*(int32x4_t *)&v60[v59], *(int32x4_t *)&v555[v58]);
          v59 += 4LL;
          v58 += 2LL;
        }

        while (v58 != 128);
        ++v51;
      }

      while (v51 != v52);
    }

    v507 = (char *)BrotliAllocate(v543);
    unint64_t v61 = (char *)BrotliAllocate(v543);
    int v62 = (void *)BrotliAllocate(v543);
    if (((v31 + 7) >> 3) * v16) {
      int v63 = (char *)BrotliAllocate(v543);
    }
    else {
      int v63 = 0LL;
    }
    uint64_t result = BrotliAllocate(v543);
    uint64_t v101 = 10LL;
    if (v504[1] <= 10) {
      uint64_t v101 = 3LL;
    }
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    __b = (void *)result;
    unint64_t v102 = 0LL;
    v485 = v41 + 256;
    size_t v490 = v16 - 1;
    v481 = v41 + 255;
    unsigned int v103 = (unsigned __int8 *)v507;
    int v104 = v551;
    v511 = v41;
    v493 = (char *)v101;
    v473 = v507 - 2;
    do
    {
      __srca = v102;
      if (v31 > 1)
      {
        bzero(v61, v31 << 11);
        uint64_t v107 = 0LL;
        unsigned int v108 = v485;
        do
        {
          unint64_t v109 = *v108;
          if (v109 > 0xFF) {
            double v110 = log2((double)v109);
          }
          else {
            double v110 = kBrotliLog2Table[v109];
          }
          v108 += 260;
          *(double *)&v61[8 * v107++] = v110;
        }

        while (v31 != v107);
        unint64_t v527 = (v31 + 7) >> 3;
        unint64_t v111 = &v61[2040 * v31];
        unint64_t v112 = v481;
        uint64_t v113 = 256LL;
        do
        {
          uint64_t v114 = 0LL;
          --v113;
          unint64_t v115 = v112;
          do
          {
            double v116 = *(double *)&v61[8 * v114];
            uint64_t v117 = *v115;
            if ((_DWORD)v117)
            {
              else {
                double v118 = kBrotliLog2Table[v117];
              }
            }

            else
            {
              double v118 = -2.0;
            }

            v115 += 260;
            *(double *)&v111[8 * v114++] = v116 - v118;
          }

          while (v31 != v114);
          v111 -= 8 * v31;
          --v112;
        }

        while (v113);
        bzero(v62, 8 * v31);
        bzero(v63, v527 * v16);
        unint64_t v119 = 0LL;
        int v104 = v551;
        unsigned int v103 = (unsigned __int8 *)v507;
        do
        {
          uint64_t v120 = 0LL;
          unint64_t v121 = &v61[8 * v31 * v551[v119]];
          double v122 = 1.0e99;
          do
          {
            double v123 = *(double *)&v121[8 * v120] + *((double *)v62 + v120);
            *((double *)v62 + v120) = v123;
            if (v123 < v122)
            {
              v507[v119] = v120;
              double v122 = v123;
            }

            ++v120;
          }

          while (v31 != v120);
          double v124 = 28.1;
          if (v119 <= 0x7CF) {
            double v124 = ((double)v119 * 0.07 / 2000.0 + 0.77) * 28.1;
          }
          for (unint64_t i = 0LL; i != v31; ++i)
          {
            double v126 = *((double *)v62 + i) - v122;
            *((double *)v62 + i) = v126;
            if (v126 >= v124)
            {
              *((double *)v62 + i) = v124;
              v63[v119 * v527 + (i >> 3)] |= 1 << (i & 7);
            }
          }

          ++v119;
        }

        while (v119 != v16);
        unsigned int v127 = v507[v490];
        uint64_t v128 = &v63[(v16 - 2) * v527];
        size_t v129 = v16;
        unint64_t v105 = 1LL;
        uint64_t v106 = __b;
        do
        {
          if (((v128[(unint64_t)v127 >> 3] >> (v127 & 7)) & 1) != 0)
          {
            unsigned int v127 = v473[v129];
          }

          v128 -= v527;
          v473[v129--] = v127;
        }

        while (v129 != 1);
      }

      else
      {
        bzero(v103, v16);
        unint64_t v105 = 1LL;
        uint64_t v106 = __b;
      }

      if (v31) {
        memset_pattern16(v106, &unk_181095120, 2 * v31);
      }
      uint64_t v130 = 0LL;
      unsigned __int16 v131 = 0;
      do
      {
        uint64_t v132 = v103[v130];
        if (*((_WORD *)v106 + v132) == 256) {
          *((_WORD *)v106 + v132) = v131++;
        }
        ++v130;
      }

      while (v16 != v130);
      v528 = (char *)v105;
      for (uint64_t j = 0LL; j != v16; ++j)
        v103[j] = *((_WORD *)v106 + v103[j]);
      unint64_t v31 = v131;
      if (v131)
      {
        unint64_t v134 = v511;
        uint64_t v135 = v131;
        do
        {
          bzero(v134, 0x408uLL);
          v134[129] = 0x7FF0000000000000LL;
          v134 += 130;
          --v135;
        }

        while (v135);
      }

      uint64_t v136 = 0LL;
      unsigned int v103 = (unsigned __int8 *)v507;
      do
      {
        uint64_t v137 = (char *)&v511[130 * v507[v136]];
        ++*(_DWORD *)&v137[4 * v104[v136]];
        ++*((void *)v137 + 128);
        ++v136;
      }

      while (v16 != v136);
      unint64_t v102 = __srca + 1;
    }

    while (__srca + 1 != v493);
    BrotliFree(v543, (unint64_t)v61);
    BrotliFree(v543, (unint64_t)v62);
    BrotliFree(v543, (unint64_t)v63);
    BrotliFree(v543, (unint64_t)__b);
    BrotliFree(v543, (unint64_t)v511);
    if (v105)
    {
      v465 = (_DWORD *)BrotliAllocate(v543);
      uint64_t v138 = (unsigned int *)BrotliAllocate(v543);
      unint64_t v139 = 16 * v105 + 1008;
      uint64_t v140 = v139 >> 6;
      if (v139 < 0x40)
      {
        unint64_t v141 = (char *)(v139 >> 6);
        __srcb = 0LL;
        v477 = 0LL;
        goto LABEL_180;
      }
    }

    else
    {
      v465 = 0LL;
      uint64_t v138 = 0LL;
      uint64_t v140 = 15LL;
    }

    __srcb = (char *)BrotliAllocate(v543);
    unint64_t v141 = (char *)v140;
    v477 = (void *)BrotliAllocate(v543);
LABEL_180:
    uint64_t v142 = 64LL;
    if (v105 < 0x40) {
      uint64_t v142 = v105;
    }
    if (v142) {
      uint64_t v143 = BrotliAllocate(v543);
    }
    else {
      uint64_t v143 = 0LL;
    }
    uint64_t result = BrotliAllocate(v543);
    __dst = (unsigned int *)result;
    __int128 v619 = 0u;
    __int128 v618 = 0u;
    __int128 v617 = 0u;
    __int128 v616 = 0u;
    __int128 v615 = 0u;
    __int128 v614 = 0u;
    __int128 v613 = 0u;
    __int128 v612 = 0u;
    __int128 v611 = 0u;
    __int128 v610 = 0u;
    __int128 v609 = 0u;
    __int128 v608 = 0u;
    __int128 v607 = 0u;
    __int128 v606 = 0u;
    __int128 v605 = 0u;
    __int128 v604 = 0u;
    __int128 v603 = 0u;
    __int128 v602 = 0u;
    __int128 v601 = 0u;
    __int128 v600 = 0u;
    __int128 v599 = 0u;
    __int128 v598 = 0u;
    __int128 v597 = 0u;
    __int128 v596 = 0u;
    __int128 v595 = 0u;
    __int128 v594 = 0u;
    __int128 v593 = 0u;
    __int128 v592 = 0u;
    __int128 v591 = 0u;
    __int128 v590 = 0u;
    __int128 v589 = 0u;
    __int128 v588 = 0u;
    __int128 v587 = 0u;
    __int128 v586 = 0u;
    __int128 v585 = 0u;
    __int128 v584 = 0u;
    __int128 v583 = 0u;
    __int128 v582 = 0u;
    __int128 v581 = 0u;
    __int128 v580 = 0u;
    __int128 v579 = 0u;
    __int128 v578 = 0u;
    __int128 v577 = 0u;
    __int128 v576 = 0u;
    __int128 v575 = 0u;
    __int128 v574 = 0u;
    __int128 v573 = 0u;
    __int128 v572 = 0u;
    __int128 v571 = 0u;
    __int128 v570 = 0u;
    __int128 v569 = 0u;
    __int128 v568 = 0u;
    __int128 v567 = 0u;
    __int128 v566 = 0u;
    __int128 v565 = 0u;
    __int128 v564 = 0u;
    __int128 v563 = 0u;
    __int128 v562 = 0u;
    __int128 v561 = 0u;
    __int128 v560 = 0u;
    __int128 v559 = 0u;
    __int128 v558 = 0u;
    __int128 v557 = 0u;
    __int128 v556 = 0u;
    int v20 = v534;
    if (*(_DWORD *)(v543 + 24)) {
      goto LABEL_186;
    }
    unint64_t v144 = (unint64_t)v141;
    bzero(v138, 4 * v105);
    uint64_t v145 = 0LL;
    for (uint64_t k = 0LL; k != v16; ++k)
    {
      ++v138[v145];
      if (v490 == k || v507[k] != v507[k + 1]) {
        ++v145;
      }
    }

    unint64_t v147 = (char *)v105;
    if (v105)
    {
      uint64_t v491 = 0LL;
      uint64_t v494 = 0LL;
      unint64_t v148 = 0LL;
      unint64_t v149 = 0LL;
      uint64_t v150 = 0LL;
      v482 = v141;
      v486 = v465;
      unint64_t v151 = v105;
      while (1)
      {
        unint64_t v474 = v149;
        unint64_t v470 = v151 - 64;
        if (v151 >= 0x40) {
          uint64_t v152 = 64LL;
        }
        else {
          uint64_t v152 = v151;
        }
        v545 = v148;
        uint64_t v153 = v147 - v148;
        __ba = (void *)v153;
        if (v153)
        {
          uint64_t v154 = 0LL;
          do
          {
            unint64_t v155 = (void *)(v143 + 1040 * v154);
            bzero(v155, 0x408uLL);
            v155[129] = 0x7FF0000000000000LL;
            if (v138[(void)&v545[v154]])
            {
              unint64_t v156 = 0LL;
              do
              {
                ++*((_DWORD *)v155 + v551[v150 + v156++]);
                v155[128] = v156;
              }

              while (v156 < v138[(void)&v545[v154]]);
              v150 += v156;
            }

            BrotliPopulationCostLiteral(v143 + 1040 * v154);
            v155[129] = v157;
            *((_DWORD *)&v588 + v154) = v154;
            *((_DWORD *)&v572 + v154) = v154;
            *((_DWORD *)&v604 + v154++) = 1;
          }

          while (v154 != v152);
        }

        uint64_t result = BrotliHistogramCombineLiteral( v143,  (uint64_t)&v604,  &v572,  &v588,  __dst,  (unint64_t)__ba,  (uint64_t)__ba,  0x40uLL,  0x800uLL);
        unint64_t v158 = (char *)result;
        if (v144 < result + v494)
        {
          if (v144) {
            uint64_t v159 = v144;
          }
          else {
            uint64_t v159 = result + v494;
          }
          do
          {
            unint64_t v160 = (char *)v159;
            v159 *= 2LL;
          }

          while ((unint64_t)v160 < result + v494);
          if (v160) {
            uint64_t v161 = (char *)BrotliAllocate(v543);
          }
          else {
            uint64_t v161 = 0LL;
          }
          if (*v534) {
            BOOL v162 = 1;
          }
          else {
            BOOL v162 = v144 == 0;
          }
          if (!v162) {
            memcpy(v161, __srcb, 1040 * v144);
          }
          uint64_t result = BrotliFree(v543, (unint64_t)__srcb);
          __srcb = v161;
          unint64_t v144 = (unint64_t)v160;
        }

        uint64_t v163 = v482;
        if (v482 < &v158[v491])
        {
          if (v482) {
            uint64_t v164 = (uint64_t)v482;
          }
          else {
            uint64_t v164 = (uint64_t)&v158[v491];
          }
          do
          {
            unint64_t v165 = (char *)v164;
            v164 *= 2LL;
          }

          while (v165 < &v158[v491]);
          if (v165)
          {
            uint64_t v166 = BrotliAllocate(v543);
            uint64_t v163 = v482;
            uint64_t v167 = (void *)v166;
          }

          else
          {
            uint64_t v167 = 0LL;
          }

          if (*v534) {
            BOOL v168 = 1;
          }
          else {
            BOOL v168 = v163 == 0LL;
          }
          if (!v168) {
            memcpy(v167, v477, 4LL * (void)v163);
          }
          uint64_t result = BrotliFree(v543, (unint64_t)v477);
          v477 = v167;
          uint64_t v163 = v165;
        }

        int v20 = v534;
        if (*v534) {
          goto LABEL_186;
        }
        v482 = v163;
        if (v158)
        {
          unint64_t v169 = 0LL;
          unint64_t v170 = &__srcb[1040 * v494];
          do
          {
            uint64_t v171 = *((unsigned int *)&v588 + (void)v169);
            memcpy(v170, (const void *)(v143 + 1040LL * v171), 0x410uLL);
            *((_DWORD *)v477 + v491 + (void)v169) = *((_DWORD *)&v604 + v171);
            *((_DWORD *)&v556 + *((unsigned int *)&v588 + (void)v169)) = (_DWORD)v169;
            ++v169;
            v170 += 1040;
          }

          while (v158 != v169);
          v494 += (uint64_t)v169;
          v491 += (uint64_t)v169;
        }

        if (__ba)
        {
          unint64_t v172 = (unsigned int *)&v572;
          unint64_t v173 = v486;
          do
          {
            unsigned int v174 = *v172++;
            *v173++ = *((_DWORD *)&v556 + v174) + v474;
            --v152;
          }

          while (v152);
        }

        unint64_t v149 = (unint64_t)&v158[v474];
        unint64_t v148 = v545 + 64;
        v486 += 64;
        unint64_t v151 = v470;
        unint64_t v147 = v528;
        if (v545 + 64 >= v528) {
          goto LABEL_320;
        }
      }
    }

    unint64_t v149 = 0LL;
LABEL_320:
    uint64_t v223 = v543;
    unint64_t v224 = v149;
    uint64_t result = BrotliFree(v543, v143);
    if (v224 << 6 >= (v224 >> 1) * v224) {
      unint64_t v225 = (v224 >> 1) * v224;
    }
    else {
      unint64_t v225 = v224 << 6;
    }
    if (v225 < 0x801)
    {
      unint64_t v226 = v224;
      int v20 = v534;
    }

    else
    {
      BrotliFree(v543, (unint64_t)__dst);
      uint64_t result = BrotliAllocate(v543);
      __dst = (unsigned int *)result;
      int v20 = v534;
      if (*(_DWORD *)(v543 + 24)) {
        goto LABEL_186;
      }
      uint64_t v223 = v543;
      unint64_t v226 = v224;
    }

    if (v226)
    {
      uint64_t result = BrotliAllocate(v223);
      int v20 = v534;
      if (*(_DWORD *)(v223 + 24)) {
        goto LABEL_186;
      }
      unint64_t v227 = (unsigned int *)result;
      uint64_t v228 = 0LL;
      do
      {
        *(_DWORD *)(result + 4 * v228) = v228;
        ++v228;
      }

      while (v224 != v228);
    }

    else
    {
      if (*v20) {
        goto LABEL_186;
      }
      unint64_t v227 = 0LL;
    }

    v546 = (char *)BrotliHistogramCombineLiteral( (uint64_t)__srcb,  (uint64_t)v477,  v465,  v227,  __dst,  v224,  (uint64_t)v528,  0x100uLL,  v225);
    BrotliFree(v543, (unint64_t)__dst);
    uint64_t result = BrotliFree(v543, (unint64_t)v477);
    if (v224)
    {
      uint64_t result = BrotliAllocate(v543);
      int v20 = v534;
      if (*(_DWORD *)(v543 + 24)) {
        goto LABEL_186;
      }
      unint64_t v229 = result;
      memset((void *)result, 255, 4 * v224);
    }

    else
    {
      int v20 = v534;
      if (*v534) {
        goto LABEL_186;
      }
      unint64_t v229 = 0LL;
    }

    if (v528)
    {
      int v514 = 0;
      v291 = 0LL;
      uint64_t v292 = 0LL;
      do
      {
        bzero(v555, 0x408uLL);
        v555[129] = 0x7FF0000000000000LL;
        if (v138[(void)v291])
        {
          unint64_t v293 = 0LL;
          do
            ++*((_DWORD *)v555 + v551[v292 + v293++]);
          while (v293 < v138[(void)v291]);
          v555[128] = v293;
          v292 += v293;
        }

        unint64_t v294 = v229;
        v295 = (char *)v291 - 1;
        if (!v291) {
          v295 = 0LL;
        }
        uint64_t v296 = v465[(void)v295];
        double v297 = BrotliHistogramBitCostDistanceLiteral(v555, (uint64_t)&__srcb[1040 * v296]);
        v298 = v546;
        if (v546)
        {
          double v299 = v297;
          v300 = v227;
          do
          {
            double v301 = BrotliHistogramBitCostDistanceLiteral(v555, (uint64_t)&__srcb[1040 * *v300]);
            if (v301 < v299)
            {
              uint64_t v296 = *v300;
              double v299 = v301;
            }

            ++v300;
            --v298;
          }

          while (v298);
        }

        v465[(void)v291] = v296;
        unint64_t v229 = v294;
        if (*(_DWORD *)(v294 + 4 * v296) == -1) {
          *(_DWORD *)(v294 + 4 * v296) = v514++;
        }
        v291 = (char *)v291 + 1;
      }

      while (v291 != v528);
    }

    BrotliFree(v543, (unint64_t)v227);
    uint64_t result = BrotliFree(v543, (unint64_t)__srcb);
    unint64_t v302 = *(void *)(a8 + 32);
    v303 = v528;
    if (v302 < (unint64_t)v528)
    {
      if (!v302) {
        unint64_t v302 = (unint64_t)v528;
      }
      do
      {
        unint64_t v304 = v302;
        v302 *= 2LL;
      }

      while (v304 < (unint64_t)v528);
      if (v304) {
        v305 = (void *)BrotliAllocate(v543);
      }
      else {
        v305 = 0LL;
      }
      if (!*v534)
      {
        size_t v318 = *(void *)(a8 + 32);
        if (v318) {
          memcpy(v305, *(const void **)(a8 + 16), v318);
        }
      }

      uint64_t result = BrotliFree(v543, *(void *)(a8 + 16));
      *(void *)(a8 + 16) = v305;
      *(void *)(a8 + 32) = v304;
      v303 = v528;
    }

    unint64_t v319 = *(void *)(a8 + 40);
    BOOL v57 = v319 >= (unint64_t)v303;
    int v20 = v534;
    if (!v57)
    {
      if (!v319) {
        unint64_t v319 = (unint64_t)v528;
      }
      do
      {
        unint64_t v320 = v319;
        v319 *= 2LL;
      }

      while (v320 < (unint64_t)v528);
      if (v320) {
        v321 = (void *)BrotliAllocate(v543);
      }
      else {
        v321 = 0LL;
      }
      if (!*v534)
      {
        uint64_t v322 = *(void *)(a8 + 40);
        if (v322) {
          memcpy(v321, *(const void **)(a8 + 24), 4 * v322);
        }
      }

      uint64_t result = BrotliFree(v543, *(void *)(a8 + 24));
      *(void *)(a8 + 24) = v321;
      *(void *)(a8 + 40) = v320;
      int v20 = v534;
    }

    if (!*v20)
    {
      v323 = v528;
      if (v528)
      {
        unsigned __int8 v324 = 0;
        v323 = 0LL;
        int v325 = 0;
        v326 = v465 + 1;
        v327 = (int *)v138;
        v328 = (void *)a8;
        v329 = v528;
        do
        {
          int v330 = *v327++;
          v325 += v330;
          uint64_t v331 = *(v326 - 1);
          v332 = v329;
          if (v329 == (char *)1 || (_DWORD)v331 != *v326)
          {
            int v333 = *(_DWORD *)(v229 + 4 * v331);
            v323[*(void *)(a8 + 16)] = v333;
            *(_DWORD *)(*(void *)(a8 + 24) + 4LL * (void)v323) = v325;
            ++v323;
            int v325 = 0;
          }

          ++v326;
          --v329;
        }

        while (v332 != (char *)1);
      }

      else
      {
        unsigned __int8 v324 = 0;
        v328 = (void *)a8;
      }

      void *v328 = v324 + 1LL;
      v328[1] = v323;
      BrotliFree(v543, v229);
      BrotliFree(v543, (unint64_t)v138);
      uint64_t result = BrotliFree(v543, (unint64_t)v465);
      if (!*(_DWORD *)(v543 + 24)) {
        uint64_t result = BrotliFree(v543, (unint64_t)v507);
      }
      int v20 = v534;
      a7 = v504;
      size_t v11 = v518;
      goto LABEL_29;
    }

LABEL_186:
    size_t v11 = v518;
    a7 = v504;
    goto LABEL_29;
  }

  unint64_t v32 = *(void *)(a8 + 32);
  unint64_t v33 = *(void *)(a8 + 8) + 1LL;
  if (v32 < v33)
  {
    if (!v32) {
      unint64_t v32 = *(void *)(a8 + 8) + 1LL;
    }
    do
    {
      unint64_t v34 = v32;
      v32 *= 2LL;
    }

    while (v34 < v33);
    if (v34) {
      int v35 = (void *)BrotliAllocate(v543);
    }
    else {
      int v35 = 0LL;
    }
    if (!*v534)
    {
      size_t v72 = *(void *)(a8 + 32);
      if (v72) {
        memcpy(v35, *(const void **)(a8 + 16), v72);
      }
    }

    uint64_t result = BrotliFree(v543, *(void *)(a8 + 16));
    *(void *)(a8 + 16) = v35;
    *(void *)(a8 + 32) = v34;
    unint64_t v33 = *(void *)(a8 + 8) + 1LL;
  }

  unint64_t v73 = *(void *)(a8 + 40);
  if (v73 < v33)
  {
    if (!v73) {
      unint64_t v73 = v33;
    }
    do
    {
      unint64_t v74 = v73;
      v73 *= 2LL;
    }

    while (v74 < v33);
    if (v74) {
      unsigned __int8 v75 = (void *)BrotliAllocate(v543);
    }
    else {
      unsigned __int8 v75 = 0LL;
    }
    if (!*v534)
    {
      uint64_t v76 = *(void *)(a8 + 40);
      if (v76) {
        memcpy(v75, *(const void **)(a8 + 24), 4 * v76);
      }
    }

    uint64_t result = BrotliFree(v543, *(void *)(a8 + 24));
    *(void *)(a8 + 24) = v75;
    *(void *)(a8 + 40) = v74;
  }

  if (*v534) {
    return result;
  }
  *(void *)a8 = 1LL;
  *(_BYTE *)(*(void *)(a8 + 16) + *(void *)(a8 + 8)) = 0;
  uint64_t v77 = *(void *)(a8 + 8);
  *(_DWORD *)(*(void *)(a8 + 24) + 4 * v77) = v16;
  uint64_t v78 = v77 + 1;
  int v20 = v534;
  *(void *)(a8 + 8) = v78;
LABEL_29:
  if (*v20) {
    return result;
  }
  v535 = v20;
  uint64_t result = BrotliFree(v543, (unint64_t)v551);
  if (v11)
  {
    uint64_t result = BrotliAllocate(v543);
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    uint64_t v36 = v543;
    uint64_t v37 = 0LL;
    unint64_t v38 = (__int16 *)(a2 + 12);
    unint64_t v39 = result;
    do
    {
      __int16 v40 = *v38;
      v38 += 8;
      *(_WORD *)(result + 2 * v37++) = v40;
    }

    while (v11 != v37);
  }

  else
  {
    if (*v535) {
      return result;
    }
    unint64_t v39 = 0LL;
    uint64_t v36 = v543;
  }

  uint64_t v64 = a10;
  if (v11 <= 0x6783) {
    unint64_t v65 = (unsigned __int16)v11 / 0x212u + 1;
  }
  else {
    unint64_t v65 = 50LL;
  }
  if (!v11)
  {
    *(void *)a9 = 1LL;
    uint64_t result = BrotliFree(v36, v39);
    int v70 = v535;
    if (*(_DWORD *)(v36 + 24)) {
      return result;
    }
    unint64_t v71 = 0LL;
    goto LABEL_76;
  }

  unint64_t v541 = v39;
  if (v11 > 0x7F)
  {
    uint64_t result = BrotliAllocate(v36);
    if (*(_DWORD *)(v36 + 24)) {
      return result;
    }
    uint64_t v79 = 0LL;
    v544 = (_DWORD *)result;
    do
    {
      uint64_t v80 = (_DWORD *)(result + v79);
      bzero((void *)(result + v79), 0xB08uLL);
      uint64_t result = (uint64_t)v544;
      *((void *)v80 + 353) = 0x7FF0000000000000LL;
      v79 += 2832LL;
    }

    while (2832LL * v65 != v79);
    uint64_t v81 = 0LL;
    LODWORD(v82) = 7;
    do
    {
      size_t v83 = v81 * v11 / v65;
      if (v81)
      {
        unint64_t v82 = (16807 * v82);
        v83 += v82 % (v11 / v65);
      }

      uint64_t v84 = 0LL;
      if (v83 + 40 >= v11) {
        size_t v85 = v11 - 41;
      }
      else {
        size_t v85 = v83;
      }
      unsigned __int16 v86 = (char *)&v544[708 * v81];
      unint64_t v87 = v541 + 2 * v85;
      *((void *)v86 + 352) += 40LL;
      do
      {
        ++*(_DWORD *)&v86[4 * *(unsigned __int16 *)(v87 + v84)];
        v84 += 2LL;
      }

      while (v84 != 80);
      ++v81;
    }

    while (v81 != v65);
    size_t v519 = v11;
    unint64_t v88 = v65 + 2 * v11 / 0x28 + 99 - (v65 + 2 * v11 / 0x28 + 99) % v65;
    if (v88)
    {
      unint64_t v89 = 0LL;
      if (v88 <= 1) {
        unint64_t v90 = 1LL;
      }
      else {
        unint64_t v90 = v65 + 2 * v11 / 0x28 + 99 - (v65 + 2 * v11 / 0x28 + 99) % v65;
      }
      LODWORD(v91) = 7;
      do
      {
        bzero(v555, 0xB08uLL);
        unint64_t v91 = (16807 * v91);
        unint64_t v92 = (unsigned __int16 *)(v541 + 2 * (v91 % (v11 - 39)));
        uint64_t v93 = -40LL;
        do
        {
          unsigned int v94 = *v92++;
          ++*((_DWORD *)v555 + v94);
          BOOL v57 = __CFADD__(v93++, 1LL);
        }

        while (!v57);
        uint64_t v95 = 0LL;
        uint64_t v96 = 0LL;
        unsigned int v97 = (char *)&v544[708 * (v89 % v65)];
        *((void *)v97 + 352) += 40LL;
        do
        {
          *(int32x4_t *)&v97[4 * v96] = vaddq_s32(*(int32x4_t *)&v97[4 * v96], *(int32x4_t *)&v555[v95]);
          v96 += 4LL;
          v95 += 2LL;
        }

        while (v95 != 352);
        ++v89;
      }

      while (v89 != v90);
    }

    __src = (char *)BrotliAllocate(v543);
    BOOL v98 = (char *)BrotliAllocate(v543);
    int v99 = (void *)BrotliAllocate(v543);
    unsigned int v100 = ((v65 + 7) >> 3) * v11 ? (char *)BrotliAllocate(v543) : 0LL;
    uint64_t result = BrotliAllocate(v543);
    uint64_t v183 = a7[1] <= 10 ? 3LL : 10LL;
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    v505 = a7;
    unint64_t v184 = 0LL;
    size_t v495 = v11 - 1;
    unint64_t v185 = (unsigned __int8 *)__src;
    v478 = __src - 2;
    uint64_t v186 = v543;
    uint64_t v187 = (void *)result;
    v508 = (char *)v183;
    v512 = (void *)result;
    do
    {
      v529 = v184;
      if (v65 > 1)
      {
        unint64_t __bb = (v65 + 7) >> 3;
        bzero(v98, 5632 * v65);
        uint64_t v189 = 0LL;
        unint64_t v190 = v544 + 704;
        do
        {
          unint64_t v191 = *v190;
          if (v191 > 0xFF) {
            double v192 = log2((double)v191);
          }
          else {
            double v192 = kBrotliLog2Table[v191];
          }
          v190 += 708;
          *(double *)&v98[8 * v189++] = v192;
        }

        while (v65 != v189);
        unint64_t v193 = &v98[5624 * v65];
        unint64_t v194 = v544 + 703;
        uint64_t v195 = 704LL;
        do
        {
          uint64_t v196 = 0LL;
          --v195;
          unint64_t v197 = v194;
          do
          {
            double v198 = *(double *)&v98[8 * v196];
            uint64_t v199 = *v197;
            if ((_DWORD)v199)
            {
              else {
                double v200 = kBrotliLog2Table[v199];
              }
            }

            else
            {
              double v200 = -2.0;
            }

            v197 += 708;
            *(double *)&v193[8 * v196++] = v198 - v200;
          }

          while (v65 != v196);
          v193 -= 8 * v65;
          --v194;
        }

        while (v195);
        bzero(v99, 8 * v65);
        size_t v11 = v519;
        bzero(v100, __bb * v519);
        unint64_t v201 = 0LL;
        uint64_t v186 = v543;
        unint64_t v185 = (unsigned __int8 *)__src;
        uint64_t v187 = v512;
        do
        {
          uint64_t v202 = 0LL;
          unsigned int v203 = &v98[8 * v65 * *(unsigned __int16 *)(v541 + 2 * v201)];
          double v204 = 1.0e99;
          do
          {
            double v205 = *(double *)&v203[8 * v202] + *((double *)v99 + v202);
            *((double *)v99 + v202) = v205;
            if (v205 < v204)
            {
              __src[v201] = v202;
              double v204 = v205;
            }

            ++v202;
          }

          while (v65 != v202);
          double v206 = 13.5;
          if (v201 <= 0x7CF) {
            double v206 = ((double)v201 * 0.07 / 2000.0 + 0.77) * 13.5;
          }
          for (unint64_t m = 0LL; m != v65; ++m)
          {
            double v208 = *((double *)v99 + m) - v204;
            *((double *)v99 + m) = v208;
            if (v208 >= v206)
            {
              *((double *)v99 + m) = v206;
              v100[v201 * __bb + (m >> 3)] |= 1 << (m & 7);
            }
          }

          ++v201;
        }

        while (v201 != v519);
        unsigned int v209 = __src[v495];
        uint64_t v210 = &v100[(v519 - 2) * __bb];
        size_t v211 = v519;
        unint64_t v188 = 1LL;
        do
        {
          if (((v210[(unint64_t)v209 >> 3] >> (v209 & 7)) & 1) != 0)
          {
            unsigned int v209 = v478[v211];
          }

          v210 -= __bb;
          v478[v211--] = v209;
        }

        while (v211 != 1);
      }

      else
      {
        bzero(v185, v11);
        unint64_t v188 = 1LL;
      }

      if (v65) {
        memset_pattern16(v187, &unk_181095120, 2 * v65);
      }
      uint64_t v212 = 0LL;
      unsigned __int16 v213 = 0;
      do
      {
        uint64_t v214 = v185[v212];
        if (*((_WORD *)v187 + v214) == 256) {
          *((_WORD *)v187 + v214) = v213++;
        }
        ++v212;
      }

      while (v11 != v212);
      for (uint64_t n = 0LL; n != v11; ++n)
        v185[n] = *((_WORD *)v187 + v185[n]);
      unint64_t v65 = v213;
      if (v213)
      {
        __int16 v216 = v544;
        uint64_t v217 = v213;
        do
        {
          bzero(v216, 0xB08uLL);
          v216[353] = 0x7FF0000000000000LL;
          v216 += 354;
          --v217;
        }

        while (v217);
      }

      uint64_t v218 = 0LL;
      unint64_t v185 = (unsigned __int8 *)__src;
      do
      {
        unsigned int v219 = (char *)&v544[708 * __src[v218]];
        ++*(_DWORD *)&v219[4 * *(unsigned __int16 *)(v541 + 2 * v218)];
        ++*((void *)v219 + 352);
        ++v218;
      }

      while (v11 != v218);
      unint64_t v184 = v529 + 1;
      uint64_t v187 = v512;
    }

    while (v529 + 1 != v508);
    BrotliFree(v186, (unint64_t)v98);
    BrotliFree(v186, (unint64_t)v99);
    BrotliFree(v186, (unint64_t)v100);
    BrotliFree(v186, (unint64_t)v512);
    BrotliFree(v186, (unint64_t)v544);
    if (v188)
    {
      v464 = (_DWORD *)BrotliAllocate(v186);
      uint64_t v220 = (unsigned int *)BrotliAllocate(v186);
      unint64_t v221 = 16 * v188 + 1008;
      uint64_t v222 = v221 >> 6;
      if (v221 < 0x40)
      {
        v483 = 0LL;
        unint64_t v487 = v221 >> 6;
        v530 = 0LL;
        goto LABEL_339;
      }
    }

    else
    {
      v464 = 0LL;
      uint64_t v220 = 0LL;
      uint64_t v222 = 15LL;
    }

    v530 = (char *)BrotliAllocate(v186);
    unint64_t v487 = v222;
    v483 = (void *)BrotliAllocate(v186);
LABEL_339:
    uint64_t v230 = 64LL;
    if (v188 < 0x40) {
      uint64_t v230 = v188;
    }
    if (v230) {
      v552 = (void *)BrotliAllocate(v186);
    }
    else {
      v552 = 0LL;
    }
    uint64_t result = BrotliAllocate(v186);
    v471 = (unsigned int *)result;
    __int128 v619 = 0u;
    __int128 v618 = 0u;
    __int128 v617 = 0u;
    __int128 v616 = 0u;
    __int128 v615 = 0u;
    __int128 v614 = 0u;
    __int128 v613 = 0u;
    __int128 v612 = 0u;
    __int128 v611 = 0u;
    __int128 v610 = 0u;
    __int128 v609 = 0u;
    __int128 v608 = 0u;
    __int128 v607 = 0u;
    __int128 v606 = 0u;
    __int128 v605 = 0u;
    __int128 v604 = 0u;
    __int128 v603 = 0u;
    __int128 v602 = 0u;
    __int128 v601 = 0u;
    __int128 v600 = 0u;
    __int128 v599 = 0u;
    __int128 v598 = 0u;
    __int128 v597 = 0u;
    __int128 v596 = 0u;
    __int128 v595 = 0u;
    __int128 v594 = 0u;
    __int128 v593 = 0u;
    __int128 v592 = 0u;
    __int128 v591 = 0u;
    __int128 v590 = 0u;
    __int128 v589 = 0u;
    __int128 v588 = 0u;
    __int128 v587 = 0u;
    __int128 v586 = 0u;
    __int128 v585 = 0u;
    __int128 v584 = 0u;
    __int128 v583 = 0u;
    __int128 v582 = 0u;
    __int128 v581 = 0u;
    __int128 v580 = 0u;
    __int128 v579 = 0u;
    __int128 v578 = 0u;
    __int128 v577 = 0u;
    __int128 v576 = 0u;
    __int128 v575 = 0u;
    __int128 v574 = 0u;
    __int128 v573 = 0u;
    __int128 v572 = 0u;
    __int128 v571 = 0u;
    __int128 v570 = 0u;
    __int128 v569 = 0u;
    __int128 v568 = 0u;
    __int128 v567 = 0u;
    __int128 v566 = 0u;
    __int128 v565 = 0u;
    __int128 v564 = 0u;
    __int128 v563 = 0u;
    __int128 v562 = 0u;
    __int128 v561 = 0u;
    __int128 v560 = 0u;
    __int128 v559 = 0u;
    __int128 v558 = 0u;
    __int128 v557 = 0u;
    __int128 v556 = 0u;
    uint64_t v182 = v535;
    if (*(_DWORD *)(v186 + 24)) {
      goto LABEL_345;
    }
    bzero(v220, 4 * v188);
    uint64_t v238 = 0LL;
    uint64_t v239 = 0LL;
    unint64_t v240 = v541;
    do
    {
      ++v220[v238];
      if (v495 == v239 || __src[v239] != __src[v239 + 1]) {
        ++v238;
      }
      ++v239;
    }

    while (v11 != v239);
    if (v188)
    {
      v509 = 0LL;
      v241 = 0LL;
      v242 = 0LL;
      uint64_t v243 = 0LL;
      v496 = v464;
      __bc = 0LL;
      unint64_t v244 = v188;
      v492 = (char *)v487;
      unint64_t v245 = (unint64_t)v552;
      while (1)
      {
        unint64_t v475 = v244 - 64;
        v479 = v242;
        if (v244 >= 0x40) {
          uint64_t v246 = 64LL;
        }
        else {
          uint64_t v246 = v244;
        }
        v547 = v241;
        uint64_t v247 = v188 - (void)v241;
        v513 = (void *)v247;
        if (v247)
        {
          uint64_t v248 = 0LL;
          do
          {
            v249 = (void *)(v245 + 2832 * v248);
            bzero(v249, 0xB08uLL);
            v249[353] = 0x7FF0000000000000LL;
            if (v220[(void)&v547[v248]])
            {
              unint64_t v250 = 0LL;
              do
                ++*((_DWORD *)v249 + *(unsigned __int16 *)(v240 + 2 * v243 + 2 * v250++));
              while (v250 < v220[(void)&v547[v248]]);
              v249[352] = v250;
              v243 += v250;
            }

            BrotliPopulationCostCommand((uint64_t)v249);
            v249[353] = v251;
            *((_DWORD *)&v588 + v248) = v248;
            *((_DWORD *)&v572 + v248) = v248;
            *((_DWORD *)&v604 + v248++) = 1;
            size_t v11 = v519;
            unint64_t v245 = (unint64_t)v552;
          }

          while (v248 != v246);
        }

        uint64_t result = BrotliHistogramCombineCommand( v245,  (uint64_t)&v604,  &v572,  &v588,  v471,  (unint64_t)v513,  (uint64_t)v513,  0x40uLL,  0x800uLL);
        uint64_t v252 = result;
        unint64_t v253 = v487;
        uint64_t v186 = v543;
        if (v487 < (unint64_t)v509 + result)
        {
          if (v487) {
            unint64_t v254 = v487;
          }
          else {
            unint64_t v254 = (unint64_t)v509 + result;
          }
          do
          {
            v255 = (char *)v254;
            v254 *= 2LL;
          }

          while (v255 < (char *)v509 + result);
          if (v255) {
            __dsta = (char *)BrotliAllocate(v543);
          }
          else {
            __dsta = 0LL;
          }
          if (*v535) {
            BOOL v256 = 1;
          }
          else {
            BOOL v256 = v487 == 0;
          }
          if (!v256) {
            memcpy(__dsta, v530, 2832 * v487);
          }
          uint64_t result = BrotliFree(v543, (unint64_t)v530);
          v530 = __dsta;
          unint64_t v253 = (unint64_t)v255;
        }

        v257 = v492;
        unint64_t v487 = v253;
        if (v492 < &__bc[v252])
        {
          if (v492) {
            uint64_t v258 = (uint64_t)v492;
          }
          else {
            uint64_t v258 = (uint64_t)&__bc[v252];
          }
          do
          {
            v259 = (char *)v258;
            v258 *= 2LL;
          }

          while (v259 < &__bc[v252]);
          if (v259)
          {
            uint64_t v260 = BrotliAllocate(v543);
            v257 = v492;
            __dstb = (void *)v260;
          }

          else
          {
            __dstb = 0LL;
          }

          if (*v535) {
            BOOL v261 = 1;
          }
          else {
            BOOL v261 = v257 == 0LL;
          }
          if (!v261) {
            memcpy(__dstb, v483, 4LL * (void)v257);
          }
          uint64_t result = BrotliFree(v543, (unint64_t)v483);
          v483 = __dstb;
          v257 = v259;
        }

        uint64_t v182 = v535;
        if (*v535) {
          goto LABEL_345;
        }
        v492 = v257;
        if (v252)
        {
          v262 = 0LL;
          v263 = &v530[2832 * (void)v509];
          unint64_t v245 = (unint64_t)v552;
          do
          {
            uint64_t v264 = *((unsigned int *)&v588 + (void)v262);
            memcpy(v263, (const void *)(v245 + 2832LL * v264), 0xB10uLL);
            unint64_t v245 = (unint64_t)v552;
            *((_DWORD *)v483 + (void)__bc + (void)v262) = *((_DWORD *)&v604 + v264);
            *((_DWORD *)&v556 + *((unsigned int *)&v588 + (void)v262)) = (_DWORD)v262;
            v262 = (_DWORD *)((char *)v262 + 1);
            v263 += 2832;
          }

          while ((_DWORD *)v252 != v262);
          v509 = (char *)v262 + (void)v509;
          __bc = (char *)v262 + (void)__bc;
          uint64_t v186 = v543;
          size_t v11 = v519;
        }

        else
        {
          unint64_t v245 = (unint64_t)v552;
        }

        unint64_t v240 = v541;
        if (v513)
        {
          v265 = (unsigned int *)&v572;
          v266 = v496;
          do
          {
            unsigned int v267 = *v265++;
            *v266++ = *((_DWORD *)&v556 + v267) + (_DWORD)v479;
            --v246;
          }

          while (v246);
        }

        v242 = &v479[v252];
        v241 = v547 + 64;
        v496 += 64;
        unint64_t v244 = v475;
      }
    }

    v242 = 0LL;
    unint64_t v245 = (unint64_t)v552;
LABEL_475:
    unint64_t v306 = (unint64_t)v242;
    uint64_t result = BrotliFree(v186, v245);
    if (v306 << 6 >= (v306 >> 1) * v306) {
      unint64_t v307 = (v306 >> 1) * v306;
    }
    else {
      unint64_t v307 = v306 << 6;
    }
    if (v307 >= 0x801)
    {
      BrotliFree(v186, (unint64_t)v471);
      uint64_t result = BrotliAllocate(v186);
      v471 = (unsigned int *)result;
      uint64_t v182 = v535;
      if (*(_DWORD *)(v186 + 24)) {
        goto LABEL_345;
      }
    }

    if (v306)
    {
      uint64_t result = BrotliAllocate(v186);
      uint64_t v182 = v535;
      if (*(_DWORD *)(v186 + 24)) {
        goto LABEL_345;
      }
      v308 = (unsigned int *)result;
      for (iunint64_t i = 0LL; ii != v306; ++ii)
        *(_DWORD *)(result + 4 * ii) = ii;
    }

    else
    {
      uint64_t v182 = v535;
      if (*v535) {
        goto LABEL_345;
      }
      v308 = 0LL;
    }

    v549 = (char *)BrotliHistogramCombineCommand( (uint64_t)v530,  (uint64_t)v483,  v464,  v308,  v471,  v306,  v188,  0x100uLL,  v307);
    BrotliFree(v186, (unint64_t)v471);
    uint64_t result = BrotliFree(v186, (unint64_t)v483);
    if (v306)
    {
      size_t v310 = 4 * v306;
      uint64_t result = BrotliAllocate(v186);
      v553 = (_DWORD *)result;
      uint64_t v182 = v535;
      size_t v11 = v519;
      if (*(_DWORD *)(v186 + 24)) {
        goto LABEL_345;
      }
      memset((void *)result, 255, v310);
    }

    else
    {
      uint64_t v182 = v535;
      size_t v11 = v519;
      if (*v535) {
        goto LABEL_345;
      }
      v553 = 0LL;
    }

    if (v188)
    {
      int v515 = 0;
      uint64_t v334 = 0LL;
      uint64_t v335 = 0LL;
      do
      {
        bzero(v555, 0xB08uLL);
        v555[353] = 0x7FF0000000000000LL;
        if (v220[v334])
        {
          unint64_t v336 = 0LL;
          do
            ++*((_DWORD *)v555 + *(unsigned __int16 *)(v541 + 2 * v335 + 2 * v336++));
          while (v336 < v220[v334]);
          v555[352] = v336;
          v335 += v336;
        }

        uint64_t v337 = v334 - 1;
        if (!v334) {
          uint64_t v337 = 0LL;
        }
        uint64_t v338 = v464[v337];
        double v339 = BrotliHistogramBitCostDistanceCommand(v555, (uint64_t)&v530[2832 * v338]);
        v340 = v549;
        if (v549)
        {
          double v341 = v339;
          v342 = v308;
          do
          {
            double v343 = BrotliHistogramBitCostDistanceCommand(v555, (uint64_t)&v530[2832 * *v342]);
            if (v343 < v341)
            {
              uint64_t v338 = *v342;
              double v341 = v343;
            }

            ++v342;
            --v340;
          }

          while (v340);
        }

        v464[v334] = v338;
        if (v553[v338] == -1) {
          v553[v338] = v515++;
        }
        ++v334;
      }

      while (v334 != v188);
    }

    BrotliFree(v543, (unint64_t)v308);
    uint64_t result = BrotliFree(v543, (unint64_t)v530);
    unint64_t v344 = *(void *)(a9 + 32);
    if (v344 < v188)
    {
      if (!v344) {
        unint64_t v344 = v188;
      }
      do
      {
        unint64_t v345 = v344;
        v344 *= 2LL;
      }

      while (v345 < v188);
      if (v345) {
        v346 = (void *)BrotliAllocate(v543);
      }
      else {
        v346 = 0LL;
      }
      if (!*v535)
      {
        size_t v419 = *(void *)(a9 + 32);
        if (v419) {
          memcpy(v346, *(const void **)(a9 + 16), v419);
        }
      }

      uint64_t result = BrotliFree(v543, *(void *)(a9 + 16));
      *(void *)(a9 + 16) = v346;
      *(void *)(a9 + 32) = v345;
    }

    unint64_t v420 = *(void *)(a9 + 40);
    if (v420 < v188)
    {
      if (!v420) {
        unint64_t v420 = v188;
      }
      do
      {
        unint64_t v421 = v420;
        v420 *= 2LL;
      }

      while (v421 < v188);
      if (v421) {
        v422 = (void *)BrotliAllocate(v543);
      }
      else {
        v422 = 0LL;
      }
      if (!*v535)
      {
        uint64_t v423 = *(void *)(a9 + 40);
        if (v423) {
          memcpy(v422, *(const void **)(a9 + 24), 4 * v423);
        }
      }

      uint64_t result = BrotliFree(v543, *(void *)(a9 + 24));
      *(void *)(a9 + 24) = v422;
      *(void *)(a9 + 40) = v421;
    }

    uint64_t v182 = v535;
    size_t v11 = v519;
    if (!*v535)
    {
      if (v188)
      {
        unsigned __int8 v424 = 0;
        uint64_t v425 = 0LL;
        int v426 = 0;
        v427 = v464 + 1;
        v428 = (int *)v220;
        do
        {
          int v429 = *v428++;
          v426 += v429;
          uint64_t v430 = *(v427 - 1);
          if (v188 == 1 || (_DWORD)v430 != *v427)
          {
            int v431 = v553[v430];
            *(_BYTE *)(*(void *)(a9 + 16) + v425) = v431;
            *(_DWORD *)(*(void *)(a9 + 24) + 4 * v425) = v426;
            ++v425;
            int v426 = 0;
          }

          ++v427;
          --v188;
        }

        while (v188);
      }

      else
      {
        uint64_t v425 = 0LL;
        unsigned __int8 v424 = 0;
      }

      *(void *)a9 = v424 + 1LL;
      *(void *)(a9 + 8) = v425;
      BrotliFree(v543, (unint64_t)v553);
      BrotliFree(v543, (unint64_t)v220);
      uint64_t result = BrotliFree(v543, (unint64_t)v464);
      uint64_t v182 = v535;
      a7 = v505;
      size_t v11 = v519;
      uint64_t v64 = a10;
      if (!*(_DWORD *)(v543 + 24))
      {
        uint64_t result = BrotliFree(v543, (unint64_t)__src);
        uint64_t v182 = v535;
      }

      goto LABEL_346;
    }

LABEL_345:
    a7 = v505;
    uint64_t v64 = a10;
    goto LABEL_346;
  }

  unint64_t v66 = *(void *)(a9 + 32);
  unint64_t v67 = *(void *)(a9 + 8) + 1LL;
  if (v66 < v67)
  {
    if (!v66) {
      unint64_t v66 = *(void *)(a9 + 8) + 1LL;
    }
    do
    {
      unint64_t v68 = v66;
      v66 *= 2LL;
    }

    while (v68 < v67);
    if (v68)
    {
      uint64_t v69 = (void *)BrotliAllocate(v36);
      if (*(_DWORD *)(v36 + 24))
      {
LABEL_248:
        uint64_t result = BrotliFree(v36, *(void *)(a9 + 16));
        *(void *)(a9 + 16) = v69;
        *(void *)(a9 + 32) = v68;
        unint64_t v67 = *(void *)(a9 + 8) + 1LL;
        goto LABEL_249;
      }
    }

    else
    {
      uint64_t v69 = 0LL;
    }

    size_t v175 = *(void *)(a9 + 32);
    if (v175) {
      memcpy(v69, *(const void **)(a9 + 16), v175);
    }
    goto LABEL_248;
  }

LABEL_249:
  unint64_t v176 = *(void *)(a9 + 40);
  if (v176 < v67)
  {
    if (!v176) {
      unint64_t v176 = v67;
    }
    do
    {
      unint64_t v177 = v176;
      v176 *= 2LL;
    }

    while (v177 < v67);
    if (v177) {
      uint64_t v178 = (void *)BrotliAllocate(v36);
    }
    else {
      uint64_t v178 = 0LL;
    }
    if (!*v535)
    {
      uint64_t v179 = *(void *)(a9 + 40);
      if (v179) {
        memcpy(v178, *(const void **)(a9 + 24), 4 * v179);
      }
    }

    uint64_t result = BrotliFree(v36, *(void *)(a9 + 24));
    *(void *)(a9 + 24) = v178;
    *(void *)(a9 + 40) = v177;
  }

  if (*v535) {
    return result;
  }
  *(void *)a9 = 1LL;
  *(_BYTE *)(*(void *)(a9 + 16) + *(void *)(a9 + 8)) = 0;
  uint64_t v180 = *(void *)(a9 + 8);
  *(_DWORD *)(*(void *)(a9 + 24) + 4 * v180) = v11;
  uint64_t v181 = v180 + 1;
  uint64_t v182 = v535;
  *(void *)(a9 + 8) = v181;
LABEL_346:
  if (*v182) {
    return result;
  }
  BrotliFree(v543, v541);
  uint64_t result = BrotliAllocate(v543);
  if (*(_DWORD *)(v543 + 24)) {
    return result;
  }
  unint64_t v71 = result;
  unint64_t v231 = 0LL;
  unint64_t v232 = (unsigned __int16 *)(a2 + 12);
  do
  {
    if ((*((_DWORD *)v232 - 2) & 0x1FFFFFF) != 0 && *v232 >= 0x80u) {
      *(_WORD *)(result + 2 * v231++) = v232[1] & 0x3FF;
    }
    v232 += 8;
    --v11;
  }

  while (v11);
  if (v231 >> 6 <= 0x1A8) {
    unint64_t v233 = (unsigned __int16)v231 / 0x220u + 1;
  }
  else {
    unint64_t v233 = 50LL;
  }
  if (!v231)
  {
    int v70 = v535;
LABEL_76:
    *(void *)uint64_t v64 = 1LL;
    goto LABEL_77;
  }

  size_t v537 = v231;
  if (v231 > 0x7F)
  {
    uint64_t result = BrotliAllocate(v543);
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    unint64_t v542 = v71;
    uint64_t v466 = v64;
    v268 = a7;
    uint64_t v269 = 0LL;
    v548 = (_DWORD *)result;
    do
    {
      v270 = (_DWORD *)(result + v269);
      bzero((void *)(result + v269), 0x888uLL);
      uint64_t result = (uint64_t)v548;
      *((void *)v270 + 273) = 0x7FF0000000000000LL;
      v269 += 2192LL;
    }

    while (2192LL * v233 != v269);
    uint64_t v271 = 0LL;
    LODWORD(v272) = 7;
    do
    {
      size_t v273 = v271 * v537 / v233;
      if (v271)
      {
        unint64_t v272 = (16807 * v272);
        v273 += v272 % (v537 / v233);
      }

      uint64_t v274 = 0LL;
      if (v273 + 40 >= v537) {
        size_t v275 = v537 - 41;
      }
      else {
        size_t v275 = v273;
      }
      v276 = (char *)&v548[548 * v271];
      unint64_t v277 = v71 + 2 * v275;
      *((void *)v276 + 272) += 40LL;
      do
      {
        ++*(_DWORD *)&v276[4 * *(unsigned __int16 *)(v277 + v274)];
        v274 += 2LL;
      }

      while (v274 != 80);
      ++v271;
    }

    while (v271 != v233);
    unint64_t v278 = v233 + 2 * v537 / 0x28 + 99 - (v233 + 2 * v537 / 0x28 + 99) % v233;
    if (v278)
    {
      unint64_t v279 = 0LL;
      if (v278 <= 1) {
        unint64_t v280 = 1LL;
      }
      else {
        unint64_t v280 = v233 + 2 * v537 / 0x28 + 99 - (v233 + 2 * v537 / 0x28 + 99) % v233;
      }
      LODWORD(v281) = 7;
      do
      {
        bzero(v555, 0x888uLL);
        unint64_t v281 = (16807 * v281);
        v282 = (unsigned __int16 *)(v542 + 2 * (v281 % (v537 - 39)));
        uint64_t v283 = -40LL;
        do
        {
          unsigned int v284 = *v282++;
          ++*((_DWORD *)v555 + v284);
          BOOL v57 = __CFADD__(v283++, 1LL);
        }

        while (!v57);
        uint64_t v285 = 0LL;
        uint64_t v286 = 0LL;
        v287 = (char *)&v548[548 * (v279 % v233)];
        *((void *)v287 + 272) += 40LL;
        do
        {
          *(int32x4_t *)&v287[4 * v286] = vaddq_s32(*(int32x4_t *)&v287[4 * v286], *(int32x4_t *)&v555[v285]);
          v286 += 4LL;
          v285 += 2LL;
        }

        while (v285 != 272);
        ++v279;
      }

      while (v279 != v280);
    }

    uint64_t v510 = BrotliAllocate(v543);
    v288 = (char *)BrotliAllocate(v543);
    v289 = (void *)BrotliAllocate(v543);
    if (((v233 + 7) >> 3) * v537) {
      v290 = (char *)BrotliAllocate(v543);
    }
    else {
      v290 = 0LL;
    }
    uint64_t result = BrotliAllocate(v543);
    __bd = (void *)result;
    uint64_t v347 = 3LL;
    if (v268[1] > 10) {
      uint64_t v347 = 10LL;
    }
    __srcc = (char *)v347;
    if (*(_DWORD *)(v543 + 24)) {
      return result;
    }
    v348 = 0LL;
    size_t v349 = v537;
    v516 = (char *)(v537 - 1);
    v350 = (unsigned __int8 *)v510;
    v488 = (char *)(v510 - 2);
    v351 = (void *)result;
    do
    {
      v531 = v348;
      if (v233 > 1)
      {
        bzero(v288, 4352 * v233);
        uint64_t v353 = 0LL;
        v354 = v548 + 544;
        do
        {
          unint64_t v355 = *v354;
          if (v355 > 0xFF) {
            double v356 = log2((double)v355);
          }
          else {
            double v356 = kBrotliLog2Table[v355];
          }
          v354 += 548;
          *(double *)&v288[8 * v353++] = v356;
        }

        while (v233 != v353);
        unint64_t v520 = (v233 + 7) >> 3;
        v357 = &v288[4344 * v233];
        v358 = v548 + 543;
        uint64_t v359 = 544LL;
        do
        {
          uint64_t v360 = 0LL;
          --v359;
          v361 = v358;
          do
          {
            double v362 = *(double *)&v288[8 * v360];
            uint64_t v363 = *v361;
            if ((_DWORD)v363)
            {
              else {
                double v364 = kBrotliLog2Table[v363];
              }
            }

            else
            {
              double v364 = -2.0;
            }

            v361 += 548;
            *(double *)&v357[8 * v360++] = v362 - v364;
          }

          while (v233 != v360);
          v357 -= 8 * v233;
          --v358;
        }

        while (v359);
        bzero(v289, 8 * v233);
        bzero(v290, v520 * v537);
        unint64_t v365 = 0LL;
        v350 = (unsigned __int8 *)v510;
        v351 = __bd;
        do
        {
          uint64_t v366 = 0LL;
          v367 = &v288[8 * v233 * *(unsigned __int16 *)(v542 + 2 * v365)];
          double v368 = 1.0e99;
          do
          {
            double v369 = *(double *)&v367[8 * v366] + *((double *)v289 + v366);
            *((double *)v289 + v366) = v369;
            if (v369 < v368)
            {
              *(_BYTE *)(v510 + v365) = v366;
              double v368 = v369;
            }

            ++v366;
          }

          while (v233 != v366);
          double v370 = 14.6;
          if (v365 <= 0x7CF) {
            double v370 = ((double)v365 * 0.07 / 2000.0 + 0.77) * 14.6;
          }
          for (juint64_t j = 0LL; jj != v233; ++jj)
          {
            double v372 = *((double *)v289 + jj) - v368;
            *((double *)v289 + jj) = v372;
            if (v372 >= v370)
            {
              *((double *)v289 + jj) = v370;
              v290[v365 * v520 + (jj >> 3)] |= 1 << (jj & 7);
            }
          }

          ++v365;
        }

        while (v365 != v537);
        unsigned int v373 = v516[v510];
        v374 = &v290[(v537 - 2) * v520];
        size_t v375 = v537;
        unint64_t v352 = 1LL;
        do
        {
          if (((v374[(unint64_t)v373 >> 3] >> (v373 & 7)) & 1) != 0)
          {
            unsigned int v373 = v488[v375];
          }

          v374 -= v520;
          v488[v375--] = v373;
        }

        while (v375 != 1);
      }

      else
      {
        bzero(v350, v349);
        unint64_t v352 = 1LL;
      }

      if (v233) {
        memset_pattern16(v351, &unk_181095120, 2 * v233);
      }
      uint64_t v376 = 0LL;
      unsigned __int16 v377 = 0;
      do
      {
        uint64_t v378 = v350[v376];
        if (*((_WORD *)v351 + v378) == 256) {
          *((_WORD *)v351 + v378) = v377++;
        }
        ++v376;
      }

      while (v537 != v376);
      v554 = (char *)v352;
      for (kuint64_t k = 0LL; kk != v537; ++kk)
        v350[kk] = *((_WORD *)v351 + v350[kk]);
      unint64_t v233 = v377;
      if (v377)
      {
        v380 = v548;
        uint64_t v381 = v377;
        do
        {
          bzero(v380, 0x888uLL);
          v380[273] = 0x7FF0000000000000LL;
          v380 += 274;
          --v381;
        }

        while (v381);
      }

      uint64_t v382 = 0LL;
      size_t v349 = v537;
      do
      {
        v383 = (char *)&v548[548 * v350[v382]];
        ++*(_DWORD *)&v383[4 * *(unsigned __int16 *)(v542 + 2 * v382)];
        ++*((void *)v383 + 272);
        ++v382;
      }

      while (v537 != v382);
      v348 = v531 + 1;
    }

    while (v531 + 1 != __srcc);
    BrotliFree(v543, (unint64_t)v288);
    BrotliFree(v543, (unint64_t)v289);
    BrotliFree(v543, (unint64_t)v290);
    BrotliFree(v543, (unint64_t)v351);
    BrotliFree(v543, (unint64_t)v548);
    if (v352)
    {
      v472 = (_DWORD *)BrotliAllocate(v543);
      v384 = (unsigned int *)BrotliAllocate(v543);
      unint64_t v385 = 16 * v352 + 1008;
      unint64_t v532 = v385 >> 6;
      if (v385 < 0x40)
      {
        v550 = 0LL;
        v506 = 0LL;
        goto LABEL_619;
      }
    }

    else
    {
      v472 = 0LL;
      v384 = 0LL;
      unint64_t v532 = 15LL;
    }

    v550 = (char *)BrotliAllocate(v543);
    v506 = (void *)BrotliAllocate(v543);
LABEL_619:
    uint64_t v386 = 64LL;
    if (v352 < 0x40) {
      uint64_t v386 = v352;
    }
    if (v386) {
      v480 = (char *)BrotliAllocate(v543);
    }
    else {
      v480 = 0LL;
    }
    uint64_t result = BrotliAllocate(v543);
    v476 = (unsigned int *)result;
    __int128 v619 = 0u;
    __int128 v618 = 0u;
    __int128 v617 = 0u;
    __int128 v616 = 0u;
    __int128 v615 = 0u;
    __int128 v614 = 0u;
    __int128 v613 = 0u;
    __int128 v612 = 0u;
    __int128 v611 = 0u;
    __int128 v610 = 0u;
    __int128 v609 = 0u;
    __int128 v608 = 0u;
    __int128 v607 = 0u;
    __int128 v606 = 0u;
    __int128 v605 = 0u;
    __int128 v604 = 0u;
    __int128 v603 = 0u;
    __int128 v602 = 0u;
    __int128 v601 = 0u;
    __int128 v600 = 0u;
    __int128 v599 = 0u;
    __int128 v598 = 0u;
    __int128 v597 = 0u;
    __int128 v596 = 0u;
    __int128 v595 = 0u;
    __int128 v594 = 0u;
    __int128 v593 = 0u;
    __int128 v592 = 0u;
    __int128 v591 = 0u;
    __int128 v590 = 0u;
    __int128 v589 = 0u;
    __int128 v588 = 0u;
    __int128 v587 = 0u;
    __int128 v586 = 0u;
    __int128 v585 = 0u;
    __int128 v584 = 0u;
    __int128 v583 = 0u;
    __int128 v582 = 0u;
    __int128 v581 = 0u;
    __int128 v580 = 0u;
    __int128 v579 = 0u;
    __int128 v578 = 0u;
    __int128 v577 = 0u;
    __int128 v576 = 0u;
    __int128 v575 = 0u;
    __int128 v574 = 0u;
    __int128 v573 = 0u;
    __int128 v572 = 0u;
    __int128 v571 = 0u;
    __int128 v570 = 0u;
    __int128 v569 = 0u;
    __int128 v568 = 0u;
    __int128 v567 = 0u;
    __int128 v566 = 0u;
    __int128 v565 = 0u;
    __int128 v564 = 0u;
    __int128 v563 = 0u;
    __int128 v562 = 0u;
    __int128 v561 = 0u;
    __int128 v560 = 0u;
    __int128 v559 = 0u;
    __int128 v558 = 0u;
    __int128 v557 = 0u;
    __int128 v556 = 0u;
    int v70 = v535;
    if (*(_DWORD *)(v543 + 24)) {
      goto LABEL_625;
    }
    bzero(v384, 4 * v352);
    uint64_t v387 = 0LL;
    for (munint64_t m = 0LL; mm != (char *)v537; ++mm)
    {
      ++v384[v387];
      if (v516 == mm || mm[v510] != mm[v510 + 1]) {
        ++v387;
      }
    }

    if (v352)
    {
      uint64_t v521 = 0LL;
      __srcd = 0LL;
      uint64_t v389 = 0LL;
      unint64_t v390 = 0LL;
      uint64_t v391 = 0LL;
      v392 = v472;
      v393 = (char *)v352;
      unint64_t v394 = v352;
      unint64_t v517 = v532;
      unint64_t v395 = (unint64_t)v480;
      while (1)
      {
        v484 = (void *)(v394 - 64);
        v489 = v392;
        if (v394 >= 0x40) {
          uint64_t v396 = 64LL;
        }
        else {
          uint64_t v396 = v394;
        }
        uint64_t v397 = (uint64_t)&v393[-v389];
        size_t v538 = v397;
        if (v397)
        {
          uint64_t v398 = 0LL;
          do
          {
            v399 = (void *)(v395 + 2192 * v398);
            bzero(v399, 0x888uLL);
            v399[273] = 0x7FF0000000000000LL;
            if (v384[v398 + v389])
            {
              unint64_t v400 = 0LL;
              do
                ++*((_DWORD *)v399 + *(unsigned __int16 *)(v542 + 2 * v391 + 2 * v400++));
              while (v400 < v384[v398 + v389]);
              v399[272] = v400;
              v391 += v400;
            }

            BrotliPopulationCostDistance(v395 + 2192 * v398);
            v399[273] = v401;
            *((_DWORD *)&v588 + v398) = v398;
            *((_DWORD *)&v572 + v398) = v398;
            *((_DWORD *)&v604 + v398++) = 1;
          }

          while (v398 != v396);
        }

        uint64_t result = BrotliHistogramCombineDistance(v395, (uint64_t)&v604, &v572, &v588, v476, v538, v538, 0x40uLL, 0x800uLL);
        uint64_t v497 = v389;
        __be = (char *)v390;
        if (v532 < result + v521)
        {
          v402 = (_DWORD *)result;
          unint64_t v403 = v532;
          if (!v532) {
            unint64_t v403 = result + v521;
          }
          do
          {
            unint64_t v404 = v403;
            v403 *= 2LL;
          }

          while (v404 < result + v521);
          if (v404) {
            v405 = (char *)BrotliAllocate(v543);
          }
          else {
            v405 = 0LL;
          }
          if (*v535) {
            BOOL v406 = 1;
          }
          else {
            BOOL v406 = v532 == 0;
          }
          if (!v406) {
            memcpy(v405, v550, 2192 * v532);
          }
          BrotliFree(v543, (unint64_t)v550);
          v550 = v405;
          unint64_t v532 = v404;
          uint64_t result = (uint64_t)v402;
        }

        if (v517 < (unint64_t)&__srcd[result])
        {
          v407 = (_DWORD *)result;
          unint64_t v408 = v517;
          if (!v517) {
            unint64_t v408 = (unint64_t)&__srcd[result];
          }
          do
          {
            v409 = (char *)v408;
            v408 *= 2LL;
          }

          while (v409 < &__srcd[result]);
          if (v409) {
            v410 = (void *)BrotliAllocate(v543);
          }
          else {
            v410 = 0LL;
          }
          if (*v535) {
            BOOL v411 = 1;
          }
          else {
            BOOL v411 = v517 == 0;
          }
          if (!v411) {
            memcpy(v410, v506, 4 * v517);
          }
          BrotliFree(v543, (unint64_t)v506);
          v506 = v410;
          unint64_t v517 = (unint64_t)v409;
          uint64_t result = (uint64_t)v407;
        }

        int v70 = v535;
        if (*v535) {
          goto LABEL_625;
        }
        if (result)
        {
          v412 = 0LL;
          v413 = &v550[2192 * v521];
          do
          {
            uint64_t v414 = *((unsigned int *)&v588 + (void)v412);
            v415 = (_DWORD *)result;
            memcpy(v413, &v480[2192 * v414], 0x890uLL);
            uint64_t result = (uint64_t)v415;
            *((_DWORD *)v506 + (void)__srcd + (void)v412) = *((_DWORD *)&v604 + v414);
            *((_DWORD *)&v556 + *((unsigned int *)&v588 + (void)v412)) = (_DWORD)v412;
            v412 = (_DWORD *)((char *)v412 + 1);
            v413 += 2192;
          }

          while (v415 != v412);
          v521 += (uint64_t)v412;
          __srcd = (char *)v412 + (void)__srcd;
        }

        v393 = v554;
        unint64_t v395 = (unint64_t)v480;
        if (v538)
        {
          v416 = (unsigned int *)&v572;
          v417 = v489;
          do
          {
            unsigned int v418 = *v416++;
            *v417++ = *((_DWORD *)&v556 + v418) + (_DWORD)__be;
            --v396;
          }

          while (v396);
        }

        unint64_t v390 = (unint64_t)&__be[result];
        v389 += 64LL;
        v392 = v489 + 64;
        unint64_t v394 = (unint64_t)v484;
      }
    }

    unint64_t v390 = 0LL;
    unint64_t v395 = (unint64_t)v480;
LABEL_711:
    uint64_t result = BrotliFree(v543, v395);
    unint64_t v432 = v390;
    if (v390 << 6 >= (v390 >> 1) * v390) {
      unint64_t v433 = (v390 >> 1) * v390;
    }
    else {
      unint64_t v433 = v390 << 6;
    }
    if (v433 >= 0x801)
    {
      BrotliFree(v543, (unint64_t)v476);
      uint64_t result = BrotliAllocate(v543);
      v476 = (unsigned int *)result;
      int v70 = v535;
      if (*(_DWORD *)(v543 + 24)) {
        goto LABEL_625;
      }
    }

    if (v432)
    {
      uint64_t result = BrotliAllocate(v543);
      int v70 = v535;
      if (*(_DWORD *)(v543 + 24)) {
        goto LABEL_625;
      }
      v434 = (unsigned int *)result;
      for (nuint64_t n = 0LL; nn != v432; ++nn)
        *(_DWORD *)(result + 4 * nn) = nn;
    }

    else
    {
      int v70 = v535;
      if (*v535) {
        goto LABEL_625;
      }
      v434 = 0LL;
    }

    v533 = (char *)BrotliHistogramCombineDistance( (uint64_t)v550,  (uint64_t)v506,  v472,  v434,  v476,  v432,  (uint64_t)v554,  0x100uLL,  v433);
    BrotliFree(v543, (unint64_t)v476);
    uint64_t result = BrotliFree(v543, (unint64_t)v506);
    if (v432)
    {
      size_t v436 = 4 * v432;
      uint64_t result = BrotliAllocate(v543);
      size_t v539 = result;
      int v70 = v535;
      if (!*(_DWORD *)(v543 + 24))
      {
        memset((void *)result, 255, v436);
LABEL_728:
        if (v554)
        {
          int v437 = 0;
          v438 = 0LL;
          uint64_t v439 = 0LL;
          do
          {
            bzero(v555, 0x888uLL);
            v555[273] = 0x7FF0000000000000LL;
            if (v384[(void)v438])
            {
              unint64_t v440 = 0LL;
              do
                ++*((_DWORD *)v555 + *(unsigned __int16 *)(v542 + 2 * v439 + 2 * v440++));
              while (v440 < v384[(void)v438]);
              v555[272] = v440;
              v439 += v440;
            }

            v441 = (char *)v438 - 1;
            if (!v438) {
              v441 = 0LL;
            }
            uint64_t v442 = v472[(void)v441];
            double v443 = BrotliHistogramBitCostDistanceDistance(v555, (uint64_t)&v550[2192 * v442]);
            if (v533)
            {
              double v444 = v443;
              v445 = v434;
              v446 = v533;
              do
              {
                double v447 = BrotliHistogramBitCostDistanceDistance(v555, (uint64_t)&v550[2192 * *v445]);
                if (v447 < v444)
                {
                  uint64_t v442 = *v445;
                  double v444 = v447;
                }

                ++v445;
                --v446;
              }

              while (v446);
            }

            v472[(void)v438] = v442;
            if (*(_DWORD *)(v539 + 4 * v442) == -1) {
              *(_DWORD *)(v539 + 4 * v442) = v437++;
            }
            v438 = (char *)v438 + 1;
          }

          while (v438 != v554);
        }

        BrotliFree(v543, (unint64_t)v434);
        uint64_t result = BrotliFree(v543, (unint64_t)v550);
        unint64_t v448 = *(void *)(v466 + 32);
        if (v448 < (unint64_t)v554)
        {
          if (!v448) {
            unint64_t v448 = (unint64_t)v554;
          }
          do
          {
            unint64_t v449 = v448;
            v448 *= 2LL;
          }

          while (v449 < (unint64_t)v554);
          if (v449) {
            v450 = (void *)BrotliAllocate(v543);
          }
          else {
            v450 = 0LL;
          }
          if (!*v535)
          {
            size_t v451 = *(void *)(v466 + 32);
            if (v451) {
              memcpy(v450, *(const void **)(v466 + 16), v451);
            }
          }

          uint64_t result = BrotliFree(v543, *(void *)(v466 + 16));
          *(void *)(v466 + 16) = v450;
          *(void *)(v466 + 32) = v449;
        }

        unint64_t v452 = *(void *)(v466 + 40);
        if (v452 < (unint64_t)v554)
        {
          if (!v452) {
            unint64_t v452 = (unint64_t)v554;
          }
          do
          {
            unint64_t v453 = v452;
            v452 *= 2LL;
          }

          while (v453 < (unint64_t)v554);
          if (v453) {
            v454 = (void *)BrotliAllocate(v543);
          }
          else {
            v454 = 0LL;
          }
          if (!*v535)
          {
            uint64_t v455 = *(void *)(v466 + 40);
            if (v455) {
              memcpy(v454, *(const void **)(v466 + 24), 4 * v455);
            }
          }

          uint64_t result = BrotliFree(v543, *(void *)(v466 + 24));
          *(void *)(v466 + 24) = v454;
          *(void *)(v466 + 40) = v453;
        }

        int v70 = v535;
        if (!*v535)
        {
          v456 = v554;
          if (v554)
          {
            unsigned __int8 v457 = 0;
            v456 = 0LL;
            int v458 = 0;
            v459 = v472 + 1;
            v460 = (int *)v384;
            do
            {
              int v461 = *v460++;
              v458 += v461;
              uint64_t v462 = *(v459 - 1);
              if (v554 == (char *)1 || (_DWORD)v462 != *v459)
              {
                int v463 = *(_DWORD *)(v539 + 4 * v462);
                v456[*(void *)(v466 + 16)] = v463;
                *(_DWORD *)(*(void *)(v466 + 24) + 4LL * (void)v456) = v458;
                ++v456;
                int v458 = 0;
              }

              ++v459;
              --v554;
            }

            while (v554);
          }

          else
          {
            unsigned __int8 v457 = 0;
          }

          *(void *)uint64_t v466 = v457 + 1LL;
          *(void *)(v466 + 8) = v456;
          BrotliFree(v543, v539);
          BrotliFree(v543, (unint64_t)v384);
          uint64_t result = BrotliFree(v543, (unint64_t)v472);
          if (!*(_DWORD *)(v543 + 24)) {
            uint64_t result = BrotliFree(v543, v510);
          }
          int v70 = v535;
        }
      }
    }

    else
    {
      int v70 = v535;
      if (!*v535)
      {
        size_t v539 = 0LL;
        goto LABEL_728;
      }
    }

LABEL_625:
    unint64_t v71 = v542;
LABEL_77:
    if (!*v70) {
      return BrotliFree(v543, v71);
    }
    return result;
  }

  unint64_t v234 = *(void *)(v64 + 32);
  unint64_t v235 = *(void *)(v64 + 8) + 1LL;
  if (v234 >= v235) {
    goto LABEL_494;
  }
  if (!v234) {
    unint64_t v234 = *(void *)(v64 + 8) + 1LL;
  }
  do
  {
    unint64_t v236 = v234;
    v234 *= 2LL;
  }

  while (v236 < v235);
  if (!v236)
  {
    uint64_t v237 = 0LL;
    goto LABEL_491;
  }

  uint64_t v237 = (void *)BrotliAllocate(v543);
  if (!*(_DWORD *)(v543 + 24))
  {
LABEL_491:
    size_t v311 = *(void *)(v64 + 32);
    if (v311) {
      memcpy(v237, *(const void **)(v64 + 16), v311);
    }
  }

  uint64_t result = BrotliFree(v543, *(void *)(v64 + 16));
  *(void *)(v64 + 16) = v237;
  *(void *)(v64 + 32) = v236;
  unint64_t v235 = *(void *)(v64 + 8) + 1LL;
LABEL_494:
  unint64_t v312 = *(void *)(v64 + 40);
  if (v312 < v235)
  {
    if (!v312) {
      unint64_t v312 = v235;
    }
    do
    {
      unint64_t v313 = v312;
      v312 *= 2LL;
    }

    while (v313 < v235);
    if (v313) {
      v314 = (void *)BrotliAllocate(v543);
    }
    else {
      v314 = 0LL;
    }
    if (!*v535)
    {
      uint64_t v315 = *(void *)(v64 + 40);
      if (v315) {
        memcpy(v314, *(const void **)(v64 + 24), 4 * v315);
      }
    }

    uint64_t result = BrotliFree(v543, *(void *)(v64 + 24));
    *(void *)(v64 + 24) = v314;
    *(void *)(v64 + 40) = v313;
  }

  if (!*v535)
  {
    *(void *)uint64_t v64 = 1LL;
    *(_BYTE *)(*(void *)(v64 + 16) + *(void *)(v64 + 8)) = 0;
    uint64_t v316 = *(void *)(v64 + 8);
    *(_DWORD *)(*(void *)(v64 + 24) + 4 * v316) = v537;
    uint64_t v317 = v316 + 1;
    int v70 = v535;
    *(void *)(v64 + 8) = v317;
    goto LABEL_77;
  }

  return result;
}

uint64_t lzvnStreamEncodeStateSize(int a1)
{
  return lzvn_encode_scratch_size(a1) + 524544;
}

uint64_t lzvnStreamEncodeInit(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  uint64_t v5 = lzvn_encode_scratch_size(a2);
  unint64_t v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, a2, (int)v5 + 524544, (int)v5 + 524344);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = v6;
  uint64_t result = 0LL;
  v7[4] = v7 + 32;
  int v9 = (char *)v7 + v5 + 256;
  v7[2] = v9;
  v7[3] = v9 + 0x40000;
  v7[8] = v9;
  v7[14] = v9 + 0x40000;
  v7[15] = v9 + 0x40000;
  v7[16] = v9 + 0x80000;
  v9[0x40000] = 14;
  *(_BYTE *)(v7[14] + 1LL) = 22;
  *(_BYTE *)(v7[14] + 2LL) = 22;
  *(_BYTE *)(v7[14] + 3LL) = 14;
  v7[14] += 4LL;
  return result;
}

uint64_t lzvnStreamEncode(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v64 = v3 + 64;
  if ((a2 & 1) != 0) {
    *(_DWORD *)(v3 + 44) = 1;
  }
  while (1)
  {
    if (*(_DWORD *)(v3 + 48))
    {
      int64_t v4 = 0LL;
    }

    else
    {
      uint64_t v5 = *(void *)(v3 + 80);
      unint64_t v6 = *(void *)(a1 + 24);
      if (v6 >= 0x40000 - v5) {
        int64_t v4 = 0x40000 - v5;
      }
      else {
        int64_t v4 = *(void *)(a1 + 24);
      }
      if (v4 >= 1)
      {
        memcpy((void *)(*(void *)(v3 + 16) + v5), *(const void **)(a1 + 16), v4);
        *(void *)(v3 + 80) += v4;
        unint64_t v6 = *(void *)(a1 + 24) - v4;
        *(void *)(a1 + 16) += v4;
        *(void *)(a1 + 24) = v6;
      }

      if (!v6 && *(_DWORD *)(v3 + 44)) {
        *(_DWORD *)(v3 + 48) = 1;
      }
    }

    unsigned int v7 = *(char **)(v3 + 120);
    uint64_t v8 = *(char **)(v3 + 24);
    if (v7 >= v8 + 0x20000)
    {
      int v9 = *(_BYTE **)(v3 + 112);
      uint64_t v10 = v9 - v7;
      if (v9 != v7)
      {
        memmove(v8, v7, v9 - v7);
        uint64_t v8 = *(char **)(v3 + 24);
      }

      *(void *)(v3 + 112) = &v8[v10];
      *(void *)(v3 + 120) = v8;
    }

    if (*(_DWORD *)(v3 + 40))
    {
      if (*(_DWORD *)(v3 + 52)) {
        goto LABEL_34;
      }
      uint64_t v11 = 0LL;
      uint64_t v12 = *(void *)(v3 + 72);
      if (v12 <= -65536) {
        LODWORD(v12) = -65536;
      }
      int32x4_t v13 = vdupq_n_s32(v12);
      int v14 = *(_DWORD *)(v3 + 136);
      unsigned int v15 = 1;
      do
      {
        *(int32x4_t *)(*(void *)(v3 + 192) + v11) = vmaxq_s32(*(int32x4_t *)(*(void *)(v3 + 192) + v11), v13);
        unsigned int v16 = v15++ >> v14;
        v11 += 32LL;
      }

      while (!v16);
      goto LABEL_27;
    }

    if (*(_DWORD *)(v3 + 52)) {
      goto LABEL_34;
    }
    lzvnEncodeInitState(v64, *(_DWORD *)(v3 + 4), *(void *)(v3 + 32));
    *(_DWORD *)(v3 + 40) = 1;
LABEL_27:
    uint64_t v17 = *(void *)(v3 + 80);
    *(void *)(v3 + 96) = v17 - 400;
    if (*(_DWORD *)(v3 + 48)) {
      *(void *)(v3 + 96) = v17 - 8;
    }
    lzvnEncode(v64, (int8x16_t)v13);
    if (*(_DWORD *)(v3 + 48) && *(void *)(v3 + 88) >= *(void *)(v3 + 80) - 8LL)
    {
      *(_DWORD *)(v3 + 52) = 1;
    }

    else if (!*(_DWORD *)(v3 + 52))
    {
      goto LABEL_35;
    }

LABEL_34:
    if (*(_DWORD *)(v3 + 56)) {
      goto LABEL_35;
    }
    unint64_t v30 = *(void *)(v3 + 160);
    uint64_t v31 = *(void *)(v3 + 104);
    if (!v30) {
      goto LABEL_98;
    }
    unint64_t v32 = *(void *)(v3 + 168);
    unint64_t v33 = *(void *)(v3 + 144) - v31;
    unint64_t v34 = (int *)(*(void *)(v3 + 64) + v31);
    int v35 = *(char **)(v3 + 112);
    unint64_t v36 = *(void *)(v3 + 128);
    uint64_t v62 = *(void *)(v3 + 184);
    uint64_t v63 = *(void *)(v3 + 152);
    if (v33 >= 0x10)
    {
      do
      {
        uint64_t v37 = v33 >= 0x10F ? 271LL : v33;
        *(_WORD *)int v35 = ((_WORD)v37 << 8) - 3872;
        unint64_t v38 = v35 + 2;
        v33 -= v37;
        memcpy(v38, v34, ((v37 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
        int v35 = &v38[v37];
        unint64_t v34 = (int *)((char *)v34 + v37);
      }

      while (v33 > 0xF);
    }

    if (v33 >= 4)
    {
      *int v35 = v33 | 0xE0;
      unint64_t v39 = v35 + 1;
      memcpy(v39, v34, ((v33 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
      int v35 = &v39[v33];
      unint64_t v34 = (int *)((char *)v34 + v33);
      unint64_t v33 = 0LL;
    }

    if (10 - 2 * v33 >= v30) {
      uint64_t v40 = v30;
    }
    else {
      uint64_t v40 = 10 - 2 * v33;
    }
    if ((unint64_t)(v35 + 8) < v36)
    {
      unint64_t v41 = v30 - v40;
      char v42 = v40 - 3;
      int v43 = *v34;
      if (v32 == v62)
      {
        char v44 = ((_BYTE)v33 << 6) + 8 * v42;
        if (v33) {
          char v45 = 6;
        }
        else {
          char v45 = -16;
        }
        if (!v33) {
          char v44 = v40;
        }
        *int v35 = v45 | v44;
        uint64_t v46 = v35 + 1;
LABEL_83:
        *uint64_t v46 = v43;
        size_t v47 = (_WORD *)((char *)v46 + v33);
        if (v41 < 0x10)
        {
          unint64_t v48 = (char *)v46 + v33;
          if (v41)
          {
LABEL_89:
            if ((unint64_t)(v48 + 1) < v36)
            {
              *unint64_t v48 = v41 | 0xF0;
              unint64_t v36 = (unint64_t)(v48 + 1);
            }
          }

          else
          {
LABEL_92:
            unint64_t v36 = (unint64_t)v48;
          }
        }

        else
        {
          while (1)
          {
            unint64_t v48 = v47 + 1;
            uint64_t v49 = 271LL;
            if (v41 < 0x10F) {
              uint64_t v49 = v41;
            }
            _WORD *v47 = ((_WORD)v49 << 8) - 3856;
            v41 -= v49;
            ++v47;
            if (v41 <= 0xF)
            {
              if (!v41) {
                goto LABEL_92;
              }
              goto LABEL_89;
            }
          }
        }

        goto LABEL_93;
      }

      if (v32 <= 0x5FF)
      {
        *int v35 = ((_BYTE)v33 << 6) + BYTE1(v32) + 8 * v42;
        v35[1] = v32;
        uint64_t v46 = v35 + 2;
        goto LABEL_83;
      }

      if (v30 > 0x22 || v32 >> 14 || !v41)
      {
        *int v35 = (((_BYTE)v33 << 6) + 8 * v42) | 7;
        *(_WORD *)(v35 + 1) = v32;
        uint64_t v46 = v35 + 3;
        goto LABEL_83;
      }

      *int v35 = ((v30 - 3) >> 2) + 8 * v33 - 96;
      *(_WORD *)(v35 + 1) = (v30 - 3) & 3 | (4 * v32);
      *(_DWORD *)(v35 + 3) = v43;
      unint64_t v36 = (unint64_t)&v35[v33 + 3];
    }

        uint64_t v50 = vqtbl1_s8(v28, lzbitmap_pack_perm_table[v35]);
        *(int8x8_t *)((char *)&v197 + v23) = v50;
        v50.i32[0] = v35;
        v23 += vaddlv_u8((uint8x8_t)vcnt_s8(v50));
        unsigned int v19 = *(_DWORD *)v14 | (1 << v20);
        *(_DWORD *)int v14 = v19;
        v14[v22++ + 4] = v35;
      }

LABEL_93:
    if (v36 < *(void *)(v3 + 128))
    {
      uint64_t v50 = *(void *)(v3 + 112);
      *(void *)(v3 + 184) = v32;
      *(void *)(v3 + 104) = v63;
      *(void *)(v3 + 112) = v36;
      if (v36 != v50)
      {
        *(void *)(v3 + 176) = 0LL;
        *(_OWORD *)(v3 + 144) = 0u;
        *(_OWORD *)(v3 + 160) = 0u;
      }
    }

    if (*(void *)(v3 + 160)) {
      goto LABEL_35;
    }
    uint64_t v31 = *(void *)(v3 + 104);
LABEL_98:
    uint64_t v51 = *(void *)(v3 + 80);
    unint64_t v52 = v51 - v31;
    if (v51 > v31)
    {
      unint64_t v53 = (char *)(*(void *)(v3 + 64) + v31);
      char v54 = *(char **)(v3 + 112);
      unint64_t v55 = *(void *)(v3 + 128);
      size_t v56 = v51 - v31;
      if (v52 < 0x10)
      {
LABEL_105:
        if (v56)
        {
          if ((unint64_t)&v54[v56 + 10] < v55)
          {
            *char v54 = v56 | 0xE0;
            uint64_t v59 = v54 + 1;
            memcpy(v59, v53, v56);
            unint64_t v55 = (unint64_t)v59 + v56;
          }
        }

        else
        {
          unint64_t v55 = (unint64_t)v54;
        }
      }

      else
      {
        while (1)
        {
          size_t v57 = v56 >= 0x10F ? 271LL : v56;
          *(_WORD *)char v54 = ((_WORD)v57 << 8) - 3872;
          uint64_t v58 = v54 + 2;
          v56 -= v57;
          memcpy(v58, v53, v57);
          char v54 = &v58[v57];
          v53 += v57;
          if (v56 <= 0xF) {
            goto LABEL_105;
          }
        }
      }

      if (v55 < *(void *)(v3 + 128))
      {
        *(void *)(v3 + 104) += v52;
        *(void *)(v3 + 112) = v55;
      }
    }

    if (!*(void *)(v3 + 160) && *(void *)(v3 + 80) == *(void *)(v3 + 104))
    {
      int v60 = *(void **)(v3 + 112);
      if (*(void *)(v3 + 128) >= (unint64_t)(v60 + 1))
      {
        *int v60 = 6LL;
        *(void *)(v3 + 112) = v60 + 1;
        *(_DWORD *)(v3 + 56) = 1;
      }
    }

        __break(1u);
      }

      else
      {
        return v9 - v87;
      }
    }
  }

  return result;
}

LABEL_35:
    if (*(_DWORD *)(v3 + 60))
    {
      if (*(_DWORD *)(v3 + 56)) {
        return 1LL;
      }
      int64_t v18 = 0LL;
    }

    else
    {
      unsigned int v19 = *(const void **)(v3 + 120);
      if (*(void *)(a1 + 8) >= *(void *)(v3 + 112) - (void)v19) {
        int64_t v18 = *(void *)(v3 + 112) - (void)v19;
      }
      else {
        int64_t v18 = *(void *)(a1 + 8);
      }
      if (v18 >= 1)
      {
        memcpy(*(void **)a1, v19, v18);
        unsigned int v19 = (const void *)(*(void *)(v3 + 120) + v18);
        *(void *)(v3 + 120) = v19;
        int64_t v20 = *(void *)(a1 + 8) - v18;
        *(void *)a1 += v18;
        *(void *)(a1 + 8) = v20;
      }

      if (*(_DWORD *)(v3 + 56))
      {
        if (v19 == *(const void **)(v3 + 112))
        {
          *(_DWORD *)(v3 + 60) = 1;
          return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
        }

        if (*(_DWORD *)(v3 + 60)) {
          return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
        }
      }
    }

    uint64_t v21 = *(void *)(v3 + 80);
    if (v21 >= 0x20000)
    {
      uint64_t v22 = *(void *)(v3 + 88);
      int64_t v23 = v22 - 0x10000;
      if (v22 < 0x20000) {
        int64_t v23 = 0LL;
      }
      if (v23 >= 1)
      {
        uint64_t v24 = 0LL;
        size_t v25 = v21 - v23;
        *(void *)(v3 + 80) = v21 - v23;
        *(void *)(v3 + 88) = v22 - v23;
        *(void *)(v3 + 104) -= v23;
        *(int64x2_t *)(v3 + 144) = vsubq_s64(*(int64x2_t *)(v3 + 144), vdupq_n_s64(v23));
        int32x4_t v26 = vdupq_n_s32(-(int)v23);
        int v27 = *(_DWORD *)(v3 + 136);
        unsigned int v28 = 1;
        do
        {
          *(int32x4_t *)(*(void *)(v3 + 192) + v24) = vaddq_s32(*(int32x4_t *)(*(void *)(v3 + 192) + v24), v26);
          unsigned int v29 = v28++ >> v27;
          v24 += 32LL;
        }

        while (!v29);
        memmove(*(void **)(v3 + 16), (const void *)(*(void *)(v3 + 16) + v23), v25);
        *(void *)(v3 + 64) = *(void *)(v3 + 16);
        *(void *)(v3 + 72) = 0LL;
      }
    }

    if (!(v18 | v4)) {
      return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
    }
  }

  if (*(_DWORD *)(v3 + 48)) {
    return 0xFFFFFFFFLL;
  }
  return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
}

      ++v20;
      int64_t v18 = v32 + 8;
    }

    while (v20 != 16);
    uint64_t v51 = v22 + 4LL;
    unint64_t v52 = 2 * v21 + (unint64_t)v23;
    if ((v52 + v51) <= 0x85)
    {
      int v60 = &v14[v51];
      unint64_t v61 = v210;
      *(_OWORD *)int v60 = v209;
      *((_OWORD *)v60 + 1) = v61;
      if (v60 < v60 + 32)
      {
        uint64_t v62 = &v209;
        uint64_t v63 = v60;
        do
        {
          uint64_t v64 = *v62;
          unint64_t v65 = v62[1];
          v62 += 2;
          *(_OWORD *)uint64_t v63 = v64;
          *((_OWORD *)v63 + 1) = v65;
          v63 += 32;
        }

        while (v63 < v60 + 32);
      }

      int v14 = &v60[v52];
      unint64_t v66 = v198;
      unint64_t v67 = &v60[v52 - v23];
      *(_OWORD *)unint64_t v67 = v197;
      *((_OWORD *)v67 + 1) = v66;
      if (v67 >= v14)
      {
        unsigned int v16 = v31;
        unsigned int v15 = a4;
      }

      else
      {
        unint64_t v68 = &v197;
        unsigned int v15 = a4;
        do
        {
          uint64_t v69 = *v68;
          int v70 = v68[1];
          v68 += 2;
          *(_OWORD *)unint64_t v67 = v69;
          *((_OWORD *)v67 + 1) = v70;
          v67 += 32;
        }

        while (v67 < v14);
        unsigned int v16 = v31;
      }
    }

    else
    {
      unint64_t v53 = &__src[v18 - 128];
      *(_DWORD *)int v14 = 8454143;
      v14[4] = 0;
      char v54 = *(_OWORD *)v53;
      unint64_t v55 = *((_OWORD *)v53 + 1);
      size_t v56 = *((_OWORD *)v53 + 2);
      *(_OWORD *)(v14 + 53) = *((_OWORD *)v53 + 3);
      *(_OWORD *)(v14 + 37) = v56;
      *(_OWORD *)(v14 + 21) = v55;
      *(_OWORD *)(v14 + 5) = v54;
      size_t v57 = *((_OWORD *)v53 + 4);
      uint64_t v58 = *((_OWORD *)v53 + 5);
      uint64_t v59 = *((_OWORD *)v53 + 6);
      *(_OWORD *)(v14 + 117) = *((_OWORD *)v53 + 7);
      *(_OWORD *)(v14 + 101) = v59;
      *(_OWORD *)(v14 + 85) = v58;
      *(_OWORD *)(v14 + 69) = v57;
      v14 += 133;
      unsigned int v15 = a4;
      unsigned int v16 = v30;
    }

    if (v32 + 152 > v15) {
      goto LABEL_118;
    }
  }

uint64_t lz24_decode_buffer(char *__dst, unint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t result = 0LL;
  if (a4 >= 4 && ((a4 | a2) & 0x8000000000000000LL) == 0)
  {
    unint64_t v6 = (char *)(a3 + 1);
    unint64_t v7 = *a3;
    if (v7 > a2) {
      return 0LL;
    }
    if ((_DWORD)v7)
    {
      uint64_t v8 = (char *)a3 + a4;
      int v9 = &__dst[a2];
      unint64_t v10 = (unint64_t)a3 + a4 - 34;
      uint64_t v11 = &__dst[a2 - 62];
      uint64_t v12 = __dst;
      while (1)
      {
        else {
          int64_t v13 = v7;
        }
        if (*(_WORD *)v6) {
          break;
        }
        int64_t v23 = v6 + 2;
        if (v8 - (v6 + 2) < v13) {
          return 0LL;
        }
        memcpy(v12, v6 + 2, v13);
        unint64_t v6 = &v23[v13];
LABEL_29:
        v12 += v13;
        LODWORD(v7) = v7 - v13;
        if (!(_DWORD)v7) {
          return v12 - __dst;
        }
      }

      int v14 = &v12[v13];
      if (v9 - v12 >= 63 && (unint64_t)(v8 - v6) >= 0x23)
      {
        if (v11 <= v14) {
          unsigned int v15 = v11;
        }
        else {
          unsigned int v15 = &v12[v13];
        }
        unint64_t i = v12;
        while (1)
        {
          unint64_t v17 = *(unsigned int *)v6;
          uint64_t v18 = (v17 >> 10) & 0x3FFF;
          __int128 v19 = *(_OWORD *)(v6 + 19);
          *(_OWORD *)unint64_t i = *(_OWORD *)(v6 + 3);
          *((_OWORD *)i + 1) = v19;
          int64_t v20 = &i[v17 & 0x1F];
          if (v20 - __dst < v18) {
            return 0LL;
          }
          v6 += (v17 & 0x1F) + 3;
          __int128 v21 = *(_OWORD *)&v20[-v18 + 16];
          *(_OWORD *)int64_t v20 = *(_OWORD *)&v20[-v18];
          *((_OWORD *)v20 + 1) = v21;
          unint64_t i = &v20[(v17 >> 5) & 0x1F];
          if ((unint64_t)v6 >= v10 || i >= v15)
          {
            if (i <= v14) {
              goto LABEL_32;
            }
            return 0LL;
          }
        }
      }

      for (unint64_t i = v12; ; unint64_t i = &v31[v26])
      {
LABEL_32:
        if (i >= v14) {
          goto LABEL_29;
        }
        if (v8 - v6 < 3) {
          return 0LL;
        }
        unint64_t v24 = *(unsigned __int16 *)v6;
        uint64_t v25 = v24 & 0x1F;
        uint64_t v26 = (v24 >> 5) & 0x1F;
        int v27 = v6 + 3;
        if (v8 - (v6 + 3) < v25) {
          return 0LL;
        }
        unint64_t v28 = *(unsigned __int16 *)(v6 + 1);
        unsigned int v29 = (uint64_t *)(v6 + 3);
        unint64_t v30 = i;
        if ((v24 & 0x10) != 0)
        {
          *(_OWORD *)unint64_t i = *(_OWORD *)(v6 + 3);
          unint64_t v30 = i + 16;
          unsigned int v29 = (uint64_t *)(v6 + 19);
          if ((v24 & 8) == 0)
          {
LABEL_38:
            if ((v24 & 4) == 0) {
              goto LABEL_39;
            }
            goto LABEL_48;
          }
        }

        else if ((v24 & 8) == 0)
        {
          goto LABEL_38;
        }

        uint64_t v34 = *v29++;
        *v30++ = v34;
        if ((v24 & 4) == 0)
        {
LABEL_39:
          if ((v24 & 2) == 0) {
            goto LABEL_40;
          }
          goto LABEL_49;
        }

LABEL_49:
        __int16 v36 = *(_WORD *)v29;
        unsigned int v29 = (uint64_t *)((char *)v29 + 2);
        *(_WORD *)unint64_t v30 = v36;
        unint64_t v30 = (void *)((char *)v30 + 2);
        if ((v24 & 1) != 0) {
          goto LABEL_41;
        }
LABEL_42:
        uint64_t v31 = &i[v25];
        unint64_t v32 = (__int128 *)&v31[-(v28 >> 2)];
        if ((v24 & 0x200) != 0)
        {
          __int128 v37 = *v32++;
          *(_OWORD *)uint64_t v31 = v37;
          unint64_t v33 = v31 + 16;
          if ((v24 & 0x100) == 0) {
            goto LABEL_53;
          }
LABEL_52:
          uint64_t v38 = *(void *)v32;
          unint64_t v32 = (__int128 *)((char *)v32 + 8);
          *v33++ = v38;
          goto LABEL_53;
        }

        unint64_t v33 = v31;
        if ((v24 & 0x100) != 0) {
          goto LABEL_52;
        }
LABEL_53:
        if ((v24 & 0x80) != 0)
        {
          int v39 = *(_DWORD *)v32;
          unint64_t v32 = (__int128 *)((char *)v32 + 4);
          *(_DWORD *)unint64_t v33 = v39;
          unint64_t v33 = (void *)((char *)v33 + 4);
          if ((v24 & 0x40) == 0)
          {
LABEL_55:
            if ((v24 & 0x20) == 0) {
              goto LABEL_57;
            }
LABEL_56:
            *(_BYTE *)unint64_t v33 = *(_BYTE *)v32;
            goto LABEL_57;
          }
        }

        else if ((v24 & 0x40) == 0)
        {
          goto LABEL_55;
        }

        __int16 v40 = *(_WORD *)v32;
        unint64_t v32 = (__int128 *)((char *)v32 + 2);
        *(_WORD *)unint64_t v33 = v40;
        unint64_t v33 = (void *)((char *)v33 + 2);
        if ((v24 & 0x20) != 0) {
          goto LABEL_56;
        }
LABEL_57:
        unint64_t v6 = &v27[v25];
      }
    }

    uint64_t v12 = __dst;
    return v12 - __dst;
  }

  return result;
}

void *BrotliDefaultAllocFunc(int a1, size_t __size)
{
  return malloc(__size);
}

void BrotliDefaultFreeFunc(int a1, void *a2)
{
}

uint64_t create_thread(pthread_t *a1, void *(__cdecl *a2)(void *), void *a3, size_t a4)
{
  uint64_t v8 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  int v9 = v8;
  uint64_t v10 = pthread_attr_init(v8);
  if (!(_DWORD)v10)
  {
    if (!a4 || (uint64_t v10 = pthread_attr_setstacksize(v9, a4), !(_DWORD)v10)) {
      uint64_t v10 = pthread_create(a1, v9, a2, a3);
    }
  }

  pthread_attr_destroy(v9);
  free(v9);
  return v10;
}

uint64_t join_thread(_opaque_pthread_t *a1)
{
  unint64_t v2 = 0LL;
  return pthread_join(a1, &v2);
}

uint64_t BrotliInitBitReader(uint64_t result)
{
  *(void *)uint64_t result = 0LL;
  *(_DWORD *)(result + 8) = 64;
  return result;
}

uint64_t BrotliWarmupBitReader(unint64_t *a1)
{
  if (*((_DWORD *)a1 + 2) != 64) {
    return 1LL;
  }
  unint64_t v1 = a1[3];
  if (v1)
  {
    unint64_t v2 = *a1;
    *a1 >>= 8;
    uint64_t v3 = (unsigned __int8 *)a1[2];
    *((void *)&v4 + 1) = *v3;
    *(void *)&__int128 v4 = v2;
    *a1 = v4 >> 8;
    *((_DWORD *)a1 + 2) = 56;
    a1[2] = (unint64_t)(v3 + 1);
    a1[3] = v1 - 1;
    return 1LL;
  }

  return 0LL;
}

uint64_t BrotliSafeReadBits32Slow(unint64_t *a1, int a2, unsigned int *a3)
{
  int v3 = *((_DWORD *)a1 + 2);
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = v4;
  unint64_t v7 = *a1;
  uint64_t v8 = v5;
  unint64_t v9 = *a1;
  int v10 = v3;
  if ((v3 - 49) <= 0xF)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = -1LL;
    unint64_t v9 = *a1;
    int v13 = *((_DWORD *)a1 + 2);
    while (v5 != v11)
    {
      *a1 = v9 >> 8;
      *((void *)&v14 + 1) = *(unsigned __int8 *)(v4 + v11);
      *(void *)&__int128 v14 = v9;
      unint64_t v9 = v14 >> 8;
      *a1 = v9;
      int v10 = v13 - 8;
      *((_DWORD *)a1 + 2) = v13 - 8;
      a1[2] = v4 + v11 + 1;
      a1[3] = v5 + v12;
      ++v11;
      --v12;
      unsigned int v15 = v13 - 57;
      v13 -= 8;
      if (v15 >= 0x10)
      {
        uint64_t v6 = v4 + v11;
        uint64_t v8 = v5 - v11;
        goto LABEL_6;
      }
    }

    goto LABEL_11;
  }

LABEL_6:
  int v16 = v10 + 16;
  *((_DWORD *)a1 + 2) = v10 + 16;
  unsigned int v17 = a2 - 16;
  unsigned int v18 = 48 - v10;
  if (48 - v10 < (a2 - 16))
  {
    unint64_t v19 = v6 + 1;
    unint64_t v20 = v8 - 1;
    unint64_t v21 = v9;
    while (v20 != -1LL)
    {
      *a1 = v21 >> 8;
      *((void *)&v22 + 1) = *(unsigned __int8 *)(v19 - 1);
      *(void *)&__int128 v22 = v21;
      unint64_t v21 = v22 >> 8;
      *a1 = v21;
      v16 -= 8;
      *((_DWORD *)a1 + 2) = v16;
      a1[2] = v19;
      a1[3] = v20;
      ++v19;
      --v20;
      v18 += 8;
      if (v18 >= v17) {
        goto LABEL_13;
      }
    }

  uint64_t result = 0LL;
  *a1 = v7;
  *a4 = v8;
  return result;
}

  *(_WORD *)(result + 5920) = 0;
  *(_DWORD *)(result + 5924) = 0;
  return result;
}

LABEL_11:
    uint64_t v23 = 0LL;
    *a1 = v7;
    *((_DWORD *)a1 + 2) = v3;
    a1[2] = v4;
    a1[3] = v5;
    return v23;
  }

  unint64_t v21 = v9;
LABEL_13:
  *((_DWORD *)a1 + 2) = v16 + v17;
  *a3 = (unsigned __int16)(v9 >> v10) | (((v21 >> v16) & ~(-1 << v17)) << 16);
  return 1LL;
}

      __int128 v14 = *(unsigned __int16 *)(a2 + 4LL * v3);
      unsigned int v15 = *(_DWORD *)(result + 4 * v8 + 2992);
      int v16 = *(unsigned __int16 *)(a2 + 4LL * v15);
      if (v14 < v16
        || v14 == v16
        && *(unsigned __int8 *)(result + v3 + 5292) <= *(unsigned __int8 *)(result + v15 + 5292))
      {
        break;
      }

      *(_DWORD *)(result + 4LL * a3 + 2992) = v15;
      uint64_t v4 = 2 * v6;
      uint64_t v5 = *(_DWORD *)(result + 5284);
      a3 = v6;
      if (2 * v6 > v5) {
        goto LABEL_15;
      }
    }
  }

  uint64_t v6 = a3;
LABEL_15:
  *(_DWORD *)(result + 4LL * v6 + 2992) = v3;
  return result;
}

uint64_t BrotliDecoderSetParameter(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)a1) {
    return 0LL;
  }
  if (a2 == 1)
  {
    __int16 v4 = *(_WORD *)(a1 + 664) & 0xFFDF | (32 * (a3 != 0));
  }

  else
  {
    if (a2) {
      return 0LL;
    }
    __int16 v4 = *(_WORD *)(a1 + 664) & 0xFFEF | (16 * (a3 == 0));
  }

  *(_WORD *)(a1 + 664) = v4;
  return 1LL;
}

void *BrotliDecoderCreateInstance( void *(*a1)(int a1, size_t __size), void (*a2)(int a1, void *a2), uint64_t a3)
{
  BOOL v6 = ((unint64_t)a1 | (unint64_t)a2) != 0;
  if ((unint64_t)a1 | (unint64_t)a2)
  {
    uint64_t result = 0LL;
    if (!a1 || !a2) {
      return result;
    }
    uint64_t v8 = a1(a3, 5152LL);
  }

  else
  {
    uint64_t v8 = malloc(0x1420uLL);
  }

  unint64_t v9 = v8;
  if (!v8) {
    return 0LL;
  }
  if (!v6)
  {
    free(v9);
    return 0LL;
  }

  uint64_t result = 0LL;
  if (a1 && a2)
  {
    a2(a3, v9);
    return 0LL;
  }

  return result;
}

uint64_t BrotliDecoderDestroyInstance(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v3 = *(uint64_t (**)(uint64_t, uint64_t))(result + 48);
    uint64_t v2 = *(void *)(result + 56);
    BrotliDecoderStateCleanup(result);
    return v3(v2, v1);
  }

  return result;
}

uint64_t BrotliDecoderDecompress()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v10 = v0;
  size_t v11 = 0LL;
  size_t v8 = *v1;
  unint64_t v9 = v3;
  unint64_t v7 = v4;
  uint64_t result = BrotliDecoderStateInit((uint64_t)v12, 0LL, 0LL, 0LL);
  if ((_DWORD)result)
  {
    int v6 = BrotliDecoderDecompressStream((uint64_t)v12, &v10, &v9, &v8, &v7, &v11);
    *uint64_t v2 = v11;
    BrotliDecoderStateCleanup((uint64_t)v12);
    return v6 == 1;
  }

  return result;
}

uint64_t BrotliDecoderDecompressStream(uint64_t a1, void *a2, _BYTE **a3, size_t *a4, void **a5, size_t *a6)
{
  unint64_t v7 = a5;
  if (a6) {
    *a6 = *(void *)(a1 + 376);
  }
  if ((*(_DWORD *)(a1 + 116) & 0x80000000) != 0) {
    return 0LL;
  }
  if (*a4)
  {
    if (!a5 || !*a5) {
      return SaveErrorCode(a1, 0xFFFFFFEC);
    }
  }

  else
  {
    unint64_t v7 = 0LL;
  }

  if (*(_DWORD *)(a1 + 72))
  {
    uint64_t v13 = (_BYTE *)(a1 + 64);
    unsigned int HuffmanCode = 2;
  }

  else
  {
    *(void *)(a1 + 32) = *a2;
    uint64_t v13 = *a3;
    unsigned int HuffmanCode = 1;
  }

  unsigned int v15 = (unint64_t *)(a1 + 8);
  uint64_t v16 = a1 + 64;
  *(void *)(a1 + 24) = v13;
  BOOL v162 = (unsigned int *)(a1 + 676);
  uint64_t v163 = (unsigned __int8 **)(a1 + 680);
  unint64_t v160 = (unsigned __int8 **)(a1 + 336);
  uint64_t v161 = (unsigned int *)(a1 + 328);
  uint64_t v158 = a1 + 168;
  uint64_t v159 = a1 + 192;
  unsigned int v17 = (void *)(a1 + 744);
  uint64_t v18 = a1 + 1288;
  uint64_t v156 = a1 + 952;
  uint64_t v157 = a1 + 216;
  uint64_t v154 = (_OWORD *)(a1 + 712);
LABEL_14:
  while (2)
  {
    while (HuffmanCode == 1)
    {
      switch(*(_DWORD *)a1)
      {
        case 0:
          int v24 = BrotliWarmupBitReader(v15);
          unsigned int HuffmanCode = 2;
          if (!v24) {
            continue;
          }
          __int16 v25 = *(_WORD *)(a1 + 664);
          *(_WORD *)(a1 + 664) = v25 & 0xFFDF;
          unint64_t v26 = *(void *)(a1 + 8);
          int v27 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v27 + 1;
          if (((v26 >> v27) & 1) == 0)
          {
            int v29 = 16;
            goto LABEL_173;
          }

          *(_DWORD *)(a1 + 16) = v27 + 4;
          int v28 = (v26 >> (v27 + 1)) & 7;
          if (v28)
          {
            int v29 = v28 + 17;
LABEL_173:
            *(_DWORD *)(a1 + 668) = v29;
            int v22 = 2;
            goto LABEL_177;
          }

          *(_DWORD *)(a1 + 16) = v27 + 7;
          int v137 = (v26 >> (v27 + 4)) & 7;
          if (!v137)
          {
            int v29 = 17;
            goto LABEL_173;
          }

          if (v137 != 1)
          {
            int v29 = v137 | 8;
            goto LABEL_173;
          }

          unsigned int HuffmanCode = -13;
          if ((v25 & 0x20) != 0)
          {
            *(_DWORD *)(a1 + 16) = v27 + 8;
            if (((v26 >> (v27 + 7)) & 1) == 0)
            {
              *(_WORD *)(a1 + 664) = v25 | 0x20;
              unsigned int HuffmanCode = 1;
              *(_DWORD *)a1 = 1;
            }
          }

          continue;
        case 1:
          int v30 = *(_DWORD *)(a1 + 16);
          if ((v30 - 59) >= 6)
          {
            unint64_t v34 = *v15;
          }

          else
          {
            uint64_t v31 = *(void *)(a1 + 32);
            unsigned int HuffmanCode = 2;
            if (!v31) {
              continue;
            }
            unint64_t v32 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v32 >> 8;
            unint64_t v33 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v35 + 1) = *v33;
            *(void *)&__int128 v35 = v32;
            unint64_t v34 = v35 >> 8;
            *(void *)(a1 + 8) = v34;
            v30 -= 8;
            *(void *)(a1 + 24) = v33 + 1;
            *(void *)(a1 + 32) = v31 - 1;
          }

          uint64_t v36 = (v34 >> v30) & 0x3F;
          *(_DWORD *)(a1 + 668) = v36;
          *(_DWORD *)(a1 + 16) = v30 + 6;
          unsigned int HuffmanCode = -13;
          *(_DWORD *)a1 = 2;
LABEL_69:
          *(_DWORD *)(a1 + 80) = (1 << v36) - 16;
          uint64_t v57 = (*(uint64_t (**)(void, uint64_t))(a1 + 40))(*(void *)(a1 + 56), 12336LL);
          *(void *)(a1 + 240) = v57;
          unsigned int HuffmanCode = -30;
          if (!v57) {
            continue;
          }
          *(void *)(a1 + 248) = v57 + 7584;
          *(_DWORD *)a1 = 3;
LABEL_71:
          BrotliDecoderStateMetablockBegin(a1);
          *(_DWORD *)a1 = 4;
LABEL_72:
          unsigned int HuffmanCode = DecodeMetaBlockLength(a1, v15);
          if (HuffmanCode != 1) {
            continue;
          }
          __int16 v58 = *(_WORD *)(a1 + 664);
          if ((v58 & 6) == 0) {
            goto LABEL_77;
          }
          int v59 = *(_DWORD *)(a1 + 16);
          int v60 = -v59 & 7;
          if (v60)
          {
            uint64_t v61 = *(void *)(a1 + 8) >> v59;
            *(_DWORD *)(a1 + 16) = v60 + v59;
            unsigned int HuffmanCode = -14;
          }

          if ((v58 & 4) != 0)
          {
            int v22 = 12;
            goto LABEL_177;
          }

LABEL_77:
          if (!*(_DWORD *)(a1 + 264)) {
            goto LABEL_176;
          }
          BrotliCalculateRingBufferSize(a1);
          if ((*(_WORD *)(a1 + 664) & 2) != 0)
          {
            int v22 = 11;
            goto LABEL_177;
          }

LABEL_79:
          int v51 = 0;
          *(void *)(a1 + 912) = v156;
          void *v17 = 0LL;
          *(void *)(a1 + 752) = 0LL;
          *(void *)a1 = 18LL;
LABEL_80:
          unsigned int HuffmanCode = DecodeVarLenUint8(a1, v15, (unsigned int *)(a1 + 4LL * v51 + 284));
          if (HuffmanCode != 1) {
            continue;
          }
          ++*(_DWORD *)(a1 + 284 + 4LL * *(int *)(a1 + 4));
          uint64_t v52 = *(int *)(a1 + 4);
          unsigned int v53 = *(_DWORD *)(a1 + 284 + 4 * v52);
          if (v53 <= 1)
          {
            *(_DWORD *)(a1 + 4) = v52 + 1;
            unsigned int HuffmanCode = 1;
            continue;
          }

          *(_DWORD *)a1 = 19;
LABEL_114:
          unsigned int HuffmanCode = ReadHuffmanCode( v53 + 2,  v53 + 2,  (int *)(*(void *)(a1 + 240) + 2528LL * (_DWORD)v52),  0LL,  a1);
          if (HuffmanCode != 1) {
            continue;
          }
          *(_DWORD *)a1 = 20;
LABEL_116:
          unsigned int HuffmanCode = ReadHuffmanCode(26, 0x1Au, (int *)(*(void *)(a1 + 248) + 1584LL * *(int *)(a1 + 4)), 0LL, a1);
          if (HuffmanCode != 1) {
            continue;
          }
          *(_DWORD *)a1 = 21;
LABEL_118:
          uint64_t v87 = *(int *)(a1 + 4);
          if (*(_DWORD *)(a1 + 660))
          {
            uint64_t v88 = *(unsigned int *)(a1 + 268);
            goto LABEL_129;
          }

          unint64_t v89 = (_BYTE *)(*(void *)(a1 + 248) + 1584LL * (int)v87);
          int v90 = *(_DWORD *)(a1 + 16);
          if ((v90 - 50) >= 0xF)
          {
            unint64_t v94 = *v15;
            goto LABEL_126;
          }

          uint64_t v91 = *(void *)(a1 + 32) - 1LL;
          while (v91 != -1)
          {
            unint64_t v92 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v92 >> 8;
            uint64_t v93 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v95 + 1) = *v93;
            *(void *)&__int128 v95 = v92;
            unint64_t v94 = v95 >> 8;
            *(void *)(a1 + 8) = v94;
            int v96 = v90 - 8;
            *(_DWORD *)(a1 + 16) = v90 - 8;
            *(void *)(a1 + 24) = v93 + 1;
            *(void *)(a1 + 32) = v91--;
            LODWORD(v93) = v90 - 58;
            v90 -= 8;
            if (v93 >= 0xF)
            {
              int v90 = v96;
LABEL_126:
              unint64_t v97 = v94 >> v90;
              BOOL v98 = &v89[4 * (v94 >> v90)];
              unsigned int v99 = *v98;
              if (v99 >= 9)
              {
                v90 += 8;
                unsigned int v99 = *v98;
              }

              *(_DWORD *)(a1 + 16) = v90 + v99;
              uint64_t v88 = *((unsigned __int16 *)v98 + 1);
              goto LABEL_129;
            }
          }

          uint64_t v153 = v87;
          uint64_t v88 = v164;
          uint64_t v87 = v153;
LABEL_129:
          unsigned int v100 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v88);
          unsigned int v101 = *((unsigned __int8 *)v100 + 2);
          int v102 = *v100;
          int v103 = *(_DWORD *)(a1 + 16);
          unsigned int v104 = 64 - v103;
          if (64 - v103 >= v101)
          {
            unint64_t v108 = *v15;
LABEL_135:
            *(_DWORD *)(a1 + 16) = v103 + v101;
            *(_DWORD *)(a1 + 4 * v87 + 272) = ((v108 >> v103) & ~(-1 << v101)) + v102;
            *(_DWORD *)(a1 + 660) = 0;
            ++*(_DWORD *)(a1 + 4);
            int v22 = 18;
            goto LABEL_177;
          }

          uint64_t v105 = *(void *)(a1 + 32) - 1LL;
          while (v105 != -1)
          {
            unint64_t v106 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v106 >> 8;
            uint64_t v107 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v109 + 1) = *v107;
            *(void *)&__int128 v109 = v106;
            unint64_t v108 = v109 >> 8;
            *(void *)(a1 + 8) = v108;
            v103 -= 8;
            *(_DWORD *)(a1 + 16) = v103;
            *(void *)(a1 + 24) = v107 + 1;
            *(void *)(a1 + 32) = v105--;
            v104 += 8;
            if (v104 >= v101) {
              goto LABEL_135;
            }
          }

          *(_DWORD *)(a1 + 268) = v88;
          *(_DWORD *)(a1 + 660) = 1;
          goto LABEL_180;
        case 2:
          LODWORD(v36) = *(_DWORD *)(a1 + 668);
          goto LABEL_69;
        case 3:
          goto LABEL_71;
        case 4:
          goto LABEL_72;
        case 5:
          int v37 = *(_DWORD *)(a1 + 16);
          if ((v37 - 59) >= 6)
          {
            unint64_t v41 = *v15;
          }

          else
          {
            uint64_t v38 = *(void *)(a1 + 32);
            unsigned int HuffmanCode = 2;
            if (!v38) {
              continue;
            }
            unint64_t v39 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v39 >> 8;
            __int16 v40 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v42 + 1) = *v40;
            *(void *)&__int128 v42 = v39;
            unint64_t v41 = v42 >> 8;
            *(void *)(a1 + 8) = v41;
            v37 -= 8;
            *(void *)(a1 + 24) = v40 + 1;
            *(void *)(a1 + 32) = v38 - 1;
          }

          unint64_t v62 = v41 >> v37;
          *(_DWORD *)(a1 + 16) = v37 + 6;
          int v63 = (v41 >> v37) & 3;
          *(_DWORD *)(a1 + 320) = v63;
          *(_DWORD *)(a1 + 324) = ((v62 >> 2) & 0xF) << v63;
          uint64_t v64 = (*(uint64_t (**)(void, void))(a1 + 40))(*(void *)(a1 + 56), *(unsigned int *)(a1 + 284));
          *(void *)(a1 + 688) = v64;
          unsigned int HuffmanCode = -21;
          if (!v64) {
            continue;
          }
          LODWORD(i) = 0;
          *(void *)a1 = 6LL;
LABEL_86:
          LODWORD(v54) = *(_DWORD *)(a1 + 284);
          if ((int)i < (int)v54)
          {
            for (uint64_t i = (int)i; i < v54; ++i)
            {
              int v65 = *(_DWORD *)(a1 + 16);
              if ((v65 - 63) >= 2)
              {
                unint64_t v69 = *v15;
              }

              else
              {
                uint64_t v66 = *(void *)(a1 + 32);
                if (!v66)
                {
                  *(_DWORD *)(a1 + 4) = i;
LABEL_180:
                  unsigned int HuffmanCode = 2;
                  goto LABEL_14;
                }

                unint64_t v67 = *(void *)(a1 + 8);
                *(void *)(a1 + 8) = v67 >> 8;
                unint64_t v68 = *(unsigned __int8 **)(a1 + 24);
                *((void *)&v70 + 1) = *v68;
                *(void *)&__int128 v70 = v67;
                unint64_t v69 = v70 >> 8;
                *(void *)(a1 + 8) = v69;
                v65 -= 8;
                *(void *)(a1 + 24) = v68 + 1;
                *(void *)(a1 + 32) = v66 - 1;
              }

              *(_DWORD *)(a1 + 16) = v65 + 2;
              *(_BYTE *)(*(void *)(a1 + 688) + i) = (v69 >> v65) & 3;
              uint64_t v54 = *(int *)(a1 + 284);
            }
          }

          *(_DWORD *)a1 = 22;
LABEL_94:
          unsigned int HuffmanCode = DecodeContextMap((_DWORD)v54 << 6, v162, v163, a1);
          if (HuffmanCode == 1)
          {
            *uint64_t v154 = 0u;
            v154[1] = 0u;
            uint64_t v71 = *(unsigned int *)(a1 + 284);
            if ((_DWORD)v71)
            {
              unint64_t v72 = 0LL;
              unint64_t v73 = *v163;
              do
              {
                int8x16x4_t v166 = vld4q_s8((const char *)v73);
                int8x16_t v74 = vld1q_dup_s8((const char *)v73);
                v166.val[0] = vorrq_s8( vorrq_s8(veorq_s8(v166.val[1], v74), veorq_s8(v166.val[0], v74)),  vorrq_s8(veorq_s8(v166.val[2], v74), veorq_s8(v166.val[3], v74)));
                v166.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v166.val[0]);
                v166.val[2] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v166.val[1].i8);
                v166.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v166.val[0].i8);
                int8x16_t v75 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v166.val[0].i8);
                v166.val[1] = (int8x16_t)vmovl_high_u16((uint16x8_t)v166.val[1]);
                v166.val[0] = (int8x16_t)vmovl_high_u16((uint16x8_t)v166.val[0]);
                *(int8x8_t *)v166.val[0].i8 = vorr_s8( vorr_s8( vorr_s8(*(int8x8_t *)v75.i8, *(int8x8_t *)v166.val[2].i8),  vorr_s8(*(int8x8_t *)v166.val[0].i8, *(int8x8_t *)v166.val[1].i8)),  vorr_s8( vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v166.val[2], v166.val[2], 8uLL)),  vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v166.val[0], v166.val[0], 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v166.val[1], v166.val[1], 8uLL))));
                v76.i64[0] = v166.val[0].u32[0];
                v76.i64[1] = v166.val[0].u32[1];
                ++v72;
                v73 += 64;
              }

              while (v71 != v72);
            }

            *(_DWORD *)a1 = 23;
LABEL_101:
            int v77 = *(_DWORD *)(a1 + 320);
            unsigned int v78 = *(_DWORD *)(a1 + 324);
            unsigned int v79 = v78 + 16;
            char v80 = v77 + 1;
            if ((*(_WORD *)(a1 + 664) & 0x20) != 0)
            {
              if (v78 <= 0x7FFFFFFB)
              {
                int v81 = v78 + 16;
                char v82 = -1;
                int v83 = -5;
                unsigned int v84 = ((2147483644 - v78) >> v77) + 4;
                do
                {
                  ++v82;
                  v83 += 2;
                  BOOL v85 = v84 > 3;
                  v84 >>= 1;
                }

                while (v85);
                unsigned int v86 = (((((2147483644 - v78) >> v77) + 4) >> v82) & 1) + v83;
                if (v86 != -1) {
                  int v81 = v78 + ((v86 << v77) | ~(-1 << v77)) + 17;
                }
              }

              else
              {
                int v81 = -2147483636;
              }

              int v151 = v79 + (62 << v80);
              int v152 = v81;
            }

            else
            {
              int v151 = v79 + (24 << v80);
              int v152 = v151;
            }

            unsigned int HuffmanCode = DecodeContextMap(4 * *(_DWORD *)(a1 + 292), v161, v160, a1);
            if (HuffmanCode == 1)
            {
              unint64_t v155 = v15;
              uint64_t v56 = v158;
              BOOL v149 = BrotliDecoderHuffmanTreeGroupInit(a1, v158, 256, 256, *(_DWORD *)(a1 + 676));
              int v150 = v149 & BrotliDecoderHuffmanTreeGroupInit(a1, v159, 704, 704, *(_DWORD *)(a1 + 288));
              if ((v150 & BrotliDecoderHuffmanTreeGroupInit(a1, v157, v151, v152, *(_DWORD *)(a1 + 328)) & 1) == 0)
              {
                uint64_t v148 = a1;
                unsigned int HuffmanCode = -22;
                return SaveErrorCode(v148, HuffmanCode);
              }

              int v55 = 0;
              *(void *)a1 = 24LL;
LABEL_139:
              if (*(_DWORD *)v17 == 1)
              {
                int v110 = *(_DWORD *)(a1 + 2540);
              }

              else
              {
                int v110 = 0;
                *(void *)(a1 + 2544) = *(void *)(v56 + 8);
                *(_DWORD *)(a1 + 2540) = 0;
                *(_DWORD *)(a1 + 744) = 1;
              }

              if (v110 >= *(unsigned __int16 *)(v56 + 20))
              {
LABEL_147:
                *(_DWORD *)(a1 + 744) = 0;
                *(_DWORD *)(a1 + 4) = v55 + 1;
                unsigned int HuffmanCode = 1;
                unsigned int v15 = v155;
                if (v55 >= 2)
                {
                  *(_DWORD *)a1 = 25;
LABEL_149:
                  unint64_t v114 = *(unsigned int *)(a1 + 300);
                  uint64_t v115 = ((_DWORD)v114 << 6);
                  uint64_t v116 = *(void *)(a1 + 680);
                  *(void *)(a1 + 152) = v116 + v115;
                  *(_DWORD *)(a1 + 256) = (*(_DWORD *)(a1 + ((v114 >> 3) & 0x1FFFFFFC) + 712) >> v114) & 1;
                  *(void *)(a1 + 344) = *(void *)(*(void *)(a1 + 168)
                                                    + 8LL * *(unsigned __int8 *)(v116 + v115));
                  *(void *)(a1 + 144) = &_kBrotliContextLookupTable[512
                  *(void *)(a1 + 160) = *(void *)(a1 + 336);
                  *(void *)(a1 + 136) = **(void **)(a1 + 192);
                  int v117 = BrotliEnsureRingBuffer(a1);
                  unsigned int HuffmanCode = -27;
                  if (v117)
                  {
                    int v118 = *(_DWORD *)(a1 + 324);
                    if (v118)
                    {
                      for (int j = 0; j != v118; *(_DWORD *)(v18 + 4LL * v120) = j)
                      {
                        unsigned int v120 = j + 16;
                        *((_BYTE *)v17 + v120) = 0;
                        ++j;
                      }

                      unsigned int v121 = j + 16;
                    }

                    else
                    {
                      unsigned int v121 = 16;
                    }

                    unsigned int v122 = *(unsigned __int16 *)(a1 + 234);
                    if (v121 < v122)
                    {
                      int v123 = 0;
                      int v124 = *(_DWORD *)(a1 + 320);
                      char v125 = 1;
                      do
                      {
                        unsigned int v126 = 1;
                        do
                        {
                          unsigned int v127 = v121 + v126 - 1;
                          *((_BYTE *)v17 + v127) = v125;
                          *(_DWORD *)(v18 + 4LL * v127) = v118 + ((((v123 + 2) << v125) - 4) << v124) + v126;
                        }

                        while (!(v126++ >> v124));
                        v125 += v123;
                        v123 ^= 1u;
                        unsigned int v121 = v121 + v126 - 1;
                      }

                      while (v121 < v122);
                    }

                    *(_DWORD *)a1 = 7;
LABEL_162:
                    unsigned int HuffmanCode = ProcessCommands(a1);
                    if (HuffmanCode == 2) {
                      unsigned int HuffmanCode = SafeProcessCommands(a1);
                    }
                  }
                }
              }

              else
              {
                unint64_t v111 = *(int **)(a1 + 2544);
                while (1)
                {
                  unsigned int v112 = ReadHuffmanCode( *(unsigned __int16 *)(v56 + 16),  *(unsigned __int16 *)(v56 + 18),  v111,  &v165,  a1);
                  if (v112 != 1) {
                    break;
                  }
                  uint64_t v113 = *(int *)(a1 + 2540);
                  *(void *)(*(void *)v56 + 8 * v113) = *(void *)(a1 + 2544);
                  unint64_t v111 = (int *)(*(void *)(a1 + 2544) + 4LL * v165);
                  *(void *)(a1 + 2544) = v111;
                  *(_DWORD *)(a1 + 2540) = v113 + 1;
                  if ((int)v113 + 1 >= *(unsigned __int16 *)(v56 + 20))
                  {
                    int v55 = *(_DWORD *)(a1 + 4);
                    goto LABEL_147;
                  }
                }

                unsigned int HuffmanCode = v112;
                unsigned int v15 = v155;
              }
            }
          }

          break;
        case 6:
          LODWORD(i) = *(_DWORD *)(a1 + 4);
          goto LABEL_86;
        case 7:
        case 8:
        case 9:
        case 0xA:
          goto LABEL_162;
        case 0xB:
          unsigned int HuffmanCode = CopyUncompressedBlockToOutput(a4, v7, a6, a1);
          if (HuffmanCode == 1) {
            *(_DWORD *)a1 = 14;
          }
          continue;
        case 0xC:
          int v44 = *(_DWORD *)(a1 + 264);
          if (v44 < 1) {
            goto LABEL_176;
          }
          int v45 = *(_DWORD *)(a1 + 16);
          int v46 = v44 + 1;
          do
          {
            if ((v45 - 57) <= 7)
            {
              uint64_t v47 = *(void *)(a1 + 32);
              if (!v47) {
                goto LABEL_180;
              }
              unint64_t v48 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v48 >> 8;
              uint64_t v49 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v50 + 1) = *v49;
              *(void *)&__int128 v50 = v48;
              *(void *)(a1 + 8) = v50 >> 8;
              v45 -= 8;
              *(void *)(a1 + 24) = v49 + 1;
              *(void *)(a1 + 32) = v47 - 1;
            }

            v45 += 8;
            *(_DWORD *)(a1 + 16) = v45;
            *(_DWORD *)(a1 + 264) = v46 - 2;
            --v46;
          }

          while (v46 > 1);
LABEL_176:
          int v22 = 14;
          goto LABEL_177;
        case 0xD:
        case 0xF:
        case 0x10:
          unsigned int HuffmanCode = WriteRingBuffer(a1, a4, v7, a6, 0);
          if (HuffmanCode != 1) {
            continue;
          }
          WrapRingBuffer((void **)a1);
          if (*(_DWORD *)(a1 + 88) == 1 << *(_DWORD *)(a1 + 668)) {
            *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 80);
          }
          if (*(_DWORD *)a1 == 16)
          {
            int v22 = 10;
            goto LABEL_177;
          }

          if (*(_DWORD *)a1 == 15)
          {
            if (!*(_DWORD *)(a1 + 264)) {
              goto LABEL_176;
            }
            int v22 = 7;
            goto LABEL_177;
          }

          if (*(_DWORD *)(a1 + 4))
          {
            int v22 = 8;
            goto LABEL_177;
          }

          if (*(_DWORD *)(a1 + 264))
          {
            int v22 = 9;
            goto LABEL_177;
          }

          goto LABEL_176;
        case 0xE:
          unsigned int HuffmanCode = -10;
          if ((*(_DWORD *)(a1 + 264) & 0x80000000) != 0) {
            continue;
          }
          BrotliDecoderStateCleanupAfterMetablock(a1);
          if ((*(_WORD *)(a1 + 664) & 1) != 0)
          {
            int v129 = *(_DWORD *)(a1 + 16);
            int v130 = -v129 & 7;
            if (!v130
              || (uint64_t v131 = *(void *)(a1 + 8) >> v129,
                  v129 += v130,
                  *(_DWORD *)(a1 + 16) = v129,
                  unsigned int HuffmanCode = -15,
                  (v131 & ~(-1 << v130)) == 0))
            {
              if (!*(_DWORD *)(a1 + 72))
              {
                uint64_t v132 = (64 - v129) >> 3;
                unsigned int v133 = (64 - v129) & 0xFFFFFFF8;
                uint64_t v134 = *(void *)(a1 + 32) + v132;
                uint64_t v135 = (_BYTE *)(*(void *)(a1 + 24) - v132);
                *(void *)(a1 + 24) = v135;
                *(void *)(a1 + 32) = v134;
                if (v133 == 64) {
                  unint64_t v136 = 0LL;
                }
                else {
                  unint64_t v136 = *v15 << v133;
                }
                *(void *)(a1 + 8) = v136;
                *(_DWORD *)(a1 + 16) = v133 + v129;
                *a2 = v134;
                *a3 = v135;
              }

              *(_DWORD *)a1 = 26;
LABEL_191:
              if (!*(void *)(a1 + 120) || (unsigned int HuffmanCode = WriteRingBuffer(a1, a4, v7, a6, 1), HuffmanCode == 1))
              {
                uint64_t v148 = a1;
                unsigned int HuffmanCode = 1;
                return SaveErrorCode(v148, HuffmanCode);
              }
            }
          }

          else
          {
            int v22 = 3;
LABEL_177:
            *(_DWORD *)a1 = v22;
            unsigned int HuffmanCode = 1;
          }

          continue;
        case 0x11:
          goto LABEL_79;
        case 0x12:
          int v51 = *(_DWORD *)(a1 + 4);
          if (v51 < 3) {
            goto LABEL_80;
          }
          int v22 = 5;
          goto LABEL_177;
        case 0x13:
          uint64_t v52 = *(int *)(a1 + 4);
          unsigned int v53 = *(_DWORD *)(a1 + 4 * v52 + 284);
          goto LABEL_114;
        case 0x14:
          goto LABEL_116;
        case 0x15:
          goto LABEL_118;
        case 0x16:
          LODWORD(v54) = *(_DWORD *)(a1 + 284);
          goto LABEL_94;
        case 0x17:
          goto LABEL_101;
        case 0x18:
          int v55 = *(_DWORD *)(a1 + 4);
          unint64_t v155 = v15;
          if (v55)
          {
            if (v55 == 2)
            {
              uint64_t v56 = v157;
            }

            else
            {
              uint64_t v56 = v159;
              if (v55 != 1)
              {
                uint64_t v148 = a1;
                unsigned int HuffmanCode = -31;
                return SaveErrorCode(v148, HuffmanCode);
              }
            }
          }

          else
          {
            uint64_t v56 = v158;
          }

          goto LABEL_139;
        case 0x19:
          goto LABEL_149;
        case 0x1A:
          goto LABEL_191;
        default:
          continue;
      }
    }

    if (HuffmanCode == 2)
    {
      if (*(void *)(a1 + 120) && (unsigned int v19 = WriteRingBuffer(a1, a4, v7, a6, 1), (v19 & 0x80000000) != 0))
      {
        unsigned int HuffmanCode = v19;
      }

      else
      {
        uint64_t v20 = *(unsigned int *)(a1 + 72);
        if ((_DWORD)v20)
        {
          if (!*(void *)(a1 + 32))
          {
            *(_DWORD *)(a1 + 72) = 0;
            uint64_t v23 = *a2;
            *(void *)(a1 + 24) = *a3;
            *(void *)(a1 + 32) = v23;
            unsigned int HuffmanCode = 1;
            continue;
          }

          if (*a2)
          {
            *(_BYTE *)(v16 + v20) = **a3;
            uint64_t v21 = (*(_DWORD *)(a1 + 72) + 1);
            *(_DWORD *)(a1 + 72) = v21;
            *(void *)(a1 + 32) = v21;
            ++*a3;
            --*a2;
            unsigned int HuffmanCode = 1;
            continue;
          }
        }

        else
        {
          uint64_t v138 = *(_BYTE **)(a1 + 24);
          uint64_t v139 = *(void *)(a1 + 32);
          *a3 = v138;
          *a2 = v139;
          if (v139)
          {
            unsigned int v140 = 0;
            do
            {
              *(_BYTE *)(v16 + v140) = *v138;
              unsigned int v140 = *(_DWORD *)(a1 + 72) + 1;
              *(_DWORD *)(a1 + 72) = v140;
              uint64_t v138 = *a3 + 1;
              *a3 = v138;
            }

            while ((*a2)-- != 1LL);
          }
        }

        unsigned int HuffmanCode = 2;
      }
    }

    else if (*(_DWORD *)(a1 + 72))
    {
      *(_DWORD *)(a1 + 72) = 0;
    }

    else
    {
      int v142 = *(_DWORD *)(a1 + 16);
      uint64_t v143 = (64 - v142) >> 3;
      unsigned int v144 = (64 - v142) & 0xFFFFFFF8;
      uint64_t v145 = *(void *)(a1 + 32) + v143;
      uint64_t v146 = (_BYTE *)(*(void *)(a1 + 24) - v143);
      *(void *)(a1 + 24) = v146;
      *(void *)(a1 + 32) = v145;
      if (v144 == 64) {
        unint64_t v147 = 0LL;
      }
      else {
        unint64_t v147 = *v15 << v144;
      }
      *(void *)(a1 + 8) = v147;
      *(_DWORD *)(a1 + 16) = v144 + v142;
      *a2 = v145;
      *a3 = v146;
    }

    break;
  }

  uint64_t v148 = a1;
  return SaveErrorCode(v148, HuffmanCode);
}

uint64_t SaveErrorCode(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 116) = a2;
  if (a2 - 1 >= 3) {
    return 0LL;
  }
  else {
    return a2;
  }
}

uint64_t WriteRingBuffer(uint64_t a1, size_t *a2, void **a3, size_t *a4, int a5)
{
  uint64_t v5 = *(int *)(a1 + 88);
  else {
    int v6 = *(_DWORD *)(a1 + 76);
  }
  uint64_t v7 = *(void *)(a1 + 376);
  uint64_t v8 = *(void *)(a1 + 368) * v5 - v7;
  size_t v9 = v8 + v6;
  size_t v10 = *a2;
  if (*a2 >= v9) {
    size_t v11 = v8 + v6;
  }
  else {
    size_t v11 = *a2;
  }
  if ((*(_DWORD *)(a1 + 264) & 0x80000000) != 0) {
    return 4294967287LL;
  }
  if (!a3) {
    goto LABEL_13;
  }
  unsigned int v17 = (void *)(*(void *)(a1 + 120) + (v7 & *(int *)(a1 + 92)));
  if (!*a3)
  {
    *a3 = v17;
LABEL_13:
    size_t v18 = v10;
    goto LABEL_14;
  }

  memcpy(*a3, v17, v11);
  *a3 = (char *)*a3 + v11;
  size_t v18 = *a2;
LABEL_14:
  *a2 = v18 - v11;
  size_t v20 = *(void *)(a1 + 376) + v11;
  *(void *)(a1 + 376) = v20;
  if (a4) {
    *a4 = v20;
  }
  int v21 = *(_DWORD *)(a1 + 88);
  int v22 = 1 << *(_DWORD *)(a1 + 668);
  if (v9 <= v10)
  {
    if (v21 == v22)
    {
      int v24 = *(_DWORD *)(a1 + 76);
      BOOL v25 = __OFSUB__(v24, v21);
      int v26 = v24 - v21;
      if (v26 < 0 == v25)
      {
        *(_DWORD *)(a1 + 76) = v26;
        ++*(void *)(a1 + 368);
        *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xFFF7 | (8 * (v26 != 0));
      }
    }

    return 1LL;
  }

  else if (v21 != v22 && a5 == 0)
  {
    return 1LL;
  }

  else
  {
    return 3LL;
  }

uint64_t DecodeMetaBlockLength(uint64_t a1, unint64_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 648);
  while (2)
  {
    switch(v2)
    {
      case 0:
        int v3 = *((_DWORD *)a2 + 2);
        if (v3 == 64)
        {
          unint64_t v4 = a2[3];
          if (!v4) {
            return 2LL;
          }
          unint64_t v5 = *a2;
          *a2 >>= 8;
          int v6 = (unsigned __int8 *)a2[2];
          *((void *)&v8 + 1) = *v6;
          *(void *)&__int128 v8 = v5;
          unint64_t v7 = v8 >> 8;
          *a2 = v7;
          a2[2] = (unint64_t)(v6 + 1);
          a2[3] = v4 - 1;
          int v3 = 56;
        }

        else
        {
          unint64_t v7 = *a2;
        }

        *((_DWORD *)a2 + 2) = v3 + 1;
        uint64_t v10 = v7 & (1LL << v3);
        __int16 v11 = *(_WORD *)(a1 + 664) & 0xFFF8 | (v10 != 0);
        *(_DWORD *)(a1 + 264) = 0;
        *(_WORD *)(a1 + 664) = v11;
        if (v10)
        {
          *(_DWORD *)(a1 + 648) = 1;
          goto LABEL_10;
        }

        int v2 = 2;
        goto LABEL_22;
      case 1:
LABEL_10:
        int v12 = *((_DWORD *)a2 + 2);
        if (v12 == 64)
        {
          unint64_t v13 = a2[3];
          if (!v13) {
            return 2LL;
          }
          unint64_t v14 = *a2;
          *a2 >>= 8;
          unsigned int v15 = (unsigned __int8 *)a2[2];
          *((void *)&v17 + 1) = *v15;
          *(void *)&__int128 v17 = v14;
          unint64_t v16 = v17 >> 8;
          *a2 = v16;
          a2[2] = (unint64_t)(v15 + 1);
          a2[3] = v13 - 1;
          int v12 = 56;
        }

        else
        {
          unint64_t v16 = *a2;
        }

        int v9 = v12 + 1;
        *((_DWORD *)a2 + 2) = v12 + 1;
        if (((v16 >> v12) & 1) != 0) {
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 648) = 2;
LABEL_16:
        if ((v9 - 63) >= 2)
        {
          unint64_t v21 = *a2;
        }

        else
        {
          unint64_t v18 = a2[3];
          if (!v18) {
            return 2LL;
          }
          unint64_t v19 = *a2;
          *a2 >>= 8;
          size_t v20 = (unsigned __int8 *)a2[2];
          *((void *)&v22 + 1) = *v20;
          *(void *)&__int128 v22 = v19;
          unint64_t v21 = v22 >> 8;
          *a2 = v21;
          v9 -= 8;
          a2[2] = (unint64_t)(v20 + 1);
          a2[3] = v18 - 1;
        }

        unint64_t v23 = v21 >> v9;
        *((_DWORD *)a2 + 2) = v9 + 2;
        unsigned int v24 = *(_WORD *)(a1 + 664) & 0xC03F | ((v23 & 3) << 6) | 0x100;
        *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xC03F | ((v23 & 3) << 6) | 0x100;
        *(_DWORD *)(a1 + 4) = 0;
        if ((v23 & 3) == 3)
        {
          *(_WORD *)(a1 + 664) = v24 | 4;
          int v2 = 5;
LABEL_22:
          *(_DWORD *)(a1 + 648) = v2;
          continue;
        }

        int v25 = 0;
        *(_DWORD *)(a1 + 648) = 3;
LABEL_27:
        if (v25 < (v24 >> 6))
        {
          int v27 = *((_DWORD *)a2 + 2);
          int v28 = 4 * v25;
          do
          {
            if ((v27 - 61) >= 4)
            {
              unint64_t v32 = *a2;
            }

            else
            {
              unint64_t v29 = a2[3];
              if (!v29)
              {
LABEL_85:
                *(_DWORD *)(a1 + 4) = v25;
                return 2LL;
              }

              unint64_t v30 = *a2;
              *a2 >>= 8;
              uint64_t v31 = (unsigned __int8 *)a2[2];
              *((void *)&v33 + 1) = *v31;
              *(void *)&__int128 v33 = v30;
              unint64_t v32 = v33 >> 8;
              *a2 = v32;
              v27 -= 8;
              a2[2] = (unint64_t)(v31 + 1);
              a2[3] = v29 - 1;
            }

            uint64_t v34 = (v32 >> v27) & 0xF;
            v27 += 4;
            *((_DWORD *)a2 + 2) = v27;
            ++v25;
            unsigned int v24 = *(unsigned __int16 *)(a1 + 664);
            unsigned int v35 = (v24 >> 6);
            if (v25 == v35 && v35 >= 5 && (_DWORD)v34 == 0) {
              return 0xFFFFFFFFLL;
            }
            *(_DWORD *)(a1 + 264) |= (_DWORD)v34 << v28;
            v28 += 4;
          }

          while (v25 < (int)v35);
        }

        *(_DWORD *)(a1 + 648) = 4;
        if ((v24 & 1) == 0)
        {
LABEL_44:
          int v38 = *((_DWORD *)a2 + 2);
          if (v38 == 64)
          {
            unint64_t v39 = a2[3];
            if (!v39) {
              return 2LL;
            }
            unint64_t v40 = *a2;
            *a2 >>= 8;
            unint64_t v41 = (unsigned __int8 *)a2[2];
            *((void *)&v43 + 1) = *v41;
            *(void *)&__int128 v43 = v40;
            unint64_t v42 = v43 >> 8;
            *a2 = v42;
            a2[2] = (unint64_t)(v41 + 1);
            a2[3] = v39 - 1;
            int v38 = 56;
          }

          else
          {
            unint64_t v42 = *a2;
          }

          *((_DWORD *)a2 + 2) = v38 + 1;
          *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xFFFD | (2 * ((v42 >> v38) & 1));
        }

LABEL_54:
        int v52 = *(_DWORD *)(a1 + 264) + 1;
LABEL_83:
        *(_DWORD *)(a1 + 264) = v52;
LABEL_84:
        *(_DWORD *)(a1 + 648) = 0;
        return 1LL;
      case 2:
        int v9 = *((_DWORD *)a2 + 2);
        goto LABEL_16;
      case 3:
        int v25 = *(_DWORD *)(a1 + 4);
        unsigned int v24 = *(unsigned __int16 *)(a1 + 664);
        goto LABEL_27;
      case 4:
        if ((*(_WORD *)(a1 + 664) & 1) == 0) {
          goto LABEL_44;
        }
        goto LABEL_54;
      case 5:
        int v44 = *((_DWORD *)a2 + 2);
        if (v44 == 64)
        {
          unint64_t v45 = a2[3];
          if (!v45) {
            return 2LL;
          }
          unint64_t v46 = *a2;
          *a2 >>= 8;
          uint64_t v47 = (unsigned __int8 *)a2[2];
          *((void *)&v49 + 1) = *v47;
          *(void *)&__int128 v49 = v46;
          unint64_t v48 = v49 >> 8;
          *a2 = v48;
          a2[2] = (unint64_t)(v47 + 1);
          a2[3] = v45 - 1;
          int v44 = 56;
        }

        else
        {
          unint64_t v48 = *a2;
        }

        int v50 = v44 + 1;
        *((_DWORD *)a2 + 2) = v44 + 1;
        if (((v48 >> v44) & 1) != 0) {
          return 4294967294LL;
        }
        *(_DWORD *)(a1 + 648) = 6;
LABEL_60:
        if ((v50 - 63) >= 2)
        {
          unint64_t v56 = *a2;
        }

        else
        {
          unint64_t v53 = a2[3];
          if (!v53) {
            return 2LL;
          }
          unint64_t v54 = *a2;
          *a2 >>= 8;
          int v55 = (unsigned __int8 *)a2[2];
          *((void *)&v57 + 1) = *v55;
          *(void *)&__int128 v57 = v54;
          unint64_t v56 = v57 >> 8;
          *a2 = v56;
          v50 -= 8;
          a2[2] = (unint64_t)(v55 + 1);
          a2[3] = v53 - 1;
        }

        *((_DWORD *)a2 + 2) = v50 + 2;
        int v58 = (v56 >> v50) & 3;
        if (!v58) {
          goto LABEL_84;
        }
        unsigned int v51 = *(_WORD *)(a1 + 664) & 0xC03F | (v58 << 6);
        *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xC03F | ((_WORD)v58 << 6);
        *(_DWORD *)(a1 + 648) = 7;
LABEL_66:
        int v25 = *(_DWORD *)(a1 + 4);
        if (v25 >= (v51 >> 6))
        {
          int v70 = *(_DWORD *)(a1 + 264);
        }

        else
        {
          int v59 = *((_DWORD *)a2 + 2);
          int v60 = 8 * v25;
          do
          {
            if ((v59 - 57) >= 8)
            {
              unint64_t v64 = *a2;
            }

            else
            {
              unint64_t v61 = a2[3];
              if (!v61) {
                goto LABEL_85;
              }
              unint64_t v62 = *a2;
              *a2 >>= 8;
              int v63 = (unsigned __int8 *)a2[2];
              *((void *)&v65 + 1) = *v63;
              *(void *)&__int128 v65 = v62;
              unint64_t v64 = v65 >> 8;
              *a2 = v64;
              v59 -= 8;
              a2[2] = (unint64_t)(v63 + 1);
              a2[3] = v61 - 1;
            }

            int v66 = (v64 >> v59);
            v59 += 8;
            *((_DWORD *)a2 + 2) = v59;
            ++v25;
            unsigned int v67 = (*(unsigned __int16 *)(a1 + 664) >> 6);
            if (v25 == v67 && v67 >= 2 && v66 == 0) {
              return 4294967293LL;
            }
            int v70 = *(_DWORD *)(a1 + 264) | (v66 << v60);
            *(_DWORD *)(a1 + 264) = v70;
            v60 += 8;
          }

          while (v25 < (int)v67);
        }

        int v52 = v70 + 1;
        goto LABEL_83;
      case 6:
        int v50 = *((_DWORD *)a2 + 2);
        goto LABEL_60;
      case 7:
        unsigned int v51 = *(unsigned __int16 *)(a1 + 664);
        goto LABEL_66;
      default:
        return 4294967265LL;
    }
  }

      if (v9 >= v7)
      {
LABEL_55:
        unint64_t v7 = v9;
        if (v18) {
          return v7;
        }
        return 0LL;
      }
    }
  }

  return v7;
}

uint64_t BrotliCalculateRingBufferSize(uint64_t result)
{
  int v1 = 1 << *(_DWORD *)(result + 668);
  int v2 = *(_DWORD *)(result + 88);
  if (v2) {
    int v3 = *(_DWORD *)(result + 88);
  }
  else {
    int v3 = 1024;
  }
  if (v2 != v1)
  {
    __int16 v4 = *(_WORD *)(result + 664);
    if ((v4 & 4) == 0)
    {
      uint64_t v5 = *(void *)(result + 120);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(result + 76);
      }
      int v6 = *(_DWORD *)(result + 264) + v5;
      if (v3 <= v6) {
        int v3 = v6;
      }
      if ((v4 & 0x10) != 0)
      {
        do
        {
          int v7 = v1;
          v1 >>= 1;
        }

        while (v1 >= v3);
      }

      else
      {
        int v7 = 1 << *(_DWORD *)(result + 668);
      }

      *(_DWORD *)(result + 672) = v7;
    }
  }

  return result;
}

uint64_t DecodeVarLenUint8(uint64_t a1, unint64_t *a2, unsigned int *a3)
{
  int v3 = *(_DWORD *)(a1 + 656);
  if (v3)
  {
    if (v3 != 1)
    {
      if (v3 != 2) {
        return 4294967265LL;
      }
      unsigned int v4 = *a3;
      goto LABEL_18;
    }

    int v11 = *((_DWORD *)a2 + 2);
  }

  else
  {
    int v5 = *((_DWORD *)a2 + 2);
    if (v5 == 64)
    {
      unint64_t v6 = a2[3];
      if (!v6) {
        return 2LL;
      }
      unint64_t v7 = *a2;
      *a2 >>= 8;
      __int128 v8 = (unsigned __int8 *)a2[2];
      *((void *)&v10 + 1) = *v8;
      *(void *)&__int128 v10 = v7;
      unint64_t v9 = v10 >> 8;
      *a2 = v9;
      a2[2] = (unint64_t)(v8 + 1);
      a2[3] = v6 - 1;
      int v5 = 56;
    }

    else
    {
      unint64_t v9 = *a2;
    }

    int v11 = v5 + 1;
    *((_DWORD *)a2 + 2) = v5 + 1;
    if (((v9 >> v5) & 1) == 0)
    {
      *a3 = 0;
      return 1LL;
    }
  }

  if ((v11 - 62) >= 3)
  {
    unint64_t v16 = *a2;
    goto LABEL_16;
  }

  unint64_t v13 = a2[3];
  if (!v13)
  {
    *(_DWORD *)(a1 + 656) = 1;
    return 2LL;
  }

  unint64_t v14 = *a2;
  *a2 >>= 8;
  unsigned int v15 = (unsigned __int8 *)a2[2];
  *((void *)&v17 + 1) = *v15;
  *(void *)&__int128 v17 = v14;
  unint64_t v16 = v17 >> 8;
  *a2 = v16;
  v11 -= 8;
  a2[2] = (unint64_t)(v15 + 1);
  a2[3] = v13 - 1;
LABEL_16:
  *((_DWORD *)a2 + 2) = v11 + 3;
  unsigned int v4 = (v16 >> v11) & 7;
  if (!v4)
  {
    uint64_t v12 = 1LL;
    *a3 = 1;
LABEL_26:
    *(_DWORD *)(a1 + 656) = 0;
    return v12;
  }

  *a3 = v4;
LABEL_18:
  int v18 = *((_DWORD *)a2 + 2);
  unsigned int v19 = 64 - v18;
  if (64 - v18 >= v4)
  {
    unint64_t v23 = *a2;
LABEL_24:
    int v25 = (v23 >> v18) & ~(-1 << v4);
    *((_DWORD *)a2 + 2) = v18 + v4;
    uint64_t v12 = 1LL;
    *a3 = (1 << *a3) + v25;
    goto LABEL_26;
  }

  uint64_t v20 = a2[3] - 1;
  while (v20 != -1)
  {
    unint64_t v21 = *a2;
    *a2 >>= 8;
    __int128 v22 = (unsigned __int8 *)a2[2];
    *((void *)&v24 + 1) = *v22;
    *(void *)&__int128 v24 = v21;
    unint64_t v23 = v24 >> 8;
    *a2 = v23;
    v18 -= 8;
    *((_DWORD *)a2 + 2) = v18;
    a2[2] = (unint64_t)(v22 + 1);
    a2[3] = v20--;
    v19 += 8;
    if (v19 >= v4) {
      goto LABEL_24;
    }
  }

  uint64_t v12 = 2LL;
  *(_DWORD *)(a1 + 656) = 2;
  return v12;
}

uint64_t ReadHuffmanCode(int a1, unsigned int a2, int *__src, _DWORD *a4, uint64_t a5)
{
  uint64_t v9 = a5 + 760;
  __int128 v10 = (unint64_t *)(a5 + 8);
  int v11 = *(_DWORD *)(a5 + 752);
  uint64_t v12 = (unsigned __int16 *)(a5 + 2506);
  unint64_t v13 = (void *)(a5 + 2488);
  if (!v11)
  {
    int v14 = *(_DWORD *)(a5 + 16);
    if ((v14 - 63) >= 2)
    {
      unint64_t v18 = *v10;
    }

    else
    {
      uint64_t v15 = *(void *)(a5 + 32);
      if (!v15) {
        return 2LL;
      }
      unint64_t v16 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v16 >> 8;
      __int128 v17 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v19 + 1) = *v17;
      *(void *)&__int128 v19 = v16;
      unint64_t v18 = v19 >> 8;
      *(void *)(a5 + 8) = v18;
      v14 -= 8;
      *(void *)(a5 + 24) = v17 + 1;
      *(void *)(a5 + 32) = v15 - 1;
    }

    uint64_t v20 = (v18 >> v14) & 3;
    *(_DWORD *)(a5 + 756) = v20;
    int v21 = v14 + 2;
    *(_DWORD *)(a5 + 16) = v21;
    if ((_DWORD)v20 != 1)
    {
      *(void *)(a5 + 772) = 0x2000000000LL;
      *(void *)(a5 + 2496) = 0LL;
      *(void *)(a5 + 2504) = 0LL;
      *unint64_t v13 = 0LL;
      *(void *)(a5 + 2510) = 0LL;
      int v11 = 4;
      *(_DWORD *)(a5 + 752) = 4;
      goto LABEL_8;
    }

LABEL_8:
  switch(v11)
  {
    case 1:
      int v21 = *(_DWORD *)(a5 + 16);
      goto LABEL_10;
    case 2:
      goto LABEL_38;
    case 3:
      LODWORD(v28) = *(_DWORD *)(a5 + 768);
      goto LABEL_15;
    case 4:
      int v35 = *(_DWORD *)(a5 + 772);
      int v36 = *(_DWORD *)(a5 + 776);
      uint64_t v37 = *(unsigned int *)(a5 + 756);
      int v38 = *(_DWORD *)(a5 + 16);
      break;
    case 5:
      unsigned int v133 = a2;
      uint64_t v134 = (unsigned __int16 *)(a5 + 2506);
      __srca = (char *)__src;
      uint64_t v132 = a4;
      unsigned int v49 = *(_DWORD *)(a5 + 768);
      int v50 = *(_DWORD *)(a5 + 772);
      int v51 = *(_DWORD *)(a5 + 776);
      int v52 = *(_DWORD *)(a5 + 764);
      LODWORD(v53) = *(_DWORD *)(a5 + 760);
      uint64_t v54 = *(void *)(a5 + 912);
      goto LABEL_67;
    default:
      return 4294967265LL;
  }

  do
  {
    uint64_t v39 = kCodeLengthCodeOrder[v37];
    if ((v38 - 61) >= 4)
    {
      unint64_t v43 = *v10;
      goto LABEL_25;
    }

    uint64_t v40 = *(void *)(a5 + 32);
    if (v40)
    {
      unint64_t v41 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v41 >> 8;
      unint64_t v42 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v44 + 1) = *v42;
      *(void *)&__int128 v44 = v41;
      unint64_t v43 = v44 >> 8;
      *(void *)(a5 + 8) = v43;
      v38 -= 8;
      *(void *)(a5 + 24) = v42 + 1;
      *(void *)(a5 + 32) = v40 - 1;
LABEL_25:
      uint64_t v45 = (v43 >> v38) & 0xF;
      unsigned int v46 = kCodeLengthPrefixLength[v45];
      goto LABEL_26;
    }

    if (v38 == 64) {
      uint64_t v45 = 0LL;
    }
    else {
      uint64_t v45 = *v10 >> v38;
    }
    unsigned int v46 = kCodeLengthPrefixLength[v45];
    if (64 - v38 < v46)
    {
      *(_DWORD *)(a5 + 756) = v37;
      *(_DWORD *)(a5 + 772) = v35;
      *(_DWORD *)(a5 + 776) = v36;
      int v48 = 4;
      goto LABEL_149;
    }

      __int128 v17 = v16;
      if (a3 - (unint64_t)v7 < v16)
      {
        memcpy(v7, v8, (a3 - (_DWORD)v7));
        v7 += (a3 - (_DWORD)v7);
        goto LABEL_6;
      }

      memcpy(v7, v8, v16);
      v8 += v17;
      unint64_t v18 = &v7[v17];
      if ((unint64_t)v8 >= a5)
      {
        v7 += v17;
        goto LABEL_6;
      }

      uint64_t v20 = *(unsigned __int16 *)v8;
      v8 += 2;
      __int128 v19 = v20;
      int v21 = (v14 & 0xF) + 4;
      if ((v14 & 0xF) == 0xF)
      {
        while ((unint64_t)v8 < a5)
        {
          __int128 v26 = *v8++;
          v21 += v26;
          if (v26 != 255) {
            goto LABEL_15;
          }
        }

        return 1LL;
      }

    ++v4;
  }

  while (v4 != 288);
  int v5 = 0LL;
  *(void *)&unint64_t v6 = 0x505050505050505LL;
  *((void *)&v6 + 1) = 0x505050505050505LL;
  v48[0] = v6;
  v48[1] = v6;
  v7.i64[0] = 0x100000001LL;
  v7.i64[1] = 0x100000001LL;
  v8.i64[0] = 0x100000001LL;
  v8.i64[1] = 0x100000001LL;
  v9.i64[0] = 0x100000001LL;
  v9.i64[1] = 0x100000001LL;
  v10.i64[0] = 0x100000001LL;
  v10.i64[1] = 0x100000001LL;
  do
  {
    int v11 = (uint8x16_t)v48[v5 + 2];
    uint64_t v12 = vmovl_u8(*(uint8x8_t *)v11.i8);
    unint64_t v13 = vmovl_high_u8(v11);
    __int128 v10 = vmaxq_s32(v10, (int32x4_t)vmovl_high_u16(v13));
    uint64_t v9 = vmaxq_s32(v9, (int32x4_t)vmovl_u16(*(uint16x4_t *)v13.i8));
    __int128 v8 = vmaxq_s32(v8, (int32x4_t)vmovl_high_u16(v12));
    unint64_t v7 = vmaxq_s32(v7, (int32x4_t)vmovl_u16(*(uint16x4_t *)v12.i8));
    ++v5;
  }

  while (v5 != 18);
  int v14 = 1 << vmaxvq_s32(vmaxq_s32(vmaxq_s32(v7, v9), vmaxq_s32(v8, v10)));
  if (v14 > *a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = 0LL;
  int v52 = 0u;
  uint64_t v53 = 0u;
  int v50 = 0u;
  int v51 = 0u;
  do
    ++*((_DWORD *)&v50 + *((unsigned __int8 *)&v48[2] + v15++));
  while (v15 != 288);
  unint64_t v16 = 0LL;
  __int128 v17 = 0;
  LODWORD(v50) = 0;
  v49[0] = 0;
  do
  {
    __int128 v17 = 2 * (*(_DWORD *)((char *)&v50 + v16 * 4) + v17);
    v49[++v16] = v17;
  }

  while (v16 != 15);
  for (uint64_t i = 0LL;
        i != 288;
        *((_WORD *)&v48[20] + i++) = (breverse_brev8[BYTE1(v20)] | (breverse_brev8[v20] << 8)) >> (16 - v19))
  {
    __int128 v19 = *((unsigned __int8 *)&v48[2] + i);
    uint64_t v20 = v49[v19];
    v49[v19] = v20 + 1;
  }

  for (int j = 0LL; j != 288; ++j)
  {
    uint64_t v22 = *((unsigned __int8 *)&v48[2] + j);
    if (*((_BYTE *)&v48[2] + j))
    {
      unint64_t v23 = *((unsigned __int16 *)&v48[20] + j);
      if (v14 > (int)v23)
      {
        __int128 v24 = v22 + 16 * j - 1;
        unint64_t v25 = 1 << v22;
        do
        {
          *(_WORD *)(a2 + 2 * v23) = v24;
          v23 += v25;
        }

        while (v23 < v14);
      }
    }
  }

  __int128 v26 = 0LL;
  v27.i64[0] = 0x100000001LL;
  v27.i64[1] = 0x100000001LL;
  v28.i64[0] = 0x100000001LL;
  v28.i64[1] = 0x100000001LL;
  v29.i64[0] = 0x100000001LL;
  v29.i64[1] = 0x100000001LL;
  v30.i64[0] = 0x100000001LL;
  v30.i64[1] = 0x100000001LL;
  do
  {
    unint64_t v31 = (uint8x16_t)v48[v26];
    unint64_t v32 = vmovl_u8(*(uint8x8_t *)v31.i8);
    unint64_t v33 = vmovl_high_u8(v31);
    uint64_t v30 = vmaxq_s32(v30, (int32x4_t)vmovl_high_u16(v33));
    int v29 = vmaxq_s32(v29, (int32x4_t)vmovl_u16(*(uint16x4_t *)v33.i8));
    uint64_t v28 = vmaxq_s32(v28, (int32x4_t)vmovl_high_u16(v32));
    int v27 = vmaxq_s32(v27, (int32x4_t)vmovl_u16(*(uint16x4_t *)v32.i8));
    ++v26;
  }

  while (v26 != 2);
  __int128 v34 = 1 << vmaxvq_s32(vmaxq_s32(vmaxq_s32(v27, v29), vmaxq_s32(v28, v30)));
  if (v34 > *a3) {
    return 0xFFFFFFFFLL;
  }
  int v36 = 0LL;
  int v52 = 0u;
  uint64_t v53 = 0u;
  int v50 = 0u;
  int v51 = 0u;
  do
    ++*((_DWORD *)&v50 + *((unsigned __int8 *)v48 + v36++));
  while (v36 != 32);
  uint64_t v37 = 0LL;
  int v38 = 0;
  LODWORD(v50) = 0;
  v49[0] = 0;
  do
  {
    int v38 = 2 * (*(_DWORD *)((char *)&v50 + v37 * 4) + v38);
    v49[++v37] = v38;
  }

  while (v37 != 15);
  for (uint64_t k = 0LL; k != 32; ++k)
  {
    uint64_t v40 = *((unsigned __int8 *)v48 + k);
    unint64_t v41 = v49[v40];
    v49[v40] = v41 + 1;
    *((_WORD *)&v48[20] + k) = (breverse_brev8[BYTE1(v41)] | (breverse_brev8[v41] << 8)) >> (16 - v40);
  }

  for (unint64_t m = 0LL; m != 32; ++m)
  {
    unint64_t v43 = *((unsigned __int8 *)v48 + m);
    if (*((_BYTE *)v48 + m))
    {
      __int128 v44 = *((unsigned __int16 *)&v48[20] + m);
      if (v34 > (int)v44)
      {
        uint64_t v45 = v43 + 16 * m - 1;
        unsigned int v46 = 1 << v43;
        do
        {
          *(_WORD *)(a4 + 2 * v44) = v45;
          v44 += v46;
        }

        while (v44 < v34);
      }
    }
  }

  int v35 = 0LL;
  *a1 = v14;
  *a3 = v34;
  return v35;
}

    __int128 v8 = *(_DWORD *)(a1 + 156);
    uint64_t v9 = ((*(_DWORD *)(a1 + 112) << *(_DWORD *)(a1 + 128)) ^ *(unsigned __int8 *)(*(void *)(a1 + 80) + v8 + 2)) & *(_DWORD *)(a1 + 124);
    *(_DWORD *)(a1 + 112) = v9;
    __int128 v10 = *(void *)(a1 + 104);
    int v11 = *(unsigned __int16 *)(v10 + 2LL * v9);
    *(_WORD *)(*(void *)(a1 + 96) + 2LL * (*(_DWORD *)(a1 + 76) & v8)) = v11;
    *(_WORD *)(v10 + 2LL * v9) = v8;
    *(_DWORD *)(a1 + 168) = v5;
    unint64_t v7 = 2;
    *(_DWORD *)(a1 + 144) = 2;
    *(_DWORD *)(a1 + 148) = v6;
    if (!v11) {
      goto LABEL_18;
    }
    if (v5 < *(_DWORD *)(a1 + 176) && v8 - v11 <= *(_DWORD *)(a1 + 68) - 262)
    {
      unint64_t v7 = longest_match(a1, v11);
      *(_DWORD *)(a1 + 144) = v7;
      if (v7 <= 5)
      {
        if (*(_DWORD *)(a1 + 184) != 1)
        {
          if (v7 != 3) {
            goto LABEL_17;
          }
          if ((*(_DWORD *)(a1 + 156) - *(_DWORD *)(a1 + 160)) <= 0x1000)
          {
            unint64_t v7 = 3;
            goto LABEL_17;
          }
        }

        unint64_t v7 = 2;
        *(_DWORD *)(a1 + 144) = 2;
      }
    }

LABEL_26:
    unsigned int v47 = kCodeLengthPrefixValue[v45];
    v38 += v46;
    *(_DWORD *)(a5 + 16) = v38;
    *(_BYTE *)(a5 + v39 + 2488) = v47;
    if (((0x1111uLL >> v45) & 1) == 0)
    {
      v36 -= 0x20u >> v47;
      ++v35;
      ++*(_WORD *)(a5 + 2LL * v47 + 2506);
    }

    ++v37;
  }

  while ((_DWORD)v37 != 18);
LABEL_59:
  if (v35 != 1 && v36 != 0) {
    return 4294967290LL;
  }
  unsigned int v133 = a2;
  __srca = (char *)__src;
  uint64_t v132 = a4;
  unint64_t v72 = v12;
  BrotliBuildCodeLengthsHuffmanTable(a5 + 780, (uint64_t)v13, v12);
  unint64_t v73 = 0LL;
  *(_OWORD *)unint64_t v72 = 0u;
  *((_OWORD *)v72 + 1) = 0u;
  uint64_t v134 = v72;
  int8x16_t v74 = (_OWORD *)(v9 + 1600);
  *(void *)&__int128 v75 = -1LL;
  *((void *)&v75 + 1) = -1LL;
  uint64_t v54 = *(void *)(a5 + 912);
  do
  {
    int32x2_t v76 = vdup_n_s32(v73);
    int64x2_t v77 = vaddq_s64(vdupq_n_s64(v73), (int64x2_t)xmmword_181096880);
    *(int32x2_t *)&__int128 v78 = vmovn_s64(v77);
    *((int32x2_t *)&v78 + 1) = vadd_s32(v76, (int32x2_t)0xFFFFFFF3FFFFFFF2LL);
    int32x2_t v79 = vadd_s32(v76, (int32x2_t)0xFFFFFFF7FFFFFFF6LL);
    *(int32x2_t *)&__int128 v80 = vadd_s32(v76, (int32x2_t)0xFFFFFFF5FFFFFFF4LL);
    *((int32x2_t *)&v80 + 1) = v79;
    *int8x16_t v74 = v78;
    v74[1] = v80;
    v74 += 2;
    *(_OWORD *)(v54 + 2 * v77.i64[0]) = v75;
    v73 += 8LL;
  }

  while (v73 != 16);
  LODWORD(v53) = 0;
  int v50 = 0;
  unsigned int v49 = 0;
  *(_OWORD *)uint64_t v9 = xmmword_181096890;
  int v51 = 0x8000;
  *(_DWORD *)(a5 + 776) = 0x8000;
  *(_DWORD *)(a5 + 752) = 5;
  int v52 = 8;
LABEL_67:
  uint64_t v81 = a5 + 2360;
  if (!BrotliWarmupBitReader(v10))
  {
    unsigned int v49 = *(_DWORD *)(a5 + 768);
    int v51 = *(_DWORD *)(a5 + 776);
    uint64_t v83 = (uint64_t)v134;
    unsigned int v82 = v133;
LABEL_113:
    if (v49 >= v82) {
      goto LABEL_153;
    }
    int v106 = 0;
    uint64_t v107 = a5 + 780;
    while (1)
    {
      if (!v51) {
        goto LABEL_155;
      }
      if (v106)
      {
        uint64_t v108 = *(void *)(a5 + 32);
        if (!v108) {
          return 2LL;
        }
        unint64_t v109 = *(void *)(a5 + 8);
        *(void *)(a5 + 8) = v109 >> 8;
        int v110 = *(unsigned __int8 **)(a5 + 24);
        *((void *)&v111 + 1) = *v110;
        *(void *)&__int128 v111 = v109;
        *(void *)(a5 + 8) = v111 >> 8;
        int v112 = *(_DWORD *)(a5 + 16) - 8;
        *(_DWORD *)(a5 + 16) = v112;
        *(void *)(a5 + 24) = v110 + 1;
        *(void *)(a5 + 32) = v108 - 1;
      }

      else
      {
        int v112 = *(_DWORD *)(a5 + 16);
      }

      if (v112 == 64) {
        LODWORD(v113) = 0;
      }
      else {
        unint64_t v113 = *v10 >> v112;
      }
      unsigned int v114 = *(unsigned __int8 *)(v107 + 4 * (v113 & 0x1F));
      if (64 - v112 < v114) {
        goto LABEL_124;
      }
      uint64_t v115 = *(unsigned __int16 *)(v107 + 4 * (v113 & 0x1F) + 2);
      if (v115 <= 0xF)
      {
        *(_DWORD *)(a5 + 16) = v112 + v114;
        uint64_t v116 = *(void *)(a5 + 912);
        *(_DWORD *)(a5 + 772) = 0;
        if ((_DWORD)v115)
        {
          *(_WORD *)(v116 + 2LL * *(int *)(v81 + 4 * v115)) = v49;
          *(_DWORD *)(v81 + 4 * v115) = v49;
          *(_DWORD *)(a5 + 764) = v115;
          v51 -= 0x8000u >> v115;
          *(_DWORD *)(a5 + 776) = v51;
          ++*(_WORD *)(v83 + 2 * v115);
        }

        int v106 = 0;
        *(_DWORD *)(a5 + 768) = ++v49;
        goto LABEL_145;
      }

      char v117 = v115 - 14;
      unsigned int v118 = v115 - 14 + v114;
      if (64 - v112 < v118)
      {
LABEL_124:
        int v106 = 1;
      }

      else
      {
        *(_DWORD *)(a5 + 16) = v118 + v112;
        if ((_DWORD)v115 == 16)
        {
          unsigned int v119 = *(_DWORD *)(a5 + 764);
          char v120 = 2;
        }

        else
        {
          unsigned int v119 = 0;
          char v120 = 3;
        }

        if (*(_DWORD *)(a5 + 760) == v119)
        {
          int v121 = *(_DWORD *)(v9 + 12);
          if (v121) {
            int v122 = (v121 - 2) << v120;
          }
          else {
            int v122 = 0;
          }
        }

        else
        {
          int v122 = 0;
          int v121 = 0;
          *(_DWORD *)(a5 + 760) = v119;
        }

        unsigned int v123 = (v113 >> v114) & ~(-1 << v117);
        uint64_t v124 = *(void *)(a5 + 912);
        int v125 = v123 + v122 + 3;
        *(_DWORD *)(v9 + 12) = v125;
        int v126 = v125 - v121;
        unsigned int v127 = v125 - v121 + v49;
        if (v127 > v82)
        {
          *(_DWORD *)(a5 + 768) = v82;
          *(_DWORD *)(a5 + 776) = 0xFFFFF;
          return 4294967289LL;
        }

        if (v119)
        {
          int v128 = *(_DWORD *)(v81 + 4LL * v119);
          int v129 = v122 + v123 - v121 + 3;
          do
          {
            *(_WORD *)(v124 + 2LL * v128) = v49;
            int v128 = v49++;
            --v129;
          }

          while (v129);
          int v106 = 0;
          *(_DWORD *)(a5 + 768) = v127;
          *(_DWORD *)(v81 + 4LL * v119) = v49 - 1;
          v51 -= v126 << (15 - v119);
          *(_DWORD *)(a5 + 776) = v51;
          *(_WORD *)(v83 + 2LL * v119) += v126;
        }

        else
        {
          int v106 = 0;
          *(_DWORD *)(a5 + 768) = v127;
        }

        unsigned int v49 = v127;
      }

    if (v27 >> 13 != ((v22 >> 8) & 0x7FFFF)) {
      goto LABEL_46;
    }
    if (v12 + 1 >= v14)
    {
      LODWORD(v31) = 0;
LABEL_36:
      if (!(_DWORD)v29) {
        goto LABEL_44;
      }
    }

    else
    {
      unint64_t v31 = 0LL;
      unint64_t v32 = 0;
      while (1)
      {
        unint64_t v31 = *(void *)(a3 + v29 + v31) ^ *(void *)(a3 + v32 + v12 + 1);
        if (v31) {
          break;
        }
        v32 += 8;
        unint64_t v31 = v32;
        if (v12 + v32 + 1 >= v14) {
          goto LABEL_36;
        }
      }

      LODWORD(v31) = v32 + (__clz(__rbit64(v31)) >> 3);
      if (!(_DWORD)v29) {
        goto LABEL_44;
      }
    }

    int v35 = v29 - 1;
    if (*(unsigned __int8 *)(a3 + v12) == *(unsigned __int8 *)(a3 + v35) && v33 <= v31)
    {
      LODWORD(v33) = v31 + 1;
      LOWORD(v28) = v35;
      goto LABEL_46;
    }

LABEL_145:
      if (v49 >= v82) {
        goto LABEL_153;
      }
    }
  }

  unsigned int v82 = v133;
  if (v49 >= v133)
  {
    uint64_t v83 = (uint64_t)v134;
    goto LABEL_152;
  }

  uint64_t v83 = (uint64_t)v134;
  if (!v51) {
    goto LABEL_152;
  }
  unint64_t v84 = *(void *)(a5 + 32);
  while (2)
  {
    unint64_t v85 = v84 - 4;
    if (v84 < 4)
    {
      *(_DWORD *)(a5 + 768) = v49;
      *(_DWORD *)(a5 + 772) = v50;
      *(_DWORD *)(a5 + 764) = v52;
      *(_DWORD *)(a5 + 760) = v53;
      *(_DWORD *)(a5 + 776) = v51;
      goto LABEL_113;
    }

    unsigned int v86 = *(_DWORD *)(a5 + 16);
    unint64_t v87 = *(void *)(a5 + 8);
    if (v86 >= 0x20)
    {
      v86 ^= 0x20u;
      *(_DWORD *)(a5 + 16) = v86;
      uint64_t v88 = *(unsigned int **)(a5 + 24);
      *((void *)&v89 + 1) = *v88;
      *(void *)&__int128 v89 = v87;
      unint64_t v87 = v89 >> 32;
      *(void *)(a5 + 8) = v87;
      *(void *)(a5 + 24) = v88 + 1;
      *(void *)(a5 + 32) = v85;
      unint64_t v84 = v85;
    }

    int v90 = (unsigned __int8 *)(a5 + 780 + 4 * ((v87 >> v86) & 0x1F));
    unsigned int v91 = v86 + *v90;
    *(_DWORD *)(a5 + 16) = v91;
    uint64_t v92 = *((unsigned __int16 *)v90 + 1);
    if (v92 <= 0xF)
    {
      if (*((_WORD *)v90 + 1))
      {
        *(_WORD *)(v54 + 2LL * *(int *)(v81 + 4 * v92)) = v49;
        *(_DWORD *)(v81 + 4 * v92) = v49;
        v51 -= 0x8000u >> v92;
        ++v134[v92];
        int v52 = v92;
      }

      int v50 = 0;
      ++v49;
      goto LABEL_101;
    }

    BOOL v93 = (_DWORD)v92 == 16;
    if ((_DWORD)v92 == 16) {
      int v94 = 2;
    }
    else {
      int v94 = 3;
    }
    int v95 = (v87 >> v91) & ~(-1 << v94);
    *(_DWORD *)(a5 + 16) = v94 + v91;
    if (v93) {
      unsigned int v96 = v52;
    }
    else {
      unsigned int v96 = 0;
    }
    int v97 = (v50 - 2) << v94;
    if (v50) {
      int v98 = v50;
    }
    else {
      int v98 = 0;
    }
    if (!v50) {
      int v97 = 0;
    }
    BOOL v99 = (_DWORD)v53 == v96;
    if ((_DWORD)v53 == v96) {
      uint64_t v53 = v53;
    }
    else {
      uint64_t v53 = v96;
    }
    if (v99)
    {
      int v100 = v97;
    }

    else
    {
      int v98 = 0;
      int v100 = 0;
    }

    int v50 = v95 + v100 + 3;
    int v101 = v50 - v98;
    unsigned int v102 = v50 - v98 + v49;
    if (v102 <= v133)
    {
      if ((_DWORD)v53)
      {
        int v103 = *(_DWORD *)(v81 + 4LL * v53);
        int v104 = v100 + v95 - v98 + 3;
        do
        {
          *(_WORD *)(v54 + 2LL * v103) = v49;
          int v103 = v49++;
          --v104;
        }

        while (v104);
        *(_DWORD *)(v81 + 4 * v53) = v49 - 1;
        v51 -= v101 << (15 - v53);
        v134[v53] += v101;
      }

      unsigned int v49 = v102;
LABEL_101:
      if (v49 >= v133 || !v51) {
        goto LABEL_152;
      }
      continue;
    }

    break;
  }

  int v51 = 0xFFFFF;
LABEL_152:
  *(_DWORD *)(a5 + 776) = v51;
LABEL_153:
  if (v51) {
    return 4294967289LL;
  }
LABEL_155:
  int v130 = BrotliBuildHuffmanTable(__srca, 8, *(void *)(a5 + 912), v83);
  if (v132) {
    *uint64_t v132 = v130;
  }
LABEL_157:
  *(_DWORD *)(a5 + 752) = 0;
  return 1LL;
}

uint64_t CopyUncompressedBlockToOutput(size_t *a1, void **a2, size_t *a3, uint64_t a4)
{
  for (int i = *(_DWORD *)(a4 + 652); ; int i = 0)
  {
    do
    {
      if (i == 1) {
        goto LABEL_24;
      }
    }

    while (i);
    unint64_t v9 = *(void *)(a4 + 32);
    int v10 = *(_DWORD *)(a4 + 16);
    if (v9 <= 0x40000000) {
      LODWORD(v9) = v9 + ((64 - v10) >> 3);
    }
    else {
      LODWORD(v9) = 0x40000000;
    }
    uint64_t v11 = *(int *)(a4 + 76);
    int v12 = *(_DWORD *)(a4 + 88);
    unint64_t v13 = (_BYTE *)(*(void *)(a4 + 120) + v11);
    int v14 = v9;
    if ((v10 - 65) <= 0xFFFFFFF7 && (_DWORD)v9)
    {
      unint64_t v9 = (int)v9;
      do
      {
        *v13++ = *(void *)(a4 + 8) >> v10;
        int v15 = *(_DWORD *)(a4 + 16);
        LOBYTE(v10) = v15 + 8;
        *(_DWORD *)(a4 + 16) = v15 + 8;
        size_t v16 = v9 - 1;
      }

      while ((v15 - 57) <= 0xFFFFFFF7 && v9-- != 1);
    }

    else
    {
      size_t v16 = (int)v9;
    }

    memcpy(v13, *(const void **)(a4 + 24), v16);
    size_t v18 = *(void *)(a4 + 32) - v16;
    *(void *)(a4 + 24) += v16;
    *(void *)(a4 + 32) = v18;
    int v19 = *(_DWORD *)(a4 + 76) + v14;
    *(_DWORD *)(a4 + 76) = v19;
    int v20 = *(_DWORD *)(a4 + 264);
    *(_DWORD *)(a4 + 264) = v20 - v14;
    if (v19 < 1 << *(_DWORD *)(a4 + 668)) {
      break;
    }
    *(_DWORD *)(a4 + 652) = 1;
LABEL_24:
    uint64_t result = WriteRingBuffer(a4, a1, a2, a3, 0);
    if ((_DWORD)result != 1) {
      return result;
    }
    if (*(_DWORD *)(a4 + 88) == 1 << *(_DWORD *)(a4 + 668)) {
      *(_DWORD *)(a4 + 84) = *(_DWORD *)(a4 + 80);
    }
    *(_DWORD *)(a4 + 652) = 0;
  }

  if (v20 == v14) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

uint64_t DecodeContextMap(unsigned int a1, unsigned int *a2, unsigned __int8 **a3, uint64_t a4)
{
  __int128 v8 = (unint64_t *)(a4 + 8);
  switch(*(_DWORD *)(a4 + 748))
  {
    case 0:
      uint64_t result = DecodeVarLenUint8(a4, (unint64_t *)(a4 + 8), a2);
      if ((_DWORD)result == 1)
      {
        ++*a2;
        *(_DWORD *)(a4 + 2552) = 0;
        int v10 = (unsigned __int8 *)(*(uint64_t (**)(void, void))(a4 + 40))(*(void *)(a4 + 56), a1);
        *a3 = v10;
        if (v10)
        {
          if (*a2 > 1)
          {
            *(_DWORD *)(a4 + 748) = 1;
            goto LABEL_11;
          }

          bzero(v10, a1);
          return 1LL;
        }

        else
        {
          return 4294967271LL;
        }
      }

      return result;
    case 1:
LABEL_11:
      int v13 = *(_DWORD *)(a4 + 16);
      if ((v13 - 60) >= 5)
      {
        unint64_t v17 = *v8;
      }

      else
      {
        uint64_t v14 = *(void *)(a4 + 32);
        if (!v14) {
          return 2LL;
        }
        unint64_t v15 = *(void *)(a4 + 8);
        *(void *)(a4 + 8) = v15 >> 8;
        size_t v16 = *(unsigned __int8 **)(a4 + 24);
        *((void *)&v18 + 1) = *v16;
        *(void *)&__int128 v18 = v15;
        unint64_t v17 = v18 >> 8;
        *(void *)(a4 + 8) = v17;
        v13 -= 8;
        *(void *)(a4 + 24) = v16 + 1;
        *(void *)(a4 + 32) = v14 - 1;
      }

      unint64_t v19 = v17 >> v13;
      BOOL v25 = (v19 & 1) == 0;
      unsigned int v11 = ((int)((_DWORD)v19 << 31) >> 31) & (((v19 >> 1) & 0xF) + 1);
      if (v25) {
        int v20 = v13 + 1;
      }
      else {
        int v20 = v13 + 5;
      }
      *(_DWORD *)(a4 + 2556) = v11;
      *(_DWORD *)(a4 + 16) = v20;
      *(_DWORD *)(a4 + 748) = 2;
      goto LABEL_19;
    case 2:
      unsigned int v11 = *(_DWORD *)(a4 + 2556);
LABEL_19:
      uint64_t result = ReadHuffmanCode(v11 + *a2, v11 + *a2, (int *)(a4 + 2564), 0LL, a4);
      if ((_DWORD)result != 1) {
        return result;
      }
      unsigned int v12 = 0xFFFF;
      *(_DWORD *)(a4 + 2560) = 0xFFFF;
      *(_DWORD *)(a4 + 748) = 3;
LABEL_21:
      unsigned int v21 = *(_DWORD *)(a4 + 2552);
      unsigned int v22 = *(_DWORD *)(a4 + 2556);
      unint64_t v23 = *a3;
      unsigned int v52 = v12;
      BOOL v24 = v12 != 0xFFFF;
      BOOL v25 = v21 >= a1 && v12 == 0xFFFF;
      if (v25) {
        goto LABEL_52;
      }
      uint64_t v26 = a4 + 2564;
      break;
    case 3:
      unsigned int v12 = *(_DWORD *)(a4 + 2560);
      goto LABEL_21;
    case 4:
      goto LABEL_52;
    default:
      return 4294967265LL;
  }

  while (1)
  {
    int v27 = *(_DWORD *)(a4 + 16);
    if (v24) {
      break;
    }
    if ((v27 - 50) >= 0xF)
    {
      unint64_t v31 = *v8;
LABEL_33:
      unint64_t v34 = v31 >> v27;
      int v35 = (unsigned __int8 *)(v26 + 4LL * (v31 >> v27));
      unsigned int v36 = *v35;
      if (v36 >= 9)
      {
        v27 += 8;
        unsigned int v36 = *v35;
      }

      *(_DWORD *)(a4 + 16) = v27 + v36;
      unsigned int v12 = *((unsigned __int16 *)v35 + 1);
      unsigned int v52 = v12;
      if (!v12) {
        goto LABEL_49;
      }
    }

    else
    {
      uint64_t v28 = *(void *)(a4 + 32) - 1LL;
      while (v28 != -1)
      {
        unint64_t v29 = *(void *)(a4 + 8);
        *(void *)(a4 + 8) = v29 >> 8;
        uint64_t v30 = *(unsigned __int8 **)(a4 + 24);
        *((void *)&v32 + 1) = *v30;
        *(void *)&__int128 v32 = v29;
        unint64_t v31 = v32 >> 8;
        *(void *)(a4 + 8) = v31;
        int v33 = v27 - 8;
        *(_DWORD *)(a4 + 16) = v27 - 8;
        *(void *)(a4 + 24) = v30 + 1;
        *(void *)(a4 + 32) = v28--;
        LODWORD(v30) = v27 - 58;
        v27 -= 8;
        if (v30 >= 0xF)
        {
          int v27 = v33;
          goto LABEL_33;
        }
      }

      if (!SafeDecodeSymbol((_BYTE *)(a4 + 2564), (uint64_t)v8, &v52))
      {
        unsigned int v12 = 0xFFFF;
        goto LABEL_63;
      }

      unsigned int v12 = v52;
      if (!v52)
      {
LABEL_49:
        unsigned __int8 v37 = 0;
        goto LABEL_50;
      }
    }

    unsigned __int8 v37 = v12 - v22;
    if (v12 <= v22)
    {
      int v27 = *(_DWORD *)(a4 + 16);
      break;
    }

LABEL_50:
    v23[v21++] = v37;
LABEL_51:
    BOOL v24 = 0;
    if (v21 >= a1)
    {
LABEL_52:
      int v45 = *(_DWORD *)(a4 + 16);
      if (v45 == 64)
      {
        uint64_t v46 = *(void *)(a4 + 32);
        if (v46)
        {
          unint64_t v47 = *(void *)(a4 + 8);
          *(void *)(a4 + 8) = v47 >> 8;
          int v48 = *(unsigned __int8 **)(a4 + 24);
          *((void *)&v50 + 1) = *v48;
          *(void *)&__int128 v50 = v47;
          unint64_t v49 = v50 >> 8;
          *(void *)(a4 + 8) = v49;
          *(void *)(a4 + 24) = v48 + 1;
          *(void *)(a4 + 32) = v46 - 1;
          int v45 = 56;
          goto LABEL_56;
        }

        uint64_t result = 2LL;
        int v51 = 4;
      }

      else
      {
        unint64_t v49 = *v8;
LABEL_56:
        *(_DWORD *)(a4 + 16) = v45 + 1;
        if (((v49 >> v45) & 1) != 0) {
          InverseMoveToFrontTransform(*a3, a1, (_DWORD *)a4);
        }
        int v51 = 0;
        uint64_t result = 1LL;
      }

      *(_DWORD *)(a4 + 748) = v51;
      return result;
    }
  }

  unsigned int v38 = 64 - v27;
  if (64 - v27 >= v12)
  {
    unint64_t v42 = *v8;
LABEL_44:
    *(_DWORD *)(a4 + 16) = v27 + v12;
    int v44 = ((v42 >> v27) & ~(-1 << v12)) + (1 << v12);
    if (v44 + v21 > a1) {
      return 4294967288LL;
    }
    do
    {
      v23[v21++] = 0;
      --v44;
    }

    while (v44);
    goto LABEL_51;
  }

  uint64_t v39 = *(void *)(a4 + 32) - 1LL;
  while (v39 != -1)
  {
    unint64_t v40 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v40 >> 8;
    unint64_t v41 = *(unsigned __int8 **)(a4 + 24);
    *((void *)&v43 + 1) = *v41;
    *(void *)&__int128 v43 = v40;
    unint64_t v42 = v43 >> 8;
    *(void *)(a4 + 8) = v42;
    v27 -= 8;
    *(_DWORD *)(a4 + 16) = v27;
    *(void *)(a4 + 24) = v41 + 1;
    *(void *)(a4 + 32) = v39--;
    v38 += 8;
    if (v38 >= v12) {
      goto LABEL_44;
    }
  }

LABEL_63:
  *(_DWORD *)(a4 + 2560) = v12;
  *(_DWORD *)(a4 + 2552) = v21;
  return 2LL;
}

uint64_t BrotliEnsureRingBuffer(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 672);
  if (*(_DWORD *)(a1 + 88) == (_DWORD)v1) {
    return 1LL;
  }
  int v3 = *(const void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 40))(*(void *)(a1 + 56), v1 + 42);
  *(void *)(a1 + 120) = result;
  if (result)
  {
    *(_BYTE *)(*(int *)(a1 + 672) + result - 2) = 0;
    *(_BYTE *)(*(int *)(a1 + 672) + *(void *)(a1 + 120) - 1LL) = 0;
    if (v3)
    {
      memcpy(*(void **)(a1 + 120), v3, *(int *)(a1 + 76));
      (*(void (**)(void, const void *))(a1 + 48))(*(void *)(a1 + 56), v3);
    }

    uint64_t v5 = *(int *)(a1 + 672);
    *(_DWORD *)(a1 + 88) = v5;
    *(_DWORD *)(a1 + 92) = v5 - 1;
    *(void *)(a1 + 128) = *(void *)(a1 + 120) + v5;
    return 1LL;
  }

  *(void *)(a1 + 120) = v3;
  return result;
}

uint64_t ProcessCommands(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 76);
  LODWORD(v3) = *(_DWORD *)(a1 + 4);
  if (*(void *)(a1 + 32) < 0x1CuLL) {
    goto LABEL_6;
  }
  unsigned int v123 = (unint64_t *)(a1 + 8);
  BrotliWarmupBitReader((unint64_t *)(a1 + 8));
  switch(*(_DWORD *)a1)
  {
    case 7:
      goto LABEL_10;
    case 8:
      goto LABEL_22;
    case 9:
      goto LABEL_57;
    case 0xA:
      uint64_t v4 = v2;
      break;
    default:
      return 4294967265LL;
  }

LABEL_101:
  uint64_t v115 = 0LL;
  int v116 = *(_DWORD *)(a1 + 88) - v2;
  while (1)
  {
    BOOL v117 = __OFSUB__((_DWORD)v3, 1);
    LODWORD(v3) = v3 - 1;
    if (((v3 & 0x80000000) != 0LL) != v117) {
      break;
    }
    *(_BYTE *)(v4 + v115 + *(void *)(a1 + 120)) = *(_BYTE *)(*(void *)(a1 + 120)
                                                             + (((int)v4 + (int)v115 - *(_DWORD *)(a1 + 360)) & *(_DWORD *)(a1 + 92)));
    if (v116 == (_DWORD)++v115)
    {
      int v2 = v4 + v115;
      int v118 = 16;
LABEL_123:
      *(_DWORD *)a1 = v118;
LABEL_125:
      uint64_t result = 1LL;
      goto LABEL_7;
    }
  }

  int v2 = v4 + v115;
  if (*(int *)(a1 + 264) < 1)
  {
    *(_DWORD *)a1 = 14;
    uint64_t result = 1LL;
    goto LABEL_7;
  }

  while (1)
  {
    while (1)
    {
LABEL_10:
      unint64_t v6 = *(void *)(a1 + 32);
      if (v6 < 0x1C)
      {
        *(_DWORD *)a1 = 7;
        goto LABEL_6;
      }

      int v7 = *(_DWORD *)(a1 + 276);
      if (v7) {
        break;
      }
      DecodeCommandBlockSwitch(a1);
    }

    uint64_t v8 = *(void *)(a1 + 136);
    unsigned int v9 = *(_DWORD *)(a1 + 16);
    unint64_t v10 = *(void *)(a1 + 8);
    if (v9 >= 0x30)
    {
      *(void *)(a1 + 8) = HIWORD(v10);
      v9 ^= 0x30u;
      unsigned int v11 = *(void **)(a1 + 24);
      *((void *)&v12 + 1) = *v11;
      *(void *)&__int128 v12 = v10;
      unint64_t v10 = v12 >> 48;
      *(void *)(a1 + 8) = v10;
      v6 -= 6LL;
      *(void *)(a1 + 24) = (char *)v11 + 6;
      *(void *)(a1 + 32) = v6;
    }

    unint64_t v13 = v10 >> v9;
    uint64_t v14 = (unsigned __int8 *)(v8 + 4LL * (v10 >> v9));
    unsigned int v15 = *v14;
    if (v15 >= 9)
    {
      v9 += 8;
      unsigned int v15 = *v14;
    }

    unsigned int v16 = v9 + v15;
    *(_DWORD *)(a1 + 16) = v9 + v15;
    unint64_t v17 = (unsigned __int8 *)&kCmdLut + 8 * *((unsigned __int16 *)v14 + 1);
    int v18 = *v17;
    int v19 = v17[1];
    uint64_t v20 = v17[3];
    *(_DWORD *)(a1 + 360) = (char)v17[2];
    *(_DWORD *)(a1 + 260) = v20;
    int v21 = *((unsigned __int16 *)v17 + 2);
    int v22 = *((unsigned __int16 *)v17 + 3);
    *(_BYTE *)(a1 + 352) = *(_BYTE *)(*(void *)(a1 + 160) + v20);
    if (v18)
    {
      if (v16 >= 0x20)
      {
        v16 ^= 0x20u;
        *(_DWORD *)(a1 + 16) = v16;
        int v121 = *(unsigned int **)(a1 + 24);
        *((void *)&v122 + 1) = *v121;
        *(void *)&__int128 v122 = v10;
        unint64_t v10 = v122 >> 32;
        *(void *)(a1 + 8) = v10;
        v6 -= 4LL;
        *(void *)(a1 + 24) = v121 + 1;
        *(void *)(a1 + 32) = v6;
      }

      int v23 = (v10 >> v16) & ~(-1 << v18);
      v16 += v18;
    }

    else
    {
      int v23 = 0;
    }

    if (v16 >= 0x20)
    {
      v16 ^= 0x20u;
      *(_DWORD *)(a1 + 16) = v16;
      BOOL v24 = *(unsigned int **)(a1 + 24);
      *((void *)&v25 + 1) = *v24;
      *(void *)&__int128 v25 = v10;
      unint64_t v10 = v25 >> 32;
      *(void *)(a1 + 8) = v10;
      *(void *)(a1 + 24) = v24 + 1;
      *(void *)(a1 + 32) = v6 - 4;
    }

    *(_DWORD *)(a1 + 16) = v16 + v19;
    *(_DWORD *)(a1 + 356) = ((v10 >> v16) & ~(-1 << v19)) + v22;
    *(_DWORD *)(a1 + 276) = v7 - 1;
    LODWORD(v3) = v23 + v21;
    if (v23 + v21) {
      break;
    }
LABEL_57:
    int v71 = *(_DWORD *)(a1 + 360);
    if (v71 < 0)
    {
      if (!*(_DWORD *)(a1 + 280)) {
        DecodeDistanceBlockSwitch(a1);
      }
      uint64_t v75 = *(void *)(*(void *)(a1 + 216) + 8LL * *(unsigned __int8 *)(a1 + 352));
      unsigned int v76 = *(_DWORD *)(a1 + 16);
      unint64_t v77 = *(void *)(a1 + 8);
      if (v76 >= 0x30)
      {
        *(void *)(a1 + 8) = HIWORD(v77);
        v76 ^= 0x30u;
        __int128 v78 = *(void **)(a1 + 24);
        uint64_t v79 = *(void *)(a1 + 32);
        *((void *)&v80 + 1) = *v78;
        *(void *)&__int128 v80 = v77;
        unint64_t v77 = v80 >> 48;
        *(void *)(a1 + 8) = v77;
        *(void *)(a1 + 24) = (char *)v78 + 6;
        *(void *)(a1 + 32) = v79 - 6;
      }

      unint64_t v81 = v77 >> v76;
      unsigned int v82 = (unsigned __int8 *)(v75 + 4LL * (v77 >> v76));
      unsigned int v83 = *v82;
      if (v83 >= 9)
      {
        v76 += 8;
        unsigned int v83 = *v82;
      }

      unsigned int v84 = v76 + v83;
      *(_DWORD *)(a1 + 16) = v76 + v83;
      uint64_t v85 = *((unsigned __int16 *)v82 + 1);
      --*(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 260) = 0;
      if (v85 > 0xF)
      {
        int v88 = *(unsigned __int8 *)(a1 + 744 + v85);
        if (v84 >= 0x20)
        {
          v84 ^= 0x20u;
          *(_DWORD *)(a1 + 16) = v84;
          __int128 v89 = *(unsigned int **)(a1 + 24);
          uint64_t v90 = *(void *)(a1 + 32);
          *((void *)&v91 + 1) = *v89;
          *(void *)&__int128 v91 = v77;
          unint64_t v77 = v91 >> 32;
          *(void *)(a1 + 8) = v77;
          *(void *)(a1 + 24) = v89 + 1;
          *(void *)(a1 + 32) = v90 - 4;
        }

        unsigned int v72 = 0;
        *(_DWORD *)(a1 + 16) = v84 + v88;
        signed int v74 = (((v77 >> v84) & ~(-1 << v88)) << *(_DWORD *)(a1 + 320)) + *(_DWORD *)(a1 + 4 * v85 + 1288);
      }

      else
      {
        *(_DWORD *)(a1 + 360) = v85;
        if (v85 <= 3)
        {
          char v86 = ~(_BYTE)v85;
          unsigned int v72 = 1u >> v85;
          *(_DWORD *)(a1 + 260) = 1u >> v85;
          int v87 = *(_DWORD *)(a1 + 96);
          signed int v74 = *(_DWORD *)(a1 + 4LL * (((_BYTE)v87 + v86) & 3) + 100);
          *(_DWORD *)(a1 + 360) = v74;
          *(_DWORD *)(a1 + 96) = v87 - v72;
          goto LABEL_80;
        }

        unsigned int v72 = 0;
        else {
          char v92 = -4;
        }
        else {
          char v93 = 3;
        }
        signed int v74 = ((0x605142u >> (4 * (v92 + v85))) & 7)
        if (v74 < 1) {
          signed int v74 = 0x7FFFFFFF;
        }
      }
    }

    else
    {
      unsigned int v72 = v71 == 0;
      *(_DWORD *)(a1 + 260) = v72;
      int v73 = *(_DWORD *)(a1 + 96) - 1;
      *(_DWORD *)(a1 + 96) = v73;
      signed int v74 = *(_DWORD *)(a1 + 4LL * (v73 & 3) + 100);
    }

    *(_DWORD *)(a1 + 360) = v74;
LABEL_80:
    int v95 = *(_DWORD *)(a1 + 80);
    signed int v94 = *(_DWORD *)(a1 + 84);
    if (v94 != v95)
    {
      if (v2 >= v95) {
        signed int v94 = *(_DWORD *)(a1 + 80);
      }
      else {
        signed int v94 = v2;
      }
      *(_DWORD *)(a1 + 84) = v94;
    }

    size_t v3 = *(unsigned int *)(a1 + 356);
    if (v74 <= v94)
    {
      int v106 = *(_DWORD *)(a1 + 96);
      int v107 = *(_DWORD *)(a1 + 92) & (v2 - v74);
      uint64_t v108 = *(void *)(a1 + 120);
      uint64_t v4 = v2;
      unint64_t v109 = (_OWORD *)(v108 + v2);
      int v110 = (_OWORD *)(v108 + v107);
      int v111 = v3 + v2;
      *(_DWORD *)(a1 + 4LL * (v106 & 3) + 100) = v74;
      *(_DWORD *)(a1 + 96) = v106 + 1;
      *(_DWORD *)(a1 + 264) -= v3;
      *unint64_t v109 = *v110;
      int v113 = *(_DWORD *)(a1 + 88);
      if ((int)v3 >= 17)
      {
        unsigned int v119 = v109 + 1;
        char v120 = v110 + 1;
        else {
          memcpy(v119, v120, (v3 - 16));
        }
      }
    }

    else
    {
      if (v74 > 2147483644) {
        return 4294967280LL;
      }
      uint64_t v96 = *(void *)(a1 + 696);
      uint64_t v97 = *(void *)(a1 + 704);
      uint64_t v98 = *(int *)(v96 + 4 * v3 + 32);
      char v99 = *(_BYTE *)(v96 + v3);
      *(_DWORD *)(a1 + 96) += v72;
      uint64_t v100 = *(void *)(v96 + 168);
      if (!v100) {
        return 4294967277LL;
      }
      int v101 = v74 + ~v94;
      int v102 = v101 >> v99;
      if (v101 >> v99 >= *(_DWORD *)(v97 + 24)) {
        return 4294967285LL;
      }
      int v103 = (void *)(v100 + v98 + (v101 & ~(-1 << v99)) * (int)v3);
      int v104 = (void *)(*(void *)(a1 + 120) + v2);
      if (v102 == *(__int16 *)(v97 + 48))
      {
        memcpy(v104, v103, v3);
        int v105 = v3;
      }

      else
      {
        int v105 = BrotliTransformDictionaryWord((uint64_t)v104, (char *)v103, v3, (void *)v97, v102);
      }

      v2 += v105;
      *(_DWORD *)(a1 + 264) -= v105;
      if (v2 >= *(_DWORD *)(a1 + 88))
      {
        int v118 = 15;
        goto LABEL_123;
      }

      int v111 = v2;
    }

    if (*(int *)(a1 + 264) <= 0)
    {
      *(_DWORD *)a1 = 14;
      uint64_t result = 1LL;
      int v2 = v111;
      goto LABEL_7;
    }

    int v2 = v111;
  }

  *(_DWORD *)(a1 + 264) -= v3;
LABEL_22:
  int v26 = v2;
  if (*(_DWORD *)(a1 + 256))
  {
LABEL_23:
    unsigned int v27 = *(_DWORD *)(a1 + 16);
    unint64_t v28 = *(void *)(a1 + 8);
    if (v27 >= 0x38)
    {
      *(void *)(a1 + 8) = HIBYTE(v28);
      v27 ^= 0x38u;
      *(_DWORD *)(a1 + 16) = v27;
      unint64_t v29 = *(void **)(a1 + 24);
      uint64_t v30 = *(void *)(a1 + 32);
      *((void *)&v31 + 1) = *v29;
      *(void *)&__int128 v31 = v28;
      unint64_t v28 = v31 >> 56;
      *(void *)(a1 + 8) = v28;
      *(void *)(a1 + 24) = (char *)v29 + 7;
      *(void *)(a1 + 32) = v30 - 7;
    }

    uint64_t v32 = 0LL;
    int v33 = (unsigned __int8 *)(*(void *)(a1 + 344) + 4LL * (v28 >> v27));
    unsigned int v34 = *v33;
    uint64_t v35 = *((unsigned __int16 *)v33 + 1);
    int v36 = v26;
    while (*(void *)(a1 + 32) > 0x1BuLL)
    {
      if (*(_DWORD *)(a1 + 272))
      {
        uint64_t v37 = *(void *)(a1 + 344);
      }

      else
      {
        DecodeLiteralBlockSwitch(a1);
        unsigned int v46 = *(_DWORD *)(a1 + 16);
        unint64_t v47 = *(void *)(a1 + 8);
        if (v46 >= 0x38)
        {
          *(void *)(a1 + 8) = HIBYTE(v47);
          v46 ^= 0x38u;
          *(_DWORD *)(a1 + 16) = v46;
          int v48 = *(void **)(a1 + 24);
          uint64_t v49 = *(void *)(a1 + 32);
          *((void *)&v50 + 1) = *v48;
          *(void *)&__int128 v50 = v47;
          unint64_t v47 = v50 >> 56;
          *(void *)(a1 + 8) = v47;
          *(void *)(a1 + 24) = (char *)v48 + 7;
          *(void *)(a1 + 32) = v49 - 7;
        }

        int v51 = *(_DWORD *)(a1 + 256);
        if (!v51)
        {
LABEL_54:
          int v26 = v36 + v32;
          LODWORD(v3) = v3 - v32;
          if (v51) {
            goto LABEL_23;
          }
          goto LABEL_43;
        }

        uint64_t v37 = *(void *)(a1 + 344);
        unsigned int v52 = (unsigned __int8 *)(v37 + 4LL * (v47 >> v46));
        unsigned int v34 = *v52;
        uint64_t v35 = *((unsigned __int16 *)v52 + 1);
      }

      unsigned int v38 = *(_DWORD *)(a1 + 16);
      if (v34 >= 9)
      {
        unint64_t v41 = *v123;
        if (v38 >= 0x30)
        {
          *(void *)(a1 + 8) = HIWORD(v41);
          v38 ^= 0x30u;
          uint64_t v53 = *(void **)(a1 + 24);
          uint64_t v54 = *(void *)(a1 + 32);
          *((void *)&v55 + 1) = *v53;
          *(void *)&__int128 v55 = v41;
          unint64_t v41 = v55 >> 48;
          *(void *)(a1 + 8) = v41;
          *(void *)(a1 + 24) = (char *)v53 + 6;
          *(void *)(a1 + 32) = v54 - 6;
        }

        unsigned int v56 = (unsigned __int8 *)(v37
                                + 4LL * (v41 >> v38)
                                + 4 * v35
                                + 4LL * (((v41 >> v38) >> 8) & ~(-1 << (v34 - 8))));
        unsigned int v39 = v38 + *v56 + 8;
        *(_DWORD *)(a1 + 16) = v39;
        unsigned __int8 v40 = v56[2];
      }

      else
      {
        unsigned int v39 = v38 + v34;
        *(_DWORD *)(a1 + 16) = v39;
        unsigned __int8 v40 = v35;
        unint64_t v41 = *(void *)(a1 + 8);
      }

      if (v39 >= 0x38)
      {
        *(void *)(a1 + 8) = HIBYTE(v41);
        v39 ^= 0x38u;
        *(_DWORD *)(a1 + 16) = v39;
        unint64_t v42 = *(void **)(a1 + 24);
        uint64_t v43 = *(void *)(a1 + 32);
        *((void *)&v44 + 1) = *v42;
        *(void *)&__int128 v44 = v41;
        unint64_t v41 = v44 >> 56;
        *(void *)(a1 + 8) = v41;
        *(void *)(a1 + 24) = (char *)v42 + 7;
        *(void *)(a1 + 32) = v43 - 7;
      }

      int v45 = (unsigned __int8 *)(v37 + 4LL * (v41 >> v39));
      unsigned int v34 = *v45;
      uint64_t v35 = *((unsigned __int16 *)v45 + 1);
      *(_BYTE *)(*(void *)(a1 + 120) + v26 + v32) = v40;
      --*(_DWORD *)(a1 + 272);
      int v2 = *(_DWORD *)(a1 + 88);
      if (v26 + (_DWORD)v32 + 1 == v2)
      {
LABEL_124:
        *(_DWORD *)a1 = 13;
        LODWORD(v3) = ~(_DWORD)v32 + v3;
        goto LABEL_125;
      }

      if ((_DWORD)v3 == (_DWORD)++v32)
      {
LABEL_56:
        int v2 = v26 + v32;
        LODWORD(v3) = 0;
        int v118 = 14;
        goto LABEL_123;
      }
    }
  }

  else
  {
LABEL_43:
    uint64_t v32 = 0LL;
    uint64_t v57 = *(void *)(a1 + 120);
    int v36 = v26;
    uint64_t v58 = *(int *)(a1 + 92);
    uint64_t v59 = *(unsigned __int8 *)(v57 + (v58 & (v26 - 1LL)));
    uint64_t v60 = *(unsigned __int8 *)(v57 + (v58 & (v26 - 2LL)));
    while (*(void *)(a1 + 32) > 0x1BuLL)
    {
      if (!*(_DWORD *)(a1 + 272))
      {
        DecodeLiteralBlockSwitch(a1);
        int v51 = *(_DWORD *)(a1 + 256);
        if (v51) {
          goto LABEL_54;
        }
      }

      uint64_t v61 = *(void *)(*(void *)(a1 + 168)
                      + 8LL
      unsigned int v62 = *(_DWORD *)(a1 + 16);
      unint64_t v63 = *(void *)(a1 + 8);
      if (v62 >= 0x30)
      {
        *(void *)(a1 + 8) = HIWORD(v63);
        v62 ^= 0x30u;
        unsigned int v64 = *(void **)(a1 + 24);
        uint64_t v65 = *(void *)(a1 + 32);
        *((void *)&v66 + 1) = *v64;
        *(void *)&__int128 v66 = v63;
        unint64_t v63 = v66 >> 48;
        *(void *)(a1 + 8) = v63;
        *(void *)(a1 + 24) = (char *)v64 + 6;
        *(void *)(a1 + 32) = v65 - 6;
      }

      unint64_t v67 = v63 >> v62;
      unint64_t v68 = (unsigned __int8 *)(v61 + 4LL * (v63 >> v62));
      unsigned int v69 = *v68;
      if (v69 >= 9)
      {
        v62 += 8;
        unsigned int v69 = *v68;
      }

      *(_DWORD *)(a1 + 16) = v62 + v69;
      uint64_t v70 = v68[2];
      *(_BYTE *)(*(void *)(a1 + 120) + v26 + v32) = v70;
      --*(_DWORD *)(a1 + 272);
      int v2 = *(_DWORD *)(a1 + 88);
      if (v26 + (_DWORD)v32 + 1 == v2) {
        goto LABEL_124;
      }
      ++v32;
      uint64_t v60 = v59;
      uint64_t v59 = v70;
      if ((_DWORD)v3 == (_DWORD)v32) {
        goto LABEL_56;
      }
    }
  }

  int v2 = v26 + v32;
  *(_DWORD *)a1 = 8;
  LODWORD(v3) = v3 - v32;
LABEL_6:
  uint64_t result = 2LL;
LABEL_7:
  *(_DWORD *)(a1 + 76) = v2;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

uint64_t SafeProcessCommands(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 76);
  LODWORD(v3) = *(_DWORD *)(a1 + 4);
  uint64_t v4 = (unint64_t *)(a1 + 8);
  switch(*(_DWORD *)a1)
  {
    case 7:
      goto LABEL_4;
    case 8:
      goto LABEL_34;
    case 9:
      goto LABEL_76;
    case 0xA:
      uint64_t v5 = v2;
      break;
    default:
      return 4294967265LL;
  }

LABEL_135:
  uint64_t v130 = 0LL;
  int v131 = *(_DWORD *)(a1 + 88) - v2;
  while (1)
  {
    BOOL v132 = __OFSUB__((_DWORD)v3, 1);
    LODWORD(v3) = v3 - 1;
    if (((v3 & 0x80000000) != 0LL) != v132) {
      break;
    }
    *(_BYTE *)(v5 + v130 + *(void *)(a1 + 120)) = *(_BYTE *)(*(void *)(a1 + 120)
                                                             + (((int)v5 + (int)v130 - *(_DWORD *)(a1 + 360)) & *(_DWORD *)(a1 + 92)));
    if (v131 == (_DWORD)++v130)
    {
      int v2 = v5 + v130;
      int v133 = 16;
      goto LABEL_158;
    }
  }

  int v2 = v5 + v130;
  if (*(int *)(a1 + 264) < 1)
  {
    *(_DWORD *)a1 = 14;
    uint64_t result = 1LL;
    goto LABEL_151;
  }

            int v118 = (v84 >> 5) - 1;
            bzero((void *)(v239 + 4 * v233 + 4), 4 * v118);
            uint64_t v32 = v235 + 1;
            uint64_t v15 = v241;
            unsigned int v31 = v242;
            uint64_t v75 = v118 + v233;
            int v30 = v243;
          }
        }

        unint64_t v33 = v75 + 1;
        unsigned int v21 = v246;
        unsigned int v26 = v230;
      }

      while (v75 + 4 < v246);
      uint64_t v228 = 1;
    }
  }

  else
  {
    unint64_t v232 = (_DWORD *)(v13 + 24);
    if (*(_DWORD *)(v13 + 24)) {
      return;
    }
    uint64_t v228 = 0;
    uint64_t v239 = 0LL;
    int v30 = 0LL;
  }

  unint64_t v244 = (unint64_t)v30;
  unint64_t v169 = a12;
  BOOL v168 = a13;
  unint64_t v170 = a10;
  unint64_t v226 = *a13;
  unint64_t v231 = *a10;
  unint64_t v253 = *a9;
  unint64_t v234 = *a12;
  uint64_t v171 = v21 + 1;
  if (v21 == -1LL)
  {
    unint64_t v172 = 0LL;
  }

  else
  {
    unint64_t v173 = BrotliAllocate(v227);
    unsigned int v21 = v246;
    uint64_t v15 = v241;
    unint64_t v172 = (_DWORD *)v173;
  }

  if (!*v232)
  {
    InitZopfliCostModel(v227, (uint64_t)v247, v15 + 64, v21);
    if (!*(_DWORD *)(v227 + 24))
    {
      unsigned int v174 = 1;
      unint64_t v221 = v171;
      do
      {
        size_t v175 = v174;
        if (v171)
        {
          unint64_t v176 = v172 + 3;
          unint64_t v177 = v171;
          do
          {
            *(void *)(v176 - 3) = 1LL;
            *(void *)(v176 - 1) = 0x7EFFC99E00000000LL;
            v176 += 4;
            --v177;
          }

          while (v177);
        }

        unint64_t v236 = v175;
        if ((v175 & 1) != 0)
        {
          ZopfliCostModelSetFromLiteralCosts((uint64_t)v247);
          uint64_t v178 = v242;
          uint64_t v179 = v241;
          uint64_t v180 = v244;
        }

        else
        {
          uint64_t v181 = *v169;
          bzero(v258, 0x400uLL);
          bzero(v256, 0xB00uLL);
          bzero(v255, 0x880uLL);
          if (v181 != v234)
          {
            uint64_t v182 = 0LL;
            uint64_t v183 = v240 - v231;
            do
            {
              unint64_t v184 = (unsigned int *)(a11 + 16 * v182);
              unint64_t v185 = *v184;
              uint64_t v186 = v184[1];
              uint64_t v187 = *((_WORD *)v184 + 7);
              unint64_t v188 = *((unsigned __int16 *)v184 + 6);
              ++v256[v188];
              if (v188 >= 0x80) {
                ++v255[v187 & 0x3FF];
              }
              if ((_DWORD)v185)
              {
                uint64_t v189 = v183;
                unint64_t v190 = v185;
                do
                {
                  ++v258[*(unsigned __int8 *)(v19 + (v189++ & v242))];
                  --v190;
                }

                while (v190);
              }

              v183 += v185 + (v186 & 0x1FFFFFF);
              ++v182;
            }

            while (v182 != v181 - v234);
          }

          SetCost(v258, 256LL, 1, v254);
          SetCost(v256, 704LL, 0, v247);
          SetCost(v255, v249, 0, v248);
          unint64_t v191 = 0LL;
          double v192 = 1.7e38;
          do
          {
            if (v192 >= v247[v191]) {
              double v192 = v247[v191];
            }
            ++v191;
          }

          while (v191 != 704);
          uint64_t v251 = v192;
          unint64_t v193 = v250;
          unint64_t v194 = v252;
          *unint64_t v250 = 0;
          uint64_t v179 = v241;
          uint64_t v178 = v242;
          uint64_t v180 = v244;
          if (v194)
          {
            uint64_t v195 = (float *)(v193 + 1);
            uint64_t v196 = 0.0;
            unint64_t v197 = v240;
            double v198 = 0.0;
            do
            {
              uint64_t v199 = v198 + v254[*(unsigned __int8 *)(v19 + (v197 & v242))];
              double v200 = v196 + v199;
              *v195++ = v196 + v199;
              double v198 = v199 - (float)((float)(v196 + v199) - v196);
              ++v197;
              uint64_t v196 = v200;
              --v194;
            }

            while (v194);
          }
        }

        *unint64_t v169 = v234;
        *BOOL v168 = v226;
        *unint64_t v170 = v231;
        *a9 = v253;
        unint64_t v201 = *(void *)(v179 + 16);
        uint64_t v202 = *(_DWORD *)(v179 + 8);
        unsigned int v203 = 325LL;
        uint64_t v238 = v203;
        *unint64_t v172 = 0;
        v172[3] = 0;
        v257 = 0LL;
        double v204 = v246;
        if (v228)
        {
          double v205 = 0LL;
          double v206 = 0LL;
          unint64_t v207 = (1LL << v202) - 16;
          double v208 = (void *)(v201 + v240);
          do
          {
            updated = UpdateNodes( v204,  v240,  v205,  v19,  v178,  v179,  v207,  a9,  *(unsigned int *)(v239 + 4 * v205),  v180 + 8 * v206,  (uint64_t)v247,  (uint64_t)v256,  (uint64_t)v172);
            uint64_t v180 = v244;
            if (updated >= 0x4000) {
              uint64_t v210 = updated;
            }
            else {
              uint64_t v210 = 0LL;
            }
            size_t v211 = *(unsigned int *)(v239 + 4 * v205);
            v206 += v211;
            if ((_DWORD)v211 == 1)
            {
              uint64_t v212 = *(unsigned int *)(v244 + 8 * v206 - 4);
              unsigned __int16 v213 = v212 >> 5;
              if (v212 >> 5 <= v210) {
                unsigned __int16 v213 = v210;
              }
              if (v238 < v212 >> 5) {
                uint64_t v210 = v213;
              }
            }

            if (v210 >= 2)
            {
              uint64_t v214 = v210 - 1;
              double v204 = v246;
              do
              {
                unint64_t v215 = v205 + 1;
                if (v205 + 4 >= v204) {
                  break;
                }
                EvaluateNode(v208, v205 + 1, v207, a9, (uint64_t)v247, (uint64_t)v256, (uint64_t)v172);
                double v204 = v246;
                v206 += *(unsigned int *)(v239 + 4 + 4 * v205++);
                --v214;
              }

              while (v214);
              double v205 = v215;
              uint64_t v180 = v244;
              unint64_t v19 = v245;
            }

            else
            {
              double v204 = v246;
            }

            __int16 v216 = v205 + 4;
            ++v205;
            uint64_t v179 = v241;
            uint64_t v178 = v242;
          }

          while (v216 < v204);
        }

        uint64_t v217 = v179;
        uint64_t v218 = v204;
        unint64_t v170 = a10;
        unint64_t v169 = a12;
        *a12 += ComputeShortestPathFromNodes(v204, (uint64_t)v172);
        unsigned int v219 = v218;
        BOOL v168 = a13;
        BrotliZopfliCreateCommands(v219, v240, (uint64_t)v172, (uint64_t)a9, a10, v217, a11, a13);
        unsigned int v174 = 0;
        uint64_t v171 = v221;
      }

      while ((v236 & 1) != 0);
      BrotliFree(v227, (unint64_t)v250);
      unint64_t v250 = 0LL;
      BrotliFree(v227, (unint64_t)v248);
      uint64_t v248 = 0LL;
      BrotliFree(v227, (unint64_t)v172);
      BrotliFree(v227, v244);
      BrotliFree(v227, v239);
    }
  }

LABEL_4:
  while (1)
  {
    *(_DWORD *)a1 = 7;
    if (*(_DWORD *)(a1 + 276)) {
      break;
    }
  }

  unint64_t v7 = *(void *)(a1 + 8);
  int v8 = *(_DWORD *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  unsigned int v11 = *(_BYTE **)(a1 + 136);
  unint64_t v12 = v7;
  int v13 = v8;
  if ((v8 - 50) > 0xE)
  {
LABEL_11:
    unint64_t v19 = v12 >> v13;
    uint64_t v20 = &v11[4 * (v12 >> v13)];
    unsigned int v21 = *v20;
    if (v21 >= 9)
    {
      v13 += 8;
      unsigned int v21 = *v20;
    }

    *(_DWORD *)(a1 + 16) = v13 + v21;
    unsigned int v22 = *((unsigned __int16 *)v20 + 1);
    unsigned int v134 = v22;
  }

  else
  {
    uint64_t v14 = v9 + 1;
    uint64_t v15 = v10 - 1;
    unint64_t v12 = *(void *)(a1 + 8);
    int v16 = *(_DWORD *)(a1 + 16);
    while (v15 != -1)
    {
      *(void *)(a1 + 8) = v12 >> 8;
      *((void *)&v17 + 1) = *(unsigned __int8 *)(v14 - 1);
      *(void *)&__int128 v17 = v12;
      unint64_t v12 = v17 >> 8;
      *(void *)(a1 + 8) = v12;
      int v13 = v16 - 8;
      *(_DWORD *)(a1 + 16) = v16 - 8;
      *(void *)(a1 + 24) = v14;
      *(void *)(a1 + 32) = v15;
      ++v14;
      --v15;
      unsigned int v18 = v16 - 58;
      v16 -= 8;
      if (v18 >= 0xF) {
        goto LABEL_11;
      }
    }

    unsigned int v22 = v134;
  }

  int v23 = 0;
  BOOL v24 = (unsigned __int8 *)&kCmdLut + 8 * v22;
  unsigned int v25 = *v24;
  unsigned int v26 = v24[1];
  int v27 = (char)v24[2];
  uint64_t v28 = v24[3];
  LODWORD(v3) = *((unsigned __int16 *)v24 + 2);
  int v29 = *((unsigned __int16 *)v24 + 3);
  *(_DWORD *)(a1 + 360) = v27;
  *(_DWORD *)(a1 + 260) = v28;
  *(_BYTE *)(a1 + 352) = *(_BYTE *)(*(void *)(a1 + 160) + v28);
  if (v25)
  {
    int v30 = *(_DWORD *)(a1 + 16);
    unsigned int v31 = 64 - v30;
    if (64 - v30 < v25)
    {
      uint64_t v32 = *(void *)(a1 + 32) - 1LL;
      while (v32 != -1)
      {
        unint64_t v33 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v33 >> 8;
        unsigned int v34 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v36 + 1) = *v34;
        *(void *)&__int128 v36 = v33;
        unint64_t v35 = v36 >> 8;
        *(void *)(a1 + 8) = v35;
        v30 -= 8;
        *(_DWORD *)(a1 + 16) = v30;
        *(void *)(a1 + 24) = v34 + 1;
        *(void *)(a1 + 32) = v32--;
        v31 += 8;
        if (v31 >= v25) {
          goto LABEL_23;
        }
      }

      goto LABEL_149;
    }

    unint64_t v35 = *v4;
LABEL_23:
    int v23 = (v35 >> v30) & ~(-1 << v25);
    *(_DWORD *)(a1 + 16) = v30 + v25;
  }

  int v37 = 0;
  if (v26)
  {
    int v38 = *(_DWORD *)(a1 + 16);
    unsigned int v39 = 64 - v38;
    if (64 - v38 < v26)
    {
      uint64_t v40 = *(void *)(a1 + 32) - 1LL;
      while (v40 != -1)
      {
        unint64_t v41 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v41 >> 8;
        unint64_t v42 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v44 + 1) = *v42;
        *(void *)&__int128 v44 = v41;
        unint64_t v43 = v44 >> 8;
        *(void *)(a1 + 8) = v43;
        v38 -= 8;
        *(_DWORD *)(a1 + 16) = v38;
        *(void *)(a1 + 24) = v42 + 1;
        *(void *)(a1 + 32) = v40--;
        v39 += 8;
        if (v39 >= v26) {
          goto LABEL_31;
        }
      }

      goto LABEL_149;
    }

    unint64_t v43 = *v4;
LABEL_31:
    int v37 = (v43 >> v38) & ~(-1 << v26);
    *(_DWORD *)(a1 + 16) = v38 + v26;
  }

  *(_DWORD *)(a1 + 356) = v37 + v29;
  --*(_DWORD *)(a1 + 276);
  if (!(v23 + (_DWORD)v3))
  {
    LODWORD(v3) = 0;
    goto LABEL_76;
  }

  *(_DWORD *)(a1 + 264) -= v23 + v3;
  LODWORD(v3) = v23 + v3;
LABEL_34:
  int v45 = *(_DWORD *)(a1 + 256);
  *(_DWORD *)a1 = 8;
  if (v45) {
    goto LABEL_35;
  }
  uint64_t v60 = *(void *)(a1 + 120);
  uint64_t v61 = v2;
  uint64_t v62 = *(int *)(a1 + 92);
  uint64_t v63 = *(unsigned __int8 *)(v60 + (v62 & (v2 - 1LL)));
  uint64_t v64 = *(unsigned __int8 *)(v60 + (v62 & (v2 - 2LL)));
  int v65 = *(_DWORD *)(a1 + 272);
  while (1)
  {
    if (!v65)
    {
      if (*(_DWORD *)(a1 + 256))
      {
        *(_DWORD *)a1 = 8;
        int v2 = v61;
LABEL_35:
        uint64_t v46 = v2;
        int v47 = *(_DWORD *)(a1 + 272);
        while (1)
        {
          if (!v47)
          {
            if (!*(_DWORD *)(a1 + 256))
            {
              int v2 = v46;
              goto LABEL_34;
            }
          }

          int v48 = *(_BYTE **)(a1 + 344);
          int v49 = *(_DWORD *)(a1 + 16);
          if ((v49 - 50) >= 0xF)
          {
            unint64_t v53 = *v4;
LABEL_43:
            unint64_t v56 = v53 >> v49;
            uint64_t v57 = &v48[4 * (v53 >> v49)];
            unsigned int v58 = *v57;
            if (v58 >= 9)
            {
              v49 += 8;
              unsigned int v58 = *v57;
            }

            *(_DWORD *)(a1 + 16) = v49 + v58;
            __int16 v59 = *((_WORD *)v57 + 1);
          }

          else
          {
            uint64_t v50 = *(void *)(a1 + 32) - 1LL;
            while (v50 != -1)
            {
              unint64_t v51 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v51 >> 8;
              unsigned int v52 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v54 + 1) = *v52;
              *(void *)&__int128 v54 = v51;
              unint64_t v53 = v54 >> 8;
              *(void *)(a1 + 8) = v53;
              int v55 = v49 - 8;
              *(_DWORD *)(a1 + 16) = v49 - 8;
              *(void *)(a1 + 24) = v52 + 1;
              *(void *)(a1 + 32) = v50--;
              LODWORD(v52) = v49 - 58;
              v49 -= 8;
              if (v52 >= 0xF)
              {
                int v49 = v55;
                goto LABEL_43;
              }
            }

            if (!SafeDecodeSymbol(v48, (uint64_t)v4, &v134))
            {
LABEL_86:
              uint64_t result = 2LL;
              goto LABEL_87;
            }

            LOBYTE(v59) = v134;
          }

          *(_BYTE *)(*(void *)(a1 + 120) + v46) = v59;
          int v47 = *(_DWORD *)(a1 + 272) - 1;
          *(_DWORD *)(a1 + 272) = v47;
          ++v46;
          int v2 = *(_DWORD *)(a1 + 88);
          if (v2 == (_DWORD)v46) {
            goto LABEL_159;
          }
          LODWORD(v3) = v3 - 1;
          if (!(_DWORD)v3) {
            goto LABEL_73;
          }
        }
      }
    }

    __int128 v66 = *(_BYTE **)(*(void *)(a1 + 168)
                    + 8LL
    int v67 = *(_DWORD *)(a1 + 16);
    if ((v67 - 50) >= 0xF)
    {
      unint64_t v71 = *v4;
LABEL_62:
      unint64_t v74 = v71 >> v67;
      uint64_t v75 = &v66[4 * (v71 >> v67)];
      unsigned int v76 = *v75;
      if (v76 >= 9)
      {
        v67 += 8;
        unsigned int v76 = *v75;
      }

      *(_DWORD *)(a1 + 16) = v67 + v76;
      uint64_t v77 = v75[2];
    }

    else
    {
      uint64_t v68 = *(void *)(a1 + 32) - 1LL;
      while (v68 != -1)
      {
        unint64_t v69 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v69 >> 8;
        uint64_t v70 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v72 + 1) = *v70;
        *(void *)&__int128 v72 = v69;
        unint64_t v71 = v72 >> 8;
        *(void *)(a1 + 8) = v71;
        int v73 = v67 - 8;
        *(_DWORD *)(a1 + 16) = v67 - 8;
        *(void *)(a1 + 24) = v70 + 1;
        *(void *)(a1 + 32) = v68--;
        LODWORD(v70) = v67 - 58;
        v67 -= 8;
        if (v70 >= 0xF)
        {
          int v67 = v73;
          goto LABEL_62;
        }
      }

      if (!SafeDecodeSymbol(v66, (uint64_t)v4, &v134))
      {
LABEL_108:
        uint64_t result = 2LL;
        int v2 = v61;
        goto LABEL_151;
      }

      uint64_t v77 = v134;
    }

    *(_BYTE *)(*(void *)(a1 + 120) + v61) = v77;
    int v65 = *(_DWORD *)(a1 + 272) - 1;
    *(_DWORD *)(a1 + 272) = v65;
    ++v61;
    int v2 = *(_DWORD *)(a1 + 88);
    if (v2 == (_DWORD)v61) {
      break;
    }
    uint64_t v64 = v63;
    uint64_t v63 = v77;
    LODWORD(v46) = v61;
    LODWORD(v3) = v3 - 1;
    if (!(_DWORD)v3)
    {
LABEL_73:
      if (*(int *)(a1 + 264) <= 0)
      {
        LODWORD(v3) = 0;
        *(_DWORD *)a1 = 14;
        uint64_t result = 1LL;
LABEL_87:
        int v2 = v46;
        goto LABEL_151;
      }

      LODWORD(v3) = 0;
      int v2 = v46;
LABEL_76:
      *(_DWORD *)a1 = 9;
      int v78 = *(_DWORD *)(a1 + 360);
      if ((v78 & 0x80000000) == 0)
      {
        unsigned int v79 = v78 == 0;
        *(_DWORD *)(a1 + 260) = v79;
        int v80 = *(_DWORD *)(a1 + 96) - 1;
        *(_DWORD *)(a1 + 96) = v80;
        int v81 = *(_DWORD *)(a1 + 4LL * (v80 & 3) + 100);
        goto LABEL_112;
      }

      uint64_t v82 = a1 + 744;
      unsigned int v83 = *(_BYTE **)(*(void *)(a1 + 216) + 8LL * *(unsigned __int8 *)(a1 + 352));
      unint64_t v7 = *(void *)(a1 + 8);
      int v8 = *(_DWORD *)(a1 + 16);
      uint64_t v9 = *(void *)(a1 + 24);
      uint64_t v10 = *(void *)(a1 + 32);
      unint64_t v84 = v7;
      int v85 = v8;
      if ((v8 - 50) > 0xE)
      {
LABEL_83:
        unint64_t v91 = v84 >> v85;
        char v92 = &v83[4 * (v84 >> v85)];
        unsigned int v93 = *v92;
        if (v93 >= 9)
        {
          v85 += 8;
          unsigned int v93 = *v92;
        }

        *(_DWORD *)(a1 + 16) = v85 + v93;
        unsigned int v94 = *((unsigned __int16 *)v92 + 1);
      }

      else
      {
        uint64_t v86 = v9 + 1;
        uint64_t v87 = v10 - 1;
        unint64_t v84 = *(void *)(a1 + 8);
        int v88 = *(_DWORD *)(a1 + 16);
        while (v87 != -1)
        {
          *(void *)(a1 + 8) = v84 >> 8;
          *((void *)&v89 + 1) = *(unsigned __int8 *)(v86 - 1);
          *(void *)&__int128 v89 = v84;
          unint64_t v84 = v89 >> 8;
          *(void *)(a1 + 8) = v84;
          int v85 = v88 - 8;
          *(_DWORD *)(a1 + 16) = v88 - 8;
          *(void *)(a1 + 24) = v86;
          *(void *)(a1 + 32) = v87;
          ++v86;
          --v87;
          unsigned int v90 = v88 - 58;
          v88 -= 8;
          if (v90 >= 0xF) {
            goto LABEL_83;
          }
        }

        unsigned int v94 = v134;
      }

      int v95 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 280) = v95 - 1;
      *(_DWORD *)(a1 + 260) = 0;
      if (v94 > 0xF)
      {
        int v97 = 0;
        unsigned int v98 = *(unsigned __int8 *)(v82 + v94);
        if (*(_BYTE *)(v82 + v94))
        {
          int v99 = *(_DWORD *)(a1 + 16);
          unsigned int v100 = 64 - v99;
          if (64 - v99 < v98)
          {
            uint64_t v101 = *(void *)(a1 + 32) - 1LL;
            while (v101 != -1)
            {
              unint64_t v102 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v102 >> 8;
              int v103 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v105 + 1) = *v103;
              *(void *)&__int128 v105 = v102;
              unint64_t v104 = v105 >> 8;
              *(void *)(a1 + 8) = v104;
              v99 -= 8;
              *(_DWORD *)(a1 + 16) = v99;
              *(void *)(a1 + 24) = v103 + 1;
              *(void *)(a1 + 32) = v101--;
              v100 += 8;
              if (v100 >= v98) {
                goto LABEL_110;
              }
            }

            *(_DWORD *)(a1 + 280) = v95;
LABEL_149:
            *(void *)(a1 + 8) = v7;
            *(_DWORD *)(a1 + 16) = v8;
            *(void *)(a1 + 24) = v9;
            *(void *)(a1 + 32) = v10;
LABEL_150:
            uint64_t result = 2LL;
            goto LABEL_151;
          }

          unint64_t v104 = *v4;
LABEL_110:
          int v97 = (v104 >> v99) & ~(-1 << v98);
          *(_DWORD *)(a1 + 16) = v99 + v98;
        }

        unsigned int v79 = 0;
        int v81 = (v97 << *(_DWORD *)(a1 + 320)) + *(_DWORD *)(a1 + 4LL * v94 + 1288);
        goto LABEL_112;
      }

      *(_DWORD *)(a1 + 360) = v94;
      if (v94 <= 3)
      {
        unsigned int v79 = 1u >> v94;
        *(_DWORD *)(a1 + 260) = 1u >> v94;
        int v96 = *(_DWORD *)(a1 + 96);
        int v81 = *(_DWORD *)(a1 + 4LL * (((_BYTE)v96 + ~(_BYTE)v94) & 3) + 100);
        *(_DWORD *)(a1 + 360) = v81;
        *(_DWORD *)(a1 + 96) = v96 - v79;
        goto LABEL_113;
      }

      unsigned int v79 = 0;
      if (v94 >= 0xA) {
        char v106 = 10;
      }
      else {
        char v106 = 3;
      }
      if (v94 >= 0xA) {
        char v107 = -10;
      }
      else {
        char v107 = -4;
      }
      int v81 = ((0x605142u >> (4 * (v107 + v94))) & 7)
      if (v81 < 1) {
        int v81 = 0x7FFFFFFF;
      }
LABEL_112:
      *(_DWORD *)(a1 + 360) = v81;
LABEL_113:
      int v109 = *(_DWORD *)(a1 + 80);
      int v108 = *(_DWORD *)(a1 + 84);
      if (v108 != v109)
      {
        if (v2 >= v109) {
          int v108 = *(_DWORD *)(a1 + 80);
        }
        else {
          int v108 = v2;
        }
        *(_DWORD *)(a1 + 84) = v108;
      }

      size_t v3 = *(unsigned int *)(a1 + 356);
      if (v81 > v108)
      {
        if (v81 > 2147483644) {
          return 4294967280LL;
        }
        uint64_t v110 = *(void *)(a1 + 696);
        uint64_t v111 = *(void *)(a1 + 704);
        uint64_t v112 = *(int *)(v110 + 4 * v3 + 32);
        char v113 = *(_BYTE *)(v110 + v3);
        *(_DWORD *)(a1 + 96) += v79;
        uint64_t v114 = *(void *)(v110 + 168);
        if (!v114) {
          return 4294967277LL;
        }
        int v115 = v81 + ~v108;
        int v116 = v115 >> v113;
        if (v115 >> v113 >= *(_DWORD *)(v111 + 24)) {
          return 4294967285LL;
        }
        BOOL v117 = (void *)(v114 + v112 + (v115 & ~(-1 << v113)) * (int)v3);
        int v118 = (void *)(*(void *)(a1 + 120) + v2);
        if (v116 == *(__int16 *)(v111 + 48))
        {
          memcpy(v118, v117, v3);
          int v119 = v3;
        }

        else
        {
          int v119 = BrotliTransformDictionaryWord((uint64_t)v118, (char *)v117, v3, (void *)v111, v116);
        }

        v2 += v119;
        *(_DWORD *)(a1 + 264) -= v119;
        if (v2 < *(_DWORD *)(a1 + 88))
        {
          int v125 = v2;
          goto LABEL_144;
        }

        int v133 = 15;
LABEL_158:
        *(_DWORD *)a1 = v133;
        goto LABEL_160;
      }

      int v120 = *(_DWORD *)(a1 + 96);
      int v121 = *(_DWORD *)(a1 + 92) & (v2 - v81);
      uint64_t v122 = *(void *)(a1 + 120);
      uint64_t v5 = v2;
      unsigned int v123 = (_OWORD *)(v122 + v2);
      uint64_t v124 = (_OWORD *)(v122 + v121);
      int v125 = v3 + v2;
      *(_DWORD *)(a1 + 4LL * (v120 & 3) + 100) = v81;
      *(_DWORD *)(a1 + 96) = v120 + 1;
      *(_DWORD *)(a1 + 264) -= v3;
      _OWORD *v123 = *v124;
      int v127 = *(_DWORD *)(a1 + 88);
      if ((int)v3 >= 17)
      {
        int v128 = v123 + 1;
        int v129 = v124 + 1;
        else {
          memcpy(v128, v129, (v3 - 16));
        }
      }

LABEL_144:
      if (*(int *)(a1 + 264) <= 0)
      {
        *(_DWORD *)a1 = 14;
        uint64_t result = 1LL;
        int v2 = v125;
        goto LABEL_151;
      }

      int v2 = v125;
      goto LABEL_4;
    }
  }

LABEL_159:
  *(_DWORD *)a1 = 13;
  LODWORD(v3) = v3 - 1;
LABEL_160:
  uint64_t result = 1LL;
LABEL_151:
  *(_DWORD *)(a1 + 76) = v2;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

    if (v74 <= v164 && v118)
    {
      a7[3] = a7[2];
      *(void *)(a7 + 1) = *(void *)a7;
      *a7 = v74;
    }

void **WrapRingBuffer(void **result)
{
  if (((_WORD)result[83] & 8) != 0)
  {
    uint64_t v1 = result;
    uint64_t result = (void **)memcpy(result[15], v1[16], *((int *)v1 + 19));
    *((_WORD *)v1 + 332) &= ~8u;
  }

  return result;
}

BOOL BrotliDecoderHasMoreOutput(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 116) & 0x80000000) == 0
      && *(void *)(a1 + 120)
      && *(int *)(a1 + 76) - *(void *)(a1 + 376) + *(void *)(a1 + 368) * *(int *)(a1 + 88) != 0LL;
}

void *BrotliDecoderTakeOutput(uint64_t a1, size_t *a2)
{
  if (*a2) {
    size_t v3 = *a2;
  }
  else {
    size_t v3 = 0x1000000LL;
  }
  size_t v7 = v3;
  int v8 = 0LL;
  if (*(void *)(a1 + 120) && (*(_DWORD *)(a1 + 116) & 0x80000000) == 0)
  {
    WrapRingBuffer((void **)a1);
    unsigned int v5 = WriteRingBuffer(a1, &v7, &v8, 0LL, 1);
    if ((v5 & 0xFFFFFFFD) == 1)
    {
      uint64_t result = v8;
      *a2 = v3 - v7;
      return result;
    }

    if ((v5 & 0x80000000) != 0) {
      SaveErrorCode(a1, v5);
    }
  }

  uint64_t result = 0LL;
  *a2 = 0LL;
  return result;
}

BOOL BrotliDecoderIsUsed(_DWORD *a1)
{
  return *a1 || a1[4] != 64;
}

BOOL BrotliDecoderIsFinished(uint64_t a1)
{
  if (*(_DWORD *)a1 != 26) {
    return 0LL;
  }
  if ((*(_DWORD *)(a1 + 116) & 0x80000000) != 0 || !*(void *)(a1 + 120)) {
    return 1LL;
  }
  return *(int *)(a1 + 76) - *(void *)(a1 + 376) + *(void *)(a1 + 368) * *(int *)(a1 + 88) == 0LL;
}

uint64_t BrotliDecoderGetErrorCode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

const char *BrotliDecoderErrorString(int a1)
{
  else {
    return off_189B48D90[a1 + 31];
  }
}

uint64_t SafeDecodeSymbol(_BYTE *a1, uint64_t a2, _DWORD *a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 != 64)
  {
    unsigned int v5 = 64 - v3;
    uint64_t v6 = *(void *)a2 >> v3;
    size_t v7 = &a1[4 * v6];
    unsigned int v8 = *v7;
    if (v8 > 8)
    {
      if (v5 < 9) {
        return 0LL;
      }
      uint64_t v10 = *(unsigned __int16 *)&a1[4 * v6 + 2] + ((v6 & ~(-1 << v8)) >> 8);
      unsigned int v11 = v7[4 * v10];
      if (56 - v3 < v11) {
        return 0LL;
      }
      *(_DWORD *)(a2 + 8) = v3 + v11 + 8;
      uint64_t v9 = &v7[4 * v10];
    }

    else
    {
      if (v5 < v8) {
        return 0LL;
      }
      *(_DWORD *)(a2 + 8) = v3 + v8;
      uint64_t v9 = &a1[4 * v6];
    }

    uint64_t v4 = (unsigned __int16 *)(v9 + 2);
    goto LABEL_12;
  }

  if (*a1) {
    return 0LL;
  }
  uint64_t v4 = (unsigned __int16 *)(a1 + 2);
LABEL_12:
  *a3 = *v4;
  return 1LL;
}

unsigned __int8 *InverseMoveToFrontTransform(unsigned __int8 *result, unsigned int a2, _DWORD *a3)
{
  uint64_t v4 = result;
  int v5 = a3[96];
  uint64_t v6 = a3 + 98;
  a3[98] = 50462976;
  else {
    uint64_t v7 = 2LL;
  }
  unsigned int v8 = a3 + 99;
  uint64_t v9 = v7 - 1;
  int v10 = 117835012;
  do
  {
    *v8++ = v10;
    v10 += 67372036;
    --v9;
  }

  while (v9);
  if (a2)
  {
    unsigned int v11 = 0;
    unint64_t v12 = (unsigned __int8 *)a3 + 391;
    uint64_t v13 = a2;
    do
    {
      uint64_t v14 = *v4;
      unsigned __int8 v15 = v6[v14];
      *v4++ = v15;
      *unint64_t v12 = v15;
      uint64_t result = (unsigned __int8 *)memmove(v6, (char *)a3 + 391, v14 + 1);
      v11 |= v14;
      --v13;
    }

    while (v13);
    unsigned int v16 = v11 >> 2;
  }

  else
  {
    unsigned int v16 = 0;
  }

  a3[96] = v16;
  return result;
}

uint64_t SafeDecodeCommandBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 288);
  if (v1 < 2) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 248);
  uint64_t v4 = (_BYTE *)(*(void *)(a1 + 240) + 2528LL);
  int v5 = (unint64_t *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    unsigned int v18 = &v4[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      unsigned int v19 = *v18;
    }

    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v46 = *((unsigned __int16 *)v18 + 1);
  }

  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&__int128 v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
  }

  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }

  else
  {
    unsigned int v21 = (_BYTE *)(v3 + 1584);
    int v22 = *(_DWORD *)(a1 + 16);
    if ((v22 - 50) >= 0xF)
    {
      unint64_t v26 = *v5;
LABEL_19:
      unint64_t v29 = v26 >> v22;
      int v30 = &v21[4 * (v26 >> v22)];
      unsigned int v31 = *v30;
      if (v31 >= 9)
      {
        v22 += 8;
        unsigned int v31 = *v30;
      }

      *(_DWORD *)(a1 + 16) = v22 + v31;
      unsigned int v20 = *((unsigned __int16 *)v30 + 1);
    }

    else
    {
      uint64_t v23 = *(void *)(a1 + 32) - 1LL;
      while (v23 != -1)
      {
        unint64_t v24 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v24 >> 8;
        unsigned int v25 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v27 + 1) = *v25;
        *(void *)&__int128 v27 = v24;
        unint64_t v26 = v27 >> 8;
        *(void *)(a1 + 8) = v26;
        int v28 = v22 - 8;
        *(_DWORD *)(a1 + 16) = v22 - 8;
        *(void *)(a1 + 24) = v25 + 1;
        *(void *)(a1 + 32) = v23--;
        LODWORD(v25) = v22 - 58;
        v22 -= 8;
        if (v25 >= 0xF)
        {
          int v22 = v28;
          goto LABEL_19;
        }
      }

      unsigned int v20 = v47;
    }
  }

  uint64_t v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v33 = *((unsigned __int8 *)v32 + 2);
  int v34 = *v32;
  int v35 = *(_DWORD *)(a1 + 16);
  unsigned int v36 = 64 - v35;
  if (64 - v35 < v33)
  {
    uint64_t v37 = *(void *)(a1 + 32) - 1LL;
    while (v37 != -1)
    {
      unint64_t v38 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v38 >> 8;
      unsigned int v39 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v41 + 1) = *v39;
      *(void *)&__int128 v41 = v38;
      unint64_t v40 = v41 >> 8;
      *(void *)(a1 + 8) = v40;
      v35 -= 8;
      *(_DWORD *)(a1 + 16) = v35;
      *(void *)(a1 + 24) = v39 + 1;
      *(void *)(a1 + 32) = v37--;
      v36 += 8;
      if (v36 >= v33) {
        goto LABEL_28;
      }
    }

    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0LL;
  }

  unint64_t v40 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v35 + v33;
  *(_DWORD *)(a1 + 276) = ((v40 >> v35) & ~(-1 << v33)) + v34;
  *(_DWORD *)(a1 + 660) = 0;
  if (v46)
  {
    if (v46 == 1) {
      unsigned int v42 = *(_DWORD *)(a1 + 308) + 1;
    }
    else {
      unsigned int v42 = v46 - 2;
    }
  }

  else
  {
    unsigned int v42 = *(_DWORD *)(a1 + 304);
  }

  if (v42 >= v1) {
    unsigned int v44 = v1;
  }
  else {
    unsigned int v44 = 0;
  }
  unsigned int v45 = v42 - v44;
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = v45;
  *(void *)(a1 + 136) = *(void *)(*(void *)(a1 + 192) + 8LL * v45);
  return 1LL;
}

uint64_t DecodeCommandBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 288);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240) + 2528LL;
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      int v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&__int128 v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }

    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4LL * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      unsigned int v10 = *v9;
    }

    uint64_t v11 = *(void *)(result + 248) + 1584LL;
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      int v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&__int128 v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }

    unint64_t v17 = v4 >> v12;
    unsigned int v18 = (unsigned __int8 *)(v11 + 4LL * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      unsigned int v19 = *v18;
    }

    unsigned int v20 = v12 + v19;
    unsigned int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      unint64_t v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&__int128 v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }

    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 276) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 308) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }

    else
    {
      unsigned int v27 = *(_DWORD *)(result + 304);
    }

    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 304) = *(_DWORD *)(result + 308);
    *(_DWORD *)(result + 308) = v28;
    *(void *)(result + 136) = *(void *)(*(void *)(result + 192) + 8LL * v28);
  }

  return result;
}

uint64_t SafeDecodeLiteralBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 284);
  if (v1 < 2) {
    return 0LL;
  }
  unsigned int v3 = *(_BYTE **)(a1 + 240);
  unint64_t v4 = *(_BYTE **)(a1 + 248);
  int v5 = (unint64_t *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    unsigned int v18 = &v3[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      unsigned int v19 = *v18;
    }

    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v47 = *((unsigned __int16 *)v18 + 1);
  }

  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&__int128 v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
  }

  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }

  else
  {
    int v21 = *(_DWORD *)(a1 + 16);
    if ((v21 - 50) >= 0xF)
    {
      unint64_t v25 = *v5;
LABEL_19:
      unint64_t v28 = v25 >> v21;
      unint64_t v29 = &v4[4 * (v25 >> v21)];
      unsigned int v30 = *v29;
      if (v30 >= 9)
      {
        v21 += 8;
        unsigned int v30 = *v29;
      }

      *(_DWORD *)(a1 + 16) = v21 + v30;
      unsigned int v20 = *((unsigned __int16 *)v29 + 1);
    }

    else
    {
      uint64_t v22 = *(void *)(a1 + 32) - 1LL;
      while (v22 != -1)
      {
        unint64_t v23 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v23 >> 8;
        unint64_t v24 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v26 + 1) = *v24;
        *(void *)&__int128 v26 = v23;
        unint64_t v25 = v26 >> 8;
        *(void *)(a1 + 8) = v25;
        int v27 = v21 - 8;
        *(_DWORD *)(a1 + 16) = v21 - 8;
        *(void *)(a1 + 24) = v24 + 1;
        *(void *)(a1 + 32) = v22--;
        LODWORD(v24) = v21 - 58;
        v21 -= 8;
        if (v24 >= 0xF)
        {
          int v21 = v27;
          goto LABEL_19;
        }
      }

      unsigned int v20 = v48;
    }
  }

  unsigned int v31 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v32 = *((unsigned __int8 *)v31 + 2);
  int v33 = *v31;
  int v34 = *(_DWORD *)(a1 + 16);
  unsigned int v35 = 64 - v34;
  if (64 - v34 < v32)
  {
    uint64_t v36 = *(void *)(a1 + 32) - 1LL;
    while (v36 != -1)
    {
      unint64_t v37 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v37 >> 8;
      unint64_t v38 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v40 + 1) = *v38;
      *(void *)&__int128 v40 = v37;
      unint64_t v39 = v40 >> 8;
      *(void *)(a1 + 8) = v39;
      v34 -= 8;
      *(_DWORD *)(a1 + 16) = v34;
      *(void *)(a1 + 24) = v38 + 1;
      *(void *)(a1 + 32) = v36--;
      v35 += 8;
      if (v35 >= v32) {
        goto LABEL_28;
      }
    }

    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0LL;
  }

  unint64_t v39 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v34 + v32;
  *(_DWORD *)(a1 + 272) = ((v39 >> v34) & ~(-1 << v32)) + v33;
  *(_DWORD *)(a1 + 660) = 0;
  if (v47)
  {
    if (v47 == 1) {
      unsigned int v41 = *(_DWORD *)(a1 + 300) + 1;
    }
    else {
      unsigned int v41 = v47 - 2;
    }
  }

  else
  {
    unsigned int v41 = *(_DWORD *)(a1 + 296);
  }

  if (v41 >= v1) {
    unsigned int v43 = v1;
  }
  else {
    unsigned int v43 = 0;
  }
  unsigned int v44 = v41 - v43;
  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = v44;
  uint64_t v45 = v44 << 6;
  uint64_t v46 = *(void *)(a1 + 680);
  *(void *)(a1 + 152) = v46 + v45;
  *(_DWORD *)(a1 + 256) = (*(_DWORD *)(a1 + 4LL * (v44 >> 5) + 712) >> v44) & 1;
  *(void *)(a1 + 344) = *(void *)(*(void *)(a1 + 168) + 8LL * *(unsigned __int8 *)(v46 + v45));
  *(void *)(a1 + 144) = &_kBrotliContextLookupTable[512
                                                    * (unint64_t)(*(_BYTE *)(*(void *)(a1 + 688) + v44) & 3)];
  return 1LL;
}

uint64_t DecodeLiteralBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 284);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240);
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      int v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&__int128 v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }

    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4LL * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      unsigned int v10 = *v9;
    }

    uint64_t v11 = *(void *)(result + 248);
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      int v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&__int128 v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }

    unint64_t v17 = v4 >> v12;
    unsigned int v18 = (unsigned __int8 *)(v11 + 4LL * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      unsigned int v19 = *v18;
    }

    unsigned int v20 = v12 + v19;
    int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      unint64_t v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&__int128 v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }

    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 272) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 300) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }

    else
    {
      unsigned int v27 = *(_DWORD *)(result + 296);
    }

    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 296) = *(_DWORD *)(result + 300);
    *(_DWORD *)(result + 300) = v28;
    uint64_t v29 = v28 << 6;
    uint64_t v30 = *(void *)(result + 680);
    *(void *)(result + 152) = v30 + v29;
    *(_DWORD *)(result + 256) = (*(_DWORD *)(result + 4LL * (v28 >> 5) + 712) >> v28) & 1;
    *(void *)(result + 344) = *(void *)(*(void *)(result + 168)
                                          + 8LL * *(unsigned __int8 *)(v30 + v29));
    *(void *)(result + 144) = (char *)&_kBrotliContextLookupTable
                              + 512 * (unint64_t)(*(_BYTE *)(*(void *)(result + 688) + v28) & 3);
  }

  return result;
}

uint64_t SafeDecodeDistanceBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 292);
  if (v1 < 2) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 248);
  unint64_t v4 = (_BYTE *)(*(void *)(a1 + 240) + 5056LL);
  int v5 = (unint64_t *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    unsigned int v18 = &v4[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      unsigned int v19 = *v18;
    }

    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v47 = *((unsigned __int16 *)v18 + 1);
  }

  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&__int128 v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
  }

  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }

  else
  {
    int v21 = (_BYTE *)(v3 + 3168);
    int v22 = *(_DWORD *)(a1 + 16);
    if ((v22 - 50) >= 0xF)
    {
      unint64_t v26 = *v5;
LABEL_19:
      unint64_t v29 = v26 >> v22;
      uint64_t v30 = &v21[4 * (v26 >> v22)];
      unsigned int v31 = *v30;
      if (v31 >= 9)
      {
        v22 += 8;
        unsigned int v31 = *v30;
      }

      *(_DWORD *)(a1 + 16) = v22 + v31;
      unsigned int v20 = *((unsigned __int16 *)v30 + 1);
    }

    else
    {
      uint64_t v23 = *(void *)(a1 + 32) - 1LL;
      while (v23 != -1)
      {
        unint64_t v24 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v24 >> 8;
        uint64_t v25 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v27 + 1) = *v25;
        *(void *)&__int128 v27 = v24;
        unint64_t v26 = v27 >> 8;
        *(void *)(a1 + 8) = v26;
        int v28 = v22 - 8;
        *(_DWORD *)(a1 + 16) = v22 - 8;
        *(void *)(a1 + 24) = v25 + 1;
        *(void *)(a1 + 32) = v23--;
        LODWORD(v25) = v22 - 58;
        v22 -= 8;
        if (v25 >= 0xF)
        {
          int v22 = v28;
          goto LABEL_19;
        }
      }

      unsigned int v20 = v48;
    }
  }

  unsigned int v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v33 = *((unsigned __int8 *)v32 + 2);
  int v34 = *v32;
  int v35 = *(_DWORD *)(a1 + 16);
  unsigned int v36 = 64 - v35;
  if (64 - v35 < v33)
  {
    uint64_t v37 = *(void *)(a1 + 32) - 1LL;
    while (v37 != -1)
    {
      unint64_t v38 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v38 >> 8;
      unint64_t v39 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v41 + 1) = *v39;
      *(void *)&__int128 v41 = v38;
      unint64_t v40 = v41 >> 8;
      *(void *)(a1 + 8) = v40;
      v35 -= 8;
      *(_DWORD *)(a1 + 16) = v35;
      *(void *)(a1 + 24) = v39 + 1;
      *(void *)(a1 + 32) = v37--;
      v36 += 8;
      if (v36 >= v33) {
        goto LABEL_28;
      }
    }

    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0LL;
  }

  unint64_t v40 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v35 + v33;
  *(_DWORD *)(a1 + 280) = ((v40 >> v35) & ~(-1 << v33)) + v34;
  *(_DWORD *)(a1 + 660) = 0;
  if (v47)
  {
    if (v47 == 1) {
      unsigned int v42 = *(_DWORD *)(a1 + 316) + 1;
    }
    else {
      unsigned int v42 = v47 - 2;
    }
  }

  else
  {
    unsigned int v42 = *(_DWORD *)(a1 + 312);
  }

  if (v42 >= v1) {
    unsigned int v44 = v1;
  }
  else {
    unsigned int v44 = 0;
  }
  unsigned int v45 = v42 - v44;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 316) = v45;
  uint64_t v46 = *(void *)(a1 + 336) + 4 * v45;
  *(void *)(a1 + 160) = v46;
  *(_BYTE *)(a1 + 352) = *(_BYTE *)(v46 + *(int *)(a1 + 260));
  return 1LL;
}

uint64_t DecodeDistanceBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 292);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240) + 5056LL;
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      int v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&__int128 v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }

    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4LL * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      unsigned int v10 = *v9;
    }

    uint64_t v11 = *(void *)(result + 248) + 3168LL;
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      int v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&__int128 v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }

    unint64_t v17 = v4 >> v12;
    unsigned int v18 = (unsigned __int8 *)(v11 + 4LL * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      unsigned int v19 = *v18;
    }

    unsigned int v20 = v12 + v19;
    int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      unint64_t v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&__int128 v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }

    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 280) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 316) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }

    else
    {
      unsigned int v27 = *(_DWORD *)(result + 312);
    }

    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 312) = *(_DWORD *)(result + 316);
    *(_DWORD *)(result + 316) = v28;
    uint64_t v29 = *(void *)(result + 336) + 4 * v28;
    *(void *)(result + 160) = v29;
    *(_BYTE *)(result + 352) = *(_BYTE *)(v29 + *(int *)(result + 260));
  }

  return result;
}

uint64_t lzfse_decode_lmd(uint64_t a1)
{
  unsigned int v1 = *(void **)(a1 + 24);
  uint64_t v2 = (uint64_t *)(*(void *)a1 + *(int *)(a1 + 120));
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(unsigned int *)(a1 + 112);
  uint64_t v5 = *(unsigned int *)(a1 + 72);
  unint64_t v6 = *(unsigned int *)(a1 + 88);
  unint64_t v7 = *(unsigned int *)(a1 + 92);
  unint64_t v8 = *(unsigned int *)(a1 + 96);
  unint64_t v9 = *(unsigned __int16 *)(a1 + 124);
  unint64_t v10 = *(unsigned __int16 *)(a1 + 126);
  unint64_t v11 = *(unsigned __int16 *)(a1 + 128);
  uint64_t v12 = *(void *)(a1 + 40) - (void)v1 - 32LL;
  int v13 = *(char **)(a1 + 80);
  if (v6 | v7) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    while (1)
    {
      uint64_t v2 = (uint64_t *)((char *)v2 - ((unint64_t)(63 - v4) >> 3));
      uint64_t v3 = *v2;
      int v14 = (unsigned __int8 *)(a1 + 136 + 8 * v9);
      uint64_t v15 = *v14;
      uint64_t v16 = v4 + ((63 - v4) & 0xFFFFFFFFFFFFFFF8LL) - v15;
      unint64_t v17 = (unint64_t)*v2 >> v16;
      unint64_t v18 = v17 & ~(-1LL << v15);
      LOBYTE(v15) = v14[1];
      unint64_t v9 = (v18 >> v15) + *((unsigned __int16 *)v14 + 1);
      unint64_t v6 = (v17 & ~(-1LL << v15)) + *((unsigned int *)v14 + 1);
      unsigned int v19 = (unsigned __int8 *)(a1 + 648 + 8 * v10);
      uint64_t v20 = *v19;
      uint64_t v21 = v16 - v20;
      unint64_t v22 = (unint64_t)*v2 >> v21;
      unint64_t v23 = v22 & ~(-1LL << v20);
      LOBYTE(v20) = v19[1];
      unint64_t v10 = (v23 >> v20) + *((unsigned __int16 *)v19 + 1);
      unint64_t v7 = (v22 & ~(-1LL << v20)) + *((unsigned int *)v19 + 1);
      unint64_t v24 = (unsigned __int8 *)(a1 + 1160 + 8 * v11);
      uint64_t v25 = *v24;
      uint64_t v4 = v21 - v25;
      unint64_t v26 = (unint64_t)*v2 >> v4;
      unint64_t v27 = v26 & ~(-1LL << v25);
      LOBYTE(v25) = v24[1];
      unint64_t v11 = (v27 >> v25) + *((unsigned __int16 *)v24 + 1);
      uint64_t v28 = (v26 & ~(-1LL << v25)) + *((unsigned int *)v24 + 1);
      if (v28) {
        unint64_t v8 = v28;
      }
      --v5;
LABEL_7:
      if (v8 > (unint64_t)v1 + v6 - *(void *)(a1 + 32)
        || a1 + *(unsigned int *)(a1 + 7304) + 7308LL < (uint64_t)&v13[v6])
      {
        return -3LL;
      }

      BOOL v29 = v12 < (uint64_t)(v6 + v7);
      v12 -= v6 + v7;
      if (v29)
      {
        uint64_t v40 = v12 + v6 + v7 + 32;
        if (v6)
        {
          do
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              goto LABEL_30;
            }
            char v42 = *v13++;
            *(_BYTE *)unsigned int v1 = v42;
            unsigned int v1 = (void *)((char *)v1 + 1);
          }

          while (--v6);
        }

        if (v7)
        {
          unsigned int v43 = (char *)v1 - v8;
          while (1)
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              break;
            }
            char v44 = *v43++;
            *(_BYTE *)unsigned int v1 = v44;
            unsigned int v1 = (void *)((char *)v1 + 1);
            if (!--v7) {
              goto LABEL_28;
            }
          }

LABEL_28:
        uint64_t v12 = v40 - 32;
        if (!v5) {
          goto LABEL_29;
        }
      }

      else
      {
        do
        {
          uint64_t v30 = *(void *)v13;
          uint64_t v31 = *((void *)v13 + 1);
          v13 += 16;
          void *v1 = v30;
          v1[1] = v31;
          v1 += 2;
          BOOL v29 = v6 > 0x10;
          v6 -= 16LL;
        }

        while (v29);
        unsigned int v32 = (int8x16_t *)((char *)v1 + v6);
        v13 += v6;
        unsigned int v33 = (int8x16_t *)((char *)v32 - v8);
        if (v8 < 0x10)
        {
          unsigned int v36 = (int8x16_t *)((char *)&unk_1810968A0 + 32 * v8);
          unint64_t v37 = byte_181096AA0[v8];
          int8x16_t v38 = vqtbl1q_s8(*v33, *v36);
          int8x16_t v39 = vqtbl1q_s8(*v33, v36[1]);
          do
          {
            *unsigned int v32 = v38;
            v32[1] = v39;
            unsigned int v32 = (int8x16_t *)((char *)v32 + v37);
            BOOL v29 = v7 > v37;
            v7 -= v37;
          }

          while (v29);
          unsigned int v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }

        else
        {
          do
          {
            uint64_t v34 = v33->i64[0];
            uint64_t v35 = v33->i64[1];
            ++v33;
            v32->i64[0] = v34;
            v32->i64[1] = v35;
            ++v32;
            BOOL v29 = v7 > 0x10;
            v7 -= 16LL;
          }

          while (v29);
          unsigned int v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
      }
    }
  }

  else
  {
LABEL_29:
    *(void *)(a1 + 24) = v1;
    return 0LL;
  }

unint64_t lzbitmap_decode( uint64_t a1, unsigned int a2, _BYTE *a3, unsigned int a4, uint64_t a5, double a6, double a7, double a8, int32x4_t a9)
{
  if (a4 < 4) {
    return 0LL;
  }
  if (*a3 != 90) {
    return 0LL;
  }
  if (a3[1] != 66) {
    return 0LL;
  }
  if (a3[2] != 77) {
    return 0LL;
  }
  unsigned int v13 = a3[3];
  if (v13 > 0xF || (v13 & 3) - 2 < 2) {
    return 0LL;
  }
  int v18 = (v13 & 3) != 0 ? 0x8000 : 0x4000;
  unsigned int v214 = v18;
  int v19 = (v13 & 8) != 0 ? -3 : -4;
  unsigned int v20 = (v13 & 8) != 0 ? 3 : 4;
  if (!a2) {
    return 0LL;
  }
  uint64_t v21 = 0LL;
  unsigned int v199 = v13 & 4;
  unsigned int v200 = v20;
  unint64_t v197 = (int8x16_t *)(a5 + 4160);
  uint8x8_t v22 = (uint8x8_t)vdup_n_s8(v20);
  int v198 = 10 * (v19 + (v199 >> 2) + 15);
  int8x16_t v212 = 0u;
  unsigned int v23 = 4;
  __int128 v24 = xmmword_181096B10;
  LODWORD(v24) = -1;
  int32x4_t v201 = (int32x4_t)v24;
  int v211 = 1;
  int8x16_t v213 = 0u;
  while (1)
  {
    unsigned int v25 = v23 + 6;
    if (v23 + 6 > a4) {
      return 0LL;
    }
    unint64_t v26 = &a3[v23];
    uint64_t v27 = *v26 & 0xFFFFFF;
    unsigned int v28 = *(_DWORD *)((char *)v26 + 2);
    if ((_DWORD)v27 == 6 && v28 < 0x100) {
      break;
    }
    unsigned int v29 = v28 >> 8;
    unsigned int v30 = (v28 >> 8) + 6;
    unsigned int v33 = v29 + v21;
    if (v33 >= a2) {
      unint64_t v34 = a2;
    }
    else {
      unint64_t v34 = v33;
    }
    if (v30 == (_DWORD)v27)
    {
      size_t v35 = (v34 - v21);
      unsigned int v36 = (void *)(a1 + v21);
      unsigned int v37 = v23;
      int32x4_t v215 = v10;
      int32x4_t v218 = v9;
      memcpy(v36, &a3[v25], v35);
      int32x4_t v10 = v215;
      int32x4_t v9 = v218;
      unsigned int v23 = v27 + v37;
      goto LABEL_121;
    }

    v23 += v27;
    unint64_t v39 = *(unsigned int *)((char *)v26 + 5);
    unint64_t v40 = v39 >> 8;
    unint64_t v41 = (unint64_t)v26[2] >> 8;
    unint64_t v42 = (unint64_t)*(unsigned int *)((char *)v26 + 11) >> 8;
    unsigned int v43 = v27 - 17;
    unint64_t v44 = (v27 - 17 - v42);
    int v45 = 0;
    unint64_t v46 = (unint64_t)v26 + v27;
    unsigned int v47 = (v34 - v21 + 63) >> 3;
    unint64_t v48 = v47 & 0x1FFFFFF8;
    unsigned int v49 = v200;
    int8x16_t v50 = v212;
    int8x16_t v51 = v213;
    do
    {
      int8x16_t v228 = v50;
      *(_BYTE *)((unint64_t)&v228 | v45 & 0xF) = 0;
      int8x16_t v50 = v228;
      int8x16_t v227 = v51;
      *(_BYTE *)((unint64_t)&v227 | v45 & 0xF) = v45;
      int8x16_t v51 = v227;
      ++v45;
    }

    while (v200 != v45);
    unsigned int v52 = 0;
    do
    {
      int v53 = *(unsigned __int16 *)((char *)v26 + v43 + ((unint64_t)v52 >> 3)) >> (v52 & 6);
      int8x16_t v225 = v50;
      *(_BYTE *)((unint64_t)&v225 | v49 & 0xF) = v53;
      int8x16_t v50 = v225;
      int8x16_t v226 = v51;
      *(_BYTE *)((unint64_t)&v226 | v49 & 0xF) = BYTE1(v53) & 3;
      int8x16_t v51 = v226;
      v52 += 10;
      ++v49;
    }

    while (v198 != v52);
    int8x16_t v212 = v50;
    int8x16_t v213 = v226;
    unsigned int v208 = v23;
    unint64_t v209 = v47 & 0x1FFFFFF8;
    uint64_t v210 = (char *)v26 + v27;
    if (v199)
    {
      if (!(_DWORD)v48)
      {
LABEL_120:
        unint64_t v34 = v21;
        goto LABEL_121;
      }

      int32x4_t v216 = v10;
      int32x4_t v219 = v9;
      unint64_t v62 = 0LL;
      uint64_t v63 = (_DWORD *)((char *)v26 + v42);
      do
      {
        unsigned int v64 = *v63++;
        uint64x2_t v65 = (uint64x2_t)vdupq_n_s64(v64);
        int8x16_t v66 = vorrq_s8( vandq_s8((int8x16_t)vshlq_u64(v65, (uint64x2_t)xmmword_181096AB0), (int8x16_t)xmmword_181096AE0),  vandq_s8((int8x16_t)vshlq_u64(v65, (uint64x2_t)xmmword_181096AC0), (int8x16_t)xmmword_181096AD0));
        *(void *)(a5 + v62) = *(unint64_t *)&vorr_s8( *(int8x8_t *)v66.i8,  (int8x8_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL)) | v64 & 0xF | ((unint64_t)v64 << 24) & 0xF000000000000LL | ((((unint64_t)v64 >> 20) & 0xF) << 40) | ((unint64_t)v64 << 28) & 0xF00000000000000LL;
        v62 += 8LL;
      }

      while (v62 < v48);
    }

    else
    {
      unint64_t v206 = v41;
      unint64_t v54 = v40;
      int32x4_t v216 = v10;
      int32x4_t v219 = v9;
      v55.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v55.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      if (v43 != (_DWORD)v42)
      {
        unint64_t v56 = 0LL;
        uint64_t v57 = (char *)v26 + v42;
        unsigned int v58 = v197;
        do
        {
          int8x16_t v59 = *(int8x16_t *)&v57[v56];
          int8x16_t v60 = vandq_s8(v59, v55);
          int8x16_t v61 = (int8x16_t)vshrq_n_u8((uint8x16_t)v59, 4uLL);
          *unsigned int v58 = vzip1q_s8(v60, v61);
          v58[1] = vzip2q_s8(v60, v61);
          v58 += 2;
          v56 += 16LL;
        }

        while (v56 < v44);
      }

      lzbitmap_decode_rle(a5, v197, v47 & 0x1FFFFFF8);
      unint64_t v48 = v209;
      unint64_t v46 = (unint64_t)v210;
      unsigned int v23 = v208;
      unint64_t v40 = v54;
      unint64_t v41 = v206;
    }

    if ((_DWORD)v48)
    {
      unint64_t v67 = 0LL;
      uint64_t v68 = (int8x16_t *)((char *)v26 + 15);
      unint64_t v69 = (uint64_t *)((char *)v26 + v41);
      uint64_t v70 = (int8x16_t *)((char *)v26 + v40);
      int v71 = 8;
      v72.i64[0] = -1LL;
      v72.i64[1] = -1LL;
      int32x4_t v10 = v216;
      int32x4_t v9 = v219;
      while (1)
      {
        v73.i64[0] = *(void *)(a5 + v67);
        v73.i64[1] = -1LL;
        int8x16_t v74 = vqtbl1q_s8(v213, v73);
        *(uint8x8_t *)a9.i8 = vshl_u8(*(uint8x8_t *)v74.i8, (uint8x8_t)0x604020006040200LL);
        int32x4_t v75 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&a9 - 1), (int8x16_t)xmmword_181096AF0);
        LODWORD(v76) = vaddq_s32( vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v75.i8, 1), v75),  vaddq_s32(vdupq_laneq_s32(v75, 2), vdupq_laneq_s32(v75, 3))).u32[0];
        uint64_t v77 = (int8x16_t *)((char *)v70 + v76);
        int8x8_t v78 = (int8x8_t)vcgt_u8(v22, *(uint8x8_t *)(a5 + v67));
        v79.i64[1] = v212.i64[1];
        v79.i64[0] = *v69;
        int8x8_t v80 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vand_s8( v78,  (int8x8_t)0x8040201008040201LL))));
        *(int8x8_t *)&__int128 v11 = vorr_s8( vqtbl1_s8(v79, lzbitmap_unpack_perm_table[*(void *)&v80]),  vbic_s8((int8x8_t)*(_OWORD *)&vqtbl1q_s8(v212, v73), v78));
        int8x16_t v81 = *v70;
        v81.i32[3] = v71;
        int32x4_t v82 = (int32x4_t)vqtbl1q_s8(v81, lzbitmap_unpack_dist_perm_table[BYTE2(v76)]);
        int16x8_t v83 = vmovl_s8(vmvn_s8(vceq_s8(*(int8x8_t *)&v11, (int8x8_t)-1LL)));
        int32x4_t v84 = vdupq_n_s32(v21);
        int8x16_t v85 = (int8x16_t)vmovl_s16(*(int16x4_t *)v83.i8);
        a9 = vaddq_s32(v84, (int32x4_t)xmmword_181096B10);
        int8x16_t v86 = *v77;
        v86.i32[3] = v82.i32[3];
        int32x4_t v87 = (int32x4_t)vqtbl1q_s8(v86, lzbitmap_unpack_dist_perm_table[v76 >> 24]);
        int8x16_t v88 = (int8x16_t)vmovl_high_s16(v83);
        int32x4_t v89 = vaddq_s32(v84, (int32x4_t)xmmword_181096B00);
        int32x4_t v90 = (int32x4_t)vandq_s8(v88, (int8x16_t)vcgtq_u32((uint32x4_t)v87, (uint32x4_t)v89));
        v90.i32[0] = vmaxvq_u32((uint32x4_t)v90);
        int v91 = v90.i32[0];
        if (v90.i32[0] < 0) {
          return 0LL;
        }
        int8x16_t v92 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v90, v201), 0);
        int32x4_t v10 = (int32x4_t)vbslq_s8(v92, vandq_s8((int8x16_t)vsubq_s32(v89, v87), v88), (int8x16_t)v10);
        int32x4_t v9 = (int32x4_t)vbslq_s8(v92, vandq_s8((int8x16_t)vsubq_s32(a9, v82), v85), (int8x16_t)v9);
        v211 &= ~(v91 >> 31);
        if ((int)v21 + 64 > v34)
        {
          int v171 = 0;
          while ((unint64_t)&v68->u64[1] <= v46)
          {
            if (v21 < v34)
            {
              unint64_t v172 = 0LL;
              uint64_t v221 = v11;
              int v173 = *(unsigned __int8 *)((unint64_t)&v221 | v171 & 7);
              v222[0] = v9;
              v222[1] = v10;
              int v174 = *((_DWORD *)v222 + (v171 & 7));
              do
              {
                unint64_t v175 = v172;
                int v176 = 1 << v172;
                BOOL v177 = (v176 & v173) == 0;
                if ((v176 & v173) != 0) {
                  uint64_t v178 = v68;
                }
                else {
                  uint64_t v178 = (int8x16_t *)(a1 + (v174 + v175));
                }
                if (!v177) {
                  uint64_t v68 = (int8x16_t *)((char *)v68 + 1);
                }
                *(_BYTE *)(a1 + v21 + v175) = v178->i8[0];
                unint64_t v172 = v175 + 1;
              }

              while (v175 <= 6 && v172 + v21 < v34);
              uint64_t v21 = (v21 + v172);
            }

            if (++v171 == 8) {
              goto LABEL_120;
            }
          }

          return 0LL;
        }

        uint8x8_t v93 = (uint8x8_t)vcnt_s8((int8x8_t)(unsigned __int16)v11);
        v93.i16[0] = vaddlv_u8(v93);
        unsigned int v94 = (int8x16_t *)((char *)v68 + v93.u32[0]);
        uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)WORD1(v11));
        v95.i16[0] = vaddlv_u8(v95);
        int v96 = (int8x16_t *)((char *)v94 + v95.u32[0]);
        BOOL v97 = (unint64_t)&v94[1] > v46 || (unint64_t)&v96[1] > v46;
        uint8x8_t v98 = (uint8x8_t)vcnt_s8((int8x8_t)WORD2(v11));
        v98.i16[0] = vaddlv_u8(v98);
        int v99 = (int8x16_t *)((char *)v96 + v98.u32[0]);
        uint8x16_t v101 = (uint8x16_t)xmmword_181096B20;
        int16x8_t v102 = vdupq_lane_s16(*(int16x4_t *)&v11, 0);
        *(int8x8_t *)v103.i8 = vmovn_s16(v102);
        v103.u64[1] = (unint64_t)vuzp2_s8( *(int8x8_t *)v102.i8,  (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL));
        int8x16_t v104 = (int8x16_t)vshlq_u8(v103, (uint8x16_t)xmmword_181096B20);
        int8x16_t v105 = vcgtq_s8(v104, v72);
        int8x16_t v106 = vcntq_s8(v104);
        v106.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL),  vdup_lane_s8(*(int8x8_t *)v106.i8, 7));
        int8x16_t v107 = vorrq_s8(vaddq_s8(v106, v72), v105);
        int8x16_t v108 = vceqq_s8(v107, v72);
        int16x8_t v109 = vdupq_lane_s16(*(int16x4_t *)&v11, 1);
        *(int8x8_t *)v110.i8 = vmovn_s16(v109);
        v110.u64[1] = (unint64_t)vuzp2_s8( *(int8x8_t *)v109.i8,  (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL));
        int8x16_t v111 = (int8x16_t)vshlq_u8(v110, (uint8x16_t)xmmword_181096B20);
        int8x16_t v112 = vcntq_s8(v111);
        v112.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v112, v112, 8uLL),  vdup_lane_s8(*(int8x8_t *)v112.i8, 7));
        int32x4_t v113 = (int32x4_t)vorrq_s8(vaddq_s8(v112, v72), vcgtq_s8(v111, v72));
        int8x16_t v114 = vceqq_s8((int8x16_t)v113, v72);
        int8x16_t v115 = vqtbl1q_s8(*v68, v107);
        int8x16_t v116 = vqtbl1q_s8(*v94, (int8x16_t)v113);
        int8x16_t v117 = *v96;
        int8x16_t v118 = *v99;
        v113.i64[0] = 0x800000008LL;
        v113.i64[1] = 0x800000008LL;
        unint64_t v119 = vextq_s8(v116, v116, 8uLL).u64[0];
        unint64_t v120 = vextq_s8(v114, v114, 8uLL).u64[0];
        unint64_t v121 = vextq_s8(v115, v115, 8uLL).u64[0];
        unint64_t v122 = vextq_s8(v108, v108, 8uLL).u64[0];
        int32x4_t v217 = v10;
        int32x4_t v220 = v9;
        __int128 v207 = v11;
        int8x8_t v204 = v80;
        double v205 = v77;
        int v203 = v87.i32[3];
        uint64_t v202 = v99;
        if ((vminvq_u32(vcgeq_u32((uint32x4_t)v84, (uint32x4_t)vaddq_s32(v9, v113))) & 0x80000000) != 0)
        {
          v129.i64[0] = *(void *)(a1 + v9.u32[0]);
          v129.i64[1] = *(void *)(a1 + v9.u32[1]);
          int8x16_t v130 = vorrq_s8(vandq_s8(v108, v129), v115);
          v131.i64[0] = *(void *)(a1 + v9.u32[2]);
          v131.i64[1] = *(void *)(a1 + v9.u32[3]);
          int8x16_t v132 = vorrq_s8(vandq_s8(v114, v131), v116);
          int8x16_t __src = v130;
          int8x16_t v230 = v132;
          unsigned int v127 = v21 + 32;
          int v133 = (int8x16_t *)(a1 + v21);
          if ((int)v21 + 32 >= v34)
          {
            size_t v136 = (v34 - v21);
            unint64_t v137 = v67;
            uint64_t v138 = v69;
            uint64_t v194 = v116.i64[0];
            uint64_t v196 = v114.i64[0];
            unint64_t v190 = v120;
            unint64_t v192 = v119;
            unint64_t v186 = v122;
            unint64_t v188 = v121;
            int8x16_t v184 = v117;
            int8x16_t v182 = v118;
            memcpy(v133, &__src, v136);
            int8x16_t v118 = v182;
            int8x16_t v117 = v184;
            uint8x16_t v101 = (uint8x16_t)xmmword_181096B20;
            unint64_t v122 = v186;
            unint64_t v121 = v188;
            unint64_t v120 = v190;
            unint64_t v119 = v192;
            v116.i64[0] = v194;
            v114.i64[0] = v196;
            __int128 v11 = v207;
            unint64_t v69 = v138;
            unint64_t v67 = v137;
            unint64_t v48 = v209;
            unint64_t v46 = (unint64_t)v210;
            int32x4_t v10 = v217;
            int32x4_t v9 = v220;
            v72.i64[0] = -1LL;
            v72.i64[1] = -1LL;
            unsigned int v23 = v208;
            unsigned int v127 = v34;
          }

          else
          {
            *int v133 = v130;
            v133[1] = v132;
          }
        }

        else
        {
          int v123 = 0;
          while (1)
          {
            v224[0] = v9;
            v224[1] = v10;
            switch(v123)
            {
              case 0:
                int8x8_t v124 = *(int8x8_t *)v115.i8;
                int8x8_t v125 = *(int8x8_t *)v108.i8;
                break;
              case 1:
                int8x8_t v124 = (int8x8_t)v121;
                int8x8_t v125 = (int8x8_t)v122;
                break;
              case 2:
                int8x8_t v124 = *(int8x8_t *)v116.i8;
                int8x8_t v125 = *(int8x8_t *)v114.i8;
                break;
              case 3:
                int8x8_t v124 = (int8x8_t)v119;
                int8x8_t v125 = (int8x8_t)v120;
                break;
              default:
                int8x8_t v124 = 0LL;
                int8x8_t v125 = 0LL;
                break;
            }

            int8x8_t v126 = vorr_s8(vand_s8(v125, *(int8x8_t *)(a1 + *((unsigned int *)v224 + (v123 & 7)))), v124);
            *(int8x8_t *)__src.i8 = v126;
            unsigned int v127 = v21 + 8;
            int v128 = (int8x8_t *)(a1 + v21);
            *int v128 = v126;
            ++v123;
            LODWORD(v21) = v21 + 8;
            if (v123 == 4) {
              goto LABEL_87;
            }
          }

          size_t v134 = (v34 - v21);
          unint64_t v135 = v67;
          char v180 = BYTE1(v76);
          unsigned int v76 = v69;
          uint64_t v193 = v116.i64[0];
          uint64_t v195 = v114.i64[0];
          unint64_t v189 = v120;
          unint64_t v191 = v119;
          unint64_t v185 = v122;
          unint64_t v187 = v121;
          int8x16_t v183 = v117;
          int8x16_t v181 = v118;
          memcpy(v128, &__src, v134);
          int8x16_t v118 = v181;
          int8x16_t v117 = v183;
          uint8x16_t v101 = (uint8x16_t)xmmword_181096B20;
          unint64_t v122 = v185;
          unint64_t v121 = v187;
          unint64_t v120 = v189;
          unint64_t v119 = v191;
          v116.i64[0] = v193;
          v114.i64[0] = v195;
          __int128 v11 = v207;
          unint64_t v69 = v76;
          BYTE1(v76) = v180;
          unint64_t v67 = v135;
          unint64_t v48 = v209;
          unint64_t v46 = (unint64_t)v210;
          int32x4_t v10 = v217;
          int32x4_t v9 = v220;
          v72.i64[0] = -1LL;
          v72.i64[1] = -1LL;
          unsigned int v23 = v208;
          unsigned int v127 = v34;
        }

LABEL_87:
        int16x8_t v139 = vdupq_lane_s16(*(int16x4_t *)&v11, 3);
        *(int8x8_t *)v140.i8 = vmovn_s16(v139);
        v140.u64[1] = (unint64_t)vuzp2_s8( *(int8x8_t *)v139.i8,  (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v139, (int8x16_t)v139, 8uLL));
        int8x16_t v141 = (int8x16_t)vshlq_u8(v140, v101);
        int8x16_t v142 = vcgtq_s8(v141, v72);
        int8x16_t v143 = vcntq_s8(v141);
        v143.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v143, v143, 8uLL),  vdup_lane_s8(*(int8x8_t *)v143.i8, 7));
        int8x16_t v144 = vorrq_s8(vaddq_s8(v143, v72), v142);
        int16x8_t v145 = vdupq_lane_s16(*(int16x4_t *)&v11, 2);
        *(int8x8_t *)v142.i8 = vmovn_s16(v145);
        v142.u64[1] = (unint64_t)vuzp2_s8( *(int8x8_t *)v145.i8,  (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v145, (int8x16_t)v145, 8uLL));
        int8x16_t v146 = (int8x16_t)vshlq_u8((uint8x16_t)v142, v101);
        int8x16_t v147 = vcgtq_s8(v146, v72);
        int8x16_t v148 = vcntq_s8(v146);
        v148.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v148, v148, 8uLL),  vdup_lane_s8(*(int8x8_t *)v148.i8, 7));
        int8x16_t v149 = vorrq_s8(vaddq_s8(v148, v72), v147);
        int8x16_t v150 = vceqq_s8(v149, v72);
        int8x16_t v151 = vqtbl1q_s8(v117, v149);
        int8x16_t v152 = vqtbl1q_s8(v118, v144);
        a9 = (int32x4_t)vceqq_s8(v144, v72);
        v153.i64[0] = 0x800000008LL;
        v153.i64[1] = 0x800000008LL;
        v163.i64[0] = *(void *)(a1 + v10.u32[0]);
        v163.i64[1] = *(void *)(a1 + v10.u32[1]);
        v164.i64[0] = *(void *)(a1 + v10.u32[2]);
        v164.i64[1] = *(void *)(a1 + v10.u32[3]);
        a9 = (int32x4_t)vandq_s8((int8x16_t)a9, v164);
        int8x16_t v165 = vorrq_s8(vandq_s8(v150, v163), v151);
        int8x16_t v166 = vorrq_s8((int8x16_t)a9, v152);
        int8x16_t __src = v165;
        int8x16_t v230 = v166;
        uint64_t v21 = v127 + 32;
        BOOL v162 = (int8x16_t *)(a1 + v127);
        *BOOL v162 = v165;
        v162[1] = v166;
LABEL_104:
        uint8x8_t v169 = (uint8x8_t)vcnt_s8(v204);
        v169.i16[0] = vaddlv_u8(v169);
        unint64_t v69 = (uint64_t *)((char *)v69 + v169.u32[0]);
        uint64_t v70 = (int8x16_t *)((char *)v205 + BYTE1(v76));
        int v71 = v203;
        uint8x8_t v170 = (uint8x8_t)vcnt_s8((int8x8_t)WORD3(v11));
        v170.i16[0] = vaddlv_u8(v170);
        uint64_t v68 = (int8x16_t *)((char *)v202 + v170.u32[0]);
        v67 += 8LL;
        if (v67 >= v48) {
          goto LABEL_120;
        }
      }

      unint64_t v154 = vextq_s8(v152, v152, 8uLL).u64[0];
      unint64_t v155 = vextq_s8((int8x16_t)a9, (int8x16_t)a9, 8uLL).u64[0];
      unint64_t v156 = vextq_s8(v151, v151, 8uLL).u64[0];
      int v157 = 4;
      unint64_t v158 = vextq_s8(v150, v150, 8uLL).u64[0];
      while (1)
      {
        v223[0] = v9;
        v223[1] = v10;
        switch(v157)
        {
          case 1:
            int8x8_t v159 = (int8x8_t)v121;
            int8x8_t v160 = (int8x8_t)v122;
            break;
          case 2:
            int8x8_t v159 = *(int8x8_t *)v116.i8;
            int8x8_t v160 = *(int8x8_t *)v114.i8;
            break;
          case 3:
            int8x8_t v159 = (int8x8_t)v119;
            int8x8_t v160 = (int8x8_t)v120;
            break;
          case 4:
            int8x8_t v159 = *(int8x8_t *)v151.i8;
            int8x8_t v160 = *(int8x8_t *)v150.i8;
            break;
          case 5:
            int8x8_t v159 = (int8x8_t)v156;
            int8x8_t v160 = (int8x8_t)v158;
            break;
          case 6:
            int8x8_t v159 = *(int8x8_t *)v152.i8;
            int8x8_t v160 = *(int8x8_t *)a9.i8;
            break;
          case 7:
            int8x8_t v159 = (int8x8_t)v154;
            int8x8_t v160 = (int8x8_t)v155;
            break;
          default:
            int8x8_t v159 = 0LL;
            int8x8_t v160 = 0LL;
            break;
        }

        int8x8_t v161 = vorr_s8(vand_s8(v160, *(int8x8_t *)(a1 + *((unsigned int *)v223 + (v157 & 7)))), v159);
        *(int8x8_t *)__src.i8 = v161;
        uint64_t v21 = v127 + 8;
        BOOL v162 = (int8x16_t *)(a1 + v127);
        *(int8x8_t *)v162->i8 = v161;
        ++v157;
        v127 += 8;
        if (v157 == 8) {
          goto LABEL_104;
        }
      }

    int v18 = v13;
    goto LABEL_118;
  }

  if (a6) {
    return 0LL;
  }
  int v203 = 0u;
  int8x8_t v204 = 0u;
  int32x4_t v201 = 0u;
  uint64_t v202 = 0u;
  unsigned int v199 = 0u;
  unsigned int v200 = 0u;
  unint64_t v197 = 0u;
  int v198 = 0u;
  unint64_t v209 = 0u;
  uint64_t v210 = 0u;
  if ((v13 | 0x90) > a4) {
    goto LABEL_87;
  }
  uint64_t v16 = 8LL;
  unint64_t v17 = vdupq_n_s32(0x9E3779B1);
  int v18 = v13;
  while ((unint64_t)(v14 + 164) <= v193)
  {
    int v19 = 0;
    unsigned int v20 = 0LL;
    uint64_t v21 = 0;
    uint8x8_t v22 = 0;
    unsigned int v23 = 0;
    __int128 v24 = (int32x4_t *)&__src[v18];
    unsigned int v25 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[1], v17), 0x13uLL);
    int v211 = vshrq_n_u32((uint32x4_t)vmulq_s32(*v24, v17), 0x13uLL);
    int8x16_t v212 = v25;
    unint64_t v26 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[3], v17), 0x13uLL);
    int8x16_t v213 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[2], v17), 0x13uLL);
    unsigned int v214 = v26;
    uint64_t v27 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[5], v17), 0x13uLL);
    int32x4_t v215 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[4], v17), 0x13uLL);
    int32x4_t v216 = v27;
    unsigned int v28 = (int8x16_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v24[6], v17), 0x13uLL);
    unsigned int v29 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[7], v17), 0x13uLL);
    int32x4_t v217 = v28;
    int32x4_t v218 = v29;
    *(_DWORD *)int v14 = 0;
    unsigned int v30 = v16;
    uint64_t v31 = v16;
    do
    {
      unsigned int v32 = v18;
      unsigned int v33 = (int8x8_t *)&__src[v18];
      *(int8x8_t *)v28.i8 = *v33;
      unint64_t v34 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v33 - (unsigned __int16)v31),  *v33)))));
      if (v34.i8[0])
      {
        size_t v35 = v34.i8[0];
        v34.i32[0] = v34.u8[0];
        unsigned int v36 = (uint8x8_t)vcnt_s8(v34);
        v36.i16[0] = vaddlv_u8(v36);
        unsigned int v37 = v36.i8[0];
        if (v36.i32[0] != 1)
        {
          int8x16_t v38 = 0LL;
          unint64_t v39 = (unsigned int *)&v211 + 2 * v20;
          unint64_t v40 = *v39;
          unint64_t v41 = v39[1];
          uint64_t v194 = v32 - *((_WORD *)a5 + v40);
          uint64_t v195 = v32 + 4 - *((_WORD *)a5 + v41);
          *((_WORD *)a5 + v41) = v32 + 4;
          *((_WORD *)a5 + v40) = v32;
          unint64_t v42 = 1;
          LODWORD(v43) = v31;
          do
          {
            unint64_t v44 = v42;
            int v45 = (unsigned __int16)*(&v194 + v38);
            unint64_t v46 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v33 - v45),  *(int8x8_t *)v28.i8)))));
            unsigned int v47 = v46.u8[0] | ((v45 - 8) >> 24);
            if (!(v46.i8[0] | ((v45 - 8) >> 24)))
            {
              v19 |= 0x10000 << v20;
              *(_DWORD *)int v14 = v19;
              *((_WORD *)&v209 + v21++) = v45;
              uint64_t v31 = v45;
              goto LABEL_35;
            }

            v46.i32[0] = v46.i8[0] | ((v45 - 8) >> 24);
            unint64_t v48 = (uint8x8_t)vcnt_s8(v46);
            v48.i16[0] = vaddlv_u8(v48);
            unsigned int v49 = v48.i8[0] + 2;
            if (((v48.i32[0] + 2 < v37) & ~v42) != 0)
            {
              unsigned int v43 = v45;
              size_t v35 = v47;
              goto LABEL_33;
            }

            unint64_t v42 = 0;
            else {
              unsigned int v43 = v43;
            }
            int8x16_t v38 = 1LL;
          }

          while ((v44 & 1) != 0);
LABEL_33:
          *(_DWORD *)int v14 = (0x10000 << v20) | v19;
          *((_WORD *)&v209 + v21++) = v43;
          uint64_t v31 = v43;
        }

LABEL_103:
      unint64_t v167 = v67;
      BOOL v168 = v69;
      memcpy(v162, &__src, v34 - v127);
      __int128 v11 = v207;
      unint64_t v69 = v168;
      unint64_t v67 = v167;
      unint64_t v48 = v209;
      unint64_t v46 = (unint64_t)v210;
      int32x4_t v10 = v217;
      int32x4_t v9 = v220;
      v72.i64[0] = -1LL;
      v72.i64[1] = -1LL;
      unsigned int v23 = v208;
      uint64_t v21 = v34;
      goto LABEL_104;
    }

    unint64_t v34 = v21;
    int32x4_t v10 = v216;
    int32x4_t v9 = v219;
LABEL_121:
    uint64_t v21 = v34;
  }

  unint64_t v34 = v21;
LABEL_124:
  if (!v211) {
    return 0LL;
  }
  return v34;
}

uint64_t BrotliDecoderStateInit( uint64_t a1, void *(*a2)(int a1, size_t __size), void (*a3)(int a1, void *a2), uint64_t a4)
{
  uint64_t v5 = BrotliDefaultAllocFunc;
  if (a2) {
    uint64_t v5 = a2;
  }
  unint64_t v6 = BrotliDefaultFreeFunc;
  if (a2) {
    unint64_t v6 = a3;
  }
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = v6;
  if (a2) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = 0LL;
  }
  *(void *)(a1 + 56) = v7;
  *(_DWORD *)(a1 + 116) = 0;
  BrotliInitBitReader(a1 + 8);
  __int16 v8 = *(_WORD *)(a1 + 664);
  *(void *)a1 = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 336) = 0LL;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_WORD *)(a1 + 664) = v8 & 0xFFC0 | 0x10;
  *(void *)(a1 + 668) = 0LL;
  *(_OWORD *)(a1 + 100) = xmmword_181096B50;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(_DWORD *)(a1 + 84) = 0;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 248) = 0LL;
  *(_DWORD *)(a1 + 384) = 63;
  *(void *)(a1 + 696) = BrotliGetDictionary();
  *(void *)(a1 + 704) = BrotliGetTransforms();
  return 1LL;
}

double BrotliDecoderStateMetablockBegin(uint64_t a1)
{
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = xmmword_181096B60;
  *(_OWORD *)(a1 + 288) = xmmword_181096B70;
  *(_OWORD *)(a1 + 304) = xmmword_181096B80;
  double result = 0.0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0LL;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_BYTE *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 680) = 0u;
  return result;
}

uint64_t BrotliDecoderStateCleanupAfterMetablock(uint64_t a1)
{
  *(void *)(a1 + 688) = 0LL;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 680));
  *(void *)(a1 + 680) = 0LL;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 336));
  *(void *)(a1 + 336) = 0LL;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 168));
  *(void *)(a1 + 168) = 0LL;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 192));
  *(void *)(a1 + 192) = 0LL;
  uint64_t result = (*(uint64_t (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 216));
  *(void *)(a1 + 216) = 0LL;
  return result;
}

uint64_t BrotliDecoderStateCleanup(uint64_t a1)
{
  *(void *)(a1 + 120) = 0LL;
  uint64_t result = (*(uint64_t (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 240));
  *(void *)(a1 + 240) = 0LL;
  return result;
}

BOOL BrotliDecoderHuffmanTreeGroupInit(uint64_t a1, uint64_t a2, __int16 a3, int a4, unsigned int a5)
{
  __int16 v6 = a4;
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(a1 + 40))( *(void *)(a1 + 56),  (4LL * (a4 + 376) + 8) * a5);
  *(_WORD *)(a2 + 16) = a3;
  *(_WORD *)(a2 + 18) = v6;
  *(_WORD *)(a2 + 20) = a5;
  *(void *)a2 = v9;
  *(void *)(a2 + 8) = v9 + 8LL * a5;
  return v9 != 0;
}

uint64_t smb_lznt1_decode_buffer(char *__dst, unint64_t a2, char *__src, uint64_t a4)
{
  unint64_t v5 = a2;
  __int16 v6 = __dst;
  uint64_t v7 = 0LL;
  uint64_t v8 = 15LL;
  if (a2 > 0xF) {
    uint64_t v8 = a2;
  }
  uint64_t v9 = &__dst[v8 - 15];
  if (a4)
  {
    while (a4 != 1)
    {
      int v12 = *(unsigned __int16 *)__src;
      __int128 v11 = __src + 2;
      __int16 v10 = v12;
      if (!v12) {
        return v7;
      }
      if ((v10 & 0x7000) != 0x3000 || (v7 & 0xFFF) != 0) {
        break;
      }
      uint64_t v14 = a4 - 2;
      unint64_t v15 = (v10 & 0xFFF) + 1LL;
      if (a4 - 2 < v15) {
        break;
      }
      if (v10 < 0)
      {
        unint64_t v16 = 0LL;
        unint64_t v17 = 0LL;
        do
        {
          unsigned int v18 = v11[v17];
          unint64_t v19 = v17 + 9;
          ++v17;
          if (v18) {
            BOOL v20 = 1;
          }
          else {
            BOOL v20 = v19 > v15;
          }
          if (v20 || v16 + 8 > v5)
          {
            if (v17 < v15)
            {
              unsigned int v22 = 1;
              while (1)
              {
                if ((v18 & 1) != 0)
                {
                  unint64_t v24 = v17 + 2;
                  if (v17 + 2 > v15) {
                    return 0LL;
                  }
                  unsigned int v25 = *(unsigned __int16 *)&v11[v17];
                  unsigned int v26 = __clz(((_WORD)v16 - 1) & 0xFFF | 8) - 16;
                  unsigned int v27 = v25 >> v26;
                  unint64_t v28 = (v25 >> v26) + 1;
                  if (v16 < v28) {
                    return 0LL;
                  }
                  unint64_t v29 = (v25 & ~(-1 << v26)) + 3;
                  unsigned int v30 = &v6[v16];
                  uint64_t v31 = &v6[v16 + v29];
                  if (v27 < 0xF || v31 > v9)
                  {
                    if (v5 - v16 < v29) {
                      return 0LL;
                    }
                    uint64_t v33 = -(uint64_t)v28;
                    do
                    {
                      *unsigned int v30 = v30[v33];
                      ++v30;
                    }

                    while (v30 < v31);
                  }

                  else
                  {
                    uint64_t v32 = -(uint64_t)v28;
                    do
                    {
                      *(_OWORD *)unsigned int v30 = *(_OWORD *)&v30[v32];
                      v30 += 16;
                    }

                    while (v30 < v31);
                  }

                  v16 += v29;
                  unint64_t v17 = v24;
                }

                else
                {
                  if (v5 <= v16) {
                    return 0LL;
                  }
                  char v23 = v11[v17++];
                  v6[v16++] = v23;
                }

                if (v22 <= 7)
                {
                  v18 >>= 1;
                  ++v22;
                  if (v17 < v15) {
                    continue;
                  }
                }

                break;
              }
            }
          }

          else
          {
            *(void *)&v6[v16] = *(void *)&v11[v17];
            unint64_t v17 = v19;
            v16 += 8LL;
          }
        }

        while (v17 < v15);
      }

      else
      {
        if (v5 < v15) {
          return 0LL;
        }
        memcpy(v6, v11, (v10 & 0xFFF) + 1LL);
        unint64_t v16 = v15;
        unint64_t v17 = v15;
      }

      v6 += v16;
      v5 -= v16;
      int8x16_t __src = &v11[v17];
      a4 = v14 - v17;
      v7 += v16;
      if (v14 == v17) {
        return v7;
      }
    }

    return 0LL;
  }

  return v7;
}

uint64_t smb_lznt1_encode_buffer(_WORD *a1, unint64_t a2, _BYTE *a3, unint64_t a4, void *a5)
{
  uint64_t v10 = 0LL;
  if (!a4) {
    goto LABEL_63;
  }
  do
  {
    if (a4 >= 0x1000) {
      size_t v11 = 4096LL;
    }
    else {
      size_t v11 = a4;
    }
    unsigned int v12 = v11 + 7;
    if (a4 < v11 + 7) {
      unsigned int v12 = a4;
    }
    if (v12 <= 7) {
      unsigned int v12 = 7;
    }
    if (a2 < 3) {
      return 0LL;
    }
    unsigned int v13 = 0;
    unint64_t v14 = v12 - 7;
    unsigned int v15 = 2;
    unsigned int v16 = 0x10000;
    unsigned int v17 = 3;
    while (a2 >= v17 + 3)
    {
      if (v16 <= 0x1FF)
      {
        *((_BYTE *)a1 + v15) = v16;
        unsigned int v15 = v17++;
        unsigned int v16 = 0x10000;
      }

      v16 >>= 1;
      if (a4 < v13 + 4)
      {
        char v18 = a3[v13++];
        *((_BYTE *)a1 + v17++) = v18;
        goto LABEL_54;
      }

      unint64_t v19 = &a3[v13];
      unsigned int v20 = *(_DWORD *)v19;
      int v21 = *(_DWORD *)v19 >> 8;
      unsigned int v22 = (-1640531535 * (*(_DWORD *)v19 & 0xFFFFFFu)) >> 19;
      uint64_t v23 = (-1640531535 * v21) >> 19;
      unsigned int v24 = *((_DWORD *)a5 + v22);
      unsigned int v25 = *((_DWORD *)a5 + v23);
      uint64_t v26 = v24 & 0xFFF;
      int v27 = *(_DWORD *)v19 & 0xFFFFF;
      *((_DWORD *)a5 + v22) = v13 + (*(_DWORD *)v19 << 12);
      if (v27 != v24 >> 12 || v26 >= v13 || v13 >= v14)
      {
        LODWORD(v30) = 0;
      }

      else
      {
        unint64_t v30 = 0LL;
        unsigned int v31 = 0;
        while (1)
        {
          unint64_t v30 = *(void *)&a3[v26 + v30] ^ *(void *)&v19[v30];
          if (v30) {
            break;
          }
          v31 += 8;
          unint64_t v30 = v31;
        }

        LODWORD(v30) = v31 + (__clz(__rbit64(v30)) >> 3);
      }

LABEL_29:
      if (((v20 >> 8) & 0xFFFFF) != v25 >> 12) {
        goto LABEL_47;
      }
      uint64_t v32 = v25 & 0xFFF;
      uint64_t v33 = v13 + 1;
      if (v33 >= v14)
      {
        LODWORD(v34) = 0;
LABEL_37:
        if ((_DWORD)v32)
        {
LABEL_40:
          int v36 = v32 - 1;
          if (*v19 == a3[v36] && v30 <= v34)
          {
            LODWORD(v30) = v34 + 1;
            LOWORD(v26) = v36;
LABEL_47:
            if (v30 > 2)
            {
              *((_DWORD *)a5 + v23) = v13 + 1 + (v21 << 12);
              unsigned int v38 = __clz(((_WORD)v13 - 1) & 0xFFF | 8) - 16;
              unsigned int v39 = (1 << v38) + 2;
              *(_WORD *)((char *)a1 + v17) = (((_WORD)v13 + ~(_WORD)v26) << v38) - 3 + v39;
              v17 += 2;
              v13 += v39;
              v16 |= 0x80u;
            }

            else
            {
              *((_BYTE *)a1 + v17++) = *v19;
              ++v13;
            }

            goto LABEL_54;
          }
        }
      }

      else
      {
        unint64_t v34 = 0LL;
        unsigned int v35 = 0;
        while (1)
        {
          unint64_t v34 = *(void *)&a3[v32 + v34] ^ *(void *)&a3[v33 + v34];
          if (v34) {
            break;
          }
          v35 += 8;
          unint64_t v34 = v35;
        }

        LODWORD(v34) = v35 + (__clz(__rbit64(v34)) >> 3);
        if ((_DWORD)v32) {
          goto LABEL_40;
        }
      }

      *((_BYTE *)a1 + v17++) = *v19;
      ++v13;
LABEL_54:
    }

    unsigned int v17 = -1;
    do
    {
LABEL_57:
      unsigned int v40 = v16;
      v16 >>= 1;
    }

    while (v40 > 0x1FF);
    *((_BYTE *)a1 + v15) = v40;
    uint64_t v41 = (v11 + 2);
    if (v17 < v41)
    {
      *a1 = (v17 + 32765) | 0xB000;
      uint64_t v41 = v17;
      goto LABEL_62;
    }

    *a1 = (v11 - 1) | 0x3000;
    memcpy(a1 + 1, a3, v11);
LABEL_62:
    a3 += v11;
    a1 = (_WORD *)((char *)a1 + v41);
    a2 -= v41;
    v10 += v41;
    a4 -= v11;
  }

  while (a4);
LABEL_63:
  if (a2 >= 2)
  {
    *a1 = 0;
    v10 += 2LL;
  }

  return v10;
}

uLong adler32(uLong adler, const Bytef *buf, uInt len)
{
  unint64_t v5 = WORD1(adler);
  adler = (unsigned __int16)adler;
  if (len == 1)
  {
    unint64_t v6 = (unsigned __int16)adler + (unint64_t)*buf;
    if (v6 > 0xFFF0) {
      v6 -= 65521LL;
    }
    if (v6 + v5 <= 0xFFF0) {
      uint64_t v7 = (v6 + v5) << 16;
    }
    else {
      uint64_t v7 = ((v6 + v5) << 16) - 4293984256u;
    }
    return v7 | v6;
  }

  else if (buf)
  {
    if ((int)len >= 16)
    {
      if ((buf & 0xF) != 0)
      {
        size_t v11 = buf + 1;
        unsigned int v12 = buf;
        do
        {
          --len;
          unsigned int v13 = *v12++;
          uLong v14 = adler + v13;
          if (v14 <= 0xFFF0) {
            adler = v14;
          }
          else {
            adler = v14 - 65521;
          }
          unint64_t v5 = (v14 + v5) % 0xFFF1;
        }

        while ((v11++ & 0xF) != 0LL);
        buf = &buf[-(buf & 0xF) + 16];
      }

      return adler32_vec(adler, v5, (uint8x16_t *)buf, len);
    }

    else
    {
      for (; len; --len)
      {
        unsigned int v9 = *buf++;
        adler += v9;
        v5 += adler;
      }

      uLong v10 = adler - 65521;
      if (adler <= 0xFFF0) {
        uLong v10 = adler;
      }
      return v10 | ((v5 % 0xFFF1) << 16);
    }
  }

  else
  {
    return 1LL;
  }

unint64_t get_max_payload_size(int a1, int a2, int a3, int a4, int a5)
{
  return (a2 * a1 * get_format_components(a3, a5) * (unint64_t)(a4 + 2) + 1024) >> 3;
}

uint64_t get_plane_max_rice_size(int a1)
{
  return (666 * a1 + 9580) >> 3;
}

uint64_t get_slice_width(unsigned __int16 *a1, int a2)
{
  unsigned int v2 = a1[2] + a2;
  if (v2 >= *a1) {
    unsigned int v2 = *a1;
  }
  return v2 - a2;
}

uint64_t get_slice_height(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 6) + a2;
  return v2 - a2;
}

uint64_t get_pool_size(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 17);
  if (*(_BYTE *)(a1 + 17))
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = a1 + 18;
    uint64_t v37 = a1 + 18;
    do
    {
      unint64_t v9 = v4;
      uLong v10 = (unsigned __int16 *)(v8 + 10 * v4);
      uint64_t v11 = v8;
      unsigned int v13 = v10 + 1;
      unsigned __int16 v12 = v10[1];
      if (v12)
      {
        unsigned int v14 = 0;
        uint64_t v41 = v10;
        unint64_t v42 = v9;
        uint64_t v15 = v11 + 10 * v9;
        unsigned int v16 = (unsigned __int16 *)(v15 + 4);
        unsigned int v17 = (unsigned __int16 *)(v15 + 6);
        char v18 = (unsigned __int8 *)(v15 + 8);
        unsigned int v19 = *v10;
        unsigned int v39 = v18;
        unsigned int v40 = v17;
        unsigned int v38 = v10 + 1;
        do
        {
          if (v19)
          {
            unsigned int v20 = 0;
            int v21 = *v16;
            do
            {
              uint64_t v43 = v7;
              uint64_t v44 = v5;
              unsigned int v22 = v20 + v21;
              if (v22 < v19) {
                unsigned int v19 = v22;
              }
              uint64_t v23 = v19 - v20;
              unsigned int v24 = v14 + *v17;
              if (v24 >= *v13) {
                unsigned int v24 = *v13;
              }
              uint64_t v25 = v24 - v14;
              int v26 = *v18;
              unint64_t v27 = (v26 + 2)
                  * (unint64_t)((_DWORD)v25
                                     * (_DWORD)v23
              int v28 = *(unsigned __int8 *)(a1 + 16);
              unsigned int format_components = get_format_components(v28, v42);
              v6 += yzip_plane_encoder_allocate(v45, v23, v25, format_components, v28, 0LL) + (v27 >> 3) + 16;
              LODWORD(v25) = *(unsigned __int8 *)(a1 + 16);
              unsigned int v30 = get_format_components(v25, v42);
              unint64_t v31 = yzip_plane_decoder_allocate(v45, v23, v30, v25, 0LL);
              unsigned int v13 = v38;
              char v18 = v39;
              uint64_t v32 = v43 + v31;
              unsigned int v17 = v40;
              uint64_t v7 = v32 + 16;
              int v21 = *v16;
              v20 += v21;
              uint64_t v5 = v44 + 1;
              unsigned int v19 = *v41;
            }

            while (v20 < v19);
            unsigned __int16 v12 = *v38;
          }

          v14 += *v17;
        }

        while (v14 < v12);
        unsigned int v2 = *(unsigned __int8 *)(a1 + 17);
        uint64_t v8 = v37;
        unint64_t v33 = v42;
      }

      else
      {
        uint64_t v8 = v11;
        unint64_t v33 = v9;
      }

      unint64_t v4 = v33 + 1;
    }

    while (v4 < v2);
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v34 = v6 + 32 * v5;
  if (!a2) {
    uint64_t v34 = v7 + 16 * v5;
  }
  return 160 * v5 + 2664LL * v2 + v34 + 80;
}

uint64_t yzip_jobs_worker_entry(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 152);
  switch(v3)
  {
    case 2:
      uint64_t v4 = yzip_plane_decoder(a2);
LABEL_7:
      *(void *)(a2 + 144) = v4;
      return 0LL;
    case 1:
      uint64_t v4 = yzip_plane_encoder_phase2(a2);
      goto LABEL_7;
    case 0:
      *(void *)(a2 + 144) = (int)yzip_plane_encoder_phase1(a2);
      *(_DWORD *)(a2 + 152) = 1;
      break;
  }

  return 0LL;
}

unint64_t yzip_jobs_create_encoder_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t empty_list = yzip_jobs_create_empty_list(a1, a3);
  unsigned int v5 = *(unsigned __int8 *)(a3 + 17);
  if (*(_BYTE *)(a3 + 17))
  {
    unint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(empty_list + 16);
    uint64_t v8 = a3 + 18;
    do
    {
      unint64_t v9 = (unsigned __int16 *)(v8 + 10 * v6);
      unsigned __int16 v10 = v9[1];
      unsigned int v39 = v9 + 1;
      if (v10)
      {
        unsigned int v11 = 0;
        uint64_t v12 = a2 + 32 * v6;
        int v36 = (void *)(v12 + 24);
        uint64_t v37 = (uint64_t *)(v12 + 16);
        unint64_t v13 = v8 + 10 * v6;
        unsigned int v38 = (unsigned __int16 *)(v13 + 4);
        unsigned int v40 = (unsigned __int16 *)(v13 + 6);
        unsigned int v35 = (unsigned __int8 *)(v13 + 8);
        unsigned int v14 = *v9;
        do
        {
          if (v14)
          {
            unsigned int v15 = 0;
            int v16 = *v38;
            do
            {
              *(_DWORD *)(v7 + 152) = 0;
              *(void *)(v7 + 24) = a3;
              *(void *)(v7 + 32) = v9;
              unsigned int v17 = v9;
              *(void *)(v7 + 8) = *v36;
              unsigned int v18 = v15 + v16;
              if (v18 < v14) {
                unsigned int v14 = v18;
              }
              *(_DWORD *)(v7 + 16) = v14 - v15;
              unsigned int v19 = v11 + *v40;
              if (v19 >= *v39) {
                unsigned int v19 = *v39;
              }
              *(_DWORD *)(v7 + 20) = v19 - v11;
              uint64_t v20 = *v37;
              *(void *)uint64_t v7 = v20
                            + get_format_bytes_per_pixel(*(unsigned __int8 *)(a3 + 16), *v35, v6) * v15
                            + *(void *)(v7 + 8) * v11;
              LODWORD(v20) = *v35;
              int v21 = *(_DWORD *)(v7 + 20) * *(_DWORD *)(v7 + 16);
              size_t v22 = ((v20 + 2)
              *(void *)(v7 + 144) = v22;
              unint64_t v23 = *(void *)(a1 + 16);
              unint64_t v24 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
              *(void *)(a1 + 8) = v24 + v22;
              if (v24 + v22 > v23) {
                unint64_t v24 = (unint64_t)malloc(v22);
              }
              *(void *)(v7 + 104) = v24;
              uint64_t v25 = *(unsigned int *)(v7 + 16);
              uint64_t v26 = *(unsigned int *)(v7 + 20);
              int v27 = *(unsigned __int8 *)(a3 + 16);
              unsigned int format_components = get_format_components(v27, v6);
              size_t v29 = yzip_plane_encoder_allocate(v41, v25, v26, format_components, v27, 0LL) + 16;
              unint64_t v30 = *(void *)(a1 + 16);
              unint64_t v31 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
              *(void *)(a1 + 8) = v31 + v29;
              if (v31 + v29 > v30) {
                unint64_t v31 = (unint64_t)malloc(v29);
              }
              *(void *)(v7 + 96) = v31;
              int v16 = *v38;
              v15 += v16;
              v7 += 160LL;
              unint64_t v9 = v17;
              unsigned int v14 = *v17;
            }

            while (v15 < v14);
            unsigned __int16 v10 = *v39;
          }

          v11 += *v40;
        }

        while (v11 < v10);
        unsigned int v5 = *(unsigned __int8 *)(a3 + 17);
        uint64_t v8 = a3 + 18;
      }

      ++v6;
    }

    while (v6 < v5);
  }

  return empty_list;
}

unint64_t yzip_jobs_create_empty_list(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  *(void *)(a1 + 8) = v5 + 32;
  if (v5 + 32 > v4) {
    unint64_t v5 = (unint64_t)malloc(0x20uLL);
  }
  *(_OWORD *)unint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  uint64_t v6 = *(unsigned __int8 *)(a2 + 17);
  if (*(_BYTE *)(a2 + 17))
  {
    unsigned int v7 = 0;
    uint64_t v8 = (unsigned __int16 *)(a2 + 24);
    do
    {
      int v9 = (*(v8 - 3) + *(v8 - 1) - 1) / *(v8 - 1);
      int v10 = *(v8 - 2);
      int v11 = *v8;
      v8 += 5;
      v7 += (v10 + v11 - 1) / v11 * v9;
      --v6;
    }

    while (v6);
  }

  else
  {
    unsigned int v7 = 0;
  }

  *(_DWORD *)(v5 + 24) = v7;
  *(void *)unint64_t v5 = a2;
  unsigned int v12 = *(unsigned __int8 *)(a2 + 17);
  unint64_t v13 = *(void *)(a1 + 16);
  unint64_t v14 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v15 = v14 + 2664LL * v12;
  if (v15 > v13) {
    unint64_t v14 = (unint64_t)malloc(2664LL * v12);
  }
  *(void *)(v5 + 8) = v14;
  unint64_t v16 = (v15 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v17 = v16 + 160LL * v7;
  *(void *)(a1 + 8) = v17;
  if (v17 > v13) {
    unint64_t v16 = (unint64_t)malloc(160LL * v7);
  }
  *(void *)(v5 + 16) = v16;
  return v5;
}

unint64_t yzip_jobs_create_decoder_list(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v7 = a3;
  unint64_t result = yzip_jobs_create_empty_list(a1, a3);
  uint64_t v10 = *(unsigned __int16 *)(v7 + 6);
  if (v10 > a5) {
    return 0LL;
  }
  if (*(_BYTE *)(v7 + 17))
  {
    unint64_t v11 = 0LL;
    unsigned int v12 = 0;
    unint64_t v13 = 0LL;
    unint64_t v80 = (unint64_t)&a4[a5];
    int16x8_t v83 = &a4[v10];
    unint64_t v14 = &a4[v10 & 0xFFFC];
    unint64_t v84 = result;
    uint64_t v85 = v7;
    do
    {
      unint64_t v15 = (char *)(*(void *)(result + 8) + 2664 * v11);
      unsigned int v16 = *(unsigned __int8 *)(v7 + 10 * v11 + 26);
      bzero(v15, 0xA68uLL);
      unint64_t v17 = 0LL;
      unsigned int v18 = 0;
      if (v16 <= 8) {
        char v19 = 7;
      }
      else {
        char v19 = 15;
      }
      do
      {
        if (v12 <= 0x20)
        {
          if (a4 >= v14)
          {
            uint64_t v20 = 0LL;
          }

          else
          {
            unsigned int v21 = *(_DWORD *)a4;
            a4 += 4;
            uint64_t v20 = v21;
          }

          v13 += v20 << v12;
          v12 += 32;
        }

        char v22 = v13;
        unsigned int v23 = v12 - 1;
        v13 >>= 1;
        if ((v22 & 1) != 0)
        {
          if (v17 <= 0xA) {
            int v24 = -1;
          }
          else {
            int v24 = -11;
          }
          int v25 = v24 + v17;
          if (v25 < 0)
          {
            int v27 = 0;
            char v28 = 0;
          }

          else
          {
            uint64_t v26 = &v15[4 * v25];
            int v27 = *(__int16 *)v26;
            char v28 = v26[2];
          }

          int v29 = 0;
          for (unsigned int i = v18 - 1; ; ++i)
          {
            if (v23 > 0x20)
            {
              unsigned int v33 = v23;
            }

            else
            {
              if (a4 >= v14)
              {
                uint64_t v31 = 0LL;
              }

              else
              {
                unsigned int v32 = *(_DWORD *)a4;
                a4 += 4;
                uint64_t v31 = v32;
              }

              v13 += v31 << v23;
              unsigned int v33 = v23 + 32;
            }

            char v34 = v13;
            unsigned int v23 = v33 - 1;
            v13 >>= 1;
            int v35 = lut_rle[v18 & 0x3F];
            if ((v34 & 1) == 0) {
              break;
            }
            LOBYTE(v18) = v18 + 1;
            v29 += 1 << v35;
          }

          if (v23 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v36 = 0LL;
            }

            else
            {
              unsigned int v37 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v36 = v37;
            }

            v13 += v36 << v23;
            unsigned int v23 = v33 + 31;
          }

          int v38 = v13 & ~(-1 << v35);
          unsigned int v39 = v23 - v35;
          unint64_t v40 = v13 >> v35;
          *(_WORD *)&v15[4 * v17] = (int)(((-((v38 + v29) & 1) ^ ((v38 + v29) >> 1)) + v27) << (32 - v16)) >> (32 - v16);
          if (v39 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v41 = 0LL;
            }

            else
            {
              unsigned int v42 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v41 = v42;
            }

            v40 += v41 << v39;
            v39 += 32;
          }

          unsigned int v43 = __clz(__rbit32(v40 | 0x80000000));
          unsigned int v44 = v39 - (v43 + 1);
          unint64_t v45 = v40 >> (v43 + 1);
          if (v44 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v46 = 0LL;
            }

            else
            {
              unsigned int v47 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v46 = v47;
            }

            v45 += v46 << v44;
            v44 += 32;
          }

          unsigned int v18 = i + (i >> 31);
          char v48 = -1;
          unsigned int v49 = (v45 & ~(-1 << v43)) + ~(-1 << v43);
          char v50 = ((-(v49 & 1) ^ (v49 >> 1)) + v28) & v19;
          v15[4 * v17 + 2] = v50;
          int v51 = 16 << v50;
          do
            ++v48;
          while (!(((1 << v48) + v51) >> v16));
          unsigned int v12 = v44 - v43;
          unint64_t v13 = v45 >> v43;
          v15[4 * v17 + 3] = v48;
        }

        else
        {
          --v12;
        }

        ++v17;
      }

      while (v17 != 666);
      ++v11;
      unint64_t result = v84;
      uint64_t v7 = v85;
      unint64_t v52 = *(unsigned __int8 *)(v85 + 17);
    }

    while (v11 < v52);
    if (*(_BYTE *)(v85 + 17))
    {
      uint64_t v53 = 0LL;
      uint64_t v54 = v85 + 18;
      uint64_t v55 = *(void *)(v84 + 16);
      while (1)
      {
        unint64_t v56 = (unsigned __int16 *)(v54 + 10 * v53);
        unsigned int v58 = v56 + 1;
        unsigned __int16 v57 = v56[1];
        if (v57) {
          break;
        }
LABEL_68:
      }

      unsigned int v59 = 0;
      uint64_t v60 = a2 + 32 * v53;
      uint64_t v77 = (void *)(v60 + 24);
      int8x8_t v78 = (uint64_t *)(v60 + 16);
      uint64_t v61 = v54 + 10 * v53;
      int8x16_t v79 = (unsigned __int16 *)(v61 + 4);
      int8x16_t v81 = (unsigned __int16 *)(v61 + 6);
      unsigned int v76 = (unsigned __int8 *)(v61 + 8);
      unsigned int v62 = *v56;
      while (!v62)
      {
LABEL_66:
        v59 += *v81;
        if (v59 >= v57)
        {
          LOBYTE(v52) = *(_BYTE *)(v85 + 17);
          goto LABEL_68;
        }
      }

      unsigned int v63 = 0;
      int v64 = *v79;
      while (1)
      {
        *(_DWORD *)(v55 + 152) = 2;
        *(void *)(v55 + 24) = v85;
        *(void *)(v55 + 32) = v56;
        *(void *)(v55 + 8) = *v77;
        unsigned int v65 = v63 + v64;
        if (v65 < v62) {
          unsigned int v62 = v65;
        }
        *(_DWORD *)(v55 + 16) = v62 - v63;
        unsigned int v66 = v59 + *v81;
        if (v66 >= *v58) {
          unsigned int v66 = *v58;
        }
        *(_DWORD *)(v55 + 20) = v66 - v59;
        uint64_t v67 = *v78;
        *(void *)uint64_t v55 = v67
                       + get_format_bytes_per_pixel(*(unsigned __int8 *)(v85 + 16), *v76, v53) * v63
                       + *(void *)(v55 + 8) * v59;
        uint64_t v68 = *(unsigned int *)(v55 + 16);
        int v69 = *(unsigned __int8 *)(v85 + 16);
        unsigned int format_components = get_format_components(v69, v53);
        size_t v71 = yzip_plane_decoder_allocate(&v86, v68, format_components, v69, 0LL) + 16;
        unint64_t v72 = *(void *)(a1 + 16);
        unint64_t v73 = (*(void *)(a1 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
        *(void *)(a1 + 8) = v73 + v71;
        if (v73 + v71 > v72) {
          unint64_t v73 = (unint64_t)malloc(v71);
        }
        *(void *)(v55 + 96) = v73;
        unint64_t result = v84;
        *(void *)(v55 + 120) = *(void *)(v84 + 8) + 2664 * v53;
        *(void *)(v55 + 104) = v83 + 4;
        uint64_t v74 = *(unsigned int *)v83;
        *(void *)(v55 + 144) = v74;
        unint64_t v75 = (unint64_t)&v83[v74 + 4];
        if (v75 > v80) {
          return 0LL;
        }
        int16x8_t v83 = (char *)v75;
        int v64 = *v79;
        v63 += v64;
        v55 += 160LL;
        unsigned int v62 = *v56;
        if (v63 >= v62)
        {
          unsigned __int16 v57 = *v58;
          uint64_t v54 = v85 + 18;
          goto LABEL_66;
        }
      }
    }
  }

  return result;
}

uint64_t yzip_jobs_encode(uint64_t a1, uint64_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t)a2;
  uint64_t v7 = *a2;
  yzip_jobs_process(a1, (uint64_t)a2);
  uint64_t v69 = a4;
  uint64_t v8 = (char *)a3 + (a4 & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v74 = v6;
  unsigned int v66 = v8;
  uint64_t v67 = a3;
  if (*(_BYTE *)(v7 + 17))
  {
    uint64_t v9 = 0LL;
    unsigned int v10 = 0;
    unint64_t v11 = 0LL;
    unsigned int v12 = *(void **)(v6 + 16);
    unint64_t v13 = v8 - 7;
    uint64_t v14 = v7 + 18;
    size_t v71 = v8 - 7;
    uint64_t v72 = v7;
    uint64_t v70 = v7 + 18;
    while (1)
    {
      unsigned int v15 = *(unsigned __int8 *)(v7 + 10 * v9 + 26);
      uint64_t v16 = v12[14];
      unint64_t v17 = (unsigned __int16 *)(v14 + 10 * v9);
      int v18 = (v17[1] + v17[3] - 1) / v17[3] * ((*v17 + v17[2] - 1) / v17[2]);
      if (v18) {
        break;
      }
      uint64_t v21 = *(void *)(v6 + 8);
LABEL_13:
      uint64_t v73 = v9;
      int v25 = (char *)(v21 + 2664 * v9);
      bzero(v25, 0xA68uLL);
      unint64_t v26 = 0LL;
      unsigned int v27 = 0u;
      if (v15 > 8) {
        char v28 = 28;
      }
      else {
        char v28 = 29;
      }
      uint64_t v14 = v70;
      unint64_t v13 = v71;
      do
      {
        int v29 = (uint64_t *)(v16 + 24 * v26);
        uint64_t v30 = *((_DWORD *)v29 + 4) != 0;
        *a3 = v11;
        unint64_t v11 = (v30 << (v10 & 0x1F)) + (v11 >> (v10 & 0x20));
        LODWORD(v30) = v10 >> 5;
        unsigned int v10 = (v10 & 0x1F) + 1;
        a3 += v30;
        unint64_t v31 = *((unsigned int *)v29 + 4);
        if ((_DWORD)v31)
        {
          uint64_t v32 = *(void *)(v16 + 24 * v26 + 8);
          if (v32 <= 0) {
            unint64_t v33 = -(uint64_t)(-v32 / v31);
          }
          else {
            unint64_t v33 = (v31 + v32 - 1) / v31;
          }
          *(_WORD *)&v25[4 * v26] = v33;
          uint64_t v34 = *v29;
          unsigned __int8 v35 = -1;
          do
            ++v35;
          while ((uint64_t)(v31 << v35) < v34);
          v25[4 * v26 + 2] = v35;
          int v36 = v35;
          int v37 = 16 << v35;
          char v38 = -1;
          do
            ++v38;
          while (!(((1 << v38) + v37) >> v15));
          v25[4 * v26 + 3] = v38;
          if (v26 <= 0xA) {
            int v39 = -1;
          }
          else {
            int v39 = -11;
          }
          int v40 = v39 + v26;
          if (v40 < 0)
          {
            int v42 = 0;
            int v43 = 0;
          }

          else
          {
            uint64_t v41 = &v25[4 * v40];
            int v42 = *(__int16 *)v41;
            int v43 = v41[2];
          }

          unsigned int v44 = (2 * (((__int16)v33 - v42) << (32 - v15) >> (32 - v15))) ^ ~(~(2
                                                                             * (((__int16)v33 - v42) << (32 - v15) >> (32 - v15))) >> 31);
          int v45 = lut_rle[v27];
          if (v44 >> v45)
          {
            uint64_t v46 = &lut_rle[v27 + 1];
            do
            {
              *a3 = v11;
              unint64_t v11 = (v11 >> (v10 & 0x20)) + (1LL << (v10 & 0x1F));
              unsigned int v47 = (v10 & 0x1F) + 1;
              a3 += v10 >> 5;
              v44 += -1 << v45;
              int v48 = *v46++;
              int v45 = v48;
              ++v27;
              unsigned int v10 = v47;
            }

            while (v44 >> v48);
          }

          else
          {
            unsigned int v47 = v10;
          }

          *a3 = v11;
          unint64_t v49 = ((unint64_t)(2 * v44) << (v47 & 0x1F)) + (v11 >> (v47 & 0x20));
          unsigned int v50 = (v47 & 0x1F) + v45 + 1;
          int v51 = &a3[v47 >> 5];
          unsigned int v27 = v27 - 1 + ((v27 - 1) >> 31);
          unsigned int v52 = ((2 * ((v36 - v43) << v28 >> v28)) ^ ~(~(2 * ((v36 - v43) << v28 >> v28)) >> 31)) + 1;
          unsigned int v53 = __clz(v52);
          uint64_t v54 = 0x80000000 >> v53;
          *int v51 = v49;
          unint64_t v55 = (v49 >> (v50 & 0x20)) + (v54 << (v50 & 0x1F));
          unsigned int v56 = (v50 & 0x1F) - v53;
          unsigned __int16 v57 = &v51[v50 >> 5];
          *unsigned __int16 v57 = v55;
          unint64_t v11 = (v55 >> ((v56 + 32) & 0x20)) + ((unint64_t)(v52 - v54) << (v56 & 0x1F));
          unsigned int v10 = (v56 & 0x1F) - v53 + 31;
          a3 = &v57[(v56 + 32) >> 5];
        }

        ++v26;
      }

      while (v26 != 666);
      uint64_t v7 = v72;
      uint64_t v9 = v73 + 1;
      uint64_t v6 = v74;
    }

    int v19 = 0;
    while (1)
    {
      uint64_t result = v12[18];
      if (result < 0) {
        break;
      }
      uint64_t v21 = *(void *)(v6 + 8);
      v12[15] = v21 + 2664 * v9;
      if (v19)
      {
        uint64_t v22 = v12[14];
        uint64_t v23 = -15984LL;
        do
        {
          int v24 = (int64x2_t *)(v16 + v23);
          v24[1000].i32[0] = *(_DWORD *)(v16 + v23 + 16000) + *(_DWORD *)(v22 + v23 + 16000);
          v24[999] = vaddq_s64(*(int64x2_t *)(v16 + v23 + 15984), *(int64x2_t *)(v22 + v23 + 15984));
          v23 += 24LL;
        }

        while (v23);
      }

      ++v19;
      v12 += 20;
      if (v19 == v18) {
        goto LABEL_13;
      }
    }
  }

  else
  {
    unint64_t v11 = 0LL;
    unsigned int v10 = 0;
LABEL_41:
    unint64_t v58 = (unint64_t)v67 + a4;
    *(void *)a3 = v11;
    *((void *)v66 - 1) = 0LL;
    unsigned __int16 v59 = ((_WORD)a3 - (_WORD)v67 + ((v10 + 7) >> 3) + 3) & 0xFFFC;
    *(_WORD *)(v7 + 6) = v59;
    uint64_t v60 = (char *)v67 + v59;
    yzip_jobs_process(a1, v6);
    if (*(_DWORD *)(v6 + 24))
    {
      uint64_t v61 = 0LL;
      unint64_t v62 = 0LL;
      while (1)
      {
        uint64_t v63 = *(void *)(v6 + 16);
        uint64_t v64 = v63 + v61;
        uint64_t result = *(void *)(v63 + v61 + 144);
        if (result < 0) {
          break;
        }
        *(_DWORD *)uint64_t v60 = result;
        unsigned int v65 = v60 + 4;
        memcpy(v65, *(const void **)(v63 + v61 + 104), *(void *)(v64 + 144));
        uint64_t v60 = &v65[*(void *)(v64 + 144)];
        ++v62;
        uint64_t v6 = v74;
        v61 += 160LL;
      }
    }

    else
    {
      return (uint64_t)&v60[v69 - v58];
    }
  }

  return result;
}

void yzip_jobs_process(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 32);
  size_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == 1)
  {
    if (!*(_DWORD *)(a2 + 24)) {
      return;
    }
  }

  else if (v4 != 1)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 0x40000000LL;
    block[2] = __yzip_jobs_process_block_invoke;
    block[3] = &__block_descriptor_tmp;
    block[4] = a2;
    dispatch_apply(v4, 0LL, block);
    return;
  }

  uint64_t v5 = 0LL;
  size_t v6 = 0LL;
  do
  {
    uint64_t v7 = (void *)(*(void *)(a2 + 16) + v5);
    if (*v7)
    {
      yzip_jobs_worker_entry(v4, (uint64_t)v7);
      size_t v4 = *(unsigned int *)(a2 + 24);
    }

    ++v6;
    v5 += 160LL;
  }

  while (v6 < v4);
}

uint64_t yzip_jobs_decode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 24);
  if (!(_DWORD)v3) {
    return 0LL;
  }
  uint64_t result = 0LL;
  for (unsigned int i = *(void **)(a2 + 16); !*i; i += 20)
  {
LABEL_6:
    if (!--v3) {
      return result;
    }
  }

  uint64_t v6 = i[18];
  if ((v6 & 0x8000000000000000LL) == 0)
  {
    result += v6;
    goto LABEL_6;
  }

  return i[18];
}

uint64_t __yzip_jobs_process_block_invoke(uint64_t result, uint64_t a2)
{
  unsigned int v2 = (void *)(*(void *)(*(void *)(result + 32) + 16LL) + 160 * a2);
  if (*v2) {
    return yzip_jobs_worker_entry(result, (uint64_t)v2);
  }
  return result;
}

uint64_t lzbitmap_fast_encode_state_size(unsigned int a1)
{
  if (a1 > 2) {
    return 0LL;
  }
  else {
    return dword_181096BF0[a1];
  }
}

uint64_t lzbitmap_fast_encode( uint64_t a1, unsigned int a2, char *__src, unsigned int a4, void *a5, unsigned int a6)
{
  uint64_t result = 0LL;
  uint64_t v219 = *MEMORY[0x1895F89C0];
  if (!a4 || !a5) {
    return result;
  }
  if (a4 >= 8) {
    size_t v10 = 8LL;
  }
  else {
    size_t v10 = a4;
  }
  unint64_t v193 = a1 + a2;
  if (a1 + v10 + 5 > v193) {
    return 0LL;
  }
  *(_WORD *)a1 = -1;
  *(_WORD *)(a1 + 2) = v10;
  *(_BYTE *)(a1 + 4) = 0;
  int v189 = a1;
  size_t v190 = v10;
  uint64_t v12 = a1 + 5;
  memcpy((void *)(a1 + 5), __src, v10);
  unsigned int v13 = v190;
  uint64_t v14 = (char *)(v12 + v190);
  if (a6 <= 2)
  {
    memset_pattern16(a5, asc_181096BE0, qword_181096C00[a6]);
    unsigned int v13 = v190;
  }

  unsigned int v15 = a4;
  if (a6 == 2)
  {
    int8x16_t v217 = 0u;
    uint32x4_t v218 = 0u;
    uint32x4_t v215 = 0u;
    uint32x4_t v216 = 0u;
    uint32x4_t v213 = 0u;
    uint32x4_t v214 = 0u;
    uint32x4_t v211 = 0u;
    uint32x4_t v212 = 0u;
    __int128 v209 = 0u;
    __int128 v210 = 0u;
    if ((v13 | 0x90) <= a4)
    {
      uint64_t v191 = 8LL;
      int32x4_t v129 = vdupq_n_s32(0x9E3779B1);
      unsigned int v18 = v13;
      while ((unint64_t)(v14 + 164) <= v193)
      {
        unint64_t v130 = 0LL;
        int8x16_t v131 = &__src[v18];
        int8x16_t v133 = *(int8x16_t *)v131;
        int8x16_t v132 = (int8x16_t *)(v131 + 16);
        int8x16_t v134 = v133;
        do
        {
          int8x16_t v135 = v134;
          int8x16_t v136 = *v132++;
          int8x16_t v134 = v136;
          unint64_t v137 = (uint32x4_t *)(&v197 + 2 * v130);
          *unint64_t v137 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_181096BA0), v129),  0x11uLL);
          v137[1] = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_181096BB0), v129),  0x11uLL);
          v137[2] = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_181096BC0), v129),  0x11uLL);
          v137[3] = vshrq_n_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v134 - 1), (int8x16_t)xmmword_181096BD0),  v129),  0x11uLL);
          v130 += 2LL;
        }

        while (v130 < 0xE);
        int v138 = 0;
        uint64_t v139 = 0LL;
        int v140 = 0;
        unsigned __int8 v141 = 0;
        __int16 v142 = 0;
        int8x16_t v143 = *v132;
        uint32x4_t v205 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_181096BA0), v129),  0x11uLL);
        uint32x4_t v206 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_181096BB0), v129),  0x11uLL);
        int8x16_t v144 = (int8x16_t)vshrq_n_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v134.i8, (int8x16_t)xmmword_181096BD0),  v129),  0x11uLL);
        uint32x4_t v207 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_181096BC0), v129),  0x11uLL);
        int8x16_t v208 = v144;
        *(_DWORD *)uint64_t v14 = 0;
        uint64_t v145 = v191;
        do
        {
          unsigned int v146 = v18;
          int8x16_t v147 = (int8x8_t *)&__src[v18];
          *(int8x8_t *)v144.i8 = *v147;
          int8x8_t v148 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v147 - v145),  *v147)))));
          if (v148.i8[0])
          {
            unsigned __int8 v149 = v148.i8[0];
            v148.i32[0] = v148.u8[0];
            uint8x8_t v150 = (uint8x8_t)vcnt_s8(v148);
            v150.i16[0] = vaddlv_u8(v150);
            unsigned __int8 v151 = v150.i8[0];
            if (v150.i32[0] == 1)
            {
LABEL_102:
              int8x8_t v166 = vqtbl1_s8(v144, lzbitmap_pack_perm_table[v149]);
              *(int8x8_t *)&v211.i8[v142] = v166;
              v166.i32[0] = v149;
              v142 += vaddlv_u8((uint8x8_t)vcnt_s8(v166));
              int v138 = *(_DWORD *)v14 | (1 << v139);
              *(_DWORD *)uint64_t v14 = v138;
              v14[v141++ + 4] = v149;
            }

            else
            {
              uint64_t v152 = 0LL;
              int32x4_t v153 = (int8x16_t *)(&v197 + 2 * v139);
              int8x16_t v154 = v153[1];
              unsigned int v155 = v154.i32[0];
              __int16 v156 = *((_WORD *)a5 + v154.u32[0]);
              unsigned __int32 v157 = vextq_s8(*v153, *v153, 8uLL).u32[0];
              int8x16_t v158 = *v153;
              v154.i32[0] = HIDWORD(*(unsigned __int128 *)v153);
              LODWORD(v153) = *v153;
              __int16 v159 = *((_WORD *)a5 + v153);
              __int16 v160 = *((_WORD *)a5 + v157);
              *((_WORD *)a5 + v158.u32[1]) = v146 + 1;
              *((_WORD *)a5 + v157) = v146 + 2;
              *((_WORD *)a5 + v154.u32[0]) = v146 + 3;
              *((_WORD *)a5 + v154.u32[1]) = v146 + 5;
              *((_WORD *)a5 + v154.u32[2]) = v146 + 6;
              __int16 v194 = v146 + 4 - v156;
              __int16 v195 = v146 - v159;
              *((_WORD *)a5 + v154.u32[3]) = v146 + 7;
              __int16 v196 = v146 + 2 - v160;
              *((_WORD *)a5 + v155) = v146 + 4;
              *((_WORD *)a5 + v153) = v146;
              uint64_t v161 = v145;
              while (1)
              {
                uint64_t v162 = *(unsigned __int16 *)((char *)&v194 + v152);
                int8x8_t v163 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v147 - v162),  *(int8x8_t *)v144.i8)))));
                unsigned int v164 = v163.u8[0] | ((v162 - 8) >> 24);
                v163.i32[0] = v163.i8[0] | ((v162 - 8) >> 24);
                uint8x8_t v165 = (uint8x8_t)vcnt_s8(v163);
                v165.i16[0] = vaddlv_u8(v165);
                if (v165.i32[0] + 2 < v151)
                {
                  unsigned __int8 v149 = v164;
                  unsigned __int8 v151 = v165.i8[0] + 2;
                  uint64_t v161 = *(unsigned __int16 *)((char *)&v194 + v152);
                  if (v152 == 4) {
                    goto LABEL_101;
                  }
                }

                v152 += 2LL;
                if (v152 == 6)
                {
                  uint64_t v162 = v161;
                  LOBYTE(v164) = v149;
                  if (v161 == v145) {
                    goto LABEL_102;
                  }
LABEL_101:
                  *(_DWORD *)uint64_t v14 = (0x10000 << v139) | v138;
                  *((_WORD *)&v209 + v140++) = v162;
                  uint64_t v145 = v162;
                  unsigned __int8 v149 = v164;
                  goto LABEL_102;
                }
              }

              v138 |= 0x10000 << v139;
              *(_DWORD *)uint64_t v14 = v138;
              *((_WORD *)&v209 + v140++) = v162;
              uint64_t v145 = v162;
            }
          }

          ++v139;
          unsigned int v18 = v146 + 8;
        }

        while (v139 != 16);
        uint64_t v167 = v141 + 4LL;
        unint64_t v168 = 2 * v140 + (unint64_t)v142;
        if ((v168 + v167) <= 0x85)
        {
          int v176 = &v14[v167];
          __int128 v177 = v210;
          *(_OWORD *)int v176 = v209;
          *((_OWORD *)v176 + 1) = v177;
          if (v176 < v176 + 32)
          {
            uint64_t v178 = &v209;
            uint64_t v179 = v176;
            do
            {
              __int128 v180 = *v178;
              __int128 v181 = v178[1];
              v178 += 2;
              *(_OWORD *)uint64_t v179 = v180;
              *((_OWORD *)v179 + 1) = v181;
              v179 += 32;
            }

            while (v179 < v176 + 32);
          }

          uint64_t v14 = &v176[v168];
          uint32x4_t v182 = v212;
          int8x16_t v183 = (uint32x4_t *)&v176[v168 - v142];
          *int8x16_t v183 = v211;
          v183[1] = v182;
          if (v183 >= (uint32x4_t *)v14)
          {
            uint64_t v191 = v145;
            unsigned int v15 = a4;
          }

          else
          {
            int8x16_t v184 = &v211;
            unsigned int v15 = a4;
            do
            {
              uint32x4_t v185 = *v184;
              uint32x4_t v186 = v184[1];
              v184 += 2;
              *int8x16_t v183 = v185;
              v183[1] = v186;
              v183 += 2;
            }

            while (v183 < (uint32x4_t *)v14);
            uint64_t v191 = v145;
          }
        }

        else
        {
          uint8x8_t v169 = &__src[v18 - 128];
          *(_DWORD *)uint64_t v14 = 8454143;
          v14[4] = 0;
          __int128 v170 = *(_OWORD *)v169;
          __int128 v171 = *((_OWORD *)v169 + 1);
          __int128 v172 = *((_OWORD *)v169 + 2);
          *(_OWORD *)(v14 + 53) = *((_OWORD *)v169 + 3);
          *(_OWORD *)(v14 + 37) = v172;
          *(_OWORD *)(v14 + 21) = v171;
          *(_OWORD *)(v14 + 5) = v170;
          __int128 v173 = *((_OWORD *)v169 + 4);
          __int128 v174 = *((_OWORD *)v169 + 5);
          __int128 v175 = *((_OWORD *)v169 + 6);
          *(_OWORD *)(v14 + 117) = *((_OWORD *)v169 + 7);
          *(_OWORD *)(v14 + 101) = v175;
          *(_OWORD *)(v14 + 85) = v174;
          *(_OWORD *)(v14 + 69) = v173;
          v14 += 133;
          unsigned int v15 = a4;
        }

        if (v146 + 152 > v15) {
          goto LABEL_118;
        }
      }

      goto LABEL_117;
    }

    goto LABEL_87;
  }

  if (a6 == 1)
  {
    int8x16_t v217 = 0u;
    uint32x4_t v218 = 0u;
    uint32x4_t v215 = 0u;
    uint32x4_t v216 = 0u;
    uint32x4_t v213 = 0u;
    uint32x4_t v214 = 0u;
    uint32x4_t v211 = 0u;
    uint32x4_t v212 = 0u;
    __int128 v209 = 0u;
    __int128 v210 = 0u;
    if ((v13 | 0x90) <= a4)
    {
      uint64_t v71 = 8LL;
      int32x4_t v72 = vdupq_n_s32(0x9E3779B1);
      unsigned int v18 = v13;
      while ((unint64_t)(v14 + 164) <= v193)
      {
        unint64_t v73 = 0LL;
        uint64_t v74 = &__src[v18];
        int8x16_t v76 = *(int8x16_t *)v74;
        unint64_t v75 = (int8x16_t *)(v74 + 16);
        int8x16_t v77 = v76;
        do
        {
          int8x16_t v78 = v77;
          int8x16_t v79 = *v75++;
          int8x16_t v77 = v79;
          unint64_t v80 = (uint32x4_t *)(&v197 + 2 * v73);
          *unint64_t v80 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_181096BA0), v72),  0x13uLL);
          v80[1] = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_181096BB0), v72),  0x13uLL);
          v80[2] = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_181096BC0), v72),  0x13uLL);
          v80[3] = vshrq_n_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v77 - 1), (int8x16_t)xmmword_181096BD0),  v72),  0x13uLL);
          v73 += 2LL;
        }

        while (v73 < 0xE);
        int v81 = 0;
        uint64_t v82 = 0LL;
        int v83 = 0;
        unsigned __int8 v84 = 0;
        __int16 v85 = 0;
        int8x16_t v86 = *v75;
        uint32x4_t v205 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_181096BA0), v72),  0x13uLL);
        uint32x4_t v206 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_181096BB0), v72),  0x13uLL);
        int8x16_t v87 = (int8x16_t)vshrq_n_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v77.i8, (int8x16_t)xmmword_181096BD0),  v72),  0x13uLL);
        uint32x4_t v207 = vshrq_n_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_181096BC0), v72),  0x13uLL);
        int8x16_t v208 = v87;
        *(_DWORD *)uint64_t v14 = 0;
        uint64_t v88 = v71;
        do
        {
          unsigned int v89 = v18;
          int32x4_t v90 = (int8x8_t *)&__src[v18];
          *(int8x8_t *)v87.i8 = *v90;
          int8x8_t v91 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v90 - (unsigned __int16)v88),  *v90)))));
          if (v91.i8[0])
          {
            unsigned __int8 v92 = v91.i8[0];
            v91.i32[0] = v91.u8[0];
            uint8x8_t v93 = (uint8x8_t)vcnt_s8(v91);
            v93.i16[0] = vaddlv_u8(v93);
            unsigned __int8 v94 = v93.i8[0];
            if (v93.i32[0] != 1)
            {
              uint64_t v95 = 0LL;
              int v96 = (int8x16_t *)(&v197 + 2 * v82);
              int8x16_t v97 = *v96;
              int8x16_t v98 = v96[1];
              unint64_t v99 = vextq_s8(v97, v97, 4uLL).u64[0];
              __int16 v194 = v89 + 4 - *((_WORD *)a5 + v98.u32[0]);
              __int16 v195 = v89 - *((_WORD *)a5 + v97.u32[0]);
              *((_WORD *)a5 + v99) = v89 + 1;
              *((_WORD *)a5 + HIDWORD(v99)) = v89 + 2;
              *((_WORD *)a5 + v97.u32[3]) = v89 + 3;
              *((_WORD *)a5 + v98.u32[1]) = v89 + 5;
              *((_WORD *)a5 + v98.u32[2]) = v89 + 6;
              *((_WORD *)a5 + v98.u32[3]) = v89 + 7;
              *((_WORD *)a5 + v98.u32[0]) = v89 + 4;
              *((_WORD *)a5 + v97.u32[0]) = v89;
              int v100 = 1;
              LODWORD(v101) = v88;
              do
              {
                uint64_t v102 = (unsigned __int16)*(&v194 + v95);
                int8x8_t v103 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8( (int8x8_t)0x8040201008040201LL,  vceq_s8( *(int8x8_t *)((char *)v90 - v102),  *(int8x8_t *)v87.i8)))));
                unsigned int v104 = v103.u8[0] | ((v102 - 8) >> 24);
                if (!(v103.i8[0] | ((v102 - 8) >> 24)))
                {
                  v81 |= 0x10000 << v82;
                  *(_DWORD *)uint64_t v14 = v81;
                  *((_WORD *)&v209 + v83++) = v102;
                  uint64_t v88 = v102;
                  goto LABEL_73;
                }

                char v105 = v100;
                v103.i32[0] = v103.i8[0] | ((v102 - 8) >> 24);
                uint8x8_t v106 = (uint8x8_t)vcnt_s8(v103);
                v106.i16[0] = vaddlv_u8(v106);
                unsigned __int8 v107 = v106.i8[0] + 2;
                if (((v106.i32[0] + 2 < v94) & ~v100) != 0)
                {
                  uint64_t v101 = v102;
                  unsigned __int8 v92 = v104;
                  goto LABEL_71;
                }

                int v100 = 0;
                else {
                  uint64_t v101 = v101;
                }
                uint64_t v95 = 1LL;
              }

              while ((v105 & 1) != 0);
LABEL_71:
              *(_DWORD *)uint64_t v14 = (0x10000 << v82) | v81;
              *((_WORD *)&v209 + v83++) = v101;
              uint64_t v88 = v101;
            }

LABEL_72:
            int8x8_t v108 = vqtbl1_s8(v87, lzbitmap_pack_perm_table[v92]);
            *(int8x8_t *)&v211.i8[v85] = v108;
            v108.i32[0] = v92;
            v85 += vaddlv_u8((uint8x8_t)vcnt_s8(v108));
            int v81 = *(_DWORD *)v14 | (1 << v82);
            *(_DWORD *)uint64_t v14 = v81;
            v14[v84++ + 4] = v92;
          }

LABEL_73:
          ++v82;
          unsigned int v18 = v89 + 8;
        }

        while (v82 != 16);
        uint64_t v109 = v84 + 4LL;
        unint64_t v110 = 2 * v83 + (unint64_t)v85;
        if ((v110 + v109) <= 0x85)
        {
          int8x16_t v118 = &v14[v109];
          __int128 v119 = v210;
          *(_OWORD *)int8x16_t v118 = v209;
          *((_OWORD *)v118 + 1) = v119;
          if (v118 < v118 + 32)
          {
            unint64_t v120 = &v209;
            unint64_t v121 = v118;
            do
            {
              __int128 v122 = *v120;
              __int128 v123 = v120[1];
              v120 += 2;
              *(_OWORD *)unint64_t v121 = v122;
              *((_OWORD *)v121 + 1) = v123;
              v121 += 32;
            }

            while (v121 < v118 + 32);
          }

          uint64_t v14 = &v118[v110];
          uint32x4_t v124 = v212;
          int8x8_t v125 = (uint32x4_t *)&v118[v110 - v85];
          uint32x4_t *v125 = v211;
          v125[1] = v124;
          if (v125 >= (uint32x4_t *)v14)
          {
            uint64_t v71 = v88;
            unsigned int v15 = a4;
          }

          else
          {
            int8x8_t v126 = &v211;
            unsigned int v15 = a4;
            do
            {
              uint32x4_t v127 = *v126;
              uint32x4_t v128 = v126[1];
              v126 += 2;
              uint32x4_t *v125 = v127;
              v125[1] = v128;
              v125 += 2;
            }

            while (v125 < (uint32x4_t *)v14);
            uint64_t v71 = v88;
          }
        }

        else
        {
          int8x16_t v111 = &__src[v18 - 128];
          *(_DWORD *)uint64_t v14 = 8454143;
          v14[4] = 0;
          __int128 v112 = *(_OWORD *)v111;
          __int128 v113 = *((_OWORD *)v111 + 1);
          __int128 v114 = *((_OWORD *)v111 + 2);
          *(_OWORD *)(v14 + 53) = *((_OWORD *)v111 + 3);
          *(_OWORD *)(v14 + 37) = v114;
          *(_OWORD *)(v14 + 21) = v113;
          *(_OWORD *)(v14 + 5) = v112;
          __int128 v115 = *((_OWORD *)v111 + 4);
          __int128 v116 = *((_OWORD *)v111 + 5);
          __int128 v117 = *((_OWORD *)v111 + 6);
          *(_OWORD *)(v14 + 117) = *((_OWORD *)v111 + 7);
          *(_OWORD *)(v14 + 101) = v117;
          *(_OWORD *)(v14 + 85) = v116;
          *(_OWORD *)(v14 + 69) = v115;
          v14 += 133;
          unsigned int v15 = a4;
        }

        if (v89 + 152 > v15) {
          goto LABEL_118;
        }
      }

      goto LABEL_117;
    }

  int8x8_t v46 = *a6;
  *(void *)(a7 + (*a6 >> 3)) = ((unint64_t)(v34 != 0) << (*(_BYTE *)a6 & 7)) | *(unsigned __int8 *)(a7 + (*a6 >> 3));
  *a6 = v46 + 1;
  if (v34)
  {
    *(void *)(a7 + ((v46 + 1) >> 3)) = ((unint64_t)(v34 - 1) << ((v46 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((v46 + 1) >> 3));
    *a6 = v46 + 5;
  }

  BuildAndStoreHuffmanTree((unint64_t)&__src, v10 + v34, v10 + v34, a5, v57, (uint64_t)v56, a6, a7);
  unsigned int v47 = *a6;
  if (!v43)
  {
    uint8x8_t v48 = (unsigned int *)v15;
    do
    {
      int8x8_t v50 = *v48++;
      unsigned __int8 v49 = v50;
      uint64_t v51 = v50 & 0x1FF;
      unint64_t v52 = v57[v51];
      *(void *)(a7 + (v47 >> 3)) = ((unint64_t)(unsigned __int16)v56[v51] << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
      v47 += v52;
      *a6 = v47;
      if ((int)v51 - 1 < v34)
      {
        *(void *)(a7 + (v47 >> 3)) = (v49 >> 9 << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
        v47 += v51;
        *a6 = v47;
      }

      --v35;
    }

    while (v35);
  }

  *(void *)(a7 + (v47 >> 3)) = (1LL << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
  *a6 = v47 + 1;
  return BrotliFree(a1, v15);
}

LABEL_117:
  uint64_t v14 = 0LL;
  unsigned int v18 = v190;
LABEL_118:
  if (!v14) {
    return 0LL;
  }
  do
  {
    uint64_t v187 = v15 - v18;
    if (v15 < v18) {
      break;
    }
    *(_WORD *)uint64_t v14 = -1;
    *((_WORD *)v14 + 1) = v15 - v18;
    v14[4] = 0;
    memcpy(v14 + 5, &__src[v18], v15 - v18);
    unsigned int v15 = a4;
    v14 += v187 + 5;
    BOOL v188 = a4 == v18;
    unsigned int v18 = a4;
  }

  while (!v188);
  return ((_DWORD)v14 - v189);
}

uint64_t lzfse_decode_literals( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5, unint64_t a6, double a7)
{
  uint64_t v7 = LOWORD(a7);
  uint64_t v8 = WORD1(a7);
  uint64_t v9 = WORD2(a7);
  uint64_t v10 = HIWORD(a7);
  unint64_t v12 = *(void *)a4;
  int v13 = *(_DWORD *)(a4 + 8);
  uint64_t v14 = *a5;
  while (1)
  {
    unsigned int v15 = *(_DWORD *)(a2 + 4 * v7);
    unsigned int v16 = *(_DWORD *)(a2 + 4 * v8);
    unsigned int v17 = *(_DWORD *)(a2 + 4 * v9);
    unsigned int v18 = *(_DWORD *)(a2 + 4 * v10);
    *a1++ = (v16 & 0xFF00)
    unint64_t v19 = (63 - v13) & 0xFFFFFFF8;
    if (((63 - v13) & 0xFFFFFFF8) != 0) {
      break;
    }
LABEL_5:
    uint64_t v20 = v13 - v15;
    uint64_t v21 = v20 - v16;
    unint64_t v22 = v12 >> (v13 - v15);
    unint64_t v23 = v12 & qword_18103C100[v20];
    uint64_t v24 = v21 - v17;
    uint64_t v7 = v22 + HIWORD(v15);
    unint64_t v25 = v23 >> (v20 - v16);
    unint64_t v26 = v23 & qword_18103C100[v21];
    int v13 = v24 - v18;
    uint64_t v8 = v25 + HIWORD(v16);
    unint64_t v27 = v26 >> (v21 - v17);
    unint64_t v28 = v26 & qword_18103C100[v24];
    uint64_t v9 = v27 + HIWORD(v17);
    unint64_t v29 = v28 >> (v24 - v18);
    unint64_t v12 = v28 & qword_18103C100[v13];
    uint64_t v10 = v29 + HIWORD(v18);
    BOOL v30 = a3 <= 4;
    a3 -= 4LL;
    if (v30)
    {
      *(void *)a4 = v12;
      *(_DWORD *)(a4 + 8) = v13;
      *a5 = v14;
      return 0LL;
    }
  }

  uint64_t v14 = (void *)((char *)v14 - (v19 >> 3));
  if ((unint64_t)v14 >= a6)
  {
    v13 += v19;
    unint64_t v12 = (v12 << v19) | *v14 & qword_18103C100[v19];
    goto LABEL_5;
  }

  return -3LL;
}

compression_status compression_stream_init( compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  if ((int)algorithm > 2192)
  {
    if (algorithm - 2304 < 2) {
      return lzvn_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    if (algorithm == 2818) {
      return brotli_stream_init((uint64_t)stream, operation);
    }
    if (algorithm == 2193) {
      return lzfse_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    return -1;
  }

  if ((int)algorithm > 2048)
  {
    if (algorithm - 2049 < 2) {
      return lzfse_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    return -1;
  }

  if (algorithm == COMPRESSION_LZ4) {
    return lz4_stream_init((uint64_t)stream, operation, 0);
  }
  if (algorithm != COMPRESSION_ZLIB)
  {
    if (algorithm == COMPRESSION_LZMA)
    {
      lzma_stream_init((uint64_t)stream, operation);
      return result;
    }

    return -1;
  }

  return zlib_stream_init((uint64_t)stream, operation, 0);
}

uint64_t compression_stream_init_with_state_buffer(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 32) = a4;
  *(void *)a4 = 0LL;
  *(_DWORD *)(a4 + 8) = -1412628475;
  *(_DWORD *)(a4 + 12) = a5;
  return compression_stream_reinit(a1, a2, a3);
}

uint64_t compression_stream_reinit(uint64_t a1, int a2, int a3)
{
  if (a3 > 2192)
  {
    if (a3 != 2193) {
      return 0xFFFFFFFFLL;
    }
    return lzfse_stream_init(a1, a2, a3, 1);
  }

  if (a3 == 256) {
    return lz4_stream_init(a1, a2, 1);
  }
  if (a3 == 517) {
    return zlib_stream_init(a1, a2, 1);
  }
  return 0xFFFFFFFFLL;
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  state = stream->state;
  if (!state) {
    return -1;
  }
  char v3 = flags;
  src_ptr = stream->src_ptr;
  dst_ptr = stream->dst_ptr;
  int v7 = state[1];
  compression_status result = COMPRESSION_STATUS_ERROR;
  if (v7 > 2192)
  {
    if ((v7 - 2304) < 2)
    {
      compression_status result = lzvn_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      goto LABEL_23;
    }

    if (v7 == 2818)
    {
      compression_status result = brotli_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      goto LABEL_23;
    }

    if (v7 != 2193) {
      return result;
    }
LABEL_14:
    compression_status result = lzfse_stream_process((uint64_t)stream, flags);
    if (result) {
      return result;
    }
    goto LABEL_23;
  }

  if (v7 > 2048)
  {
    goto LABEL_14;
  }

  switch(v7)
  {
    case 256:
      compression_status result = lz4_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      break;
    case 517:
      compression_status result = zlib_stream_process((void **)&stream->dst_ptr, flags);
      if (result) {
        return result;
      }
      break;
    case 774:
      compression_status result = lzma_stream_process(stream, flags);
      if (result) {
        return result;
      }
      break;
    default:
      return result;
  }

LABEL_23:
  if ((v3 & 1) != 0 && stream->src_ptr == src_ptr && stream->dst_ptr == dst_ptr) {
    return -1;
  }
  return result;
}

    ++v11;
    __int128 v61 = v21;
    int v13 = v20;
  }

  while (v11 < v7[1]);
  *(_DWORD *)a3 = v52 & 0xFFFE;
  uint8x8_t v36 = v52 & 0xFFFE;
  unsigned __int8 v37 = (_DWORD *)((char *)a3 + v36);
  uint64_t v38 = v53 - v36;
  a2 = v55;
  if (v10 != 1297111641)
  {
LABEL_60:
    pool_size = get_pool_size((uint64_t)a3, 1);
    if ((yzip_codec_pool_init(a2, pool_size) & 0x80000000) == 0)
    {
      encoder_list = (uint64_t *)yzip_jobs_create_encoder_list((uint64_t)a2, (uint64_t)v7, (uint64_t)a3);
      uint64_t v51 = yzip_jobs_encode((uint64_t)a2, encoder_list, v37, v38);
      if (v51 >= 1)
      {
        uint8x8_t v48 = *(_DWORD *)a3 + v51;
        *(_DWORD *)a3 = v48;
        return (_DWORD *)v48;
      }
    }

    return 0LL;
  }

  int v39 = a3[10];
  if (!a3[10]) {
    return (_DWORD *)*(unsigned int *)a3;
  }
  uint64_t v40 = 0;
  uint64_t v41 = a3[9];
  while (!v41)
  {
LABEL_57:
    v40 += a3[12];
    if (v40 >= v39) {
      return (_DWORD *)*(unsigned int *)a3;
    }
  }

  int v42 = 0;
  while (1)
  {
    slice_width = get_slice_width(v12, v42);
    slice_height = get_slice_height((uint64_t)v12, v40);
    compression_status result = create_rectangle_within_image((uint64_t)v7, v42, v40, slice_width, slice_height);
    if (!result) {
      return result;
    }
    int8x8_t v46 = result;
    unsigned int v47 = yzip_image_encode(result, v55, v37, v38);
    if (!v47)
    {
      free(v46);
      return 0LL;
    }

    unsigned __int8 v37 = (_DWORD *)((char *)v37 + v47);
    v38 -= v47;
    *(_DWORD *)a3 += v47;
    free(v46);
    v42 += a3[11];
    uint64_t v41 = a3[9];
    if (v42 >= v41)
    {
      int v39 = a3[10];
      goto LABEL_57;
    }
  }

      uint64_t v21 = a6;
    }

    if (v33 < 4) {
      goto LABEL_27;
    }
    unsigned __int8 v37 = 135 * v33 + 1935;
    if (v37 < 0x7E5) {
      goto LABEL_27;
    }
    int8x8_t v148 = *(void *)(a5 + 80);
    uint64_t v38 = 0;
    *(_DWORD *)(v20 + 4 * v28) = v11;
LABEL_43:
    compression_status result = 0LL;
    uint8x8_t v48 = *a7;
    unsigned __int8 v49 = a5;
    while (1)
    {
      --v22;
      int8x8_t v50 = v33 - 1;
      if (v33 - 1 >= v22) {
        int8x8_t v50 = v22;
      }
      else {
        uint64_t v51 = v50;
      }
      unint64_t v52 = v11 + 1;
      if (v11 + 1 < v17) {
        unsigned int v53 = v11 + 1;
      }
      else {
        unsigned int v53 = v17;
      }
      __int128 v54 = v52 + v154;
      if (v52 + v154 >= v17) {
        __int128 v54 = v17;
      }
      __int128 v55 = *(unsigned __int8 *)(a3 + v51 + (v52 & a4));
      __int128 v56 = (void *)(a3 + (v52 & a4));
      __int128 v57 = (0xBD1E35A7BD000000LL * *v56) >> 48;
      if (v52 >= v48)
      {
        __int128 v58 = a4 & (v52 - v48);
        if (v55 == *(unsigned __int8 *)(a3 + v58 + v51))
        {
          __int128 v59 = a3 + v58;
          if (v22 < 8)
          {
            uint64_t v60 = 0LL;
            __int128 v64 = (unsigned __int8 *)(a3 + (v52 & a4));
LABEL_111:
            unsigned __int8 v92 = v22 & 7;
            if ((v22 & 7) != 0)
            {
              do
              {
                ++v64;
                ++v60;
                --v92;
              }

              while (v92);
            }
          }

          else
          {
            uint64_t v60 = 0LL;
            __int128 v61 = v22 >> 3;
            while (1)
            {
              unint64_t v62 = *(void *)((char *)v56 + v60);
              uint64_t v63 = *(void *)(v59 + v60);
              if (v62 != v63) {
                break;
              }
              v60 += 8LL;
              if (!--v61)
              {
                __int128 v64 = (unsigned __int8 *)v56 + v60;
                unsigned __int8 v49 = a5;
                goto LABEL_111;
              }
            }

            v60 += __clz(__rbit64(v63 ^ v62)) >> 3;
            unsigned __int8 v49 = a5;
          }

          int v13 = v152;
          if (v60 >= 4)
          {
            __int128 v65 = 135 * v60 + 1935;
            if (v65 >= 0x7E5)
            {
              __int128 v66 = 0;
              *(_DWORD *)(v20 + 4 * v57) = v52;
              uint64_t v67 = v48;
              goto LABEL_87;
            }
          }
        }
      }

      uint64_t v68 = *(unsigned int *)(v20 + 4 * v57);
      *(_DWORD *)(v20 + 4 * v57) = v52;
      if (v55 != *(unsigned __int8 *)(a3 + (v68 & a4) + v51)
        || ((v67 = v52 - v68, v52 != v68) ? (__int128 v69 = v67 > v53) : (__int128 v69 = 1), v69))
      {
        __int128 v66 = 0;
        uint64_t v67 = 0LL;
        __int128 v65 = 2020LL;
        uint64_t v60 = v51;
        goto LABEL_87;
      }

      __int128 v70 = a3 + (v68 & a4);
      if (v22 < 8)
      {
        uint64_t v60 = 0LL;
        uint64_t v74 = (unsigned __int8 *)(a3 + (v52 & a4));
LABEL_106:
        int8x8_t v91 = v22 & 7;
        if ((v22 & 7) != 0)
        {
          do
          {
            ++v74;
            ++v60;
            --v91;
          }

          while (v91);
        }
      }

      else
      {
        uint64_t v60 = 0LL;
        uint64_t v71 = v22 >> 3;
        while (1)
        {
          int32x4_t v72 = *(void *)((char *)v56 + v60);
          unint64_t v73 = *(void *)(v70 + v60);
          if (v72 != v73) {
            break;
          }
          v60 += 8LL;
          if (!--v71)
          {
            uint64_t v74 = (unsigned __int8 *)v56 + v60;
            goto LABEL_106;
          }
        }

        v60 += __clz(__rbit64(v73 ^ v72)) >> 3;
      }

      if (v60 >= 4)
      {
        __int128 v65 = 135 * v60 - 30 * (__clz(v67) ^ 0x1F) + 1920;
        if (v65 > 0x7E4)
        {
          __int128 v66 = 0;
          goto LABEL_87;
        }
      }

      unint64_t v75 = *(void *)(v21 + 48);
      int8x16_t v76 = *(void *)(v75 + 8);
      int8x16_t v77 = *(void *)(v75 + 16);
      if (v77 >= v76 >> 7)
      {
        int8x16_t v78 = ((506832829 * *(_DWORD *)v56) >> 17) & 0x7FFELL;
        int8x16_t v79 = *(void *)(v49 + 120);
        *(void *)(v75 + 8) = v76 + 1;
        unint64_t v80 = *(unsigned __int8 *)(v79 + v78);
        if (!*(_BYTE *)(v79 + v78) || v22 < v80)
        {
          __int128 v66 = 0;
          uint64_t v67 = 0LL;
          __int128 v65 = 2020LL;
          uint64_t v60 = v51;
          uint64_t v21 = a6;
          goto LABEL_86;
        }

        uint64_t v82 = *(unsigned __int16 *)(*(void *)(v49 + 112) + 2 * v78);
        int v83 = *(void *)(v49 + 88);
        unsigned __int8 v84 = *(unsigned int *)(v83 + 4 * v80 + 32);
        __int16 v85 = *(void *)(v83 + 168);
        int8x16_t v86 = (unsigned __int8 *)(v85 + v84 + v82 * (unint64_t)v80);
        if (v80 < 8)
        {
          uint64_t v60 = 0LL;
LABEL_116:
          uint8x8_t v93 = v80 & 7;
          uint64_t v21 = a6;
          if ((v80 & 7) != 0)
          {
            __int16 v142 = v60 | v93;
            while (*((unsigned __int8 *)v56 + v60) == *v86)
            {
              ++v86;
              ++v60;
              if (!--v93)
              {
                uint64_t v60 = v142;
                goto LABEL_97;
              }
            }

            goto LABEL_97;
          }
        }

        else
        {
          int8x16_t v87 = 0LL;
          uint64_t v60 = v80 & 0xF8;
          uint64_t v88 = (unsigned __int8 *)(v85 + v82 * (unint64_t)v80 + v60 + v84);
          while (1)
          {
            unsigned int v89 = *(void *)&v86[v87];
            int32x4_t v90 = v56[v87 / 8];
            if (v89 != v90) {
              break;
            }
            v87 += 8LL;
            if (v60 == v87)
            {
              int8x16_t v86 = v88;
              unsigned __int8 v49 = a5;
              goto LABEL_116;
            }
          }

          uint64_t v60 = v87 + (__clz(__rbit64(v90 ^ v89)) >> 3);
          uint64_t v21 = a6;
LABEL_97:
          unsigned __int8 v49 = a5;
        }

        uint64_t v67 = 0LL;
        __int128 v66 = 0;
        if (v60 && v60 + *(unsigned int *)(v49 + 100) > v80)
        {
          uint64_t v67 = v54
              + 1
              + v82
          if (v67 <= v148 && (__int128 v65 = 135 * v60 - 30 * (__clz(v67) ^ 0x1F) + 1920, v65 >= 0x7E4))
          {
            __int128 v66 = v80 - v60;
            *(void *)(v75 + 16) = v77 + 1;
          }

          else
          {
            __int128 v66 = 0;
            uint64_t v67 = 0LL;
            __int128 v65 = 2020LL;
            uint64_t v60 = v51;
          }

          uint64_t v21 = a6;
          unsigned __int8 v49 = a5;
          goto LABEL_86;
        }

        goto LABEL_82;
      }

      __int128 v66 = 0;
      uint64_t v67 = 0LL;
LABEL_82:
      __int128 v65 = 2020LL;
      uint64_t v60 = v51;
LABEL_86:
      int v13 = v152;
LABEL_87:
      if (v65 < v37 + 175) {
        break;
      }
      ++v12;
      if (result <= 2)
      {
        int v81 = v11 + 9;
        compression_status result = (result + 1);
        unsigned __int8 v37 = v65;
        unint64_t v29 = v67;
        unint64_t v33 = v60;
        uint64_t v38 = v66;
        ++v11;
        if (v81 < v13) {
          continue;
        }
      }

      goto LABEL_139;
    }

    __int128 v54 = v11 + v154;
    if (v11 + v154 >= v17) {
      __int128 v54 = v17;
    }
    uint64_t v67 = v29;
    uint64_t v60 = v33;
    __int128 v66 = v38;
    unint64_t v52 = v11;
LABEL_139:
    if (v67 > v54)
    {
LABEL_140:
      uint64_t v102 = v67 + 15;
      goto LABEL_141;
    }

    int8x8_t v103 = *v149;
    if (v67 == v103)
    {
      uint64_t v102 = 0LL;
      goto LABEL_146;
    }

    __int128 v122 = v149[1];
    if (v67 == v122)
    {
      uint64_t v102 = 1LL;
    }

    else
    {
      __int128 v123 = v67 + 3 - v103;
      if (v123 > 6)
      {
        int8x8_t v126 = v67 + 3 - v122;
        if (v126 > 6)
        {
          if (v67 == v149[2])
          {
            uint64_t v102 = 2LL;
          }

          else
          {
            if (v67 != v149[3]) {
              goto LABEL_140;
            }
            uint64_t v102 = 3LL;
          }

          goto LABEL_141;
        }

        uint32x4_t v124 = 4 * v126;
        int8x8_t v125 = 266017486;
      }

      else
      {
        uint32x4_t v124 = 4 * v123;
        int8x8_t v125 = 158663784;
      }

      uint64_t v102 = (v125 >> v124) & 0xF;
    }

compression_status compression_stream_destroy(compression_stream *stream)
{
  state = stream->state;
  if (!state) {
    return -1;
  }
  int v2 = state[1];
  if (v2 <= 2192)
  {
    if (v2 <= 2048)
    {
      if (v2 != 256 && v2 != 517)
      {
        if (v2 == 774) {
          return lzma_stream_end((uint64_t)stream);
        }
        return -1;
      }

      return lzfse_stream_end((uint64_t)stream);
    }

    return -1;
  }

  if (v2 != 2818)
  {
    if (v2 == 2193) {
      return lzfse_stream_end((uint64_t)stream);
    }
    return -1;
  }

  return brotli_stream_end((uint64_t)stream);
}

uint64_t compression_stream_identify_algorithm(int *a1)
{
  if (lzma_stream_identify_algorithm(a1)) {
    return 774LL;
  }
  if (lz4_stream_identify_algorithm(a1)) {
    return 256LL;
  }
  if (lzvn_stream_identify_algorithm(a1)) {
    return 2304LL;
  }
  if (lzbitmap_stream_identify_algorithm(a1)) {
    return 1794LL;
  }
  return 0xFFFFFFFFLL;
}

uint64_t compression_stream_get_state_size(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  int v3 = *(_DWORD *)(v1 + 4);
  if (v3 > 2048)
  {
    return *(unsigned int *)(v1 + 12);
  }

  if (v3 == 256 || v3 == 517) {
    return *(unsigned int *)(v1 + 12);
  }
  return result;
}

uint64_t compression_stream_get_encode_state_size(int a1)
{
  if (a1 > 2192)
  {
    if (a1 != 2193) {
      return 0LL;
    }
    return lzfse_stream_get_encode_state_size();
  }

  if (a1 == 256) {
    return lz4_stream_get_state_size();
  }
  if (a1 == 517) {
    return lzvn_decode_scratch_size();
  }
  return 0LL;
}

uint64_t compression_stream_get_decode_state_size(int a1)
{
  if (a1 > 2192)
  {
    if (a1 != 2193) {
      return 0LL;
    }
    return lzfse_stream_get_decode_state_size();
  }

  if (a1 == 256) {
    return lz4_stream_get_state_size();
  }
  if (a1 == 517) {
    return zlib_stream_get_decode_state_size();
  }
  return 0LL;
}

_DWORD *compression_stream_is_state_valid(_DWORD *result)
{
  if (result)
  {
    if (*result > 1u) {
      return 0LL;
    }
    else {
      return (_DWORD *)(result[2] == -1412628475);
    }
  }

  return result;
}

_DWORD *realloc_stream_state(_DWORD *a1, int a2, int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6 = a4;
  uint64_t v9 = a1;
  if (a1 && a1[3] >= a4)
  {
    unsigned int v6 = a1[3];
  }

  else
  {
    free(a1);
    uint64_t v9 = malloc(v6);
    if (!v9) {
      return v9;
    }
  }

  if (v6 > a5) {
    bzero(v9, v6 - a5);
  }
  *uint64_t v9 = a2;
  v9[1] = a3;
  v9[2] = -1412628475;
  v9[3] = v6;
  return v9;
}

uint64_t lzfse_stream_init(uint64_t a1, int a2, int a3, int a4)
{
  if (a2 == 1) {
    return lzfseStreamDecodeInit(a1, a3, a4);
  }
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  return lzfseStreamEncodeInit(a1, a3, a4);
}

uint64_t lzfse_stream_process(uint64_t a1, char a2)
{
  int v2 = **(_DWORD **)(a1 + 32);
  if (v2 == 1) {
    return lzfseStreamDecode(a1, a2);
  }
  if (v2) {
    return 0xFFFFFFFFLL;
  }
  return lzfseStreamEncode(a1, a2);
}

uint64_t lzfse_stream_end(uint64_t a1)
{
  *(void *)(a1 + 32) = 0LL;
  return 0LL;
}

uint64_t lzfse_stream_identify_algorithm(int *a1)
{
  int v1 = *a1;
  uint64_t result = 1LL;
  if (v1 <= 829978209)
  {
    BOOL v3 = v1 == 611874402;
    int v4 = 762869346;
  }

  else
  {
    BOOL v3 = v1 == 829978210 || v1 == 846755426;
    int v4 = 1853388386;
  }

  if (!v3 && v1 != v4) {
    return 0LL;
  }
  return result;
}

uint64_t lzfse_stream_get_state_size(uint64_t a1)
{
  int v1 = *(_DWORD **)(a1 + 32);
  if (*v1 == 1) {
    return lzfseStreamDecodeStateSize();
  }
  if (*v1) {
    return 0LL;
  }
  return lzfseStreamEncodeStateSize(v1[1]);
}

void BrotliEstimateBitCostsForLiterals()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v54 = v1;
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  unint64_t v7 = v6;
  uint64_t v8 = v0;
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (BrotliIsMostlyUTF8(v2, v0, v4, v6, 0.75))
  {
    uint64_t v56 = 0LL;
    uint64_t v57 = 0LL;
    uint64_t v58 = 0LL;
    if (v7)
    {
      unint64_t v9 = 0LL;
      uint64_t v10 = v8;
      unint64_t v11 = v7;
      do
      {
        if (*(char *)(v3 + (v10 & v5)) < 0)
        {
          uint64_t v13 = 2LL * (v9 > 0xDF);
          else {
            uint64_t v12 = 1LL;
          }
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        unint64_t v9 = *(unsigned __int8 *)(v3 + (v10 & v5));
        ++*(&v56 + v12);
        ++v10;
        --v11;
      }

      while (v11);
      BOOL v14 = (unint64_t)(v57 + v58) > 0x18;
    }

    else
    {
      BOOL v14 = 0LL;
    }

    bzero(&v56, 0x1800uLL);
    uint64_t v27 = 495LL;
    if (v7 < 0x1EF) {
      uint64_t v27 = v7;
    }
    memset(v55, 0, sizeof(v55));
    if (v27)
    {
      unint64_t v28 = 0LL;
      BOOL v29 = 0LL;
      uint64_t v30 = v8;
      do
      {
        int v31 = *(char *)(v3 + (v30 & v5));
        unint64_t v32 = *(unsigned __int8 *)(v3 + (v30 & v5));
        ++*(&v56 + 256 * v29 + v32);
        ++v55[v29];
        BOOL v29 = v28 >= 0xE0 && v14;
        if (v31 >= 0) {
          BOOL v29 = 0LL;
        }
        ++v30;
        unint64_t v28 = v32;
        --v27;
      }

      while (v27);
    }

    if (v7)
    {
      unint64_t v33 = 0LL;
      unint64_t v34 = 2000LL;
      do
      {
        if (v33 >= 0x1EF)
        {
          if (v33 != 495
            && ((v35 = v8 + v33, v33 >= 0x1F1) ? (unint64_t v36 = *(unsigned __int8 *)(v3 + ((v35 - 497) & v5))) : (unint64_t v36 = 0LL),
                unsigned int v37 = *(unsigned __int8 *)(v3 + ((v35 - 496) & v5)),
                (v37 & 0x80) != 0))
          {
            BOOL v38 = v14;
            if (v37 <= 0xBF) {
              BOOL v38 = v36 >= 0xE0 && v14;
            }
          }

          else
          {
            BOOL v38 = 0LL;
          }

          uint64_t v39 = *(unsigned __int8 *)(v3 + ((v8 + v33 - 495) & v5));
          --*(&v56 + 256 * v38 + v39);
          --v55[v38];
        }

        if (v33 + 495 < v7)
        {
          BOOL v40 = *(unsigned __int8 *)(v3 + ((v8 + v33 + 493) & v5)) >= 0xE0u && v14;
          uint64_t v41 = *(unsigned __int8 *)(v3 + ((v8 + v33 + 495) & v5));
          ++*(&v56 + 256 * v40 + v41);
          ++v55[v40];
        }

        if (v33)
        {
          unint64_t v42 = v8 + v33;
          if (v33 == 1) {
            unint64_t v43 = 0LL;
          }
          else {
            unint64_t v43 = *(unsigned __int8 *)(v3 + ((v42 - 2) & v5));
          }
          unsigned int v45 = *(unsigned __int8 *)(v3 + ((v42 - 1) & v5));
          BOOL v46 = v43 >= 0xE0 && v14;
          if (v45 > 0xBF) {
            BOOL v46 = v14;
          }
          BOOL v44 = (v45 & 0x80) != 0 && v46;
        }

        else
        {
          BOOL v44 = 0LL;
        }

        unsigned int v47 = &v56 + 256 * v44;
        else {
          unint64_t v48 = v47[*(unsigned __int8 *)(v3 + ((v8 + v33) & v5))];
        }
        unint64_t v49 = v55[v44];
        if (v49 > 0xFF) {
          double v50 = log2((double)v49);
        }
        else {
          double v50 = kBrotliLog2Table[v49];
        }
        if (v48 > 0xFF) {
          double v51 = log2((double)v48);
        }
        else {
          double v51 = kBrotliLog2Table[v48];
        }
        double v52 = v50 - v51 + 0.02905;
        if (v52 < 1.0) {
          double v52 = v52 * 0.5 + 0.5;
        }
        if (v33 <= 0x7CF) {
          double v52 = (double)v34 / -2000.0 * 0.35 + 0.7 + v52;
        }
        float v53 = v52;
        *(float *)(v54 + 4 * v33++) = v53;
        --v34;
      }

      while (v7 != v33);
    }
  }

  else
  {
    bzero(&v56, 0x800uLL);
    if (v7 >= 0x7D0) {
      unint64_t v15 = 2000LL;
    }
    else {
      unint64_t v15 = v7;
    }
    if (v15)
    {
      uint64_t v16 = v8;
      unint64_t v17 = v15;
      do
      {
        ++*(&v56 + *(unsigned __int8 *)(v3 + (v16++ & v5)));
        --v17;
      }

      while (v17);
    }

    if (v7)
    {
      unint64_t v18 = 0LL;
      do
      {
        if (v18 >= 0x7D0)
        {
          uint64_t v19 = *(unsigned __int8 *)(v3 + ((v8 + v18 - 2000) & v5));
          --*(&v56 + v19);
          --v15;
        }

        unint64_t v20 = v18 + 2000;
        if (v18 + 2000 < v7)
        {
          uint64_t v21 = *(unsigned __int8 *)(v3 + ((v8 + v18 + 2000) & v5));
          ++*(&v56 + v21);
          ++v15;
        }

        else {
          unint64_t v22 = *(&v56 + *(unsigned __int8 *)(v3 + ((v8 + v18) & v5)));
        }
        if (v15 > 0xFF) {
          double v23 = log2((double)v15);
        }
        else {
          double v23 = kBrotliLog2Table[v15];
        }
        if (v22 > 0xFF) {
          double v24 = log2((double)v22);
        }
        else {
          double v24 = kBrotliLog2Table[v22];
        }
        double v25 = v23 - v24 + 0.029;
        if (v25 < 1.0) {
          double v25 = v25 * 0.5 + 0.5;
        }
        float v26 = v25;
        *(float *)(v54 + 4 * v18++) = v26;
      }

      while (v20 - 1999 != v7);
    }
  }

uint64_t lz24_encode_scratch_buffer_size()
{
  return 279532LL;
}

unint64_t lz24_encode_buffer( char *a1, unint64_t a2, char *a3, unint64_t a4, char *__b, int a6)
{
  unint64_t result = 0LL;
  if (!HIDWORD(a4) && (a6 - 32) >= 0xFFFFFFE1)
  {
    if ((a2 & 0x8000000000000000LL) != 0 || a2 < 4)
    {
      return 0LL;
    }

    else
    {
      *(_DWORD *)a1 = a4;
      unint64_t v9 = a1 + 4;
      int8x16_t v87 = a1;
      if ((_DWORD)a4)
      {
        uint64_t v10 = __b;
        uint64_t v12 = __b + 279520;
        uint64_t v13 = __b + 213488;
        unsigned int v89 = &a1[a2];
        BOOL v14 = __b + 0x20000;
        int v90 = a6 - 1;
        __dst = __b + 147456;
        int v88 = a4 + (_DWORD)a3;
        int v91 = a4;
        unsigned int v15 = a4;
        uint64_t v16 = a3;
        int8x16_t v98 = __b + 279520;
        int8x16_t v97 = __b + 0x10000;
        while (1)
        {
          unsigned int v94 = v15;
          if (v15 >= 0x1000) {
            size_t v17 = 4096LL;
          }
          else {
            size_t v17 = v15;
          }
          unsigned int v18 = *((_DWORD *)v12 + 1);
          if (v18 > 0x7F || (*((_DWORD *)v12 + 2) ^ v18) != 0xE11CCA)
          {
            unsigned int v18 = 0;
            *((_DWORD *)v12 + 1) = 0;
          }

          unsigned int v95 = v18;
          int8x16_t __src = v16;
          unint64_t v19 = v16 - a3;
          if ((((_DWORD)v16 - (_DWORD)a3) & 0x7FFFFFFF) == 0) {
            unint64_t result = (unint64_t)memset(v10, (v19 >> 24) - 2, 0x10000uLL);
          }
          uint64_t v20 = (v17 + v19);
          if (v20 > v19)
          {
            unint64_t v21 = ((_DWORD)v16 - (_DWORD)a3);
            unsigned int v22 = v88 - (_DWORD)v16;
            do
            {
              double v23 = &v14[4 * (v21 & 0xFFF)];
              *(_WORD *)double v23 = 0;
              unint64_t v24 = (v91 - v21);
              if (v24 >= 4)
              {
                unsigned int v25 = *((_DWORD *)v10 + ((-1640531535 * *(_DWORD *)&a3[v21]) >> 18));
                __int16 v26 = v21 - v25;
                unsigned int v27 = (v21 - v25) >> 14;
                if (v27)
                {
                  unsigned int v27 = 0;
                }

                else
                {
                  int v28 = 64;
                  while (v28)
                  {
                    unint64_t result = 0LL;
                    --v28;
                    char v29 = 1;
                    while (1)
                    {
                      char v30 = v29;
                      if (result + 16 > v24) {
                        break;
                      }
                      int8x16_t v31 = veorq_s8(*(int8x16_t *)&a3[v25 + result], *(int8x16_t *)&a3[v21 + result]);
                      if (*(_OWORD *)&v31 != 0LL)
                      {
                        unsigned int v33 = (__clz(__rbit64(v31.u64[1])) >> 3) + 8;
                        unsigned int v34 = __clz(__rbit64(v31.u64[0])) >> 3;
                        if (v31.i64[0]) {
                          unsigned int v33 = v34;
                        }
                        unint64_t result = v33 + result;
                        else {
                          LODWORD(v32) = result;
                        }
                        goto LABEL_40;
                      }

                      char v29 = 0;
                      unint64_t result = 16LL;
                      if ((v30 & 1) == 0)
                      {
LABEL_33:
                        LODWORD(v32) = 31;
                        goto LABEL_40;
                      }
                    }

                    if (result <= v22) {
                      unint64_t v32 = v22;
                    }
                    else {
                      unint64_t v32 = result;
                    }
                    while (v32 != result)
                    {
                      if (a3[(v21 + result)] != a3[v25 + result])
                      {
                        LODWORD(v32) = result;
                        break;
                      }

                      if (++result == 31) {
                        goto LABEL_33;
                      }
                    }

uint64_t lz4raw_encode_buffer(int32x4_t *a1, uint64_t a2, char *a3, unint64_t a4, void *__b)
{
  unsigned int v15 = a1;
  uint64_t v16 = a3;
  unint64_t v6 = a1;
  if (!a4) {
    return (char *)v6 - (char *)a1;
  }
  unint64_t v8 = a4;
  uint64_t v9 = (uint64_t)a3;
  unint64_t v11 = a1;
  while (1)
  {
    memset_pattern8(__b, &unk_181076880, 0x8000uLL);
    unint64_t v12 = v8 >= 0x7FFFF000 ? 2147479552LL : v8;
    lz4_encode_2gb(&v15, a2, &v16, v9, v12, (uint64_t)__b, v8 > 0x7FFFF000);
    unint64_t v6 = v15;
    unint64_t v13 = (unint64_t)&v16[-v9];
    if (v8 <= 0x7FFFF000 && v12 > v13) {
      break;
    }
    if (v8 >= 0x7FFFF001 && (v12 - v13) >> 16) {
      break;
    }
    a2 = &v11->i8[a2] - (__int8 *)v15;
    uint64_t v9 = (uint64_t)v16;
    unint64_t v11 = v15;
    v8 -= v13;
    if (!v8) {
      return (char *)v6 - (char *)a1;
    }
  }

  return 0LL;
}

char *lz4raw_decode_buffer(char *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v9 = a1;
  uint64_t v10 = a3;
  if (a2 >= 0x81
    && a4 >= 0x81
    && lz4_decode_asm( (int8x16_t **)&v9,  (unint64_t)a1,  (unint64_t)&a1[a2 - 128],  &v10,  (unint64_t)&a3[a4 - 128])
    || lz4_decode( (void **)&v9,  (unint64_t)a1,  (unint64_t)&a1[a2],  &v10,  (unint64_t)&a3[a4]))
  {
    return 0LL;
  }

  else
  {
    return (char *)(v9 - a1);
  }

uint64_t BrotliSetDepth(int a1, uint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = 0;
  uint64_t v9 = *MEMORY[0x1895F89C0];
  v8[0] = -1;
  while (1)
  {
    while (1)
    {
      uint64_t v5 = a1;
      *(_BYTE *)(a3 + *(__int16 *)(a2 + 8LL * a1 + 6)) = v4;
      if ((v4 & 0x80000000) != 0) {
        return 1LL;
      }
      while (1)
      {
        a1 = v8[v4];
        if (a1 != -1) {
          break;
        }
        BOOL v6 = (int)v4 <= 0;
        LODWORD(v4) = v4 - 1;
        if (v6) {
          return 1LL;
        }
      }

      v8[v4] = -1;
    }

    a1 = *(unsigned __int16 *)(a2 + 8LL * a1 + 4);
    uint64_t v4 = (int)v4 + 1LL;
    v8[v4] = *(__int16 *)(a2 + 8 * v5 + 6);
  }

  return 0LL;
}

uint64_t BrotliCreateHuffmanTree(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = result;
  uint64_t v45 = a2 - 1;
  uint64_t v10 = a4 + 8;
  for (unsigned int i = 1; ; i *= 2)
  {
    unint64_t v12 = 0LL;
    if (a2) {
      break;
    }
    uint64_t v22 = -1LL;
    *(void *)a4 = -1LL;
    *(void *)(a4 + 8) = -1LL;
    uint64_t v23 = 1LL;
LABEL_37:
    uint64_t v34 = 0LL;
    unsigned int v35 = (void *)(v10 - 8 * v22 + 16 * v12);
    do
    {
      unsigned int v36 = *(_DWORD *)(a4 + 8 * v34);
      unsigned int v37 = *(_DWORD *)(a4 + 8 * v23);
      BOOL v38 = v36 > v37;
      if (v36 > v37) {
        uint64_t v39 = v34;
      }
      else {
        uint64_t v39 = v34 + 1;
      }
      if (v38) {
        uint64_t v40 = v23 + 1;
      }
      else {
        uint64_t v40 = v23;
      }
      unsigned int v41 = *(_DWORD *)(a4 + 8 * v39);
      unsigned int v42 = *(_DWORD *)(a4 + 8 * v40);
      if (!v38) {
        uint64_t v23 = v34;
      }
      BOOL v43 = v41 > v42;
      if (v41 > v42) {
        uint64_t v44 = v40;
      }
      else {
        uint64_t v44 = v39;
      }
      *((_DWORD *)v35 - 2) = *(_DWORD *)(a4 + 8 * v44) + *(_DWORD *)(a4 + 8 * v23);
      *((_WORD *)v35 - 2) = v23;
      if (v43) {
        uint64_t v34 = v39;
      }
      else {
        uint64_t v34 = v39 + 1;
      }
      if (v43) {
        uint64_t v23 = v40 + 1;
      }
      else {
        uint64_t v23 = v40;
      }
      *((_WORD *)v35 - 1) = v44;
      *v35++ = -1LL;
      --v22;
    }

    while (v22);
    unint64_t result = BrotliSetDepth(2 * (int)v12 - 1, a4, a5, a3);
    if ((_DWORD)result) {
      return result;
    }
  }

  uint64_t v13 = v45;
  do
  {
    unsigned int v14 = *(_DWORD *)(v9 + 4 * v13);
    if (v14)
    {
      if (v14 <= i) {
        unsigned int v14 = i;
      }
      unint64_t v15 = a4 + 8 * v12;
      *(_DWORD *)unint64_t v15 = v14;
      ++v12;
      *(_WORD *)(v15 + 4) = -1;
      *(_WORD *)(v15 + 6) = v13;
    }

    --v13;
  }

  while (v13 != -1);
  if (v12 != 1)
  {
    if (v12 <= 0xC)
    {
      if (v12 >= 2)
      {
        uint64_t v16 = 0LL;
        for (uint64_t j = 1LL; j != v12; ++j)
        {
          uint64_t v18 = *(void *)(a4 + 8 * j);
          uint64_t v19 = v16;
          uint64_t v20 = j;
          do
          {
            unsigned int v21 = *(_DWORD *)(a4 + v19);
            if (v21 == (_DWORD)v18)
            {
            }

            else if (v21 <= v18)
            {
              break;
            }

            *(void *)(a4 + 8 * v20) = *(void *)(a4 + v19);
            v19 -= 8LL;
            --v20;
          }

          while (v20);
          *(void *)(a4 + 8 * v20) = v18;
          v16 += 8LL;
        }
      }

LABEL_36:
      *(void *)&__int128 v33 = -1LL;
      *((void *)&v33 + 1) = -1LL;
      *(_OWORD *)(a4 + 8 * v12) = v33;
      uint64_t v22 = v12 - 1;
      uint64_t v23 = v12 + 1;
      goto LABEL_37;
    }

    uint64_t v24 = 2LL * (v12 < 0x39);
LABEL_23:
    unint64_t v25 = kBrotliShellGaps[v24];
    if (v25 >= v12) {
      goto LABEL_35;
    }
    uint64_t v26 = 0LL;
    unint64_t v27 = kBrotliShellGaps[v24];
LABEL_25:
    uint64_t v28 = *(void *)(a4 + 8 * v27);
    unint64_t v29 = v27;
    if (v27 < v25) {
      goto LABEL_34;
    }
    uint64_t v30 = v26;
    unint64_t v31 = v27;
    while (1)
    {
      unsigned int v32 = *(_DWORD *)(a4 + v30);
      if (v32 == (_DWORD)v28)
      {
      }

      else if (v32 <= v28)
      {
LABEL_33:
        unint64_t v29 = v31;
LABEL_34:
        *(void *)(a4 + 8 * v29) = v28;
        ++v27;
        v26 += 8LL;
        if (v27 == v12)
        {
LABEL_35:
          if (++v24 == 6) {
            goto LABEL_36;
          }
          goto LABEL_23;
        }

        goto LABEL_25;
      }

      unint64_t v29 = v31 - v25;
      *(void *)(a4 + 8 * v31) = *(void *)(a4 + v30);
      v30 -= 8 * v25;
      unint64_t v31 = v29;
      if (v29 < v25) {
        goto LABEL_34;
      }
    }
  }

  *(_BYTE *)(a5 + *(__int16 *)(a4 + 6)) = 1;
  return result;
}

  int v47 = 0LL;
LABEL_37:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

void BrotliOptimizeHuffmanCountsForRle(uint64_t a1, int *a2, char *a3)
{
  if (a1)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    do
    {
      if (a2[v5]) {
        ++v6;
      }
      ++v5;
    }

    while (a1 != v5);
    if (v6 >= 0x10)
    {
      unint64_t v7 = a1 - 1;
      while (v7 != -1LL)
      {
        if (a2[v7--])
        {
          unint64_t v9 = 0LL;
          uint64_t v10 = 0LL;
          unint64_t v11 = v7 + 2;
          unsigned int v12 = 0x40000000;
          do
          {
            unint64_t v13 = v9;
            unsigned int v14 = a2[v10];
            if (v12 >= v14) {
              unsigned int v15 = a2[v10];
            }
            else {
              unsigned int v15 = v12;
            }
            if (v14)
            {
              ++v9;
              unsigned int v12 = v15;
            }

            ++v10;
          }

          while (v11 != v10);
          if (v9 >= 5)
          {
            if (v14) {
              unint64_t v16 = v13 + 1;
            }
            else {
              unint64_t v16 = v13;
            }
            unint64_t v17 = v7 - v16 + 2;
            BOOL v19 = v12 <= 3 && v17 <= 5 && v7 + 1 >= 2;
            if (v19)
            {
              uint64_t v20 = 0LL;
              do
              {
                if (a2[v20])
                {
                  unsigned int v21 = &a2[v20];
                  if (!v21[1])
                  {
                    if (v21[2]) {
                      v21[1] = 1;
                    }
                  }
                }

                ++v20;
              }

              while (v7 != v20);
            }

            if (v9 >= 0x1C)
            {
              bzero(a3, v7 + 2);
              size_t v22 = 0LL;
              unint64_t v23 = 0LL;
              int v24 = *a2;
              do
              {
                if (v11 == v23 || a2[v23] != v24)
                {
                  if (!v24 && v22 > 4 || v24 && v22 > 6) {
                    memset(&a3[v23 - v22], 1, v22);
                  }
                  if (v11 != v23) {
                    int v24 = a2[v23];
                  }
                  size_t v22 = 1LL;
                }

                else
                {
                  ++v22;
                }

                BOOL v19 = v23++ >= v11;
              }

              while (!v19);
              unint64_t v25 = 0LL;
              uint64_t v26 = 0LL;
              unint64_t v27 = 0LL;
              unint64_t v28 = ((a2[1] + *a2 + a2[2]) << 8) / 3u + 420;
              unint64_t v29 = a2 - 1;
              do
              {
                if (v11 == v25
                  || a3[v25]
                  || v25 && a3[v25 - 1]
                  || (uint64_t v35 = a2[v25], ((_DWORD)v35 << 8) - v28 - 1240 <= 0xFFFFFFFFFFFFF64FLL))
                {
                  if (v27 > 3 || v27 == 3 && !v26)
                  {
                    unint64_t v30 = v26 + (v27 >> 1);
                    if (v27 > v30) {
                      int v31 = 1;
                    }
                    else {
                      int v31 = v30 / v27;
                    }
                    if (v26) {
                      int v32 = v31;
                    }
                    else {
                      int v32 = 0;
                    }
                    __int128 v33 = v29;
                    do
                    {
                      *v33-- = v32;
                      --v27;
                    }

                    while (v27);
                  }

                  if (v25 >= v7)
                  {
                    if (v25 >= v11) {
                      unsigned int v34 = 0;
                    }
                    else {
                      unsigned int v34 = a2[v25] << 8;
                    }
                  }

                  else
                  {
                    unsigned int v34 = ((a2[v25 + 1] + a2[v25] + a2[v25 + 2]) << 8) / 3u + 420;
                  }

                  unint64_t v28 = v34;
                  if (v11 == v25) {
                    uint64_t v26 = 0LL;
                  }
                  else {
                    uint64_t v26 = a2[v25];
                  }
                  unint64_t v27 = 1LL;
                }

                else
                {
                  ++v27;
                  v26 += v35;
                  if (v27 >= 4)
                  {
                    unint64_t v28 = ((v26 << 8) + (v27 >> 1)) / v27;
                    if (v27 == 4) {
                      v28 += 120LL;
                    }
                  }
                }

                ++v29;
                BOOL v19 = v25++ >= v11;
              }

              while (!v19);
            }
          }

          return;
        }
      }
    }
  }

uint64_t BrotliWriteHuffmanTree(uint64_t result, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (!a2) {
    return result;
  }
  unint64_t v5 = a2;
  while (!*(_BYTE *)(result - 1 + v5))
  {
    if (!--v5)
    {
      if (a2 > 0x32)
      {
        unint64_t v5 = 0LL;
        unint64_t v16 = 0LL;
        unint64_t v17 = 0LL;
        unint64_t v18 = 2LL;
        unint64_t v19 = 2LL;
        goto LABEL_26;
      }

      return result;
    }
  }

  if (a2 <= 0x32)
  {
    BOOL v20 = 0;
    BOOL v21 = 0;
LABEL_29:
    unint64_t v22 = 0LL;
    int v23 = 8;
    while (1)
    {
      int v24 = *(unsigned __int8 *)(result + v22);
      BOOL v25 = *(_BYTE *)(result + v22) || !v21;
      BOOL v26 = !v25;
      BOOL v27 = !v20 || v24 == 0;
      BOOL v28 = v27 && !v26;
      if (v28 || v22 + 1 >= v5) {
        break;
      }
      unint64_t v29 = 1LL;
      while (*(unsigned __int8 *)(result + v22 + v29) == v24)
      {
        if (v5 - v22 == ++v29)
        {
          unint64_t v29 = v5 - v22;
          break;
        }
      }

      if (*(_BYTE *)(result + v22)) {
        goto LABEL_52;
      }
      if (v29 == 11)
      {
        *(_BYTE *)(a4 + *a3) = 0;
        *(_BYTE *)(a5 + *a3) = 0;
        unint64_t v30 = *a3 + 1;
        *a3 = v30;
        unint64_t v29 = 11LL;
        unint64_t v31 = 7LL;
LABEL_78:
        *(_BYTE *)(a4 + v30) = 17;
        *(_BYTE *)(a5 + *a3) = v31 & 7;
        unint64_t v44 = *a3;
        uint64_t v45 = *a3 + 1;
        *a3 = v45;
        if (v31 >= 8)
        {
          do
          {
            unint64_t v31 = (v31 >> 3) - 1;
            *(_BYTE *)(a4 + v45) = 17;
            *(_BYTE *)(a5 + *a3) = v31 & 7;
            unint64_t v44 = *a3;
            uint64_t v45 = *a3 + 1;
            *a3 = v45;
          }

          while (v31 > 7);
        }

        if (v44 > v30)
        {
          unint64_t v46 = v30;
          do
          {
            char v47 = *(_BYTE *)(a4 + v46);
            *(_BYTE *)(a4 + v46) = *(_BYTE *)(a4 + v44);
            *(_BYTE *)(a4 + v44) = v47;
            ++v46;
            --v44;
          }

          while (v46 < v44);
          uint64_t v45 = *a3;
        }

        for (unint64_t i = v45 - 1; v30 < i; --i)
        {
          char v49 = *(_BYTE *)(a5 + v30);
          *(_BYTE *)(a5 + v30) = *(_BYTE *)(a5 + i);
          *(_BYTE *)(a5 + i) = v49;
          ++v30;
        }

        goto LABEL_75;
      }

      unint64_t v31 = v29 - 3;
      if (v29 >= 3)
      {
        unint64_t v30 = *a3;
        goto LABEL_78;
      }

      if (v29)
      {
LABEL_73:
        uint64_t v42 = *a3;
        unint64_t v43 = v29;
        do
        {
          *(_BYTE *)(a4 + v42) = 0;
          *(_BYTE *)(a5 + *a3) = 0;
          uint64_t v42 = *a3 + 1;
          *a3 = v42;
          --v43;
        }

        while (v43);
      }

LABEL_75:
      v22 += v29;
      if (v22 >= v5) {
        return result;
      }
    }

    unint64_t v29 = 1LL;
    if (!*(_BYTE *)(result + v22)) {
      goto LABEL_73;
    }
LABEL_52:
    unint64_t v32 = v29;
    if (v23 != v24)
    {
      *(_BYTE *)(a4 + *a3) = v24;
      *(_BYTE *)(a5 + (*a3)++) = 0;
      unint64_t v32 = v29 - 1;
    }

    if (v32 == 7)
    {
      *(_BYTE *)(a4 + *a3) = v24;
      *(_BYTE *)(a5 + *a3) = 0;
      unint64_t v33 = *a3 + 1;
      *a3 = v33;
      unint64_t v32 = 6LL;
    }

    else
    {
      if (v32 < 3)
      {
        if (v32)
        {
          uint64_t v34 = *a3;
          do
          {
            *(_BYTE *)(a4 + v34) = v24;
            *(_BYTE *)(a5 + *a3) = 0;
            uint64_t v34 = *a3 + 1;
            *a3 = v34;
            --v32;
          }

          while (v32);
        }

        goto LABEL_70;
      }

      unint64_t v33 = *a3;
    }

    unint64_t v35 = v32 - 3;
    *(_BYTE *)(a4 + v33) = 16;
    *(_BYTE *)(a5 + *a3) = (v32 - 3) & 3;
    unint64_t v36 = *a3;
    uint64_t v37 = *a3 + 1;
    *a3 = v37;
    if (v35 >= 4)
    {
      do
      {
        unint64_t v35 = (v35 >> 2) - 1;
        *(_BYTE *)(a4 + v37) = 16;
        *(_BYTE *)(a5 + *a3) = v35 & 3;
        unint64_t v36 = *a3;
        uint64_t v37 = *a3 + 1;
        *a3 = v37;
      }

      while (v35 > 3);
    }

    if (v36 > v33)
    {
      unint64_t v38 = v33;
      do
      {
        char v39 = *(_BYTE *)(a4 + v38);
        *(_BYTE *)(a4 + v38) = *(_BYTE *)(a4 + v36);
        *(_BYTE *)(a4 + v36) = v39;
        ++v38;
        --v36;
      }

      while (v38 < v36);
      uint64_t v37 = *a3;
    }

    for (unint64_t j = v37 - 1; v33 < j; --j)
    {
      char v41 = *(_BYTE *)(a5 + v33);
      *(_BYTE *)(a5 + v33) = *(_BYTE *)(a5 + j);
      *(_BYTE *)(a5 + j) = v41;
      ++v33;
    }

LABEL_70:
    int v23 = v24;
    goto LABEL_75;
  }

  unint64_t v17 = 0LL;
  unint64_t v6 = 0LL;
  unint64_t v16 = 0LL;
  uint64_t v7 = 1LL;
  uint64_t v8 = 1LL;
  do
  {
    int v9 = *(unsigned __int8 *)(result + v6);
    if (v6 + 1 >= v5)
    {
      ++v6;
      unint64_t v10 = 1LL;
    }

    else
    {
      unint64_t v10 = 1LL;
      while (*(unsigned __int8 *)(result + v6 + v10) == v9)
      {
        if (v5 - v6 == ++v10)
        {
          unint64_t v10 = v5 - v6;
          break;
        }
      }

      v6 += v10;
    }

    BOOL v11 = v9 == 0;
    char v12 = !v11;
    uint64_t v13 = (v10 > 2) & v11;
    v8 += v13;
    if ((_DWORD)v13) {
      unint64_t v14 = v10;
    }
    else {
      unint64_t v14 = 0LL;
    }
    v17 += v14;
    uint64_t v15 = (v10 > 3) & v12;
    v16 += v10;
    v7 += v15;
  }

  while (v6 < v5);
  unint64_t v19 = 2 * v7;
  unint64_t v18 = 2 * v8;
LABEL_26:
  BOOL v20 = v16 > v19;
  BOOL v21 = v17 > v18;
  if (v5) {
    goto LABEL_29;
  }
  return result;
}

    ;
  }

  while (v8 - 1 < *(void *)(a1 + 64) - *(void *)a1);
LABEL_88:
  unint64_t result = 0LL;
  unint64_t v38 = 12;
LABEL_89:
  *(_DWORD *)(a1 + 48) = v38;
  return result;
}

unsigned __int8 *BrotliConvertBitDepthsToSymbols(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  memset(v14, 0, sizeof(v14));
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = a2;
    do
    {
      unsigned int v5 = *v3++;
      ++*((_WORD *)v14 + v5);
      --v4;
    }

    while (v4);
  }

  uint64_t v6 = 0LL;
  int v7 = 0;
  LOWORD(v14[0]) = 0;
  do
  {
    int v7 = 2 * (v7 + *(unsigned __int16 *)((char *)v14 + v6));
    *(_WORD *)&v13[v6 + 2] = v7;
    v6 += 2LL;
  }

  while (v6 != 30);
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
    {
      unint64_t v9 = result[i];
      if (result[i])
      {
        unsigned __int16 v10 = *(_WORD *)&v13[2 * v9];
        *(_WORD *)&v13[2 * v9] = v10 + 1;
        unint64_t v11 = BrotliReverseBits_kLut[v10 & 0xF];
        if (v9 >= 5)
        {
          for (unint64_t j = 4LL; j < v9; j += 4LL)
          {
            v10 >>= 4;
            unint64_t v11 = BrotliReverseBits_kLut[v10] | (16 * v11);
          }
        }

        *(_WORD *)(a3 + 2 * i) = v11 >> (-(char)v9 & 3);
      }
    }
  }

  return result;
}

uint64_t lzfse_decode_buffer_output_size(int *__src, uint64_t a2)
{
  uint64_t v2 = __src;
  uint64_t v3 = 0LL;
  uint64_t v4 = (char *)__src + a2;
  while (1)
  {
    uint64_t result = 0LL;
    int v6 = *v2;
    if (*v2 > 846755425)
    {
      if (v6 != 846755426)
      {
        if (v6 != 1853388386) {
          return 0LL;
        }
        uint64_t v7 = v2[2];
        uint64_t v8 = v2[1];
        uint64_t v2 = (int *)((char *)v2 + v7 + 12);
        v3 += v8;
        goto LABEL_27;
      }
    }

    else
    {
      if (v6 == 762869346)
      {
        uint64_t v12 = v2[1];
        uint64_t v2 = (int *)((char *)v2 + v12 + 8);
        v3 += v12;
        goto LABEL_27;
      }

      if (v6 != 829978210)
      {
        uint64_t result = v3;
        if (v6 != 611874402) {
          return 0LL;
        }
        return result;
      }
    }

    if (v6 == 846755426)
    {
      uint64_t v9 = *((void *)v2 + 3);
      int v10 = 1;
      uint64_t v11 = v9;
    }

    else
    {
      memcpy(__dst, v2, sizeof(__dst));
      uint64_t v11 = 772LL;
    }

    if ((char *)v2 + v11 + __dst[2] <= v4)
    {
      uint64_t v2 = (int *)((char *)v2 + v11 + __dst[2]);
      v3 += __dst[1];
LABEL_27:
      int v10 = 2;
      goto LABEL_28;
    }

LABEL_25:
    int v10 = 1;
LABEL_28:
    if (v10 != 2) {
      return 0LL;
    }
  }

        int v23 = v25 >> 61;
        unint64_t v30 = 8 * v25;
        int8x8_t v125 = v30;
        unint64_t v31 = v29 - 3;
        int8x8_t v126 = v29 - 3;
        if (v29 > 0x33) {
          goto LABEL_32;
        }
        unint64_t v32 = v29 + 13;
        unint64_t v33 = (unint64_t)(v123 + 1);
        uint64_t v34 = 51 - v29;
        while (v33 <= v124)
        {
          unint64_t v35 = *(unsigned __int16 *)(v33 - 2);
          int8x8_t v126 = v32;
          v30 |= v35 << v34;
          __int128 v123 = (unsigned __int16 *)v33;
          int8x8_t v125 = v30;
          unint64_t v36 = v32 + 16;
          v33 += 2LL;
          uint64_t v37 = v32 - 16;
          v34 -= 16;
          v32 += 16;
          if (v37 >= 33)
          {
            unint64_t v31 = v36 - 16;
            goto LABEL_32;
          }
        }

        unint64_t v31 = v32 - 16;
        if (v32 - 16 < 1) {
          return 0LL;
        }
LABEL_32:
        unint64_t v38 = 2 * v30;
        int8x8_t v125 = 2 * v30;
        char v39 = v31 - 1;
        int8x8_t v126 = v31 - 1;
        if (v30 < 0)
        {
          LODWORD(v22) = v19;
        }

        else
        {
          if (v31 > 0x31) {
            goto LABEL_40;
          }
          uint64_t v40 = v31 + 15;
          char v41 = (unint64_t)(v123 + 1);
          uint64_t v42 = 49 - v31;
          while (v41 <= v124)
          {
            unint64_t v43 = *(unsigned __int16 *)(v41 - 2);
            int8x8_t v126 = v40;
            v38 |= v43 << v42;
            __int128 v123 = (unsigned __int16 *)v41;
            int8x8_t v125 = v38;
            unint64_t v44 = v40 + 16;
            v41 += 2LL;
            uint64_t v45 = v40 - 16;
            v42 -= 16;
            v40 += 16;
            if (v45 >= 33)
            {
              char v39 = v44 - 16;
              goto LABEL_40;
            }
          }

          char v39 = v40 - 16;
          if (v40 - 16 < 16) {
            return 0LL;
          }
LABEL_40:
          int8x8_t v125 = v38 << 16;
          int8x8_t v126 = v39 - 16;
          if (v38 > 0x8000FFFFFFFFFFFFLL) {
            return 0LL;
          }
          unint64_t v22 = HIWORD(v38);
        }
      }

      v20 += v22;
      if (v20 > a2) {
        return 0LL;
      }
      unint64_t v46 = v22;
      if (v23 != 3)
      {
        if (v23 == 4)
        {
          if ((v126 & 7) != 0) {
            return 0LL;
          }
          char v47 = (char *)v123 - (v126 >> 3);
          __int128 v123 = (unsigned __int16 *)v47;
          int8x8_t v125 = 0LL;
          int8x8_t v126 = 0;
          unsigned int v48 = &v47[v22];
          memcpy((void *)(a1 + v21), v47, v22);
          __int128 v123 = (unsigned __int16 *)v48;
          goto LABEL_137;
        }

        if (!(_DWORD)v22) {
          goto LABEL_137;
        }
        if (v23 == 2)
        {
          uint64_t v56 = 0LL;
          unsigned int v57 = v126;
          uint64_t v59 = v124;
          unsigned int v58 = v125;
          unsigned int v60 = v123;
          do
          {
            if (v57 > 48)
            {
              unsigned int v62 = v60;
              int v64 = v57;
            }

            else
            {
              unsigned int v61 = 48 - v57;
              while (1)
              {
                unsigned int v62 = v60 + 1;
                uint64_t v63 = *v60;
                int v64 = v57 + 16;
                int8x8_t v126 = v57 + 16;
                v58 |= v63 << v61;
                __int128 v123 = v62;
                int8x8_t v125 = v58;
                v61 -= 16;
                unsigned int v60 = v62;
                uint8x8_t v106 = v57 < 33;
                v57 += 16;
                if (!v106) {
                  goto LABEL_66;
                }
              }

              unsigned int v62 = v60;
              int v64 = v57;
              if (v57 < 3) {
                return 0LL;
              }
            }

uint64_t lzfseDecodeV1(_DWORD *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)(a2 + 16);
  int v8 = *(_DWORD *)(a2 + 4);
  *a1 = 829978210;
  a1[1] = v8;
  unint64_t v9 = v7 >> 10;
  unsigned int v10 = v7 >> 20;
  unint64_t v11 = v7 >> 30;
  uint64_t v12 = (v7 >> 40) & 0xFFFFF;
  uint64_t v13 = (v7 >> 60) & 7;
  LOWORD(v14) = v7;
  unint64_t v15 = *(void *)(a2 + 24);
  WORD2(v14) = v10;
  uint64_t v16 = (v6 >> 20) & 0xFFFFF;
  LOWORD(v14) = v14 & 0x3FF;
  WORD1(v14) = v9 & 0x3FF;
  WORD2(v14) &= 0x3FFu;
  HIWORD(v14) = v11 & 0x3FF;
  *((void *)a1 + 4) = v14;
  a1[4] = (v6 >> 40) & 0xFFFFF;
  a1[5] = v16;
  a1[6] = v12;
  a1[7] = ((v6 >> 60) & 7) - 7;
  a1[10] = v13 - 7;
  *((_WORD *)a1 + 22) = WORD2(v15) & 0x3FF;
  *((_WORD *)a1 + 23) = (v15 >> 42) & 0x3FF;
  *((_WORD *)a1 + 24) = (v15 >> 52) & 0x3FF;
  a1[2] = v12 + v16;
  a1[3] = v6 & 0xFFFFF;
  unint64_t v17 = (unsigned __int8 *)(a2 + 32);
  unint64_t v18 = a2 + v15;
  uint64_t result = 0xFFFFFFFFLL;
  if (v18 >= a2 + 32 && v18 <= a3)
  {
    uint64_t v20 = 0LL;
    int v21 = 0;
    unsigned int v22 = 0;
    do
    {
      if ((unint64_t)v17 >= v18 || v21 > 24)
      {
        int v23 = v21;
      }

      else
      {
        do
        {
          int v23 = v21 + 8;
          int v24 = *v17++;
          v22 |= v24 << v21;
          BOOL v28 = v21 < 17;
          v21 += 8;
        }

        while (v28);
      }

      int v25 = lzfse_freq_nbits_table[v22 & 0x1F];
      if (v25 == 14)
      {
        int v26 = ((v22 >> 4) & 0x3FF) + 24;
      }

      else if (v25 == 8)
      {
        LOWORD(v26) = (v22 >> 4) + 8;
      }

      else
      {
        LOWORD(v26) = lzfse_freq_value_table[v22 & 0x1F];
      }

      int v27 = (char)v25;
      *((_WORD *)a1 + v20 + 25) = v26;
      int v21 = v23 - (char)v25;
      if (v23 < v27) {
        return 0xFFFFFFFFLL;
      }
      v22 >>= v27;
      ++v20;
    }

    while (v20 != 360);
    BOOL v28 = v17 == (unsigned __int8 *)v18 && v21 <= 7;
    int v29 = !v28;
    return (v29 << 31 >> 31);
  }

  return result;
}

uint64_t lzfse_decode_buffer_scratch_size_iboot()
{
  return 8088LL;
}

char *lzfse_decode_buffer_iboot(char *a1, uint64_t a2, char *a3, uint64_t a4, char **a5)
{
  uint64_t result = 0LL;
  *a5 = a3;
  a5[1] = a3;
  unint64_t v11 = (unint64_t)&a3[a4];
  a5[3] = a1;
  uint32x4_t v185 = a5 + 3;
  a5[2] = &a3[a4];
  a5[5] = a1;
  a5[6] = 0LL;
  a5[4] = &a1[a2];
  uint64_t v12 = a3 + 4;
  uint64_t v13 = (_DWORD *)a5 + 15;
  uint64_t v14 = (uint64_t)a5 + 110;
  uint64_t v15 = (uint64_t)a5 + 150;
  uint64_t v16 = (uint64_t)a5 + 190;
  uint64_t v17 = (uint64_t)a5 + 318;
  int8x16_t v184 = a5 + 490;
  int8x16_t v183 = a5 + 1006;
  uint32x4_t v182 = a5 + 1002;
  while (1)
  {
    uint64_t result = 0LL;
    int v18 = *(_DWORD *)a3;
    *((_DWORD *)a5 + 14) = *(_DWORD *)a3;
    if (v18 <= 846755425) {
      break;
    }
    if (v18 == 846755426) {
      goto LABEL_13;
    }
    if (v18 != 1853388386) {
      return result;
    }
    if ((lzfse_decode_lzvn_block_iboot(a5) & 0x80000000) != 0) {
      return 0LL;
    }
    a3 = *a5;
LABEL_117:
    uint64_t result = 0LL;
    unint64_t v11 = (unint64_t)a5[2];
    if ((unint64_t)a3 < v11)
    {
      uint64_t v12 = a3 + 4;
    }

    return result;
  }

  if (v18 == 762869346)
  {
    uint64_t v20 = (unsigned __int8 *)(a3 + 8);
    uint64_t v21 = *((unsigned int *)a3 + 1);
    a3 = &(*a5)[v21 + 8];
    goto LABEL_116;
  }

  if (v18 != 829978210)
  {
    if (v18 == 611874402)
    {
      *a5 = v12;
      if (*((_DWORD *)a5 + 13))
      {
        int v176 = a5[5];
        *(_DWORD *)int v176 = *((_DWORD *)a5 + 12);
        uint64_t v177 = *((unsigned int *)a5 + 13);
      }

      else
      {
        uint64_t v177 = 0LL;
        int v176 = a5[5];
      }

      return &v176[v177 - *v185];
    }

    return result;
  }

LABEL_13:
  *((_DWORD *)a5 + 208) = 0;
  if (v18 == 846755426)
  {
    uint64_t result = 0LL;
    uint64_t v19 = *((void *)a3 + 3);
    *((_DWORD *)a5 + 208) = v19;
  }

  else
  {
    memcpy(v13, a3, 0x304uLL);
    *((_DWORD *)a5 + 208) = 772;
  }

  unint64_t v22 = 0LL;
  for (uint64_t i = 110LL; i != 150; i += 2LL)
    v22 += *(unsigned __int16 *)((char *)a5 + i);
  unint64_t v24 = 0LL;
  for (uint64_t j = 150LL; j != 190; j += 2LL)
    v24 += *(unsigned __int16 *)((char *)a5 + j);
  int64x2_t v26 = 0uLL;
  int64x2_t v27 = 0uLL;
  int64x2_t v28 = 0uLL;
  int64x2_t v29 = 0uLL;
  do
  {
    uint16x8_t v30 = *(uint16x8_t *)((char *)a5 + j);
    uint32x4_t v31 = vmovl_u16(*(uint16x4_t *)v30.i8);
    uint32x4_t v32 = vmovl_high_u16(v30);
    int64x2_t v29 = (int64x2_t)vaddw_high_u32((uint64x2_t)v29, v32);
    int64x2_t v28 = (int64x2_t)vaddw_u32((uint64x2_t)v28, *(uint32x2_t *)v32.i8);
    int64x2_t v27 = (int64x2_t)vaddw_high_u32((uint64x2_t)v27, v31);
    int64x2_t v26 = (int64x2_t)vaddw_u32((uint64x2_t)v26, *(uint32x2_t *)v31.i8);
    j += 16LL;
  }

  while (j != 318);
  unint64_t v33 = vaddvq_s64(vaddq_s64(vaddq_s64(v26, v28), vaddq_s64(v27, v29)));
  int64x2_t v34 = 0uLL;
  uint64_t v35 = 318LL;
  int64x2_t v36 = 0uLL;
  int64x2_t v37 = 0uLL;
  int64x2_t v38 = 0uLL;
  do
  {
    uint16x8_t v39 = *(uint16x8_t *)((char *)a5 + v35);
    uint32x4_t v40 = vmovl_u16(*(uint16x4_t *)v39.i8);
    uint32x4_t v41 = vmovl_high_u16(v39);
    int64x2_t v38 = (int64x2_t)vaddw_high_u32((uint64x2_t)v38, v41);
    int64x2_t v37 = (int64x2_t)vaddw_u32((uint64x2_t)v37, *(uint32x2_t *)v41.i8);
    int64x2_t v36 = (int64x2_t)vaddw_high_u32((uint64x2_t)v36, v40);
    int64x2_t v34 = (int64x2_t)vaddw_u32((uint64x2_t)v34, *(uint32x2_t *)v40.i8);
    v35 += 16LL;
  }

  while (v35 != 830);
  int8x16_t v42 = vbicq_s8( (int8x16_t)xmmword_181096F40,  (int8x16_t)vmovl_u16(vcgt_u16((uint16x4_t)0x400040004000400LL, *(uint16x4_t *)((char *)a5 + 92))));
  *(int8x8_t *)v42.i8 = vorr_s8(*(int8x8_t *)v42.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
  if (v42.i32[0] | v42.i32[1] | (2 * (*((_DWORD *)a5 + 18) > 0x9C40u)) | ((*((unsigned __int16 *)a5 + 52) > 0x3Fu) << 7) | (4 * (*((_DWORD *)a5 + 19) > 0x2710u)) | ((*((unsigned __int16 *)a5 + 54) > 0xFFu) << 9) | ((*((unsigned __int16 *)a5 + 53) > 0x3Fu) << 8) | ((v24 > 0x40) << 11) | ((v22 > 0x40) << 10) | (((unint64_t)vaddvq_s64(vaddq_s64(vaddq_s64(v34, v37), vaddq_s64(v36, v38))) > 0x400) << 13) | ((v33 > 0x100) << 12) | (*((_DWORD *)a5 + 15) != 829978210)
    || &(*a5)[*((unsigned int *)a5 + 208) + *((unsigned int *)a5 + 17)] > a5[2])
  {
    return 0LL;
  }

  int v181 = *((_DWORD *)a5 + 17);
  uint64_t v43 = 0LL;
  int v44 = 0;
  uint64_t v45 = a5 + 490;
  do
  {
    unsigned int v46 = *(unsigned __int16 *)(v17 + 2 * v43);
    if (*(_WORD *)(v17 + 2 * v43))
    {
      v44 += v46;
      if (v44 > 1024) {
        return 0LL;
      }
      signed int v47 = 0;
      char v48 = __clz(v46);
      char v49 = v48 - 21;
      unsigned int v50 = 0x800u >> (v48 - 21);
      signed int v51 = v50 - v46;
      char v52 = v48 - 22;
      unsigned int v53 = v46 - v50;
      do
      {
        int v54 = (v53 + v47) << v52;
        if (v47 >= v51)
        {
          char v55 = v52;
        }

        else
        {
          LOWORD(v54) = (((_WORD)v46 + (_WORD)v47) << v49) - 1024;
          char v55 = v49;
        }

        *(_BYTE *)uint64_t v45 = v55;
        *((_BYTE *)v45 + 1) = v43;
        *((_WORD *)v45 + 1) = v54;
        uint64_t v45 = (char **)((char *)v45 + 4);
        ++v47;
      }

      while (v46 != v47);
    }

    ++v43;
  }

  while (v43 != 256);
  uint64_t v56 = 0LL;
  unsigned int v57 = a5 + 106;
  do
  {
    unsigned int v58 = *(unsigned __int16 *)(v14 + 2 * v56);
    if (*(_WORD *)(v14 + 2 * v56))
    {
      signed int v59 = 0;
      char v60 = __clz(v58);
      char v61 = v60 - 25;
      unsigned int v62 = 0x80u >> (v60 - 25);
      signed int v63 = v62 - v58;
      char v64 = kLSymbolVBits[v56];
      int v65 = kLSymbolVBase[v56];
      char v66 = v60 - 26;
      unsigned int v67 = v58 - v62;
      do
      {
        int v68 = (v67 + v59) << v66;
        if (v59 >= v63)
        {
          char v69 = v66;
        }

        else
        {
          LOWORD(v68) = (((_WORD)v58 + (_WORD)v59) << v61) - 64;
          char v69 = v61;
        }

        *(_BYTE *)unsigned int v57 = v64 + v69;
        *((_BYTE *)v57 + 1) = v64;
        *((_WORD *)v57 + 1) = v68;
        *((_DWORD *)v57++ + 1) = v65;
        ++v59;
      }

      while (v58 != v59);
    }

    ++v56;
  }

  while (v56 != 20);
  uint64_t v70 = 0LL;
  int v71 = a5 + 170;
  do
  {
    unsigned int v72 = *(unsigned __int16 *)(v15 + 2 * v70);
    if (*(_WORD *)(v15 + 2 * v70))
    {
      signed int v73 = 0;
      char v74 = __clz(v72);
      char v75 = v74 - 25;
      unsigned int v76 = 0x80u >> (v74 - 25);
      signed int v77 = v76 - v72;
      char v78 = kMSymbolVBits[v70];
      int v79 = kMSymbolVBase[v70];
      char v80 = v74 - 26;
      unsigned int v81 = v72 - v76;
      do
      {
        int v82 = (v81 + v73) << v80;
        if (v73 >= v77)
        {
          char v83 = v80;
        }

        else
        {
          LOWORD(v82) = (((_WORD)v72 + (_WORD)v73) << v75) - 64;
          char v83 = v75;
        }

        *(_BYTE *)int v71 = v78 + v83;
        *((_BYTE *)v71 + 1) = v78;
        *((_WORD *)v71 + 1) = v82;
        *((_DWORD *)v71++ + 1) = v79;
        ++v73;
      }

      while (v72 != v73);
    }

    ++v70;
  }

  while (v70 != 20);
  uint64_t v84 = 0LL;
  __int16 v85 = a5 + 234;
  do
  {
    unsigned int v86 = *(unsigned __int16 *)(v16 + 2 * v84);
    if (*(_WORD *)(v16 + 2 * v84))
    {
      signed int v87 = 0;
      char v88 = __clz(v86);
      char v89 = v88 - 23;
      unsigned int v90 = 0x200u >> (v88 - 23);
      signed int v91 = v90 - v86;
      char v92 = kDSymbolVBits[v84];
      int v93 = kDSymbolVBase[v84];
      char v94 = v88 - 24;
      unsigned int v95 = v86 - v90;
      do
      {
        int v96 = (v95 + v87) << v94;
        if (v87 >= v91)
        {
          char v97 = v94;
        }

        else
        {
          LOWORD(v96) = (((_WORD)v86 + (_WORD)v87) << v89) - 256;
          char v97 = v89;
        }

        *(_BYTE *)__int16 v85 = v92 + v97;
        *((_BYTE *)v85 + 1) = v92;
        *((_WORD *)v85 + 1) = v96;
        *((_DWORD *)v85++ + 1) = v93;
        ++v87;
      }

      while (v86 != v87);
    }

    ++v84;
  }

  while (v84 != 64);
  *((_DWORD *)a5 + 210) = *((_DWORD *)a5 + 18);
  uint64_t v98 = (uint64_t)*a5;
  uint64_t v99 = *((unsigned int *)a5 + 208);
  unint64_t v100 = (unint64_t)&(*a5)[v99 + *((unsigned int *)a5 + 20)];
  a5[1008] = (char *)v100;
  unint64_t v101 = (unint64_t)a5[2];
  if (v100 > v101) {
    return 0LL;
  }
  a5[1010] = 0LL;
  uint16x4_t v102 = *(uint16x4_t *)((char *)a5 + 92);
  a5[1009] = (char *)v102;
  unsigned int v103 = *((_DWORD *)a5 + 22);
  unsigned int v104 = a5[1];
  if (v103)
  {
    a5[1008] = (char *)(v100 - 8);
    unint64_t v105 = *(void *)(v100 - 8);
    a5[1006] = (char *)v105;
    char v106 = v103 + 64;
    *((_DWORD *)a5 + 2014) = v103 + 64;
    if (v103 < 0xFFFFFFF8) {
      return 0LL;
    }
  }

  else
  {
    a5[1008] = (char *)(v100 - 7);
    int v107 = *(_DWORD *)(v100 - 7);
    *(_DWORD *)((char *)a5 + 8051) = *(_DWORD *)(v100 - 4);
    *int8x16_t v183 = v107;
    unint64_t v105 = (unint64_t)a5[1006] & 0xFFFFFFFFFFFFFFLL;
    a5[1006] = (char *)v105;
    char v106 = 56;
    *((_DWORD *)a5 + 2014) = 56;
  }

  uint64_t result = 0LL;
  int v108 = *((_DWORD *)a5 + 19);
  *((_DWORD *)a5 + 209) = v108;
  unint64_t v109 = v100 + *((unsigned int *)a5 + 21);
  a5[1004] = (char *)v109;
  if (v109 > v101) {
    return 0LL;
  }
  unsigned int v110 = *((unsigned __int16 *)a5 + 52);
  *((_WORD *)a5 + 4020) = v110;
  unsigned int v111 = *((unsigned __int16 *)a5 + 53);
  *((_WORD *)a5 + 4021) = v111;
  unsigned int v112 = *((unsigned __int16 *)a5 + 54);
  *((_WORD *)a5 + 4022) = v112;
  unsigned int v113 = *((_DWORD *)a5 + 25);
  if (v113)
  {
    a5[1004] = (char *)(v109 - 8);
    unint64_t v114 = *(void *)(v109 - 8);
    a5[1002] = (char *)v114;
    char v115 = v113 + 64;
    *((_DWORD *)a5 + 2006) = v113 + 64;
    if (v113 < 0xFFFFFFF8) {
      return 0LL;
    }
  }

  else
  {
    a5[1004] = (char *)(v109 - 7);
    int v116 = *(_DWORD *)(v109 - 7);
    *(_DWORD *)((char *)a5 + 8019) = *(_DWORD *)(v109 - 4);
    _DWORD *v182 = v116;
    unint64_t v114 = (unint64_t)a5[1002] & 0xFFFFFFFFFFFFFFLL;
    a5[1002] = (char *)v114;
    char v115 = 56;
    *((_DWORD *)a5 + 2006) = 56;
  }

  uint64_t result = 0LL;
  if (v114 >> v115) {
    return result;
  }
  if (v110 > 0x3F) {
    return result;
  }
  if (v111 > 0x3F) {
    return result;
  }
  BOOL v117 = __OFSUB__(v112, 255);
  if (v112 > 0xFF) {
    return result;
  }
  if (!v108)
  {
LABEL_115:
    a3 = (char *)(v98 + (v99 + v181));
LABEL_116:
    *a5 = a3;
    goto LABEL_117;
  }

  int v118 = 0;
  unsigned int v119 = 0;
  uint64_t v178 = v13;
  while (1)
  {
    int v120 = *((_DWORD *)a5 + 2006);
    int v121 = 63 - v120;
    unsigned int v122 = (63 - v120) & 0xFFFFFFF8;
    int v180 = v118;
    if ((v121 < 0) ^ v117 | ((v121 & 0xFFFFFFF8) == 0))
    {
      uint32x4_t v124 = *(char **)v182;
    }

    else
    {
      __int128 v123 = &a5[1004][-(v121 >> 3)];
      if (v123 < a5[1]) {
        return 0LL;
      }
      a5[1004] = v123;
      uint32x4_t v124 = (char *)(FSE_mask_lsb64_mtable[v122] & *(void *)v123 | ((void)a5[1002] << v122));
      a5[1002] = v124;
      v120 += v122;
      *((_DWORD *)a5 + 2006) = v120;
    }

    uint64_t result = 0LL;
    int8x8_t v125 = &a5[*((unsigned __int16 *)a5 + 4020) + 106];
    int v126 = *(unsigned __int8 *)v125;
    uint64_t v127 = *((unsigned __int8 *)v125 + 1);
    __int16 v128 = *((_WORD *)v125 + 1);
    int v129 = *((_DWORD *)v125 + 1);
    int v130 = v120 - v126;
    *((_DWORD *)a5 + 2006) = v130;
    unint64_t v131 = (unint64_t)v124 >> v130;
    unint64_t v132 = FSE_mask_lsb64_mtable[v130] & (unint64_t)v124;
    a5[1002] = (char *)v132;
    unsigned __int16 v133 = v128 + (((unint64_t)v124 >> v130) >> v127);
    unsigned int v134 = v133;
    *((_WORD *)a5 + 4020) = v133;
    uint64_t v135 = FSE_mask_lsb64_mtable[v127];
    uint64_t v136 = (uint64_t)&a5[*((unsigned __int16 *)a5 + 4021) + 170];
    int v137 = *(unsigned __int8 *)v136;
    uint64_t v138 = *(unsigned __int8 *)(v136 + 1);
    int v139 = *(unsigned __int16 *)(v136 + 2);
    int v179 = *(_DWORD *)(v136 + 4);
    LODWORD(v136) = v130 - v137;
    *((_DWORD *)a5 + 2006) = v130 - v137;
    unint64_t v140 = v132 >> (v130 - v137);
    unint64_t v141 = FSE_mask_lsb64_mtable[v130 - v137] & v132;
    a5[1002] = (char *)v141;
    int v142 = v139 + (v140 >> v138);
    *((_WORD *)a5 + 4021) = v139 + (v140 >> v138);
    uint64_t v143 = FSE_mask_lsb64_mtable[v138];
    int8x16_t v144 = &a5[*((unsigned __int16 *)a5 + 4022) + 234];
    uint64_t v145 = *((unsigned __int8 *)v144 + 1);
    LODWORD(v136) = v136 - *(unsigned __int8 *)v144;
    *((_DWORD *)a5 + 2006) = v136;
    unint64_t v146 = v141 >> v136;
    int8x16_t v147 = (char *)(FSE_mask_lsb64_mtable[(int)v136] & v141);
    __int16 v148 = *((_WORD *)v144 + 1);
    int v149 = *((_DWORD *)v144 + 1);
    a5[1002] = v147;
    *((_WORD *)a5 + 4022) = v148 + (v146 >> v145);
    if (v134 > 0x3F
      || (unsigned __int16)v142 > 0x3Fu
      || (unsigned __int16)(v148 + (v146 >> v145)) > 0xFFu)
    {
      return result;
    }

    int v150 = v129 + (v135 & v131);
    if (v150)
    {
      int v151 = *((_DWORD *)a5 + 2021);
      do
      {
        if (v151)
        {
          int v152 = *((_DWORD *)a5 + 2020);
        }

        else
        {
          unsigned int v153 = *((_DWORD *)a5 + 210);
          BOOL v155 = __OFSUB__(v153, 4);
          BOOL v154 = v153 >= 4;
          unsigned int v156 = v153 - 4;
          if (!v154) {
            return 0LL;
          }
          *((_DWORD *)a5 + 2020) = 0;
          int v157 = *((_DWORD *)a5 + 2014);
          int v158 = 63 - v157;
          unsigned int v159 = (63 - v157) & 0xFFFFFFF8;
          if ((v158 < 0) ^ v155 | ((v158 & 0xFFFFFFF8) == 0))
          {
            unint64_t v161 = *(void *)v183;
          }

          else
          {
            __int16 v160 = &a5[1008][-(v158 >> 3)];
            if (v160 < a5[1]) {
              return 0LL;
            }
            a5[1008] = v160;
            unint64_t v161 = FSE_mask_lsb64_mtable[v159] & *(void *)v160 | ((void)a5[1006] << v159);
            v157 += v159;
            *((_DWORD *)a5 + 2014) = v157;
          }

          int v162 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4036));
          int v163 = v157 - v162;
          *((_DWORD *)a5 + 2014) = v163;
          unint64_t v164 = v161 >> v163;
          unint64_t v165 = FSE_mask_lsb64_mtable[v163] & v161;
          *((_WORD *)a5 + 4036) = v164 + HIWORD(v162);
          *((_DWORD *)a5 + 2020) = BYTE1(v162);
          LODWORD(v164) = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4037));
          int v166 = v163 - v164;
          *((_DWORD *)a5 + 2014) = v166;
          unint64_t v167 = v165 >> v166;
          unint64_t v168 = FSE_mask_lsb64_mtable[v166] & v165;
          *((_WORD *)a5 + 4037) = v167 + WORD1(v164);
          LODWORD(v167) = v164 & 0xFF00 | BYTE1(v162);
          *((_DWORD *)a5 + 2020) = v167;
          int v169 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4038));
          int v170 = v166 - v169;
          *((_DWORD *)a5 + 2014) = v170;
          unint64_t v171 = v168 >> v170;
          unint64_t v172 = FSE_mask_lsb64_mtable[v170] & v168;
          *((_WORD *)a5 + 4038) = v171 + HIWORD(v169);
          LODWORD(v167) = v167 & 0xFF00FFFF | (BYTE1(v169) << 16);
          *((_DWORD *)a5 + 2020) = v167;
          int v173 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4039));
          int v174 = v170 - v173;
          *((_DWORD *)a5 + 2014) = v174;
          a5[1006] = (char *)(FSE_mask_lsb64_mtable[v174] & v172);
          *((_WORD *)a5 + 4039) = (v172 >> v174) + HIWORD(v173);
          int v152 = v167 & 0xFFFFFF | (BYTE1(v173) << 24);
          *((_DWORD *)a5 + 2020) = v152;
          *((_DWORD *)a5 + 2021) = 4;
          *((_DWORD *)a5 + 210) = v156;
        }

        *((_DWORD *)a5 + 2020) >>= 8;
        int v151 = *((_DWORD *)a5 + 2021) - 1;
        *((_DWORD *)a5 + 2021) = v151;
      }

      while (--v150);
    }

    int v118 = v180 + 1;
    unsigned int v175 = *((_DWORD *)a5 + 209);
    BOOL v117 = __OFSUB__(v180 + 1, v175);
    uint64_t v13 = v178;
    if (v180 + 1 >= v175)
    {
      LODWORD(v99) = *((_DWORD *)a5 + 208);
      uint64_t v98 = (uint64_t)*a5;
      goto LABEL_115;
    }
  }

  if (v8 > 0xFF)
  {
    uint64_t v16 = log2((double)v8);
    if (!v6) {
      return;
    }
  }

  else
  {
    uint64_t v16 = kBrotliLog2Table[v8];
    if (!v6) {
      return;
    }
  }

  uint64_t v17 = v12;
  int v18 = v16;
  uint64_t v19 = v18 + 2.0;
  do
  {
    uint64_t v21 = *v7++;
    uint64_t v20 = v21;
    if (v21)
    {
      else {
        unint64_t v22 = kBrotliLog2Table[v20];
      }
      int v23 = v22;
      unint64_t v24 = v17 - v23;
      *a4 = v24;
      if (v24 < 1.0) {
        *a4 = 1.0;
      }
    }

    else
    {
      *a4 = v19;
    }

    ++a4;
    --v6;
  }

  while (v6);
}

uint64_t lzfse_decode_lzvn_block_iboot(void *a1)
{
  unint64_t v1 = *a1 + 12LL;
  unint64_t v2 = a1[2];
  if (v1 <= v2)
  {
    uint64_t v3 = *(unsigned int *)(*a1 + 8LL);
    if (v1 + v3 <= v2)
    {
      if ((_DWORD)v3) {
        __asm { BR              X9 }
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t LZFSEIBootBufferPushN(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  unsigned int v4 = a2;
  if (*(void *)(a1 + 16) + (unint64_t)a2 <= *(void *)(a1 + 8))
  {
    if (a2)
    {
      while (*(_DWORD *)(a1 + 28))
      {
        if ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
        ++a3;
        if (!--v4) {
          return 0LL;
        }
      }

      if (v4 < 4) {
        goto LABEL_16;
      }
      uint64_t v6 = 0LL;
      uint64_t v7 = *(void *)(a1 + 16);
      do
      {
        *(_DWORD *)(v7 + v6) = *(_DWORD *)&a3[v6];
        *(void *)(a1 + 16) = v7 + v6 + 4;
        v4 -= 4;
        v6 += 4LL;
      }

      while (v4 > 3);
      if (v4)
      {
        a3 += v6;
LABEL_16:
        while ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) == 0)
        {
          ++a3;
          if (!--v4) {
            return 0LL;
          }
        }

        return 0xFFFFFFFFLL;
      }
    }

    return 0LL;
  }

  if (!a2) {
    return 0LL;
  }
  while ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) == 0)
  {
    ++a3;
    if (!--v4) {
      return 0LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t LZFSEIBootBufferPush(uint64_t a1, int a2)
{
  unint64_t v2 = *(int **)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 28);
  int v4 = (a2 << (8 * v3++)) | *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = v3;
  if (v3 != 4) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  *unint64_t v2 = v4;
  *(void *)(a1 + 16) = v2 + 1;
  *(void *)(a1 + 24) = 0LL;
  return v5;
}

uint64_t LZFSEIBootBufferCopy(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL v3 = 0;
  int v4 = a2 != 0;
  if (a3 && a2)
  {
    unsigned int v7 = 0;
    uint64_t v8 = a3;
    unint64_t v9 = (_DWORD *)(a1 + 24);
    while (1)
    {
      unsigned int v10 = *(_DWORD **)(a1 + 16);
      uint64_t v11 = *(unsigned int *)(a1 + 28);
      uint64_t v12 = (uint64_t)v10 + v11 - *(void *)a1 - v8;
      unsigned int v13 = v12 & 3;
      v12 &= 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v14 = (_DWORD *)(*(void *)a1 + v12);
      if (v12 < 0 != v3 || v14 >= v10)
      {
        BOOL v16 = v14 != v10 || v13 >= v11;
        uint64_t v14 = v9;
        if (v16) {
          break;
        }
      }

      BOOL v3 = __OFSUB__(++v7, a2);
      if (v7 >= a2)
      {
        int v4 = 0;
        return (v4 << 31 >> 31);
      }
    }

    int v4 = 1;
  }

  return (v4 << 31 >> 31);
}

uint64_t is_format_msb_layout(int a1)
{
  else {
    return dword_18109717C[a1 - 6];
  }
}

uint64_t get_format_bytes_per_pixel(int a1, unsigned int a2, int a3)
{
  return get_format_components(a1, a3) << (a2 > 8);
}

uint64_t get_format_components(int a1, int a2)
{
  unsigned __int8 v2 = 1;
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 15:
    case 16:
      return v2;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      if (a2) {
        unsigned __int8 v2 = 2;
      }
      else {
        unsigned __int8 v2 = 1;
      }
      break;
    case 13:
      unsigned __int8 v2 = 3;
      break;
    case 14:
      unsigned __int8 v2 = 4;
      break;
    default:
      unsigned __int8 v2 = 0;
      break;
  }

  return v2;
}

uint64_t get_format_convert_at_once(int a1)
{
  if (a1 == 16) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = 1;
  }
  if (a1 == 15) {
    return 2LL;
  }
  else {
    return v1;
  }
}

uint64_t get_format_process_at_once(int a1)
{
  else {
    return 2LL;
  }
}

const char *is_format_invalid(unsigned int a1, unsigned int a2, int a3, int a4)
{
  if (a1 > 0x10) {
    return "unknown format";
  }
  int v4 = "width/height is 0";
  if (a2 && a3)
  {
    if ((a3 | a2) >> 16)
    {
      return "width/height too large";
    }

    else
    {
      if (a1 - 1 > 0xA) {
        int v6 = 0;
      }
      else {
        int v6 = dword_181097198[a1 - 1];
      }
      if ((v6 & a2) != 0) {
        return "width/format invalid";
      }
      if (a1 == 16) {
        int v7 = 3;
      }
      else {
        int v7 = 0;
      }
      if (a1 == 15) {
        int v7 = 1;
      }
      if ((v7 & a2) != 0)
      {
        return "width/format invalid";
      }

      else
      {
        if (a1 > 0xA || (int v8 = 1, ((1 << a1) & 0x482) == 0)) {
          int v8 = 0;
        }
        int v4 = "height/format invalid";
        if ((v8 & a3) == 0 && (v7 & a3) == 0)
        {
          int v4 = "bits/sample invalid";
        }
      }
    }
  }

  return v4;
}

uint64_t get_format_bits(int a1, int a2)
{
  unsigned __int8 v2 = 8;
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 15:
      unsigned __int8 v2 = a2;
      break;
    case 6:
    case 10:
    case 11:
    case 12:
      else {
        unsigned __int8 v2 = a2;
      }
      break;
    case 13:
    case 14:
    case 16:
      return v2;
    default:
      unsigned __int8 v2 = 0;
      break;
  }

  return v2;
}

_DWORD *yzip_image_create(unsigned int a1, unsigned int a2, int a3, unsigned int a4)
{
  int format_plane_count = get_format_plane_count(a4);
  uint64_t result = calloc(1uLL, (32 * format_plane_count) | 0x10u);
  if (result)
  {
    result[1] = format_plane_count;
    result[2] = a4;
    if (format_plane_count)
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = (int)(a4 - 1);
      uint64_t v15 = result;
      for (uint64_t i = result + 10; ; i += 8)
      {
        if (v10)
        {
          else {
            int v13 = dword_181097198[v11];
          }
          if (a4 <= 0xA && ((1 << a4) & 0x482) != 0)
          {
            char v14 = 1;
            goto LABEL_15;
          }
        }

        else
        {
          LOBYTE(v13) = 0;
        }

        char v14 = 0;
LABEL_15:
        *(i - 2) = a1 >> v13;
        *(i - 1) = a2 >> v14;
        *uint64_t i = a3;
        if (format_plane_count == v10) {
          return v15;
        }
      }
    }
  }

  return result;
}

uint64_t get_format_plane_count(unsigned int a1)
{
  if (a1 > 0x10) {
    return 0LL;
  }
  else {
    return byte_1810971C4[a1];
  }
}

unsigned int *yzip_image_create_with_payload(unsigned int *a1, unint64_t a2)
{
  uint64_t result = header_fetch_from_payload(a1, a2);
  if (result) {
    return yzip_image_create( *((unsigned __int16 *)result + 9),  *((unsigned __int16 *)result + 10),  *((unsigned __int8 *)result + 26),  *((unsigned __int8 *)result + 16));
  }
  return result;
}

unsigned int *header_fetch_from_payload(unsigned int *a1, unint64_t a2)
{
  if (a2 < 0x12) {
    return 0LL;
  }
  uint64_t v4 = *((unsigned __int8 *)a1 + 17);
  unint64_t v5 = 10 * v4 + 18;
  if (v5 > a2) {
    return 0LL;
  }
  unint64_t v6 = *a1;
  if (v6 > a2) {
    return 0LL;
  }
  unint64_t v7 = *((unsigned __int16 *)a1 + 2);
  unsigned int v9 = a1[2];
  if (v9 != 1297111641 && v9 != 810572377) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if ((_DWORD)v4)
  {
    unsigned int v10 = *((unsigned __int8 *)a1 + 16);
    if (v10 <= 0x10)
    {
      uint64_t v11 = 0LL;
      for (uint64_t i = (unsigned __int8 *)a1 + 27; ; i += 10)
      {
        unsigned int v13 = *(unsigned __int16 *)(i - 9);
        if (!*(_WORD *)(i - 9)) {
          break;
        }
        unsigned int v14 = *(unsigned __int16 *)(i - 5);
        unsigned int v15 = *(unsigned __int16 *)(i - 7);
        if (!*(_WORD *)(i - 7)) {
          break;
        }
        unsigned int v16 = *(unsigned __int16 *)(i - 3);
        if (v16 <= 0x3F && v15 != v16) {
          break;
        }
        int v17 = *i;
        if (v4 == ++v11) {
          return a1;
        }
      }

      return 0LL;
    }
  }

  return result;
}

_DWORD *yzip_image_encode(uint64_t a1, void **a2, unsigned __int16 *a3, unint64_t a4)
{
  unint64_t v7 = (unsigned int *)a1;
  uint64_t v8 = 10LL * v7[1];
  unsigned __int16 v9 = v8 + 18;
  if (v8 + 18 > a4) {
    return 0LL;
  }
  int v10 = 810572377;
  bzero(a3, v8 + 18);
  a3[2] = v9;
  *((_DWORD *)a3 + 2) = 810572377;
  *((_DWORD *)a3 + 3) = *v7;
  *((_BYTE *)a3 + 16) = v7[2];
  *((_BYTE *)a3 + 17) = v7[1];
  if (!v7[1])
  {
    *(_DWORD *)a3 = v9 & 0xFFFE;
    int64x2_t v37 = (_DWORD *)((char *)a3 + (v9 & 0xFFFE));
    uint64_t v38 = a4 - (v9 & 0xFFFE);
    goto LABEL_60;
  }

  unsigned __int16 v52 = v9;
  unint64_t v53 = a4;
  unint64_t v11 = 0LL;
  uint64_t v12 = a3 + 9;
  unsigned int v61 = 810572377;
  uint64_t v13 = 810572377LL;
  unsigned int v58 = v7;
  signed int v59 = a3;
  int v54 = a3 + 9;
  char v55 = a2;
  do
  {
    unsigned int v14 = &v12[5 * v11];
    unsigned int v15 = &v7[8 * v11];
    unsigned int v16 = v15[8];
    unsigned int v17 = v15[9];
    *unsigned int v14 = v16;
    v14[1] = v17;
    *((_BYTE *)v14 + 8) = v15[10];
    char format_components = get_format_components(v7[2], v11);
    _OWORD v14[2] = v16;
    uint64_t v19 = v14 + 2;
    *((_BYTE *)v19 + 5) = format_components;
    v19[1] = v17;
    uint64_t v20 = 1297111641LL;
    if ((_DWORD)v13 == 1297111641)
    {
      int v21 = v61;
      goto LABEL_23;
    }

    unsigned int v62 = v19 + 1;
    signed int v63 = v19;
    unsigned __int16 v57 = v16;
    if (v11)
    {
      LOWORD(v22) = v17;
LABEL_9:
      unsigned int v23 = 1;
      unsigned int v24 = 3;
      do
      {
        unsigned int v25 = v24 - 1;
        if ((unsigned __int16)v16 <= (unsigned __int16)v22)
        {
          unsigned int v22 = (v25 + (unsigned __int16)v22) / v24;
          *unsigned int v62 = v22;
        }

        else
        {
          unsigned int v16 = (v25 + (unsigned __int16)v16) / v24;
          *signed int v63 = v16;
        }

        v23 *= v24;
        unsigned int v24 = 2;
      }

      while (v23 < 0x18);
      uint64_t v20 = v13;
      int v21 = v61;
      goto LABEL_15;
    }

    __int16 v56 = v17;
    unsigned int v28 = v7[2];
    int format_plane_count = get_format_plane_count(v28);
    if (!format_plane_count)
    {
      LOWORD(v22) = v17;
      goto LABEL_46;
    }

    int v30 = format_plane_count;
    LOWORD(v22) = v56;
    while (2)
    {
      int v60 = v10;
      unint64_t v31 = 0LL;
      int v32 = 0;
      uint64_t v33 = (int)(v28 - 1);
      do
      {
        if (!v32)
        {
          char v34 = 0;
LABEL_32:
          char v35 = 0;
          goto LABEL_37;
        }

        else {
          char v34 = byte_1810971D5[v33];
        }
        if (v28 > 0xA || ((1 << v28) & 0x482) == 0) {
          goto LABEL_32;
        }
        char v35 = 1;
LABEL_37:
        v31 += ((unint64_t)(unsigned __int16)v16 >> v34)
      }

      while (v30 != v32);
      if (v31 >= 0x600000)
      {
        unint64_t v7 = v58;
        a3 = v59;
        if ((unsigned __int16)v16 <= (unsigned __int16)v22)
        {
          unsigned int v22 = ((unsigned __int16)v22 + 1) >> 1;
          *unsigned int v62 = v22;
        }

        else
        {
          unsigned int v16 = ((unsigned __int16)v16 + 1) >> 1;
          *signed int v63 = v16;
        }

        *((_DWORD *)v59 + 2) = 1297111641;
        unsigned int v28 = v58[2];
        int v30 = get_format_plane_count(v28);
        int v10 = 1297111641;
        uint64_t v20 = 1297111641LL;
        unsigned int v61 = 1297111641;
        if (!v30)
        {
          int v21 = 1297111641;
          uint64_t v12 = v54;
          unint64_t v11 = 0LL;
          LOWORD(v17) = v56;
          goto LABEL_15;
        }

        continue;
      }

      break;
    }

    unint64_t v7 = v58;
    a3 = v59;
    uint64_t v12 = v54;
    unint64_t v11 = 0LL;
    int v10 = v60;
    LOWORD(v17) = v56;
LABEL_46:
    uint64_t v13 = v61;
    uint64_t v20 = 1297111641LL;
    int v21 = 1297111641;
    if (v61 != 1297111641) {
      goto LABEL_9;
    }
LABEL_15:
    unsigned __int16 v26 = (v16 + 7) & 0xFFF8;
    *signed int v63 = v26;
    unsigned __int16 v27 = (v22 + 7) & 0xFFF8;
    *unsigned int v62 = v27;
    if ((unsigned __int16)(v16 + 7) <= 0x3Fu)
    {
      unsigned __int16 v26 = 64;
      *signed int v63 = 64;
    }

    if ((((_WORD)v22 + 7) & 0xFFF8u) <= 0x3F)
    {
      unsigned __int16 v27 = 64;
      *unsigned int v62 = 64;
    }

uint64_t is_image_valid(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 4);
  if ((_DWORD)v1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 8);
    if ((_DWORD)v1 == get_format_plane_count(v3)
      && !is_format_invalid(v3, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unsigned __int8 *)(a1 + 40)))
    {
      for (uint64_t i = (void *)(a1 + 16); *i; i += 4)
      {
        if (!--v1) {
          return 1LL;
        }
      }
    }
  }

  return 0LL;
}

_DWORD *create_rectangle_within_image( uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unint64_t v6 = yzip_image_create(a4, a5, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 8));
  if (v6)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 4);
    if ((_DWORD)v7)
    {
      int v8 = 0;
      unint64_t v9 = 0LL;
      uint64_t v19 = 32 * v7;
      do
      {
        if (v9)
        {
          unsigned int v10 = *(_DWORD *)(a1 + 8);
          if (v10 - 1 > 0xA) {
            char v11 = 0;
          }
          else {
            char v11 = byte_1810971D5[v10 - 1];
          }
          BOOL v13 = v10 > 0xA;
          int v14 = (1 << v10) & 0x482;
          char v12 = !v13 && v14 != 0;
        }

        else
        {
          char v11 = 0;
          char v12 = 0;
        }

        uint64_t v16 = *(void *)(a1 + v9 + 16);
        *(void *)&v6[v9 / 4 + 6] = *(void *)(a1 + v9 + 24);
        unsigned int v17 = *(unsigned __int8 *)(a1 + v9 + 40);
        *(void *)&v6[v9 / 4 + 4] = v16
                                   + (get_format_components(v6[2], v8) << (v17 > 8))
        v9 += 32LL;
        ++v8;
      }

      while (v19 != v9);
    }
  }

  return v6;
}

uint64_t yzip_image_decode(_DWORD *a1, void **a2, unsigned int *a3, unint64_t a4)
{
  int v8 = header_fetch_from_payload(a3, a4);
  if (!v8) {
    return 0LL;
  }
  unint64_t v9 = (unsigned __int16 *)v8;
  uint64_t v10 = a1[1];
  uint64_t v11 = *((unsigned __int16 *)v8 + 2);
  if ((_DWORD)v10)
  {
    char v12 = a1 + 10;
    BOOL v13 = (unsigned __int16 *)v8 + 9;
    while (*((void *)v12 - 3) && *(v12 - 2) == *v13 && *(v12 - 1) == v13[1] && *v12 == *((unsigned __int8 *)v13 + 8))
    {
      v12 += 8;
      v13 += 5;
      if (!--v10) {
        goto LABEL_10;
      }
    }

    return 0LL;
  }

uint64_t yzip_image_get_descriptor(int *a1, uint64_t a2)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1[1];
  if (!(_DWORD)v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
  uint64_t v5 = 32 * v2;
  do
  {
    v4 += *(void *)&a1[v3 / 4 + 6] * a1[v3 / 4 + 9];
    v3 += 32LL;
  }

  while (v5 != v3);
  uint64_t v6 = 0LL;
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = *((void *)a1 + 4);
  *(_DWORD *)(a2 + 16) = a1[10];
  *(_DWORD *)(a2 + 20) = a1[1];
  int v7 = *a1;
  *(_DWORD *)(a2 + 24) = a1[2];
  *(_DWORD *)(a2 + 28) = v7;
  return v6;
}

uint64_t yzip_image_get_plane_descriptor(uint64_t a1, unsigned int a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (!a1 || *(_DWORD *)(a1 + 4) <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  uint64_t v5 = a1 + 32LL * a2;
  uint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = *(void *)(v5 + 24);
  uint64_t v9 = v5 + 32;
  LODWORD(v5) = *(_DWORD *)(v5 + 32);
  uint64_t v8 = *(unsigned int *)(v9 + 4);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v7 * v8;
  *(void *)(a3 + 16) = v7;
  *(_DWORD *)(a3 + 24) = v5;
  *(_DWORD *)(a3 + 28) = v8;
  return result;
}

uint64_t yzip_image_get_max_payload_size(_DWORD *a1)
{
  if (!a1) {
    return 0LL;
  }
  unsigned int v2 = a1[1];
  uint64_t v3 = 10LL * v2 + 18;
  if (v2)
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = a1 + 10;
    do
    {
      uint64_t v6 = get_plane_max_rice_size(*v5) + v3;
      int v7 = *(v5 - 2);
      int v8 = *(v5 - 1);
      int v9 = *v5;
      v5 += 8;
      uint64_t v3 = v6 + get_max_payload_size(v7, v8, a1[2], v9, v4++);
    }

    while (v4 < a1[1]);
  }

  return v3;
}

uint64_t yzip_image_set_data(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 4);
    if ((_DWORD)v4)
    {
      unint64_t v5 = 0LL;
      uint64_t v6 = a1 + 24;
      uint64_t v7 = *(unsigned int *)(a1 + 4);
      do
      {
        *(void *)(v6 - 8) = v5 + a2;
        v5 += *(void *)v6 * *(unsigned int *)(v6 + 12);
        v6 += 32LL;
        --v7;
      }

      while (v7);
      BOOL v8 = v5 > a3;
      int v9 = v5 > a3;
      if (v8)
      {
        uint64_t v10 = (void *)(a1 + 16);
        do
        {
          *uint64_t v10 = 0LL;
          v10 += 4;
          --v4;
        }

        while (v4);
        int v9 = 1;
      }
    }

    else
    {
      int v9 = 0;
    }

    return (v9 << 31 >> 31);
  }

  return v3;
}

uint64_t yzip_image_set_plane_data( uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a3 && a4)
  {
    if (*(_DWORD *)(a1 + 4) <= a2) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v10 = a1 + 16;
    uint64_t v11 = a2;
    uint64_t v12 = a1 + 16 + 32LL * a2;
    unsigned int v13 = *(_DWORD *)(v12 + 16);
    unsigned int v14 = *(unsigned __int8 *)(v12 + 24);
    int format_components = get_format_components(*(_DWORD *)(a1 + 8), a2);
    if (HIWORD(v13)) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v16 = *(unsigned int *)(v12 + 20);
    if (WORD1(v16)) {
      return 0xFFFFFFFFLL;
    }
    if (a5)
    {
    }

    else
    {
      a5 = v13 * (unint64_t)(format_components << (v14 > 8));
    }

    if (a5 * v16 <= a4)
    {
      uint64_t result = 0LL;
      *(void *)uint64_t v12 = a3;
      *(void *)(v10 + 32 * v11 + 8) = a5;
      return result;
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

_DWORD *yzip_image_set_identifier(_DWORD *result, int a2)
{
  if (result) {
    *uint64_t result = a2;
  }
  return result;
}

unint64_t smb_lz77h_decode_buffer( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char *a5)
{
  unint64_t v6 = 0LL;
  unint64_t v7 = 0LL;
  uint64_t v79 = *MEMORY[0x1895F89C0];
  uint64_t v8 = 15LL;
  if (a2 > 0xF) {
    uint64_t v8 = a2;
  }
  int v9 = a5 + 5120;
  uint64_t v10 = a5 + 4096;
  uint64_t v11 = a5 + 5121;
  __int128 v12 = 0uLL;
  v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  unint64_t v74 = a2;
  unint64_t v75 = a4;
  uint64_t v73 = a3;
  unint64_t v71 = a1 + v8 - 15;
LABEL_4:
  unint64_t v14 = v7 + 256;
  if (v7 + 256 > a4)
  {
    if (v6 != a2) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v15 = (int8x16_t *)(a3 + v7);
    __int16 v78 = 0;
    unint64_t v16 = -32LL;
    __int128 v76 = v12;
    __int128 v77 = v12;
    do
    {
      int8x16_t v17 = *v15++;
      int8x16_t v18 = vandq_s8(v17, v13);
      int8x16_t v19 = (int8x16_t)vshrq_n_u8((uint8x16_t)v17, 4uLL);
      unsigned int v20 = (int8x16_t *)&a5[v16];
      v20[323] = vzip2q_s8(v18, v19);
      v20[322] = vzip1q_s8(v18, v19);
      v16 += 32LL;
    }

    while (v16 < 0x1E0);
    unint64_t v21 = 0LL;
    do
    {
      unsigned int v22 = (char *)&v76 + 2 * v11[v21 - 1];
      ++*((_WORD *)v22 + 1);
      unsigned int v23 = (char *)&v76 + 2 * v11[v21];
      ++*((_WORD *)v23 + 1);
      unsigned int v24 = (char *)&v76 + 2 * v11[v21 + 1];
      ++*((_WORD *)v24 + 1);
      uint64_t v25 = (char *)&v76 + 2 * v11[v21 + 2];
      ++*((_WORD *)v25 + 1);
      BOOL v26 = v21 >= 0x1FC;
      v21 += 4LL;
    }

    while (!v26);
    int v27 = 0;
    WORD1(v76) = 0;
    for (uint64_t i = 4LL; i != 34; i += 2LL)
    {
      v27 += *(unsigned __int16 *)((char *)&v76 + i);
      *(_WORD *)((char *)&v76 + i) = v27;
    }

    uint64_t v29 = 0LL;
    LOWORD(v76) = v78;
    do
    {
      uint64_t v30 = v9[v29];
      uint64_t v31 = *((unsigned __int16 *)&v76 + v30);
      *((_WORD *)&v76 + v30) = v31 + 1;
      *(_WORD *)&v10[2 * v31] = v30 + 16 * v29++;
    }

    while (v29 != 512);
    uint64_t v32 = HIWORD(v77);
    if (HIWORD(v77))
    {
      bzero(a5, 0x800uLL);
      int v33 = 0x8000;
      unint64_t v34 = 1024LL;
      while (1)
      {
        int v35 = v33;
        __int16 v36 = *(_WORD *)&a5[2 * v32 + 4094];
        unsigned int v37 = v36 & 0xF;
        v33 += -1 << (v36 & 0xF ^ 0xF);
        if (v33 < 0) {
          break;
        }
        int v38 = v33 >> 5;
        if (v37 > 0xA)
        {
          unsigned int v41 = *(unsigned __int16 *)&a5[2 * v38];
          if (!*(_WORD *)&a5[2 * v38])
          {
            LOWORD(v41) = v37 | (16 * v34);
            *(_WORD *)&a5[2 * v38] = v41;
            v34 += (1 << (v37 - 10));
            if (v34 > 0x800) {
              return 0LL;
            }
            unsigned int v41 = (unsigned __int16)v41;
          }

          uint64_t v42 = (v33 >> (v41 & 0xF ^ 0xF)) & ~(-1 << ((v41 & 0xF) - 10));
          unint64_t v43 = (1 << ((v41 & 0xF) - v37)) + (v41 >> 4) + v42;
          unint64_t v44 = v42 + (v41 >> 4);
          do
            *(_WORD *)&a5[2 * v44++] = v36;
          while (v44 < v43);
        }

        else if (v38 < v35 >> 5)
        {
          unsigned int v39 = &a5[2 * v38];
          uint64_t v40 = (v35 >> 5) - (uint64_t)v38;
          do
          {
            *(_WORD *)unsigned int v39 = v36;
            v39 += 2;
            --v40;
          }

          while (v40);
        }

        BOOL v63 = v32-- <= 1;
        if (v63)
        {
          if (v33) {
            return 0LL;
          }
          unint64_t v45 = v7 + 258;
          a4 = v75;
          if (v7 + 258 > v75) {
            return 0LL;
          }
          v7 += 260LL;
          if (v7 > v75) {
            return 0LL;
          }
          a3 = v73;
          a2 = v74;
          unsigned int v46 = *(unsigned __int16 *)(v73 + v45) | (*(unsigned __int16 *)(v73 + v14) << 16);
          if (v6 + 0x10000 >= v74) {
            unint64_t v47 = v74;
          }
          else {
            unint64_t v47 = v6 + 0x10000;
          }
          int v48 = 16;
          if (v6 < v47)
          {
            __int128 v12 = 0uLL;
            v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
            v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
            while (1)
            {
              unsigned int v49 = *(unsigned __int16 *)&a5[2 * (v46 >> 22)];
              if (v49 >= 0x4000) {
                unsigned int v49 = *(unsigned __int16 *)&a5[2 * (v46 << 10 >> (42 - (v49 & 0xF))) + 2 * (v49 >> 4)];
              }
              unsigned int v50 = v46 << (v49 & 0xF);
              v48 -= v49 & 0xF;
              if (v48 < 0)
              {
                if (v7 + 2 > v75) {
                  return 0LL;
                }
                v50 |= *(unsigned __int16 *)(v73 + v7) << -(char)v48;
                v48 += 16;
                v7 += 2LL;
              }

              unsigned int v51 = v49 >> 4;
              if (v49 > 0xFFF)
              {
                if (v51 == 256 && v7 == v75) {
                  return v6;
                }
                unint64_t v53 = v49 >> 4;
                if ((_DWORD)v53 == 15)
                {
                  if (v7 >= v75) {
                    return 0LL;
                  }
                  unint64_t v54 = v7 + 1;
                  unint64_t v55 = *(unsigned __int8 *)(v73 + v7);
                  if (v55 == 255)
                  {
                    unint64_t v56 = v7 + 3;
                    if (v7 + 3 > v75) {
                      return 0LL;
                    }
                    unint64_t v57 = *(unsigned __int16 *)(v73 + v54);
                    if (!*(_WORD *)(v73 + v54))
                    {
                      if (v7 + 7 > v75) {
                        return 0LL;
                      }
                      unint64_t v57 = *(unsigned int *)(v73 + v56);
                      unint64_t v56 = v7 + 7;
                    }

                    BOOL v26 = v57 >= 0xF;
                    unint64_t v55 = v57 - 15;
                    if (!v26) {
                      return 0LL;
                    }
                  }

                  else
                  {
                    unint64_t v56 = v7 + 1;
                  }

                  unint64_t v53 = v55 + 15;
                  unint64_t v7 = v56;
                }

                int v58 = (v49 >> 8) & 0xF;
                unsigned int v46 = v50 << v58;
                v48 -= v58;
                if (v48 < 0)
                {
                  if (v7 + 2 > v75) {
                    return 0LL;
                  }
                  v46 |= *(unsigned __int16 *)(v73 + v7) << -(char)v48;
                  v48 += 16;
                  v7 += 2LL;
                }

                unint64_t v59 = (HIWORD(v50) >> (16 - v58)) | (1 << v58);
                if (v6 < v59) {
                  return 0LL;
                }
                unint64_t v60 = v53 + 3;
                unsigned int v61 = (_BYTE *)(a1 + v6);
                unint64_t v62 = a1 + v6 + v53 + 3;
                BOOL v63 = v59 < 0x10 || v62 > v71;
                if (v63)
                {
                  if (v60 > v74 - v6) {
                    return 0LL;
                  }
                  uint64_t v64 = -(uint64_t)v59;
                  do
                  {
                    _BYTE *v61 = v61[v64];
                    ++v61;
                  }

                  while ((unint64_t)v61 < v62);
                }

                else
                {
                  uint64_t v65 = -(uint64_t)v59;
                  do
                  {
                    *(_OWORD *)unsigned int v61 = *(_OWORD *)&v61[v65];
                    v61 += 16;
                  }

                  while ((unint64_t)v61 < v62);
                }

                v6 += v60;
              }

              else
              {
                *(_BYTE *)(a1 + v6++) = v51;
                unsigned int v46 = v50;
              }

              if (v6 >= v47) {
                goto LABEL_77;
              }
            }
          }

          __int128 v12 = 0uLL;
          v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
LABEL_77:
          unsigned int v66 = *(unsigned __int16 *)&a5[2 * (v46 >> 22)];
          if (v66 >= 0x4000) {
            LOWORD(v66) = *(_WORD *)&a5[2 * (v46 << 10 >> (42 - (v66 & 0xF))) + 2 * (v66 >> 4)];
          }
          int v67 = v66 & 0xFFF0;
          int v68 = v66 & 0xF;
          if (v67 == 4096 && v48 < v68)
          {
            v7 += 2LL;
            if (v7 > v75) {
              return 0LL;
            }
          }

          if (v7 != v75) {
            goto LABEL_4;
          }
          return v6;
        }
      }
    }

    return 0LL;
  }

  return v6;
}

uint64_t smb_lz77h_encode_buffer(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5)
{
  uint64_t v161 = *MEMORY[0x1895F89C0];
  int v151 = (unsigned __int16 *)(a5 + 171362);
  uint64_t v145 = a5 + 170338;
  unint64_t v146 = (unsigned __int16 *)(a5 + 171876);
  uint64_t v8 = a5 + 169312;
  unsigned int v153 = (unsigned __int16 *)(a5 + 162144);
  bzero(a5, 0x10006uLL);
  uint64_t v9 = a3;
  uint64_t result = 0LL;
  unint64_t v11 = 0LL;
  __int128 v12 = a5 + 167264;
  int8x16_t v13 = a5 + 165216;
  unint64_t v14 = a5 + 168288;
  int8x16_t v144 = a5 + 161120;
  uint64_t v143 = v9 + 1;
  uint64_t v149 = v9;
  do
  {
    if (v11 >= a4) {
      return result;
    }
    uint64_t v154 = result;
    unint64_t v155 = v11;
    if (v11 + 0x10000 >= a4) {
      unint64_t v15 = a4;
    }
    else {
      unint64_t v15 = v11 + 0x10000;
    }
    if (v15 <= 8) {
      uint64_t v16 = 8LL;
    }
    else {
      uint64_t v16 = v15;
    }
    unint64_t v17 = v11 + 1;
    bzero(a5 + 152928, 0x2000uLL);
    if (v17 < v15)
    {
      int v18 = 0;
      unint64_t v19 = v16 - 8;
      unsigned int v20 = 1;
      unint64_t v21 = v17;
      uint64_t v22 = v149;
      while (1)
      {
        if (v21 + 4 <= a4)
        {
          uint64_t v23 = 0LL;
          unsigned int v24 = 0;
          uint64_t v25 = &a5[2 * ((-1640531535 * (*(_DWORD *)(v149 + v21) & 0xFFFFFFu)) >> 17)];
          uint64_t v26 = v21 & 0xFFFF0000;
          unsigned int v27 = 2;
          LOWORD(v28) = v21;
          do
          {
            uint64_t v29 = *(unsigned __int16 *)&v25[2 * v23];
            *(_WORD *)&v25[2 * v23] = v28;
            unint64_t v28 = v26 | v29;
            if (v21 != (v26 | v29))
            {
              unsigned int v30 = v28 - 0x10000;
              if (v28 < v21) {
                unsigned int v30 = v28;
              }
              if (v21 >= v19)
              {
                LODWORD(v31) = 0;
              }

              else
              {
                unint64_t v31 = 0LL;
                unsigned int v32 = 0;
                while (1)
                {
                  unint64_t v31 = *(void *)(v149 + v30 + v31) ^ *(void *)(v149 + v21 + v31);
                  if (v31) {
                    break;
                  }
                  v32 += 8;
                  unint64_t v31 = v32;
                  if (v21 + v32 >= v19) {
                    goto LABEL_24;
                  }
                }

                LODWORD(v31) = v32 + (__clz(__rbit64(v31)) >> 3);
              }

LABEL_24:
              BOOL v33 = v27 >= v31;
              if (!v33) {
                unsigned int v24 = v30;
              }
            }

            ++v23;
          }

          while (v23 != 3);
          if (v27 >= 4)
          {
            LOWORD(v34) = v21 - v24;
LABEL_34:
            *(_DWORD *)&a5[4 * (v20 >> 5) + 152928] |= 1 << v20;
            int v35 = v18 + 1;
            __int16 v36 = &a5[4 * v18 + 65542];
            *(_WORD *)__int16 v36 = v34;
            *((_WORD *)v36 + 1) = v27;
            unint64_t v37 = v21 + v27;
            unint64_t v17 = v21 + 1;
            if (v21 + 1 >= v37)
            {
              int v18 = v35;
            }

            else
            {
              uint64_t v38 = v27 - 1LL;
              do
              {
                unint64_t v39 = v21 + 1;
                if (v21 + 5 <= a4)
                {
                  uint64_t v40 = &a5[2 * ((-1640531535 * (*(_DWORD *)(v143 + v21) & 0xFFFFFFu)) >> 17)];
                  int v41 = *(_DWORD *)v40;
                  *(_WORD *)uint64_t v40 = v39;
                  *(_DWORD *)(v40 + 2) = v41;
                }

                unint64_t v21 = v39;
                --v38;
              }

              while (v38);
              int v18 = v35;
              unint64_t v17 = v37;
            }

            goto LABEL_41;
          }

          if (v27 == 3)
          {
            unint64_t v34 = v21 - v24;
            if (v34 < 0x100) {
              goto LABEL_34;
            }
          }
        }

        unint64_t v17 = v21 + 1;
LABEL_41:
        ++v20;
        unint64_t v21 = v17;
        if (v17 >= v15) {
          goto LABEL_44;
        }
      }
    }

    unsigned int v20 = 1;
    uint64_t v22 = v149;
LABEL_44:
    unint64_t v152 = v17;
    uint64_t v157 = a1 + v154;
    uint64_t v42 = v22 + v155;
    bzero(a5 + 167264, 0x400uLL);
    unsigned int v43 = 0;
    int v44 = 0;
    int v45 = 0;
    uint64_t v46 = 2176LL;
    do
    {
      if (((*(_DWORD *)&a5[4 * (v43 >> 5) + 152928] >> v43) & 1) != 0)
      {
        unint64_t v47 = &a5[4 * v44++];
        v47 += 65542;
        unsigned int v48 = *(unsigned __int16 *)v47;
        unsigned int v49 = *((unsigned __int16 *)v47 + 1);
        signed int v50 = 31 - __clz(v48);
        int v51 = v49 - 3;
        if (v49 - 3 >= 0xF) {
          int v51 = 15;
        }
        int v52 = (v51 | (16 * v50)) + 256;
        v45 += v49;
        uint64_t v53 = v46 + v50;
        ++*(_WORD *)&v12[2 * v52];
        if (v49 <= 0x110) {
          uint64_t v54 = 8LL;
        }
        else {
          uint64_t v54 = 24LL;
        }
        uint64_t v55 = v53 + v54;
        if (v49 >= 0x12) {
          uint64_t v46 = v55;
        }
        else {
          uint64_t v46 = v53;
        }
      }

      else
      {
        uint64_t v56 = *(unsigned __int8 *)(v42 + v45++);
        ++*(_WORD *)&v12[2 * v56];
      }

      ++v43;
    }

    while (v20 != v43);
    uint64_t v150 = v46;
    if (!v153[2816]) {
      v153[2816] = 1;
    }
    bzero(v151, 0x404uLL);
    uint64_t v57 = 0LL;
    int v58 = 0;
    do
    {
      unint64_t v59 = *(unsigned __int16 *)&v12[2 * v57];
      if (*(_WORD *)&v12[2 * v57])
      {
        ++v151[v59 + 1];
        ++*(unsigned __int16 *)((char *)v146 + ((v59 >> 7) & 0x1FE) + 2);
        *(_WORD *)&v8[2 * v58++] = v57;
      }

      ++v57;
    }

    while (v57 != 512);
    uint64_t v156 = v42;
    int v60 = *v151;
    int v61 = *v146;
    unint64_t v62 = (unsigned __int16 *)(a5 + 171364);
    uint64_t v63 = 255LL;
    do
    {
      v60 += *v62;
      *unint64_t v62 = v60;
      v61 += v62[257];
      v62[257] = v61;
      ++v62;
      --v63;
    }

    while (v63);
    uint64_t v64 = v58;
    if (v58 >= 1)
    {
      uint64_t v65 = (unsigned __int16 *)v8;
      uint64_t v66 = v58;
      do
      {
        int v67 = *v65++;
        uint64_t v68 = v12[2 * v67];
        uint64_t v69 = v151[v68];
        v151[v68] = v69 + 1;
        *(_WORD *)&v145[2 * v69] = v67;
        --v66;
      }

      while (v66);
      uint64_t v70 = (unsigned __int16 *)v145;
      uint64_t v71 = v58;
      do
      {
        int v72 = *v70++;
        unint64_t v73 = ((unint64_t)*(unsigned __int16 *)&v12[2 * v72] >> 7) & 0x1FE;
        uint64_t v74 = *(unsigned __int16 *)((char *)v146 + v73);
        *(unsigned __int16 *)((char *)v146 + v73) = v74 + 1;
        *(_WORD *)&v8[2 * v74] = v72;
        --v71;
      }

      while (v71);
    }

    memcpy(a5 + 165216, a5 + 167264, 0x400uLL);
    v153[2048] = -1;
    *(_WORD *)&v8[2 * v58] = 512;
    uint64_t v75 = (v58 + 511);
    uint64_t v76 = (int)v75;
    else {
      int v77 = v58 + 511;
    }
    if (v58 > 1)
    {
      int v120 = 0;
      uint64_t v121 = (v77 + 1);
      unsigned int v122 = (char *)v14 + v75;
      uint64_t v123 = 513LL;
      int v124 = 513;
      int8x8_t v125 = &a5[4 * v75 + 161118];
      __int128 v78 = 0uLL;
      while (1)
      {
        do
        {
          *(_WORD *)&v13[2 * v123] = -1;
          int v126 = *(unsigned __int16 *)&v8[2 * v120];
          unsigned int v127 = *(unsigned __int16 *)&v13[2 * *(unsigned __int16 *)&v8[2 * v120]];
          unsigned int v128 = *(unsigned __int16 *)&v13[2 * v124];
          BOOL v129 = v127 > v128;
          if (v127 <= v128) {
            int v130 = v124;
          }
          else {
            int v130 = v124 + 1;
          }
          if (v129) {
            int v126 = v124;
          }
          else {
            ++v120;
          }
          unsigned int v131 = *(unsigned __int16 *)&v13[2 * *(unsigned __int16 *)&v8[2 * v120]];
          unsigned int v132 = *(unsigned __int16 *)&v13[2 * v130];
          BOOL v133 = v131 > v132;
          if (v131 <= v132) {
            int v124 = v130;
          }
          else {
            int v124 = v130 + 1;
          }
          if (!v133) {
            int v130 = *(unsigned __int16 *)&v8[2 * v120];
          }
          *(_WORD *)&v13[2 * v123] = *(_WORD *)&v13[2 * v130] + *(_WORD *)&v13[2 * v126];
          if (!v133) {
            ++v120;
          }
          unsigned int v134 = &a5[4 * v123 + 161116];
          *(_WORD *)unsigned int v134 = v126;
          *((_WORD *)v134 + 1) = v130;
          ++v123;
        }

        while (v123 != v121);
        unsigned int v135 = 0;
        *((_OWORD *)a5 + 10548) = 0uLL;
        *((_OWORD *)a5 + 10549) = 0uLL;
        *((_OWORD *)a5 + 10546) = 0uLL;
        *((_OWORD *)a5 + 10547) = 0uLL;
        *((_OWORD *)a5 + 10544) = 0uLL;
        *((_OWORD *)a5 + 10545) = 0uLL;
        *((_OWORD *)a5 + 10542) = 0uLL;
        *((_OWORD *)a5 + 10543) = 0uLL;
        *((_OWORD *)a5 + 10540) = 0uLL;
        *((_OWORD *)a5 + 10541) = 0uLL;
        *((_OWORD *)a5 + 10538) = 0uLL;
        *((_OWORD *)a5 + 10539) = 0uLL;
        *((_OWORD *)a5 + 10536) = 0uLL;
        *((_OWORD *)a5 + 10537) = 0uLL;
        *((_OWORD *)a5 + 10534) = 0uLL;
        *((_OWORD *)a5 + 10535) = 0uLL;
        *((_OWORD *)a5 + 10532) = 0uLL;
        *((_OWORD *)a5 + 10533) = 0uLL;
        *((_OWORD *)a5 + 10530) = 0uLL;
        *((_OWORD *)a5 + 10531) = 0uLL;
        *((_OWORD *)a5 + 10528) = 0uLL;
        *((_OWORD *)a5 + 10529) = 0uLL;
        *((_OWORD *)a5 + 10526) = 0uLL;
        *((_OWORD *)a5 + 10527) = 0uLL;
        *((_OWORD *)a5 + 10524) = 0uLL;
        *((_OWORD *)a5 + 10525) = 0uLL;
        *((_OWORD *)a5 + 10522) = 0uLL;
        *((_OWORD *)a5 + 10523) = 0uLL;
        *((_OWORD *)a5 + 10520) = 0uLL;
        *((_OWORD *)a5 + 10521) = 0uLL;
        uint64_t v136 = v122;
        int v137 = v125;
        int v138 = v58 + 512;
        *unint64_t v14 = 0uLL;
        *((_OWORD *)a5 + 10519) = 0uLL;
        *((_BYTE *)v14 + v76) = 0;
        do
        {
          v135 |= 2 << *v136;
          *((_BYTE *)v14 + *((unsigned __int16 *)v137 - 1)) = *v136 + 1;
          char v139 = *v136--;
          char v140 = v139 + 1;
          unsigned int v141 = *(unsigned __int16 *)v137;
          v137 -= 4;
          *((_BYTE *)v14 + v141) = v140;
          --v138;
        }

        while (v138 > 513);
        if (v135 < 0x10000) {
          break;
        }
        for (uint64_t i = 0LL; i != 1024; i += 16LL)
          *(int16x8_t *)&v13[i] = vsubq_s16(*(int16x8_t *)&v13[i], (int16x8_t)vshrq_n_u16(*(uint16x8_t *)&v13[i], 1uLL));
        int v120 = 0;
        uint64_t v123 = 513LL;
        int v124 = 513;
      }
    }

    else
    {
      __int128 v78 = 0uLL;
      *((_OWORD *)a5 + 10548) = 0u;
      *((_OWORD *)a5 + 10549) = 0u;
      *((_OWORD *)a5 + 10546) = 0u;
      *((_OWORD *)a5 + 10547) = 0u;
      *((_OWORD *)a5 + 10544) = 0u;
      *((_OWORD *)a5 + 10545) = 0u;
      *((_OWORD *)a5 + 10542) = 0u;
      *((_OWORD *)a5 + 10543) = 0u;
      *((_OWORD *)a5 + 10540) = 0u;
      *((_OWORD *)a5 + 10541) = 0u;
      *((_OWORD *)a5 + 10538) = 0u;
      *((_OWORD *)a5 + 10539) = 0u;
      *((_OWORD *)a5 + 10536) = 0u;
      *((_OWORD *)a5 + 10537) = 0u;
      *((_OWORD *)a5 + 10534) = 0u;
      *((_OWORD *)a5 + 10535) = 0u;
      *((_OWORD *)a5 + 10532) = 0u;
      *((_OWORD *)a5 + 10533) = 0u;
      *((_OWORD *)a5 + 10530) = 0u;
      *((_OWORD *)a5 + 10531) = 0u;
      *((_OWORD *)a5 + 10528) = 0u;
      *((_OWORD *)a5 + 10529) = 0u;
      *((_OWORD *)a5 + 10526) = 0u;
      *((_OWORD *)a5 + 10527) = 0u;
      *((_OWORD *)a5 + 10524) = 0u;
      *((_OWORD *)a5 + 10525) = 0u;
      *((_OWORD *)a5 + 10522) = 0u;
      *((_OWORD *)a5 + 10523) = 0u;
      *((_OWORD *)a5 + 10520) = 0u;
      *((_OWORD *)a5 + 10521) = 0u;
      *unint64_t v14 = 0u;
      *((_OWORD *)a5 + 10519) = 0u;
      *((_BYTE *)v14 + (int)v75) = 0;
    }

    uint64_t v79 = 0LL;
    v160[0] = v78;
    v160[1] = v78;
    __int16 v159 = 0;
    v158[0] = v78;
    v158[1] = v78;
    do
    {
      uint64_t v80 = *((unsigned __int8 *)v14 + v79);
      *((_WORD *)v160 + v80) += *(_WORD *)&v12[2 * v79];
      ++*((_WORD *)v158 + v80 + 1);
      ++v79;
    }

    while (v79 != 512);
    uint64_t v81 = 0LL;
    int v82 = 0;
    uint64_t v83 = 0LL;
    WORD1(v158[0]) = 0;
    do
    {
      uint64_t v84 = (char *)v158 + 2 * v81;
      v83 += (v81 + 1) * *((unsigned __int16 *)v160 + v81 + 1);
      v82 += *((unsigned __int16 *)v84 + 2);
      *((_WORD *)v84 + 2) = v82;
      ++v81;
    }

    while (v81 != 15);
    uint64_t v85 = 0LL;
    LOWORD(v158[0]) = v159;
    do
    {
      uint64_t v86 = *((unsigned __int8 *)v14 + v85);
      uint64_t v87 = *((unsigned __int16 *)v158 + v86);
      *((_WORD *)v158 + v86) = v87 + 1;
      *(_WORD *)&a5[2 * v87 + 169312] = v85++;
    }

    while (v85 != 512);
    if (v58 >= 1)
    {
      LOWORD(v88) = 0;
      char v89 = (unsigned __int16 *)v8;
      do
      {
        int v90 = *v89++;
        __int16 v91 = a5[v90 + 168288];
        char v92 = &a5[4 * v90 + 161120];
        *(_WORD *)char v92 = (unsigned __int16)v88 >> (15 - v91);
        *((_WORD *)v92 + 1) = v91;
        int v88 = (1 << (15 - v91)) + (unsigned __int16)v88;
        --v64;
      }

      while (v64);
    }

    unint64_t v93 = 0LL;
    char v94 = (int8x16_t *)(a1 + v154);
    do
    {
      unsigned int v95 = (const char *)&v14[v93];
      int8x16x2_t v162 = vld2q_s8(v95);
      *v94++ = vorrq_s8(vshlq_n_s8(v162.val[1], 4uLL), v162.val[0]);
      BOOL v33 = v93 >= 30;
      v93 += 2LL;
    }

    while (!v33);
    uint64_t v96 = 0LL;
    int v97 = 0;
    unsigned int v98 = 0;
    unsigned int v99 = 0;
    int v100 = 16;
    uint64_t v101 = 260LL;
    uint64_t v102 = 258LL;
    uint64_t v103 = 256LL;
    do
    {
      if (((*(_DWORD *)&a5[4 * (v98 >> 5) + 152928] >> v98) & 1) != 0)
      {
        unsigned int v104 = *(unsigned __int16 *)&a5[4 * v97 + 65542];
        uint64_t v105 = *(unsigned __int16 *)&a5[4 * v97 + 65544];
        unsigned int v106 = __clz(v104);
        signed int v107 = 31 - v106;
        else {
          int v108 = v105 - 3;
        }
        unint64_t v109 = &v144[4 * (v108 | (16 * v107)) + 1024];
        int v110 = *((unsigned __int16 *)v109 + 1);
        unsigned int v111 = *(unsigned __int16 *)v109;
        if (v110 <= v100)
        {
          v111 += v99 << v110;
        }

        else
        {
          int v112 = (v111 >> (v110 - v100)) + (v99 << v100);
          v100 += 16;
          *(_WORD *)(v157 + v103) = v112;
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2LL;
        }

        if (v105 >= 0x12)
        {
          if (v105 > 0x110)
          {
            *(_DWORD *)(v157 + v101) = (((_DWORD)v105 - 3) << 8) | 0xFF;
            v101 += 3LL;
          }

          else
          {
            *(_BYTE *)(v157 + v101++) = v105 - 18;
          }
        }

        ++v97;
        uint64_t v113 = v96 + v105;
        signed int v117 = v100 - v110;
        unsigned int v99 = v104 - (0x80000000 >> v106);
        int v100 = v100 - v110 - v107;
        if (v117 >= v107)
        {
          v99 += (unsigned __int16)v111 << v107;
        }

        else
        {
          int v100 = v106 + v117 - 15;
          *(_WORD *)(v157 + v103) = (v99 >> (v107 - v117)) + ((_WORD)v111 << v117);
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2LL;
        }
      }

      else
      {
        uint64_t v113 = v96 + 1;
        unint64_t v114 = &v144[4 * *(unsigned __int8 *)(v156 + v96)];
        int v115 = *((unsigned __int16 *)v114 + 1);
        unsigned int v116 = *(unsigned __int16 *)v114;
        if (v100 >= v115)
        {
          unsigned int v99 = v116 + (v99 << v115);
          v100 -= v115;
        }

        else
        {
          *(_WORD *)(v157 + v103) = (v116 >> (v115 - v100)) + (v99 << v100);
          int v100 = v100 - v115 + 16;
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2LL;
          unsigned int v99 = v116;
        }
      }

      ++v98;
      uint64_t v96 = v113;
    }

    while (v20 != v98);
    unint64_t v11 = v152;
    if (v152 == a4)
    {
      int v118 = v153[1];
      unsigned int v119 = *v153;
      if (v100 >= v118)
      {
        unsigned int v99 = v119 + (v99 << v118);
        LOBYTE(v100) = v100 - v118;
      }

      else
      {
        *(_WORD *)(v157 + v103) = (v119 >> (v118 - v100)) + (v99 << v100);
        LOBYTE(v100) = v100 - v118 + 16;
        uint64_t v103 = v102;
        uint64_t v102 = v101;
        v101 += 2LL;
        unsigned int v99 = v119;
      }

      unint64_t v11 = v152;
    }

    *(_WORD *)(v157 + v103) = v99 << v100;
    *(_WORD *)(v157 + v102) = 0;
    uint64_t result = v101 + v154;
  }

  while (v101);
  return 0LL;
}

      uint64_t v22 = v24;
    }
  }

  return result;
}

      uint64_t v22 = v24;
    }
  }

  return result;
}

  uint64_t v16 = a1[1481];
  if (v12 == v13 || a1[46] == 4)
  {
    uint64_t v25 = a4 + 2;
    if (v16 < 14)
    {
      *((_WORD *)a1 + 2960) |= v25 << v16;
      unsigned int v32 = v16 + 3;
    }

    else
    {
      uint64_t v26 = *((_WORD *)a1 + 2960) | (v25 << v16);
      *((_WORD *)a1 + 2960) = v26;
      unsigned int v27 = *((void *)a1 + 2);
      unint64_t v28 = a1[10];
      a1[10] = v28 + 1;
      *(_BYTE *)(v27 + v28) = v26;
      LOBYTE(v26) = *((_BYTE *)a1 + 5921);
      uint64_t v29 = *((void *)a1 + 2);
      unsigned int v30 = a1[10];
      a1[10] = v30 + 1;
      *(_BYTE *)(v29 + v30) = v26;
      unint64_t v31 = a1[1481];
      *((_WORD *)a1 + 2960) = (unsigned __int16)(a4 + 2) >> (16 - v31);
      unsigned int v32 = v31 - 13;
    }

    a1[1481] = v32;
    int v44 = &static_ltree;
    int v45 = &static_dtree;
    uint64_t v46 = (uint64_t)a1;
  }

  else
  {
    unint64_t v17 = a4 + 4;
    if (v16 < 14)
    {
      uint64_t v23 = *((unsigned __int16 *)a1 + 2960) | (v17 << v16);
      unsigned int v24 = v16 + 3;
    }

    else
    {
      int v18 = *((_WORD *)a1 + 2960) | (v17 << v16);
      *((_WORD *)a1 + 2960) = v18;
      unint64_t v19 = *((void *)a1 + 2);
      unsigned int v20 = a1[10];
      a1[10] = v20 + 1;
      *(_BYTE *)(v19 + v20) = v18;
      LOBYTE(v18) = *((_BYTE *)a1 + 5921);
      unint64_t v21 = *((void *)a1 + 2);
      uint64_t v22 = a1[10];
      a1[10] = v22 + 1;
      *(_BYTE *)(v21 + v22) = v18;
      LODWORD(v21) = a1[1481];
      uint64_t v23 = (unsigned __int16)(a4 + 4) >> (16 - v21);
      unsigned int v24 = v21 - 13;
    }

    a1[1481] = v24;
    BOOL v33 = a1[724];
    unint64_t v34 = a1[730];
    int v35 = v33 + 65280;
    if (v24 < 12)
    {
      uint64_t v42 = v23 | (v35 << v24);
      unsigned int v43 = v24 + 5;
    }

    else
    {
      __int16 v36 = v23 | (v35 << v24);
      *((_WORD *)a1 + 2960) = v36;
      unint64_t v37 = *((void *)a1 + 2);
      uint64_t v38 = a1[10];
      a1[10] = v38 + 1;
      *(_BYTE *)(v37 + v38) = v36;
      LOBYTE(v36) = *((_BYTE *)a1 + 5921);
      unint64_t v39 = *((void *)a1 + 2);
      uint64_t v40 = a1[10];
      a1[10] = v40 + 1;
      *(_BYTE *)(v39 + v40) = v36;
      int v41 = a1[1481];
      uint64_t v42 = (unsigned __int16)(v33 - 256) >> (16 - v41);
      unsigned int v43 = v41 - 11;
    }

    a1[1481] = v43;
    if (v43 < 12)
    {
      int v52 = v42 | (v34 << v43);
      uint64_t v53 = v43 + 5;
    }

    else
    {
      unint64_t v47 = v42 | (v34 << v43);
      *((_WORD *)a1 + 2960) = v47;
      unsigned int v48 = *((void *)a1 + 2);
      unsigned int v49 = a1[10];
      a1[10] = v49 + 1;
      *(_BYTE *)(v48 + v49) = v47;
      LOBYTE(v47) = *((_BYTE *)a1 + 5921);
      signed int v50 = *((void *)a1 + 2);
      int v51 = a1[10];
      a1[10] = v51 + 1;
      *(_BYTE *)(v50 + v51) = v47;
      LODWORD(v50) = a1[1481];
      int v52 = (unsigned __int16)v34 >> (16 - v50);
      uint64_t v53 = v50 - 11;
    }

    a1[1481] = v53;
    uint64_t v54 = v11 + 65533;
    if (v53 < 13)
    {
      int v60 = v52 | (v54 << v53);
      *((_WORD *)a1 + 2960) = v60;
      int v61 = v53 + 4;
    }

    else
    {
      uint64_t v55 = v52 | (v54 << v53);
      *((_WORD *)a1 + 2960) = v55;
      uint64_t v56 = *((void *)a1 + 2);
      uint64_t v57 = a1[10];
      a1[10] = v57 + 1;
      *(_BYTE *)(v56 + v57) = v55;
      LOBYTE(v55) = *((_BYTE *)a1 + 5921);
      int v58 = *((void *)a1 + 2);
      unint64_t v59 = a1[10];
      a1[10] = v59 + 1;
      *(_BYTE *)(v58 + v59) = v55;
      LODWORD(v58) = a1[1481];
      int v60 = (unsigned __int16)(v11 - 3) >> (16 - v58);
      *((_WORD *)a1 + 2960) = v60;
      int v61 = v58 - 12;
    }

    a1[1481] = v61;
    if ((v11 & 0x80000000) == 0)
    {
      unint64_t v62 = v11 + 1;
      uint64_t v63 = bl_order;
      do
      {
        uint64_t v64 = *v63++;
        uint64_t v65 = HIWORD(a1[v64 + 683]);
        v60 |= v65 << v61;
        *((_WORD *)a1 + 2960) = v60;
        if (v61 < 14)
        {
          v61 += 3;
        }

        else
        {
          uint64_t v66 = *((void *)a1 + 2);
          int v67 = a1[10];
          a1[10] = v67 + 1;
          *(_BYTE *)(v66 + v67) = v60;
          uint64_t v68 = *((_BYTE *)a1 + 5921);
          uint64_t v69 = *((void *)a1 + 2);
          uint64_t v70 = a1[10];
          a1[10] = v70 + 1;
          *(_BYTE *)(v69 + v70) = v68;
          LODWORD(v69) = a1[1481];
          int v60 = v65 >> (16 - v69);
          *((_WORD *)a1 + 2960) = v60;
          int v61 = v69 - 13;
        }

        a1[1481] = v61;
        --v62;
      }

      while (v62);
    }

    send_tree((uint64_t)a1, (uint64_t)(a1 + 49), v33);
    send_tree((uint64_t)a1, (uint64_t)(a1 + 622), v34);
    uint64_t v46 = (uint64_t)a1;
    int v44 = a1 + 49;
    int v45 = a1 + 622;
  }

  compress_block(v46, (uint64_t)v44, (uint64_t)v45);
LABEL_50:
  init_block((uint64_t)a1);
  if (a4) {
    bi_windup((uint64_t)a1);
  }
}

uint16x8_t *convert_row_to_msb(uint16x8_t *result, unint64_t a2, char a3)
{
  if (a2 >= 8)
  {
    uint64_t v4 = 0LL;
    uint16x8_t v5 = (uint16x8_t)vdupq_n_s16(a3);
    unint64_t v6 = result;
    do
    {
      *unint64_t v6 = vshlq_u16(*v6, v5);
      ++v6;
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8LL;
    }

    while (v7 <= a2);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  uint64_t v8 = a2 - v3;
  if (a2 > v3)
  {
    uint64_t v9 = &result->i16[v3];
    do
    {
      *uint64_t v9 = (unsigned __int16)*v9 << a3;
      ++v9;
      --v8;
    }

    while (v8);
  }

  return result;
}

uint16x8_t *convert_row_to_lsb(uint16x8_t *result, unint64_t a2, char a3)
{
  if (a2 >= 8)
  {
    uint64_t v4 = 0LL;
    uint16x8_t v5 = (uint16x8_t)vnegq_s16(vdupq_n_s16(a3));
    unint64_t v6 = result;
    do
    {
      *unint64_t v6 = vshlq_u16(*v6, v5);
      ++v6;
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8LL;
    }

    while (v7 <= a2);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  uint64_t v8 = a2 - v3;
  if (a2 > v3)
  {
    uint64_t v9 = &result->i16[v3];
    do
    {
      *uint64_t v9 = (unsigned __int16)*v9 >> a3;
      ++v9;
      --v8;
    }

    while (v8);
  }

  return result;
}

void *(**get_conversion_set( void *(**result)(void *a1, const void *a2, uint64_t a3), int a2, unsigned int a3, int a4))(void *a1, const void *a2, uint64_t a3)
{
  *uint64_t result = 0LL;
  result[1] = 0LL;
  switch(a2)
  {
    case 13:
      uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_row_RGB888toGUV;
      uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_row_GUVtoRGB888;
      goto LABEL_17;
    case 14:
      uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_row_RGBA8888toGUVA;
      uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_row_GUVAtoRGBA8888;
      goto LABEL_17;
    case 15:
      if (a3 > 8)
      {
        uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_rows_from_bayer16;
        uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_rows_to_bayer16;
      }

      else
      {
        uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_rows_from_bayer8;
        uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_rows_to_bayer8;
      }

      goto LABEL_17;
    case 16:
      if (a3 > 8) {
        return result;
      }
      uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_rows_from_quadra8;
      uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_rows_to_quadra8;
      goto LABEL_17;
    default:
      if (a4 == 2)
      {
        if (a3 > 8)
        {
          uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_row_RGtoPlanarRG;
          uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_row_PlanarRGtoRG;
        }

        else
        {
          uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_row_RG88toRG;
          uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_row_RGtoRG88;
        }
      }

      else
      {
        if (a4 != 1) {
          return result;
        }
        if (a3 > 8)
        {
          *uint64_t result = convert_row_copy16;
          result[1] = convert_row_copy16;
          return result;
        }

        uint64_t v4 = (void *(*)(void *, const void *, uint64_t))convert_row_8to16;
        uint16x8_t v5 = (void *(*)(void *, const void *, uint64_t))convert_row_16to8;
      }

LABEL_17:
      *uint64_t result = v4;
      result[1] = v5;
      return result;
  }

  unint64_t v17 = 2LL;
  if (!BYTE3(v37[0])) {
    unint64_t v17 = 3LL;
  }
  if (BYTE1(v37[0]) | BYTE2(v37[0])) {
    int v18 = 0LL;
  }
  else {
    int v18 = v17;
  }
  unint64_t v19 = *a4;
  *(void *)(a5 + (*a4 >> 3)) = (v18 << (*a4 & 7)) | *(unsigned __int8 *)(a5 + (*a4 >> 3));
  unsigned int v20 = v19 + 2;
  *a4 = v20;
  unint64_t v21 = v14 - v18;
  if (v14 > v18)
  {
    uint64_t v22 = &BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kStorageOrder[v18];
    do
    {
      uint64_t v23 = *v22++;
      unsigned int v24 = *((unsigned __int8 *)v37 + v23);
      uint64_t v25 = BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kHuffmanBitLengthHuffmanCodeBitLengths[v24];
      uint64_t result = v20 & 7;
      *(void *)(a5 + (v20 >> 3)) = ((unint64_t)BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kHuffmanBitLengthHuffmanCodeSymbols[v24] << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
      v20 += v25;
      --v21;
    }

    while (v21);
    *a4 = v20;
  }

  if (v12 == 1) {
    *((_BYTE *)v37 + v11) = 0;
  }
  uint64_t v26 = v33;
  if (v33)
  {
    unsigned int v27 = v39;
    unint64_t v28 = v40;
    while (1)
    {
      unsigned int v30 = *v28++;
      uint64_t v29 = v30;
      unint64_t v31 = *((unsigned __int8 *)v37 + v30);
      uint64_t result = *(unsigned __int8 *)(a5 + (v20 >> 3));
      *(void *)(a5 + (v20 >> 3)) = ((unint64_t)(unsigned __int16)v36[v30] << (v20 & 7)) | result;
      v20 += v31;
      if (v30 == 16) {
        break;
      }
      if (v29 == 17)
      {
        unsigned int v32 = 3LL;
LABEL_34:
        uint64_t result = v20 & 7;
        *(void *)(a5 + (v20 >> 3)) = ((unint64_t)*v27 << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
        v20 += v32;
      }

      ++v27;
      if (!--v26)
      {
        *a4 = v20;
        return result;
      }
    }

    unsigned int v32 = 2LL;
    goto LABEL_34;
  }

  return result;
}

    uint16x8_t v5 = *(_DWORD *)(a1 + 168);
LABEL_18:
    __int128 v12 = v5 - 3;
    if (v5 < 3 || v7 > v5)
    {
      if (*(_DWORD *)(a1 + 152))
      {
        uint64_t v29 = *(unsigned __int8 *)(*(void *)(a1 + 80) + (*(_DWORD *)(a1 + 156) - 1));
        unsigned int v30 = *(unsigned int *)(a1 + 5884);
        *(_WORD *)(*(void *)(a1 + 5888) + 2 * v30) = 0;
        unint64_t v31 = *(void *)(a1 + 5872);
        *(_DWORD *)(a1 + 5884) = v30 + 1;
        *(_BYTE *)(v31 + v30) = v29;
        ++*(_WORD *)(a1 + 4 * v29 + 196);
        if (*(_DWORD *)(a1 + 5884) == *(_DWORD *)(a1 + 5880) - 1)
        {
          unsigned int v32 = *(void *)(a1 + 136);
          if (v32 < 0) {
            BOOL v33 = 0LL;
          }
          else {
            BOOL v33 = (char *)(*(void *)(a1 + 80) + v32);
          }
          _tr_flush_block((int *)a1, v33, *(unsigned int *)(a1 + 156) - v32, 0);
          *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
          flush_pending(*(void **)a1);
        }

        ++*(_DWORD *)(a1 + 156);
        --*(_DWORD *)(a1 + 164);
        goto LABEL_39;
      }

      unint64_t v34 = *(_DWORD *)(a1 + 156) + 1;
      *(_DWORD *)(a1 + 152) = 1;
      *(_DWORD *)(a1 + 156) = v34;
      --*(_DWORD *)(a1 + 164);
    }

    else
    {
      int8x16_t v13 = *(_DWORD *)(a1 + 156);
      unint64_t v14 = v13 + *(_DWORD *)(a1 + 164);
      unint64_t v15 = v13 + ~*(_DWORD *)(a1 + 148);
      uint64_t v16 = *(unsigned int *)(a1 + 5884);
      *(_WORD *)(*(void *)(a1 + 5888) + 2 * v16) = v15;
      unint64_t v17 = *(void *)(a1 + 5872);
      *(_DWORD *)(a1 + 5884) = v16 + 1;
      *(_BYTE *)(v17 + v16) = v12;
      int v18 = v15 - 1;
      unint64_t v19 = a1 + 4LL * _length_code[v12];
      ++*(_WORD *)(v19 + 1224);
      if ((v18 & 0xFF00) != 0) {
        int v18 = (v18 >> 7) + 256;
      }
      unsigned int v20 = v14 - 3;
      unsigned int v24 = a1 + 4LL * _dist_code[v18];
      ++*(_WORD *)(v24 + 2488);
      unint64_t v21 = *(_DWORD *)(a1 + 5884);
      uint64_t v22 = *(_DWORD *)(a1 + 5880) - 1;
      LODWORD(v24) = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 164) = *(_DWORD *)(a1 + 164) - v24 + 1;
      *(_DWORD *)(a1 + 168) = v24 - 2;
      uint64_t v23 = v24 - 3;
      LODWORD(v24) = *(_DWORD *)(a1 + 156) + 1;
      do
      {
        *(_DWORD *)(a1 + 156) = v24;
        if (v24 <= v20)
        {
          *(_DWORD *)(a1 + 112) = v25;
          uint64_t v26 = *(void *)(a1 + 104);
          *(_WORD *)(*(void *)(a1 + 96) + 2LL * (*(_DWORD *)(a1 + 76) & v24)) = *(_WORD *)(v26 + 2LL * v25);
          *(_WORD *)(v26 + 2LL * v25) = v24;
        }

        *(_DWORD *)(a1 + 168) = v23--;
        unsigned int v24 = (v24 + 1);
      }

      while (v23 != -1);
      *(_DWORD *)(a1 + 144) = 2;
      *(_DWORD *)(a1 + 152) = 0;
      *(_DWORD *)(a1 + 156) = v24;
      if (v21 == v22)
      {
        unsigned int v27 = *(void *)(a1 + 136);
        if (v27 < 0) {
          unint64_t v28 = 0LL;
        }
        else {
          unint64_t v28 = (char *)(*(void *)(a1 + 80) + v27);
        }
        _tr_flush_block((int *)a1, v28, v24 - v27, 0);
        *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
        flush_pending(*(void **)a1);
LABEL_39:
        if (!*(_DWORD *)(*(void *)a1 + 32LL)) {
          return 0LL;
        }
      }
    }
  }

  if (*(_DWORD *)(a1 + 152))
  {
    __int16 v36 = *(unsigned __int8 *)(*(void *)(a1 + 80) + (*(_DWORD *)(a1 + 156) - 1));
    unint64_t v37 = *(unsigned int *)(a1 + 5884);
    *(_WORD *)(*(void *)(a1 + 5888) + 2 * v37) = 0;
    uint64_t v38 = *(void *)(a1 + 5872);
    *(_DWORD *)(a1 + 5884) = v37 + 1;
    *(_BYTE *)(v38 + v37) = v36;
    ++*(_WORD *)(a1 + 4 * v36 + 196);
    *(_DWORD *)(a1 + 152) = 0;
  }

  unint64_t v39 = *(void *)(a1 + 136);
  if (v39 < 0) {
    uint64_t v40 = 0LL;
  }
  else {
    uint64_t v40 = (char *)(*(void *)(a1 + 80) + v39);
  }
  _tr_flush_block((int *)a1, v40, *(unsigned int *)(a1 + 156) - v39, a2 == 4);
  *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
  flush_pending(*(void **)a1);
  if (!*(_DWORD *)(*(void *)a1 + 32LL)) {
    return 2 * (a2 == 4);
  }
  if (a2 == 4) {
    return 3LL;
  }
  return 1LL;
}

uint64_t convert_rows_from_quadra8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2 * a4;
  uint64_t v6 = 3 * a4;
  unint64_t v7 = a3 >> 1;
  if (a3 >= 0x10)
  {
    uint64_t v10 = 0LL;
    uint64_t v8 = 0LL;
    do
    {
      unint64_t v11 = (const __int16 *)(a2 + v10);
      int16x4x2_t v36 = vld2_s16(v11);
      __int128 v12 = (const __int16 *)(a2 + v5 + v10);
      int16x4x2_t v37 = vld2_s16(v12);
      int8x16_t v13 = (const __int16 *)(a2 + a4 + v10);
      int16x4x2_t v38 = vld2_s16(v13);
      unint64_t v14 = (const __int16 *)(a2 + v6 + v10);
      int16x4x2_t v39 = vld2_s16(v14);
      *(uint16x8_t *)(result + v10) = vmovl_u8((uint8x8_t)v36.val[0]);
      *(uint16x8_t *)(result + 2 * v7 + v10) = vmovl_u8((uint8x8_t)v36.val[1]);
      *(uint16x8_t *)(result + 2 * a3 + v10) = vmovl_u8((uint8x8_t)v37.val[0]);
      *(uint16x8_t *)(result + 6 * v7 + v10) = vmovl_u8((uint8x8_t)v37.val[1]);
      *(uint16x8_t *)(result + 2 * a5 + v10) = vmovl_u8((uint8x8_t)v38.val[0]);
      *(uint16x8_t *)(result + 2 * a5 + 2 * v7 + v10) = vmovl_u8((uint8x8_t)v38.val[1]);
      *(uint16x8_t *)(result + 2 * a5 + 2 * a3 + v10) = vmovl_u8((uint8x8_t)v39.val[0]);
      *(uint16x8_t *)(result + 6 * v7 + 2 * a5 + v10) = vmovl_u8((uint8x8_t)v39.val[1]);
      v8 += 8LL;
      uint64_t v9 = v10 + 16;
      unint64_t v15 = v10 + 32;
      v10 += 16LL;
    }

    while (v15 <= a3);
  }

  else
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
  }

  if ((v9 | 4uLL) <= a3)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = result + 2 * v8;
    uint64_t v18 = v9 + v5;
    uint64_t v19 = result + 2 * v8 + 2 * a5;
    uint64_t v20 = a2 + v18;
    uint64_t v21 = result + 6 * v7 + 2 * v8;
    uint64_t v22 = a2 + v9 + a4;
    uint64_t v23 = result + 2 * v8 + 2 * a3;
    uint64_t v24 = result + 2 * (v8 + a5 + v7);
    uint64_t v25 = 2 * v8 + 2 * v7 + result + 2;
    uint64_t v26 = a2 + v9 + v6;
    uint64_t v27 = v24 + 2;
    uint64_t v28 = result + 2 * (v8 + a5 + 3 * (a3 >> 1));
    uint64_t v29 = result + 2 * (v8 + a5 + a3);
    do
    {
      *(_WORD *)(v17 + v16) = *(unsigned __int8 *)(a2 + v9 + v16);
      *(_WORD *)(result + 2 * (v8 | 1)) = *(unsigned __int8 *)(a2 + ((v9 + v16) | 1));
      unsigned int v30 = (_WORD *)(v25 + v16);
      *(v30 - 1) = *(unsigned __int8 *)(a2 + ((v9 + v16) | 2));
      *unsigned int v30 = *(unsigned __int8 *)(a2 + ((v9 + v16) | 3));
      unint64_t v31 = (_WORD *)(v23 + v16);
      *unint64_t v31 = *(unsigned __int8 *)(v20 + v16);
      v31[1] = *(unsigned __int8 *)(a2 + ((v18 + v16) | 1));
      unsigned int v32 = (_WORD *)(v21 + v16);
      *unsigned int v32 = *(unsigned __int8 *)(v20 + v16 + 2);
      v32[1] = *(unsigned __int8 *)(v20 + v16 + 3);
      *(_WORD *)(v19 + v16) = *(unsigned __int8 *)(v22 + v16);
      *(_WORD *)(result + 2 * ((v8 | 1) + a5)) = *(unsigned __int8 *)(v22 + v16 + 1);
      BOOL v33 = (_WORD *)(v27 + v16);
      *(v33 - 1) = *(unsigned __int8 *)(v22 + v16 + 2);
      *BOOL v33 = *(unsigned __int8 *)(v22 + v16 + 3);
      unint64_t v34 = (_WORD *)(v29 + v16);
      *unint64_t v34 = *(unsigned __int8 *)(v26 + v16);
      v34[1] = *(unsigned __int8 *)(v26 + v16 + 1);
      int v35 = (_WORD *)(v28 + v16);
      *int v35 = *(unsigned __int8 *)(v26 + v16 + 2);
      v35[1] = *(unsigned __int8 *)(v26 + v16 + 3);
      v8 += 2LL;
      v16 += 4LL;
    }

    while (v9 + v16 + 4 <= a3);
  }

  return result;
}

uint64_t convert_rows_to_quadra8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = a3 >> 1;
  uint64_t v6 = 2 * a4;
  uint64_t v7 = 3 * a4;
  if (a3 >= 0x10)
  {
    uint64_t v9 = 0LL;
    unint64_t v8 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8LL) + 8;
    do
    {
      int16x8_t v10 = *(int16x8_t *)(a2 + v9);
      *(int8x8_t *)v10.i8 = vmovn_s16(v10);
      int16x8_t v11 = *(int16x8_t *)(a2 + 2 * v5 + v9);
      *(int8x8_t *)v11.i8 = vmovn_s16(v11);
      int16x8_t v12 = vzip1q_s16(v10, v11);
      int16x8_t v13 = *(int16x8_t *)(a2 + 2 * a3 + v9);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      int16x8_t v14 = *(int16x8_t *)(a2 + 6 * v5 + v9);
      *(int8x8_t *)v14.i8 = vmovn_s16(v14);
      int16x8_t v15 = vzip1q_s16(v13, v14);
      *(int8x8_t *)v14.i8 = vmovn_s16(*(int16x8_t *)(a2 + 2 * a5 + v9));
      int16x8_t v16 = *(int16x8_t *)(a2 + 2 * a5 + 2 * v5 + v9);
      *(int8x8_t *)v16.i8 = vmovn_s16(v16);
      int16x8_t v17 = vzip1q_s16(v14, v16);
      int16x8_t v18 = *(int16x8_t *)(a2 + 2 * a5 + 2 * a3 + v9);
      *(int8x8_t *)v18.i8 = vmovn_s16(v18);
      int16x8_t v19 = *(int16x8_t *)(a2 + 6 * v5 + 2 * a5 + v9);
      *(int8x8_t *)v19.i8 = vmovn_s16(v19);
      *(int16x8_t *)(result + v9) = v12;
      *(int16x8_t *)(result + v6 + v9) = v15;
      *(int16x8_t *)(result + a4 + v9) = v17;
      *(int16x8_t *)(result + v7 + v9) = vzip1q_s16(v18, v19);
      unint64_t v20 = v9 + 32;
      v9 += 16LL;
    }

    while (v20 <= a3);
  }

  else
  {
    unint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
  }

  if ((v9 | 4uLL) <= a3)
  {
    uint64_t v21 = 0LL;
    uint64_t v22 = a2 + 2 * v8;
    uint64_t v23 = v9 + v6;
    uint64_t v24 = a2 + 2 * v8 + 2 * a5;
    uint64_t v25 = a2 + 6 * v5 + 2 * v8;
    uint64_t v26 = result + v9 + a4;
    uint64_t v27 = a2 + 2 * v8 + 2 * a3;
    uint64_t v28 = a2 + 2 * (v8 + a5 + v5);
    uint64_t v29 = 2 * v8 + 2 * v5 + a2 + 2;
    uint64_t v30 = result + v9 + v7;
    uint64_t v31 = v28 + 2;
    uint64_t v32 = a2 + 2 * (v8 + a5 + 3 * (a3 >> 1));
    uint64_t v33 = a2 + 2 * (v8 + a5 + a3);
    do
    {
      *(_BYTE *)(result + v9 + v21) = *(_BYTE *)(v22 + v21);
      *(_BYTE *)(result + ((v9 + v21) | 1)) = *(_WORD *)(a2 + 2 * (v8 | 1));
      *(_BYTE *)(result + ((v9 + v21) | 2)) = *(_BYTE *)(v29 + v21 - 2);
      *(_BYTE *)(result + ((v9 + v21) | 3)) = *(_BYTE *)(v29 + v21);
      unint64_t v34 = (_BYTE *)(result + v23 + v21);
      *unint64_t v34 = *(_BYTE *)(v27 + v21);
      *(_BYTE *)(result + ((v23 + v21) | 1)) = *(_BYTE *)(v27 + v21 + 2);
      v34[2] = *(_BYTE *)(v25 + v21);
      v34[3] = *(_BYTE *)(v25 + v21 + 2);
      int v35 = (_BYTE *)(v26 + v21);
      *int v35 = *(_BYTE *)(v24 + v21);
      v35[1] = *(_WORD *)(a2 + 2 * ((v8 | 1) + a5));
      v35[2] = *(_BYTE *)(v31 + v21 - 2);
      v35[3] = *(_BYTE *)(v31 + v21);
      int16x4x2_t v36 = (_BYTE *)(v30 + v21);
      *int16x4x2_t v36 = *(_BYTE *)(v33 + v21);
      v36[1] = *(_BYTE *)(v33 + v21 + 2);
      v36[2] = *(_BYTE *)(v32 + v21);
      v36[3] = *(_BYTE *)(v32 + v21 + 2);
      v8 += 2LL;
      v21 += 4LL;
    }

    while (v9 + v21 + 4 <= a3);
  }

  return result;
}

uint64_t convert_rows_from_bayer8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v6 = a2 + a4;
  if (a3 >= 0x10)
  {
    unint64_t v9 = 0LL;
    uint64_t v7 = 0LL;
    for (unint64_t i = 16LL; i <= a3; i += 16LL)
    {
      int16x8_t v11 = (const char *)(a2 + v9);
      int8x8x2_t v20 = vld2_s8(v11);
      int16x8_t v12 = (const char *)(v6 + v9);
      int8x8x2_t v21 = vld2_s8(v12);
      unint64_t v8 = i;
      uint64_t v13 = 2 * v7;
      *(uint16x8_t *)(result + v13) = vmovl_u8((uint8x8_t)v20.val[1]);
      *(uint16x8_t *)(result + 2 * v4 + v13) = vmovl_u8((uint8x8_t)v21.val[0]);
      *(uint16x8_t *)(result + 2 * v5 + v13) = vmovl_u8((uint8x8_t)v21.val[1]);
      *(uint16x8_t *)(result + 6 * v4 + v13) = vmovl_u8((uint8x8_t)v20.val[0]);
      v7 += 8LL;
      unint64_t v9 = v8;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = 0LL;
  }

  if ((v8 | 2) <= a3)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = result + 6 * v4 + 2 * v7;
    uint64_t v16 = result + 2 * v7;
    uint64_t v17 = result + v5 + 2 * v7;
    uint64_t v18 = result + 4 * v4 + 2 * v7;
    do
    {
      *(_WORD *)(v15 + v14) = *(unsigned __int8 *)(a2 + v8 + v14);
      uint64_t v19 = (v8 + v14) | 1;
      *(_WORD *)(v16 + v14) = *(unsigned __int8 *)(a2 + v19);
      uint64_t result = *(unsigned __int8 *)(a2 + v8 + a4 + v14);
      *(_WORD *)(v17 + v14) = result;
      *(_WORD *)(v18 + v14) = *(unsigned __int8 *)(v6 + v19);
      v14 += 2LL;
    }

    while (v8 + v14 + 2 <= a3);
  }

  return result;
}

uint64_t convert_rows_to_bayer8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v6 = result + a4;
  if (a3 >= 0x10)
  {
    uint64_t v8 = 0LL;
    unint64_t v9 = 0LL;
    for (unint64_t i = 16LL; i <= a3; i += 16LL)
    {
      unint64_t v7 = i;
      int16x8_t v11 = *(int16x8_t *)(a2 + 2 * v8);
      int16x8_t v12 = *(int16x8_t *)(a2 + 2 * v4 + 2 * v8);
      *(int8x8_t *)v11.i8 = vmovn_s16(v11);
      *(int8x8_t *)v12.i8 = vmovn_s16(v12);
      int16x8_t v13 = *(int16x8_t *)(a2 + 2 * v5 + 2 * v8);
      int16x8_t v14 = *(int16x8_t *)(a2 + 6 * v4 + 2 * v8);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      *(int8x8_t *)v14.i8 = vmovn_s16(v14);
      *(int8x16_t *)(result + v9) = vzip1q_s8((int8x16_t)v14, (int8x16_t)v11);
      *(int8x16_t *)(v6 + v9) = vzip1q_s8((int8x16_t)v12, (int8x16_t)v13);
      v8 += 8LL;
      unint64_t v9 = v7;
    }
  }

  else
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
  }

  if ((v7 | 2) <= a3)
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = a2 + 6 * v4 + 2 * v8;
    uint64_t v17 = a2 + 2 * v8;
    uint64_t v18 = a2 + v5 + 2 * v8;
    uint64_t v19 = a2 + 4 * v4 + 2 * v8;
    do
    {
      *(_BYTE *)(result + v7 + v15) = *(_BYTE *)(v16 + v15);
      uint64_t v20 = (v7 + v15) | 1;
      *(_BYTE *)(result + v20) = *(_BYTE *)(v17 + v15);
      *(_BYTE *)(result + v7 + a4 + v15) = *(_BYTE *)(v18 + v15);
      *(_BYTE *)(v6 + v20) = *(_BYTE *)(v19 + v15);
      v15 += 2LL;
    }

    while (v7 + v15 + 2 <= a3);
  }

  return result;
}

uint64_t convert_rows_from_bayer16( uint64_t result, const __int16 *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v6 = a4 >> 1;
  if (a3 >= 0x10)
  {
    uint64_t v8 = 0LL;
    unint64_t v7 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8LL) + 8;
    unint64_t v9 = a2;
    do
    {
      int16x8_t v10 = &v9[v6];
      int16x8x2_t v21 = vld2q_s16(v9);
      v9 += 16;
      int16x8x2_t v22 = vld2q_s16(v10);
      *(int16x8_t *)(result + v8) = v21.val[1];
      *(int16x8_t *)(result + v5 + v8) = v22.val[0];
      *(int16x8_t *)(result + 4 * v4 + v8) = v22.val[1];
      *(int16x8_t *)(result + 6 * v4 + v8) = v21.val[0];
      unint64_t v11 = v8 + 32;
      v8 += 16LL;
    }

    while (v11 <= a3);
  }

  else
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
  }

  if ((v8 | 2uLL) <= a3)
  {
    uint64_t v12 = 0LL;
    int16x8_t v13 = &a2[v6];
    int16x8_t v14 = &a2[v8 + v6];
    uint64_t v15 = result + 6 * v4 + 2 * v7;
    uint64_t v16 = 4 * v4 + 2 * v7;
    uint64_t v17 = result + 2 * v7;
    uint64_t v18 = result + v5 + 2 * v7;
    uint64_t v19 = result + v16;
    do
    {
      *(_WORD *)(v15 + v12) = a2[v8 + v12];
      uint64_t v20 = (2 * (v8 + v12)) | 2;
      *(_WORD *)(v17 + v12) = *(const __int16 *)((char *)a2 + v20);
      uint64_t result = (unsigned __int16)v14[v12];
      *(_WORD *)(v18 + v12) = result;
      *(_WORD *)(v19 + v12) = *(const __int16 *)((char *)v13 + v20);
      v12 += 2LL;
    }

    while (v8 + v12 + 2 <= a3);
  }

  return result;
}

int16x8_t *convert_rows_to_bayer16(int16x8_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v6 = a4 >> 1;
  unint64_t v7 = 0LL;
  if (a3 >= 0x10)
  {
    unint64_t v8 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8LL) + 8;
    unint64_t v9 = result;
    do
    {
      int16x8_t v10 = *(int16x8_t *)(a2 + v7);
      int16x8_t v11 = *(int16x8_t *)(a2 + v5 + v7);
      int16x8_t v12 = *(int16x8_t *)(a2 + 4 * v4 + v7);
      int16x8_t v13 = *(int16x8_t *)(a2 + 6 * v4 + v7);
      *unint64_t v9 = vzip1q_s16(v13, v10);
      v9[1] = vzip2q_s16(v13, v10);
      int16x8_t v14 = (int16x8_t *)((char *)v9 + 2 * v6);
      *int16x8_t v14 = vzip1q_s16(v11, v12);
      v14[1] = vzip2q_s16(v11, v12);
      unint64_t v15 = v7 + 32;
      v7 += 16LL;
      v9 += 2;
    }

    while (v15 <= a3);
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  if ((v7 | 2) <= a3)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = &result->i8[2 * v6];
    uint64_t v18 = &result[v7 / 8].i8[2 * v6];
    uint64_t v19 = a2 + 6 * v4 + 2 * v8;
    uint64_t v20 = 4 * v4 + 2 * v8;
    uint64_t v21 = a2 + 2 * v8;
    uint64_t v22 = a2 + v5 + 2 * v8;
    uint64_t v23 = a2 + v20;
    do
    {
      result[v7 / 8].i16[v16] = *(_WORD *)(v19 + v16);
      uint64_t v24 = (2 * (v7 + v16)) | 2;
      *(__int16 *)((char *)result->i16 + v24) = *(_WORD *)(v21 + v16);
      *(_WORD *)&v18[2 * v16] = *(_WORD *)(v22 + v16);
      *(_WORD *)&v17[v24] = *(_WORD *)(v23 + v16);
      v16 += 2LL;
    }

    while (v7 + v16 + 2 <= a3);
  }

  return result;
}

__n128 *convert_row_RGB888toGUV( __n128 *result, uint64_t a2, unint64_t a3, double a4, __n128 a5, double a6, double a7, double a8, __n128 a9)
{
  unint64_t v9 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v12 = 0LL;
    uint64_t v10 = 0LL;
    a5.n128_u64[1] = -1LL;
    v13.i64[0] = 0x80008000800080LL;
    v13.i64[1] = 0x80008000800080LL;
    int16x8_t v14 = result;
    do
    {
      __int128 v15 = *(_OWORD *)(a2 + v10);
      a9.n128_u64[0] = *(void *)(a2 + v10 + 16);
      int8x16_t v16 = vqtbl2q_s8(*(int8x16x2_t *)(&a9 - 1), (int8x16_t)xmmword_1810971F0);
      int8x8_t v17 = (int8x8_t)vextq_s8(v16, v16, 8uLL).u64[0];
      *(void *)&__int128 v15 = vqtbl2q_s8(*(int8x16x2_t *)(&a9 - 1), (int8x16_t)xmmword_181097200).u64[0];
      *(uint16x8_t *)((char *)v14 + 2 * a3) = vmovl_u8((uint8x8_t)veor_s8( vsub_s8(*(int8x8_t *)v16.i8, v17),  (int8x8_t)0x8080808080808080LL));
      a9 = (__n128)vmovl_high_u8((uint8x16_t)v16);
      *(__n128 *)((char *)v14 + 4 * a3) = (__n128)(*(_OWORD *)&vaddq_s16( (int16x8_t)vsubl_u8( *(uint8x8_t *)&v15,  vhadd_u8( *(uint8x8_t *)v16.i8,  (uint8x8_t)v17)),  v13) & __PAIR128__( 0xFF00FF00FF00FFLL,  0xFF00FF00FF00FFLL));
      *v14++ = a9;
      v10 += 24LL;
      unint64_t v11 = v12 + 8;
      unint64_t v18 = v12 + 16;
      v12 += 8LL;
    }

    while (v18 <= a3);
  }

  else
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
  }

  uint64_t v19 = a3 - v11;
  if (a3 > v11)
  {
    if (a3 <= 7)
    {
      uint64_t v27 = (_WORD *)result + v11;
      uint64_t v28 = (unsigned __int8 *)(v10 + a2 + 1);
      do
      {
        int v29 = *(v28 - 1);
        int v30 = *v28;
        unsigned __int8 v31 = v28[1];
        *uint64_t v27 = v30;
        v27[a3] = (v29 - v30 + 0x80);
        v27[2 * a3] = (v31 - ((v30 + v29) >> 1) + 0x80);
        ++v27;
        v28 += 3;
        --v19;
      }

      while (v19);
    }

    else
    {
      uint64_t v20 = (__int128 *)(a2 + 3 * v9);
      uint64_t v21 = 2 * v9;
      __int128 v22 = *v20;
      a5.n128_u64[0] = *((void *)v20 + 2);
      int8x16_t v23 = vqtbl2q_s8(*(int8x16x2_t *)(&a5 - 1), (int8x16_t)xmmword_1810971F0);
      int8x8_t v24 = (int8x8_t)vextq_s8(v23, v23, 8uLL).u64[0];
      *(void *)&__int128 v22 = vqtbl2q_s8(*(int8x16x2_t *)(&a5 - 1), (int8x16_t)xmmword_181097200).u64[0];
      *(uint16x8_t *)((char *)result + 2 * a3 + v21) = vmovl_u8((uint8x8_t)veor_s8( vsub_s8(*(int8x8_t *)v23.i8, v24),  (int8x8_t)0x8080808080808080LL));
      uint16x8_t v25 = vmovl_high_u8((uint8x16_t)v23);
      *(uint8x8_t *)v23.i8 = vhadd_u8(*(uint8x8_t *)v23.i8, (uint8x8_t)v24);
      v26.i64[0] = 0x80008000800080LL;
      v26.i64[1] = 0x80008000800080LL;
      *(__n128 *)((char *)result + 4 * a3 + v21) = (__n128)(*(_OWORD *)&vaddq_s16( (int16x8_t)vsubl_u8( *(uint8x8_t *)&v22,  *(uint8x8_t *)v23.i8),  v26) & __PAIR128__( 0xFF00FF00FF00FFLL,  0xFF00FF00FF00FFLL));
      *(uint16x8_t *)((char *)result + v21) = v25;
    }
  }

  return result;
}

uint64_t convert_row_GUVtoRGB888( uint64_t result, int16x8_t *a2, unint64_t a3, double a4, double a5, double a6, double a7, int8x16_t a8)
{
  unint64_t v9 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
    int16x8_t v13 = a2;
    do
    {
      *(int8x8_t *)v14.i8 = vmovn_s16(*v13);
      int8x8_t v15 = veor_s8( vadd_s8(vmovn_s16(*(int16x8_t *)((char *)v13 + 2 * a3)), *(int8x8_t *)v14.i8),  (int8x8_t)0x8080808080808080LL);
      uint64_t v16 = result + v11;
      *(int8x8_t *)&__int128 v8 = veor_s8( vadd_s8( (int8x8_t)vhadd_u8(*(uint8x8_t *)v14.i8, (uint8x8_t)v15),  vmovn_s16(*(int16x8_t *)((char *)v13 + 4 * a3))),  (int8x8_t)0x8080808080808080LL);
      int8x16_t v17 = vmovn_hight_s16(v15, *v13);
      v14.i64[1] = v8;
      *(int8x16_t *)uint64_t v16 = vqtbl2q_s8(*(int8x16x2_t *)(&v8 - 1), (int8x16_t)xmmword_181097210);
      *(int8x8_t *)a8.i8 = vqtbl1_s8(v14, (int8x8_t)0xF07FF0E06FF0D05LL);
      a8.u64[1] = (unint64_t)v15;
      *(int8x8_t *)(v16 + 16) = vqtbl1_s8(a8, (int8x8_t)0x7060F04030E0100LL);
      v11 += 24LL;
      unint64_t v10 = v12 + 8;
      ++v13;
      unint64_t v18 = v12 + 16;
      v12 += 8LL;
    }

    while (v18 <= a3);
  }

  else
  {
    unint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
  }

  uint64_t v19 = a3 - v10;
  if (a3 > v10)
  {
    if (a3 <= 7)
    {
      int16x8_t v26 = &a2->i16[v10];
      uint64_t v27 = (_BYTE *)(v11 + result + 1);
      do
      {
        __int16 v28 = *v26;
        __int16 v29 = v26[2 * a3];
        int v30 = *v26;
        __int16 v31 = (v26[a3] + *v26) ^ 0xFF80;
        *(v27 - 1) = (v26[a3] + *v26) ^ 0x80;
        *uint64_t v27 = v28;
        v27[1] = (v29 + ((v30 + v31) >> 1)) ^ 0x80;
        ++v26;
        v27 += 3;
        --v19;
      }

      while (v19);
    }

    else
    {
      uint64_t v20 = result + 3 * v9;
      uint64_t v21 = 2 * v9;
      int16x8_t v22 = *(int16x8_t *)((char *)a2 + v21);
      *(int8x8_t *)v23.i8 = vmovn_s16(v22);
      a8.i16[0] = -32640;
      a8.i8[2] = 0x80;
      a8.i8[3] = 0x80;
      a8.i8[4] = 0x80;
      a8.i8[5] = 0x80;
      a8.i8[6] = 0x80;
      a8.i8[7] = 0x80;
      int8x8_t v24 = veor_s8( vadd_s8(vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 + v21)), *(int8x8_t *)v23.i8),  *(int8x8_t *)a8.i8);
      *(int8x8_t *)a8.i8 = veor_s8( vadd_s8( (int8x8_t)vhadd_u8(*(uint8x8_t *)v23.i8, (uint8x8_t)v24),  vmovn_s16(*(int16x8_t *)((char *)a2 + 4 * a3 + v21))),  *(int8x8_t *)a8.i8);
      int8x16_t v25 = vmovn_hight_s16(v24, v22);
      *(int8x16_t *)uint64_t v20 = vqtbl2q_s8(*(int8x16x2_t *)(&a8 - 1), (int8x16_t)xmmword_181097210);
      v23.i64[1] = a8.i64[0];
      *(int8x8_t *)v22.i8 = vqtbl1_s8(v23, (int8x8_t)0xF07FF0E06FF0D05LL);
      v22.u64[1] = (unint64_t)v24;
      *(int8x8_t *)(v20 + 16) = vqtbl1_s8((int8x16_t)v22, (int8x8_t)0x7060F04030E0100LL);
    }
  }

  return result;
}

uint16x8_t *convert_row_RGBA8888toGUVA(uint16x8_t *result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v4 = 0LL;
    v7.i64[0] = 0x80008000800080LL;
    v7.i64[1] = 0x80008000800080LL;
    __int128 v8 = result;
    do
    {
      unint64_t v9 = (const char *)(a2 + v4);
      int8x16x2_t v31 = vld2q_s8(v9);
      int8x8_t v10 = (int8x8_t)vextq_s8(v31.val[0], v31.val[0], 8uLL).u64[0];
      int8x8_t v11 = vuzp1_s8(*(int8x8_t *)v31.val[0].i8, v10);
      int8x8_t v12 = (int8x8_t)vextq_s8(v31.val[1], v31.val[1], 8uLL).u64[0];
      int8x8_t v13 = vuzp1_s8(*(int8x8_t *)v31.val[1].i8, v12);
      *(uint16x8_t *)((char *)v8 + 2 * a3) = vmovl_u8((uint8x8_t)veor_s8( vsub_s8(v11, v13),  (int8x8_t)0x8080808080808080LL));
      *(uint16x8_t *)((char *)v8 + 4 * a3) = (uint16x8_t)(*(_OWORD *)&vaddq_s16( (int16x8_t)vsubl_u8( (uint8x8_t)vuzp2_s8( *(int8x8_t *)v31.val[0].i8,  v10),  vhadd_u8( (uint8x8_t)v11,  (uint8x8_t)v13)),  v7) & __PAIR128__( 0xFF00FF00FF00FFLL,  0xFF00FF00FF00FFLL));
      *__int128 v8 = vmovl_u8((uint8x8_t)v13);
      *(uint16x8_t *)((char *)v8 + 6 * a3) = vmovl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v31.val[1].i8, v12));
      v4 += 32LL;
      unint64_t v5 = v6 + 8;
      ++v8;
      unint64_t v14 = v6 + 16;
      v6 += 8LL;
    }

    while (v14 <= a3);
  }

  else
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = 0LL;
  }

  uint64_t v15 = a3 - v5;
  if (a3 > v5)
  {
    if (a3 <= 7)
    {
      int8x16_t v25 = &result->i16[v5];
      int16x8_t v26 = (unsigned __int8 *)(v4 + a2 + 1);
      do
      {
        int v27 = *(v26 - 1);
        int v28 = *v26;
        unsigned __int8 v29 = v26[1];
        *int8x16_t v25 = v28;
        v25[a3] = (v27 - v28 + 0x80);
        v25[2 * a3] = (v29 - ((v28 + v27) >> 1) + 0x80);
        v25[3 * a3] = v26[2];
        ++v25;
        v26 += 4;
        --v15;
      }

      while (v15);
    }

    else
    {
      uint64_t v16 = (const char *)(a2 + 4 * v3);
      uint64_t v17 = 2 * v3;
      int8x16x2_t v30 = vld2q_s8(v16);
      int8x8_t v18 = (int8x8_t)vextq_s8(v30.val[0], v30.val[0], 8uLL).u64[0];
      int8x8_t v19 = vuzp1_s8(*(int8x8_t *)v30.val[0].i8, v18);
      int8x8_t v20 = (int8x8_t)vextq_s8(v30.val[1], v30.val[1], 8uLL).u64[0];
      int8x8_t v21 = vuzp1_s8(*(int8x8_t *)v30.val[1].i8, v20);
      *(uint16x8_t *)((char *)result + 2 * a3 + v17) = vmovl_u8((uint8x8_t)veor_s8( vsub_s8(v19, v21),  (int8x8_t)0x8080808080808080LL));
      uint16x8_t v22 = vmovl_u8((uint8x8_t)v21);
      uint8x8_t v23 = vhadd_u8((uint8x8_t)v19, (uint8x8_t)v21);
      v24.i64[0] = 0x80008000800080LL;
      v24.i64[1] = 0x80008000800080LL;
      *(uint16x8_t *)((char *)result + 4 * a3 + v17) = (uint16x8_t)(*(_OWORD *)&vaddq_s16( (int16x8_t)vsubl_u8( (uint8x8_t)vuzp2_s8(*(int8x8_t *)v30.val[0].i8, v18),  v23),  v24) & __PAIR128__( 0xFF00FF00FF00FFLL,  0xFF00FF00FF00FFLL));
      *(uint16x8_t *)((char *)result + v17) = v22;
      *(uint16x8_t *)((char *)result + 6 * a3 + v17) = vmovl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v30.val[1].i8, v20));
    }
  }

  return result;
}

uint64_t convert_row_GUVAtoRGBA8888(uint64_t result, int16x8_t *a2, unint64_t a3)
{
  unint64_t v3 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
    int16x8_t v7 = a2;
    do
    {
      __int128 v8 = (int8x16_t *)(result + v5);
      int8x8_t v9 = vmovn_s16(*v7);
      int8x8_t v10 = vmovn_s16(*(int16x8_t *)((char *)v7 + 6 * a3));
      int8x8_t v11 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)v7 + 2 * a3)), v9), (int8x8_t)0x8080808080808080LL);
      int8x8_t v12 = veor_s8( vadd_s8((int8x8_t)vhadd_u8((uint8x8_t)v9, (uint8x8_t)v11), vmovn_s16(*(int16x8_t *)((char *)v7 + 4 * a3))),  (int8x8_t)0x8080808080808080LL);
      *(int8x8_t *)v13.i8 = vzip2_s8(v11, v12);
      *(int8x8_t *)v14.i8 = vzip1_s8(v11, v12);
      v14.u64[1] = (unint64_t)vzip1_s8(v9, v10);
      v13.u64[1] = (unint64_t)vzip2_s8(v9, v10);
      *__int128 v8 = vqtbl1q_s8(v14, (int8x16_t)xmmword_181097220);
      v8[1] = vqtbl1q_s8(v13, (int8x16_t)xmmword_181097220);
      v5 += 32LL;
      unint64_t v4 = v6 + 8;
      ++v7;
      unint64_t v15 = v6 + 16;
      v6 += 8LL;
    }

    while (v15 <= a3);
  }

  else
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v16 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int8x16_t v25 = &a2->i16[v4];
      int16x8_t v26 = (_BYTE *)(v5 + result + 1);
      do
      {
        __int16 v27 = *v25;
        __int16 v28 = v25[2 * a3];
        int v29 = *v25;
        unsigned __int8 v30 = (v25[a3] + *v25) ^ 0x80;
        *(v26 - 1) = v30;
        *int16x8_t v26 = v27;
        v26[1] = (v28 + ((v29 + v30) >> 1)) ^ 0x80;
        v26[2] = v25[3 * a3];
        ++v25;
        v26 += 4;
        --v16;
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = (int8x16_t *)(result + 4 * v3);
      uint64_t v18 = 2 * v3;
      int8x8_t v19 = vmovn_s16(*(int16x8_t *)((char *)a2 + v18));
      int8x8_t v20 = vmovn_s16(*(int16x8_t *)((char *)a2 + 6 * a3 + v18));
      int8x8_t v21 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 + v18)), v19), (int8x8_t)0x8080808080808080LL);
      int8x8_t v22 = veor_s8( vadd_s8( (int8x8_t)vhadd_u8((uint8x8_t)v19, (uint8x8_t)v21),  vmovn_s16(*(int16x8_t *)((char *)a2 + 4 * a3 + v18))),  (int8x8_t)0x8080808080808080LL);
      *(int8x8_t *)v23.i8 = vzip2_s8(v21, v22);
      *(int8x8_t *)v24.i8 = vzip1_s8(v21, v22);
      v24.u64[1] = (unint64_t)vzip1_s8(v19, v20);
      v23.u64[1] = (unint64_t)vzip2_s8(v19, v20);
      int8x16_t *v17 = vqtbl1q_s8(v24, (int8x16_t)xmmword_181097220);
      v17[1] = vqtbl1q_s8(v23, (int8x16_t)xmmword_181097220);
    }
  }

  return result;
}

uint16x8_t *convert_row_8to16(uint16x8_t *result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = result;
    do
    {
      *v5++ = vmovl_u8(*(uint8x8_t *)(a2 + v4));
      unint64_t v3 = v4 + 8;
      unint64_t v6 = v4 + 16;
      v4 += 8LL;
    }

    while (v6 <= a3);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  uint64_t v7 = a3 - v3;
  if (a3 > v3)
  {
    if (a3 <= 7)
    {
      __int128 v8 = &result->i16[v3];
      int8x8_t v9 = (unsigned __int8 *)(a2 + v3);
      do
      {
        __int16 v10 = *v9++;
        *v8++ = v10;
        --v7;
      }

      while (v7);
    }

    else
    {
      *(uint16x8_t *)((char *)result + 2 * a3 - 16) = vmovl_u8(*(uint8x8_t *)(a2 + a3 - 8));
    }
  }

  return result;
}

uint64_t convert_row_16to8(uint64_t result, int16x8_t *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = a2;
    do
    {
      int16x8_t v6 = *v5++;
      *(int8x8_t *)(result + v4) = vmovn_s16(v6);
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8LL;
    }

    while (v7 <= a3);
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  uint64_t v8 = a3 - v3;
  if (a3 > v3)
  {
    if (a3 <= 7)
    {
      int8x8_t v9 = (_BYTE *)(result + v3);
      __int16 v10 = &a2->i8[2 * v3];
      do
      {
        char v11 = *v10;
        v10 += 2;
        *v9++ = v11;
        --v8;
      }

      while (v8);
    }

    else
    {
      *(int8x8_t *)(result + a3 - 8) = vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 - 16));
    }
  }

  return result;
}

void *convert_row_copy16(void *a1, const void *a2, uint64_t a3)
{
  return memcpy(a1, a2, 2 * a3);
}

uint64_t convert_row_RG88toRG(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = result + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
    do
    {
      unint64_t v7 = (const char *)(a2 + v5);
      int8x8x2_t v13 = vld2_s8(v7);
      *(uint16x8_t *)(result + v5) = vmovl_u8((uint8x8_t)v13.val[0]);
      *(uint16x8_t *)(v3 + v5) = vmovl_u8((uint8x8_t)v13.val[1]);
      v5 += 16LL;
      unint64_t v4 = v6 + 8;
      unint64_t v8 = v6 + 16;
      v6 += 8LL;
    }

    while (v8 <= a3);
  }

  else
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v9 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int8x8_t v12 = (_WORD *)(result + 2 * v4);
      do
      {
        *int8x8_t v12 = *(unsigned __int8 *)(a2 + v5);
        v12[a3] = *(unsigned __int8 *)(a2 + (v5 | 1));
        v5 += 2LL;
        ++v12;
        --v9;
      }

      while (v9);
    }

    else
    {
      uint64_t v10 = 2 * a3 - 16;
      char v11 = (const char *)(a2 + v10);
      int8x8x2_t v14 = vld2_s8(v11);
      *(uint16x8_t *)(result + v10) = vmovl_u8((uint8x8_t)v14.val[0]);
      *(uint16x8_t *)(v3 + v10) = vmovl_u8((uint8x8_t)v14.val[1]);
    }
  }

  return result;
}

uint64_t convert_row_RGtoRG88(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
    do
    {
      int16x8_t v7 = *(int16x8_t *)(a2 + v5);
      *(int8x8_t *)v7.i8 = vmovn_s16(v7);
      int16x8_t v8 = *(int16x8_t *)(v3 + v5);
      *(int8x8_t *)v8.i8 = vmovn_s16(v8);
      *(int8x16_t *)(result + v5) = vzip1q_s8((int8x16_t)v7, (int8x16_t)v8);
      v5 += 16LL;
      unint64_t v4 = v6 + 8;
      unint64_t v9 = v6 + 16;
      v6 += 8LL;
    }

    while (v9 <= a3);
  }

  else
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v10 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int8x8x2_t v14 = (_BYTE *)(a2 + 2 * v4);
      do
      {
        *(_BYTE *)(result + v5) = *v14;
        *(_BYTE *)(result + (v5 | 1)) = v14[2 * a3];
        v5 += 2LL;
        v14 += 2;
        --v10;
      }

      while (v10);
    }

    else
    {
      uint64_t v11 = 2 * a3 - 16;
      int16x8_t v12 = *(int16x8_t *)(a2 + v11);
      *(int8x8_t *)v12.i8 = vmovn_s16(v12);
      int16x8_t v13 = *(int16x8_t *)(v3 + v11);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      *(int8x16_t *)(result + 2 * a3 - 16) = vzip1q_s8((int8x16_t)v12, (int8x16_t)v13);
    }
  }

  return result;
}

uint64_t convert_row_RGtoPlanarRG(uint64_t result, const __int16 *a2, unint64_t a3)
{
  uint64_t v3 = result + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
    int16x8_t v7 = a2;
    do
    {
      int16x8x2_t v13 = vld2q_s16(v7);
      v7 += 16;
      *(int16x8_t *)(result + v5) = v13.val[0];
      *(int16x8_t *)(v3 + v5) = v13.val[1];
      v5 += 16LL;
      unint64_t v4 = v6 + 8;
      unint64_t v8 = v6 + 16;
      v6 += 8LL;
    }

    while (v8 <= a3);
  }

  else
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v9 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int16x8_t v12 = (_WORD *)(result + 2 * v4);
      do
      {
        *int16x8_t v12 = a2[v5];
        v12[a3] = *(const __int16 *)((char *)a2 + ((2 * v5) | 2));
        v5 += 2LL;
        ++v12;
        --v9;
      }

      while (v9);
    }

    else
    {
      uint64_t v10 = 2 * a3 - 16;
      uint64_t v11 = &a2[v10];
      int16x8x2_t v14 = vld2q_s16(v11);
      *(int16x8_t *)(result + v10) = v14.val[0];
      *(int16x8_t *)(v3 + v10) = v14.val[1];
    }
  }

  return result;
}

int16x8_t *convert_row_PlanarRGtoRG(int16x8_t *result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0LL;
    uint64_t v5 = 0LL;
    int16x8_t v7 = result;
    do
    {
      int16x8_t v8 = *(int16x8_t *)(a2 + v5);
      int16x8_t v9 = *(int16x8_t *)(v3 + v5);
      *int16x8_t v7 = vzip1q_s16(v8, v9);
      v7[1] = vzip2q_s16(v8, v9);
      v7 += 2;
      v5 += 16LL;
      unint64_t v4 = v6 + 8;
      unint64_t v10 = v6 + 16;
      v6 += 8LL;
    }

    while (v10 <= a3);
  }

  else
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  uint64_t v11 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      uint64_t v16 = (__int16 *)(a2 + 2 * v4);
      do
      {
        result->i16[v5] = *v16;
        *(__int16 *)((char *)result->i16 + ((2 * v5) | 2)) = v16[a3];
        v5 += 2LL;
        ++v16;
        --v11;
      }

      while (v11);
    }

    else
    {
      uint64_t v12 = 2 * a3 - 16;
      int16x8_t v13 = *(int16x8_t *)(a2 + v12);
      int16x8_t v14 = *(int16x8_t *)(v3 + v12);
      unint64_t v15 = (int16x8_t *)((char *)result + 4 * a3);
      v15[-2] = vzip1q_s16(v13, v14);
      v15[-1] = vzip2q_s16(v13, v14);
    }
  }

  return result;
}

void BrotliCompareAndPushToQueueLiteral( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[130] = v12;
    v40[131] = v11;
    v40[132] = v10;
    v40[133] = v9;
    v40[144] = v7;
    v40[145] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4LL * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4LL * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 1040LL * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 1032);
    uint64_t v29 = a1 + 1040LL * v19;
    double v30 = *(double *)(v29 + 1032);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 1024)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 1040LL * v19 + 1024);
    double v30 = *(double *)(v27 + 1032);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0x410uLL);
    uint64_t v34 = 0LL;
    v40[128] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2LL;
    }

    while (v34 != 128);
    BrotliPopulationCostLiteral((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }

        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }

          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }

      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }

unint64_t BrotliHistogramCombineLiteral( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0LL;
  if (!a6) {
    return 0LL;
  }
  uint64_t v12 = 0LL;
  unint64_t v13 = a9;
  unint64_t v14 = a6 - 1;
  unint64_t v15 = a4 + 1;
  unint64_t v55 = a6;
  do
  {
    uint64_t v17 = v12 + 1;
    if (v12 + 1 < a6)
    {
      uint64_t v18 = v15;
      unint64_t v19 = v14;
      do
      {
        unsigned int v20 = *v18++;
        BrotliCompareAndPushToQueueLiteral(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
        unint64_t v13 = a9;
        --v19;
      }

      while (v19);
    }

    --v14;
    ++v15;
    ++v12;
    a6 = v55;
  }

  while (v17 != v55);
  if (v55 >= 2)
  {
    double v21 = 0.0;
    unint64_t v22 = 1LL;
    unint64_t v23 = a4;
    while (1)
    {
      if (*((double *)a5 + 2) >= v21)
      {
        unint64_t v22 = a8;
        double v21 = 1.0e99;
        unint64_t v31 = a6;
      }

      else
      {
        uint64_t v24 = 0LL;
        uint64_t v26 = *a5;
        uint64_t v25 = a5[1];
        uint64_t v27 = a1 + 1040LL * v26;
        uint64_t v28 = a1 + 1040LL * v25;
        *(void *)(v27 + 1024) += *(void *)(v28 + 1024);
        do
        {
          *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
          v24 += 4LL;
        }

        while (v24 != 1024);
        *(void *)(a1 + 1040LL * v26 + 1032) = *((void *)a5 + 1);
        *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
        uint64_t v29 = a3;
        for (uint64_t i = a7; i; --i)
        {
          if (*v29 == (_DWORD)v25) {
            *uint64_t v29 = v26;
          }
          ++v29;
        }

        unint64_t v31 = a6 - 1;
        if (a6 <= 1) {
          uint64_t v32 = 1LL;
        }
        else {
          uint64_t v32 = a6;
        }
        size_t v33 = 4 * a6 - 4;
        uint64_t v34 = v23;
        while (*v34 != (_DWORD)v25)
        {
          v33 -= 4LL;
          ++v34;
          if (!--v32) {
            goto LABEL_25;
          }
        }

        memmove(v34, v34 + 1, v33);
LABEL_25:
        unint64_t v35 = v57;
        if (v57)
        {
          unint64_t v36 = 0LL;
          double v37 = (double *)a5;
          while (2)
          {
            int v38 = *(_DWORD *)v37;
            if (*(_DWORD *)v37 == (_DWORD)v26) {
              goto LABEL_41;
            }
            unsigned int v39 = *((_DWORD *)v37 + 1);
            BOOL v40 = v39 == (_DWORD)v25 || v38 == (_DWORD)v25;
            if (v40 || v39 == (_DWORD)v26) {
              goto LABEL_41;
            }
            double v42 = *((double *)a5 + 2);
            double v43 = v37[2];
            if (v42 == v43)
            {
              if (a5[1] - *a5 <= v39 - v38) {
                goto LABEL_39;
              }
LABEL_37:
              __int128 v44 = *(_OWORD *)a5;
              uint64_t v45 = *((void *)a5 + 2);
              uint64_t v46 = *((void *)v37 + 2);
              *(_OWORD *)a5 = *(_OWORD *)v37;
              *((void *)a5 + 2) = v46;
            }

            else
            {
              if (v42 > v43) {
                goto LABEL_37;
              }
LABEL_39:
              __int128 v44 = *(_OWORD *)v37;
              uint64_t v45 = *((void *)v37 + 2);
            }

            unint64_t v47 = &a5[6 * v36];
            *((void *)v47 + 2) = v45;
            *(_OWORD *)unint64_t v47 = v44;
            ++v36;
LABEL_41:
            v37 += 3;
            if (!--v35) {
              goto LABEL_44;
            }
            continue;
          }
        }

        unint64_t v36 = 0LL;
LABEL_44:
        unint64_t v57 = v36;
        if (!v31) {
          return v31;
        }
        unsigned int v48 = v23;
        unint64_t v49 = v31;
        do
        {
          unsigned int v50 = *v48++;
          BrotliCompareAndPushToQueueLiteral(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
          --v49;
        }

        while (v49);
        a6 = v31;
        unint64_t v23 = a4;
      }

      if (v31 <= v22) {
        return v31;
      }
    }
  }

  return v55;
}

double BrotliHistogramBitCostDistanceLiteral(void *__src, uint64_t a2)
{
  if (!__src[128]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0LL;
  v6[128] += *(void *)(a2 + 1024);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2LL;
  }

  while (v3 != 128);
  BrotliPopulationCostLiteral((uint64_t)v6);
  return v4 - *(double *)(a2 + 1032);
}

void BrotliHistogramRemapLiteral( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0LL;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceLiteral((void *)(a1 + 1040 * i), a5 + 1040LL * v12);
      if (a4)
      {
        double v14 = v13;
        unint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceLiteral((void *)(a1 + 1040 * i), a5 + 1040LL * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }

          ++v15;
          --v16;
        }

        while (v16);
      }

      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }

  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 1040LL * v18), 0x408uLL);
    *(void *)(a5 + 1040LL * v18 + 1032) = 0x7FF0000000000000LL;
  }

  if (a2)
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0LL;
      uint64_t v22 = a5 + 1040LL * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 1024) += *(void *)(a1 + 1040 * v19 + 1024);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4LL;
      }

      while (v21 != 1024);
      ++v19;
      v20 += 1040LL;
    }

    while (v19 != a2);
  }

uint64_t BrotliHistogramReindexLiteral(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4LL * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }

    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0LL;
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 1040LL * v17++), &a2[1040 * v18], 0x410uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4LL * *a3);
        }

        *a3++ = v19;
        --v4;
      }

      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0x410uLL);
          v20 += 1040;
          a2 += 1040;
          --v21;
        }

        while (v21);
        goto LABEL_25;
      }
    }

    else
    {
      BrotliFree(a1, v9);
    }

    uint64_t v16 = 0LL;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }

  uint64_t v16 = 0LL;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0LL;
    unint64_t v9 = 0LL;
    goto LABEL_14;
  }

  return v16;
}

void BrotliClusterHistogramsLiteral( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_181097240, 4 * a3);
    uint64_t v15 = 0LL;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0x410uLL);
      BrotliPopulationCostLiteral((uint64_t)v17);
      *((void *)v16 + 129) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 1040;
      v16 += 1040;
    }

    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }

  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
  }

  uint64_t v34 = a1;
  unint64_t v35 = v19;
  unint64_t v21 = 0LL;
  if (a3)
  {
    unint64_t v22 = 0LL;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64LL;
      }
      if (a3 - v22 >= 0x40) {
        unint64_t v25 = 64LL;
      }
      else {
        unint64_t v25 = a3 - v22;
      }
      if (v25)
      {
        uint64_t v26 = 0LL;
        do
        {
          v12[v21 + v26] = v22 + v26;
          ++v26;
        }

        while (v23 != v26);
      }

      v21 += BrotliHistogramCombineLiteral((uint64_t)a5, (uint64_t)v11, &a7[v22], &v12[v21], v14, v25, v25, a4, 0x800uLL);
      v22 += 64LL;
      unint64_t v23 = v24;
    }

    while (v22 < a3);
  }

  if (v21 << 6 >= (v21 >> 1) * v21) {
    unint64_t v27 = (v21 >> 1) * v21;
  }
  else {
    unint64_t v27 = v21 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }

  else
  {
    uint64_t v28 = 2048LL;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2LL;
    }

    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }

  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineLiteral((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v21, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapLiteral(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexLiteral(v29, a5, a7, a3);
  }

void BrotliCompareAndPushToQueueCommand( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[354] = v12;
    v40[355] = v11;
    v40[356] = v10;
    v40[357] = v9;
    v40[368] = v7;
    v40[369] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4LL * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4LL * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 2832LL * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 2824);
    uint64_t v29 = a1 + 2832LL * v19;
    double v30 = *(double *)(v29 + 2824);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 2816)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 2832LL * v19 + 2816);
    double v30 = *(double *)(v27 + 2824);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0xB10uLL);
    uint64_t v34 = 0LL;
    v40[352] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2LL;
    }

    while (v34 != 352);
    BrotliPopulationCostCommand((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }

        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }

          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }

      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }

unint64_t BrotliHistogramCombineCommand( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0LL;
  if (!a6) {
    return 0LL;
  }
  uint64_t v12 = 0LL;
  unint64_t v13 = a9;
  unint64_t v14 = a6 - 1;
  uint64_t v15 = a4 + 1;
  unint64_t v55 = a6;
  do
  {
    uint64_t v17 = v12 + 1;
    if (v12 + 1 < a6)
    {
      uint64_t v18 = v15;
      unint64_t v19 = v14;
      do
      {
        unsigned int v20 = *v18++;
        BrotliCompareAndPushToQueueCommand(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
        unint64_t v13 = a9;
        --v19;
      }

      while (v19);
    }

    --v14;
    ++v15;
    ++v12;
    a6 = v55;
  }

  while (v17 != v55);
  if (v55 >= 2)
  {
    double v21 = 0.0;
    unint64_t v22 = 1LL;
    unint64_t v23 = a4;
    while (1)
    {
      if (*((double *)a5 + 2) >= v21)
      {
        unint64_t v22 = a8;
        double v21 = 1.0e99;
        unint64_t v31 = a6;
      }

      else
      {
        uint64_t v24 = 0LL;
        uint64_t v26 = *a5;
        uint64_t v25 = a5[1];
        uint64_t v27 = a1 + 2832LL * v26;
        uint64_t v28 = a1 + 2832LL * v25;
        *(void *)(v27 + 2816) += *(void *)(v28 + 2816);
        do
        {
          *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
          v24 += 4LL;
        }

        while (v24 != 2816);
        *(void *)(a1 + 2832LL * v26 + 2824) = *((void *)a5 + 1);
        *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
        uint64_t v29 = a3;
        for (uint64_t i = a7; i; --i)
        {
          if (*v29 == (_DWORD)v25) {
            *uint64_t v29 = v26;
          }
          ++v29;
        }

        unint64_t v31 = a6 - 1;
        if (a6 <= 1) {
          uint64_t v32 = 1LL;
        }
        else {
          uint64_t v32 = a6;
        }
        size_t v33 = 4 * a6 - 4;
        uint64_t v34 = v23;
        while (*v34 != (_DWORD)v25)
        {
          v33 -= 4LL;
          ++v34;
          if (!--v32) {
            goto LABEL_25;
          }
        }

        memmove(v34, v34 + 1, v33);
LABEL_25:
        unint64_t v35 = v57;
        if (v57)
        {
          unint64_t v36 = 0LL;
          double v37 = (double *)a5;
          while (2)
          {
            int v38 = *(_DWORD *)v37;
            if (*(_DWORD *)v37 == (_DWORD)v26) {
              goto LABEL_41;
            }
            unsigned int v39 = *((_DWORD *)v37 + 1);
            BOOL v40 = v39 == (_DWORD)v25 || v38 == (_DWORD)v25;
            if (v40 || v39 == (_DWORD)v26) {
              goto LABEL_41;
            }
            double v42 = *((double *)a5 + 2);
            double v43 = v37[2];
            if (v42 == v43)
            {
              if (a5[1] - *a5 <= v39 - v38) {
                goto LABEL_39;
              }
LABEL_37:
              __int128 v44 = *(_OWORD *)a5;
              uint64_t v45 = *((void *)a5 + 2);
              uint64_t v46 = *((void *)v37 + 2);
              *(_OWORD *)a5 = *(_OWORD *)v37;
              *((void *)a5 + 2) = v46;
            }

            else
            {
              if (v42 > v43) {
                goto LABEL_37;
              }
LABEL_39:
              __int128 v44 = *(_OWORD *)v37;
              uint64_t v45 = *((void *)v37 + 2);
            }

            unint64_t v47 = &a5[6 * v36];
            *((void *)v47 + 2) = v45;
            *(_OWORD *)unint64_t v47 = v44;
            ++v36;
LABEL_41:
            v37 += 3;
            if (!--v35) {
              goto LABEL_44;
            }
            continue;
          }
        }

        unint64_t v36 = 0LL;
LABEL_44:
        unint64_t v57 = v36;
        if (!v31) {
          return v31;
        }
        unsigned int v48 = v23;
        unint64_t v49 = v31;
        do
        {
          unsigned int v50 = *v48++;
          BrotliCompareAndPushToQueueCommand(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
          --v49;
        }

        while (v49);
        a6 = v31;
        unint64_t v23 = a4;
      }

      if (v31 <= v22) {
        return v31;
      }
    }
  }

  return v55;
}

double BrotliHistogramBitCostDistanceCommand(void *__src, uint64_t a2)
{
  if (!__src[352]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0LL;
  v6[352] += *(void *)(a2 + 2816);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2LL;
  }

  while (v3 != 352);
  BrotliPopulationCostCommand((uint64_t)v6);
  return v4 - *(double *)(a2 + 2824);
}

void BrotliHistogramRemapCommand( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0LL;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceCommand((void *)(a1 + 2832 * i), a5 + 2832LL * v12);
      if (a4)
      {
        double v14 = v13;
        uint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceCommand((void *)(a1 + 2832 * i), a5 + 2832LL * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }

          ++v15;
          --v16;
        }

        while (v16);
      }

      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }

  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 2832LL * v18), 0xB08uLL);
    *(void *)(a5 + 2832LL * v18 + 2824) = 0x7FF0000000000000LL;
  }

  if (a2)
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0LL;
      uint64_t v22 = a5 + 2832LL * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 2816) += *(void *)(a1 + 2832 * v19 + 2816);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4LL;
      }

      while (v21 != 2816);
      ++v19;
      v20 += 2832LL;
    }

    while (v19 != a2);
  }

uint64_t BrotliHistogramReindexCommand(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4LL * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }

    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0LL;
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 2832LL * v17++), &a2[2832 * v18], 0xB10uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4LL * *a3);
        }

        *a3++ = v19;
        --v4;
      }

      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0xB10uLL);
          v20 += 2832;
          a2 += 2832;
          --v21;
        }

        while (v21);
        goto LABEL_25;
      }
    }

    else
    {
      BrotliFree(a1, v9);
    }

    uint64_t v16 = 0LL;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }

  uint64_t v16 = 0LL;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0LL;
    unint64_t v9 = 0LL;
    goto LABEL_14;
  }

  return v16;
}

void BrotliClusterHistogramsCommand( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_181097240, 4 * a3);
    uint64_t v15 = 0LL;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0xB10uLL);
      BrotliPopulationCostCommand((uint64_t)v17);
      *((void *)v16 + 353) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 2832;
      v16 += 2832;
    }

    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }

  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
  }

  uint64_t v34 = a1;
  unint64_t v35 = v19;
  unint64_t v21 = 0LL;
  if (a3)
  {
    unint64_t v22 = 0LL;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64LL;
      }
      if (a3 - v22 >= 0x40) {
        unint64_t v25 = 64LL;
      }
      else {
        unint64_t v25 = a3 - v22;
      }
      if (v25)
      {
        uint64_t v26 = 0LL;
        do
        {
          v12[v21 + v26] = v22 + v26;
          ++v26;
        }

        while (v23 != v26);
      }

      v21 += BrotliHistogramCombineCommand((uint64_t)a5, (uint64_t)v11, &a7[v22], &v12[v21], v14, v25, v25, a4, 0x800uLL);
      v22 += 64LL;
      unint64_t v23 = v24;
    }

    while (v22 < a3);
  }

  if (v21 << 6 >= (v21 >> 1) * v21) {
    unint64_t v27 = (v21 >> 1) * v21;
  }
  else {
    unint64_t v27 = v21 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }

  else
  {
    uint64_t v28 = 2048LL;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2LL;
    }

    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }

  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineCommand((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v21, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapCommand(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexCommand(v29, a5, a7, a3);
  }

void BrotliCompareAndPushToQueueDistance( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[274] = v12;
    v40[275] = v11;
    v40[276] = v10;
    v40[277] = v9;
    v40[288] = v7;
    v40[289] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4LL * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4LL * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 2192LL * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 2184);
    uint64_t v29 = a1 + 2192LL * v19;
    double v30 = *(double *)(v29 + 2184);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 2176)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 2192LL * v19 + 2176);
    double v30 = *(double *)(v27 + 2184);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0x890uLL);
    uint64_t v34 = 0LL;
    v40[272] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2LL;
    }

    while (v34 != 272);
    BrotliPopulationCostDistance((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }

        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }

          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }

      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }

unint64_t BrotliHistogramCombineDistance( uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0LL;
  if (!a6) {
    return 0LL;
  }
  uint64_t v12 = 0LL;
  unint64_t v13 = a9;
  unint64_t v14 = a6 - 1;
  uint64_t v15 = a4 + 1;
  unint64_t v55 = a6;
  do
  {
    uint64_t v17 = v12 + 1;
    if (v12 + 1 < a6)
    {
      uint64_t v18 = v15;
      unint64_t v19 = v14;
      do
      {
        unsigned int v20 = *v18++;
        BrotliCompareAndPushToQueueDistance(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
        unint64_t v13 = a9;
        --v19;
      }

      while (v19);
    }

    --v14;
    ++v15;
    ++v12;
    a6 = v55;
  }

  while (v17 != v55);
  if (v55 >= 2)
  {
    double v21 = 0.0;
    unint64_t v22 = 1LL;
    unint64_t v23 = a4;
    while (1)
    {
      if (*((double *)a5 + 2) >= v21)
      {
        unint64_t v22 = a8;
        double v21 = 1.0e99;
        unint64_t v31 = a6;
      }

      else
      {
        uint64_t v24 = 0LL;
        uint64_t v26 = *a5;
        uint64_t v25 = a5[1];
        uint64_t v27 = a1 + 2192LL * v26;
        uint64_t v28 = a1 + 2192LL * v25;
        *(void *)(v27 + 2176) += *(void *)(v28 + 2176);
        do
        {
          *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
          v24 += 4LL;
        }

        while (v24 != 2176);
        *(void *)(a1 + 2192LL * v26 + 2184) = *((void *)a5 + 1);
        *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
        uint64_t v29 = a3;
        for (uint64_t i = a7; i; --i)
        {
          if (*v29 == (_DWORD)v25) {
            *uint64_t v29 = v26;
          }
          ++v29;
        }

        unint64_t v31 = a6 - 1;
        if (a6 <= 1) {
          uint64_t v32 = 1LL;
        }
        else {
          uint64_t v32 = a6;
        }
        size_t v33 = 4 * a6 - 4;
        uint64_t v34 = v23;
        while (*v34 != (_DWORD)v25)
        {
          v33 -= 4LL;
          ++v34;
          if (!--v32) {
            goto LABEL_25;
          }
        }

        memmove(v34, v34 + 1, v33);
LABEL_25:
        unint64_t v35 = v57;
        if (v57)
        {
          unint64_t v36 = 0LL;
          double v37 = (double *)a5;
          while (2)
          {
            int v38 = *(_DWORD *)v37;
            if (*(_DWORD *)v37 == (_DWORD)v26) {
              goto LABEL_41;
            }
            unsigned int v39 = *((_DWORD *)v37 + 1);
            BOOL v40 = v39 == (_DWORD)v25 || v38 == (_DWORD)v25;
            if (v40 || v39 == (_DWORD)v26) {
              goto LABEL_41;
            }
            double v42 = *((double *)a5 + 2);
            double v43 = v37[2];
            if (v42 == v43)
            {
              if (a5[1] - *a5 <= v39 - v38) {
                goto LABEL_39;
              }
LABEL_37:
              __int128 v44 = *(_OWORD *)a5;
              uint64_t v45 = *((void *)a5 + 2);
              uint64_t v46 = *((void *)v37 + 2);
              *(_OWORD *)a5 = *(_OWORD *)v37;
              *((void *)a5 + 2) = v46;
            }

            else
            {
              if (v42 > v43) {
                goto LABEL_37;
              }
LABEL_39:
              __int128 v44 = *(_OWORD *)v37;
              uint64_t v45 = *((void *)v37 + 2);
            }

            unint64_t v47 = &a5[6 * v36];
            *((void *)v47 + 2) = v45;
            *(_OWORD *)unint64_t v47 = v44;
            ++v36;
LABEL_41:
            v37 += 3;
            if (!--v35) {
              goto LABEL_44;
            }
            continue;
          }
        }

        unint64_t v36 = 0LL;
LABEL_44:
        unint64_t v57 = v36;
        if (!v31) {
          return v31;
        }
        unsigned int v48 = v23;
        unint64_t v49 = v31;
        do
        {
          unsigned int v50 = *v48++;
          BrotliCompareAndPushToQueueDistance(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
          --v49;
        }

        while (v49);
        a6 = v31;
        unint64_t v23 = a4;
      }

      if (v31 <= v22) {
        return v31;
      }
    }
  }

  return v55;
}

double BrotliHistogramBitCostDistanceDistance(void *__src, uint64_t a2)
{
  if (!__src[272]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0LL;
  v6[272] += *(void *)(a2 + 2176);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2LL;
  }

  while (v3 != 272);
  BrotliPopulationCostDistance((uint64_t)v6);
  return v4 - *(double *)(a2 + 2184);
}

void BrotliHistogramRemapDistance( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0LL; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0LL;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceDistance((void *)(a1 + 2192 * i), a5 + 2192LL * v12);
      if (a4)
      {
        double v14 = v13;
        uint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceDistance((void *)(a1 + 2192 * i), a5 + 2192LL * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }

          ++v15;
          --v16;
        }

        while (v16);
      }

      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }

  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 2192LL * v18), 0x888uLL);
    *(void *)(a5 + 2192LL * v18 + 2184) = 0x7FF0000000000000LL;
  }

  if (a2)
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0LL;
      uint64_t v22 = a5 + 2192LL * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 2176) += *(void *)(a1 + 2192 * v19 + 2176);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4LL;
      }

      while (v21 != 2176);
      ++v19;
      v20 += 2192LL;
    }

    while (v19 != a2);
  }

uint64_t BrotliHistogramReindexDistance(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4LL * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }

    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0LL;
    if (*(_DWORD *)(a1 + 24)) {
      return 0LL;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 2192LL * v17++), &a2[2192 * v18], 0x890uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4LL * *a3);
        }

        *a3++ = v19;
        --v4;
      }

      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0x890uLL);
          v20 += 2192;
          a2 += 2192;
          --v21;
        }

        while (v21);
        goto LABEL_25;
      }
    }

    else
    {
      BrotliFree(a1, v9);
    }

    uint64_t v16 = 0LL;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }

  uint64_t v16 = 0LL;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0LL;
    unint64_t v9 = 0LL;
    goto LABEL_14;
  }

  return v16;
}

void BrotliClusterHistogramsDistance( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_181097240, 4 * a3);
    uint64_t v15 = 0LL;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0x890uLL);
      BrotliPopulationCostDistance((uint64_t)v17);
      *((void *)v16 + 273) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 2192;
      v16 += 2192;
    }

    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }

  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
  }

  uint64_t v34 = a1;
  unint64_t v35 = v19;
  unint64_t v21 = 0LL;
  if (a3)
  {
    unint64_t v22 = 0LL;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64LL;
      }
      if (a3 - v22 >= 0x40) {
        unint64_t v25 = 64LL;
      }
      else {
        unint64_t v25 = a3 - v22;
      }
      if (v25)
      {
        uint64_t v26 = 0LL;
        do
        {
          v12[v21 + v26] = v22 + v26;
          ++v26;
        }

        while (v23 != v26);
      }

      v21 += BrotliHistogramCombineDistance((uint64_t)a5, (uint64_t)v11, &a7[v22], &v12[v21], v14, v25, v25, a4, 0x800uLL);
      v22 += 64LL;
      unint64_t v23 = v24;
    }

    while (v22 < a3);
  }

  if (v21 << 6 >= (v21 >> 1) * v21) {
    unint64_t v27 = (v21 >> 1) * v21;
  }
  else {
    unint64_t v27 = v21 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }

  else
  {
    uint64_t v28 = 2048LL;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2LL;
    }

    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }

  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineDistance((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v21, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapDistance(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexDistance(v29, a5, a7, a3);
  }

uint64_t lzfseStreamDecodeStateSize()
{
  return 1620288LL;
}

uint64_t lzfseStreamDecodeInit(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v5 = *(_DWORD **)(a1 + 32);
  }

  else
  {
    uint64_t v5 = 0LL;
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  uint64_t v6 = realloc_stream_state(v5, 1, a2, 0x18B940u, 0x180000u);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  uint64_t result = 0LL;
  if (a2 == 2193) {
    int v9 = 15000;
  }
  else {
    int v9 = 40000;
  }
  v7[1838] = v9;
  *((void *)v7 + 16) -= v7;
  *((void *)v7 + 10) = 833856LL;
  *((void *)v7 + 11) = 1620288LL;
  *((void *)v7 + 6) = 47424LL;
  *((void *)v7 + 7) = 47424LL;
  *((void *)v7 + 8) = 47424LL;
  *((void *)v7 + 9) = 833856LL;
  *((void *)v7 + 2) = 47424LL;
  *((void *)v7 + 3) = 833856LL;
  *((void *)v7 + 4) = 833856LL;
  return result;
}

uint64_t lzfseStreamDecode(uint64_t a1, char a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  int64x2_t v5 = *(int64x2_t *)(v4 + 48);
  *(void *)(v4 + 128) += v4;
  int64x2_t v6 = vdupq_n_s64(v4);
  *(int64x2_t *)(v4 + 48) = vaddq_s64(v6, v5);
  int64x2_t v7 = vaddq_s64(v6, *(int64x2_t *)(v4 + 80));
  *(int64x2_t *)(v4 + 64) = vaddq_s64(v6, *(int64x2_t *)(v4 + 64));
  *(int64x2_t *)(v4 + 80) = v7;
  int64x2_t v28 = v6;
  int64x2_t v8 = vaddq_s64(v6, *(int64x2_t *)(v4 + 16));
  *(int64x2_t *)(v4 + 16) = v8;
  *(void *)(v4 + 32) += v4;
  int v9 = (char *)v8.i64[0];
  while (1)
  {
    uint64_t v10 = *(void *)(v4 + 64);
    else {
      size_t v11 = *(void *)(a1 + 24);
    }
    if (v11)
    {
      memcpy(*(void **)(v4 + 64), *(const void **)(a1 + 16), v11);
      *(void *)(v4 + 64) += v11;
      size_t v12 = *(void *)(a1 + 24) - v11;
      *(void *)(a1 + 16) += v11;
      *(void *)(a1 + 24) = v12;
    }

    unint64_t v14 = *(void *)(v4 + 24);
    unint64_t v13 = *(void *)(v4 + 32);
    if (v13 >= v14 + 393216)
    {
      uint64_t v15 = *(_BYTE **)(v4 + 72);
      uint64_t v16 = v15 - 0x40000;
      else {
        unsigned int v17 = *(_BYTE **)(v4 + 24);
      }
      if (v14 < (unint64_t)v16)
      {
        if (v15 != v17)
        {
          memmove(*(void **)(v4 + 80), v17, v15 - v17);
          unint64_t v13 = *(void *)(v4 + 32);
          uint64_t v15 = *(_BYTE **)(v4 + 72);
        }

        *(void *)(v4 + 32) = v13 + v14 - (void)v17;
        *(void *)(v4 + 72) = &v15[v14 - (void)v17];
      }
    }

    if (!*(_DWORD *)(v4 + 40) && *(void *)(v4 + 72) < *(void *)(v4 + 88))
    {
      int v18 = lzfseDecode(v4 + 48);
      if (v18 == -1)
      {
        if ((a2 & 1) != 0)
        {
LABEL_46:
          char v25 = 1;
          goto LABEL_41;
        }
      }

      else if (v18 == -3)
      {
        goto LABEL_46;
      }

      if (*(_DWORD *)(v4 + 96)) {
        *(_DWORD *)(v4 + 40) = 1;
      }
    }

    if (*(_DWORD *)(v4 + 44)) {
      goto LABEL_40;
    }
    unsigned int v19 = *(char **)(v4 + 32);
    if (*(void *)(a1 + 8) >= *(void *)(v4 + 72) - (void)v19) {
      size_t v20 = *(void *)(v4 + 72) - (void)v19;
    }
    else {
      size_t v20 = *(void *)(a1 + 8);
    }
    if (v20)
    {
      memcpy(*(void **)a1, v19, v20);
      unsigned int v19 = (char *)(*(void *)(v4 + 32) + v20);
      *(void *)(v4 + 32) = v19;
      size_t v21 = *(void *)(a1 + 8) - v20;
      *(void *)a1 += v20;
      *(void *)(a1 + 8) = v21;
    }

    if (*(_DWORD *)(v4 + 44))
    {
LABEL_40:
      char v25 = 0;
LABEL_41:
      uint64_t v26 = *(char **)(v4 + 72);
      unsigned int v19 = *(char **)(v4 + 32);
      goto LABEL_42;
    }

    unint64_t v22 = *(char **)(v4 + 48);
    int v9 = *(char **)(v4 + 16);
    if (v22 >= v9 + 393216)
    {
      uint64_t v23 = *(void *)(v4 + 64);
      uint64_t v24 = v23 - (void)v22;
      if (v23 - (uint64_t)v22 >= 1)
      {
        memmove(v9, v22, v23 - (void)v22);
        int v9 = *(char **)(v4 + 16);
      }

      *(void *)(v4 + 48) = v9;
      *(void *)(v4 + 64) = &v9[v24];
    }

    char v25 = v20 | v11;
    if (!(v20 | v11)) {
      goto LABEL_41;
    }
  }

  char v25 = 0;
  *(_DWORD *)(v4 + 44) = 1;
  uint64_t v26 = v19;
LABEL_42:
  *(void *)(v4 + 128) -= v4;
  *(int64x2_t *)(v4 + 48) = vsubq_s64(*(int64x2_t *)(v4 + 48), v28);
  *(void *)(v4 + 64) -= v4;
  *(void *)(v4 + 72) = &v26[-v4];
  *(int64x2_t *)(v4 + 80) = vsubq_s64(*(int64x2_t *)(v4 + 80), v28);
  *(int64x2_t *)(v4 + 16) = vsubq_s64(*(int64x2_t *)(v4 + 16), v28);
  *(void *)(v4 + 32) = &v19[-v4];
  if ((v25 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(_DWORD *)(v4 + 44) != 0;
  }
}

uint64_t lzbitmap_fast_decode(uint64_t a1, uint64_t a2, int8x16_t *a3, unsigned int a4, int8x16_t a5)
{
  uint64_t v7 = a2;
  if ((_DWORD)a2)
  {
    uint64_t v9 = 0LL;
    unint64_t v10 = (unint64_t)a3->u64 + a4;
    uint64_t v11 = -(int)a2;
    unsigned int v12 = 8;
    unint64_t v13 = (int8x16_t *)&lzbitmap_fast_unpack_dist;
    uint8x16_t v14 = (uint8x16_t)xmmword_181096B20;
    v15.i64[0] = -1LL;
    v15.i64[1] = -1LL;
    int32x4_t v16 = (int32x4_t)xmmword_181096B10;
    v6.i32[0] = -1;
    v17.i64[0] = 0x800000008LL;
    v17.i64[1] = 0x800000008LL;
    int v18 = 1;
    while (1)
    {
      unsigned int v19 = &a3->u8[5];
      size_t v20 = (int8x16_t *)((char *)a3->i64 + 4);
      unint64_t v21 = a3->u32[0];
      unint64_t v22 = v21 >> 16;
      int v23 = (unsigned __int16)a3->i32[0];
      if (v23 == 0xFFFF && !v20->i8[0])
      {
        else {
          unsigned __int16 v89 = v7 - v9;
        }
        uint64_t v90 = v11;
        unsigned int v94 = v12;
        unint64_t v91 = v10;
        char v92 = v13;
        int32x4_t v96 = v16;
        uint8x16_t v97 = v14;
        int32x4_t v95 = v6;
        memcpy((void *)(a1 + v9), v19, v89);
        v17.i64[0] = 0x800000008LL;
        v17.i64[1] = 0x800000008LL;
        int32x4_t v6 = v95;
        int32x4_t v16 = v96;
        v15.i64[0] = -1LL;
        v15.i64[1] = -1LL;
        uint8x16_t v14 = v97;
        unint64_t v13 = v92;
        unint64_t v10 = v91;
        unsigned int v12 = v94;
        uint64_t v11 = v90;
        uint64_t v9 = v9 + v89;
        a3 = (int8x16_t *)&v19[v89];
      }

      else
      {
        a5.i32[0] = (unsigned __int16)a3->i32[0];
        *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
        a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
        uint64_t v24 = (int8x16_t *)((char *)v20 + a5.u32[0]);
        if ((int)v9 + 128 > v7 || (unint64_t)a3[11].u64 + 4 > v10)
        {
          a5.i32[0] = HIWORD(a3->i32[0]);
          *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
          a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
          a3 = (int8x16_t *)((char *)v24 + (2 * a5.i32[0]));
          if ((unint64_t)a3 <= v10)
          {
            int v78 = 1;
            while (1)
            {
              int v79 = v9;
              if ((v78 & v22) != 0)
              {
                unsigned int v80 = v24->u16[0];
                uint64_t v24 = (int8x16_t *)((char *)v24 + 2);
                unsigned int v12 = v80;
              }

              if ((v78 & v23) != 0)
              {
                unsigned __int32 v82 = v20->u8[0];
                size_t v20 = (int8x16_t *)((char *)v20 + 1);
                unsigned __int32 v81 = v82;
              }

              else
              {
                unsigned __int32 v81 = 0;
              }

              a5.i32[0] = v81;
              *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
              a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
              int v83 = 0;
              int v84 = v9 - (unsigned __int16)v12;
              int v85 = v11 + v9;
              while (1)
              {
                LODWORD(v9) = v79 + v83;
                if (v83 == 8) {
                  break;
                }
                int v86 = 1 << v83;
                int v87 = v83 + 1;
                int v88 = (int8x16_t *)(a1 + (v84 + v83));
                if ((v86 & v81) != 0)
                {
                  int v88 = a3;
                  a3 = (int8x16_t *)((char *)a3 + 1);
                }

                *(_BYTE *)(a1 + v9) = v88->i8[0];
                int v83 = v87;
                if (!(v85 + v87)) {
                  return v7;
                }
              }

              v78 *= 2;
              if (v78 >= 0x10000)
              {
                uint64_t v9 = (v79 + 8);
                goto LABEL_54;
              }
            }
          }

          return 0LL;
        }

        int8x16_t v25 = vcntq_s8((int8x16_t)vdupq_n_s16(v22));
        a5 = vorrq_s8( vandq_s8((int8x16_t)vdupq_n_s16(v12), vcltzq_s8(v13[BYTE2(v21)])),  vqtbl1q_s8(*v24, v13[BYTE2(v21)]));
        v25.i16[0] = vaddq_s8(v25, v25).u16[0];
        a3 = (int8x16_t *)((char *)v24 + ((v25.i8[0] + v25.i8[1]) & 0x3E));
        int8x16_t v26 = vorrq_s8( vandq_s8( (int8x16_t)vdupq_laneq_s16((int16x8_t)a5, 7),  vcltzq_s8(*(int8x16_t *)((char *)v13 + ((v21 >> 20) & 0xFF0)))),  vqtbl1q_s8( *(int8x16_t *)((char *)v24 + (v25.i8[0] & 0x1E)),  *(int8x16_t *)((char *)v13 + ((v21 >> 20) & 0xFF0))));
        unsigned int v12 = v26.u16[7];
        if (v7 > v9)
        {
          unsigned int v27 = 0;
          *(int8x8_t *)v28.i8 = vdup_n_s8(v21);
          int8x8_t v29 = (int8x8_t)vdup_n_s16(v21);
          v28.u64[1] = (unint64_t)vuzp2_s8(v29, v29);
          int8x16_t v30 = (int8x16_t)vshlq_u8(v28, v14);
          int8x16_t v31 = vcgtq_s8(v30, v15);
          int8x16_t v32 = vcntq_s8(v30);
          v32.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL),  vdup_lane_s8(*(int8x8_t *)v32.i8, 7));
          int8x16_t v33 = vqtbl1q_s8(*v20, vorrq_s8(vaddq_s8(v32, v15), v31));
          unint64_t v34 = vextq_s8(v26, v26, 8uLL).u64[0];
          v31.i64[0] = vextq_s8(v33, v33, 8uLL).u64[0];
          int8x8_t v35 = vzip2_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)a5.i8);
          int8x8_t v36 = vzip1_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)a5.i8);
          unint64_t v37 = vextq_s8(a5, a5, 8uLL).u64[0];
          int8x8_t v38 = vzip2_s8(*(int8x8_t *)v33.i8, *(int8x8_t *)a5.i8);
          int8x8_t v39 = vzip1_s8(*(int8x8_t *)v33.i8, *(int8x8_t *)a5.i8);
          while (1)
          {
            switch(v27)
            {
              case 0u:
                uint16x4_t v40 = *(uint16x4_t *)a5.i8;
                *(int8x8_t *)v5.i8 = v39;
                break;
              case 1u:
                uint16x4_t v40 = (uint16x4_t)v37;
                *(int8x8_t *)v5.i8 = v38;
                break;
              case 2u:
                uint16x4_t v40 = *(uint16x4_t *)v26.i8;
                *(int8x8_t *)v5.i8 = v36;
                break;
              case 3u:
                uint16x4_t v40 = (uint16x4_t)v34;
                *(int8x8_t *)v5.i8 = v35;
                break;
              default:
                uint16x4_t v40 = 0LL;
                int16x8_t v5 = 0uLL;
                break;
            }

            int32x4_t v41 = vdupq_n_s32(v9);
            uint32x4_t v42 = (uint32x4_t)vaddq_s32(v41, v16);
            int8x16_t v43 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vceq_s16( (int16x4_t)(v5.i64[0] & 0xFF00FF00FF00FFLL),  (int16x4_t)0xFF00FF00FF00FFLL)));
            int32x4_t v44 = (int32x4_t)vandq_s8(v43, (int8x16_t)vcgtq_u32(vmovl_u16(v40), v42));
            v44.i32[0] = vmaxvq_u32((uint32x4_t)v44);
            int v45 = v44.i32[0];
            if (v44.i32[0] < 0) {
              return 0LL;
            }
            int32x4_t v46 = (int32x4_t)vandq_s8( vandq_s8((int8x16_t)vsubw_u16(v42, v40), v43),  (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v44, v6), 0));
            int16x4_t v47 = (int16x4_t)vmovn_s16(v5);
            v47.i16[2] = v47.i16[1];
            __int32 v99 = v47.i32[0];
            v5.i32[0] = v47.u16[0];
            uint8x8_t v48 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v5.i8);
            v48.i16[0] = vaddlv_u8(v48);
            unsigned __int32 v49 = v48.i32[0];
            int16x8_t v50 = vdupq_lane_s16(v47, 0);
            *(int8x8_t *)v51.i8 = vmovn_s16(v50);
            v51.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v50.i8);
            int8x16_t v52 = (int8x16_t)vshlq_u8(v51, v14);
            int8x16_t v53 = vcgtq_s8(v52, v15);
            int8x16_t v54 = vcntq_s8(v52);
            v54.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL),  vdup_lane_s8(*(int8x8_t *)v54.i8, 7));
            int8x16_t v55 = vorrq_s8(vaddq_s8(v54, v15), v53);
            int16x8_t v5 = (int16x8_t)vqtbl1q_s8(*a3, v55);
            int16x8_t v56 = vdupq_lane_s16(v47, 2);
            int8x16_t v57 = vceqq_s8(v55, v15);
            *(int8x8_t *)v58.i8 = vmovn_s16(v56);
            v58.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v56.i8, *(int8x8_t *)v56.i8);
            int8x16_t v59 = (int8x16_t)vshlq_u8(v58, v14);
            int8x16_t v60 = vcgtq_s8(v59, v15);
            int8x16_t v61 = vcntq_s8(v59);
            v61.u64[1] = (unint64_t)vadd_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL),  vdup_lane_s8(*(int8x8_t *)v61.i8, 7));
            int8x16_t v62 = vorrq_s8(vaddq_s8(v61, v15), v60);
            int8x16_t v63 = vqtbl1q_s8(*(int8x16_t *)((char *)a3 + v49), v62);
            int8x16_t v64 = vceqq_s8(v62, v15);
            if ((vminvq_u32(vcgeq_u32((uint32x4_t)v41, (uint32x4_t)vaddq_s32(v46, v17))) & 0x80000000) == 0)
            {
              int v65 = 0;
              int8x8_t v66 = (int8x8_t)vextq_s8(v63, v63, 8uLL).u64[0];
              int8x8_t v67 = (int8x8_t)vextq_s8(v64, v64, 8uLL).u64[0];
              int8x8_t v68 = (int8x8_t)vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL).u64[0];
              int8x8_t v69 = (int8x8_t)vextq_s8(v57, v57, 8uLL).u64[0];
              while (1)
              {
                int32x4_t v98 = v46;
                int8x8_t v70 = *(int8x8_t *)(a1
                                  + *(unsigned int *)((unint64_t)&v98 & 0xFFFFFFFFFFFFFFF3LL | (4LL * (v65 & 3))));
                switch(v65)
                {
                  case 0:
                    int8x8_t v71 = vorr_s8(vand_s8(v70, *(int8x8_t *)v57.i8), *(int8x8_t *)v5.i8);
                    goto LABEL_24;
                  case 1:
                    int8x8_t v71 = vorr_s8(vand_s8(v70, v69), v68);
                    goto LABEL_24;
                  case 2:
                    int8x8_t v71 = vorr_s8(vand_s8(v70, *(int8x8_t *)v64.i8), *(int8x8_t *)v63.i8);
                    goto LABEL_24;
                  case 3:
                    *(int8x8_t *)(a1 + v9) = vorr_s8(vand_s8(v70, v67), v66);
                    uint64_t v9 = (v9 + 8);
                    goto LABEL_27;
                  default:
                    int8x8_t v71 = 0LL;
LABEL_24:
                    *(int8x8_t *)(a1 + v9) = v71;
                    LODWORD(v9) = v9 + 8;
                    ++v65;
                    break;
                }
              }
            }

            v72.i64[0] = v46.u32[2];
            v72.i64[1] = v46.u32[3];
            int8x16_t v73 = v72;
            v72.i64[1] = v46.u32[1];
            v74.i64[0] = *(void *)(a1 + v46.u32[0]);
            v73.i64[0] = *(void *)(a1 + v73.i64[0]);
            v74.i64[1] = *(void *)(a1 + v72.i64[1]);
            v73.i64[1] = *(void *)(a1 + v73.i64[1]);
            int8x16_t v75 = vorrq_s8(vandq_s8(v74, v57), (int8x16_t)v5);
            int16x8_t v5 = (int16x8_t)vorrq_s8(vandq_s8(v73, v64), v63);
            uint64_t v76 = (int8x16_t *)(a1 + v9);
            int8x16_t *v76 = v75;
            v76[1] = (int8x16_t)v5;
            uint64_t v9 = (v9 + 32);
LABEL_27:
            v18 &= ~(v45 >> 31);
            v47.i32[0] = v47.u16[1];
            uint8x8_t v77 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
            v77.i16[0] = vaddlv_u8(v77);
            a3 = (int8x16_t *)((char *)a3 + v77.i32[0] + v49);
            if (v27 <= 2)
            {
              ++v27;
            }

            break;
          }
        }
      }

uint64_t read_expected(int a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a3)
  {
    unint64_t v6 = 0LL;
    while (1)
    {
      ssize_t v7 = read(a1, (void *)(a2 + v6), v3 - v6);
      if (v7 <= 0) {
        break;
      }
      v6 += v7;
      if (v6 >= v3) {
        return v3;
      }
    }

    if (v7) {
      return -1LL;
    }
    else {
      return v6;
    }
  }

  return v3;
}

uint64_t write_expected(int __fd, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a3)
  {
    unint64_t v6 = 0LL;
    while (1)
    {
      ssize_t v7 = write(__fd, (const void *)(a2 + v6), v3 - v6);
      if (v7 <= 0) {
        break;
      }
      v6 += v7;
      if (v6 >= v3) {
        return v3;
      }
    }

    return -1LL;
  }

  return v3;
}

uint64_t parse_size(const char *a1)
{
  __endptr = 0LL;
  uint64_t v1 = strtoll(a1, &__endptr, 10);
  int v2 = *__endptr;
  uint64_t v3 = -1LL;
  if (v2 <= 102)
  {
    if (!*__endptr || v2 == 98) {
      return v1;
    }
  }

  else
  {
    switch(v2)
    {
      case 'g':
        v1 <<= 30;
        return v1;
      case 'm':
        v1 <<= 20;
        return v1;
      case 'k':
        v1 <<= 10;
        return v1;
    }
  }

  return v3;
}

double get_real_time()
{
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t get_default_nthreads()
{
  unsigned int v2 = 0;
  size_t v1 = 4LL;
  if (sysctlbyname("hw.physicalcpu", &v2, &v1, 0LL, 0LL)) {
    return 1LL;
  }
  else {
    return v2;
  }
}

__n128 lzma1_model_reset(__n128 *a1, void *__b)
{
  result.n128_u64[0] = 0x100000001LL;
  result.n128_u64[1] = 0x100000001LL;
  *a1 = result;
  a1[1].n128_u64[0] = (unint64_t)__b;
  a1[1].n128_u8[13] = 0;
  return result;
}

uint64_t lzma1_chunk_decode( unsigned int *a1, unint64_t a2, _BYTE *a3, _BYTE *a4, unint64_t a5, unsigned __int8 *a6, uint64_t a7)
{
  ssize_t v7 = (unsigned __int16 *)*((void *)a1 + 2);
  if (!v7 || !a7) {
    return 0LL;
  }
  uint64_t v8 = *((unsigned __int8 *)a1 + 29);
  if (a7 < 1)
  {
    int v10 = 0;
    uint64_t v9 = a6;
  }

  else
  {
    uint64_t v9 = a6 + 1;
    int v10 = *a6;
  }

  unsigned int v11 = 0;
  unsigned int v613 = *((unsigned __int8 *)a1 + 28);
  int v610 = *((unsigned __int8 *)a1 + 27);
  unsigned int v12 = &a6[a7];
  int v13 = 4;
  char v611 = *((_BYTE *)a1 + 26);
  do
  {
    if (v9 >= v12)
    {
      int v14 = 0;
    }

    else
    {
      int v15 = *v9++;
      int v14 = v15;
    }

    unsigned int v11 = (v11 << 8) | v14;
    --v13;
  }

  while (v13);
  uint64_t v16 = 0LL;
  if (!v10 && v11 != -1)
  {
    if (a3 >= a4)
    {
      uint32x4_t v213 = a3;
      goto LABEL_830;
    }

    char v609 = 8 - v611;
    __int128 v607 = v7 + 1220;
    __int128 v608 = v7 + 690;
    int32x4_t v17 = v7 + 1940;
    unsigned int v18 = -1;
    unsigned int v19 = a3;
    while (1)
    {
      if (!HIBYTE(v18))
      {
        if (v9 >= v12)
        {
          int v20 = 0;
        }

        else
        {
          int v21 = *v9++;
          int v20 = v21;
        }

        v18 <<= 8;
        unsigned int v11 = v20 | (v11 << 8);
      }

      int v22 = (_DWORD)v19 - a2;
      unsigned int v23 = v613 & ((_DWORD)v19 - a2);
      uint64_t v24 = &v7[16 * v8 + v23];
      unsigned int v25 = *v24;
      unsigned int v26 = (v18 >> 11) * v25;
      unsigned int v27 = v11 - v26;
      if (v11 < v26)
      {
        *uint64_t v24 = v25 + ((2048 - v25) >> 5);
        else {
          unsigned int v28 = *(v19 - 1);
        }
        uint64_t v29 = (uint64_t)&v7[816 * ((v28 >> v609) | ((v22 & v610) << v611)) + 1956];
        if (!lzma_fsm_lut[v8])
        {
          int v30 = 0;
          int v31 = v19[-*a1];
          uint64_t v32 = (uint64_t)&v7[816 * ((v28 >> v609) | ((v22 & v610) << v611)) + 2724];
          unsigned int v33 = v31 & 0xF0;
          unsigned int v34 = 1;
          do
          {
            int v35 = v30 - 3;
            if (v30 > 3) {
              break;
            }
            if (!HIBYTE(v26))
            {
              if (v9 >= v12)
              {
                int v36 = 0;
              }

              else
              {
                int v37 = *v9++;
                int v36 = v37;
              }

              v26 <<= 8;
              unsigned int v11 = v36 | (v11 << 8);
            }

            int v38 = 2 * v34;
            uint64_t v39 = ((2 * v34) | (v33 >> 7) & 1) + 16;
            unsigned int v40 = *(unsigned __int16 *)(v32 + 2LL * v39);
            int v41 = (v33 >> 7) & 1;
            unsigned int v42 = (v26 >> 11) * v40;
            unsigned int v43 = v40 + ((2048 - v40) >> 5);
            v26 -= v42;
            unsigned int v44 = v40 - (v40 >> 5);
            BOOL v45 = v11 >= v42;
            unsigned int v34 = v11 >= v42 ? v38 | 1 : v38;
            if (v11 >= v42) {
              v11 -= v42;
            }
            else {
              unsigned int v26 = v42;
            }
            __int16 v46 = v45 ? v44 : v43;
            int v47 = v45;
            *(_WORD *)(v32 + 2 * v39) = v46;
            if (v47 == v41)
            {
              ++v30;
            }

            else
            {
              if (v30 > 2) {
                break;
              }
              do
              {
                if (!HIBYTE(v26))
                {
                  if (v9 >= v12)
                  {
                    int v48 = 0;
                  }

                  else
                  {
                    int v49 = *v9++;
                    int v48 = v49;
                  }

                  v26 <<= 8;
                  unsigned int v11 = v48 | (v11 << 8);
                }

                unsigned int v50 = *(unsigned __int16 *)(v32 + 2LL * v34);
                uint64_t v51 = v34;
                unsigned int v52 = (v26 >> 11) * v50;
                v34 *= 2;
                unsigned int v53 = v50 + ((2048 - v50) >> 5);
                unsigned int v54 = v50 - (v50 >> 5);
                BOOL v55 = v11 >= v52;
                if (v11 < v52)
                {
                  unsigned int v26 = v52;
                }

                else
                {
                  v34 |= 1u;
                  v26 -= v52;
                }

                if (v11 >= v52) {
                  v11 -= v52;
                }
                if (!v55) {
                  LOWORD(v54) = v53;
                }
                *(_WORD *)(v32 + 2 * v51) = v54;
                BOOL v45 = __CFADD__(v35++, 1);
              }

              while (!v45);
              int v30 = 4;
            }

            v33 *= 2;
          }

          while (v47 == v41);
          int v57 = 16 * (v34 ^ 0x10);
          if ((v31 ^ v57) <= 0xF)
          {
            int v58 = 0;
            uint64_t v59 = v29 + 96LL * (v34 ^ 0x10);
            unsigned int v60 = 16 * v31;
            unsigned int v61 = 1;
            do
            {
              int v62 = v58 - 3;
              if (v58 > 3) {
                break;
              }
              if (!HIBYTE(v26))
              {
                if (v9 >= v12)
                {
                  int v63 = 0;
                }

                else
                {
                  int v64 = *v9++;
                  int v63 = v64;
                }

                v26 <<= 8;
                unsigned int v11 = v63 | (v11 << 8);
              }

              int v65 = 2 * v61;
              uint64_t v66 = ((2 * v61) | (v60 >> 7) & 1) + 16;
              unsigned int v67 = *(unsigned __int16 *)(v59 + 2LL * v66);
              int v68 = (v60 >> 7) & 1;
              unsigned int v69 = (v26 >> 11) * v67;
              unsigned int v70 = v67 + ((2048 - v67) >> 5);
              unsigned int v61 = (2 * v61) | 1;
              unsigned int v71 = v67 - (v67 >> 5);
              BOOL v72 = v11 >= v69;
              if (v11 >= v69)
              {
                v26 -= v69;
              }

              else
              {
                unsigned int v61 = v65;
                unsigned int v26 = v69;
              }

              if (v11 >= v69) {
                v11 -= v69;
              }
              __int16 v73 = v72 ? v71 : v70;
              int v74 = v72;
              *(_WORD *)(v59 + 2 * v66) = v73;
              if (v74 == v68)
              {
                ++v58;
              }

              else
              {
                if (v58 > 2) {
                  break;
                }
                do
                {
                  if (!HIBYTE(v26))
                  {
                    if (v9 >= v12)
                    {
                      int v75 = 0;
                    }

                    else
                    {
                      int v76 = *v9++;
                      int v75 = v76;
                    }

                    v26 <<= 8;
                    unsigned int v11 = v75 | (v11 << 8);
                  }

                  unsigned int v77 = *(unsigned __int16 *)(v59 + 2LL * v61);
                  uint64_t v78 = v61;
                  unsigned int v79 = (v26 >> 11) * v77;
                  v61 *= 2;
                  unsigned int v80 = v77 + ((2048 - v77) >> 5);
                  unsigned int v81 = v77 - (v77 >> 5);
                  BOOL v82 = v11 >= v79;
                  if (v11 < v79)
                  {
                    unsigned int v26 = v79;
                  }

                  else
                  {
                    v61 |= 1u;
                    v26 -= v79;
                  }

                  if (v11 >= v79) {
                    v11 -= v79;
                  }
                  if (!v82) {
                    LOWORD(v81) = v80;
                  }
                  *(_WORD *)(v59 + 2 * v78) = v81;
                  BOOL v45 = __CFADD__(v62++, 1);
                }

                while (!v45);
                int v58 = 4;
              }

              v60 *= 2;
            }

            while (v74 == v68);
            int v83 = v61 ^ 0x10;
            goto LABEL_199;
          }

          goto LABEL_153;
        }

        while (1)
        {
          uint64_t v84 = v29 + 1536;
          unsigned int v85 = *(unsigned __int16 *)(v29 + 1538);
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v86 = 0;
            }

            else
            {
              int v87 = *v9++;
              int v86 = v87;
            }

            v26 <<= 8;
            unsigned int v11 = v86 | (v11 << 8);
          }

          unsigned int v88 = (v26 >> 11) * v85;
          unsigned int v89 = v85 + ((2048 - v85) >> 5);
          unsigned int v90 = v26 - v88;
          unsigned int v91 = v11 - v88;
          unsigned int v92 = v85 - (v85 >> 5);
          if (v11 >= v88) {
            uint64_t v93 = 3LL;
          }
          else {
            uint64_t v93 = 2LL;
          }
          if (v11 >= v88)
          {
            __int16 v94 = v92;
          }

          else
          {
            unsigned int v90 = v88;
            unsigned int v91 = v11;
            __int16 v94 = v89;
          }

          *(_WORD *)(v29 + 1538) = v94;
          unsigned int v95 = *(unsigned __int16 *)(v84 + 2LL * v93);
          if (!HIBYTE(v90))
          {
            if (v9 >= v12)
            {
              int v96 = 0;
            }

            else
            {
              int v97 = *v9++;
              int v96 = v97;
            }

            v90 <<= 8;
            unsigned int v91 = v96 | (v91 << 8);
          }

          unsigned int v98 = (v90 >> 11) * v95;
          unsigned int v99 = v95 + ((2048 - v95) >> 5);
          unsigned int v100 = v90 - v98;
          unsigned int v101 = v95 - (v95 >> 5);
          BOOL v102 = v91 >= v98;
          if (v91 >= v98) {
            uint64_t v103 = (2 * (_DWORD)v93) | 1u;
          }
          else {
            uint64_t v103 = (2 * v93);
          }
          if (v91 >= v98) {
            unsigned int v104 = v100;
          }
          else {
            unsigned int v104 = v98;
          }
          if (v91 >= v98) {
            v91 -= v98;
          }
          if (v102) {
            __int16 v105 = v101;
          }
          else {
            __int16 v105 = v99;
          }
          *(_WORD *)(v84 + 2 * v93) = v105;
          unsigned int v106 = *(unsigned __int16 *)(v84 + 2LL * v103);
          if (!HIBYTE(v104))
          {
            if (v9 >= v12)
            {
              int v107 = 0;
            }

            else
            {
              int v108 = *v9++;
              int v107 = v108;
            }

            v104 <<= 8;
            unsigned int v91 = v107 | (v91 << 8);
          }

          unsigned int v109 = (v104 >> 11) * v106;
          unsigned int v110 = v106 + ((2048 - v106) >> 5);
          unsigned int v111 = v104 - v109;
          unsigned int v112 = v106 - (v106 >> 5);
          if (v91 >= v109) {
            uint64_t v113 = (2 * (_DWORD)v103) | 1u;
          }
          else {
            uint64_t v113 = (2 * v103);
          }
          if (v91 >= v109)
          {
            unsigned int v11 = v91 - v109;
          }

          else
          {
            unsigned int v111 = v109;
            unsigned int v11 = v91;
          }

          if (v91 >= v109) {
            __int16 v114 = v112;
          }
          else {
            __int16 v114 = v110;
          }
          *(_WORD *)(v84 + 2 * v103) = v114;
          unsigned int v115 = *(unsigned __int16 *)(v84 + 2LL * v113);
          if (!HIBYTE(v111))
          {
            if (v9 >= v12)
            {
              int v116 = 0;
            }

            else
            {
              int v117 = *v9++;
              int v116 = v117;
            }

            v111 <<= 8;
            unsigned int v11 = v116 | (v11 << 8);
          }

          unsigned int v26 = (v111 >> 11) * v115;
          int v118 = 2 * v113;
          unsigned int v119 = v11 - v26;
          if (v11 >= v26)
          {
            v118 |= 1u;
            unsigned int v26 = v111 - v26;
            unsigned int v11 = v119;
            unsigned int v120 = v115 - (v115 >> 5);
          }

          else
          {
            unsigned int v120 = v115 + ((2048 - v115) >> 5);
          }

          *(_WORD *)(v84 + 2 * v113) = v120;
          int v57 = (16 * v118) ^ 0x100;
LABEL_153:
          uint64_t v121 = v29 + 2LL * (3 * v57);
          unsigned int v122 = *(unsigned __int16 *)(v121 + 2);
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v123 = 0;
            }

            else
            {
              int v124 = *v9++;
              int v123 = v124;
            }

            v26 <<= 8;
            unsigned int v11 = v123 | (v11 << 8);
          }

          unsigned int v125 = (v26 >> 11) * v122;
          unsigned int v126 = v122 + ((2048 - v122) >> 5);
          unsigned int v127 = v26 - v125;
          unsigned int v128 = v11 - v125;
          unsigned int v129 = v122 - (v122 >> 5);
          if (v11 >= v125) {
            uint64_t v130 = 3LL;
          }
          else {
            uint64_t v130 = 2LL;
          }
          if (v11 >= v125)
          {
            __int16 v131 = v129;
          }

          else
          {
            unsigned int v127 = v125;
            unsigned int v128 = v11;
            __int16 v131 = v126;
          }

          *(_WORD *)(v121 + 2) = v131;
          unsigned int v132 = *(unsigned __int16 *)(v121 + 2LL * v130);
          if (!HIBYTE(v127))
          {
            if (v9 >= v12)
            {
              int v133 = 0;
            }

            else
            {
              int v134 = *v9++;
              int v133 = v134;
            }

            v127 <<= 8;
            unsigned int v128 = v133 | (v128 << 8);
          }

          unsigned int v135 = (v127 >> 11) * v132;
          unsigned int v136 = v132 + ((2048 - v132) >> 5);
          unsigned int v137 = v127 - v135;
          unsigned int v138 = v132 - (v132 >> 5);
          BOOL v139 = v128 >= v135;
          if (v128 >= v135) {
            uint64_t v140 = (2 * (_DWORD)v130) | 1u;
          }
          else {
            uint64_t v140 = (2 * v130);
          }
          if (v128 >= v135) {
            unsigned int v141 = v137;
          }
          else {
            unsigned int v141 = v135;
          }
          if (v128 >= v135) {
            v128 -= v135;
          }
          if (v139) {
            __int16 v142 = v138;
          }
          else {
            __int16 v142 = v136;
          }
          *(_WORD *)(v121 + 2 * v130) = v142;
          unsigned int v143 = *(unsigned __int16 *)(v121 + 2LL * v140);
          if (!HIBYTE(v141))
          {
            if (v9 >= v12)
            {
              int v144 = 0;
            }

            else
            {
              int v145 = *v9++;
              int v144 = v145;
            }

            v141 <<= 8;
            unsigned int v128 = v144 | (v128 << 8);
          }

          unsigned int v146 = (v141 >> 11) * v143;
          unsigned int v147 = v143 + ((2048 - v143) >> 5);
          unsigned int v148 = v141 - v146;
          unsigned int v149 = v143 - (v143 >> 5);
          if (v128 >= v146) {
            uint64_t v150 = (2 * (_DWORD)v140) | 1u;
          }
          else {
            uint64_t v150 = (2 * v140);
          }
          if (v128 >= v146)
          {
            unsigned int v11 = v128 - v146;
          }

          else
          {
            unsigned int v148 = v146;
            unsigned int v11 = v128;
          }

          if (v128 >= v146) {
            __int16 v151 = v149;
          }
          else {
            __int16 v151 = v147;
          }
          *(_WORD *)(v121 + 2 * v140) = v151;
          unsigned int v152 = *(unsigned __int16 *)(v121 + 2LL * v150);
          if (!HIBYTE(v148))
          {
            if (v9 >= v12)
            {
              int v153 = 0;
            }

            else
            {
              int v154 = *v9++;
              int v153 = v154;
            }

            v148 <<= 8;
            unsigned int v11 = v153 | (v11 << 8);
          }

          unsigned int v26 = (v148 >> 11) * v152;
          int v155 = 2 * v150;
          unsigned int v156 = v11 - v26;
          if (v11 >= v26)
          {
            v155 |= 1u;
            unsigned int v26 = v148 - v26;
            unsigned int v11 = v156;
            unsigned int v157 = v152 - (v152 >> 5);
          }

          else
          {
            unsigned int v157 = v152 + ((2048 - v152) >> 5);
          }

          *(_WORD *)(v121 + 2 * v150) = v157;
          int v83 = v155 ^ 0x10;
LABEL_199:
          unsigned int v158 = v83 + v57;
          uint64_t v8 = lzma_fsm_lut[v8 + 12];
          *v19++ = v83 + v57;
          if (v19 == a4) {
            break;
          }
          unsigned int v23 = ++v22 & v613;
          uint64_t v24 = &v7[16 * v8 + (v22 & v613)];
          unsigned int v25 = *v24;
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v159 = 0;
            }

            else
            {
              int v160 = *v9++;
              int v159 = v160;
            }

            v26 <<= 8;
            unsigned int v11 = v159 | (v11 << 8);
          }

          unsigned int v161 = (v26 >> 11) * v25;
          unsigned int v27 = v11 - v161;
          if (v11 >= v161)
          {
            unsigned int v56 = v26 - v161;
            goto LABEL_206;
          }

          *uint64_t v24 = v25 + ((2048 - v25) >> 5);
          uint64_t v29 = (uint64_t)&v7[816 * (((v22 & v610) << v611) | (v158 >> v609)) + 1956];
          unsigned int v26 = (v26 >> 11) * v25;
        }

        uint32x4_t v213 = a4;
LABEL_830:
        uint64_t v16 = 0LL;
        if (!v11 && v213 == a4)
        {
          *((_BYTE *)a1 + 29) = v8;
          return a4 - a3;
        }

        return v16;
      }

      unsigned int v56 = v18 - v26;
LABEL_206:
      *uint64_t v24 = v25 - (v25 >> 5);
      if (!HIBYTE(v56))
      {
        if (v9 >= v12)
        {
          int v162 = 0;
        }

        else
        {
          int v163 = *v9++;
          int v162 = v163;
        }

        v56 <<= 8;
        unsigned int v27 = v162 | (v27 << 8);
      }

      unint64_t v164 = &v7[v8 + 192];
      int v165 = *v164;
      unsigned int v166 = (v56 >> 11) * v165;
      unsigned int v11 = v27 - v166;
      if (v27 >= v166)
      {
        *v164 -= *v164 >> 5;
        if (v19 == (_BYTE *)a2) {
          return 0LL;
        }
        unsigned int v201 = v56 - v166;
        if (!HIBYTE(v201))
        {
          if (v9 >= v12)
          {
            int v202 = 0;
          }

          else
          {
            int v203 = *v9++;
            int v202 = v203;
          }

          v201 <<= 8;
          unsigned int v11 = v202 | (v11 << 8);
        }

        __int128 v204 = &v7[v8 + 204];
        int v205 = *v204;
        unsigned int v206 = (v201 >> 11) * v205;
        unsigned int v207 = v11 - v206;
        if (v11 >= v206)
        {
          unsigned int v247 = v201 - v206;
          *v204 -= *v204 >> 5;
          if (!HIBYTE(v247))
          {
            if (v9 >= v12)
            {
              int v248 = 0;
            }

            else
            {
              int v249 = *v9++;
              int v248 = v249;
            }

            v247 <<= 8;
            unsigned int v207 = v248 | (v207 << 8);
          }

          unint64_t v250 = &v7[v8 + 408];
          int v251 = *v250;
          unsigned int v252 = (v247 >> 11) * v251;
          unsigned int v253 = v207 - v252;
          if (v207 >= v252)
          {
            unsigned int v293 = v247 - v252;
            *v250 -= *v250 >> 5;
            if (HIBYTE(v293))
            {
              v207 -= v252;
            }

            else
            {
              if (v9 >= v12)
              {
                int v294 = 0;
              }

              else
              {
                int v295 = *v9++;
                int v294 = v295;
              }

              v293 <<= 8;
              unsigned int v207 = v294 | (v253 << 8);
            }

            unint64_t v440 = &v7[v8];
            unsigned int v441 = v440[420];
            unsigned int v252 = (v293 >> 11) * v441;
            unsigned int v442 = v207 - v252;
            if (v207 >= v252)
            {
              unsigned int v252 = v293 - v252;
              unsigned int v443 = v441 - (v441 >> 5);
              LODWORD(v210) = a1[3];
              a1[3] = a1[2];
              unsigned int v207 = v442;
            }

            else
            {
              unsigned int v443 = v441 + ((2048 - v441) >> 5);
              LODWORD(v210) = a1[2];
            }

            v440[420] = v443;
            a1[2] = a1[1];
          }

          else
          {
            *unint64_t v250 = v251 + ((2048 - v251) >> 5);
            LODWORD(v210) = a1[1];
          }

          unsigned int v444 = *a1;
          *a1 = v210;
          a1[1] = v444;
        }

        else
        {
          *__int128 v204 = v205 + ((2048 - v205) >> 5);
          if (!HIBYTE(v206))
          {
            if (v9 >= v12)
            {
              int v208 = 0;
            }

            else
            {
              int v209 = *v9++;
              int v208 = v209;
            }

            v206 <<= 8;
            unsigned int v11 = v208 | (v11 << 8);
          }

          uint64_t v210 = *a1;
          uint32x4_t v211 = &v7[16 * v8 + 216 + v23];
          int v212 = *v211;
          unsigned int v18 = (v206 >> 11) * v212;
          unsigned int v207 = v11 - v18;
          if (v11 < v18)
          {
            unsigned __int16 *v211 = v212 + ((2048 - v212) >> 5);
            *unsigned int v19 = v19[-v210];
            uint32x4_t v213 = v19 + 1;
            uint64_t v8 = lzma_fsm_lut[v8 + 48];
            goto LABEL_770;
          }

          unsigned int v252 = v206 - v18;
          *v211 -= *v211 >> 5;
        }

        int v445 = v7[962];
        if (!HIBYTE(v252))
        {
          if (v9 >= v12)
          {
            int v446 = 0;
          }

          else
          {
            int v447 = *v9++;
            int v446 = v447;
          }

          v252 <<= 8;
          unsigned int v207 = v446 | (v207 << 8);
        }

        unsigned int v448 = (v252 >> 11) * v445;
        unsigned int v449 = v207 - v448;
        if (v207 >= v448)
        {
          unsigned int v479 = v252 - v448;
          v7[962] -= v7[962] >> 5;
          if (!HIBYTE(v479))
          {
            if (v9 >= v12)
            {
              int v480 = 0;
            }

            else
            {
              int v481 = *v9++;
              int v480 = v481;
            }

            v479 <<= 8;
            unsigned int v449 = v480 | (v449 << 8);
          }

          int v482 = v7[963];
          unsigned int v483 = (v479 >> 11) * v482;
          unsigned int v484 = v449 - v483;
          if (v449 >= v483)
          {
            unsigned int v516 = v479 - v483;
            v7[963] -= v7[963] >> 5;
            if (!((v479 - v483) >> 24))
            {
              if (v9 >= v12)
              {
                int v517 = 0;
              }

              else
              {
                int v518 = *v9++;
                int v517 = v518;
              }

              v516 <<= 8;
              unsigned int v484 = v517 | (v484 << 8);
            }

            unsigned int v519 = v7[1221];
            unsigned int v520 = (v516 >> 11) * v519;
            unsigned int v521 = v519 + ((2048 - v519) >> 5);
            unsigned int v522 = v516 - v520;
            unsigned int v523 = v519 - (v519 >> 5);
            if (v484 >= v520) {
              uint64_t v524 = 3LL;
            }
            else {
              uint64_t v524 = 2LL;
            }
            if (v484 >= v520) {
              unsigned int v525 = v522;
            }
            else {
              unsigned int v525 = v520;
            }
            if (v484 >= v520) {
              unsigned int v526 = v484 - v520;
            }
            else {
              unsigned int v526 = v484;
            }
            if (v484 < v520) {
              LOWORD(v523) = v521;
            }
            v7[1221] = v523;
            if (!HIBYTE(v525))
            {
              if (v9 >= v12)
              {
                int v527 = 0;
              }

              else
              {
                int v528 = *v9++;
                int v527 = v528;
              }

              v525 <<= 8;
              unsigned int v526 = v527 | (v526 << 8);
            }

            unsigned int v529 = v607[v524];
            unsigned int v530 = (v525 >> 11) * v529;
            LODWORD(v531) = 2 * v524;
            unsigned int v532 = v529 + ((2048 - v529) >> 5);
            unsigned int v533 = v525 - v530;
            unsigned int v534 = v529 - (v529 >> 5);
            if (v526 >= v530) {
              uint64_t v531 = (2 * (_DWORD)v524) | 1u;
            }
            else {
              uint64_t v531 = v531;
            }
            if (v526 >= v530) {
              unsigned int v535 = v533;
            }
            else {
              unsigned int v535 = v530;
            }
            if (v526 >= v530) {
              unsigned int v536 = v526 - v530;
            }
            else {
              unsigned int v536 = v526;
            }
            if (v526 < v530) {
              LOWORD(v534) = v532;
            }
            v607[v524] = v534;
            unsigned int v537 = v607[v531];
            if (!HIBYTE(v535))
            {
              if (v9 >= v12)
              {
                int v538 = 0;
              }

              else
              {
                int v539 = *v9++;
                int v538 = v539;
              }

              v535 <<= 8;
              unsigned int v536 = v538 | (v536 << 8);
            }

            unsigned int v540 = (v535 >> 11) * v537;
            unsigned int v541 = v537 + ((2048 - v537) >> 5);
            LODWORD(v542) = (2 * v531) | 1;
            unsigned int v543 = v535 - v540;
            unsigned int v544 = v537 - (v537 >> 5);
            if (v536 >= v540) {
              uint64_t v542 = v542;
            }
            else {
              uint64_t v542 = (2 * v531);
            }
            if (v536 >= v540)
            {
              unsigned int v545 = v536 - v540;
            }

            else
            {
              unsigned int v543 = v540;
              unsigned int v545 = v536;
            }

            if (v536 >= v540) {
              unsigned __int16 v546 = v544;
            }
            else {
              unsigned __int16 v546 = v541;
            }
            v607[v531] = v546;
            unsigned int v547 = v607[v542];
            if (!HIBYTE(v543))
            {
              if (v9 >= v12)
              {
                int v548 = 0;
              }

              else
              {
                int v549 = *v9++;
                int v548 = v549;
              }

              v543 <<= 8;
              unsigned int v545 = v548 | (v545 << 8);
            }

            unsigned int v550 = (v543 >> 11) * v547;
            int v551 = 2 * v542;
            unsigned int v552 = v545 - v550;
            if (v545 >= v550)
            {
              v551 |= 1u;
              unsigned int v550 = v543 - v550;
              unsigned int v545 = v552;
              unsigned int v553 = v547 - (v547 >> 5);
            }

            else
            {
              unsigned int v553 = v547 + ((2048 - v547) >> 5);
            }

            v607[v542] = v553;
            uint64_t v554 = v551 ^ 0x10u;
            v555 = &v7[16 * v554];
            unsigned int v556 = v555[1237];
            if (!HIBYTE(v550))
            {
              if (v9 >= v12)
              {
                int v557 = 0;
              }

              else
              {
                int v558 = *v9++;
                int v557 = v558;
              }

              v550 <<= 8;
              unsigned int v545 = v557 | (v545 << 8);
            }

            __int128 v559 = v555 + 1236;
            unsigned int v560 = (v550 >> 11) * v556;
            unsigned int v561 = v556 + ((2048 - v556) >> 5);
            unsigned int v562 = v550 - v560;
            unsigned int v563 = v556 - (v556 >> 5);
            BOOL v564 = v545 >= v560;
            if (v545 >= v560) {
              uint64_t v565 = 3LL;
            }
            else {
              uint64_t v565 = 2LL;
            }
            if (v545 >= v560) {
              unsigned int v566 = v562;
            }
            else {
              unsigned int v566 = v560;
            }
            if (v545 >= v560) {
              v545 -= v560;
            }
            if (v564) {
              unsigned __int16 v567 = v563;
            }
            else {
              unsigned __int16 v567 = v561;
            }
            v559[1] = v567;
            unsigned int v568 = v559[v565];
            if (!HIBYTE(v566))
            {
              if (v9 >= v12)
              {
                int v569 = 0;
              }

              else
              {
                int v570 = *v9++;
                int v569 = v570;
              }

              v566 <<= 8;
              unsigned int v545 = v569 | (v545 << 8);
            }

            unsigned int v571 = (v566 >> 11) * v568;
            unsigned int v572 = v568 + ((2048 - v568) >> 5);
            unsigned int v573 = v566 - v571;
            unsigned int v574 = v568 - (v568 >> 5);
            if (v545 >= v571) {
              uint64_t v575 = (2 * (_DWORD)v565) | 1u;
            }
            else {
              uint64_t v575 = (2 * v565);
            }
            if (v545 >= v571) {
              unsigned int v576 = v573;
            }
            else {
              unsigned int v576 = v571;
            }
            if (v545 >= v571) {
              unsigned int v577 = v545 - v571;
            }
            else {
              unsigned int v577 = v545;
            }
            if (v545 >= v571) {
              unsigned __int16 v578 = v574;
            }
            else {
              unsigned __int16 v578 = v572;
            }
            v559[v565] = v578;
            unsigned int v579 = v559[v575];
            if (!HIBYTE(v576))
            {
              if (v9 >= v12)
              {
                int v580 = 0;
              }

              else
              {
                int v581 = *v9++;
                int v580 = v581;
              }

              v576 <<= 8;
              unsigned int v577 = v580 | (v577 << 8);
            }

            unsigned int v582 = (v576 >> 11) * v579;
            unsigned int v583 = v579 + ((2048 - v579) >> 5);
            unsigned int v584 = v576 - v582;
            unsigned int v585 = v579 - (v579 >> 5);
            if (v577 >= v582) {
              uint64_t v586 = (2 * (_DWORD)v575) | 1u;
            }
            else {
              uint64_t v586 = (2 * v575);
            }
            if (v577 >= v582)
            {
              unsigned int v11 = v577 - v582;
            }

            else
            {
              unsigned int v584 = v582;
              unsigned int v11 = v577;
            }

            if (v577 >= v582) {
              unsigned __int16 v587 = v585;
            }
            else {
              unsigned __int16 v587 = v583;
            }
            v559[v575] = v587;
            unsigned int v588 = v559[v586];
            if (!HIBYTE(v584))
            {
              if (v9 >= v12)
              {
                int v589 = 0;
              }

              else
              {
                int v590 = *v9++;
                int v589 = v590;
              }

              v584 <<= 8;
              unsigned int v11 = v589 | (v11 << 8);
            }

            unsigned int v18 = (v584 >> 11) * v588;
            int v591 = 2 * v586;
            unsigned int v592 = v11 - v18;
            if (v11 >= v18)
            {
              v591 |= 1u;
              unsigned int v18 = v584 - v18;
              unsigned int v11 = v592;
              unsigned int v593 = v588 - (v588 >> 5);
            }

            else
            {
              unsigned int v593 = v588 + ((2048 - v588) >> 5);
            }

            v559[v586] = v593;
            unsigned int v254 = (v591 ^ 0x10) + 16 * v554 + 18;
          }

          else
          {
            v7[963] = v482 + ((2048 - v482) >> 5);
            if (!HIBYTE(v483))
            {
              if (v9 >= v12)
              {
                int v485 = 0;
              }

              else
              {
                int v486 = *v9++;
                int v485 = v486;
              }

              v483 <<= 8;
              unsigned int v449 = v485 | (v449 << 8);
            }

            unint64_t v487 = &v7[8 * v23];
            v488 = v487 + 1092;
            LODWORD(v487) = v487[1093];
            unsigned int v489 = (v483 >> 11) * (_DWORD)v487;
            unsigned int v490 = (_DWORD)v487 + ((2048 - (_DWORD)v487) >> 5);
            unsigned int v491 = v483 - v489;
            unsigned int v492 = (_DWORD)v487 - (v487 >> 5);
            if (v449 >= v489) {
              uint64_t v493 = 3LL;
            }
            else {
              uint64_t v493 = 2LL;
            }
            if (v449 >= v489) {
              unsigned int v494 = v491;
            }
            else {
              unsigned int v494 = v489;
            }
            if (v449 >= v489) {
              unsigned int v495 = v449 - v489;
            }
            else {
              unsigned int v495 = v449;
            }
            if (v449 >= v489) {
              unsigned __int16 v496 = v492;
            }
            else {
              unsigned __int16 v496 = v490;
            }
            v488[1] = v496;
            if (!HIBYTE(v494))
            {
              if (v9 >= v12)
              {
                int v497 = 0;
              }

              else
              {
                int v498 = *v9++;
                int v497 = v498;
              }

              v494 <<= 8;
              unsigned int v495 = v497 | (v495 << 8);
            }

            unsigned int v499 = v488[v493];
            unsigned int v500 = (v494 >> 11) * v499;
            unsigned int v501 = v499 + ((2048 - v499) >> 5);
            unsigned int v502 = v494 - v500;
            unsigned int v503 = v499 - (v499 >> 5);
            BOOL v504 = v495 >= v500;
            if (v495 >= v500) {
              uint64_t v505 = (2 * (_DWORD)v493) | 1u;
            }
            else {
              uint64_t v505 = (2 * v493);
            }
            if (v495 >= v500) {
              v495 -= v500;
            }
            else {
              unsigned int v502 = v500;
            }
            if (v504) {
              unsigned __int16 v506 = v503;
            }
            else {
              unsigned __int16 v506 = v501;
            }
            v488[v493] = v506;
            unsigned int v507 = v488[v505];
            if (!HIBYTE(v502))
            {
              if (v9 >= v12)
              {
                int v508 = 0;
              }

              else
              {
                int v509 = *v9++;
                int v508 = v509;
              }

              v502 <<= 8;
              unsigned int v495 = v508 | (v495 << 8);
            }

            unsigned int v510 = (v502 >> 11) * v507;
            int v511 = 2 * v505;
            unsigned int v512 = v507 + ((2048 - v507) >> 5);
            unsigned int v513 = v502 - v510;
            unsigned int v514 = v507 - (v507 >> 5);
            if (v495 < v510)
            {
              unsigned int v18 = v510;
            }

            else
            {
              int v511 = (2 * v505) | 1;
              unsigned int v18 = v513;
            }

            if (v495 >= v510) {
              unsigned int v11 = v495 - v510;
            }
            else {
              unsigned int v11 = v495;
            }
            if (v495 >= v510) {
              unsigned __int16 v515 = v514;
            }
            else {
              unsigned __int16 v515 = v512;
            }
            v488[v505] = v515;
            unsigned int v254 = (v511 ^ 8) + 10;
          }
        }

        else
        {
          v7[962] = v445 + ((2048 - v445) >> 5);
          if (!HIBYTE(v448))
          {
            if (v9 >= v12)
            {
              int v450 = 0;
            }

            else
            {
              int v451 = *v9++;
              int v450 = v451;
            }

            v448 <<= 8;
            unsigned int v207 = v450 | (v207 << 8);
          }

          uint64_t v452 = (uint64_t)&v7[8 * v23 + 962];
          uint64_t v453 = v452 + 4;
          LODWORD(v452) = *(unsigned __int16 *)(v452 + 6);
          unsigned int v454 = (v448 >> 11) * v452;
          int v455 = v452 + ((2048 - v452) >> 5);
          unsigned int v456 = v448 - v454;
          unsigned int v457 = v207 - v454;
          int v458 = v452 - (v452 >> 5);
          if (v207 >= v454) {
            uint64_t v459 = 3LL;
          }
          else {
            uint64_t v459 = 2LL;
          }
          if (v207 >= v454)
          {
            __int16 v460 = v458;
          }

          else
          {
            unsigned int v456 = v454;
            unsigned int v457 = v207;
            __int16 v460 = v455;
          }

          *(_WORD *)(v453 + 2) = v460;
          if (!HIBYTE(v456))
          {
            if (v9 >= v12)
            {
              int v461 = 0;
            }

            else
            {
              int v462 = *v9++;
              int v461 = v462;
            }

            v456 <<= 8;
            unsigned int v457 = v461 | (v457 << 8);
          }

          unsigned int v463 = *(unsigned __int16 *)(v453 + 2LL * v459);
          unsigned int v464 = (v456 >> 11) * v463;
          unsigned int v465 = v463 + ((2048 - v463) >> 5);
          unsigned int v466 = v456 - v464;
          unsigned int v467 = v463 - (v463 >> 5);
          BOOL v468 = v457 >= v464;
          if (v457 >= v464) {
            uint64_t v469 = (2 * (_DWORD)v459) | 1u;
          }
          else {
            uint64_t v469 = (2 * v459);
          }
          if (v457 >= v464) {
            unsigned int v470 = v466;
          }
          else {
            unsigned int v470 = v464;
          }
          if (v457 >= v464) {
            v457 -= v464;
          }
          if (!v468) {
            LOWORD(v467) = v465;
          }
          *(_WORD *)(v453 + 2 * v459) = v467;
          unsigned int v471 = *(unsigned __int16 *)(v453 + 2LL * v469);
          if (!HIBYTE(v470))
          {
            if (v9 >= v12)
            {
              int v472 = 0;
            }

            else
            {
              int v473 = *v9++;
              int v472 = v473;
            }

            v470 <<= 8;
            unsigned int v457 = v472 | (v457 << 8);
          }

          unsigned int v474 = (v470 >> 11) * v471;
          int v475 = 2 * v469;
          unsigned int v476 = v471 + ((2048 - v471) >> 5);
          unsigned int v477 = v470 - v474;
          unsigned int v478 = v471 - (v471 >> 5);
          if (v457 < v474)
          {
            unsigned int v18 = v474;
          }

          else
          {
            int v475 = (2 * v469) | 1;
            unsigned int v18 = v477;
          }

          if (v457 >= v474) {
            unsigned int v11 = v457 - v474;
          }
          else {
            unsigned int v11 = v457;
          }
          if (v457 < v474) {
            LOWORD(v478) = v476;
          }
          *(_WORD *)(v453 + 2 * v469) = v478;
          unsigned int v254 = (v475 ^ 8) + 2;
        }

        uint64_t v8 = lzma_fsm_lut[v8 + 36];
      }

      else
      {
        *unint64_t v164 = v165 + ((2048 - v165) >> 5);
        if (!HIBYTE(v166))
        {
          if (v9 >= v12)
          {
            int v167 = 0;
          }

          else
          {
            int v168 = *v9++;
            int v167 = v168;
          }

          v166 <<= 8;
          unsigned int v27 = v167 | (v27 << 8);
        }

        int v169 = v7[432];
        unsigned int v170 = (v166 >> 11) * v169;
        unsigned int v171 = v27 - v170;
        if (v27 >= v170)
        {
          unsigned int v214 = v166 - v170;
          v7[432] -= v7[432] >> 5;
          if (!HIBYTE(v214))
          {
            if (v9 >= v12)
            {
              int v215 = 0;
            }

            else
            {
              int v216 = *v9++;
              int v215 = v216;
            }

            v214 <<= 8;
            unsigned int v171 = v215 | (v171 << 8);
          }

          int v217 = v7[433];
          unsigned int v218 = (v214 >> 11) * v217;
          unsigned int v219 = v171 - v218;
          if (v171 >= v218)
          {
            unsigned int v255 = v214 - v218;
            v7[433] -= v7[433] >> 5;
            if (!((v214 - v218) >> 24))
            {
              if (v9 >= v12)
              {
                int v256 = 0;
              }

              else
              {
                int v257 = *v9++;
                int v256 = v257;
              }

              v255 <<= 8;
              unsigned int v219 = v256 | (v219 << 8);
            }

            unsigned int v258 = v7[691];
            unsigned int v259 = (v255 >> 11) * v258;
            unsigned int v260 = v258 + ((2048 - v258) >> 5);
            unsigned int v261 = v255 - v259;
            unsigned int v262 = v258 - (v258 >> 5);
            if (v219 >= v259) {
              uint64_t v263 = 3LL;
            }
            else {
              uint64_t v263 = 2LL;
            }
            if (v219 >= v259) {
              unsigned int v264 = v261;
            }
            else {
              unsigned int v264 = v259;
            }
            if (v219 >= v259) {
              unsigned int v265 = v219 - v259;
            }
            else {
              unsigned int v265 = v219;
            }
            if (v219 < v259) {
              LOWORD(v262) = v260;
            }
            v7[691] = v262;
            if (!HIBYTE(v264))
            {
              if (v9 >= v12)
              {
                int v266 = 0;
              }

              else
              {
                int v267 = *v9++;
                int v266 = v267;
              }

              v264 <<= 8;
              unsigned int v265 = v266 | (v265 << 8);
            }

            unsigned int v268 = v608[v263];
            unsigned int v269 = (v264 >> 11) * v268;
            LODWORD(v270) = 2 * v263;
            unsigned int v271 = v268 + ((2048 - v268) >> 5);
            unsigned int v272 = v264 - v269;
            unsigned int v273 = v268 - (v268 >> 5);
            if (v265 >= v269) {
              uint64_t v270 = (2 * (_DWORD)v263) | 1u;
            }
            else {
              uint64_t v270 = v270;
            }
            if (v265 >= v269) {
              unsigned int v274 = v272;
            }
            else {
              unsigned int v274 = v269;
            }
            if (v265 >= v269) {
              unsigned int v275 = v265 - v269;
            }
            else {
              unsigned int v275 = v265;
            }
            if (v265 < v269) {
              LOWORD(v273) = v271;
            }
            v608[v263] = v273;
            unsigned int v276 = v608[v270];
            if (!HIBYTE(v274))
            {
              if (v9 >= v12)
              {
                int v277 = 0;
              }

              else
              {
                int v278 = *v9++;
                int v277 = v278;
              }

              v274 <<= 8;
              unsigned int v275 = v277 | (v275 << 8);
            }

            unsigned int v279 = (v274 >> 11) * v276;
            unsigned int v280 = v276 + ((2048 - v276) >> 5);
            LODWORD(v281) = (2 * v270) | 1;
            unsigned int v282 = v274 - v279;
            unsigned int v283 = v276 - (v276 >> 5);
            if (v275 >= v279) {
              uint64_t v281 = v281;
            }
            else {
              uint64_t v281 = (2 * v270);
            }
            if (v275 >= v279)
            {
              unsigned int v284 = v275 - v279;
            }

            else
            {
              unsigned int v282 = v279;
              unsigned int v284 = v275;
            }

            if (v275 >= v279) {
              unsigned __int16 v285 = v283;
            }
            else {
              unsigned __int16 v285 = v280;
            }
            v608[v270] = v285;
            unsigned int v286 = v608[v281];
            if (!HIBYTE(v282))
            {
              if (v9 >= v12)
              {
                int v287 = 0;
              }

              else
              {
                int v288 = *v9++;
                int v287 = v288;
              }

              v282 <<= 8;
              unsigned int v284 = v287 | (v284 << 8);
            }

            unsigned int v289 = (v282 >> 11) * v286;
            int v290 = 2 * v281;
            unsigned int v291 = v284 - v289;
            if (v284 >= v289)
            {
              v290 |= 1u;
              unsigned int v289 = v282 - v289;
              unsigned int v284 = v291;
              unsigned int v292 = v286 - (v286 >> 5);
            }

            else
            {
              unsigned int v292 = v286 + ((2048 - v286) >> 5);
            }

            v608[v281] = v292;
            uint64_t v296 = v290 ^ 0x10u;
            double v297 = &v7[16 * v296];
            unsigned int v298 = v297[707];
            if (!HIBYTE(v289))
            {
              if (v9 >= v12)
              {
                int v299 = 0;
              }

              else
              {
                int v300 = *v9++;
                int v299 = v300;
              }

              v289 <<= 8;
              unsigned int v284 = v299 | (v284 << 8);
            }

            double v301 = v297 + 706;
            unsigned int v302 = (v289 >> 11) * v298;
            unsigned int v303 = v298 + ((2048 - v298) >> 5);
            unsigned int v304 = v289 - v302;
            unsigned int v305 = v298 - (v298 >> 5);
            BOOL v306 = v284 >= v302;
            if (v284 >= v302) {
              uint64_t v307 = 3LL;
            }
            else {
              uint64_t v307 = 2LL;
            }
            if (v284 >= v302) {
              unsigned int v308 = v304;
            }
            else {
              unsigned int v308 = v302;
            }
            if (v284 >= v302) {
              v284 -= v302;
            }
            if (v306) {
              unsigned __int16 v309 = v305;
            }
            else {
              unsigned __int16 v309 = v303;
            }
            v301[1] = v309;
            unsigned int v310 = v301[v307];
            if (!HIBYTE(v308))
            {
              if (v9 >= v12)
              {
                int v311 = 0;
              }

              else
              {
                int v312 = *v9++;
                int v311 = v312;
              }

              v308 <<= 8;
              unsigned int v284 = v311 | (v284 << 8);
            }

            unsigned int v313 = (v308 >> 11) * v310;
            unsigned int v314 = v310 + ((2048 - v310) >> 5);
            unsigned int v315 = v308 - v313;
            unsigned int v316 = v310 - (v310 >> 5);
            if (v284 >= v313) {
              uint64_t v317 = (2 * (_DWORD)v307) | 1u;
            }
            else {
              uint64_t v317 = (2 * v307);
            }
            if (v284 >= v313) {
              unsigned int v318 = v315;
            }
            else {
              unsigned int v318 = v313;
            }
            if (v284 >= v313) {
              unsigned int v319 = v284 - v313;
            }
            else {
              unsigned int v319 = v284;
            }
            if (v284 >= v313) {
              unsigned __int16 v320 = v316;
            }
            else {
              unsigned __int16 v320 = v314;
            }
            v301[v307] = v320;
            unsigned int v321 = v301[v317];
            if (!HIBYTE(v318))
            {
              if (v9 >= v12)
              {
                int v322 = 0;
              }

              else
              {
                int v323 = *v9++;
                int v322 = v323;
              }

              v318 <<= 8;
              unsigned int v319 = v322 | (v319 << 8);
            }

            unsigned int v324 = (v318 >> 11) * v321;
            unsigned int v325 = v321 + ((2048 - v321) >> 5);
            unsigned int v326 = v318 - v324;
            unsigned int v327 = v321 - (v321 >> 5);
            if (v319 >= v324) {
              uint64_t v328 = (2 * (_DWORD)v317) | 1u;
            }
            else {
              uint64_t v328 = (2 * v317);
            }
            if (v319 >= v324)
            {
              unsigned int v193 = v319 - v324;
            }

            else
            {
              unsigned int v326 = v324;
              unsigned int v193 = v319;
            }

            if (v319 >= v324) {
              unsigned __int16 v329 = v327;
            }
            else {
              unsigned __int16 v329 = v325;
            }
            v301[v317] = v329;
            unsigned int v330 = v301[v328];
            if (!HIBYTE(v326))
            {
              if (v9 >= v12)
              {
                int v331 = 0;
              }

              else
              {
                int v332 = *v9++;
                int v331 = v332;
              }

              v326 <<= 8;
              unsigned int v193 = v331 | (v193 << 8);
            }

            unsigned int v197 = (v326 >> 11) * v330;
            int v333 = 2 * v328;
            unsigned int v334 = v193 - v197;
            if (v193 >= v197)
            {
              v333 |= 1u;
              unsigned int v197 = v326 - v197;
              unsigned int v193 = v334;
              unsigned int v335 = v330 - (v330 >> 5);
            }

            else
            {
              unsigned int v335 = v330 + ((2048 - v330) >> 5);
            }

            v301[v328] = v335;
            unsigned int v254 = (v333 ^ 0x10) + 16 * v296 + 18;
          }

          else
          {
            v7[433] = v217 + ((2048 - v217) >> 5);
            if (!HIBYTE(v218))
            {
              if (v9 >= v12)
              {
                int v220 = 0;
              }

              else
              {
                int v221 = *v9++;
                int v220 = v221;
              }

              v218 <<= 8;
              unsigned int v171 = v220 | (v171 << 8);
            }

            uint64_t v222 = &v7[8 * v23];
            uint64_t v223 = v222 + 562;
            LODWORD(v222) = v222[563];
            unsigned int v224 = (v218 >> 11) * (_DWORD)v222;
            unsigned int v225 = (_DWORD)v222 + ((2048 - (_DWORD)v222) >> 5);
            unsigned int v226 = v218 - v224;
            unsigned int v227 = (_DWORD)v222 - (v222 >> 5);
            if (v171 >= v224) {
              uint64_t v228 = 3LL;
            }
            else {
              uint64_t v228 = 2LL;
            }
            if (v171 >= v224) {
              unsigned int v229 = v226;
            }
            else {
              unsigned int v229 = v224;
            }
            if (v171 >= v224) {
              unsigned int v230 = v171 - v224;
            }
            else {
              unsigned int v230 = v171;
            }
            if (v171 >= v224) {
              unsigned __int16 v231 = v227;
            }
            else {
              unsigned __int16 v231 = v225;
            }
            v223[1] = v231;
            if (!HIBYTE(v229))
            {
              if (v9 >= v12)
              {
                int v232 = 0;
              }

              else
              {
                int v233 = *v9++;
                int v232 = v233;
              }

              v229 <<= 8;
              unsigned int v230 = v232 | (v230 << 8);
            }

            unsigned int v234 = v223[v228];
            unsigned int v235 = (v229 >> 11) * v234;
            unsigned int v236 = v234 + ((2048 - v234) >> 5);
            unsigned int v237 = v229 - v235;
            unsigned int v238 = v234 - (v234 >> 5);
            if (v230 >= v235) {
              uint64_t v239 = (2 * (_DWORD)v228) | 1u;
            }
            else {
              uint64_t v239 = (2 * v228);
            }
            if (v230 >= v235)
            {
              unsigned int v193 = v230 - v235;
            }

            else
            {
              unsigned int v237 = v235;
              unsigned int v193 = v230;
            }

            if (v230 >= v235) {
              unsigned __int16 v240 = v238;
            }
            else {
              unsigned __int16 v240 = v236;
            }
            v223[v228] = v240;
            unsigned int v241 = v223[v239];
            if (!HIBYTE(v237))
            {
              if (v9 >= v12)
              {
                int v242 = 0;
              }

              else
              {
                int v243 = *v9++;
                int v242 = v243;
              }

              v237 <<= 8;
              unsigned int v193 = v242 | (v193 << 8);
            }

            unsigned int v197 = (v237 >> 11) * v241;
            int v244 = 2 * v239;
            unsigned int v245 = v193 - v197;
            if (v193 >= v197)
            {
              v244 |= 1u;
              unsigned int v197 = v237 - v197;
              unsigned int v193 = v245;
              unsigned int v246 = v241 - (v241 >> 5);
            }

            else
            {
              unsigned int v246 = v241 + ((2048 - v241) >> 5);
            }

            v223[v239] = v246;
            unsigned int v254 = (v244 ^ 8) + 10;
          }
        }

        else
        {
          v7[432] = v169 + ((2048 - v169) >> 5);
          if (!HIBYTE(v170))
          {
            if (v9 >= v12)
            {
              int v172 = 0;
            }

            else
            {
              int v173 = *v9++;
              int v172 = v173;
            }

            v170 <<= 8;
            unsigned int v27 = v172 | (v27 << 8);
          }

          uint64_t v174 = (uint64_t)&v7[8 * v23 + 432];
          uint64_t v175 = v174 + 4;
          LODWORD(v174) = *(unsigned __int16 *)(v174 + 6);
          unsigned int v176 = (v170 >> 11) * v174;
          int v177 = v174 + ((2048 - v174) >> 5);
          unsigned int v178 = v170 - v176;
          int v179 = v174 - (v174 >> 5);
          if (v27 >= v176) {
            uint64_t v180 = 3LL;
          }
          else {
            uint64_t v180 = 2LL;
          }
          if (v27 >= v176) {
            unsigned int v181 = v178;
          }
          else {
            unsigned int v181 = v176;
          }
          if (v27 >= v176) {
            unsigned int v182 = v27 - v176;
          }
          else {
            unsigned int v182 = v27;
          }
          if (v27 >= v176) {
            __int16 v183 = v179;
          }
          else {
            __int16 v183 = v177;
          }
          *(_WORD *)(v175 + 2) = v183;
          if (!HIBYTE(v181))
          {
            if (v9 >= v12)
            {
              int v184 = 0;
            }

            else
            {
              int v185 = *v9++;
              int v184 = v185;
            }

            v181 <<= 8;
            unsigned int v182 = v184 | (v182 << 8);
          }

          unsigned int v186 = *(unsigned __int16 *)(v175 + 2LL * v180);
          unsigned int v187 = (v181 >> 11) * v186;
          unsigned int v188 = v186 + ((2048 - v186) >> 5);
          unsigned int v189 = v181 - v187;
          unsigned int v190 = v186 - (v186 >> 5);
          if (v182 >= v187) {
            uint64_t v191 = (2 * (_DWORD)v180) | 1u;
          }
          else {
            uint64_t v191 = (2 * v180);
          }
          if (v182 >= v187) {
            unsigned int v192 = v189;
          }
          else {
            unsigned int v192 = v187;
          }
          if (v182 >= v187) {
            unsigned int v193 = v182 - v187;
          }
          else {
            unsigned int v193 = v182;
          }
          if (v182 < v187) {
            LOWORD(v190) = v188;
          }
          *(_WORD *)(v175 + 2 * v180) = v190;
          unsigned int v194 = *(unsigned __int16 *)(v175 + 2LL * v191);
          if (!HIBYTE(v192))
          {
            if (v9 >= v12)
            {
              int v195 = 0;
            }

            else
            {
              int v196 = *v9++;
              int v195 = v196;
            }

            v192 <<= 8;
            unsigned int v193 = v195 | (v193 << 8);
          }

          unsigned int v197 = (v192 >> 11) * v194;
          int v198 = 2 * v191;
          unsigned int v199 = v193 - v197;
          if (v193 >= v197)
          {
            v198 |= 1u;
            unsigned int v197 = v192 - v197;
            unsigned int v193 = v199;
            unsigned int v200 = v194 - (v194 >> 5);
          }

          else
          {
            unsigned int v200 = v194 + ((2048 - v194) >> 5);
          }

          *(_WORD *)(v175 + 2 * v191) = v200;
          unsigned int v254 = (v198 ^ 8) + 2;
        }

        unsigned int v336 = v254 - 2;
        if (v254 >= 6) {
          unsigned int v336 = 3;
        }
        uint64_t v337 = &v7[80 * v336];
        unsigned int v338 = v337[1557];
        if (!HIBYTE(v197))
        {
          if (v9 >= v12)
          {
            int v339 = 0;
          }

          else
          {
            int v340 = *v9++;
            int v339 = v340;
          }

          v197 <<= 8;
          unsigned int v193 = v339 | (v193 << 8);
        }

        double v341 = v337 + 1492;
        v342 = v337 + 1556;
        unsigned int v343 = (v197 >> 11) * v338;
        unsigned int v344 = v338 + ((2048 - v338) >> 5);
        unsigned int v345 = v197 - v343;
        unsigned int v346 = v193 - v343;
        unsigned int v347 = v338 - (v338 >> 5);
        if (v193 >= v343) {
          uint64_t v348 = 3LL;
        }
        else {
          uint64_t v348 = 2LL;
        }
        if (v193 >= v343)
        {
          unsigned __int16 v349 = v347;
        }

        else
        {
          unsigned int v345 = v343;
          unsigned int v346 = v193;
          unsigned __int16 v349 = v344;
        }

        v341[65] = v349;
        unsigned int v350 = v342[v348];
        if (!HIBYTE(v345))
        {
          if (v9 >= v12)
          {
            int v351 = 0;
          }

          else
          {
            int v352 = *v9++;
            int v351 = v352;
          }

          v345 <<= 8;
          unsigned int v346 = v351 | (v346 << 8);
        }

        unsigned int v353 = (v345 >> 11) * v350;
        unsigned int v354 = v350 + ((2048 - v350) >> 5);
        unsigned int v355 = v345 - v353;
        unsigned int v356 = v350 - (v350 >> 5);
        BOOL v357 = v346 >= v353;
        if (v346 >= v353) {
          uint64_t v358 = (2 * (_DWORD)v348) | 1u;
        }
        else {
          uint64_t v358 = (2 * v348);
        }
        if (v346 >= v353) {
          unsigned int v359 = v355;
        }
        else {
          unsigned int v359 = v353;
        }
        if (v346 >= v353) {
          v346 -= v353;
        }
        if (v357) {
          unsigned __int16 v360 = v356;
        }
        else {
          unsigned __int16 v360 = v354;
        }
        v342[v348] = v360;
        unsigned int v361 = v342[v358];
        if (!HIBYTE(v359))
        {
          if (v9 >= v12)
          {
            int v362 = 0;
          }

          else
          {
            int v363 = *v9++;
            int v362 = v363;
          }

          v359 <<= 8;
          unsigned int v346 = v362 | (v346 << 8);
        }

        unsigned int v364 = (v359 >> 11) * v361;
        unsigned int v365 = v361 + ((2048 - v361) >> 5);
        unsigned int v366 = v359 - v364;
        unsigned int v367 = v361 - (v361 >> 5);
        BOOL v368 = v346 >= v364;
        if (v346 >= v364) {
          uint64_t v369 = (2 * (_DWORD)v358) | 1u;
        }
        else {
          uint64_t v369 = (2 * v358);
        }
        if (v346 >= v364) {
          v346 -= v364;
        }
        else {
          unsigned int v366 = v364;
        }
        if (v368) {
          unsigned __int16 v370 = v367;
        }
        else {
          unsigned __int16 v370 = v365;
        }
        v342[v358] = v370;
        unsigned int v371 = v342[v369];
        if (!HIBYTE(v366))
        {
          if (v9 >= v12)
          {
            int v372 = 0;
          }

          else
          {
            int v373 = *v9++;
            int v372 = v373;
          }

          v366 <<= 8;
          unsigned int v346 = v372 | (v346 << 8);
        }

        unsigned int v374 = (v366 >> 11) * v371;
        int v375 = 2 * v369;
        unsigned int v376 = v371 + ((2048 - v371) >> 5);
        unsigned int v377 = v366 - v374;
        unsigned int v378 = v346 - v374;
        unsigned int v379 = v371 - (v371 >> 5);
        BOOL v380 = v346 >= v374;
        if (v346 < v374)
        {
          unsigned int v381 = v374;
        }

        else
        {
          int v375 = (2 * v369) | 1;
          unsigned int v381 = v377;
        }

        if (v346 >= v374) {
          unsigned __int16 v382 = v379;
        }
        else {
          unsigned __int16 v382 = v376;
        }
        v342[v369] = v382;
        if (v380) {
          unsigned int v383 = v378;
        }
        else {
          unsigned int v383 = v346;
        }
        unsigned int v384 = (4 * v375) ^ 0x40;
        unint64_t v385 = &v341[v384];
        unsigned int v386 = v385[1];
        if (!HIBYTE(v381))
        {
          if (v9 >= v12)
          {
            int v387 = 0;
          }

          else
          {
            int v388 = *v9++;
            int v387 = v388;
          }

          v381 <<= 8;
          unsigned int v383 = v387 | (v383 << 8);
        }

        unsigned int v389 = (v381 >> 11) * v386;
        unsigned int v390 = v386 + ((2048 - v386) >> 5);
        unsigned int v391 = v381 - v389;
        unsigned int v392 = v386 - (v386 >> 5);
        BOOL v393 = v383 >= v389;
        if (v383 >= v389) {
          uint64_t v394 = 3LL;
        }
        else {
          uint64_t v394 = 2LL;
        }
        if (v383 >= v389) {
          v383 -= v389;
        }
        else {
          unsigned int v391 = v389;
        }
        if (v393) {
          unsigned __int16 v395 = v392;
        }
        else {
          unsigned __int16 v395 = v390;
        }
        v385[1] = v395;
        unsigned int v396 = v385[v394];
        if (!HIBYTE(v391))
        {
          if (v9 >= v12)
          {
            int v397 = 0;
          }

          else
          {
            int v398 = *v9++;
            int v397 = v398;
          }

          v391 <<= 8;
          unsigned int v383 = v397 | (v383 << 8);
        }

        unsigned int v399 = (v391 >> 11) * v396;
        unsigned int v400 = v396 + ((2048 - v396) >> 5);
        unsigned int v401 = v391 - v399;
        unsigned int v402 = v396 - (v396 >> 5);
        if (v383 >= v399) {
          int v403 = (2 * v394) | 1;
        }
        else {
          int v403 = 2 * v394;
        }
        if (v383 >= v399) {
          unsigned int v18 = v401;
        }
        else {
          unsigned int v18 = v399;
        }
        if (v383 >= v399) {
          unsigned int v11 = v383 - v399;
        }
        else {
          unsigned int v11 = v383;
        }
        if (v383 >= v399) {
          unsigned __int16 v404 = v402;
        }
        else {
          unsigned __int16 v404 = v400;
        }
        v385[v394] = v404;
        unsigned int v405 = (v403 ^ 4) + v384;
        if (v384)
        {
          int v406 = (v405 >> 1) - 1;
          unsigned int v407 = (v403 & 1 | 2) << ((v405 >> 1) - 1);
          if (v405 > 0xD)
          {
            int v421 = 0;
            int v422 = (v405 >> 1) - 5;
            if (v405 >> 1 != 5)
            {
              unsigned int v423 = v18;
              do
              {
                if (!HIBYTE(v423))
                {
                  if (v9 >= v12)
                  {
                    int v424 = 0;
                  }

                  else
                  {
                    int v425 = *v9++;
                    int v424 = v425;
                  }

                  v423 <<= 8;
                  unsigned int v11 = v424 | (v11 << 8);
                }

                unsigned int v18 = v423 >> 1;
                BOOL v426 = v11 >= v423 >> 1;
                if (v11 < v423 >> 1) {
                  unsigned int v427 = 0;
                }
                else {
                  unsigned int v427 = v423 >> 1;
                }
                v11 -= v427;
                int v421 = v426 | (2 * v421);
                unsigned int v423 = v18;
                --v422;
              }

              while (v422);
            }

            int v428 = 0;
            int v429 = 0;
            unsigned int v430 = 1;
            do
            {
              if (!HIBYTE(v18))
              {
                if (v9 >= v12)
                {
                  int v431 = 0;
                }

                else
                {
                  int v432 = *v9++;
                  int v431 = v432;
                }

                v18 <<= 8;
                unsigned int v11 = v431 | (v11 << 8);
              }

              uint64_t v433 = v430;
              unsigned int v434 = v17[v430];
              unsigned int v435 = v434 + ((2048 - v434) >> 5);
              unsigned int v436 = (v18 >> 11) * v434;
              v430 *= 2;
              unsigned int v437 = v434 - (v434 >> 5);
              BOOL v438 = v11 >= v436;
              if (v11 < v436)
              {
                unsigned int v18 = v436;
              }

              else
              {
                v430 |= 1u;
                v18 -= v436;
              }

              if (v11 >= v436) {
                v11 -= v436;
              }
              if (v438)
              {
                int v439 = 1;
              }

              else
              {
                LOWORD(v437) = v435;
                int v439 = 0;
              }

              v17[v433] = v437;
              v429 += v439 << v428++;
            }

            while (v428 != 4);
            int v409 = v429 + 16 * v421;
          }

          else if (v405 < 4)
          {
            int v409 = 0;
          }

          else
          {
            int v408 = 0;
            int v409 = 0;
            uint64_t v410 = (uint64_t)&v7[v407 + 1812];
            if (v406 <= 1) {
              int v406 = 1;
            }
            unsigned int v411 = 1;
            do
            {
              if (!HIBYTE(v18))
              {
                if (v9 >= v12)
                {
                  int v412 = 0;
                }

                else
                {
                  int v413 = *v9++;
                  int v412 = v413;
                }

                v18 <<= 8;
                unsigned int v11 = v412 | (v11 << 8);
              }

              uint64_t v414 = v411;
              unsigned int v415 = *(unsigned __int16 *)(v410 + 2LL * v411);
              unsigned int v416 = v415 + ((2048 - v415) >> 5);
              unsigned int v417 = (v18 >> 11) * v415;
              v411 *= 2;
              unsigned int v418 = v415 - (v415 >> 5);
              BOOL v419 = v11 >= v417;
              if (v11 < v417)
              {
                unsigned int v18 = v417;
              }

              else
              {
                v411 |= 1u;
                v18 -= v417;
              }

              if (v11 >= v417) {
                v11 -= v417;
              }
              if (v419)
              {
                int v420 = 1;
              }

              else
              {
                LOWORD(v418) = v416;
                int v420 = 0;
              }

              *(_WORD *)(v410 + 2 * v414) = v418;
              v409 += v420 << v408++;
            }

            while (v406 != v408);
          }

          unsigned int v405 = v409 + v407;
        }

        uint64_t v8 = lzma_fsm_lut[v8 + 24];
        a1[3] = a1[2];
        *(void *)(a1 + 1) = *(void *)a1;
        LODWORD(v210) = v405 + 1;
        *a1 = v405 + 1;
      }

      uint32x4_t v213 = &v19[v254];
      if ((unint64_t)(v213 + 47) > a5)
      {
        if (v213 > a4) {
          return 0LL;
        }
        do
        {
          *unsigned int v19 = v19[-v210];
          ++v19;
        }

        while (v19 < v213);
      }

      else if (v210 > 0xF)
      {
        __int128 v601 = &v19[-v210];
        if (v210 >= v254 + 47)
        {
          __int128 v603 = v601[1];
          *(_OWORD *)unsigned int v19 = *v601;
          *((_OWORD *)v19 + 1) = v603;
          *((_OWORD *)v19 + 2) = v601[2];
          if (v254 >= 0x31)
          {
            for (unint64_t i = 48LL; i < v254; i += 16LL)
              *(_OWORD *)&v19[i] = v601[i / 0x10];
          }
        }

        else
        {
          *(_OWORD *)unsigned int v19 = *v601;
          *((_OWORD *)v19 + 1) = v601[1];
          *((_OWORD *)v19 + 2) = v601[2];
          if (v254 >= 0x31)
          {
            for (unint64_t j = 48LL; j < v254; j += 16LL)
              *(_OWORD *)&v19[j] = v601[j / 0x10];
          }
        }
      }

      else
      {
        __int128 v594 = (int8x16_t *)&v19[-v210];
        int8x16_t v595 = vqtbl1q_s8(*v594, lzma_copy_with_pattern[(v210 - 1)]);
        uint64_t v596 = lzma_copy_with_pattern[(v210 - 1)];
        __int128 v597 = &v594->i8[v596];
        *(int8x16_t *)unsigned int v19 = v595;
        *((_OWORD *)v19 + 1) = *(_OWORD *)v597;
        *((_OWORD *)v19 + 2) = *((_OWORD *)v597 + 1);
        if (v254 >= 0x31)
        {
          uint64_t v598 = 0LL;
          uint64_t v599 = (uint64_t)&v19[v596 - v210 + 32];
          do
          {
            *(_OWORD *)&v19[v598 + 48] = *(_OWORD *)(v599 + v598);
            unint64_t v600 = v598 + 64;
            v598 += 16LL;
          }

          while (v600 < v254);
        }
      }

LABEL_770:
      unsigned int v19 = v213;
      if (v213 >= a4) {
        goto LABEL_830;
      }
    }
  }

  return v16;
}

uint64_t BrotliInitZopfliNodes(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = result + 12;
    do
    {
      *(void *)(v2 - 12) = 1LL;
      *(void *)(v2 - 4) = 0x7EFFC99E00000000LL;
      v2 += 16LL;
      --a2;
    }

    while (a2);
  }

  return result;
}

uint64_t BrotliZopfliCreateCommands( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v45 = result;
  uint64_t v8 = *(unsigned int *)(a3 + 12);
  if ((_DWORD)v8 == -1)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v9 = 0LL;
    unint64_t v11 = (1LL << *(_DWORD *)(a6 + 8)) - 16;
    uint64_t v12 = *(void *)(a6 + 16) + a2;
    uint64_t v13 = a7 + 8;
    do
    {
      int v14 = (unsigned int *)(a3 + 16 * (v9 + v8));
      unsigned int v15 = *v14;
      unsigned int v16 = v14[2];
      uint64_t v8 = v14[3];
      uint64_t v17 = v16 & 0x7FFFFFF;
      if (v10)
      {
        unint64_t v18 = v16 & 0x7FFFFFF;
      }

      else
      {
        unint64_t v18 = *a5 + v17;
        *a5 = 0LL;
      }

      uint64_t v19 = v15 & 0x1FFFFFF;
      uint64_t v20 = v9 + v17;
      unint64_t v21 = v14[1];
      unsigned int v22 = (v15 & 0x1FFFFFF) - (v15 >> 25) + 9;
      unint64_t v23 = v12 + v20;
      if (v12 + v20 >= v11) {
        unint64_t v23 = v11;
      }
      unsigned int v24 = v16 >> 27;
      if (v24) {
        unint64_t v25 = v24 - 1;
      }
      else {
        unint64_t v25 = (v21 + 15);
      }
      *(_DWORD *)(v13 - 8) = v18;
      *(_DWORD *)(v13 - 4) = v19 | ((v22 - v15) << 25);
      uint64_t v26 = *(unsigned int *)(a6 + 68);
      __int16 v27 = v26 + 16;
      if (v26 + 16 <= v25)
      {
        int v30 = *(_DWORD *)(a6 + 64);
        unint64_t v31 = v25 - v26 + (4LL << v30) - 16;
        unsigned int v32 = (__clz(v31) ^ 0x1F) - 1;
        __n128 result = v32 - v30;
        __int16 v29 = ((v31 & ~(-1 << v30)) + v27 + ((((v31 >> v32) & 1 | (2 * (v32 - v30))) + 65534) << v30)) | (((_WORD)v32 - (_WORD)v30) << 10);
        unint64_t v28 = (v31 - (((v31 >> v32) & 1 | 2) << v32)) >> v30;
      }

      else
      {
        LODWORD(v28) = 0;
        __int16 v29 = v25;
      }

      *(_WORD *)(v13 + 6) = v29;
      *(_DWORD *)uint64_t v13 = v28;
      if (v18 > 5)
      {
        if (v18 > 0x81)
        {
          if (v18 > 0x841)
          {
            if (v18 >> 1 >= 0xC21)
            {
              if (v18 < 0x5842) {
                LOWORD(v33) = 22;
              }
              else {
                LOWORD(v33) = 23;
              }
            }

            else
            {
              LOWORD(v33) = 21;
            }
          }

          else
          {
            unsigned int v33 = (__clz(v18 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v34 = (__clz(v18 - 2) ^ 0x1F) - 1;
          unsigned int v33 = ((v18 - 2) >> v34) + 2 * v34 + 2;
        }
      }

      else
      {
        LOWORD(v33) = v18;
      }

      if (v22 > 9)
      {
        unsigned int v36 = (__clz(v22 - 70) ^ 0x1F) + 12;
        if (v22 > 0x845) {
          LOWORD(v36) = 23;
        }
        unsigned int v37 = (__clz(v22 - 6) ^ 0x1F) - 1;
        int v38 = ((unint64_t)(int)(v22 - 6) >> v37) + 2 * v37 + 4;
        if (v22 <= 0x85) {
          unsigned __int16 v35 = v38;
        }
        else {
          unsigned __int16 v35 = v36;
        }
      }

      else
      {
        unsigned __int16 v35 = v22 - 2;
      }

      int v39 = v29 & 0x3FF;
      int v40 = v35 & 7 | (8 * (v33 & 7));
      if (v39) {
        BOOL v41 = 1;
      }
      else {
        BOOL v41 = (unsigned __int16)v33 > 7u;
      }
      if (v41 || v35 > 0xFu)
      {
        int v43 = 3 * ((unsigned __int16)v33 >> 3) + ((unsigned __int16)(v35 & 0xFFF8) >> 3);
        unsigned int v44 = ((((0x520D40u >> (2 * v43)) & 0xC0) + (v43 << 6)) | v40) + 64;
      }

      else if ((v35 & 0xFFF8) != 0)
      {
        LOWORD(v44) = v40 | 0x40;
      }

      else
      {
        LOWORD(v44) = v35 & 7 | (8 * (v33 & 7));
      }

      *(_WORD *)(v13 + 4) = v44;
      if (v23 >= v21 && (_DWORD)v25)
      {
        *(_DWORD *)(a4 + 12) = *(_DWORD *)(a4 + 8);
        *(void *)(a4 + 4) = *(void *)a4;
        *(_DWORD *)a4 = v21;
      }

      *a8 += v18;
      uint64_t v9 = v20 + v19;
      --v10;
      v13 += 16LL;
    }

    while (v8 != 0xFFFFFFFFLL);
  }

  *a5 += v45 - v9;
  return result;
}

uint64_t BrotliZopfliComputeShortestPath( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, _DWORD *a10)
{
  uint64_t v10 = MEMORY[0x1895F8858]();
  unsigned int v171 = v13;
  uint64_t v14 = v12;
  unint64_t v16 = v15;
  uint64_t v18 = v17;
  uint64_t v20 = v19;
  unint64_t v21 = v11;
  uint64_t v22 = v10;
  uint64_t v182 = *MEMORY[0x1895F89C0];
  uint64_t v163 = *(void *)(v12 + 16);
  int v23 = *(_DWORD *)(v12 + 8);
  else {
    uint64_t v24 = 150LL;
  }
  if (v11 >= 0x7F) {
    unint64_t v25 = v11 - 127;
  }
  else {
    unint64_t v25 = 0LL;
  }
  *a10 = 0;
  a10[3] = 0;
  InitZopfliCostModel(v10, (uint64_t)v177, v12 + 64, v11);
  uint64_t result = 0LL;
  if (!*(_DWORD *)(v22 + 24))
  {
    uint64_t v160 = v22;
    uint64_t v167 = v20;
    ZopfliCostModelSetFromLiteralCosts((uint64_t)v177);
    uint64_t v176 = 0LL;
    uint64_t v27 = v163;
    if (v21 >= 4)
    {
      uint64_t v28 = v14;
      uint64_t v29 = 0LL;
      unint64_t v172 = (1LL << v23) - 16;
      *(void *)int v173 = v21;
      unint64_t v161 = v25 + v167;
      int v162 = (uint64_t *)(v14 + 88);
      uint64_t v174 = a9 + 8;
      unint64_t v165 = v24;
      uint64_t v166 = v14;
      do
      {
        unint64_t v30 = v29 + v167;
        if (v29 + v167 >= v172) {
          unint64_t v31 = v172;
        }
        else {
          unint64_t v31 = v29 + v167;
        }
        unint64_t v32 = v30 + v27;
        if (v32 >= v172) {
          unint64_t v32 = v172;
        }
        unint64_t v164 = v32;
        unint64_t v33 = v21 - v29;
        unint64_t v34 = v30 & v16;
        unint64_t v35 = 16LL;
        if (*(_DWORD *)(v28 + 4) == 11) {
          unint64_t v35 = 64LL;
        }
        BOOL v36 = v30 >= v35;
        unint64_t v37 = v30 - v35;
        if (!v36) {
          unint64_t v37 = 0LL;
        }
        unint64_t v38 = v30 - 1;
        if (v30 - 1 <= v37)
        {
          int v40 = (char *)v180;
          unint64_t v41 = 1LL;
        }

        else
        {
          int v39 = (unsigned __int8 *)(v18 + v34);
          int v40 = (char *)v180;
          unint64_t v41 = 1LL;
          do
          {
            if (v30 - v38 > v31) {
              break;
            }
            unsigned int v42 = (unsigned __int8 *)(v18 + (v38 & v16));
            if (*v39 == *v42 && *(unsigned __int8 *)(v18 + v34 + 1) == *(unsigned __int8 *)((v38 & v16) + v18 + 1))
            {
              if (v33 < 8)
              {
                unint64_t v47 = 0LL;
                int v48 = (unsigned __int8 *)(v18 + v34);
LABEL_36:
                if ((v33 & 7) != 0)
                {
                  unint64_t v49 = v33 & 7 | v47;
                  unint64_t v50 = v33 & 7;
                  while (v42[v47] == *v48)
                  {
                    ++v48;
                    ++v47;
                    if (!--v50)
                    {
                      unint64_t v47 = v49;
                      break;
                    }
                  }
                }
              }

              else
              {
                uint64_t v43 = 0LL;
                unint64_t v44 = v33 >> 3;
                while (1)
                {
                  uint64_t v45 = *(void *)&v39[v43];
                  uint64_t v46 = *(void *)&v42[v43];
                  if (v45 != v46) {
                    break;
                  }
                  v43 += 8LL;
                  if (!--v44)
                  {
                    unint64_t v47 = v33 & 0xFFFFFFFFFFFFFFF8LL;
                    int v48 = (unsigned __int8 *)(v18 + v34 + (v33 & 0xFFFFFFFFFFFFFFF8LL));
                    goto LABEL_36;
                  }
                }

                unint64_t v47 = v43 + (__clz(__rbit64(v46 ^ v45)) >> 3);
              }

              if (v47 > v41)
              {
                *(_DWORD *)int v40 = v30 - v38;
                *((_DWORD *)v40 + 1) = 32 * v47;
                v40 += 8;
                unint64_t v41 = v47;
              }
            }

            if (--v38 <= v37) {
              break;
            }
          }

          while (v41 < 3);
        }

        if (v41 < v33)
        {
          uint64_t v51 = (506832829 * *(_DWORD *)(v18 + v34)) >> 15;
          uint64_t v52 = a9[9];
          uint64_t v54 = a9[6];
          uint64_t v53 = a9[7];
          uint64_t v55 = *(unsigned int *)(v53 + 4LL * v51);
          if (v33 >= 0x80) {
            uint64_t v56 = 128LL;
          }
          else {
            uint64_t v56 = v21 - v29;
          }
          unint64_t v168 = v56;
          uint64_t v169 = a9[6];
          if (v33 >= 0x80) {
            *(_DWORD *)(v53 + 4 * v51) = v30;
          }
          uint64_t v57 = 2 * (v54 & v30);
          uint64_t v58 = v57 | 1;
          if (v30 != v55)
          {
            unint64_t v140 = 0LL;
            unint64_t v141 = 0LL;
            uint64_t v142 = 64LL;
            do
            {
              if (v30 - v55 > v31 || v142 == 0) {
                break;
              }
              unint64_t v144 = v55 & v16;
              if (v141 >= v140) {
                unint64_t v145 = v140;
              }
              else {
                unint64_t v145 = v141;
              }
              uint64_t v146 = v18 + v145 + v34;
              unsigned int v147 = (unsigned __int8 *)(v18 + v144 + v145);
              unint64_t v148 = v33 - v145;
              if (v33 - v145 < 8)
              {
                unint64_t v151 = 0LL;
LABEL_187:
                uint64_t v156 = v148 & 7;
                if (v156)
                {
                  unint64_t v157 = v151 | v156;
                  while (*(unsigned __int8 *)(v146 + v151) == *v147)
                  {
                    ++v147;
                    ++v151;
                    if (!--v156)
                    {
                      unint64_t v151 = v157;
                      break;
                    }
                  }
                }
              }

              else
              {
                uint64_t v149 = 0LL;
                unint64_t v150 = v148 >> 3;
                unint64_t v151 = v148 & 0xFFFFFFFFFFFFFFF8LL;
                while (1)
                {
                  uint64_t v152 = *(void *)&v147[v149];
                  uint64_t v153 = *(void *)(v146 + v149);
                  if (v152 != v153) {
                    break;
                  }
                  v149 += 8LL;
                  if (!--v150)
                  {
                    v147 += v148 & 0xFFFFFFFFFFFFFFF8LL;
                    goto LABEL_187;
                  }
                }

                unint64_t v151 = v149 + (__clz(__rbit64(v153 ^ v152)) >> 3);
              }

              unint64_t v154 = v151 + v145;
              if (v40 && v154 > v41)
              {
                *(_DWORD *)int v40 = v30 - v55;
                *((_DWORD *)v40 + 1) = 32 * v154;
                v40 += 8;
                unint64_t v41 = v154;
              }

              if (v154 >= v168)
              {
                if (v33 < 0x80) {
                  goto LABEL_52;
                }
                unsigned int v158 = (int *)(v52 + 8 * (v55 & v169));
                int v159 = *v158;
                uint64_t v59 = v158 + 1;
                *(_DWORD *)(v52 + 4 * v57) = v159;
                goto LABEL_51;
              }

              if (*(unsigned __int8 *)(v18 + v154 + v34) <= *(unsigned __int8 *)(v18 + v154 + v144))
              {
                if (v33 >= 0x80) {
                  *(_DWORD *)(v52 + 4 * v58) = v55;
                }
                uint64_t v58 = 2 * (v55 & v169);
                unint64_t v140 = v154;
                uint64_t v155 = v58;
              }

              else
              {
                if (v33 >= 0x80) {
                  *(_DWORD *)(v52 + 4 * v57) = v55;
                }
                uint64_t v57 = (2 * (v55 & v169)) | 1;
                unint64_t v141 = v154;
                uint64_t v155 = v57;
              }

              uint64_t v55 = *(unsigned int *)(v52 + 4 * v155);
              --v142;
            }

            while (v30 != v55);
          }

          if (v33 >= 0x80)
          {
            *(_DWORD *)(v52 + 4 * v57) = *v174;
            uint64_t v59 = a9 + 8;
LABEL_51:
            *(_DWORD *)(v52 + 4 * v58) = *v59;
          }
        }

LABEL_52:
        memset_pattern16(__b, &unk_181097440, 0x98uLL);
        if (v41 + 1 > 4) {
          unint64_t v60 = v41 + 1;
        }
        else {
          unint64_t v60 = 4LL;
        }
        if (BrotliFindAllStaticDictionaryMatches( v162,  (unsigned __int8 *)(v18 + v34),  v60,  v21 - v29,  (uint64_t)__b))
        {
          if (v33 >= 0x25) {
            unint64_t v61 = 37LL;
          }
          else {
            unint64_t v61 = v21 - v29;
          }
          unint64_t v63 = v165;
          uint64_t v62 = v166;
          if (v60 <= v61)
          {
            unint64_t v64 = v61 + 1;
            int v65 = 32 * v60;
            do
            {
              unint64_t v66 = __b[v60];
              if (v66 <= 0xFFFFFFE)
              {
                unint64_t v67 = v164 + 1 + (v66 >> 5);
                if (v67 <= *(void *)(v166 + 80))
                {
                  uint64_t v68 = v66 & 0x1F;
                  if (v60 == v68) {
                    LODWORD(v68) = 0;
                  }
                  *(_DWORD *)int v40 = v67;
                  *((_DWORD *)v40 + 1) = v65 + v68;
                  v40 += 8;
                }
              }

              ++v60;
              v65 += 32;
            }

            while (v64 != v60);
          }
        }

        else
        {
          unint64_t v63 = v165;
          uint64_t v62 = v166;
        }

        uint64_t v69 = v40 - (char *)v180;
        if (v40 == (char *)v180)
        {
          uint64_t v70 = 0LL;
          unint64_t v72 = *(void *)v173;
        }

        else
        {
          uint64_t v70 = v69 >> 3;
          uint64_t v71 = (v69 >> 3) - 1;
          unint64_t v72 = *(void *)v173;
          if (v63 < (unint64_t)HIDWORD(v180[v71]) >> 5)
          {
            v180[0] = v180[v71];
            uint64_t v70 = 1LL;
          }
        }

        unint64_t updated = UpdateNodes( v72,  v167,  v29,  v18,  v16,  v62,  v172,  v171,  v70,  (uint64_t)v180,  (uint64_t)v177,  (uint64_t)v175,  (uint64_t)a10);
        if (updated >= 0x4000) {
          unint64_t v74 = updated;
        }
        else {
          unint64_t v74 = 0LL;
        }
        if (v70 == 1)
        {
          unint64_t v75 = (unint64_t)HIDWORD(v180[0]) >> 5;
          if (v75 <= v74) {
            unint64_t v75 = v74;
          }
        }

        if (v74 < 2)
        {
          unint64_t v21 = *(void *)v173;
        }

        else
        {
          unint64_t v170 = v74;
          unint64_t v76 = v161;
          if (v74 + v30 < v161) {
            unint64_t v76 = v74 + v30;
          }
          unint64_t v77 = v76 - 63;
          if (v30 + 64 > v76) {
            unint64_t v77 = v30 + 1;
          }
          if (v30 + 513 <= v77)
          {
            unint64_t v78 = v30 + 1;
            if (v30 + 1 < v77)
            {
              uint64_t v79 = a9[6];
              uint64_t v80 = a9[7];
              uint64_t v81 = a9[9];
              do
              {
                unint64_t v82 = v78 & v16;
                unsigned int v83 = (506832829 * *(_DWORD *)(v18 + (v78 & v16))) >> 15;
                uint64_t v84 = *(unsigned int *)(v80 + 4LL * v83);
                uint64_t v85 = 2 * (v79 & v78);
                uint64_t v86 = v85 | 1;
                *(_DWORD *)(v80 + 4LL * v83) = v78;
                if (v78 != v84)
                {
                  unint64_t v88 = 0LL;
                  unint64_t v89 = 0LL;
                  uint64_t v90 = 64LL;
                  do
                  {
                    if (v78 - v84 > v79 - 15 || v90 == 0) {
                      break;
                    }
                    unint64_t v92 = v84 & v16;
                    if (v89 >= v88) {
                      unint64_t v93 = v88;
                    }
                    else {
                      unint64_t v93 = v89;
                    }
                    unint64_t v94 = v18 + v82 + v93;
                    unsigned int v95 = (unsigned __int8 *)(v18 + v92 + v93);
                    unint64_t v96 = 128 - v93;
                    if (128 - v93 < 8)
                    {
                      unint64_t v99 = 0LL;
LABEL_114:
                      uint64_t v105 = v96 & 7;
                      if (v105)
                      {
                        unint64_t v106 = v99 | v105;
                        while (*(unsigned __int8 *)(v94 + v99) == *v95)
                        {
                          ++v95;
                          ++v99;
                          if (!--v105)
                          {
                            unint64_t v99 = v106;
                            break;
                          }
                        }
                      }
                    }

                    else
                    {
                      uint64_t v97 = 0LL;
                      unint64_t v98 = v96 >> 3;
                      unint64_t v99 = v96 & 0xFFFFFFFFFFFFFFF8LL;
                      while (1)
                      {
                        uint64_t v100 = *(void *)&v95[v97];
                        uint64_t v101 = *(void *)(v94 + v97);
                        if (v100 != v101) {
                          break;
                        }
                        v97 += 8LL;
                        if (!--v98)
                        {
                          v95 += v96 & 0xFFFFFFFFFFFFFFF8LL;
                          goto LABEL_114;
                        }
                      }

                      unint64_t v99 = v97 + (__clz(__rbit64(v101 ^ v100)) >> 3);
                    }

                    unint64_t v102 = v99 + v93;
                    if (v102 >= 0x80)
                    {
                      int v107 = (_DWORD *)(v81 + 8 * (v84 & v79));
                      *(_DWORD *)(v81 + 4 * v85) = *v107;
                      int v87 = v107[1];
                      goto LABEL_91;
                    }

                    unsigned int v103 = *(unsigned __int8 *)(v18 + v102 + v92);
                    uint64_t v104 = 2 * (v84 & v79);
                    if (*(unsigned __int8 *)(v18 + v102 + v82) <= v103)
                    {
                      *(_DWORD *)(v81 + 4 * v86) = v84;
                      unint64_t v88 = v102;
                      uint64_t v86 = 2 * (v84 & v79);
                    }

                    else
                    {
                      *(_DWORD *)(v81 + 4 * v85) = v84;
                      uint64_t v85 = v104 | 1;
                      unint64_t v89 = v102;
                      v104 |= 1uLL;
                    }

                    uint64_t v84 = *(unsigned int *)(v81 + 4 * v104);
                    --v90;
                  }

                  while (v78 != v84);
                }

                int v87 = *v174;
                *(_DWORD *)(v81 + 4 * v85) = *v174;
LABEL_91:
                *(_DWORD *)(v81 + 4 * v86) = v87;
                v78 += 8LL;
              }

              while (v78 < v77);
            }
          }

          if (v77 < v76)
          {
            uint64_t v108 = a9[6];
            uint64_t v109 = a9[7];
            uint64_t v110 = a9[9];
            do
            {
              unint64_t v111 = v77 & v16;
              unsigned int v112 = (506832829 * *(_DWORD *)(v18 + (v77 & v16))) >> 15;
              uint64_t v113 = *(unsigned int *)(v109 + 4LL * v112);
              uint64_t v114 = 2 * (v108 & v77);
              uint64_t v115 = v114 | 1;
              *(_DWORD *)(v109 + 4LL * v112) = v77;
              if (v77 != v113)
              {
                unint64_t v117 = 0LL;
                unint64_t v118 = 0LL;
                uint64_t v119 = 64LL;
                do
                {
                  if (v77 - v113 > v108 - 15 || v119 == 0) {
                    break;
                  }
                  unint64_t v121 = v113 & v16;
                  if (v118 >= v117) {
                    unint64_t v122 = v117;
                  }
                  else {
                    unint64_t v122 = v118;
                  }
                  unint64_t v123 = v18 + v111 + v122;
                  int v124 = (unsigned __int8 *)(v18 + v121 + v122);
                  unint64_t v125 = 128 - v122;
                  if (128 - v122 < 8)
                  {
                    unint64_t v128 = 0LL;
LABEL_148:
                    uint64_t v134 = v125 & 7;
                    if (v134)
                    {
                      unint64_t v135 = v128 | v134;
                      while (*(unsigned __int8 *)(v123 + v128) == *v124)
                      {
                        ++v124;
                        ++v128;
                        if (!--v134)
                        {
                          unint64_t v128 = v135;
                          break;
                        }
                      }
                    }
                  }

                  else
                  {
                    uint64_t v126 = 0LL;
                    unint64_t v127 = v125 >> 3;
                    unint64_t v128 = v125 & 0xFFFFFFFFFFFFFFF8LL;
                    while (1)
                    {
                      uint64_t v129 = *(void *)&v124[v126];
                      uint64_t v130 = *(void *)(v123 + v126);
                      if (v129 != v130) {
                        break;
                      }
                      v126 += 8LL;
                      if (!--v127)
                      {
                        v124 += v125 & 0xFFFFFFFFFFFFFFF8LL;
                        goto LABEL_148;
                      }
                    }

                    unint64_t v128 = v126 + (__clz(__rbit64(v130 ^ v129)) >> 3);
                  }

                  unint64_t v131 = v128 + v122;
                  if (v131 >= 0x80)
                  {
                    unsigned int v136 = (_DWORD *)(v110 + 8 * (v113 & v108));
                    *(_DWORD *)(v110 + 4 * v114) = *v136;
                    int v116 = v136[1];
                    goto LABEL_125;
                  }

                  unsigned int v132 = *(unsigned __int8 *)(v18 + v131 + v121);
                  uint64_t v133 = 2 * (v113 & v108);
                  if (*(unsigned __int8 *)(v18 + v131 + v111) <= v132)
                  {
                    *(_DWORD *)(v110 + 4 * v115) = v113;
                    unint64_t v117 = v131;
                    uint64_t v115 = 2 * (v113 & v108);
                  }

                  else
                  {
                    *(_DWORD *)(v110 + 4 * v114) = v113;
                    uint64_t v114 = v133 | 1;
                    unint64_t v118 = v131;
                    v133 |= 1uLL;
                  }

                  uint64_t v113 = *(unsigned int *)(v110 + 4 * v133);
                  --v119;
                }

                while (v77 != v113);
              }

              int v116 = *v174;
              *(_DWORD *)(v110 + 4 * v114) = *v174;
LABEL_125:
              *(_DWORD *)(v110 + 4 * v115) = v116;
              ++v77;
            }

            while (v77 < v76);
          }

          unint64_t v137 = v170 - 1;
          unint64_t v138 = v29 + 4;
          unint64_t v21 = *(void *)v173;
          do
          {
            uint64_t v29 = v138 - 3;
            if (v138 >= v21) {
              break;
            }
            EvaluateNode((void *)(v163 + v167), v138 - 3, v172, v171, (uint64_t)v177, (uint64_t)v175, (uint64_t)a10);
            unint64_t v21 = *(void *)v173;
            ++v138;
            --v137;
          }

          while (v137);
        }

        uint64_t v28 = v166;
        uint64_t v27 = v163;
        unint64_t v139 = v29 + 4;
        ++v29;
      }

      while (v139 < v21);
    }

    BrotliFree(v160, v179);
    BrotliFree(v160, v178);
    return ComputeShortestPathFromNodes(v21, (uint64_t)a10);
  }

  return result;
}

uint64_t InitZopfliCostModel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a2 + 2848) = a4;
  if (a4 == -2) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = BrotliAllocate(a1);
  }
  *(void *)(a2 + 2832) = v7;
  int v8 = *(_DWORD *)(a3 + 12);
  if (v8)
  {
    uint64_t result = BrotliAllocate(a1);
    int v8 = *(_DWORD *)(a3 + 12);
  }

  else
  {
    uint64_t result = 0LL;
  }

  *(void *)(a2 + 2816) = result;
  *(_DWORD *)(a2 + 2824) = v8;
  return result;
}

float ZopfliCostModelSetFromLiteralCosts(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 2832);
  uint64_t v3 = *(void *)(a1 + 2816);
  uint64_t v4 = *(void *)(a1 + 2848);
  int16x8_t v5 = (float *)(v2 + 1);
  BrotliEstimateBitCostsForLiterals();
  *uint64_t v2 = 0;
  if (v4)
  {
    float v6 = 0.0;
    float v7 = 0.0;
    do
    {
      float v8 = v7 + *v5;
      float v9 = v6 + v8;
      *v5++ = v6 + v8;
      float v7 = v8 - (float)((float)(v6 + v8) - v6);
      float v6 = v9;
      --v4;
    }

    while (v4);
  }

  for (unint64_t i = 0LL; i != 704; ++i)
  {
    if (i > 0xF4) {
      double v11 = log2((double)(i + 11));
    }
    else {
      double v11 = kBrotliLog2Table[i + 11];
    }
    float v12 = v11;
    *(float *)(a1 + 4 * i) = v12;
  }

  uint64_t v13 = *(unsigned int *)(a1 + 2824);
  if ((_DWORD)v13)
  {
    for (uint64_t j = 0LL; j != v13; ++j)
    {
      unint64_t v15 = (j + 20);
      else {
        double v16 = kBrotliLog2Table[v15];
      }
      float v17 = v16;
      *(float *)(v3 + 4 * j) = v17;
    }
  }

  float result = 3.45943165;
  *(float *)(a1 + 2840) = 3.45943165;
  return result;
}

unint64_t UpdateNodes( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, void *__src, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v15 = a3;
  uint64_t v16 = *(void *)(a6 + 16);
  unint64_t v17 = a3 + a2;
  uint64_t v106 = (a3 + a2) & a5;
  if (v16 + a3 + a2 >= a7) {
    unint64_t v18 = a7;
  }
  else {
    unint64_t v18 = v16 + a3 + a2;
  }
  unint64_t v108 = a1 - a3;
  int v100 = *(_DWORD *)(a6 + 4);
  if (v100 <= 10) {
    unint64_t v19 = 150LL;
  }
  else {
    unint64_t v19 = 325LL;
  }
  uint64_t v20 = a12;
  EvaluateNode((void *)(v16 + a2), a3, a7, __src, a11, a12, a13);
  if (v15 + 2 <= a1)
  {
    uint64_t v24 = a12 + 32 * (-*(_DWORD *)(a12 + 256) & 7LL);
    float v25 = (float)(*(float *)(v24 + 28) + *(float *)(a11 + 2840))
    uint64_t v23 = a13;
    uint64_t v26 = (float *)(a13 + 16 * v15 + 44);
    uint64_t v21 = 2LL;
    uint64_t v27 = 4LL;
    uint64_t v28 = 10LL;
    uint64_t v22 = a4;
    do
    {
      if (*v26 > v25) {
        break;
      }
      if (++v21 == v28)
      {
        float v25 = v25 + 1.0;
        uint64_t v29 = v27;
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      v27 <<= v21 == v28;
      v28 += v29;
      v26 += 4;
    }

    while (v15 + v21 <= a1);
  }

  else
  {
    uint64_t v21 = 2LL;
    uint64_t v22 = a4;
    uint64_t v23 = a13;
  }

  unint64_t result = 0LL;
  unint64_t v31 = 0LL;
  unint64_t v98 = v21;
  unint64_t v99 = v21 - 1;
  if (v18 >= v17) {
    unint64_t v32 = v17;
  }
  else {
    unint64_t v32 = v18;
  }
  unint64_t v104 = v32;
  uint64_t v97 = (unsigned __int8 *)(v22 + v106);
  unint64_t v96 = (unsigned __int8 *)(v22 + v106 + (v108 & 0xFFFFFFFFFFFFFFF8LL));
  uint64_t v107 = v15;
  while (1)
  {
    unint64_t v33 = *(void *)(v20 + 256);
    unint64_t v34 = 8LL;
    if (v33 < 8) {
      unint64_t v34 = *(void *)(v20 + 256);
    }
    if (v31 >= v34) {
      return result;
    }
    uint64_t v35 = ((_BYTE)v31 - (_BYTE)v33) & 7;
    unint64_t v36 = v15 - *(void *)(v20 + 32 * v35);
    if (v36 > 5)
    {
      if (v36 > 0x81)
      {
        if (v36 < 0x5842) {
          __int16 v39 = 22;
        }
        else {
          __int16 v39 = 23;
        }
        if (v36 >> 1 >= 0xC21) {
          __int16 v40 = v39;
        }
        else {
          __int16 v40 = 21;
        }
        unsigned int v41 = (__clz(v36 - 66) ^ 0x1F) + 10;
        if (v36 <= 0x841) {
          LOWORD(v37) = v41;
        }
        else {
          LOWORD(v37) = v40;
        }
      }

      else
      {
        unsigned int v38 = (__clz(v36 - 2) ^ 0x1F) - 1;
        LODWORD(v37) = ((v36 - 2) >> v38) + 2 * v38 + 2;
      }
    }

    else
    {
      uint64_t v37 = v15 - *(void *)(v20 + 32 * v35);
    }

    unint64_t v103 = v31;
    unint64_t v43 = v99;
    unsigned __int16 v102 = v37;
    if (v99 < v108)
    {
      unint64_t v44 = 0LL;
      int v45 = 8 * (v37 & 7);
      int v46 = 3 * ((unsigned __int16)v37 >> 3);
      while (1)
      {
        if (v43 + v106 > a5) {
          goto LABEL_91;
        }
        unint64_t v47 = kDistanceCacheOffset[v44] + (uint64_t)*(int *)(a12 + 32 * v35 + 4LL * kDistanceCacheIndex[v44] + 8);
        unint64_t v48 = v17 - v47;
        BOOL v49 = v104 < v47 || v48 >= v17;
        unint64_t v50 = v48 & a5;
        unint64_t v51 = v50 + v43;
        BOOL v52 = v49 || v51 > a5;
        if (!v52 && *(unsigned __int8 *)(a4 + v43 + v106) == *(unsigned __int8 *)(a4 + v51))
        {
          uint64_t v53 = a4 + v50;
          if (v108 < 8)
          {
            unint64_t v58 = 0LL;
            uint64_t v59 = v97;
LABEL_86:
            unint64_t v73 = v108 & 7;
            if ((v108 & 7) != 0)
            {
              unint64_t v74 = v108 & 7 | v58;
              while (*(unsigned __int8 *)(v53 + v58) == *v59)
              {
                ++v59;
                ++v58;
                if (!--v73)
                {
                  unint64_t v58 = v74;
                  break;
                }
              }
            }
          }

          else
          {
            uint64_t v54 = 0LL;
            unint64_t v55 = v108 >> 3;
            while (1)
            {
              uint64_t v56 = *(void *)&v97[v54];
              uint64_t v57 = *(void *)(v53 + v54);
              if (v56 != v57) {
                break;
              }
              v54 += 8LL;
              if (!--v55)
              {
                uint64_t v59 = v96;
                unint64_t v58 = v108 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_86;
              }
            }

            unint64_t v58 = v54 + (__clz(__rbit64(v57 ^ v56)) >> 3);
          }

          if (v43 + 1 <= v58) {
            break;
          }
        }

LABEL_46:
        if (v44 <= 0xE)
        {
          ++v44;
          if (v43 < v108) {
            continue;
          }
        }

        goto LABEL_91;
      }

      float v60 = *(float *)(*(void *)(a11 + 2816) + 4 * v44);
      BOOL v62 = v102 < 8u && v44 == 0;
      unint64_t v63 = (float *)(v23 + 28 + 16 * (v107 + v43));
      unint64_t v64 = v43;
      while (2)
      {
        unint64_t v65 = v64 + 1;
        if (v64 + 1 <= 9)
        {
          LOWORD(v66) = v64 - 1;
          goto LABEL_70;
        }

        if (v65 <= 0x85)
        {
          unsigned int v67 = __clz(v64 - 5);
          unsigned int v66 = ((v64 - 5) >> ((v67 ^ 0x1F) - 1)) + 2 * ((v67 ^ 0x1F) - 1) + 4;
          goto LABEL_70;
        }

        if (v65 > 0x845)
        {
          LOWORD(v66) = 23;
          int v68 = v45 | 7;
        }

        else
        {
          unsigned int v66 = (__clz(v64 - 69) ^ 0x1F) + 12;
LABEL_70:
          int v68 = v66 & 7 | v45;
          char v69 = !v62;
          if ((v69 & 1) == 0)
          {
            if ((v66 & 0xFFF8) != 0) {
              LOWORD(v68) = v68 | 0x40;
            }
LABEL_77:
            if ((v68 & 0xFF80) != 0) {
              float v70 = v60;
            }
            else {
              float v70 = -0.0;
            }
            if (v71 < *v63)
            {
              *((_DWORD *)v63 - 3) = (v64 + 1) | 0x12000000;
              *((_DWORD *)v63 - 2) = v47;
              *((_DWORD *)v63 - 1) = (((_DWORD)v44 << 27) + 0x8000000) | v36;
              *unint64_t v63 = v71;
              if (result <= v65) {
                unint64_t result = v64 + 1;
              }
            }

            unint64_t v43 = v64 + 1;
            unint64_t v72 = v64 + 2;
            v63 += 4;
            ++v64;
            if (v72 > v58) {
              goto LABEL_46;
            }
            continue;
          }
        }

        break;
      }

      int v68 = ((((0x520D40u >> (2 * (v46 + ((unsigned __int16)(v66 & 0xFFF8) >> 3)))) & 0xC0)
      goto LABEL_77;
    }

            *(_DWORD *)(v2 + 16) = v8;
            break;
          case 8:
            if (*(void *)(a1 + 24))
            {
              uint64_t v59 = 9;
              goto LABEL_92;
            }

            return 1LL;
          default:
            return result;
        }
      }
    }

    return 0xFFFFFFFFLL;
  }

  unint64_t v36 = v2 + 65596;
  uint64_t v37 = (int *)(v2 + 24);
  while (2)
  {
    unint64_t result = 1LL;
    switch(*(_DWORD *)(v2 + 16))
    {
      case 0:
        unsigned int v38 = *(unsigned int *)(v2 + 48);
        else {
          __int16 v39 = *(void *)(a1 + 24);
        }
        memcpy((void *)(v36 + v38), *(const void **)(a1 + 16), v39);
        __int16 v40 = *(void *)(a1 + 24) - v39;
        *(void *)(a1 + 16) += v39;
        *(void *)(a1 + 24) = v40;
        LODWORD(v40) = *(_DWORD *)(v2 + 44);
        unsigned int v41 = *(_DWORD *)(v2 + 48) + v39;
        *(_DWORD *)(v2 + 48) = v41;
        goto LABEL_63;
      case 5:
        float v42 = *(unsigned int *)(v2 + 36);
        if (v42 <= 3)
        {
          unint64_t v43 = 4;
          *(_DWORD *)(v2 + 40) = 4;
          goto LABEL_74;
        }

        BOOL v52 = *v37;
        if (*v37 == 758412898)
        {
          unint64_t v43 = 8;
          goto LABEL_73;
        }

        if (v52 == 825521762)
        {
          unint64_t v43 = 12;
LABEL_73:
          *(_DWORD *)(v2 + 40) = v43;
          if (v42 >= v43)
          {
            if (v52 == 758412898)
            {
              unint64_t v58 = *(_DWORD *)(v2 + 28);
              if (v58 > 0x10000) {
                goto LABEL_86;
              }
              *(_DWORD *)(v2 + 44) = v58;
              *(_DWORD *)(v2 + 48) = 0;
              *(_DWORD *)(v2 + 16) = 0;
            }

            else
            {
              uint64_t v57 = *(_DWORD *)(v2 + 32);
              if (v57 > 0x10000 || *(_DWORD *)(v2 + 28) >= 0x10001u)
              {
LABEL_86:
                *(_DWORD *)(v2 + 16) = 9;
                return 0xFFFFFFFFLL;
              }

              *(_DWORD *)(v2 + 52) = v57;
              *(_DWORD *)(v2 + 56) = 0;
              *(_DWORD *)(v2 + 16) = 6;
            }
          }

          else
          {
LABEL_74:
            uint64_t v53 = v43 - v42;
            uint64_t v54 = *(void *)(a1 + 24);
            if (v54 >= v53) {
              unint64_t v55 = v53;
            }
            else {
              unint64_t v55 = v54;
            }
            if (!(_DWORD)v55) {
              return 0LL;
            }
            memcpy((char *)v37 + v42, *(const void **)(a1 + 16), v55);
            uint64_t v56 = *(void *)(a1 + 24) - v55;
            *(void *)(a1 + 16) += v55;
            *(void *)(a1 + 24) = v56;
            *(_DWORD *)(v2 + 36) += v55;
          }

          continue;
        }

        if (v52 != 607417954) {
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(v2 + 40) = 4;
        uint64_t v59 = 8;
LABEL_92:
        *(_DWORD *)(v2 + 16) = v59;
        return result;
      case 6:
        unint64_t v44 = *(unsigned int *)(v2 + 56);
        else {
          int v45 = *(void *)(a1 + 24);
        }
        memcpy((void *)(v2 + 131260 + v44), *(const void **)(a1 + 16), v45);
        int v46 = *(void *)(a1 + 24) - v45;
        *(void *)(a1 + 16) += v45;
        *(void *)(a1 + 24) = v46;
        unint64_t v47 = *(unsigned int *)(v2 + 52);
        LODWORD(v46) = *(_DWORD *)(v2 + 56) + v45;
        *(_DWORD *)(v2 + 56) = v46;
        float v60 = (unsigned __int8 *)(v2 + 131260);
        unint64_t v61 = (void *)(v2 + 65596);
        if (lz4_decode_asm((int8x16_t **)&v61, v2 + 60, v2 + 131260, &v60, v2 + v47 + 131260)
          || lz4_decode(&v61, v2 + 60, v2 + 131260, &v60, v2 + 131260 + *(unsigned int *)(v2 + 52)))
        {
          goto LABEL_86;
        }

        *(_DWORD *)(v2 + 44) = (_DWORD)v61 - v36;
LABEL_63:
        *(_DWORD *)(v2 + 48) = 0;
        *(_DWORD *)(v2 + 16) = 7;
        continue;
      case 7:
        unint64_t v48 = *(unsigned int *)(v2 + 48);
        else {
          BOOL v49 = *(void *)(a1 + 8);
        }
        memcpy(*(void **)a1, (const void *)(v36 + v48), v49);
        unint64_t v50 = *(void *)(a1 + 8) - v49;
        *(void *)a1 += v49;
        *(void *)(a1 + 8) = v50;
        LODWORD(v50) = *(_DWORD *)(v2 + 44);
        unint64_t v51 = *(_DWORD *)(v2 + 48) + v49;
        *(_DWORD *)(v2 + 48) = v51;
        memcpy((void *)(v2 + 60), (const void *)(v2 + 65596), 0x10000uLL);
        *(_DWORD *)(v2 + 36) = 0;
        *(_DWORD *)(v2 + 40) = 0;
        *(_DWORD *)(v2 + 16) = 5;
        continue;
      case 8:
        return result;
      default:
        return 0xFFFFFFFFLL;
    }
  }

    if (v33 > 2)
    {
      unsigned int v38 = v33 - 3;
      else {
        __int16 v39 = v33 - 3;
      }
      *((_DWORD *)a5 + v25) = ((_WORD)v12 + 1) & 0x1FFF | (v23 << 13);
      *(_WORD *)(a1 + result) = v39 - 8 * v28 - v19;
      v12 += v33;
      unint64_t v18 = result + 2;
      v17 |= 1uLL;
      if (v38 >= 7)
      {
        if (v16 >= 0x100)
        {
          *(_BYTE *)(a1 + v15) = (16 * v16) | (v16 >> 4);
          uint64_t v15 = result + 2;
          unint64_t v18 = result + 3;
          uint64_t v16 = 1;
        }

        __int16 v40 = v33 - 10;
        uint64_t v16 = v40 | (16 * v16);
        if ((v33 - 10) >= 0xF)
        {
          unsigned int v41 = v33 - 25;
          else {
            float v42 = v33 - 25;
          }
          *(_BYTE *)(a1 + v18) = v42;
          if (v41 >= 0xFF)
          {
            unint64_t v43 = v41 >= 0xFFEA;
            if (v41 >= 0xFFEA) {
              unint64_t v44 = 0;
            }
            else {
              unint64_t v44 = v33 - 3;
            }
            *(_WORD *)(a1 + v18 + 1) = v44;
            if (v43)
            {
              *(_DWORD *)(a1 + v18 + 3) = v38;
              v18 += 7LL;
            }

            else
            {
              v18 += 3LL;
            }
          }

          else
          {
            ++v18;
          }
        }
      }
    }

    else
    {
      uint64_t v37 = *(_BYTE *)(a3 + v12++);
      unint64_t v18 = result + 1;
      *(_BYTE *)(a1 + result) = v37;
    }

LABEL_91:
    if (v103 <= 1 && a9)
    {
      uint64_t v75 = 0LL;
      unint64_t v76 = v98;
      do
      {
        unint64_t v77 = *(void *)(a10 + 8 * v75);
        LOWORD(v78) = v77 + 15;
        uint64_t v79 = *(unsigned int *)(a6 + 68);
        uint64_t v80 = v79 + 16;
        if (v79 + 16 <= (unint64_t)v77 + 15)
        {
          uint64_t v81 = *(unsigned int *)(a6 + 64);
          unint64_t v82 = v77 + ~v79 + (4LL << v81);
          uint64_t v83 = (__clz(v82) ^ 0x1F) - 1;
          uint64_t v78 = ((v82 & ~(-1 << v81)) + v80 + ((((v82 >> v83) & 1 | (2 * (v83 - v81))) - 2) << v81)) | ((v83 - v81) << 10);
        }

        unint64_t v84 = v77 >> 37;
        if (v76 <= v77 >> 37)
        {
          uint64_t v88 = HIDWORD(v77) & 0x1F;
          if ((v77 & 0x1F00000000LL) == 0) {
            uint64_t v88 = v77 >> 37;
          }
          unint64_t v89 = v84 + 1;
          int v90 = ((_DWORD)v76 << 25) + 301989888;
          unsigned int v91 = (float *)(v23 + 12 + 16 * (v107 + v76));
          do
          {
            else {
              unint64_t v92 = v88;
            }
            if (v92 > 9)
            {
              unsigned int v93 = (__clz(v92 - 70) ^ 0x1F) + 12;
              if (v92 > 0x845) {
                LOWORD(v93) = 23;
              }
              unsigned int v94 = (__clz(v92 - 6) ^ 0x1F) - 1;
              if (v92 <= 0x85) {
                LOWORD(v93) = ((v92 - 6) >> v94) + 2 * v94 + 4;
              }
            }

            else
            {
              LOWORD(v93) = v92 - 2;
            }

            float v95 = *(float *)(a11
                           + 4LL
                           * (unsigned __int16)(((((0x520D40u >> (2
                                                                * (3 * (v102 >> 3)
                                                                 + ((unsigned __int16)(v93 & 0xFFF8) >> 3)))) & 0xC0)
                                                + ((3 * (v102 >> 3) + ((unsigned __int16)(v93 & 0xFFF8) >> 3)) << 6)) | v93 & 7 | (8 * (v102 & 7)))
                                              + 64))
                + (float)(v87 + (float)kBrotliCopyExtra[(unsigned __int16)v93]);
            if (v95 < *v91)
            {
              *((_DWORD *)v91 - 3) = (v90 - ((_DWORD)v92 << 25)) | v76;
              *((_DWORD *)v91 - 2) = v77;
              *((_DWORD *)v91 - 1) = v36;
              *unsigned int v91 = v95;
              if (result <= v76) {
                unint64_t result = v76;
              }
            }

            ++v76;
            v90 += 0x2000000;
            v91 += 4;
          }

          while (v89 != v76);
          unint64_t v76 = v89;
        }

        ++v75;
      }

      while (v75 != a9);
    }

    if (v100 >= 11)
    {
      unint64_t v31 = v103 + 1;
      uint64_t v20 = a12;
      uint64_t v15 = v107;
      if (v103 < 4) {
        continue;
      }
    }

    return result;
  }

void *EvaluateNode( void *result, uint64_t a2, unint64_t a3, void *__src, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float v8 = (_DWORD *)(a7 + 16 * a2);
  float v9 = v8 + 3;
  float v10 = *((float *)v8 + 3);
  if (a2)
  {
    unint64_t v11 = v8[1];
    uint64_t v12 = *v8 & 0x1FFFFFF;
    unsigned int v13 = v8[2];
    int v15 = v11 + 15;
    if (v13 >> 27) {
      int v15 = (v13 >> 27) - 1;
    }
    if (!v15) {
LABEL_10:
    }
      uint64_t v16 = *(unsigned int *)(a7 + 16 * (a2 - ((v13 & 0x7FFFFFF) + v12)) + 12);
    else {
      uint64_t v16 = a2;
    }
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  *float v9 = v16;
  float v17 = *(float *)(*(void *)(a5 + 2832) + 4 * a2) - **(float **)(a5 + 2832);
  if (v10 <= v17)
  {
    *(void *)&__int128 v34 = a2;
    *((float *)&v35 + 2) = v10 - v17;
    *((float *)&v35 + 3) = v10;
    unint64_t v18 = 0LL;
    if (!v16) {
      goto LABEL_17;
    }
    do
    {
      unint64_t v19 = v18;
      uint64_t v20 = (int *)(a7 + 16 * v16);
      int v21 = *v20;
      int v22 = v20[2];
      *((_DWORD *)&v34 + v19 + 2) = v20[1];
      unint64_t v18 = v19 + 1;
      if (v19 > 2) {
        break;
      }
      uint64_t v16 = *(unsigned int *)(a7 + 16 * (v16 - ((v21 & 0x1FFFFFF) + (v22 & 0x7FFFFFFu))) + 12);
    }

    while (v16);
    if ((v18 & 0xFFFFFFFC) == 0) {
LABEL_17:
    }
      unint64_t result = memcpy((char *)&v34 + 4 * v18 + 8, __src, 16 - 4 * v18);
    uint64_t v23 = *(void *)(a6 + 256);
    *(void *)(a6 + 256) = v23 + 1;
    uint64_t v24 = ~(_BYTE)v23 & 7;
    else {
      unint64_t v25 = 8LL;
    }
    __int128 v26 = v35;
    uint64_t v27 = (_OWORD *)(a6 + 32 * v24);
    *uint64_t v27 = v34;
    v27[1] = v26;
    if (v25 >= 2)
    {
      unint64_t v28 = v25 - 1;
      do
      {
        uint64_t v29 = (float *)(a6 + 32 * (v24 & 7));
        unint64_t v30 = (float *)(a6 + 32LL * (((_BYTE)v24 + 1) & 7));
        if (v29[6] > v30[6])
        {
          __int128 v32 = *(_OWORD *)v29;
          __int128 v31 = *((_OWORD *)v29 + 1);
          __int128 v33 = *((_OWORD *)v30 + 1);
          *(_OWORD *)uint64_t v29 = *(_OWORD *)v30;
          *((_OWORD *)v29 + 1) = v33;
          *(_OWORD *)unint64_t v30 = v32;
          *((_OWORD *)v30 + 1) = v31;
        }

        LOBYTE(v24) = v24 + 1;
        --v28;
      }

      while (v28);
    }
  }

  return result;
}

uint64_t ComputeShortestPathFromNodes(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(a2 + 16 * a1);
  if ((v2[2] & 0x7FFFFFF) == 0)
  {
    uint64_t v3 = (_DWORD *)(a2 + 16 * a1);
    do
    {
      int v4 = *v3;
      v3 -= 4;
      if (v4 != 1) {
        break;
      }
      --a1;
      int v5 = *(v2 - 2);
      uint64_t v2 = v3;
    }

    while ((v5 & 0x7FFFFFF) == 0);
  }

  *(_DWORD *)(a2 + 16 * a1 + 12) = -1;
  for (uint64_t i = 0LL; a1; *(_DWORD *)(a2 + 16 * a1 + 12) = v7)
  {
    uint64_t v7 = (*(_DWORD *)(a2 + 16 * a1 + 8) & 0x7FFFFFF) + (*(_DWORD *)(a2 + 16 * a1) & 0x1FFFFFFu);
    ++i;
    a1 -= v7;
  }

  return i;
}

uint64_t BrotliCreateZopfliBackwardReferences( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13)
{
  uint64_t v18 = result;
  uint64_t v19 = a2 + 1;
  if (a2 == -1)
  {
    if (*(_DWORD *)(result + 24)) {
      return result;
    }
    uint64_t v20 = 0LL;
  }

  else
  {
    unint64_t result = BrotliAllocate(result);
    if (*(_DWORD *)(v18 + 24)) {
      return result;
    }
    uint64_t v20 = (_DWORD *)result;
    uint64_t v21 = result + 12;
    do
    {
      *(void *)(v21 - 12) = 1LL;
      *(void *)(v21 - 4) = 0x7EFFC99E00000000LL;
      v21 += 16LL;
      --v19;
    }

    while (v19);
  }

  unint64_t result = BrotliZopfliComputeShortestPath(v18, a2, a3, a4, a5, a6, a7, a9, a8, v20);
  *a12 += result;
  if (!*(_DWORD *)(v18 + 24))
  {
    BrotliZopfliCreateCommands(a2, a3, (uint64_t)v20, a9, a10, a7, a11, a13);
    return BrotliFree(v18, (unint64_t)v20);
  }

  return result;
}

void BrotliCreateHqZopfliBackwardReferences( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 *a9, void *a10, uint64_t a11, uint64_t *a12, void *a13)
{
  uint64_t v13 = MEMORY[0x1895F8858]();
  unsigned int v225 = v16;
  unint64_t v242 = v17;
  uint64_t v19 = v18;
  uint64_t v240 = v20;
  unint64_t v21 = v14;
  uint64_t v22 = v13;
  uint64_t v259 = *MEMORY[0x1895F89C0];
  uint64_t v241 = v15;
  uint64_t v245 = v19;
  unint64_t v246 = v14;
  uint64_t v227 = v13;
  if (v14)
  {
    uint64_t v224 = *(void *)(v15 + 16);
    int v23 = *(_DWORD *)(v15 + 8);
    uint64_t v24 = 4 * v14;
    uint64_t v25 = BrotliAllocate(v13);
    unint64_t v26 = v24;
    unint64_t v21 = v246;
    unint64_t v239 = v25;
    if (v246 >= 0x7F) {
      unint64_t v27 = v246 - 127;
    }
    else {
      unint64_t v27 = 0LL;
    }
    if (v26)
    {
      unint64_t v28 = v26;
      uint64_t v29 = BrotliAllocate(v22);
      unint64_t v26 = v28;
      unint64_t v21 = v246;
      unint64_t v30 = (char *)v29;
    }

    else
    {
      unint64_t v30 = 0LL;
    }

    int v232 = (_DWORD *)(v22 + 24);
    uint64_t v15 = v241;
    unint64_t v31 = v242;
    if (*(_DWORD *)(v22 + 24)) {
      return;
    }
    if (v21 < 4)
    {
      int v228 = 0;
    }

    else
    {
      uint64_t v32 = 0LL;
      uint64_t v33 = 0LL;
      unint64_t v220 = v27 + v240;
      unint64_t v222 = (1LL << v23) - 16;
      unsigned int v237 = v225 + 8;
      do
      {
        unint64_t v34 = v33 + v240;
        if (v33 + v240 >= v222) {
          unint64_t v35 = v222;
        }
        else {
          unint64_t v35 = v33 + v240;
        }
        if (v34 + v224 >= v222) {
          unint64_t v36 = v222;
        }
        else {
          unint64_t v36 = v34 + v224;
        }
        if (v26 < v32 + 128)
        {
          if (v26) {
            unint64_t v37 = v26;
          }
          else {
            unint64_t v37 = v32 + 128;
          }
          do
          {
            unint64_t v38 = v37;
            v37 *= 2LL;
          }

          while (v38 < v32 + 128);
          uint64_t v39 = v33;
          uint64_t v40 = v32;
          if (v38)
          {
            unsigned int v41 = v30;
            unint64_t v42 = v26;
            uint64_t v43 = BrotliAllocate(v227);
            unint64_t v26 = v42;
            unint64_t v30 = v41;
            unint64_t v44 = (char *)v43;
          }

          else
          {
            unint64_t v44 = 0LL;
          }

          if (*v232) {
            BOOL v45 = 1;
          }
          else {
            BOOL v45 = v26 == 0;
          }
          if (!v45)
          {
            int v46 = v30;
            memcpy(v44, v30, 8 * v26);
            unint64_t v30 = v46;
          }

          BrotliFree(v227, (unint64_t)v30);
          unint64_t v30 = v44;
          unint64_t v26 = v38;
          uint64_t v15 = v241;
          unint64_t v31 = v242;
          unint64_t v21 = v246;
          uint64_t v32 = v40;
          uint64_t v33 = v39;
        }

        if (*v232) {
          return;
        }
        unint64_t v223 = v36;
        uint64_t v233 = v33;
        uint64_t v235 = v32;
        unint64_t v47 = v21 - v33;
        int v243 = v30;
        unint64_t v48 = &v30[8 * v32];
        unint64_t v49 = v34 & v31;
        unint64_t v50 = 16LL;
        if (*(_DWORD *)(v15 + 4) == 11) {
          unint64_t v50 = 64LL;
        }
        BOOL v88 = v34 >= v50;
        unint64_t v51 = v34 - v50;
        if (!v88) {
          unint64_t v51 = 0LL;
        }
        unint64_t v52 = v34 - 1;
        unsigned int v229 = &v30[8 * v32];
        unint64_t v230 = v26;
        if (v34 - 1 <= v51)
        {
          unint64_t v54 = 1LL;
        }

        else
        {
          uint64_t v53 = (unsigned __int8 *)(v19 + v49);
          unint64_t v54 = 1LL;
          do
          {
            if (v34 - v52 > v35) {
              break;
            }
            unint64_t v55 = (unsigned __int8 *)(v19 + (v52 & v31));
            if (*v53 == *v55 && *(unsigned __int8 *)(v19 + v49 + 1) == *(unsigned __int8 *)((v52 & v31) + v19 + 1))
            {
              if (v47 < 8)
              {
                unint64_t v60 = 0LL;
                unint64_t v61 = (unsigned __int8 *)(v19 + v49);
LABEL_55:
                if ((v47 & 7) != 0)
                {
                  unint64_t v62 = v47 & 7 | v60;
                  unint64_t v63 = v47 & 7;
                  while (v55[v60] == *v61)
                  {
                    ++v61;
                    ++v60;
                    if (!--v63)
                    {
                      unint64_t v60 = v62;
                      break;
                    }
                  }
                }
              }

              else
              {
                uint64_t v56 = 0LL;
                unint64_t v57 = v47 >> 3;
                while (1)
                {
                  uint64_t v58 = *(void *)&v53[v56];
                  uint64_t v59 = *(void *)&v55[v56];
                  if (v58 != v59) {
                    break;
                  }
                  v56 += 8LL;
                  if (!--v57)
                  {
                    unint64_t v60 = v47 & 0xFFFFFFFFFFFFFFF8LL;
                    unint64_t v61 = (unsigned __int8 *)(v19 + v49 + (v47 & 0xFFFFFFFFFFFFFFF8LL));
                    goto LABEL_55;
                  }
                }

                unint64_t v60 = v56 + (__clz(__rbit64(v59 ^ v58)) >> 3);
              }

              if (v60 > v54)
              {
                *(_DWORD *)unint64_t v48 = v34 - v52;
                *((_DWORD *)v48 + 1) = 32 * v60;
                v48 += 8;
                unint64_t v54 = v60;
              }
            }

            if (--v52 <= v51) {
              break;
            }
          }

          while (v54 < 3);
        }

        if (v54 < v47)
        {
          uint64_t v64 = (506832829 * *(_DWORD *)(v19 + v49)) >> 15;
          uint64_t v65 = v225[9];
          uint64_t v67 = v225[6];
          uint64_t v66 = v225[7];
          uint64_t v68 = *(unsigned int *)(v66 + 4LL * v64);
          if (v47 >= 0x80) {
            unint64_t v69 = 128LL;
          }
          else {
            unint64_t v69 = v47;
          }
          if (v47 >= 0x80) {
            *(_DWORD *)(v66 + 4 * v64) = v34;
          }
          uint64_t v70 = 2 * (v67 & v34);
          uint64_t v71 = v70 | 1;
          if (v34 != v68)
          {
            unint64_t v119 = 0LL;
            unint64_t v120 = 0LL;
            uint64_t v121 = 64LL;
            do
            {
              if (v34 - v68 > v35 || v121 == 0) {
                break;
              }
              unint64_t v123 = v68 & v31;
              if (v120 >= v119) {
                unint64_t v124 = v119;
              }
              else {
                unint64_t v124 = v120;
              }
              uint64_t v125 = v19 + v124 + v49;
              uint64_t v126 = (unsigned __int8 *)(v19 + v123 + v124);
              unint64_t v127 = v47 - v124;
              if (v47 - v124 < 8)
              {
                unint64_t v130 = 0LL;
LABEL_166:
                uint64_t v135 = v127 & 7;
                if (v135)
                {
                  unint64_t v136 = v130 | v135;
                  while (*(unsigned __int8 *)(v125 + v130) == *v126)
                  {
                    ++v126;
                    ++v130;
                    if (!--v135)
                    {
                      unint64_t v130 = v136;
                      break;
                    }
                  }
                }
              }

              else
              {
                uint64_t v128 = 0LL;
                unint64_t v129 = v127 >> 3;
                unint64_t v130 = v127 & 0xFFFFFFFFFFFFFFF8LL;
                while (1)
                {
                  uint64_t v131 = *(void *)&v126[v128];
                  uint64_t v132 = *(void *)(v125 + v128);
                  if (v131 != v132) {
                    break;
                  }
                  v128 += 8LL;
                  if (!--v129)
                  {
                    v126 += v127 & 0xFFFFFFFFFFFFFFF8LL;
                    uint64_t v19 = v245;
                    goto LABEL_166;
                  }
                }

                unint64_t v130 = v128 + (__clz(__rbit64(v132 ^ v131)) >> 3);
                uint64_t v19 = v245;
              }

              unint64_t v133 = v130 + v124;
              if (v48 && v133 > v54)
              {
                *(_DWORD *)unint64_t v48 = v34 - v68;
                *((_DWORD *)v48 + 1) = 32 * v133;
                v48 += 8;
                unint64_t v54 = v133;
              }

              if (v133 >= v69)
              {
                if (v47 < 0x80) {
                  goto LABEL_71;
                }
                uint64_t v166 = (int *)(v65 + 8 * (v68 & v67));
                int v167 = *v166;
                unint64_t v72 = v166 + 1;
                *(_DWORD *)(v65 + 4 * v70) = v167;
                goto LABEL_70;
              }

              if (*(unsigned __int8 *)(v19 + v133 + v49) <= *(unsigned __int8 *)(v19 + v133 + v123))
              {
                if (v47 >= 0x80) {
                  *(_DWORD *)(v65 + 4 * v71) = v68;
                }
                uint64_t v71 = 2 * (v68 & v67);
                unint64_t v119 = v133;
                uint64_t v134 = v71;
              }

              else
              {
                if (v47 >= 0x80) {
                  *(_DWORD *)(v65 + 4 * v70) = v68;
                }
                uint64_t v70 = (2 * (v68 & v67)) | 1;
                unint64_t v120 = v133;
                uint64_t v134 = v70;
              }

              uint64_t v68 = *(unsigned int *)(v65 + 4 * v134);
              --v121;
            }

            while (v34 != v68);
          }

          if (v47 >= 0x80)
          {
            *(_DWORD *)(v65 + 4 * v70) = *v237;
            unint64_t v72 = v225 + 8;
LABEL_70:
            *(_DWORD *)(v65 + 4 * v71) = *v72;
          }
        }

LABEL_71:
        memset_pattern16(v256, &unk_181097440, 0x98uLL);
        if (v54 + 1 > 4) {
          unint64_t v73 = v54 + 1;
        }
        else {
          unint64_t v73 = 4LL;
        }
        if (BrotliFindAllStaticDictionaryMatches( (uint64_t *)(v241 + 88),  (unsigned __int8 *)(v19 + v49),  v73,  v47,  (uint64_t)v256))
        {
          if (v47 >= 0x25) {
            unint64_t v74 = 37LL;
          }
          else {
            unint64_t v74 = v47;
          }
          uint64_t v15 = v241;
          unint64_t v30 = v243;
          uint64_t v75 = v233;
          uint64_t v32 = v235;
          if (v73 <= v74)
          {
            unint64_t v76 = v74 + 1;
            int v77 = 32 * v73;
            unint64_t v31 = v242;
            do
            {
              unint64_t v78 = v256[v73];
              if (v78 <= 0xFFFFFFE)
              {
                unint64_t v79 = v223 + 1 + (v78 >> 5);
                if (v79 <= *(void *)(v241 + 80))
                {
                  uint64_t v80 = v78 & 0x1F;
                  if (v73 == v80) {
                    LODWORD(v80) = 0;
                  }
                  *(_DWORD *)unint64_t v48 = v79;
                  *((_DWORD *)v48 + 1) = v77 + v80;
                  v48 += 8;
                }
              }

              ++v73;
              v77 += 32;
            }

            while (v76 != v73);
          }

          else
          {
            unint64_t v31 = v242;
          }
        }

        else
        {
          uint64_t v15 = v241;
          unint64_t v31 = v242;
          unint64_t v30 = v243;
          uint64_t v75 = v233;
          uint64_t v32 = v235;
        }

        uint64_t v81 = (v48 - v229) >> 3;
        *(_DWORD *)(v239 + 4 * v75) = v81;
        if (v48 != v229)
        {
          uint64_t v82 = v81 + v32;
          uint64_t v83 = v81 + v32 - 1;
          unint64_t v84 = *(unsigned int *)&v30[8 * v83 + 4];
          if (v84 >> 6 < 0xA3)
          {
            uint64_t v32 = v82;
          }

          else
          {
            *(void *)&v30[8 * v32] = *(void *)&v30[8 * v83];
            *(_DWORD *)(v239 + 4 * v75) = 1;
            unint64_t v85 = v34 + 1;
            unint64_t v86 = v34 + (v84 >> 5);
            if (v86 >= v220) {
              unint64_t v86 = v220;
            }
            if (v34 + 64 > v86) {
              unint64_t v87 = v34 + 1;
            }
            else {
              unint64_t v87 = v86 - 63;
            }
            BOOL v88 = v34 + 513 > v87 || v85 >= v87;
            if (!v88)
            {
              uint64_t v137 = v225[6];
              uint64_t v138 = v225[7];
              uint64_t v139 = v225[9];
              while (1)
              {
                unint64_t v140 = v85 & v31;
                unsigned int v141 = (506832829 * *(_DWORD *)(v19 + (v85 & v31))) >> 15;
                uint64_t v142 = *(unsigned int *)(v138 + 4LL * v141);
                uint64_t v143 = 2 * (v137 & v85);
                uint64_t v144 = v143 | 1;
                *(_DWORD *)(v138 + 4LL * v141) = v85;
                if (v85 != v142) {
                  break;
                }
LABEL_172:
                int v145 = *v237;
                *(_DWORD *)(v139 + 4 * v143) = *v237;
LABEL_173:
                *(_DWORD *)(v139 + 4 * v144) = v145;
                v85 += 8LL;
                if (v85 >= v87) {
                  goto LABEL_100;
                }
              }

              unint64_t v146 = 0LL;
              unint64_t v147 = 0LL;
              uint64_t v148 = 64LL;
              while (2)
              {
                if (v85 - v142 > v137 - 15 || v148 == 0) {
                  goto LABEL_172;
                }
                unint64_t v150 = v142 & v31;
                if (v147 >= v146) {
                  unint64_t v151 = v146;
                }
                else {
                  unint64_t v151 = v147;
                }
                unint64_t v152 = v19 + v140 + v151;
                uint64_t v153 = (unsigned __int8 *)(v19 + v150 + v151);
                unint64_t v154 = 128 - v151;
                if (128 - v151 < 8)
                {
                  unint64_t v157 = 0LL;
LABEL_197:
                  uint64_t v163 = v154 & 7;
                  if (v163)
                  {
                    unint64_t v164 = v157 | v163;
                    while (*(unsigned __int8 *)(v152 + v157) == *v153)
                    {
                      ++v153;
                      ++v157;
                      if (!--v163)
                      {
                        unint64_t v157 = v164;
                        goto LABEL_189;
                      }
                    }

                    goto LABEL_189;
                  }
                }

                else
                {
                  uint64_t v155 = 0LL;
                  unint64_t v156 = v154 >> 3;
                  unint64_t v157 = v154 & 0xFFFFFFFFFFFFFFF8LL;
                  while (1)
                  {
                    uint64_t v158 = *(void *)&v153[v155];
                    uint64_t v159 = *(void *)(v152 + v155);
                    if (v158 != v159) {
                      break;
                    }
                    v155 += 8LL;
                    if (!--v156)
                    {
                      v153 += v154 & 0xFFFFFFFFFFFFFFF8LL;
                      uint64_t v19 = v245;
                      goto LABEL_197;
                    }
                  }

                  unint64_t v157 = v155 + (__clz(__rbit64(v159 ^ v158)) >> 3);
LABEL_189:
                  uint64_t v19 = v245;
                }

                unint64_t v160 = v157 + v151;
                if (v160 >= 0x80)
                {
                  unint64_t v165 = (_DWORD *)(v139 + 8 * (v142 & v137));
                  *(_DWORD *)(v139 + 4 * v143) = *v165;
                  int v145 = v165[1];
                  goto LABEL_173;
                }

                unsigned int v161 = *(unsigned __int8 *)(v19 + v160 + v150);
                uint64_t v162 = 2 * (v142 & v137);
                if (*(unsigned __int8 *)(v19 + v160 + v140) <= v161)
                {
                  *(_DWORD *)(v139 + 4 * v144) = v142;
                  unint64_t v146 = v160;
                  uint64_t v144 = 2 * (v142 & v137);
                }

                else
                {
                  *(_DWORD *)(v139 + 4 * v143) = v142;
                  uint64_t v143 = v162 | 1;
                  unint64_t v147 = v160;
                  v162 |= 1uLL;
                }

                uint64_t v142 = *(unsigned int *)(v139 + 4 * v162);
                --v148;
                if (v85 == v142) {
                  goto LABEL_172;
                }
                continue;
              }
            }

  unint64_t result = 0LL;
  uint64_t v33 = 12;
LABEL_72:
  *(_DWORD *)(a1 + 48) = v33;
  return result;
}

LABEL_100:
            if (v87 < v86)
            {
              uint64_t v89 = v225[6];
              uint64_t v90 = v225[7];
              uint64_t v91 = v225[9];
              while (1)
              {
                unint64_t v92 = v87 & v31;
                unsigned int v93 = (506832829 * *(_DWORD *)(v19 + (v87 & v31))) >> 15;
                uint64_t v94 = *(unsigned int *)(v90 + 4LL * v93);
                uint64_t v95 = 2 * (v89 & v87);
                uint64_t v96 = v95 | 1;
                *(_DWORD *)(v90 + 4LL * v93) = v87;
                if (v87 != v94) {
                  break;
                }
LABEL_103:
                int v97 = *v237;
                *(_DWORD *)(v91 + 4 * v95) = *v237;
LABEL_104:
                *(_DWORD *)(v91 + 4 * v96) = v97;
                if (++v87 >= v86) {
                  goto LABEL_135;
                }
              }

              unint64_t v98 = 0LL;
              unint64_t v99 = 0LL;
              uint64_t v100 = 64LL;
              while (2)
              {
                if (v87 - v94 > v89 - 15 || v100 == 0) {
                  goto LABEL_103;
                }
                unint64_t v102 = v94 & v31;
                if (v99 >= v98) {
                  unint64_t v103 = v98;
                }
                else {
                  unint64_t v103 = v99;
                }
                unint64_t v104 = v19 + v92 + v103;
                uint64_t v105 = (unsigned __int8 *)(v19 + v102 + v103);
                unint64_t v106 = 128 - v103;
                if (128 - v103 < 8)
                {
                  unint64_t v109 = 0LL;
LABEL_128:
                  uint64_t v115 = v106 & 7;
                  if (v115)
                  {
                    unint64_t v116 = v109 | v115;
                    while (*(unsigned __int8 *)(v104 + v109) == *v105)
                    {
                      ++v105;
                      ++v109;
                      if (!--v115)
                      {
                        unint64_t v109 = v116;
                        goto LABEL_120;
                      }
                    }

                    goto LABEL_120;
                  }
                }

                else
                {
                  uint64_t v107 = 0LL;
                  unint64_t v108 = v106 >> 3;
                  unint64_t v109 = v106 & 0xFFFFFFFFFFFFFFF8LL;
                  while (1)
                  {
                    uint64_t v110 = *(void *)&v105[v107];
                    uint64_t v111 = *(void *)(v104 + v107);
                    if (v110 != v111) {
                      break;
                    }
                    v107 += 8LL;
                    if (!--v108)
                    {
                      v105 += v106 & 0xFFFFFFFFFFFFFFF8LL;
                      uint64_t v19 = v245;
                      goto LABEL_128;
                    }
                  }

                  unint64_t v109 = v107 + (__clz(__rbit64(v111 ^ v110)) >> 3);
LABEL_120:
                  uint64_t v19 = v245;
                }

                unint64_t v112 = v109 + v103;
                if (v112 >= 0x80)
                {
                  unint64_t v117 = (_DWORD *)(v91 + 8 * (v94 & v89));
                  *(_DWORD *)(v91 + 4 * v95) = *v117;
                  int v97 = v117[1];
                  goto LABEL_104;
                }

                unsigned int v113 = *(unsigned __int8 *)(v19 + v112 + v102);
                uint64_t v114 = 2 * (v94 & v89);
                if (*(unsigned __int8 *)(v19 + v112 + v92) <= v113)
                {
                  *(_DWORD *)(v91 + 4 * v96) = v94;
                  unint64_t v98 = v112;
                  uint64_t v96 = 2 * (v94 & v89);
                }

                else
                {
                  *(_DWORD *)(v91 + 4 * v95) = v94;
                  uint64_t v95 = v114 | 1;
                  unint64_t v99 = v112;
                  v114 |= 1uLL;
                }

                uint64_t v94 = *(unsigned int *)(v91 + 4 * v114);
                --v100;
                if (v87 == v94) {
                  goto LABEL_103;
                }
                continue;
              }
            }

void SetCost(unsigned int *a1, uint64_t a2, int a3, float *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  unint64_t v8 = 0LL;
  if (!a2) {
    goto LABEL_5;
  }
  float v9 = a1;
  uint64_t v10 = a2;
  do
  {
    unsigned int v11 = *v9++;
    v8 += v11;
    --v10;
  }

  while (v10);
  if (v8 > 0xFF)
  {
    double v12 = log2((double)v8);
    if (a3) {
      goto LABEL_13;
    }
  }

  else
  {
LABEL_5:
    double v12 = kBrotliLog2Table[v8];
    if (a3) {
      goto LABEL_13;
    }
  }

  if (v6)
  {
    uint64_t v13 = v7;
    uint64_t v14 = v6;
    do
    {
      if (!*v13++) {
        ++v8;
      }
      --v14;
    }

    while (v14);
  }

uint64_t lzbitmap_encode_state_size(unsigned int a1)
{
  v2[17] = *MEMORY[0x1895F89C0];
  return lzbitmap_init_encode_state((uint64_t)v2, a1);
}

uint64_t lzbitmap_init_encode_state(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0LL;
  if (a2 <= 2 && a1)
  {
    unsigned int v3 = dword_1810974A0[a2];
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_DWORD *)(a1 + 80) = v3;
    *(_DWORD *)(a1 + 84) = a2;
    if (a2 >= 2) {
      int v4 = 18;
    }
    else {
      int v4 = 15;
    }
    int v5 = 2 << v4;
    *(_DWORD *)(a1 + 88) = v4;
    *(_DWORD *)(a1 + 92) = (2 << v4) + 16;
    unint64_t v6 = ((unint64_t)(v3 & 1) << 14) + 0x4000;
    *(_DWORD *)(a1 + 96) = v6;
    *(void *)(a1 + 100) = 0x30000000002LL;
    unint64_t v7 = v6 >> 2;
    *(_DWORD *)(a1 + 108) = ((v3 >> 2) | 0xFFFFFFFE) + 14;
    *(_DWORD *)(a1 + 112) = v6 >> 2;
    int v8 = (v6 >> 2) | 3;
    *(_DWORD *)(a1 + 116) = v8;
    unint64_t v9 = (a1 + 199) & 0xFFFFFFFFFFFFFFC0LL;
    unint64_t v10 = (v9 + (v5 + 79)) & 0xFFFFFFFFFFFFFFC0LL;
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = v10;
    unint64_t v11 = (v10 + (v6 >> 2) + 66) & 0xFFFFFFFFFFFFFFC0LL;
    unint64_t v12 = (v11 + (v7 | 0x3F)) & 0xFFFFFFFFFFFFFFC0LL;
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v12;
    *(void *)(a1 + 32) = (v12 + 3135) & 0xFFFFFFFFFFFFFFC0LL;
    return (v5 + v7 + v8 + 5080);
  }

  return v2;
}

uint64_t lzbitmap_encode(int *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  uint64_t result = lzbitmap_init_encode_state(a5, a6);
  if ((_DWORD)result)
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a5 + 56) = a4;
    *(void *)(a5 + 40) = a3;
    *(void *)(a5 + 48) = (char *)a1 + a2 - 31;
    if (a1)
    {
      if (a2 >= 0x23)
      {
        uint64_t v12 = (uint64_t)(a1 + 1);
        *a1 = (*(_DWORD *)(a5 + 80) << 24) | 0x4D425A;
        uint64_t v13 = *(char **)a5;
        unint64_t v14 = *(unsigned int *)(a5 + 92);
        *(void *)&__int128 v15 = 0x8000800080008LL;
        *((void *)&v15 + 1) = 0x8000800080008LL;
        __int128 v21 = v15;
        if (v14 >= 0x10)
        {
          int v17 = 31;
          if (v14 > 0x1F) {
            int v17 = v14;
          }
          size_t v16 = v17 & 0xFFFFFFF0;
          memset_pattern16(v13, asc_181096BE0, v16);
        }

        else
        {
          size_t v16 = 0LL;
        }

        memcpy(&v13[v16], &v21, v14 - v16);
        if (a4)
        {
          unsigned int v18 = 0;
          unsigned int v19 = *(_DWORD *)(a5 + 96);
          while (1)
          {
            size_t v20 = a4 - v18 >= v19 ? v19 : a4 - v18;
            uint64_t result = (uint64_t)lzbitmap_process_block((uint64_t *)a5, v12, v18, v20);
            if (!result) {
              break;
            }
            uint64_t v12 = result;
            unsigned int v19 = *(_DWORD *)(a5 + 96);
            v18 += v19;
            if (v18 >= a4) {
              goto LABEL_16;
            }
          }
        }

        else
        {
LABEL_16:
          if ((unint64_t)(v12 + 6) <= *(void *)(a5 + 48))
          {
            *(_DWORD *)uint64_t v12 = 6;
            *(_WORD *)(v12 + 4) = 0;
            return (v12 + 6 - (_DWORD)a1);
          }

          else
          {
            return 0LL;
          }
        }
      }
    }
  }

  return result;
}

char *lzbitmap_process_block(uint64_t *a1, uint64_t a2, unsigned int a3, size_t __n)
{
  int v4 = 0LL;
  uint64_t v312 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v5 = a2;
    unint64_t v6 = a1;
    unint64_t v7 = a1[6];
    int v8 = (char *)(a2 + 6);
    if (a2 + 6 <= v7)
    {
      unsigned int v9 = a3;
      if (__n >= 0x91)
      {
        int v294 = (void *)(a2 + 15);
        if (a2 + 15 <= v7)
        {
          unint64_t v10 = *((unsigned int *)a1 + 26);
          if ((_DWORD)v10)
          {
            unint64_t v11 = 0LL;
            uint64_t v12 = (int32x4_t *)a1[3];
            int32x4_t v13 = (int32x4_t)xmmword_181097460;
            int32x4_t v14 = (int32x4_t)xmmword_181097470;
            v15.i64[0] = 0x800000008LL;
            v15.i64[1] = 0x800000008LL;
            do
            {
              *uint64_t v12 = v14;
              v12[1] = v13;
              v12 += 2;
              v11 += 8LL;
              int32x4_t v14 = vaddq_s32(v14, v15);
              int32x4_t v13 = vaddq_s32(v13, v15);
            }

            while (v11 < v10);
          }

          int v16 = *((_DWORD *)a1 + 21);
          int v278 = (char *)(a2 + 6);
          switch(v16)
          {
            case 2:
              uint64_t v33 = (void *)a1[5];
              unsigned __int16 v285 = (_DWORD *)a1[3];
              int v287 = (_WORD *)a1[2];
              int v275 = __n;
              else {
                unsigned int v34 = __n + a3;
              }
              unsigned int v277 = v34;
              uint64_t v274 = a2;
              if (a3 + 128 > v34)
              {
                unsigned __int16 v35 = 0;
                unsigned int v22 = 0;
                LOWORD(v36) = 8;
                unsigned int v37 = a3;
LABEL_107:
                LODWORD(__n) = v275;
                unsigned int v204 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v22 + v204 - v37 <= v6[6])
                {
                  if (v204 <= v37)
                  {
                    uint64_t v94 = v22;
                    uint64_t v5 = v274;
                  }

                  else
                  {
                    int v206 = -(unsigned __int16)v36;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v207 = 0;
                      unsigned __int8 v208 = 0;
                      uint64_t v209 = (v37 - v9) >> 3;
                      v287[v209] = 0;
                      do
                      {
                        if (v37 < *((_DWORD *)v6 + 14))
                        {
                          int v210 = *((unsigned __int8 *)v33 + v37);
                          if (v210 != *((unsigned __int8 *)v33 + v206 + v37))
                          {
                            *((_BYTE *)v294 + v22) = v210;
                            unsigned __int16 v207 = v287[v209] | (1 << v208);
                            v287[v209] = v207;
                            ++v22;
                          }
                        }

                        unsigned int v211 = v208;
                        ++v37;
                        ++v208;
                      }

                      while (v211 < 7);
                      v285[v207] += 0x10000;
                    }

                    while (v37 < v204);
                    uint64_t v94 = v22;
                  }

                  int v212 = v35;
                  goto LABEL_126;
                }

                goto LABEL_108;
              }

              unsigned int v22 = 0;
              unsigned __int16 v35 = 0;
              uint64_t v280 = a1[1];
              uint64_t v276 = a2 + 143;
              uint64_t v36 = 8LL;
              int32x4_t v148 = vdupq_n_s32(0x9E3779B1);
              unsigned int v37 = a3;
              unsigned int v283 = (void *)a1[5];
              while (v276 + (unint64_t)v22 <= v6[6])
              {
                unint64_t v149 = 0LL;
                uint64_t v150 = v37;
                int32x4_t v151 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v152 = *(int64x2_t *)((char *)v33 + v150);
                  v316.val[1] = *(int8x16_t *)((char *)v33 + v150 + 16);
                  uint32x4_t v153 = (uint32x4_t)vnegq_s32(v151);
                  unint64_t v154 = (uint32x4_t *)&v311[2 * v149];
                  *unint64_t v154 = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v152, (int8x16_t)xmmword_181096BA0),  v148),  v153);
                  v154[1] = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v152, (int8x16_t)xmmword_181096BB0),  v148),  v153);
                  v316.val[0] = (int8x16_t)vdupq_laneq_s64(v152, 1);
                  v154[2] = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8(v316.val[0], (int8x16_t)xmmword_181096BA0),  v148),  v153);
                  v154[3] = vshlq_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(v316, (int8x16_t)xmmword_181097480), v148),  v153);
                  v150 += 16LL;
                  BOOL v47 = v149 >= 0xE;
                  v149 += 2LL;
                }

                while (!v47);
                if (!v37)
                {
                  _WORD *v287 = 255;
                  v285[255] += 0x10000;
                  *int v294 = *v33;
                  unsigned int v22 = 8;
                  unsigned int v37 = 8;
                }

                for (uint64_t i = v37 == 8; i != 16; ++i)
                {
                  unsigned int v156 = v37;
                  unint64_t v157 = (int8x16_t *)((char *)v33 + v37);
                  int8x16_t v158 = *v157;
                  uint64x2_t v159 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v157 - v36),  *v157)))));
                  if (v159.i8[0])
                  {
                    uint64_t v160 = 0LL;
                    LOWORD(v161) = 0;
                    __int16 v162 = v159.i16[0] | (v159.i16[4] << 8);
                    v159.i32[0] = v159.u8[0];
                    int8x8_t v163 = vcnt_s8(*(int8x8_t *)v159.i8);
                    v163.i16[0] = vaddlv_u8((uint8x8_t)v163);
                    __int32 v164 = v163.i32[0];
                    v163.i32[0] = HIBYTE(v162);
                    uint8x8_t v165 = (uint8x8_t)vcnt_s8(v163);
                    v165.i16[0] = vaddlv_u8(v165);
                    __int32 v166 = v165.i32[0] + 4 * v164;
                    uint64_t v167 = *v6;
                    unint64_t v168 = (unsigned int *)&v311[2 * i];
                    uint64_t v169 = v168[1];
                    uint64_t v170 = 2LL * *v168;
                    int v171 = *(_DWORD *)(*v6 + v170);
                    __int16 v295 = v37 - v171;
                    __int16 v303 = v37 - HIWORD(v171);
                    uint64_t v172 = v168[5];
                    uint64_t v173 = 2LL * v168[4];
                    int v174 = *(_DWORD *)(v167 + v173);
                    __int16 v296 = v37 + 4 - v174;
                    __int16 v304 = v37 + 4 - HIWORD(v174);
                    uint64_t v175 = v168[3];
                    uint64_t v176 = 2LL * v168[2];
                    int v177 = *(_DWORD *)(v167 + v176);
                    __int16 v297 = v37 + 2 - v177;
                    __int16 v305 = v37 + 2 - HIWORD(v177);
                    uint64_t v178 = 2 * v175;
                    LODWORD(v175) = *(_DWORD *)(v167 + 2 * v175);
                    __int16 v298 = v37 + 3 - v175;
                    __int16 v179 = v37 + 3 - WORD1(v175);
                    v169 *= 2LL;
                    LODWORD(v175) = *(_DWORD *)(v167 + v169);
                    __int16 v306 = v179;
                    __int16 v299 = v37 + 1 - v175;
                    __int16 v307 = v37 + 1 - WORD1(v175);
                    uint64_t v180 = 2 * v172;
                    LODWORD(v172) = *(_DWORD *)(v167 + 2 * v172);
                    __int16 v300 = v37 + 5 - v172;
                    __int16 v181 = v37 + 5 - WORD1(v172);
                    uint64_t v183 = v168[6];
                    uint64_t v182 = v168[7];
                    v183 *= 2LL;
                    unsigned int v184 = v22;
                    int v185 = *(_DWORD *)(v167 + v183);
                    __int16 v308 = v181;
                    __int16 v301 = v37 + 6 - v185;
                    unsigned int v186 = v166 + 4;
                    __int16 v187 = v37 + 6 - HIWORD(v185);
                    uint64_t v188 = 2 * v182;
                    LODWORD(v182) = *(_DWORD *)(v167 + 2 * v182);
                    *(_DWORD *)(v167 + v169) = (unsigned __int16)(v37 + 1) | ((unsigned __int16)v175 << 16);
                    __int16 v309 = v187;
                    *(_DWORD *)(v167 + v176) = (unsigned __int16)(v37 + 2) | ((unsigned __int16)*(_DWORD *)(v167 + v176) << 16);
                    *(_DWORD *)(v167 + v178) = (unsigned __int16)(v37 + 3) | ((unsigned __int16)*(_DWORD *)(v167 + v178) << 16);
                    *(_DWORD *)(v167 + v180) = (unsigned __int16)(v37 + 5) | ((unsigned __int16)*(_DWORD *)(v167 + v180) << 16);
                    __int16 v302 = v37 + 7 - v182;
                    *(_DWORD *)(v167 + v183) = (unsigned __int16)(v37 + 6) | ((unsigned __int16)*(_DWORD *)(v167 + v183) << 16);
                    *(_DWORD *)(v167 + v188) = (unsigned __int16)(v37 + 7) | ((unsigned __int16)*(_DWORD *)(v167 + v188) << 16);
                    __int16 v310 = v37 + 7 - WORD1(v182);
                    *(_DWORD *)(v167 + v173) = (unsigned __int16)(v37 + 4) | ((unsigned __int16)*(_DWORD *)(v167 + v173) << 16);
                    *(_DWORD *)(v167 + v170) = (unsigned __int16)v37 | ((unsigned __int16)*(_DWORD *)(v167 + v170) << 16);
                    do
                    {
                      uint64_t v189 = *(unsigned __int16 *)((char *)&v295 + v160);
                      int32x2_t v190 = vmovn_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v157 - v189),  v158))))));
                      int8x8_t v191 = vorr_s8((int8x8_t)vdup_lane_s32(vshl_n_s32(v190, 8uLL), 1), (int8x8_t)v190);
                      __int32 v192 = v191.i32[0] | (((int)v189 - 8) >> 24);
                      v191.i32[0] = v191.i8[0] | ((v189 - 8) >> 24);
                      int8x8_t v193 = vcnt_s8(v191);
                      v193.i16[0] = vaddlv_u8((uint8x8_t)v193);
                      unsigned __int32 v194 = v193.i32[0] + ((v189 + 130816) >> 16);
                      v193.i32[0] = BYTE1(v192);
                      uint8x8_t v195 = (uint8x8_t)vcnt_s8(v193);
                      v195.i16[0] = vaddlv_u8(v195);
                      if (v195.i32[0] + 4 * (v162 != 0) + 4 * v194 < v186)
                      {
                        unsigned int v161 = (v189 + 130816) >> 16;
                        unsigned int v186 = (v195.i8[0] + 4 * (v162 != 0) + 4 * v194);
                        __int16 v162 = v192;
                        uint64_t v36 = *(unsigned __int16 *)((char *)&v295 + v160);
                      }

                      v160 += 2LL;
                    }

                    while (v160 != 32);
                    *(_WORD *)(v280 + v35) = v36;
                    v35 += v161;
                    v158.i64[1] = 0LL;
                    int8x8_t v196 = vqtbl1_s8(v158, lzbitmap_pack_perm_table[v162]);
                    *(int8x8_t *)((char *)v294 + v184) = v196;
                    v287[(v37 - v9) >> 3] = v162 | (unsigned __int16)((_WORD)v161 << 8);
                    uint64_t v33 = v283;
                    v285[(unsigned __int16)(v162 | (unsigned __int16)((_WORD)v161 << 8))] += 0x10000;
                    v196.i32[0] = v162;
                    uint8x8_t v197 = (uint8x8_t)vcnt_s8(v196);
                    v197.i16[0] = vaddlv_u8(v197);
                    unsigned int v22 = v184 + v197.i32[0];
                    unsigned int v9 = a3;
                    unint64_t v6 = a1;
                  }

                  else
                  {
                    uint64_t v198 = *v6;
                    float v199 = (unsigned int *)&v311[2 * i];
                    uint64_t v200 = *v199;
                    *(_DWORD *)(v198 + 2LL * v199[1]) = (unsigned __int16)(v37 + 1) | ((unsigned __int16)*(_DWORD *)(*v6 + 2LL * v199[1]) << 16);
                    uint64_t v201 = v199[3];
                    *(_DWORD *)(v198 + 2LL * v199[2]) = (unsigned __int16)(v37 + 2) | ((unsigned __int16)*(_DWORD *)(v198 + 2LL * v199[2]) << 16);
                    *(_DWORD *)(v198 + 2 * v201) = (unsigned __int16)(v37 + 3) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v201) << 16);
                    uint64_t v202 = v199[4];
                    *(_DWORD *)(v198 + 2LL * v199[5]) = (unsigned __int16)(v37 + 5) | ((unsigned __int16)*(_DWORD *)(v198 + 2LL * v199[5]) << 16);
                    uint64_t v203 = v199[7];
                    *(_DWORD *)(v198 + 2LL * v199[6]) = (unsigned __int16)(v37 + 6) | ((unsigned __int16)*(_DWORD *)(v198 + 2LL * v199[6]) << 16);
                    *(_DWORD *)(v198 + 2 * v203) = (unsigned __int16)(v37 + 7) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v203) << 16);
                    *(_DWORD *)(v198 + 2 * v202) = (unsigned __int16)(v37 + 4) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v202) << 16);
                    *(_DWORD *)(v198 + 2 * v200) = (unsigned __int16)v37 | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v200) << 16);
                    v287[(v37 - v9) >> 3] = 0;
                    *v285 += 0x10000;
                  }

                  v37 += 8;
                }

                if (v156 + 136 > v277) {
                  goto LABEL_107;
                }
              }

              goto LABEL_109;
            case 1:
              uint64_t v25 = (void *)a1[5];
              unint64_t v26 = (_WORD *)a1[2];
              unint64_t v27 = (_DWORD *)a1[3];
              int v275 = __n;
              else {
                unsigned int v28 = __n + a3;
              }
              unsigned int v281 = v28;
              uint64_t v274 = a2;
              if (a3 + 128 > v28)
              {
                LOWORD(v29) = 0;
                LODWORD(v30) = 0;
                LOWORD(v31) = 8;
                unsigned int v32 = v9;
LABEL_48:
                LODWORD(__n) = v275;
                unsigned int v87 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v30 + v87 - v32 <= v6[6])
                {
                  if (v87 <= v32)
                  {
                    uint64_t v94 = v30;
                    uint64_t v5 = v274;
                  }

                  else
                  {
                    int v88 = -(unsigned __int16)v31;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v89 = 0;
                      unsigned __int8 v90 = 0;
                      uint64_t v91 = (v32 - v9) >> 3;
                      v26[v91] = 0;
                      do
                      {
                        if (v32 < *((_DWORD *)v6 + 14))
                        {
                          int v92 = *((unsigned __int8 *)v25 + v32);
                          if (v92 != *((unsigned __int8 *)v25 + v88 + v32))
                          {
                            *((_BYTE *)v294 + v30) = v92;
                            unsigned __int16 v89 = v26[v91] | (1 << v90);
                            v26[v91] = v89;
                            LODWORD(v30) = v30 + 1;
                          }
                        }

                        unsigned int v93 = v90;
                        ++v32;
                        ++v90;
                      }

                      while (v93 < 7);
                      v27[v89] += 0x10000;
                    }

                    while (v32 < v87);
                    uint64_t v94 = v30;
                  }

                  int v212 = (unsigned __int16)v29;
                  *((_DWORD *)v6 + 30) = v30;
                  goto LABEL_127;
                }

LABEL_108:
                uint64_t v205 = 0LL;
LABEL_110:
                uint64_t v5 = v274;
                goto LABEL_128;
              }

              uint64_t v30 = 0LL;
              int v29 = 0;
              uint64_t v286 = a1[1];
              uint64_t v279 = a2 + 143;
              uint64_t v31 = 8LL;
              int32x4_t v38 = vdupq_n_s32(0x9E3779B1);
              unsigned int v32 = v9;
              int v288 = (void *)a1[5];
              while (v279 + (unint64_t)v30 <= v6[6])
              {
                unint64_t v39 = 0LL;
                uint64_t v40 = v32;
                int32x4_t v41 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v42 = *(int64x2_t *)((char *)v25 + v40);
                  v314.val[1] = *(int8x16_t *)((char *)v25 + v40 + 16);
                  uint32x4_t v43 = (uint32x4_t)vnegq_s32(v41);
                  unint64_t v44 = &v311[2 * v39];
                  _OWORD *v44 = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v42, (int8x16_t)xmmword_181096BA0),  v38),  v43);
                  v44[1] = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v42, (int8x16_t)xmmword_181096BB0),  v38),  v43);
                  v314.val[0] = (int8x16_t)vdupq_laneq_s64(v42, 1);
                  int32x4_t v45 = (int32x4_t)vqtbl2q_s8(v314, (int8x16_t)xmmword_181097480);
                  uint32x4_t v46 = vshlq_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v314.val[0], (int8x16_t)xmmword_181096BA0), v38),  v43);
                  v44[2] = v46;
                  v44[3] = vshlq_u32((uint32x4_t)vmulq_s32(v45, v38), v43);
                  v40 += 16LL;
                  BOOL v47 = v39 >= 0xE;
                  v39 += 2LL;
                }

                while (!v47);
                if (!v32)
                {
                  *unint64_t v26 = 255;
                  v27[255] += 0x10000;
                  *int v294 = *v25;
                  uint64_t v30 = 8LL;
                  unsigned int v32 = 8;
                }

                for (uint64_t j = v32 == 8; j != 16; ++j)
                {
                  unsigned int v49 = v32;
                  unint64_t v50 = (int8x16_t *)((char *)v25 + v32);
                  int8x16_t v51 = *v50;
                  uint64x2_t v52 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v50 - v31),  *v50)))));
                  unsigned int v53 = (v32 - v9) >> 3;
                  if (v52.i8[0])
                  {
                    v46.i32[0] = v52.u8[0];
                    *(int8x8_t *)v46.i8 = vcnt_s8(*(int8x8_t *)v46.i8);
                    v46.i16[0] = vaddlv_u8(*(uint8x8_t *)v46.i8);
                    uint64_t v54 = v52.u8[0];
                    if (v46.i32[0] == 1)
                    {
                      LOWORD(v55) = 0;
LABEL_44:
                      v51.i64[1] = 0LL;
                      int8x8_t v85 = vqtbl1_s8(v51, lzbitmap_pack_perm_table[v54]);
                      *(int8x8_t *)((char *)v294 + v30) = v85;
                      v85.i32[0] = v54;
                      v26[v53] = v54 | (unsigned __int16)((_WORD)v55 << 8);
                      v27[v54 | ((unsigned __int16)v55 << 8)] += 0x10000;
                      uint8x8_t v86 = (uint8x8_t)vcnt_s8(v85);
                      v86.i16[0] = vaddlv_u8(v86);
                      uint64_t v30 = (v86.i32[0] + v30);
                    }

                    else
                    {
                      unsigned int v290 = (v32 - v9) >> 3;
                      uint64_t v56 = 0LL;
                      unsigned int v55 = 0;
                      v52.i32[0] = ((unsigned __int16)(v52.i16[0] | (v52.i16[4] << 8)) >> 8);
                      uint64_t v57 = *v6;
                      uint64_t v58 = (unsigned int *)&v311[2 * j];
                      uint64_t v59 = *v58;
                      uint64_t v60 = v58[1];
                      __int16 v295 = v32 - *(_WORD *)(*v6 + 2 * v59);
                      uint64_t v61 = v58[4];
                      uint64_t v62 = v58[5];
                      uint64_t v64 = v58[2];
                      uint64_t v63 = v58[3];
                      __int16 v65 = *(_WORD *)(v57 + 2 * v64);
                      __int16 v296 = v32 + 4 - *(_WORD *)(v57 + 2 * v61);
                      __int16 v297 = v32 + 2 - v65;
                      __int16 v298 = v32 + 3 - *(_WORD *)(v57 + 2 * v63);
                      __int16 v66 = *(_WORD *)(v57 + 2 * v60);
                      uint64_t v67 = v30;
                      __int16 v68 = *(_WORD *)(v57 + 2 * v62);
                      unint64_t v69 = v27;
                      uint64_t v70 = v58[6];
                      uint64_t v71 = v58[7];
                      __int16 v72 = *(_WORD *)(v57 + 2 * v70);
                      int v73 = v29;
                      __int16 v74 = *(_WORD *)(v57 + 2 * v71);
                      *(_WORD *)(v57 + 2 * v60) = v49 + 1;
                      __int16 v75 = v49 + 1 - v66;
                      unsigned int v76 = (vaddlv_u8((uint8x8_t)vcnt_s8(*(int8x8_t *)v52.i8)) + 4 * v46.i8[0]);
                      __int16 v299 = v75;
                      __int16 v300 = v49 + 5 - v68;
                      __int16 v301 = v49 + 6 - v72;
                      *(_WORD *)(v57 + 2 * v64) = v49 + 2;
                      *(_WORD *)(v57 + 2 * v63) = v49 + 3;
                      *(_WORD *)(v57 + 2 * v62) = v49 + 5;
                      *(_WORD *)(v57 + 2 * v70) = v49 + 6;
                      uint64_t v30 = v67;
                      unint64_t v27 = v69;
                      *(_WORD *)(v57 + 2 * v71) = v49 + 7;
                      __int16 v302 = v49 + 7 - v74;
                      *(_WORD *)(v57 + 2 * v61) = v49 + 4;
                      *(_WORD *)(v57 + 2 * v59) = v49;
                      while (1)
                      {
                        uint64_t v77 = *(unsigned __int16 *)((char *)&v295 + v56);
                        uint64x2_t v78 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v50 - v77),  v51)))));
                        int v79 = (unsigned __int16)(v78.i16[0] | (v78.i16[4] << 8));
                        int v80 = v79 | (((int)v77 - 8) >> 24);
                        unsigned int v81 = (v77 + 130816) >> 16;
                        unsigned int v82 = (unsigned __int16)(v79 | (((int)v77 - 8) >> 24));
                        v78.i32[0] = v78.i8[0] | ((v77 - 8) >> 24);
                        int8x8_t v83 = vcnt_s8(*(int8x8_t *)v78.i8);
                        v83.i16[0] = vaddlv_u8((uint8x8_t)v83);
                        unsigned __int32 v84 = v83.i32[0] + v81;
                        v83.i32[0] = v82 >> 8;
                        *(int8x8_t *)v78.i8 = vcnt_s8(v83);
                        v78.i16[0] = vaddlv_u8(*(uint8x8_t *)v78.i8);
                        if (v78.i32[0] + 4 * v84 < v76)
                        {
                          unsigned int v76 = (v78.i8[0] + 4 * v84);
                          uint64_t v54 = v80;
                          unsigned int v55 = (v77 + 130816) >> 16;
                          uint64_t v31 = *(unsigned __int16 *)((char *)&v295 + v56);
                        }

                        v56 += 2LL;
                        if (v56 == 16)
                        {
                          *(_WORD *)(v286 + (unsigned __int16)v73) = v31;
                          int v29 = v73 + v55;
                          unsigned int v9 = a3;
                          unint64_t v6 = a1;
                          uint64_t v25 = v288;
                          unsigned int v53 = v290;
                          goto LABEL_44;
                        }
                      }

                      v26[v290] = (_WORD)v81 << 8;
                      v69[256 * v81] += 0x10000;
                      *(_WORD *)(v286 + (unsigned __int16)v73) = v77;
                      int v29 = v73 + ((v77 + 130816) >> 16);
                      uint64_t v31 = v77;
                      unsigned int v9 = a3;
                      unint64_t v6 = a1;
                      uint64_t v25 = v288;
                    }
                  }

                  else
                  {
                    v26[v53] = 0;
                    *v27 += 0x10000;
                  }

                  unsigned int v32 = v49 + 8;
                }

                if (v49 + 136 > v281) {
                  goto LABEL_48;
                }
              }

LABEL_109:
              uint64_t v205 = 0LL;
              LODWORD(__n) = v275;
              goto LABEL_110;
            case 0:
              int v17 = (void *)a1[5];
              unsigned int v19 = (_WORD *)a1[2];
              unsigned int v18 = (_DWORD *)a1[3];
              int v275 = __n;
              else {
                unsigned int v20 = __n + a3;
              }
              unsigned int v284 = v20;
              uint64_t v274 = a2;
              if (a3 + 128 > v20)
              {
                LOWORD(v21) = 0;
                unsigned int v22 = 0;
                LOWORD(v23) = 8;
                unsigned int v24 = v9;
LABEL_80:
                LODWORD(__n) = v275;
                unsigned int v141 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v22 + v141 - v24 <= v6[6])
                {
                  if (v141 <= v24)
                  {
                    uint64_t v94 = v22;
                    uint64_t v5 = v274;
                  }

                  else
                  {
                    int v142 = -(unsigned __int16)v23;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v143 = 0;
                      unsigned __int8 v144 = 0;
                      uint64_t v145 = (v24 - v9) >> 3;
                      v19[v145] = 0;
                      do
                      {
                        if (v24 < *((_DWORD *)v6 + 14))
                        {
                          int v146 = *((unsigned __int8 *)v17 + v24);
                          if (v146 != *((unsigned __int8 *)v17 + v142 + v24))
                          {
                            *((_BYTE *)v294 + v22++) = v146;
                            unsigned __int16 v143 = v19[v145] | (1 << v144);
                            v19[v145] = v143;
                          }
                        }

                        unsigned int v147 = v144;
                        ++v24;
                        ++v144;
                      }

                      while (v147 < 7);
                      v18[v143] += 0x10000;
                    }

                    while (v24 < v141);
                    uint64_t v94 = v22;
                  }

                  int v212 = (unsigned __int16)v21;
LABEL_126:
                  *((_DWORD *)v6 + 30) = v22;
LABEL_127:
                  *((_DWORD *)v6 + 31) = v212;
                  uint64_t v205 = (char *)v294 + v94;
LABEL_128:
                  int v8 = v278;
                  if (v205)
                  {
                    size_t v213 = *((unsigned int *)v6 + 31);
                    unint64_t v214 = &v205[v213];
                    if ((unint64_t)&v205[v213] <= v6[6])
                    {
                      uint64_t v215 = v5;
                      int v216 = __n;
                      memcpy(v205, (const void *)v6[1], v213);
                      LODWORD(__n) = v216;
                      unsigned int v217 = 0;
                      unsigned int v218 = 0;
                      do
                      {
                        unint64_t v219 = 0LL;
                        uint64_t v220 = v6[4];
                        int32x4_t v221 = vdupq_n_s32(65537 * v218 + 16777472);
                        do
                        {
                          *(int32x4_t *)(v220 + 2LL * v217 + v219) = v221;
                          v219 += 16LL;
                        }

                        while (v219 < 0x1F1);
                        ++v218;
                        v217 += 256;
                      }

                      while (v218 <= *((_DWORD *)v6 + 25));
                      unsigned int v222 = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                      uint64_t v223 = v6[3];
                      uint64_t v225 = *((unsigned int *)v6 + 26);
                      unsigned int v224 = *((_DWORD *)v6 + 27);
                      unsigned int v226 = 0;
                      if (!(_DWORD)v225) {
                        goto LABEL_158;
                      }
                      uint64_t v227 = v6[3];
                      do
                      {
                        *(_DWORD *)(v223 + 4LL * v226) = *(_DWORD *)v227;
                        if (*(_WORD *)(v227 + 2)) {
                          ++v226;
                        }
                        v227 += 4LL;
                        --v225;
                      }

                      while (v225);
                      if (v226 > v224)
                      {
                        unsigned int v228 = 0;
                        uint64_t v5 = v215;
                        do
                        {
                          uint64_t v229 = v228;
                          unsigned int v230 = *(_DWORD *)(v223 + 4LL * v228);
                          uint64_t v231 = v226 - 1;
                          unsigned int v232 = *(_DWORD *)(v223 + 4LL * v231);
                          if (v230 > v232)
                          {
                            *(_DWORD *)(v223 + 4LL * v228) = v232;
                            *(_DWORD *)(v223 + 4 * v231) = v230;
                            unsigned int v232 = v230;
                          }

                          uint64_t v233 = (v228 + v226) >> 1;
                          unsigned int v234 = *(_DWORD *)(v223 + 4LL * v233);
                          if (v234 > v232)
                          {
                            *(_DWORD *)(v223 + 4 * v233) = v232;
                            *(_DWORD *)(v223 + 4 * v231) = v234;
                            unsigned int v234 = *(_DWORD *)(v223 + 4 * v233);
                          }

                          unsigned int v235 = *(_DWORD *)(v223 + 4LL * v228);
                          if (v234 > v235)
                          {
                            *(_DWORD *)(v223 + 4 * v229) = v234;
                            *(_DWORD *)(v223 + 4 * v233) = v235;
                            unsigned int v235 = *(_DWORD *)(v223 + 4 * v229);
                          }

                          LODWORD(v236) = v229 - 1;
                          unsigned int v237 = v226;
                          while (1)
                          {
                            do
                            {
                              uint64_t v236 = (v236 + 1);
                              unsigned int v238 = *(_DWORD *)(v223 + 4LL * v236);
                            }

                            while (v238 > v235);
                            unsigned int v239 = v237 + 1;
                            do
                            {
                              uint64_t v240 = v239 - 2;
                              unsigned int v241 = *(_DWORD *)(v223 + 4LL * v240);
                              --v239;
                            }

                            while (v241 < v235);
                            unsigned int v237 = v239 - 1;
                            *(_DWORD *)(v223 + 4 * v240) = v238;
                            *(_DWORD *)(v223 + 4 * v236) = v241;
                          }

                          if (v239 < v224)
                          {
                            unsigned int v228 = v239;
                          }

                          else
                          {
                            unsigned int v226 = v239;
                            unsigned int v228 = v229;
                          }
                        }

                        while (v224 != v239);
                      }

                      else
                      {
LABEL_158:
                        bzero((void *)(v223 + 4LL * v226), 4LL * (v224 - v226));
                        LODWORD(__n) = v216;
                        uint64_t v5 = v215;
                      }

                      *(uint64_t *)((char *)v6 + 60) = 0LL;
                      unint64_t v242 = (__int128 *)((char *)v6 + 60);
                      *(uint64_t *)((char *)v6 + 68) = 0LL;
                      *((_DWORD *)v6 + 19) = 0;
                      LODWORD(v243) = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                      int v8 = v278;
                      if (*((_DWORD *)v6 + 27))
                      {
                        unsigned int v244 = 0;
                        unint64_t v245 = 0LL;
                        uint64_t v246 = v6[3];
                        LODWORD(v243) = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                        do
                        {
                          if (*(_DWORD *)(v246 + 4 * v245) < 0x10000u) {
                            break;
                          }
                          uint64_t v247 = (unsigned __int16)*(_DWORD *)(v246 + 4 * v245);
                          *(_DWORD *)((char *)v242 + ((v244 >> 3) & 0x1FFFFFFE)) |= (_DWORD)v247 << (v244 & 0xE);
                          *(_WORD *)(v6[4] + 2 * v247) = v245 + *((_DWORD *)v6 + 25) + 1;
                          int v8 = v278;
                          LODWORD(v243) = v243 - *(unsigned __int16 *)(v246 + 4 * v245++ + 2);
                          v244 += 10;
                        }

                        while (v245 < *((unsigned int *)v6 + 27));
                      }

                      *((_DWORD *)v6 + 32) = v243;
                      unint64_t v248 = v6[6];
                      if ((unint64_t)&v214[v243] <= v248)
                      {
                        if (v222)
                        {
                          int v249 = 0;
                          uint64_t v250 = v6[4];
                          uint64_t v251 = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                          __int128 v253 = (_BYTE *)v6[1];
                          uint64_t v252 = (char *)v6[2];
                          do
                          {
                            unsigned int v254 = *(unsigned __int16 *)(v250 + 2LL * *(unsigned __int16 *)v252);
                            *v253++ = v254;
                            char v255 = *v252;
                            v252 += 2;
                            v214[v249] = v255;
                            v249 += v254 >> 8;
                            --v251;
                          }

                          while (v251);
                          uint64_t v243 = *((unsigned int *)v6 + 32);
                          unint64_t v248 = v6[6];
                          int v8 = v278;
                        }

                        else
                        {
                          uint64_t v243 = v243;
                        }

                        int v256 = (int8x16_t *)&v214[v243];
                        if ((unint64_t)&v214[v243 + (v222 >> 1)] <= v248)
                        {
                          if ((v6[10] & 4) != 0)
                          {
                            uint64_t v257 = v6[1];
                          }

                          else
                          {
                            uint64_t v257 = v6[2];
                            unsigned int v222 = lzbitmap_encode_rle(v257, v6[1], v222);
                          }

                          if (v222 >= 0x20)
                          {
                            uint64_t v258 = 0LL;
                            uint64_t v259 = v256;
                            do
                            {
                              unsigned int v260 = (const char *)(v257 + v258);
                              int8x16x2_t v313 = vld2q_s8(v260);
                              unint64_t v261 = v258 + 64;
                              v258 += 32LL;
                              *v259++ = vorrq_s8(vshlq_n_s8(v313.val[1], 4uLL), v313.val[0]);
                            }

                            while (v261 <= v222);
                          }

                          else
                          {
                            LODWORD(v258) = 0;
                          }

                          bzero(&v256->i8[v258 >> 1], (v222 + 1 - v258) >> 1);
                          if (v258 < v222)
                          {
                            unint64_t v262 = v222 - (unint64_t)v258;
                            unsigned int v263 = 4 * v258;
                            unsigned int v264 = (unsigned __int8 *)(v257 + v258);
                            do
                            {
                              int v265 = *v264++;
                              *(__int32 *)((char *)v256->i32 + ((v263 >> 3) & 0x1FFFFFFE)) |= v265 << (v263 & 0xC);
                              v263 += 4;
                              --v262;
                            }

                            while (v262);
                          }

                          int v266 = &v256->i8[(v222 + 1) >> 1];
                          int v4 = v266 + 17;
                          LODWORD(__n) = v216;
                          uint64_t v5 = v215;
                          int v8 = v278;
                          if ((unint64_t)(v266 + 17) <= v6[6])
                          {
                            __int128 v267 = *v242;
                            v266[16] = *((_BYTE *)v6 + 76);
                            *(_OWORD *)int v266 = v267;
                            uint64_t v268 = (*((_DWORD *)v6 + 30) + 15);
                            uint64_t v269 = (*((_DWORD *)v6 + 31) + v268);
                            uint64_t v270 = (*((_DWORD *)v6 + 32) + v269);
                            *(void *)(v215 + 6) = v268 + (v269 << 24) + (v270 << 48);
                            *(_BYTE *)(v215 + 14) = BYTE2(v270);
                          }
                        }
                      }
                    }
                  }

                  break;
                }

                goto LABEL_108;
              }

              unsigned int v22 = 0;
              int v21 = 0;
              uint64_t v289 = a1[1];
              uint64_t v282 = a2 + 143;
              uint64_t v23 = 8LL;
              int32x4_t v95 = vdupq_n_s32(0x9E3779B1);
              unsigned int v24 = v9;
              unsigned int v291 = (void *)a1[5];
              while (v282 + (unint64_t)v22 <= v6[6])
              {
                unint64_t v96 = 0LL;
                uint64_t v97 = v24;
                int32x4_t v98 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v99 = *(int64x2_t *)((char *)v17 + v97);
                  v315.val[1] = *(int8x16_t *)((char *)v17 + v97 + 16);
                  uint32x4_t v100 = (uint32x4_t)vnegq_s32(v98);
                  uint64_t v101 = &v311[2 * v96];
                  *uint64_t v101 = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v99, (int8x16_t)xmmword_181096BA0),  v95),  v100);
                  v101[1] = vshlq_u32( (uint32x4_t)vmulq_s32( (int32x4_t)vqtbl1q_s8((int8x16_t)v99, (int8x16_t)xmmword_181096BB0),  v95),  v100);
                  v315.val[0] = (int8x16_t)vdupq_laneq_s64(v99, 1);
                  int32x4_t v102 = (int32x4_t)vqtbl2q_s8(v315, (int8x16_t)xmmword_181097480);
                  uint32x4_t v103 = vshlq_u32( (uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v315.val[0], (int8x16_t)xmmword_181096BA0), v95),  v100);
                  v101[2] = v103;
                  v101[3] = vshlq_u32((uint32x4_t)vmulq_s32(v102, v95), v100);
                  v97 += 16LL;
                  BOOL v47 = v96 >= 0xE;
                  v96 += 2LL;
                }

                while (!v47);
                if (!v24)
                {
                  *unsigned int v19 = 255;
                  v18[255] += 0x10000;
                  *int v294 = *v17;
                  unsigned int v22 = 8;
                  unsigned int v24 = 8;
                }

                for (uint64_t k = v24 == 8; k != 16; ++k)
                {
                  unsigned int v105 = v24;
                  unint64_t v106 = (int8x16_t *)((char *)v17 + v24);
                  int8x16_t v107 = *v106;
                  uint64x2_t v108 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v106 - v23),  *v106)))));
                  unsigned int v109 = (v24 - v9) >> 3;
                  if (v108.i8[0])
                  {
                    v103.i32[0] = v108.u8[0];
                    *(int8x8_t *)v103.i8 = vcnt_s8(*(int8x8_t *)v103.i8);
                    v103.i16[0] = vaddlv_u8(*(uint8x8_t *)v103.i8);
                    uint64_t v110 = v108.u8[0];
                    if (v103.i32[0] == 1)
                    {
                      LOWORD(v111) = 0;
LABEL_76:
                      v107.i64[1] = 0LL;
                      int8x8_t v139 = vqtbl1_s8(v107, lzbitmap_pack_perm_table[v110]);
                      *(int8x8_t *)((char *)v294 + v22) = v139;
                      v139.i32[0] = v110;
                      v19[v109] = v110 | (unsigned __int16)((_WORD)v111 << 8);
                      v18[v110 | ((unsigned __int16)v111 << 8)] += 0x10000;
                      uint8x8_t v140 = (uint8x8_t)vcnt_s8(v139);
                      v140.i16[0] = vaddlv_u8(v140);
                      v22 += v140.i32[0];
                    }

                    else
                    {
                      uint64_t v112 = 0LL;
                      unsigned int v111 = 0;
                      uint64_t v113 = *v6;
                      uint64_t v114 = (unsigned int *)&v311[2 * k];
                      uint64_t v115 = *v114;
                      unint64_t v116 = v18;
                      unint64_t v117 = v19;
                      int v118 = v21;
                      __int16 v119 = *(_WORD *)(*v6 + 2 * v115);
                      uint64_t v121 = v114[4];
                      uint64_t v120 = v114[5];
                      __int16 v122 = *(_WORD *)(*v6 + 2 * v121);
                      uint64_t v123 = v114[2];
                      uint64_t v124 = v114[3];
                      __int16 v125 = *(_WORD *)(*v6 + 2 * v123);
                      __int16 v126 = *(_WORD *)(*v6 + 2 * v124);
                      *(_WORD *)(v113 + 2LL * v114[1]) = v105 + 1;
                      v108.i32[0] = ((unsigned __int16)(v108.i16[0] | (v108.i16[4] << 8)) >> 8);
                      __int16 v295 = v105 - v119;
                      *(_WORD *)(v113 + 2 * v123) = v105 + 2;
                      __int16 v296 = v105 + 4 - v122;
                      int v127 = v118;
                      unsigned int v19 = v117;
                      unsigned int v18 = v116;
                      *(_WORD *)(v113 + 2 * v124) = v105 + 3;
                      unsigned int v128 = (vaddlv_u8((uint8x8_t)vcnt_s8(*(int8x8_t *)v108.i8)) + 4 * v103.i8[0]);
                      __int16 v297 = v105 + 2 - v125;
                      *(_WORD *)(v113 + 2 * v120) = v105 + 5;
                      uint64_t v129 = v114[6];
                      uint64_t v130 = v114[7];
                      *(_WORD *)(v113 + 2 * v129) = v105 + 6;
                      *(_WORD *)(v113 + 2 * v130) = v105 + 7;
                      __int16 v298 = v105 + 3 - v126;
                      *(_WORD *)(v113 + 2 * v121) = v105 + 4;
                      *(_WORD *)(v113 + 2 * v115) = v105;
                      while (1)
                      {
                        uint64_t v131 = *(unsigned __int16 *)((char *)&v295 + v112);
                        uint64x2_t v132 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)((char *)v106 - v131),  v107)))));
                        int v133 = (unsigned __int16)(v132.i16[0] | (v132.i16[4] << 8));
                        int v134 = v133 | (((int)v131 - 8) >> 24);
                        unsigned int v135 = (v131 + 130816) >> 16;
                        unsigned int v136 = (unsigned __int16)(v133 | (((int)v131 - 8) >> 24));
                        v132.i32[0] = v132.i8[0] | ((v131 - 8) >> 24);
                        int8x8_t v137 = vcnt_s8(*(int8x8_t *)v132.i8);
                        v137.i16[0] = vaddlv_u8((uint8x8_t)v137);
                        unsigned __int32 v138 = v137.i32[0] + v135;
                        v137.i32[0] = v136 >> 8;
                        *(int8x8_t *)v132.i8 = vcnt_s8(v137);
                        v132.i16[0] = vaddlv_u8(*(uint8x8_t *)v132.i8);
                        if (v132.i32[0] + 4 * v138 < v128)
                        {
                          unsigned int v128 = (v132.i8[0] + 4 * v138);
                          uint64_t v110 = v134;
                          unsigned int v111 = (v131 + 130816) >> 16;
                          uint64_t v23 = *(unsigned __int16 *)((char *)&v295 + v112);
                        }

                        v112 += 2LL;
                        if (v112 == 8)
                        {
                          *(_WORD *)(v289 + (unsigned __int16)v127) = v23;
                          int v21 = v127 + v111;
                          unsigned int v9 = a3;
                          int v17 = v291;
                          unint64_t v6 = a1;
                          goto LABEL_76;
                        }
                      }

                      v19[v109] = (_WORD)v135 << 8;
                      v116[256 * v135] += 0x10000;
                      *(_WORD *)(v289 + (unsigned __int16)v127) = v131;
                      int v21 = v127 + ((v131 + 130816) >> 16);
                      uint64_t v23 = v131;
                      unsigned int v9 = a3;
                      int v17 = v291;
                      unint64_t v6 = a1;
                    }
                  }

                  else
                  {
                    v19[v109] = 0;
                    *v18 += 0x10000;
                  }

                  unsigned int v24 = v105 + 8;
                }

                if (v105 + 136 > v284) {
                  goto LABEL_80;
                }
              }

              goto LABEL_109;
          }
        }
      }

      int v4 = &v8[__n];
      if ((unint64_t)v4 <= v6[6])
      {
        int v271 = __n;
        uint64_t v272 = v5;
        memcpy(v8, (const void *)(v6[5] + v9), __n);
        uint64_t v5 = v272;
        LODWORD(__n) = v271;
      }

      else
      {
        int v4 = 0LL;
      }

LABEL_185:
      *(_DWORD *)uint64_t v5 = ((_DWORD)v4 - v5) | ((_DWORD)__n << 24);
      *(_WORD *)(v5 + 4) = __n >> 8;
    }
  }

  return v4;
}

        if (v79 <= v126 && v127)
        {
          v165[3] = v165[2];
          *(void *)(v165 + 1) = *(void *)v165;
          *uint8x8_t v165 = v79;
        }

        *(_DWORD *)__int16 v162 = v12;
        *(_DWORD *)(v162 + 4) = v73;
        unsigned int v128 = *(unsigned int *)(a5 + 68);
        uint64_t v129 = v128 + 16;
        uint64_t result = 0xBD1E35A7BD000000LL;
        if (v128 + 16 <= v127)
        {
          uint64x2_t v132 = *(unsigned int *)(a5 + 64);
          int v133 = v127 - v128 + (4LL << v132) - 16;
          int v134 = (__clz(v133) ^ 0x1F) - 1;
          unsigned int v135 = ((v133 >> v134) & 1 | 2) << v134;
          int v127 = ((v133 & ~(-1 << v132))
                + v129
                + ((((v133 >> v134) & 1 | (2 * (v134 - v132))) + 65534) << v132)) | ((v134 - v132) << 10);
          uint64_t v130 = (v133 - v135) >> v132;
        }

        else
        {
          LODWORD(v130) = 0;
        }

        goto LABEL_194;
      }

      int v142 = 4 * (v140 - v139);
      unsigned __int16 v143 = 266017486;
    }

    else
    {
      int v142 = 4 * v141;
      unsigned __int16 v143 = 158663784;
    }

    int v127 = (v143 >> v142) & 0xF;
    goto LABEL_185;
  }

  unsigned int v18 = a9;
  uint64_t v124 = a2;
LABEL_255:
  *a8 = v12 + v13 - v124;
  *a10 += (v18 - a9) >> 4;
  return result;
}

uint64_t lzvn_stream_init(uint64_t a1, int a2, int a3, int a4)
{
  if (a2 == 1) {
    return lzvnStreamDecodeInit(a1, a3, a4);
  }
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  return lzvnStreamEncodeInit(a1, a3, a4);
}

uint64_t lzvn_stream_process(uint64_t a1, char a2)
{
  int v2 = **(_DWORD **)(a1 + 32);
  if (v2 == 1) {
    return lzvnStreamDecode(a1, a2);
  }
  if (v2) {
    return 0xFFFFFFFFLL;
  }
  return lzvnStreamEncode(a1, a2);
}

BOOL lzvn_stream_identify_algorithm(_BYTE *a1)
{
  return *a1 == 14 && a1[1] == 22 && a1[2] == 22 && a1[3] == 14;
}

uint64_t lzvn_stream_get_state_size(uint64_t a1)
{
  size_t v1 = *(_DWORD **)(a1 + 32);
  if (*v1 == 1) {
    return lzvnStreamDecodeStateSize();
  }
  if (*v1) {
    return 0LL;
  }
  return lzvnStreamEncodeStateSize(v1[1]);
}

uint64_t lzma_decode_buffer()
{
  else {
    return 0LL;
  }
}

uint64_t lzma_encode_buffer()
{
  else {
    return 0LL;
  }
}

uint64_t lz4_decode_buffer(char *__dst, _BYTE *__n, unsigned __int8 *a3, unint64_t a4)
{
  unsigned int v18 = a3;
  unsigned int v19 = __dst;
  uint64_t v5 = __dst;
  if (!__n) {
    return v5 - __dst;
  }
  unint64_t v7 = __n;
  uint64_t v5 = __dst;
  while (1)
  {
    if (a4 < 4) {
      return 0LL;
    }
    int v8 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 == 758412898) {
      break;
    }
    if (v8 != 825521762)
    {
      if (v8 == 607417954) {
        return v5 - __dst;
      }
      else {
        return 0LL;
      }
    }

    unint64_t v9 = a4 - 12;
    if (a4 < 0xC) {
      return 0LL;
    }
    uint64_t v11 = *((unsigned int *)a3 + 1);
    unint64_t v10 = (unsigned __int8 *)*((unsigned int *)a3 + 2);
    uint64_t v12 = a3 + 12;
    unsigned int v18 = a3 + 12;
    a4 = v9 - (void)v10;
    if (v9 < (unint64_t)v10
      || (unint64_t)v7 >= 0x81
      && v10 >= 0x81
      && lz4_decode_asm( (int8x16_t **)&v19,  (unint64_t)__dst,  (unint64_t)&v7[(void)v5 - 128],  &v18,  (unint64_t)&v10[(void)v12 - 128]))
    {
      return 0LL;
    }

    if (lz4_decode( (void **)&v19,  (unint64_t)__dst,  (unint64_t)&v7[(void)v5],  &v18,  (unint64_t)&v10[(void)v12])) {
      return 0LL;
    }
    int32x4_t v13 = v19;
    size_t v14 = v19 - v5;
    if ((_BYTE *)(v19 - v5) == v7) {
      return v13 - __dst;
    }
    uint64_t result = 0LL;
    if (v14 != v11) {
      return result;
    }
    a3 = v18;
    uint64_t v5 = v19;
LABEL_20:
    v7 -= v14;
    if (!v7) {
      return v5 - __dst;
    }
  }

  unint64_t v16 = a4 - 8;
  if (a4 < 8) {
    return 0LL;
  }
  size_t v14 = *((unsigned int *)a3 + 1);
  int v17 = a3 + 8;
  unsigned int v18 = a3 + 8;
  a4 = v16 - v14;
  if (v16 < v14) {
    return 0LL;
  }
  if ((unint64_t)v7 > v14)
  {
    memcpy(v5, v17, v14);
    uint64_t v5 = &v19[v14];
    a3 = &v18[v14];
    v18 += v14;
    v19 += v14;
    goto LABEL_20;
  }

  memcpy(v5, v17, (size_t)v7);
  int32x4_t v13 = &v7[(void)v19];
  return v13 - __dst;
}

uint64_t lz4_decode( void **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  unint64_t v7 = (char *)*a1;
  int v8 = *a4;
  if ((unint64_t)*a1 < a3 && (unint64_t)v8 < a5)
  {
    while (1)
    {
      *a4 = v8;
      *a1 = v7;
      unsigned int v15 = *v8++;
      char v14 = v15;
      unsigned int v16 = v15 >> 4;
      if (v15 >> 4 == 15)
      {
        while ((unint64_t)v8 < a5)
        {
          int v25 = *v8++;
          v16 += v25;
          if (v25 != 255) {
            goto LABEL_8;
          }
        }

        return 1LL;
      }

LABEL_15:
      if (v21)
      {
        uint64_t v22 = -v19;
        uint64_t v23 = &v7[v17];
        uint64_t v24 = v21;
        do
        {
          *uint64_t v23 = v23[v22];
          ++v23;
          --v24;
        }

        while (v24);
      }

      unint64_t v7 = &v18[v21];
    }

    if ((_DWORD)a3 != (_DWORD)v18)
    {
      uint64_t v27 = -v19;
      unsigned int v28 = &v7[v17];
      uint64_t v29 = (a3 - (_DWORD)v18);
      do
      {
        *unsigned int v28 = v28[v27];
        ++v28;
        --v29;
      }

      while (v29);
    }

    unint64_t v7 = &v18[(a3 - (_DWORD)v18)];
  }

        uint64_t v24 = v13 - v14;
        if (v13 < v14) {
          uint64_t v24 = 0LL;
        }
        if (v24 <= 0xF)
        {
          uint64_t result = 0LL;
          uint64_t v33 = 1;
          goto LABEL_72;
        }

        uint64_t v17 = *(void *)(a1 + 24);
        unsigned int v16 = *(unsigned __int16 *)(v17 + ((v14 + 7) >> 3));
        *(void *)(a1 + 80) = v16;
        unsigned int v15 = ((v14 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 32;
        *(void *)(a1 + 40) = v15;
LABEL_19:
        int v25 = v13 >= v15;
        int v26 = v13 - v15;
        if (!v25) {
          int v26 = 0LL;
        }
        uint64_t v27 = v26 >> 3;
        if (v27 >= *(void *)(a1 + 8)) {
          uint64_t v27 = *(void *)(a1 + 8);
        }
        if (v27 >= v16) {
          unsigned int v28 = v16;
        }
        else {
          unsigned int v28 = v27;
        }
        memcpy(*(void **)(a1 + 64), (const void *)(v17 + (v15 >> 3)), v28);
        *(void *)(a1 + 40) += 8 * v28;
        *(void *)(a1 + 8) -= v28;
        uint64_t v29 = *(void *)(a1 + 64) + v28;
        *(void *)(a1 + 64) = v29;
        uint64_t v30 = *(void *)(a1 + 80);
        uint64_t v31 = v30 > v28;
        unsigned int v32 = v30 - v28;
        if (v31)
        {
          *(void *)(a1 + 80) = v32;
          *(_DWORD *)(a1 + 48) = 2;
          return v29 - *(void *)a1;
        }
      }

      *(_DWORD *)(a1 + 48) = 11;
      goto LABEL_84;
    }

uint64_t lzbitmap_encode_rle(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0LL;
  unsigned int v4 = a3;
  do
  {
    if ((v3 & 1) != 0) {
      char v5 = 0;
    }
    else {
      char v5 = 15;
    }
    *(_BYTE *)(a2 + a3 + v3++) = v5;
  }

  while (v3 != 16);
  if (a3)
  {
    unsigned int v4 = 0;
    unsigned int v6 = 0;
    do
    {
      unint64_t v7 = (_OWORD *)(a2 + v4);
      int8x16_t v8 = *(int8x16_t *)v7;
      int8x16_t v9 = *(int8x16_t *)((char *)v7 + 1);
      *(_OWORD *)(a1 + v6) = *v7;
      uint64x2_t v10 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v8, v9), (int8x16_t)xmmword_181097490))));
      v4 += v7;
      v6 += v7;
      if ((((v10.i32[0] | (v10.i32[2] << 8)) >> 1) & (((v10.i32[0] | (v10.i32[2] << 8)) & 0xFFFCu) >> 2) & (v10.i32[0] | (v10.i32[2] << 8))) != 0)
      {
        unsigned int v11 = v6 + 1;
        *(_BYTE *)(a1 + v6) = 15;
        v4 += 3;
        do
        {
          uint64x2_t v12 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8( (int8x16_t)xmmword_181097490,  vceqq_s8( *(int8x16_t *)(a2 + v4 - 1),  *(int8x16_t *)(a2 + v4))))));
          unsigned int v13 = __clz(__rbit32(v12.i16[0] | (unsigned __int16)(v12.i16[4] << 8) | 0xFFFF8000));
          unsigned int v6 = v11 + 1;
          *(_BYTE *)(a1 + v11) = v13;
          v4 += v13;
          ++v11;
        }

        while (v13 == 15);
      }
    }

    while (v4 < a3);
  }

  else
  {
    unsigned int v6 = 0;
  }

  return v6 + a3 - v4;
}

uint64_t lzbitmap_decode_rle(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (*a2 == 15 || (_DWORD)a3 == 0) {
    return 0LL;
  }
  int v4 = 0;
  unsigned int v5 = 0;
  v6.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v6.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v7 = *(int8x16_t *)&a2[v4];
    *(int8x16_t *)(a1 + v5) = v7;
    uint64x2_t v8 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v6), (int8x16_t)xmmword_181097490))));
    unsigned int v9 = __clz(__rbit32((unsigned __int16)(v8.i16[0] | (v8.i16[4] << 8)) | 0x10000));
    v5 += v9;
    v4 += v9;
    if (v8.i16[0] | (unsigned __int16)(v8.i16[4] << 8))
    {
      int v10 = v4 + 1;
      unsigned int v11 = &a2[v4 - 1];
      int8x16_t v12 = vld1q_dup_s8(v11);
      *(int8x16_t *)(a1 + v5) = v12;
      v5 += 3;
      do
      {
        int v4 = v10 + 1;
        unsigned int v13 = a2[v10];
        *(int8x16_t *)(a1 + v5) = v12;
        v5 += v13;
        BOOL v14 = v13 < 0xF || v5 >= a3;
        int v10 = v4;
      }

      while (!v14);
    }
  }

  while (v5 < a3);
  return a3;
}

_DWORD *BrotliInitEncoderDictionary(uint64_t a1)
{
  *(void *)a1 = BrotliGetDictionary();
  uint64_t result = BrotliGetTransforms();
  int v3 = result[6];
  *(void *)(a1 + 32) = &kStaticDictionaryHashLengths;
  *(void *)(a1 + 40) = &kStaticDictionaryBuckets;
  *(void *)(a1 + 48) = &kStaticDictionaryWords;
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 10;
  *(void *)(a1 + 16) = 0x71B520ADA2D3200LL;
  *(void *)(a1 + 24) = &kStaticDictionaryHashWords;
  return result;
}

void *BrotliGetTransforms()
{
  return &kBrotliTransforms;
}

uint64_t BrotliTransformDictionaryWord(uint64_t a1, char *a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v5 = a3;
  uint64_t v8 = a4[1];
  uint64_t v7 = a4[2];
  uint64_t v9 = a4[4];
  uint64_t v10 = 3LL * a5;
  uint64_t v11 = *(unsigned __int16 *)(v7 + 2LL * *(unsigned __int8 *)(v9 + v10));
  uint64_t v12 = v9 + (int)v10;
  int v13 = *(unsigned __int8 *)(v12 + 1);
  uint64_t v14 = *(unsigned __int16 *)(v7 + 2LL * *(unsigned __int8 *)(v12 + 2));
  int v15 = *(unsigned __int8 *)(v8 + v11);
  if (*(_BYTE *)(v8 + v11))
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = v11 + v8 + 1;
    do
    {
      *(_BYTE *)(a1 + v16) = *(_BYTE *)(v17 + v16);
      ++v16;
    }

    while (v15 != (_DWORD)v16);
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  if (v13 > 9)
  {
    if ((v13 - 12) <= 8)
    {
      uint64_t v18 = (v13 - 11);
      a2 += v18;
      uint64_t v5 = (a3 - v18);
    }
  }

  else
  {
    uint64_t v5 = (a3 - v13);
  }

  if ((int)v5 >= 1)
  {
    uint64_t v16 = v16;
    uint64_t v19 = v5;
    do
    {
      char v20 = *a2++;
      *(_BYTE *)(a1 + v16++) = v20;
      --v19;
    }

    while (v19);
  }

  if (v13 > 20)
  {
    if (v13 == 21)
    {
      Shift( (char *)(a1 - (int)v5 + (int)v16),  v5,  *(unsigned __int8 *)(a4[5] + 2LL * a5) | (*(unsigned __int8 *)(a4[5] + 2 * a5 + 1LL) << 8));
    }

    else if (v13 == 22 && (int)v5 >= 1)
    {
      int v25 = (char *)(a1 - (int)v5 + (int)v16);
      __int16 v26 = *(unsigned __int8 *)(a4[5] + 2LL * a5) | (*(unsigned __int8 *)(a4[5] + 2 * a5 + 1LL) << 8);
      do
      {
        int v27 = Shift(v25, v5, v26);
        v25 += v27;
        BOOL v24 = __OFSUB__((_DWORD)v5, v27);
        uint64_t v5 = (v5 - v27);
      }

      while (!(((int)v5 < 0) ^ v24 | ((_DWORD)v5 == 0)));
    }
  }

  else if (v13 == 10)
  {
    unsigned int v28 = (unsigned __int8 *)(a1 - (int)v5 + (int)v16);
    unsigned int v29 = *v28;
    if (v29 > 0xBF)
    {
      if (v29 > 0xDF) {
        v28[2] ^= 5u;
      }
      else {
        v28[1] ^= 0x20u;
      }
    }

    else if (v29 - 97 <= 0x19)
    {
      *unsigned int v28 = v29 ^ 0x20;
    }
  }

  else if (v13 == 11 && (int)v5 >= 1)
  {
    unsigned int v21 = (unsigned __int8 *)(a1 - (int)v5 + (int)v16);
    do
    {
      unsigned int v22 = *v21;
      if (v22 > 0xBF)
      {
        if (v22 > 0xDF)
        {
          v21[2] ^= 5u;
          unsigned int v23 = 3;
        }

        else
        {
          v21[1] ^= 0x20u;
          unsigned int v23 = 2;
        }
      }

      else
      {
        if (v22 - 97 <= 0x19) {
          *unsigned int v21 = v22 ^ 0x20;
        }
        unsigned int v23 = 1;
      }

      v21 += v23;
      BOOL v24 = __OFSUB__((_DWORD)v5, v23);
      LODWORD(v5) = v5 - v23;
    }

    while (!(((int)v5 < 0) ^ v24 | ((_DWORD)v5 == 0)));
  }

  int v30 = *(unsigned __int8 *)(v8 + v14);
  if (*(_BYTE *)(v8 + v14))
  {
    uint64_t v16 = v16;
    uint64_t v31 = (char *)(v14 + v8 + 1);
    do
    {
      char v32 = *v31++;
      *(_BYTE *)(a1 + v16++) = v32;
      --v30;
    }

    while (v30);
  }

  return v16;
}

uint64_t Shift(char *a1, uint64_t a2, __int16 a3)
{
  unsigned int v3 = *a1;
  if ((*a1 & 0x80000000) == 0)
  {
    *a1 = (v3 + a3) & 0x7F;
    return 1LL;
  }

  if (v3 < 0xC0) {
    return 1LL;
  }
  int v4 = (a3 & 0x7FFF) - (a3 & 0x8000) + 0x1000000;
  if (v3 > 0xDF)
  {
    if (v3 > 0xEF)
    {
      if (v3 > 0xF7) {
        return 1LL;
      }
      if ((int)a2 >= 4)
      {
        unsigned __int8 v10 = a1[3];
        unsigned __int8 v11 = a1[2];
        unsigned __int8 v12 = a1[1];
        int v13 = ((v3 & 7) << 18) + v4 + (v10 & 0x3F);
        unsigned int v14 = v13 + ((v11 & 0x3F) << 6);
        unsigned int v15 = v14 + ((v12 & 0x3F) << 12);
        *a1 = (v15 >> 18) & 7 | 0xF0;
        a1[1] = v12 & 0xC0 | (v15 >> 12) & 0x3F;
        a1[2] = v11 & 0xC0 | (v14 >> 6) & 0x3F;
        a1[3] = v10 & 0xC0 | v13 & 0x3F;
        return 4LL;
      }
    }

    else if ((int)a2 >= 3)
    {
      unsigned __int8 v7 = a1[2];
      unsigned __int8 v8 = a1[1];
      int v9 = ((v3 & 0xF) << 12) + v4 + (v7 & 0x3F);
      *a1 = ((unsigned __int16)(v9 + ((v8 & 0x3F) << 6)) >> 12) | 0xE0;
      a1[1] = v8 & 0xC0 | ((v9 + ((v8 & 0x3Fu) << 6)) >> 6) & 0x3F;
      a1[2] = v7 & 0xC0 | v9 & 0x3F;
      return 3LL;
    }
  }

  else
  {
    unsigned __int8 v5 = a1[1];
    unsigned int v6 = (v5 & 0x3F | ((v3 & 0x1F) << 6)) + v4;
    *a1 = (v6 >> 6) & 0x1F | 0xC0;
    a1[1] = v5 & 0xC0 | v6 & 0x3F;
    return 2LL;
  }

  return a2;
}

uint64_t lzvnEncodeInitState(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 <= -65535) {
    uint64_t v4 = -65535LL;
  }
  unsigned __int8 v5 = (const float *)(*(void *)result + v4);
  float32x4_t v6 = vld1q_dup_f32(v5);
  if (a2 == 2305) {
    int v7 = 11;
  }
  else {
    int v7 = 14;
  }
  *(_DWORD *)(result + 72) = v7;
  *(void *)(result + 128) = a3;
  int32x4_t v8 = vdupq_n_s32(v4);
  unsigned int v9 = 1;
  do
  {
    unsigned __int8 v10 = (int32x4_t *)(*(void *)(result + 128) + v3);
    *unsigned __int8 v10 = v8;
    v10[1] = (int32x4_t)v6;
    LODWORD(v10) = v9 >> v7;
    v3 += 32LL;
    ++v9;
  }

  while (!(_DWORD)v10);
  return result;
}

int64_t lzvnEncode(int64_t result, int8x16_t a2)
{
  uint64_t v2 = *(void *)(result + 24);
  if (v2 < *(void *)(result + 32))
  {
    int64_t v3 = result;
    int64_t v93 = result + 80;
    do
    {
      uint64_t v4 = *(void *)v3;
      unsigned int v5 = *(_DWORD *)(*(void *)v3 + v2);
      uint64_t v6 = (-1640531535 * (v5 & 0xFFFFFF)) >> -*(_BYTE *)(v3 + 72);
      int v7 = (int8x16_t *)(*(void *)(v3 + 128) + 32 * v6);
      int8x16_t v9 = *v7;
      int8x16_t v8 = v7[1];
      int64_t v10 = *(void *)(v3 + 40);
      if (v2 >= v10)
      {
        a2 = veorq_s8(v8, (int8x16_t)vdupq_n_s32(v5));
        unsigned int v11 = __clz(__rbit64(a2.u32[0])) >> 3;
        if (a2.i32[0]) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 4LL;
        }
        uint64_t v13 = *(void *)(v3 + 8);
        uint64_t v14 = *(void *)(v3 + 16);
        if (v12 >= 3 && (uint64_t v15 = v2 - v9.i32[0], (unint64_t)(v15 - 0x10000) >= 0xFFFFFFFFFFFF0001LL))
        {
          for (uint64_t i = v2 + v12; (_DWORD)v12 == 4 && i + 4 < v14; i += v12)
          {
            unint64_t v23 = (*(_DWORD *)(v4 + i - v15) ^ *(_DWORD *)(v4 + i));
            unsigned int v24 = __clz(__rbit64(v23)) >> 3;
            if ((_DWORD)v23) {
              uint64_t v12 = v24;
            }
            else {
              uint64_t v12 = 4LL;
            }
          }

          uint64_t v25 = 0LL;
          do
          {
            uint64_t v26 = v25;
            int64_t v27 = v2 + v25;
            uint64_t v28 = v9.i32[0] + v25;
            if (v27 <= v10 || v28 <= v13) {
              break;
            }
            uint64_t v25 = v26 - 1;
          }

          while (*(unsigned __int8 *)(v4 - 1 + v2 + v26) == *(unsigned __int8 *)(v4 - 1 + v9.i32[0] + v26));
          uint64_t result = i - v2;
          uint64_t v30 = -3LL;
          if (v15 < 1536) {
            uint64_t v30 = -2LL;
          }
          uint64_t v31 = v30 + result;
          uint64_t v32 = v30 + result - v26;
          if (v32 > 0 || (int64_t v16 = 0LL, v17 = 0LL, v18 = 0LL, v19 = 0LL, v20 = 0LL, v31 == v26) && i >= 2)
          {
            uint64_t v18 = result - v26;
            int64_t v16 = v27;
            uint64_t v17 = i;
            uint64_t v19 = v2 - v9.i32[0];
            uint64_t v20 = v32;
          }
        }

        else
        {
          int64_t v16 = 0LL;
          uint64_t v17 = 0LL;
          uint64_t v18 = 0LL;
          uint64_t v19 = 0LL;
          uint64_t v20 = 0LL;
        }

        unsigned int v33 = __clz(__rbit64(a2.u32[1])) >> 3;
        if (a2.i32[1]) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = 4LL;
        }
        if (v34 >= 3)
        {
          uint64_t v35 = v2 - v9.i32[1];
          if ((unint64_t)(v35 - 0x10000) >= 0xFFFFFFFFFFFF0001LL)
          {
            for (uint64_t j = v2 + v34; (_DWORD)v34 == 4 && j + 4 < v14; j += v34)
            {
              unint64_t v38 = (*(_DWORD *)(v4 + j - v35) ^ *(_DWORD *)(v4 + j));
              unsigned int v39 = __clz(__rbit64(v38)) >> 3;
              if ((_DWORD)v38) {
                uint64_t v34 = v39;
              }
              else {
                uint64_t v34 = 4LL;
              }
            }

            uint64_t v40 = 0LL;
            do
            {
              uint64_t v41 = v40;
              int64_t v42 = v2 + v40;
              uint64_t v43 = v9.i32[1] + v40;
              if (v42 <= v10 || v43 <= v13) {
                break;
              }
              uint64_t v40 = v41 - 1;
            }

            while (*(unsigned __int8 *)(v4 - 1 + v2 + v41) == *(unsigned __int8 *)(v4 - 1 + v9.i32[1] + v41));
            uint64_t result = j - v2;
            uint64_t v45 = v35 >= 1536 ? -3LL : -2LL;
            if (v45 + result - v41 > v20 || v45 + j - v20 - v2 == v41 && j > v17 + 1)
            {
              uint64_t v18 = result - v41;
              int64_t v16 = v42;
              uint64_t v17 = j;
              uint64_t v19 = v2 - v9.i32[1];
              uint64_t v20 = v45 + result - v41;
            }
          }
        }

        unsigned int v46 = __clz(__rbit64(a2.u32[2])) >> 3;
        if (a2.i32[2]) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = 4LL;
        }
        if (v47 >= 3)
        {
          uint64_t v48 = v2 - v9.i32[2];
          if ((unint64_t)(v48 - 0x10000) >= 0xFFFFFFFFFFFF0001LL)
          {
            uint64_t v49 = v2 + v47;
            if ((_DWORD)v47 == 4 && v49 + 4 < v14)
            {
              do
              {
                unint64_t v50 = (*(_DWORD *)(v4 + v49 - v48) ^ *(_DWORD *)(v4 + v49));
                unsigned int v51 = __clz(__rbit64(v50)) >> 3;
                if ((_DWORD)v50) {
                  uint64_t v52 = v51;
                }
                else {
                  uint64_t v52 = 4LL;
                }
                v49 += v52;
              }

              while ((_DWORD)v52 == 4 && v49 + 4 < v14);
            }

            uint64_t v54 = 0LL;
            do
            {
              uint64_t v55 = v54;
              int64_t v56 = v2 + v54;
              uint64_t v57 = v9.i32[2] + v54;
              if (v56 <= v10 || v57 <= v13) {
                break;
              }
              uint64_t v54 = v55 - 1;
            }

            while (*(unsigned __int8 *)(v4 - 1 + v2 + v55) == *(unsigned __int8 *)(v4 - 1 + v9.i32[2] + v55));
            uint64_t result = v49 - v2;
            if (v48 >= 1536) {
              uint64_t v59 = -3LL;
            }
            else {
              uint64_t v59 = -2LL;
            }
            if (v59 + result - v55 > v20 || v59 + v49 - v20 - v2 == v55 && v49 > v17 + 1)
            {
              uint64_t v18 = result - v55;
              int64_t v16 = v56;
              uint64_t v17 = v49;
              uint64_t v19 = v2 - v9.i32[2];
              uint64_t v20 = v59 + result - v55;
            }
          }
        }

        unsigned int v60 = __clz(__rbit64(a2.u32[3])) >> 3;
        if (a2.i32[3]) {
          uint64_t v61 = v60;
        }
        else {
          uint64_t v61 = 4LL;
        }
        if (v61 >= 3)
        {
          uint64_t v62 = v2 - v9.i32[3];
          if ((unint64_t)(v62 - 0x10000) >= 0xFFFFFFFFFFFF0001LL)
          {
            for (uint64_t k = v2 + v61; (_DWORD)v61 == 4 && k + 4 < v14; k += v61)
            {
              unint64_t v65 = (*(_DWORD *)(v4 + k - v62) ^ *(_DWORD *)(v4 + k));
              unsigned int v66 = __clz(__rbit64(v65)) >> 3;
              if ((_DWORD)v65) {
                uint64_t v61 = v66;
              }
              else {
                uint64_t v61 = 4LL;
              }
            }

            uint64_t v67 = 0LL;
            do
            {
              uint64_t v68 = v67;
              int64_t v69 = v2 + v67;
              uint64_t v70 = v9.i32[3] + v67;
              if (v69 <= v10 || v70 <= v13) {
                break;
              }
              uint64_t v67 = v68 - 1;
            }

            while (*(unsigned __int8 *)(v4 - 1 + v2 + v68) == *(unsigned __int8 *)(v4 - 1 + v9.i32[3] + v68));
            uint64_t result = k - v2;
            uint64_t v72 = v62 >= 1536 ? -3LL : -2LL;
            if (v72 + result - v68 > v20 || v72 + k - v20 - v2 == v68 && k > v17 + 1)
            {
              uint64_t v18 = result - v68;
              int64_t v16 = v69;
              uint64_t v17 = k;
              uint64_t v19 = v2 - v9.i32[3];
              uint64_t v20 = v72 + result - v68;
            }
          }
        }

        uint64_t v73 = *(void *)(v3 + 120);
        if (v73)
        {
          unint64_t v74 = *(_DWORD *)(v4 + v2 - v73) ^ v5;
          unsigned int v75 = __clz(__rbit64(v74)) >> 3;
          if (!(_DWORD)v74) {
            unsigned int v75 = 4;
          }
          if ((unint64_t)(v73 - 0x10000) >= 0xFFFFFFFFFFFF0001LL && v75 >= 3)
          {
            uint64_t v76 = v2 + v75;
            uint64_t v77 = v76 + 4;
            for (BOOL m = v75 == 4; m && v77 < v14; BOOL m = (_DWORD)v82 == 4)
            {
              unint64_t v80 = (*(_DWORD *)(v4 + v76 - v73) ^ *(_DWORD *)(v4 + v76));
              unsigned int v81 = __clz(__rbit64(v80)) >> 3;
              if ((_DWORD)v80) {
                uint64_t v82 = v81;
              }
              else {
                uint64_t v82 = 4LL;
              }
              v76 += v82;
              uint64_t v77 = v76 + 4;
            }

            uint64_t result = v2;
            do
            {
              int64_t v83 = result;
              if (result <= v10) {
                break;
              }
              result -= v73;
              if (v83 - v73 <= v13) {
                break;
              }
              uint64_t result = v83 - 1;
            }

            while (*(unsigned __int8 *)(v4 - 1 + v83) == *(unsigned __int8 *)(v4 - 1 - v73 + v83));
            if (v76 - v83 - 1 > v20 || ~v20 + v76 == v83 && v76 > v17 + 1)
            {
              int64_t v16 = v83;
              uint64_t v17 = v76;
              uint64_t v18 = v76 - v83;
              uint64_t v19 = *(void *)(v3 + 120);
              uint64_t v20 = v76 - v83 - 1;
            }
          }
        }

        if (v18)
        {
          if (!*(void *)(v3 + 96)) {
            goto LABEL_146;
          }
          int8x16_t v94 = v9;
          int8x16_t v97 = v8;
          if (*(void *)(v3 + 88) <= v16)
          {
            __int128 v86 = *(_OWORD *)(v93 + 16);
            __int128 v100 = *(_OWORD *)v93;
            __int128 v101 = v86;
            uint64_t v102 = *(void *)(v93 + 32);
            uint64_t result = emitMatch((void *)v3, &v100);
            int8x16_t v9 = v94;
            int8x16_t v8 = v97;
            if (!result) {
              return result;
            }
LABEL_146:
            *(void *)(v3 + 80) = v16;
            *(void *)(v3 + 88) = v17;
            *(void *)(v3 + 96) = v18;
            *(void *)(v3 + 104) = v19;
            *(void *)(v3 + 112) = v20;
            goto LABEL_147;
          }

          if (v20 > *(void *)(v3 + 112))
          {
            *(void *)(v3 + 80) = v16;
            *(void *)(v3 + 88) = v17;
            *(void *)(v3 + 96) = v18;
            *(void *)(v3 + 104) = v19;
            *(void *)(v3 + 112) = v20;
          }

          __int128 v84 = *(_OWORD *)(v93 + 16);
          __int128 v100 = *(_OWORD *)v93;
          __int128 v101 = v84;
          uint64_t v102 = *(void *)(v93 + 32);
          uint64_t result = emitMatch((void *)v3, &v100);
          int8x16_t v9 = v94;
          int8x16_t v8 = v97;
          if (!result) {
            return result;
          }
          goto LABEL_144;
        }

        if (v2 - v10 >= 400)
        {
          if (*(void *)(v3 + 96))
          {
            int8x16_t v95 = v9;
            int8x16_t v98 = v8;
            __int128 v85 = *(_OWORD *)(v93 + 16);
            __int128 v100 = *(_OWORD *)v93;
            __int128 v101 = v85;
            uint64_t v102 = *(void *)(v93 + 32);
            uint64_t result = emitMatch((void *)v3, &v100);
            int8x16_t v9 = v95;
            int8x16_t v8 = v98;
            if (!result) {
              return result;
            }
LABEL_144:
            *(void *)(v93 + 32) = 0LL;
            a2 = 0uLL;
            *(_OWORD *)int64_t v93 = 0u;
            *(_OWORD *)(v93 + 16) = 0u;
            goto LABEL_147;
          }

          unsigned __int8 v90 = *(_WORD **)(v3 + 48);
          unint64_t v91 = *(void *)(v3 + 64);
          if ((unint64_t)v90 + 281 < v91)
          {
            _WORD *v90 = -32;
            int8x16_t v96 = v9;
            int8x16_t v99 = v8;
            uint64_t result = (int64_t)memcpy(v90 + 1, (const void *)(v4 + v10), 0x10FuLL);
            int8x16_t v9 = v96;
            int8x16_t v8 = v99;
            unint64_t v91 = (unint64_t)v90 + 273;
          }

          if (v91 >= *(void *)(v3 + 64)) {
            return result;
          }
          uint64_t v92 = *(void *)(v3 + 48);
          *(void *)(v3 + 40) += 271LL;
          *(void *)(v3 + 48) = v91;
          if (v91 == v92) {
            return result;
          }
        }
      }

LABEL_147:
      a2 = vextq_s8(a2, v9, 0xCuLL);
      a2.i32[0] = v2;
      int8x16_t v87 = vextq_s8(a2, v8, 0xCuLL);
      v87.i32[0] = v5;
      uint64_t v88 = *(void *)(v3 + 128) + 32 * v6;
      *(int8x16_t *)uint64_t v88 = a2;
      *(int8x16_t *)(v88 + 16) = v87;
      uint64_t v89 = *(void *)(v3 + 32);
      uint64_t v2 = *(void *)(v3 + 24) + 1LL;
      *(void *)(v3 + 24) = v2;
    }

    while (v2 < v89);
  }

  return result;
}

unint64_t emitMatch(void *a1, void *a2)
{
  uint64_t v4 = a1[5];
  unsigned int v5 = (char *)a1[6];
  unint64_t v6 = *a2 - v4;
  unint64_t v7 = a2[2];
  unint64_t v8 = a2[3];
  uint64_t v25 = a1[15];
  int8x16_t v9 = (int *)(*a1 + v4);
  unint64_t v10 = a1[8];
  if (v6 < 0x10)
  {
LABEL_7:
    if (v6 >= 4)
    {
      *unsigned int v5 = v6 | 0xE0;
      uint64_t v13 = v5 + 1;
      memcpy(v13, v9, ((v6 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
      unsigned int v5 = &v13[v6];
      int8x16_t v9 = (int *)((char *)v9 + v6);
      unint64_t v6 = 0LL;
    }

    if (10 - 2 * v6 >= v7) {
      uint64_t v14 = v7;
    }
    else {
      uint64_t v14 = 10 - 2 * v6;
    }
    if ((unint64_t)(v5 + 8) < v10)
    {
      unint64_t v15 = v7 - v14;
      char v16 = v14 - 3;
      int v17 = *v9;
      if (v8 == v25)
      {
        char v18 = ((_BYTE)v6 << 6) + 8 * v16;
        if (v6) {
          char v19 = 6;
        }
        else {
          char v19 = -16;
        }
        if (!v6) {
          char v18 = v14;
        }
        *unsigned int v5 = v19 | v18;
        uint64_t v20 = v5 + 1;
      }

      else if (v8 > 0x5FF)
      {
        if (v7 <= 0x22 && !(v8 >> 14) && v15)
        {
          *unsigned int v5 = ((v7 - 3) >> 2) + 8 * v6 - 96;
          *(_WORD *)(v5 + 1) = (v7 - 3) & 3 | (4 * v8);
          *(_DWORD *)(v5 + 3) = v17;
          unint64_t v10 = (unint64_t)&v5[v6 + 3];
          goto LABEL_39;
        }

        *unsigned int v5 = (((_BYTE)v6 << 6) + 8 * v16) | 7;
        *(_WORD *)(v5 + 1) = v8;
        uint64_t v20 = v5 + 3;
      }

      else
      {
        *unsigned int v5 = ((_BYTE)v6 << 6) + BYTE1(v8) + 8 * v16;
        v5[1] = v8;
        uint64_t v20 = v5 + 2;
      }

      _DWORD *v20 = v17;
      unsigned int v21 = (_WORD *)((char *)v20 + v6);
      if (v15 < 0x10)
      {
        unsigned int v22 = (char *)v20 + v6;
        if (v15)
        {
LABEL_35:
          if ((unint64_t)(v22 + 1) < v10)
          {
            *unsigned int v22 = v15 | 0xF0;
            unint64_t v10 = (unint64_t)(v22 + 1);
          }
        }

        else
        {
LABEL_38:
          unint64_t v10 = (unint64_t)v22;
        }
      }

      else
      {
        while (1)
        {
          unsigned int v22 = v21 + 1;
          if (v15 >= 0x10F) {
            uint64_t v23 = 271LL;
          }
          else {
            uint64_t v23 = v15;
          }
          *unsigned int v21 = ((_WORD)v23 << 8) - 3856;
          v15 -= v23;
          ++v21;
          if (v15 <= 0xF)
          {
            if (!v15) {
              goto LABEL_38;
            }
            goto LABEL_35;
          }
        }
      }
    }
  }

  else
  {
    while (1)
    {
      uint64_t v11 = v6 >= 0x10F ? 271LL : v6;
      *(_WORD *)unsigned int v5 = ((_WORD)v11 << 8) - 3872;
      uint64_t v12 = v5 + 2;
      v6 -= v11;
      memcpy(v12, v9, ((v11 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8);
      unsigned int v5 = &v12[v11];
      int8x16_t v9 = (int *)((char *)v9 + v11);
      if (v6 <= 0xF) {
        goto LABEL_7;
      }
    }
  }

LABEL_39:
  if (v10 >= a1[8]) {
    return 0LL;
  }
  unint64_t result = v10 - a1[6];
  a1[15] = a2[3];
  a1[5] = a2[1];
  a1[6] = v10;
  return result;
}

LABEL_42:
    if (*(_DWORD *)(v3 + 60))
    {
      if (*(_DWORD *)(v3 + 56)) {
        goto LABEL_66;
      }
      uint64_t v26 = 0LL;
    }

    else
    {
      int64_t v27 = *(const void **)(v3 + 112);
      if (*(void *)(a1 + 8) >= *(void *)(v3 + 104) - (void)v27) {
        uint64_t v26 = *(void *)(v3 + 104) - (void)v27;
      }
      else {
        uint64_t v26 = *(void *)(a1 + 8);
      }
      if (v26 >= 1)
      {
        memcpy(*(void **)a1, v27, v26);
        int64_t v27 = (const void *)(*(void *)(v3 + 112) + v26);
        *(void *)(v3 + 112) = v27;
        uint64_t v28 = *(void *)(a1 + 8) - v26;
        *(void *)a1 += v26;
        *(void *)(a1 + 8) = v28;
      }

      if (*(_DWORD *)(v3 + 56))
      {
        if (v27 == *(const void **)(v3 + 104))
        {
          uint64_t v32 = 0;
          *(_DWORD *)(v3 + 60) = 1;
          goto LABEL_68;
        }

        if (*(_DWORD *)(v3 + 60))
        {
LABEL_66:
          uint64_t v32 = 0;
          goto LABEL_68;
        }
      }
    }

    unsigned int v29 = *(void *)(v3 + 72);
    if (v29 >= 393216)
    {
      uint64_t v30 = *(void *)(v3 + 88);
      uint64_t v31 = v30 > 0x80000 ? v30 - 0x40000 : 0LL;
      if (v31 >= 1)
      {
        lzfseEncodeTranslateState((uint64_t)v4, v31);
        *(void *)(v3 + 64) = *(void *)(v3 + 16);
      }
    }

    uint64_t v32 = v26 | v6;
    if (!(v26 | v6)) {
      goto LABEL_68;
    }
  }

  if (*(_DWORD *)(v3 + 52)) {
    goto LABEL_39;
  }
  if (*(_DWORD *)(v3 + 40)) {
    goto LABEL_30;
  }
  uint64_t v13 = *(void *)(v3 + 72);
  if (v13 > 4095) {
    goto LABEL_31;
  }
  uint64_t v14 = *(void *)(v3 + 120);
  unint64_t v15 = *(void *)(v3 + 104);
  if (v14 <= v15 + 16) {
    goto LABEL_29;
  }
  char v16 = lzvn_encode_scratch_size(2304);
  int v17 = (int8x16_t *)malloc(v16);
  if (v17)
  {
    char v18 = v17;
    char v19 = v14 - v15;
    uint64_t v20 = lzvn_encode_buffer( (char *)(*(void *)(v3 + 104) + 12LL),  v19 - 16,  *(const float **)(v3 + 64),  v13,  v17,  2304);
    free(v18);
    if (v20 && (unint64_t)v20 < v13)
    {
      unsigned int v21 = *(_DWORD **)(v3 + 104);
      *unsigned int v21 = 1853388386;
      v21[1] = v13;
      v21[2] = (_DWORD)v20;
      unsigned int v22 = &v20[*(void *)(v3 + 104)];
      *((_DWORD *)v22 + 3) = 611874402;
      uint64_t v23 = *(void *)(v3 + 72);
      *(void *)(v3 + 80) = v23;
      *(void *)(v3 + 88) = v23;
      unsigned int v24 = v22 + 16;
LABEL_65:
      *(void *)(v3 + 96) = v23;
      *(void *)(v3 + 104) = v24;
      *(_DWORD *)(v3 + 52) = 1;
LABEL_41:
      *(_DWORD *)(v3 + 56) = 1;
      goto LABEL_42;
    }

    if (v19 >= v13 + 12)
    {
      unsigned int v33 = *(_DWORD **)(v3 + 104);
      *unsigned int v33 = 762869346;
      v33[1] = v13;
      uint64_t v34 = (void *)(*(void *)(v3 + 104) + 8LL);
      *(void *)(v3 + 104) = v34;
      memcpy(v34, *(const void **)(v3 + 64), v13);
      uint64_t v35 = (_DWORD *)(*(void *)(v3 + 104) + v13);
      *uint64_t v35 = 611874402;
      unsigned int v24 = v35 + 1;
      uint64_t v23 = *(void *)(v3 + 72);
      *(void *)(v3 + 80) = v23;
      *(void *)(v3 + 88) = v23;
      goto LABEL_65;
    }

    goto LABEL_28;
  }

  uint64_t v32 = 1;
LABEL_68:
  *(void *)(v3 + 64) -= v3;
  *(int64x2_t *)(v3 + 104) = vsubq_s64(*(int64x2_t *)(v3 + 104), v37);
  *(void *)(v3 + 120) -= v3;
  *(int64x2_t *)(v3 + 16) = vsubq_s64(*(int64x2_t *)(v3 + 16), v37);
  *(void *)(v3 + 32) -= v3;
  if ((v32 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
}

uint64_t lzvn_encode_scratch_size(int a1)
{
  if (a1 == 2305) {
    return 0x10000LL;
  }
  else {
    return 0x80000LL;
  }
}

char *lzvn_encode_buffer( char *a1, unint64_t a2, const float *a3, unint64_t a4, int8x16_t *a5, int a6)
{
  uint64_t v8 = 0LL;
  unint64_t result = lzvn_encode_partial(a1, a2, a3, a4, &v8, a5, a6);
  if (v8 != a4) {
    return 0LL;
  }
  return result;
}

char *lzvn_encode_partial( char *a1, unint64_t a2, const float *a3, unint64_t a4, uint64_t *a5, int8x16_t *a6, int a7)
{
  if (a2 < 8 || a4 <= 7)
  {
    unint64_t result = 0LL;
    *a5 = 0LL;
    return result;
  }

  __int128 v35 = 0u;
  __int128 v36 = 0u;
  uint64_t v7 = 0xFFFFFFFFLL;
  __int128 v37 = 0u;
  if (a4 < 0xFFFFFFFF) {
    uint64_t v7 = a4;
  }
  v27[0] = a3;
  v27[1] = 0LL;
  uint64_t v28 = v7;
  uint64_t v29 = 0LL;
  uint64_t v30 = v7 - 8;
  uint64_t v31 = 0LL;
  uint64_t v32 = a1;
  unsigned int v33 = a1;
  unint64_t v8 = (unint64_t)&a1[a2];
  uint64_t v34 = (uint64_t)&a1[a2 - 8];
  if (a7 == 2305) {
    int v9 = 11;
  }
  else {
    int v9 = 14;
  }
  LODWORD(v35) = v9;
  uint64_t v38 = 0LL;
  unsigned int v39 = a6;
  unint64_t v10 = a6 + 1;
  unsigned int v11 = 1;
  int8x16_t v12 = (int8x16_t)vld1q_dup_f32(a3);
  do
  {
    v10[-1].i64[0] = 0LL;
    v10[-1].i64[1] = 0LL;
    unsigned int v13 = v11++ >> v9;
    *unint64_t v10 = v12;
    v10 += 2;
  }

  while (!v13);
  lzvnEncode((int64_t)v27, v12);
  uint64_t v14 = v28;
  uint64_t v15 = v31;
  char v16 = v32;
  size_t v17 = v28 - v31;
  char v18 = (char *)(v27[0] + v31);
  unint64_t v19 = v34;
  if ((unint64_t)(v28 - v31) < 0x10)
  {
    uint64_t v20 = v32;
    if (!v17)
    {
LABEL_22:
      uint64_t v23 = a5;
LABEL_23:
      if ((unint64_t)v20 < v19)
      {
        uint64_t v15 = v14;
        char v16 = v20;
      }

      goto LABEL_27;
    }
  }

  else
  {
    uint64_t v20 = v32;
    do
    {
      if (v17 >= 0x10F) {
        size_t v21 = 271LL;
      }
      else {
        size_t v21 = v17;
      }
      if ((unint64_t)&v20[v21 + 10] >= v19)
      {
        uint64_t v23 = a5;
        goto LABEL_27;
      }

      *(_WORD *)uint64_t v20 = ((_WORD)v21 << 8) - 3872;
      unsigned int v22 = v20 + 2;
      v17 -= v21;
      memcpy(v22, v18, v21);
      uint64_t v20 = &v22[v21];
      v18 += v21;
    }

    while (v17 > 0xF);
    if (!v17) {
      goto LABEL_22;
    }
  }

  uint64_t v23 = a5;
  if ((unint64_t)&v20[v17 + 10] < v19)
  {
    char *v20 = v17 | 0xE0;
    unsigned int v24 = v20 + 1;
    memcpy(v24, v18, v17);
    uint64_t v20 = &v24[v17];
    goto LABEL_23;
  }

LABEL_27:
  if (v8 >= (unint64_t)(v16 + 8))
  {
    *(void *)char v16 = 6LL;
    v16 += 8;
  }

  *uint64_t v23 = v15;
  return (char *)(v16 - v33);
}

    *((_DWORD *)a1 + 26) = v3;
    *((_DWORD *)a1 + 27) = v4;
    unint64_t result = 4294967294LL;
LABEL_28:
    a1[2] = v5;
    return result;
  }

  return 0LL;
}

    int v9 = v16;
    if (v10 >= a4) {
      return 0LL;
    }
  }

  if (*(_BYTE *)(a3 + v10))
  {
    unsigned int v13 = v10 + 3;
    if (v12 > 2 || v13 > a4) {
      return 0LL;
    }
    uint64_t v15 = (*(unsigned __int8 *)(v10 + a3 + 2) | ((unint64_t)*(unsigned __int8 *)(a3 + v11) << 8)) + 1;
    unint64_t v10 = v15 + v13;
    char v16 = v15 + v9;
    if (v15 + v13 > a4 || v16 > a2) {
      return 0LL;
    }
    memcpy((void *)(a1 + v9), (const void *)(a3 + v13), v15);
    goto LABEL_27;
  }

  *a5 = v11;
LABEL_30:
  if ((v12 & 0x80) != 0) {
    return 0LL;
  }
  return v9;
}

uint64_t zlib_malloc(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a3 * (unint64_t)a2;
  unint64_t v4 = a1[1];
  uint64_t v5 = v4 - v3;
  if (v4 < v3) {
    return 0LL;
  }
  uint64_t v6 = *a1;
  *a1 += v3;
  a1[1] = v5;
  return v6;
}

uint64_t smb_encode_scratch_size(int a1)
{
  uint64_t v1 = 0x10000LL;
  uint64_t v2 = 172392LL;
  if (a1 != 3104) {
    uint64_t v2 = 0LL;
  }
  if (a1 != 3088) {
    uint64_t v1 = v2;
  }
  if (a1 == 3072) {
    return 0x8000LL;
  }
  else {
    return v1;
  }
}

uint64_t smb_decode_scratch_size(int a1)
{
  if (a1 == 3104) {
    return 5632LL;
  }
  else {
    return 0LL;
  }
}

uint64_t smb_encode_buffer(_WORD *a1, unint64_t a2, _BYTE *a3, unint64_t a4, void *a5, int a6)
{
  unsigned int v6 = -16777216;
  if (a4 > 0xFFFFFFFFFF000000LL) {
    return 0LL;
  }
  if (a2 < 0xFFFFFFFFFF000000LL) {
    unsigned int v6 = a2;
  }
  unsigned int v7 = a6 & 0xFFFFFFF0;
  if ((a6 & 0xFFFFFFF0) == 0xC00) {
    return smb_lznt1_encode_buffer(a1, v6, a3, a4, a5);
  }
  if (v7 != 3104)
  {
    if (v7 == 3088) {
      return smb_lz77_encode_buffer((uint64_t)a1, v6, (uint64_t)a3, a4, a5);
    }
    return 0LL;
  }

  return smb_lz77h_encode_buffer((uint64_t)a1, v6, (uint64_t)a3, a4, (char *)a5);
}

uint64_t smb_decode_buffer(char *a1, unint64_t a2, char *a3, unint64_t a4, char *a5, int a6)
{
  unsigned int v6 = a6 & 0xFFFFFFF0;
  if ((a6 & 0xFFFFFFF0) == 0xC20) {
    return smb_lz77h_decode_buffer((uint64_t)a1, a2, (uint64_t)a3, a4, a5);
  }
  if (v6 == 3088) {
    return smb_lz77_decode_buffer((uint64_t)a1, a2, (uint64_t)a3, a4);
  }
  if (v6 == 3072) {
    return smb_lznt1_decode_buffer(a1, a2, a3, a4);
  }
  return 0LL;
}

uint64_t lzbitmap_fast_decode_buffer(uint64_t a1, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t a5)
{
  else {
    return lzbitmap_fast_decode(a1, a2, a3, a4, a5);
  }
}

uint64_t lzbitmap_fast_encode_buffer( uint64_t a1, unint64_t a2, char *a3, unint64_t a4, void *a5, unsigned int a6)
{
  if (HIDWORD(a4)) {
    return 0LL;
  }
  if (a2 >= 0xFFFFFFFF) {
    LODWORD(a2) = -1;
  }
  return lzbitmap_fast_encode(a1, a2, a3, a4, a5, a6);
}

uint64_t lzbitmap_fast_encode_scratch_size(unsigned int a1)
{
  return lzbitmap_fast_encode_state_size(a1);
}

uint64_t lzbitmap_decode_buffer( uint64_t a1, unint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, int32x4_t a9)
{
  if ((a4 | a2) >> 32) {
    return 0LL;
  }
  else {
    return lzbitmap_decode(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t lzbitmap_encode_buffer( int *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unsigned int a6)
{
  if (HIDWORD(a4)) {
    return 0LL;
  }
  if (a2 >= 0xFFFFFFFF) {
    LODWORD(a2) = -1;
  }
  return lzbitmap_encode(a1, a2, a3, a4, a5, a6);
}

uint64_t lzbitmap_decode_scratch_size()
{
  return 8320LL;
}

uint64_t lzbitmap_encode_scratch_size(unsigned int a1)
{
  return lzbitmap_encode_state_size(a1);
}

BOOL lzbitmap_stream_identify_algorithm(_DWORD *a1)
{
  return (*a1 & 0xF0FFFFFF) == 5063258;
}

uint64_t lz4_decode_asm( int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  uint64_t v5 = *a4;
  unsigned int v6 = *a1;
  while (1)
  {
    unsigned int v7 = v6;
    unint64_t v8 = v5;
    unsigned int v10 = *v5;
    int v9 = v5 + 1;
    unint64_t v11 = (unint64_t)v10 >> 4;
    unint64_t v12 = (v10 & 0xF) + 4LL;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        unsigned int v13 = *(unsigned __int8 *)v9;
        int v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255LL)
        {
          uint64_t v14 = (int8x16_t *)v9;
          uint64_t v15 = v6;
          char v16 = (unsigned __int16 *)((char *)v9 + v11);
          size_t v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            int8x16_t v19 = *v14;
            int8x16_t v20 = v14[1];
            char v18 = v14 + 2;
            *uint64_t v15 = v19;
            v15[1] = v20;
            size_t v21 = v15 + 2;
            do
            {
              int8x16_t v22 = *v18;
              int8x16_t v23 = v18[1];
              v18 += 2;
              *size_t v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }

            while (v17 > v21);
            goto LABEL_13;
          }

          goto LABEL_36;
        }
      }

      break;
    }

    *unsigned int v6 = *(int8x16_t *)v9;
    char v16 = (unsigned __int16 *)((char *)v9 + v11);
    size_t v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    unsigned int v25 = *v16;
    uint64_t v5 = (unsigned __int8 *)(v16 + 1);
    unint64_t v24 = v25;
    if (!v25 || (uint64_t v26 = (int8x16_t *)((char *)v17 - v24), (unint64_t)v17 - v24 < a2))
    {
      uint64_t v47 = -1LL;
      goto LABEL_37;
    }

    int64_t v27 = v17;
    unsigned int v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        unsigned int v28 = *v5++;
        unsigned int v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255LL)
        {
          goto LABEL_24;
        }
      }

      break;
    }

    if (v12 > 0x10)
    {
LABEL_24:
      if (v24 > 0x1F)
      {
        int8x16_t v36 = *v26;
        __int128 v35 = v26 + 1;
        *int64_t v27 = v36;
        __int128 v37 = v27 + 1;
        do
        {
          int8x16_t v38 = *v35;
          int8x16_t v39 = v35[1];
          v35 += 2;
          *__int128 v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }

        while (v6 > v37);
      }

      else if (v24 > 0xF)
      {
        int8x16_t v41 = *v26;
        uint64_t v40 = v26 + 1;
        *int64_t v27 = v41;
        int64_t v42 = v27 + 1;
        do
        {
          int8x16_t v44 = *v40;
          uint64_t v43 = v40 + 1;
          *int64_t v42 = v44;
          uint64_t v45 = v42 + 1;
          int8x16_t v46 = *v43;
          uint64_t v40 = v43 + 1;
          *uint64_t v45 = v46;
          int64_t v42 = v45 + 1;
        }

        while (v6 > v42);
      }

      else
      {
        uint64_t v29 = (int8x16_t *)&qword_18104D2C0[4 * v24];
        int8x16_t v30 = vqtbl1q_s8(*v26, *v29);
        int8x16_t v31 = vqtbl1q_s8(*v26, v29[1]);
        uint64_t v32 = *((unsigned __int8 *)qword_18104D4C0 + v24);
        *int64_t v27 = v30;
        v27[1] = v31;
        unsigned int v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          *unsigned int v33 = v30;
          v33[1] = v31;
          uint64_t v34 = (int8x16_t *)((char *)v33 + v32);
          *uint64_t v34 = v30;
          v34[1] = v31;
          unsigned int v33 = (int8x16_t *)((char *)v34 + v32);
        }

        while (v6 > v33);
      }
    }

    else if (v24 <= 0xF)
    {
      *int64_t v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_18104D2C0[4 * v24]);
    }

    else
    {
      *int64_t v27 = *v26;
    }
  }

unint64_t BrotliStoreHuffmanTree( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v33 = 0LL;
  v37[0] = 0LL;
  v37[1] = 0LL;
  __int16 v38 = 0;
  uint64_t v35 = 0LL;
  memset(v34, 0, sizeof(v34));
  BrotliWriteHuffmanTree(a1, a2, &v33, (uint64_t)v40, (uint64_t)v39);
  uint64_t v8 = v33;
  if (v33)
  {
    int v9 = v40;
    do
    {
      unsigned int v10 = *v9++;
      ++*((_DWORD *)v34 + v10);
      --v8;
    }

    while (v8);
  }

  uint64_t v11 = 0LL;
  int v12 = 0;
  uint64_t v13 = 0LL;
  while (!*((_DWORD *)v34 + v13))
  {
LABEL_8:
    if (++v13 == 18) {
      goto LABEL_11;
    }
  }

  if (!v12)
  {
    int v12 = 1;
    uint64_t v11 = v13;
    goto LABEL_8;
  }

  int v12 = 2;
LABEL_11:
  unint64_t v14 = 18LL;
  BrotliCreateHuffmanTree((uint64_t)v34, 18LL, 5, a3, (uint64_t)v37);
  unint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols((unsigned __int8 *)v37, 18LL, (uint64_t)v36);
  if (v12 >= 2)
  {
    uint64_t v16 = 0x11u;
    while (!*((_BYTE *)v37 + BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kStorageOrder[v16]))
    {
      if (--v16 == -1)
      {
        unint64_t v14 = 0LL;
        goto LABEL_17;
      }
    }

    unint64_t v14 = v16 + 1;
  }

unint64_t BrotliBuildAndStoreHuffmanTreeFast( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v92 = *MEMORY[0x1895F89C0];
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  if (!a3) {
    goto LABEL_9;
  }
  unint64_t v14 = 0LL;
  unint64_t v15 = 0LL;
  uint64_t v16 = 8LL;
  do
  {
    uint64_t v17 = *(unsigned int *)(a2 + 4 * v15);
    if ((_DWORD)v17)
    {
      if (v14 <= 3) {
        *((void *)&v90 + v14) = v15;
      }
      ++v14;
      a3 -= v17;
    }

    ++v15;
    v16 += 16LL;
  }

  while (a3);
  unint64_t v18 = v14 - 1;
  if (v14 <= 1)
  {
LABEL_9:
    unint64_t v19 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (1LL << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    v19 += 4LL;
    *a7 = v19;
    uint64_t v20 = v90;
    *(void *)(a8 + (v19 >> 3)) = ((void)v90 << (v19 & 7)) | *(unsigned __int8 *)(a8 + (v19 >> 3));
    *a7 = v19 + a4;
    a5[v20] = 0;
    *(_WORD *)(a6 + 2 * v20) = 0;
    return result;
  }

  uint64_t v89 = result;
  bzero(a5, v15);
  unint64_t result = BrotliAllocate(v89);
  if (!*(_DWORD *)(v89 + 24))
  {
    uint64_t v21 = result;
    uint64_t v88 = a6;
    unsigned int v22 = 1;
    do
    {
      if (v15)
      {
        unint64_t v23 = v15 - 1;
        uint64_t v24 = v21;
        do
        {
          unsigned int v25 = *(_DWORD *)(a2 + 4 * v23);
          if (v25)
          {
            if (v25 < v22) {
              unsigned int v25 = v22;
            }
            *(_DWORD *)uint64_t v24 = v25;
            *(_WORD *)(v24 + 4) = -1;
            *(_WORD *)(v24 + 6) = v23;
            v24 += 8LL;
          }

          --v23;
        }

        while (v23 != -1LL);
      }

      else
      {
        uint64_t v24 = v21;
      }

      unint64_t v26 = (v24 - v21) << 29;
      unint64_t v27 = (int)((v24 - v21) >> 3);
      if (((unint64_t)(v24 - v21) >> 3) > 0xCuLL)
      {
        uint64_t v33 = 2LL * (HIDWORD(v26) < 0x39);
        do
        {
          unint64_t v34 = kBrotliShellGaps[v33];
          if (v34 < v27)
          {
            uint64_t v35 = 0LL;
            unint64_t v36 = kBrotliShellGaps[v33];
            do
            {
              uint64_t v37 = *(void *)(v21 + 8 * v36);
              unint64_t v38 = v36;
              if (v36 >= v34)
              {
                uint64_t v39 = v35;
                unint64_t v40 = v36;
                while (*(_DWORD *)(v21 + v39) > v37)
                {
                  unint64_t v38 = v40 - v34;
                  *(void *)(v21 + 8 * v40) = *(void *)(v21 + v39);
                  v39 -= 8 * v34;
                  unint64_t v40 = v38;
                  if (v38 < v34) {
                    goto LABEL_40;
                  }
                }

                unint64_t v38 = v40;
              }

LABEL_96:
      uint64_t v70 = v71;
      if (v69 >= v15) {
        return result;
      }
    }

    unint64_t v76 = result - 3;
    uint64_t v77 = kNonZeroRepsDepth[v76];
    unint64_t result = (kNonZeroRepsBits[v76] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
    *(void *)(a8 + (v68 >> 3)) = result;
    v68 += v77;
LABEL_91:
    uint64_t v70 = v71;
LABEL_95:
    *a7 = v68;
    uint64_t v71 = v70;
    goto LABEL_96;
  }

  return result;
}

uint64_t BrotliStoreMetaBlock( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, unsigned int *a9, unsigned int a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t *a14, uint64_t a15)
{
  int v15 = a8;
  LODWORD(v94) = a6;
  uint64_t v122 = *MEMORY[0x1895F89C0];
  size_t v18 = a9[19];
  uint64_t v100 = a9[18];
  StoreCompressedMetaBlockHeader(a8, a4, a14, a15);
  uint64_t result = BrotliAllocate(a1);
  uint64_t v99 = a1;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v20 = result;
    uint64_t v21 = a13;
    size_t v23 = *(void *)(a13 + 16);
    unsigned int v22 = *(unsigned int **)(a13 + 24);
    size_t v24 = *(void *)a13;
    size_t v25 = *(void *)(a13 + 8);
    v115[0] = 256LL;
    v115[1] = v24;
    v115[2] = v23;
    v115[3] = (size_t)v22;
    v115[4] = v25;
    __int128 v116 = xmmword_1810C66C0;
    uint64_t v117 = 0LL;
    if (v25) {
      uint64_t v26 = *v22;
    }
    else {
      uint64_t v26 = 0LL;
    }
    uint64_t v118 = v26;
    uint64_t v119 = 0LL;
    unint64_t v121 = 0LL;
    unint64_t v120 = 0LL;
    size_t v28 = *(void *)(a13 + 64);
    unint64_t v27 = *(unsigned int **)(a13 + 72);
    size_t v29 = *(void *)(a13 + 48);
    size_t v30 = *(void *)(a13 + 56);
    v108[0] = 704LL;
    v108[1] = v29;
    v108[2] = v28;
    v108[3] = (size_t)v27;
    v108[4] = v30;
    __int128 v109 = xmmword_1810C66C0;
    uint64_t v110 = 0LL;
    if (v30) {
      uint64_t v31 = *v27;
    }
    else {
      uint64_t v31 = 0LL;
    }
    uint64_t v111 = v31;
    uint64_t v112 = 0LL;
    unint64_t v114 = 0LL;
    unint64_t v113 = 0LL;
    size_t v33 = *(void *)(a13 + 112);
    uint64_t v32 = *(unsigned int **)(a13 + 120);
    size_t v34 = *(void *)(a13 + 96);
    size_t v35 = *(void *)(a13 + 104);
    v101[0] = v18;
    v101[1] = v34;
    v101[2] = v33;
    v101[3] = (size_t)v32;
    v101[4] = v35;
    __int128 v102 = xmmword_1810C66C0;
    uint64_t v103 = 0LL;
    if (v35) {
      uint64_t v36 = *v32;
    }
    else {
      uint64_t v36 = 0LL;
    }
    uint64_t v104 = v36;
    uint64_t v105 = 0LL;
    unint64_t v107 = 0LL;
    unint64_t v106 = 0LL;
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v115, result, a14, a15);
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v108, v20, a14, a15);
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v101, v20, a14, a15);
    uint64_t v37 = a9[16];
    unint64_t v38 = *a14;
    *(void *)(a15 + (*a14 >> 3)) = (v37 << (*a14 & 7)) | *(unsigned __int8 *)(a15 + (*a14 >> 3));
    *a14 = v38 + 2;
    *(void *)(a15 + ((v38 + 2) >> 3)) = ((unint64_t)(a9[17] >> v37) << ((v38 + 2) & 7)) | *(unsigned __int8 *)(a15 + ((v38 + 2) >> 3));
    unint64_t v39 = v38 + 6;
    *a14 = v38 + 6;
    if (*(void *)a13)
    {
      unint64_t v40 = 0LL;
      do
      {
        *(void *)(a15 + (v39 >> 3)) = ((unint64_t)a10 << (v39 & 7)) | *(unsigned __int8 *)(a15 + (v39 >> 3));
        v39 += 2LL;
        *a14 = v39;
        ++v40;
      }

      while (v40 < *(void *)a13);
    }

    unint64_t v41 = *(void *)(a13 + 152);
    if (v41)
    {
      uint64_t result = EncodeContextMap(a1, *(unsigned int **)(a13 + 144), v41, *(void *)(a13 + 184), v20, a14, a15);
      if (*(_DWORD *)(a1 + 24)) {
        return result;
      }
    }

    else
    {
      StoreTrivialContextMap(*(void *)(a13 + 184), 6uLL, v20, a14, a15);
    }

    unint64_t v42 = *(void *)(a13 + 168);
    if (v42)
    {
      uint64_t result = EncodeContextMap(a1, *(unsigned int **)(a13 + 160), v42, *(void *)(a13 + 216), v20, a14, a15);
      if (*(_DWORD *)(a1 + 24)) {
        return result;
      }
    }

    else
    {
      StoreTrivialContextMap(*(void *)(a13 + 216), 2uLL, v20, a14, a15);
    }

    uint64_t v93 = a5;
    int v88 = v15;
    unint64_t v44 = *(void *)(a13 + 176);
    uint64_t v43 = *(void *)(a13 + 184);
    if (v115[0] * v43)
    {
      unint64_t v120 = BrotliAllocate(a1);
      uint64_t result = BrotliAllocate(a1);
    }

    else
    {
      uint64_t result = 0LL;
      unint64_t v120 = 0LL;
    }

    unint64_t v121 = result;
    int v45 = *(_DWORD *)(a1 + 24);
    if (v43 && !v45)
    {
      for (uint64_t i = 0LL; i != v43; ++i)
      {
        uint64_t result = BuildAndStoreHuffmanTree( v44,  v115[0],  256LL,  v20,  (_BYTE *)(v120 + v115[0] * i),  v121 + 2 * v115[0] * i,  a14,  a15);
        v44 += 1040LL;
      }

      int v45 = *(_DWORD *)(a1 + 24);
    }

    if (!v45)
    {
      unint64_t v48 = *(void *)(a13 + 192);
      uint64_t v47 = *(void *)(a13 + 200);
      if (v108[0] * v47)
      {
        unint64_t v113 = BrotliAllocate(a1);
        uint64_t result = BrotliAllocate(a1);
        int v49 = *(_DWORD *)(a1 + 24);
      }

      else
      {
        int v49 = 0;
        uint64_t result = 0LL;
        unint64_t v113 = 0LL;
      }

      unint64_t v114 = result;
      if (v47 && !v49)
      {
        for (uint64_t j = 0LL; j != v47; ++j)
        {
          uint64_t result = BuildAndStoreHuffmanTree( v48,  v108[0],  704LL,  v20,  (_BYTE *)(v113 + v108[0] * j),  v114 + 2 * v108[0] * j,  a14,  a15);
          v48 += 2832LL;
        }

        int v49 = *(_DWORD *)(a1 + 24);
      }

      if (!v49)
      {
        unint64_t v52 = *(void *)(a13 + 208);
        uint64_t v51 = *(void *)(a13 + 216);
        if (v101[0] * v51)
        {
          unint64_t v106 = BrotliAllocate(a1);
          uint64_t result = BrotliAllocate(a1);
          int v53 = *(_DWORD *)(a1 + 24);
        }

        else
        {
          int v53 = 0;
          uint64_t result = 0LL;
          unint64_t v106 = 0LL;
        }

        unint64_t v107 = result;
        if (v51 && !v53)
        {
          for (uint64_t k = 0LL; k != v51; ++k)
          {
            uint64_t result = BuildAndStoreHuffmanTree( v52,  v101[0],  v100,  v20,  (_BYTE *)(v106 + v101[0] * k),  v107 + 2 * v101[0] * k,  a14,  a15);
            v52 += 2192LL;
          }

          int v53 = *(_DWORD *)(a1 + 24);
        }

        if (!v53)
        {
          BrotliFree(a1, v20);
          if (a12)
          {
            uint64_t v55 = 0LL;
            uint64_t v94 = v94;
            uint64_t v56 = a7;
            unint64_t v57 = &_kBrotliContextLookupTable[512 * a10 + 256];
            do
            {
              uint64_t v96 = v55;
              uint64_t v58 = (unsigned int *)(a11 + 16 * v55);
              uint64_t v60 = *v58;
              unsigned int v59 = v58[1];
              uint64_t v89 = v58[2];
              unint64_t v90 = *((unsigned __int16 *)v58 + 7);
              uint64_t v91 = *((unsigned __int16 *)v58 + 6);
              StoreSymbol(v108, v91, a14, a15);
              LOWORD(v61) = v60;
              if (v60 >= 6)
              {
                if (v60 > 0x81)
                {
                  if (v60 > 0x841)
                  {
                    __int16 v63 = 22;
                    LOWORD(v61) = 21;
                  }

                  else
                  {
                    LODWORD(v61) = (__clz(v60 - 66) ^ 0x1F) + 10;
                  }
                }

                else
                {
                  unsigned int v62 = (__clz(v60 - 2) ^ 0x1F) - 1;
                  unint64_t v61 = 2 * v62 + ((unint64_t)(v60 - 2) >> v62) + 2;
                }
              }

              uint64_t v64 = (v59 & 0x1FFFFFF) + (char)(HIBYTE(v59) & 0x80 | (v59 >> 25));
              uint64_t v92 = v59 & 0x1FFFFFF;
              if (v64 > 9)
              {
                uint64_t v66 = v93;
                if (v64 > 0x85)
                {
                  LODWORD(v65) = (__clz(v64 - 70) ^ 0x1F) + 12;
                }

                else
                {
                  unsigned int v67 = (__clz(v64 - 6) ^ 0x1F) - 1;
                  unint64_t v65 = 2 * v67 + ((unint64_t)(v64 - 6) >> v67) + 4;
                }
              }

              else
              {
                LOWORD(v65) = v59 + (char)(HIBYTE(v59) & 0x80 | (v59 >> 25)) - 2;
                uint64_t v66 = v93;
              }

              uint64_t v68 = 4LL * (unsigned __int16)v61;
              int v69 = *(_DWORD *)((char *)&kBrotliInsExtra + v68);
              uint64_t v70 = 4LL * (unsigned __int16)v65;
              unint64_t v71 = ((unint64_t)(v64 - *(_DWORD *)((char *)&kBrotliCopyBase + v70)) << v69) | (v60 - *(_DWORD *)((char *)&kBrotliInsBase + v68));
              uint64_t v72 = (*(_DWORD *)((char *)&kBrotliCopyExtra + v70) + v69);
              unint64_t v73 = *a14;
              *(void *)(a15 + (*a14 >> 3)) = (v71 << (*(_BYTE *)a14 & 7)) | *(unsigned __int8 *)(a15 + (*a14 >> 3));
              *a14 = v73 + v72;
              if (*(void *)(v21 + 152))
              {
                uint64_t v74 = v66;
                uint64_t v75 = v56;
                unint64_t v76 = v57;
                uint64_t v77 = a3;
                uint64_t v78 = v94;
                if ((_DWORD)v60)
                {
                  do
                  {
                    uint64_t v75 = v78;
                    uint64_t v79 = (v76[v56] | _kBrotliContextLookupTable[512 * a10 + v78]);
                    uint64_t v78 = *(unsigned __int8 *)(a2 + (v77 & v74));
                    StoreSymbolWithContext(v115, v78, v79, *(void *)(a13 + 144), a14, a15, 6);
                    ++v77;
                    uint64_t v56 = v75;
                    --v60;
                  }

                  while (v60);
                }
              }

              else
              {
                unint64_t v76 = v57;
                if ((_DWORD)v60)
                {
                  uint64_t v77 = a3;
                  do
                  {
                    StoreSymbol(v115, *(unsigned __int8 *)(a2 + (v77++ & v66)), a14, a15);
                    --v60;
                  }

                  while (v60);
                  uint64_t v75 = v56;
                }

                else
                {
                  uint64_t v75 = v56;
                  uint64_t v77 = a3;
                }

                uint64_t v78 = v94;
              }

              uint64_t v94 = v78;
              a3 = v77 + v92;
              uint64_t v21 = a13;
              unint64_t v57 = v76;
              if ((_DWORD)v92)
              {
                uint64_t v75 = *(unsigned __int8 *)(a2 + ((a3 - 2) & v93));
                uint64_t v94 = *(unsigned __int8 *)(a2 + ((a3 - 1) & v93));
                if (v91 >= 0x80)
                {
                  uint64_t v80 = v90 & 0x3FF;
                  if (*(void *)(a13 + 168))
                  {
                    unsigned int v81 = v91 >> 6;
                    else {
                      uint64_t v85 = v91 & 7;
                    }
                    StoreSymbolWithContext(v101, v80, v85, *(void *)(a13 + 160), a14, a15, 2);
                  }

                  else
                  {
                    StoreSymbol(v101, v80, a14, a15);
                  }

                  unint64_t v86 = *a14;
                  *(void *)(a15 + (*a14 >> 3)) = (v89 << (*a14 & 7)) | *(unsigned __int8 *)(a15 + (*a14 >> 3));
                  *a14 = v86 + (v90 >> 10);
                }
              }

              uint64_t v55 = v96 + 1;
              uint64_t v56 = v75;
            }

            while (v96 + 1 != a12);
          }

          BrotliFree(v99, v106);
          unint64_t v106 = 0LL;
          BrotliFree(v99, v107);
          unint64_t v107 = 0LL;
          BrotliFree(v99, v113);
          unint64_t v113 = 0LL;
          BrotliFree(v99, v114);
          unint64_t v114 = 0LL;
          BrotliFree(v99, v120);
          unint64_t v120 = 0LL;
          uint64_t result = BrotliFree(v99, v121);
          if (v88)
          {
            unsigned int v87 = *(_DWORD *)a14 + 7;
            *a14 = v87 & 0xFFFFFFF8;
            *(_BYTE *)(a15 + (v87 >> 3)) = 0;
          }
        }
      }
    }
  }

  return result;
}

uint64_t StoreCompressedMetaBlockHeader(uint64_t result, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = ((uint64_t)(int)result << (*(_BYTE *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
  unint64_t v5 = v4 + 1;
  *a3 = v4 + 1;
  if ((_DWORD)result)
  {
    *(void *)(a4 + (v5 >> 3)) = *(unsigned __int8 *)(a4 + (v5 >> 3));
    *a3 = v4 + 2;
    if (a2 == 1 || (unsigned int v6 = __clz(a2 - 1) ^ 0x1F, v6 <= 0xE)) {
      uint64_t v7 = 4LL;
    }
    else {
      uint64_t v7 = (v6 + 4) >> 2;
    }
    *(void *)(a4 + ((v4 + 2) >> 3)) = ((v7 - 4) << ((v4 + 2) & 7)) | *(unsigned __int8 *)(a4 + ((v4 + 2) >> 3));
    unint64_t v10 = v4 + 4;
    *a3 = v10;
    *(void *)(a4 + (v10 >> 3)) = ((a2 - 1) << (v10 & 7)) | *(unsigned __int8 *)(a4 + (v10 >> 3));
    unint64_t v11 = v10 + 4 * v7;
  }

  else
  {
    if (a2 == 1 || (unsigned int v8 = __clz(a2 - 1) ^ 0x1F, v8 <= 0xE)) {
      uint64_t v9 = 4LL;
    }
    else {
      uint64_t v9 = (v8 + 4) >> 2;
    }
    *(void *)(a4 + (v5 >> 3)) = ((v9 - 4) << (v5 & 7)) | *(unsigned __int8 *)(a4 + (v5 >> 3));
    unint64_t v12 = v4 + 3;
    *a3 = v12;
    *(void *)(a4 + (v12 >> 3)) = ((a2 - 1) << (v12 & 7)) | *(unsigned __int8 *)(a4 + (v12 >> 3));
    unint64_t v13 = v12 + 4 * v9;
    *a3 = v13;
    *(void *)(a4 + (v13 >> 3)) = *(unsigned __int8 *)(a4 + (v13 >> 3));
    unint64_t v11 = v13 + 1;
  }

  *a3 = v11;
  return result;
}

unint64_t BuildAndStoreBlockSwitchEntropyCodes( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v7 = *(unsigned int **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned __int8 **)(a1 + 16);
  bzero(v40, 4 * (v10 + 2));
  uint64_t v39 = 0LL;
  memset(v38, 0, sizeof(v38));
  if (v8)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    uint64_t v13 = 1LL;
    do
    {
      uint64_t v14 = v13;
      uint64_t v13 = v9[v11];
      if (v11)
      {
        if (v12 == v13) {
          uint64_t v15 = 0LL;
        }
        else {
          uint64_t v15 = v13 + 2;
        }
        if (v14 + 1 == v13) {
          uint64_t v15 = 1LL;
        }
        ++v40[v15];
      }

      unsigned int v16 = v7[v11];
      if (v16 <= 0x2F0) {
        uint64_t v17 = 14LL;
      }
      else {
        uint64_t v17 = 20LL;
      }
      if (v16 <= 0x28) {
        uint64_t v18 = 0LL;
      }
      else {
        uint64_t v18 = 7LL;
      }
      if (v16 <= 0xB0) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v17;
      }
      unint64_t v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v19 + 4);
      do
      {
        unsigned int v21 = v19;
        if (v19 == 25) {
          break;
        }
        ++v19;
        unsigned int v22 = *v20;
        v20 += 2;
      }

      while (v16 >= v22);
      ++*((_DWORD *)v38 + v21);
      ++v11;
      uint64_t v12 = v14;
    }

    while (v11 != v8);
  }

  unint64_t result = StoreVarLenUint8(v10 - 1, a3, a4);
  if (v10 >= 2)
  {
    BuildAndStoreHuffmanTree((unint64_t)v40, v10 + 2, v10 + 2, a2, (_BYTE *)(a1 + 56), a1 + 314, a3, a4);
    unint64_t result = BuildAndStoreHuffmanTree((unint64_t)v38, 0x1AuLL, 26LL, a2, (_BYTE *)(a1 + 830), a1 + 856, a3, a4);
    unsigned int v24 = *v7;
    uint64_t v25 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = *v9;
    *(void *)(a1 + 48) = v25;
    uint64_t v26 = 14LL;
    if (v24 > 0x2F0) {
      uint64_t v26 = 20LL;
    }
    uint64_t v27 = 7LL;
    if (v24 <= 0x28) {
      uint64_t v27 = 0LL;
    }
    if (v24 <= 0xB0) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = v26;
    }
    size_t v29 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v28 + 4);
    do
    {
      unsigned int v30 = v28;
      if (v28 == 25) {
        break;
      }
      ++v28;
      unsigned int v31 = *v29;
      v29 += 2;
    }

    while (v24 >= v31);
    uint64_t v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v30);
    uint64_t v33 = *((unsigned __int8 *)v32 + 2);
    uint64_t v34 = v24 - *v32;
    uint64_t v35 = *(unsigned __int8 *)(a1 + 40 + v30 + 790);
    unint64_t v36 = *a3;
    *(void *)(a4 + (*a3 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a1 + 40 + 2LL * v30 + 816) << (*(_BYTE *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
    *a3 = v36 + v35;
    *(void *)(a4 + ((v36 + v35) >> 3)) = (v34 << ((v36 + v35) & 7)) | *(unsigned __int8 *)(a4 + ((v36 + v35) >> 3));
    *a3 = v36 + v35 + v33;
  }

  return result;
}

unint64_t StoreTrivialContextMap( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  unint64_t result = StoreVarLenUint8(a1 - 1, a4, a5);
  if (a1 >= 2)
  {
    unint64_t v11 = a2 - 1;
    unint64_t v12 = a2 - 1 + a1;
    bzero(v24, 4 * v12);
    unint64_t v13 = *a4;
    *(void *)(a5 + (*a4 >> 3)) = (1LL << (*a4 & 7)) | *(unsigned __int8 *)(a5 + (*a4 >> 3));
    *a4 = v13 + 1;
    *(void *)(a5 + ((v13 + 1) >> 3)) = ((a2 - 2) << ((v13 + 1) & 7)) | *(unsigned __int8 *)(a5 + ((v13 + 1) >> 3));
    *a4 = v13 + 5;
    v24[a2 - 1] = a1;
    v24[0] = 1;
    if (v12 > a2) {
      memset_pattern16(&v24[a2], &unk_181097240, 4 * a1 - 4);
    }
    unint64_t result = BuildAndStoreHuffmanTree((unint64_t)v24, a2 - 1 + a1, a2 - 1 + a1, a3, v23, (uint64_t)v22, a4, a5);
    uint64_t v14 = 0LL;
    uint64_t v15 = v23[v11];
    uint64_t v16 = (unsigned __int16)v22[v11];
    unint64_t v17 = *a4;
    do
    {
      uint64_t v18 = v11 + v14;
      if (!v14) {
        uint64_t v18 = 0LL;
      }
      uint64_t v19 = v23[v18];
      *(void *)(a5 + (v17 >> 3)) = ((unint64_t)(unsigned __int16)v22[v18] << (v17 & 7)) | *(unsigned __int8 *)(a5 + (v17 >> 3));
      unint64_t v20 = v17 + v19;
      *a4 = v20;
      *(void *)(a5 + (v20 >> 3)) = (v16 << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
      uint64_t v21 = v20 + v15;
      *a4 = v20 + v15;
      *(void *)(a5 + ((v20 + v15) >> 3)) = ((unint64_t)~(-1 << (a2 - 1)) << ((v20 + v15) & 7)) | *(unsigned __int8 *)(a5 + ((v20 + v15) >> 3));
      unint64_t v17 = v21 + v11;
      *a4 = v21 + v11;
      ++v14;
    }

    while (a1 != v14);
    *(void *)(a5 + (v17 >> 3)) = (1LL << (v17 & 7)) | *(unsigned __int8 *)(a5 + (v17 >> 3));
    *a4 = v21 + a2;
  }

  return result;
}

uint64_t EncodeContextMap( uint64_t a1, unsigned int *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v10 = a4;
  *(void *)&v59[1087] = *MEMORY[0x1895F89C0];
  uint64_t result = StoreVarLenUint8(a4 - 1, a6, a7);
  if (v10 == 1) {
    return result;
  }
  uint64_t result = BrotliAllocate(a1);
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v15 = result;
  unsigned int v16 = *a2;
  if (a3 >= 2)
  {
    unint64_t v17 = a3 - 1;
    uint64_t v18 = a2 + 1;
    do
    {
      unsigned int v20 = *v18++;
      unsigned int v19 = v20;
      if (v20 > v16) {
        unsigned int v16 = v19;
      }
      --v17;
    }

    while (v17);
  }

  uint64_t v21 = 0LL;
  do
  {
    v59[v21 - 1] = v21;
    ++v21;
  }

  while (v16 + 1LL != v21);
  if (!a3) {
    goto LABEL_44;
  }
  uint64_t v53 = v10;
  uint64_t v54 = a5;
  uint64_t v55 = a1;
  uint64_t v22 = 0LL;
  size_t v23 = v16 + 1;
  LOBYTE(a1) = __src;
  do
  {
    if ((_DWORD)v23)
    {
      size_t v24 = 0LL;
      LODWORD(a1) = LOBYTE(a2[v22]);
      while (v59[v24 - 1] != (_DWORD)a1)
      {
        if (v23 == ++v24)
        {
          LOBYTE(a1) = v59[v23 - 1];
          size_t v24 = v23;
          break;
        }
      }

      *(_DWORD *)(v15 + 4 * v22) = v24;
      if (v24) {
        memmove(v59, &__src, v24);
      }
    }

    else
    {
      *(_DWORD *)(v15 + 4 * v22) = 0;
    }

    char __src = a1;
    ++v22;
  }

  while (v22 != a3);
  unsigned int v25 = 0;
  unint64_t v26 = 0LL;
  a5 = v54;
  a1 = v55;
  uint64_t v10 = v53;
  do
  {
    if (a3 <= v26 + 1) {
      unint64_t v27 = v26 + 1;
    }
    else {
      unint64_t v27 = a3;
    }
    uint64_t v28 = (_DWORD *)(v15 + 4 * v26);
    while (*(_DWORD *)(v15 + 4 * v26))
    {
      ++v26;
      ++v28;
      if (v27 == v26)
      {
        unsigned int v32 = 0;
LABEL_40:
        if (v32 > v25) {
          unsigned int v25 = v32;
        }
        goto LABEL_42;
      }
    }

    if (a3 <= v26)
    {
      unsigned int v31 = 0;
    }

    else
    {
      uint64_t v29 = 0LL;
      while (!*v28++)
      {
        if (v26 - a3 == --v29)
        {
          unsigned int v32 = a3 - v26;
          goto LABEL_40;
        }
      }

      v26 -= v29;
      unsigned int v31 = -(int)v29;
    }

    if (v31 > v25) {
      unsigned int v25 = v31;
    }
  }

  while (v26 < a3);
LABEL_42:
  if (v25) {
    unsigned int v33 = __clz(v25) ^ 0x1F;
  }
  else {
LABEL_44:
  }
    unsigned int v33 = 0;
  if (v33 >= 6) {
    unsigned int v34 = 6;
  }
  else {
    unsigned int v34 = v33;
  }
  if (!a3)
  {
    bzero(&__src, 0x440uLL);
    uint64_t v35 = 0LL;
LABEL_72:
    BOOL v43 = 1;
    goto LABEL_73;
  }

  uint64_t v35 = 0LL;
  unint64_t v36 = 0LL;
  unsigned int v37 = 2 << v34;
  do
  {
    int v38 = *(_DWORD *)(v15 + 4 * v36);
    if (v38)
    {
      *(_DWORD *)(v15 + 4 * v35) = v38 + v34;
      ++v36;
LABEL_52:
      ++v35;
      continue;
    }

    if (v36 + 1 >= a3)
    {
      unsigned int v39 = 1;
      ++v36;
      goto LABEL_63;
    }

    unsigned int v39 = a3 - v36;
    uint64_t v40 = 1LL;
    while (!*(_DWORD *)(v15 + 4 * v36 + 4 * v40))
    {
      if (a3 - v36 == ++v40) {
        goto LABEL_62;
      }
    }

    unsigned int v39 = v40;
LABEL_62:
    v36 += v39;
    if (v39)
    {
LABEL_63:
      while (1)
      {
        unsigned int v41 = v39 - v37;
        if (v39 < v37) {
          break;
        }
        *(_DWORD *)(v15 + 4 * v35++) = v34 | (~(-1 << v34) << 9);
        unsigned int v39 = v41 + 1;
        if (v41 == -1) {
          goto LABEL_53;
        }
      }

      unsigned int v42 = __clz(v39);
      *(_DWORD *)(v15 + 4 * v35) = v42 ^ 0x1F | (((-1 << (v42 ^ 0x1F)) + v39) << 9);
      goto LABEL_52;
    }

LABEL_53:
    ;
  }

  while (v36 < a3);
  bzero(&__src, 0x440uLL);
  BOOL v43 = v35 == 0;
  if (!v35) {
    goto LABEL_72;
  }
  for (uint64_t i = 0LL; i != v35; ++i)
  {
    uint64_t v45 = *(_DWORD *)(v15 + 4 * i) & 0x1FF;
    ++*(_DWORD *)&v59[4 * v45 - 1];
  }

        if (v8 - 1 < *(void *)(a1 + 64) - *(void *)a1) {
          continue;
        }
      }
    }

    break;
  }

void *StoreSymbol(void *result, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4 = result[115];
  if (!v4)
  {
    uint64_t v5 = result[114] + 1LL;
    result[114] = v5;
    uint64_t v6 = *(unsigned int *)(result[3] + 4 * v5);
    uint64_t v7 = *(unsigned __int8 *)(result[2] + v5);
    result[115] = v6;
    result[116] = *result * v7;
    uint64_t v8 = result[5];
    if (v8 + 1 == v7)
    {
      uint64_t v9 = 1LL;
    }

    else if (result[6] == v7)
    {
      uint64_t v9 = 0LL;
    }

    else
    {
      uint64_t v9 = v7 + 2;
    }

    result[5] = v7;
    result[6] = v8;
    uint64_t v10 = *((unsigned __int8 *)result + v9 + 56);
    uint64_t v11 = *((unsigned __int16 *)result + v9 + 157);
    unint64_t v12 = *a3;
    *(void *)(a4 + (*a3 >> 3)) = (v11 << (*(_BYTE *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
    unint64_t v13 = v12 + v10;
    *a3 = v13;
    uint64_t v14 = 14LL;
    uint64_t v15 = 7LL;
    else {
      uint64_t v16 = v14;
    }
    unint64_t v17 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v16 + 4);
    do
    {
      unsigned int v18 = v16;
      if (v16 == 25) {
        break;
      }
      ++v16;
      unsigned int v19 = *v17;
      v17 += 2;
    }

    while (v6 >= v19);
    unsigned int v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v18);
    uint64_t v21 = *((unsigned __int8 *)v20 + 2);
    uint64_t v22 = v6 - *v20;
    uint64_t v23 = *((unsigned __int8 *)result + v18 + 830);
    *(void *)(a4 + (v13 >> 3)) = ((unint64_t)*((unsigned __int16 *)result + v18 + 428) << (v13 & 7)) | *(unsigned __int8 *)(a4 + (v13 >> 3));
    unint64_t v24 = v13 + v23;
    *a3 = v24;
    *(void *)(a4 + (v24 >> 3)) = (v22 << (v24 & 7)) | *(unsigned __int8 *)(a4 + (v24 >> 3));
    *a3 = v24 + v21;
    uint64_t v4 = result[115];
  }

  result[115] = v4 - 1;
  uint64_t v25 = result[116] + a2;
  uint64_t v26 = *(unsigned __int8 *)(result[117] + v25);
  unint64_t v27 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = ((unint64_t)*(unsigned __int16 *)(result[118] + 2 * v25) << (*(_BYTE *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
  *a3 = v27 + v26;
  return result;
}

void *StoreSymbolWithContext( void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, char a7)
{
  uint64_t v7 = result[115];
  if (!v7)
  {
    uint64_t v8 = result[114] + 1LL;
    result[114] = v8;
    uint64_t v9 = *(unsigned int *)(result[3] + 4 * v8);
    uint64_t v10 = *(unsigned __int8 *)(result[2] + v8);
    result[115] = v9;
    result[116] = v10 << a7;
    uint64_t v11 = result[5];
    if (v11 + 1 == v10)
    {
      uint64_t v12 = 1LL;
    }

    else if (result[6] == v10)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v12 = v10 + 2;
    }

    result[5] = v10;
    result[6] = v11;
    uint64_t v13 = *((unsigned __int8 *)result + v12 + 56);
    uint64_t v14 = *((unsigned __int16 *)result + v12 + 157);
    unint64_t v15 = *a5;
    *(void *)(a6 + (*a5 >> 3)) = (v14 << (*(_BYTE *)a5 & 7)) | *(unsigned __int8 *)(a6 + (*a5 >> 3));
    unint64_t v16 = v15 + v13;
    *a5 = v16;
    uint64_t v17 = 14LL;
    uint64_t v18 = 7LL;
    else {
      uint64_t v19 = v17;
    }
    unsigned int v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v19 + 4);
    do
    {
      unsigned int v21 = v19;
      if (v19 == 25) {
        break;
      }
      ++v19;
      unsigned int v22 = *v20;
      v20 += 2;
    }

    while (v9 >= v22);
    uint64_t v23 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v21);
    uint64_t v24 = *((unsigned __int8 *)v23 + 2);
    uint64_t v25 = v9 - *v23;
    uint64_t v26 = *((unsigned __int8 *)result + v21 + 830);
    *(void *)(a6 + (v16 >> 3)) = ((unint64_t)*((unsigned __int16 *)result + v21 + 428) << (v16 & 7)) | *(unsigned __int8 *)(a6 + (v16 >> 3));
    unint64_t v27 = v16 + v26;
    *a5 = v27;
    *(void *)(a6 + (v27 >> 3)) = (v25 << (v27 & 7)) | *(unsigned __int8 *)(a6 + (v27 >> 3));
    *a5 = v27 + v24;
    uint64_t v7 = result[115];
  }

  result[115] = v7 - 1;
  uint64_t v28 = a2 + *result * *(unsigned int *)(a4 + 4 * (result[116] + a3));
  uint64_t v29 = *(unsigned __int8 *)(result[117] + v28);
  unint64_t v30 = *a5;
  *(void *)(a6 + (*a5 >> 3)) = ((unint64_t)*(unsigned __int16 *)(result[118] + 2 * v28) << (*(_BYTE *)a5 & 7)) | *(unsigned __int8 *)(a6 + (*a5 >> 3));
  *a5 = v30 + v29;
  return result;
}

uint64_t BrotliStoreMetaBlockTrivial( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1895F8858]();
  uint64_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  uint64_t v21 = v20;
  uint64_t v22 = v11;
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v29 = *(unsigned int *)(v23 + 72);
  StoreCompressedMetaBlockHeader(v14, v24, a10, a11);
  bzero(v34, 0x408uLL);
  v34[129] = 0x7FF0000000000000LL;
  bzero(v32, 0xB08uLL);
  uint64_t v33 = 0x7FF0000000000000LL;
  bzero(v30, 0x888uLL);
  uint64_t v31 = 0x7FF0000000000000LL;
  BuildHistograms(v21, v19, v17, v13, a9, (uint64_t)v34, (uint64_t)v32, (uint64_t)v30);
  unint64_t v25 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v25 + 13;
  uint64_t result = BrotliAllocate(v22);
  if (!*(_DWORD *)(v22 + 24))
  {
    unint64_t v27 = result;
    BuildAndStoreHuffmanTree((unint64_t)v34, 0x100uLL, 256LL, result, v40, (uint64_t)v39, a10, a11);
    BuildAndStoreHuffmanTree((unint64_t)v32, 0x2C0uLL, 704LL, v27, v38, (uint64_t)v37, a10, a11);
    BuildAndStoreHuffmanTree((unint64_t)v30, 0x8CuLL, v29, v27, v36, (uint64_t)v35, a10, a11);
    BrotliFree(v22, v27);
    uint64_t result = StoreDataWithHuffmanCodes( v21,  v19,  v17,  v13,  a9,  (uint64_t)v40,  (uint64_t)v39,  (uint64_t)v38,  (uint64_t)v37,  (uint64_t)v36,  (uint64_t)v35,  a10,  a11);
    if (v15)
    {
      unsigned int v28 = *(_DWORD *)a10 + 7;
      *a10 = v28 & 0xFFFFFFF8;
      *(_BYTE *)(a11 + (v28 >> 3)) = 0;
    }
  }

  return result;
}

uint64_t BuildHistograms( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = *(void *)(a7 + 2816);
    do
    {
      uint64_t v10 = (unsigned int *)(a4 + 16 * v8);
      uint64_t v12 = *v10;
      unsigned int v11 = v10[1];
      uint64_t v13 = *((unsigned __int16 *)v10 + 6);
      __int16 v14 = *((_WORD *)v10 + 7);
      ++*(_DWORD *)(a7 + 4 * v13);
      *(void *)(a7 + 2816) = ++v9;
      if ((_DWORD)v12)
      {
        uint64_t v15 = *(void *)(a6 + 1024) + 1LL;
        do
        {
          ++*(_DWORD *)(a6 + 4LL * *(unsigned __int8 *)(result + (a2 & a3)));
          *(void *)(a6 + 1024) = v15;
          ++a2;
          ++v15;
          --v12;
        }

        while (v12);
      }

      uint64_t v16 = v11 & 0x1FFFFFF;
      if ((_DWORD)v16)
      {
        if (v13 >= 0x80)
        {
          ++*(_DWORD *)(a8 + 4LL * (v14 & 0x3FF));
          ++*(void *)(a8 + 2176);
        }
      }

      a2 += v16;
      ++v8;
    }

    while (v8 != a5);
  }

  return result;
}

unint64_t BuildAndStoreHuffmanTree( unint64_t result, size_t a2, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v14 = result;
  uint64_t v46 = *MEMORY[0x1895F89C0];
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  if (a2)
  {
    uint64_t v15 = 0LL;
    unint64_t v16 = 0LL;
    do
    {
      if (*(_DWORD *)(result + 4 * v15))
      {
        if (v16 > 3)
        {
          if (v16 != 4) {
            break;
          }
        }

        else
        {
          *((void *)&v44 + v16) = v15;
        }

        ++v16;
      }

      ++v15;
    }

    while (a2 != v15);
  }

  else
  {
    unint64_t v16 = 0LL;
  }

  uint64_t v17 = 0LL;
  unint64_t v18 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      ++v17;
      BOOL v19 = v18 > 1;
      v18 >>= 1;
    }

    while (v19);
  }

  unint64_t v20 = v16 - 1;
  if (v16 <= 1)
  {
    unint64_t v21 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (1LL << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    v21 += 4LL;
    *a7 = v21;
    uint64_t v22 = v44;
    *(void *)(a8 + (v21 >> 3)) = ((void)v44 << (v21 & 7)) | *(unsigned __int8 *)(a8 + (v21 >> 3));
    *a7 = v21 + v17;
    a5[v22] = 0;
    *(_WORD *)(a6 + 2 * v22) = 0;
    return result;
  }

  bzero(a5, a2);
  BrotliCreateHuffmanTree(v14, a2, 15, a4, (uint64_t)a5);
  uint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols(a5, a2, a6);
  if (v16 > 4) {
    return BrotliStoreHuffmanTree((uint64_t)a5, a2, a4, a7, a8);
  }
  uint64_t v23 = 0LL;
  unint64_t v24 = *a7;
  *(void *)(a8 + (*a7 >> 3)) = (1LL << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
  *a7 = v24 + 2;
  *(void *)(a8 + ((v24 + 2) >> 3)) = (v20 << ((v24 + 2) & 7)) | *(unsigned __int8 *)(a8 + ((v24 + 2) >> 3));
  unint64_t v25 = v24 + 4;
  *a7 = v25;
  uint64_t v26 = (char *)&v44 + 8;
  do
  {
    uint64_t v27 = v23 + 1;
    if (v23 + 1 < v16)
    {
      uint64_t v28 = *((void *)&v44 + v23);
      uint64_t v29 = (uint64_t *)v26;
      unint64_t v30 = v20;
      do
      {
        uint64_t v31 = *v29;
        uint64_t result = a5[v28];
        if (a5[*v29] < result)
        {
          *uint64_t v29 = v28;
          *((void *)&v44 + v23) = v31;
          uint64_t v28 = v31;
        }

        ++v29;
        --v30;
      }

      while (v30);
    }

    --v20;
    v26 += 8;
    ++v23;
  }

  while (v27 != v16);
  unint64_t v32 = v25 >> 3;
  if (v16 == 3)
  {
    uint64_t v35 = *((void *)&v44 + 1);
    *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
    unint64_t v36 = v25 + v17;
    *a7 = v36;
    *(void *)(a8 + (v36 >> 3)) = (v35 << (v36 & 7)) | *(unsigned __int8 *)(a8 + (v36 >> 3));
    unint64_t v34 = v36 + v17;
    *a7 = v34;
    *(void *)(a8 + (v34 >> 3)) = ((void)v45 << (v34 & 7)) | *(unsigned __int8 *)(a8 + (v34 >> 3));
  }

  else
  {
    if (v16 != 2)
    {
      __int128 v38 = v44;
      *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
      unint64_t v39 = v25 + v17;
      *a7 = v39;
      *(void *)(a8 + (v39 >> 3)) = (*((void *)&v38 + 1) << (v39 & 7)) | *(unsigned __int8 *)(a8 + (v39 >> 3));
      unint64_t v40 = v39 + v17;
      *a7 = v40;
      uint64_t v41 = *((void *)&v45 + 1);
      *(void *)(a8 + (v40 >> 3)) = ((void)v45 << (v40 & 7)) | *(unsigned __int8 *)(a8 + (v40 >> 3));
      unint64_t v42 = v40 + v17;
      *a7 = v42;
      *(void *)(a8 + (v42 >> 3)) = (v41 << (v42 & 7)) | *(unsigned __int8 *)(a8 + (v42 >> 3));
      unint64_t v43 = v42 + v17;
      *a7 = v43;
      *(void *)(a8 + (v43 >> 3)) = ((unint64_t)(a5[v38] == 1) << (v43 & 7)) | *(unsigned __int8 *)(a8 + (v43 >> 3));
      unint64_t v37 = v43 + 1;
      goto LABEL_30;
    }

    uint64_t v33 = *((void *)&v44 + 1);
    *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
    unint64_t v34 = v25 + v17;
    *a7 = v34;
    *(void *)(a8 + (v34 >> 3)) = (v33 << (v34 & 7)) | *(unsigned __int8 *)(a8 + (v34 >> 3));
  }

  unint64_t v37 = v34 + v17;
LABEL_30:
  *a7 = v37;
  return result;
}

uint64_t StoreDataWithHuffmanCodes( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t *a12, uint64_t a13)
{
  if (a5)
  {
    uint64_t v13 = 0LL;
    unint64_t v14 = *a12;
    do
    {
      uint64_t v15 = (unsigned int *)(a4 + 16 * v13);
      uint64_t v16 = *v15;
      unsigned int v17 = v15[1];
      uint64_t v18 = v15[2];
      uint64_t v19 = *((unsigned __int16 *)v15 + 6);
      unint64_t v20 = *((unsigned __int16 *)v15 + 7);
      uint64_t v21 = *(unsigned __int8 *)(a8 + v19);
      *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a9 + 2 * v19) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
      unint64_t v22 = v14 + v21;
      *a12 = v22;
      LOWORD(v23) = v16;
      if (v16 >= 6)
      {
        if (v16 > 0x81)
        {
          if (v16 > 0x841)
          {
            if (v16 >> 1 >= 0xC21)
            {
              else {
                LOWORD(v23) = 23;
              }
            }

            else
            {
              LOWORD(v23) = 21;
            }
          }

          else
          {
            LODWORD(v23) = (__clz(v16 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v24 = (__clz(v16 - 2) ^ 0x1F) - 1;
          unint64_t v23 = 2 * v24 + ((unint64_t)(v16 - 2) >> v24) + 2;
        }
      }

      int v25 = HIBYTE(v17) & 0x80 | (v17 >> 25);
      uint64_t v26 = v17 & 0x1FFFFFF;
      uint64_t v27 = (v26 + (char)v25);
      if (v27 > 9)
      {
        if (v27 > 0x85)
        {
          unsigned int v30 = (__clz(v27 - 70) ^ 0x1F) + 12;
          else {
            LOWORD(v28) = 23;
          }
        }

        else
        {
          unsigned int v29 = (__clz(v27 - 6) ^ 0x1F) - 1;
          unint64_t v28 = 2 * v29 + ((unint64_t)(v27 - 6) >> v29) + 4;
        }
      }

      else
      {
        LOWORD(v28) = v26 + (char)v25 - 2;
      }

      uint64_t v31 = 4LL * (unsigned __int16)v23;
      int v32 = *(_DWORD *)((char *)&kBrotliInsExtra + v31);
      uint64_t v33 = 4LL * (unsigned __int16)v28;
      unint64_t v34 = ((unint64_t)(v27 - *(_DWORD *)((char *)&kBrotliCopyBase + v33)) << v32) | (v16 - *(_DWORD *)((char *)&kBrotliInsBase + v31));
      uint64_t v35 = (*(_DWORD *)((char *)&kBrotliCopyExtra + v33) + v32);
      *(void *)(a13 + (v22 >> 3)) = (v34 << (v22 & 7)) | *(unsigned __int8 *)(a13 + (v22 >> 3));
      unint64_t v14 = v22 + v35;
      *a12 = v14;
      if ((_DWORD)v16)
      {
        do
        {
          uint64_t v36 = *(unsigned __int8 *)(result + (a2 & a3));
          uint64_t v37 = *(unsigned __int8 *)(a6 + v36);
          *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v36) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
          v14 += v37;
          *a12 = v14;
          ++a2;
          --v16;
        }

        while (v16);
      }

      if ((_DWORD)v26)
      {
        if (v19 >= 0x80)
        {
          uint64_t v38 = *(unsigned __int8 *)(a10 + (v20 & 0x3FF));
          *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a11 + 2 * (v20 & 0x3FF)) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
          *a12 = v14 + v38;
          *(void *)(a13 + ((v14 + v38) >> 3)) = (v18 << ((v14 + v38) & 7)) | *(unsigned __int8 *)(a13
                                                                                                  + ((v14 + v38) >> 3));
          v14 += v38 + (v20 >> 10);
          *a12 = v14;
        }
      }

      a2 += v26;
      ++v13;
    }

    while (v13 != a5);
  }

  return result;
}

unint64_t BrotliStoreMetaBlockFast( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1895F8858]();
  uint64_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  uint64_t v21 = v20;
  unint64_t v22 = v11;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  int v24 = *(_DWORD *)(v23 + 72);
  StoreCompressedMetaBlockHeader(v14, v25, a10, a11);
  unint64_t v26 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v26 + 13;
  if (a9 > 0x80)
  {
    bzero(v36, 0x408uLL);
    uint64_t v38 = 0x7FF0000000000000LL;
    bzero(v48, 0xB08uLL);
    uint64_t v50 = 0x7FF0000000000000LL;
    bzero(v45, 0x888uLL);
    uint64_t v47 = 0x7FF0000000000000LL;
    BuildHistograms(v21, v19, v17, v13, a9, (uint64_t)v36, (uint64_t)v48, (uint64_t)v45);
    unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v36, *(uint64_t *)v37, 8LL, v44, (uint64_t)v43, a10, a11);
    if (!*(_DWORD *)(v22 + 24))
    {
      unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v48, *(uint64_t *)v49, 10LL, v42, (uint64_t)v41, a10, a11);
      if (!*(_DWORD *)(v22 + 24))
      {
        unint64_t result = BrotliBuildAndStoreHuffmanTreeFast( v22,  (uint64_t)v45,  *(uint64_t *)v46,  (__clz(v24 - 1) ^ 0x1F) + 1,  v40,  (uint64_t)v39,  a10,  a11);
        if (!*(_DWORD *)(v22 + 24))
        {
          unint64_t result = StoreDataWithHuffmanCodes( v21,  v19,  v17,  v13,  a9,  (uint64_t)v44,  (uint64_t)v43,  (uint64_t)v42,  (uint64_t)v41,  (uint64_t)v40,  (uint64_t)v39,  a10,  a11);
          goto LABEL_16;
        }
      }
    }
  }

  else
  {
    bzero(v48, 0x400uLL);
    if (a9)
    {
      uint64_t v27 = 0LL;
      uint64_t v28 = 0LL;
      uint64_t v29 = v19;
      do
      {
        unsigned int v30 = (unsigned int *)(v13 + 16 * v27);
        uint64_t v31 = *v30;
        if ((_DWORD)v31)
        {
          uint64_t v32 = *v30;
          do
          {
            ++v48[*(unsigned __int8 *)(v21 + (v29++ & v17))];
            --v32;
          }

          while (v32);
        }

        v28 += v31;
        v29 += v30[1] & 0x1FFFFFF;
        ++v27;
      }

      while (v27 != a9);
    }

    else
    {
      uint64_t v28 = 0LL;
    }

    unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v48, v28, 8LL, v41, (uint64_t)v45, a10, a11);
    if (!*(_DWORD *)(v22 + 24))
    {
      unint64_t v34 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = (0x92624416307003LL << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v34 + 56;
      *(void *)(a11 + ((v34 + 56) >> 3)) = *(unsigned __int8 *)(a11 + ((v34 + 56) >> 3));
      *a10 = v34 + 59;
      *(void *)(a11 + ((v34 + 59) >> 3)) = (57269251LL << ((v34 + 59) & 7)) | *(unsigned __int8 *)(a11 + ((v34 + 59) >> 3));
      *a10 = v34 + 87;
      unint64_t result = StoreDataWithHuffmanCodes( v21,  v19,  v17,  v13,  a9,  (uint64_t)v41,  (uint64_t)v45,  (uint64_t)&kStaticCommandCodeDepth,  (uint64_t)&kStaticCommandCodeBits,  (uint64_t)&kStaticDistanceCodeDepth,  (uint64_t)&kStaticDistanceCodeBits,  a10,  a11);
LABEL_16:
      if (v15)
      {
        unsigned int v35 = *(_DWORD *)a10 + 7;
        *a10 = v35 & 0xFFFFFFF8;
        *(_BYTE *)(a11 + (v35 >> 3)) = 0;
      }
    }
  }

  return result;
}

void *BrotliStoreUncompressedMetaBlock( int a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, uint64_t *a6, uint64_t a7)
{
  size_t v9 = a5;
  uint64_t v12 = a4 & a3;
  uint64_t v13 = *a6;
  *(void *)(a7 + ((unint64_t)*a6 >> 3)) = *(unsigned __int8 *)(a7 + ((unint64_t)*a6 >> 3));
  if (a5 == 1 || (unsigned int v14 = __clz(a5 - 1) ^ 0x1F, v14 <= 0xE)) {
    uint64_t v15 = 4LL;
  }
  else {
    uint64_t v15 = (v14 + 4) >> 2;
  }
  *(void *)(a7 + ((unint64_t)(v13 + 1) >> 3)) = ((v15 - 4) << ((v13 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((unint64_t)(v13 + 1) >> 3));
  unint64_t v16 = v13 + 3;
  *(void *)(a7 + (v16 >> 3)) = ((a5 - 1) << (v16 & 7)) | *(unsigned __int8 *)(a7 + (v16 >> 3));
  unint64_t v17 = v16 + 4 * v15;
  *(void *)(a7 + (v17 >> 3)) = (1LL << (v17 & 7)) | *(unsigned __int8 *)(a7 + (v17 >> 3));
  unsigned int v18 = v17 + 8;
  unint64_t v19 = v18 & 0xFFFFFFF8;
  uint64_t v20 = (_BYTE *)(a7 + (v19 >> 3));
  _BYTE *v20 = 0;
  uint64_t v21 = a4 + 1;
  if (v12 + a5 <= a4 + 1)
  {
    unint64_t v23 = v18 >> 3;
  }

  else
  {
    uint64_t v22 = v21 - v12;
    memcpy(v20, (const void *)(a2 + v12), v21 - v12);
    uint64_t v12 = 0LL;
    v19 += 8 * v22;
    v9 -= v22;
    unint64_t v23 = v19 >> 3;
  }

  unint64_t result = memcpy((void *)(a7 + v23), (const void *)(a2 + v12), v9);
  size_t v25 = v19 + 8 * v9;
  *a6 = v25;
  *(_BYTE *)(a7 + (v25 >> 3)) = 0;
  if (a1)
  {
    *(void *)(a7 + (v25 >> 3)) = 1LL << (v19 & 7);
    *(void *)(a7 + ((v25 + 1) >> 3)) = (1LL << ((v25 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((v25 + 1) >> 3));
    unsigned int v26 = v25 + 9;
    *a6 = v26 & 0xFFFFFFF8;
    *(_BYTE *)(a7 + (v26 >> 3)) = 0;
  }

  return result;
}

uint64_t StoreVarLenUint8(uint64_t result, unint64_t *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = __clz(result) ^ 0x1F;
    unint64_t v4 = *a2;
    *(void *)(a3 + (*a2 >> 3)) = (1LL << (*a2 & 7)) | *(unsigned __int8 *)(a3 + (*a2 >> 3));
    *a2 = v4 + 1;
    *(void *)(a3 + ((v4 + 1) >> 3)) = (v3 << ((v4 + 1) & 7)) | *(unsigned __int8 *)(a3 + ((v4 + 1) >> 3));
    v4 += 4LL;
    *a2 = v4;
    *(void *)(a3 + (v4 >> 3)) = (((-1LL << v3) + result) << (v4 & 7)) | *(unsigned __int8 *)(a3 + (v4 >> 3));
    unint64_t v5 = v4 + v3;
  }

  else
  {
    unint64_t v6 = *a2;
    *(void *)(a3 + (*a2 >> 3)) = *(unsigned __int8 *)(a3 + (*a2 >> 3));
    unint64_t v5 = v6 + 1;
  }

  *a2 = v5;
  return result;
}

uint64_t lz4_stream_init(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  if (a2 == 1)
  {
    unint64_t v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 1, 256, 0x4813Cu, 0);
    *(void *)(a1 + 32) = v6;
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t result = 0LL;
      v7[4] = 5;
      return result;
    }
  }

  else if (!a2)
  {
    unint64_t v4 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, 256, 0x4813Cu, 0);
    *(void *)(a1 + 32) = v4;
    if (v4)
    {
      v4[4] = 0;
      memset_pattern8(v4 + 65615, &unk_181076880, 0x8000uLL);
      return 0LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t lz4_stream_process(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)v2 != 1)
  {
    if (!*(_DWORD *)v2)
    {
      uint64_t v5 = v2 + 65596;
      unint64_t v6 = (int *)(v2 + 24);
      int v7 = v2 + 131260;
      int v8 = *(_DWORD *)(v2 + 16);
      while (1)
      {
        uint64_t result = 0xFFFFFFFFLL;
        switch(v8)
        {
          case 0:
            uint64_t v10 = *(unsigned int *)(v2 + 44);
            else {
              size_t v11 = *(void *)(a1 + 24);
            }
            memcpy((void *)(v5 + v10), *(const void **)(a1 + 16), v11);
            size_t v12 = *(void *)(a1 + 24) - v11;
            *(void *)(a1 + 16) += v11;
            *(void *)(a1 + 24) = v12;
            uint64_t v13 = (*(_DWORD *)(v2 + 44) + v11);
            *(_DWORD *)(v2 + 44) = v13;
            uint64_t v60 = (unsigned __int8 *)(v2 + 65596);
            unint64_t v61 = (void *)(v2 + 131260);
            if (*(_DWORD *)(v2 + 20)) {
              uint64_t v14 = v2 + 60;
            }
            else {
              uint64_t v14 = v2 + 65596;
            }
            lz4_encode_2gb((int32x4_t **)&v61, 131200LL, (char **)&v60, v14, v13, v2 + 262460, 0LL);
            unsigned int v15 = (_DWORD)v61 - v7;
            *(_DWORD *)(v2 + 52) = (_DWORD)v61 - v7;
            unsigned int v16 = *(_DWORD *)(v2 + 44);
            if (v16 <= v15)
            {
              int v17 = 8;
              int v18 = 758412898;
              unint64_t v19 = (_DWORD *)(v2 + 48);
            }

            else
            {
              *(_DWORD *)(v2 + 32) = v15;
              int v17 = 12;
              int v18 = 825521762;
              unint64_t v19 = (_DWORD *)(v2 + 56);
            }

            unsigned int v20 = 0;
            *(_DWORD *)(v2 + 24) = v18;
            *(_DWORD *)(v2 + 28) = v16;
            *(_DWORD *)(v2 + 36) = 0;
            *(_DWORD *)(v2 + 40) = v17;
            *unint64_t v19 = 0;
            *(_DWORD *)(v2 + 16) = 1;
            goto LABEL_34;
          case 1:
            unsigned int v20 = *(_DWORD *)(v2 + 36);
            int v17 = *(_DWORD *)(v2 + 40);
LABEL_34:
            unint64_t v30 = v17 - v20;
            unint64_t v31 = *(void *)(a1 + 8);
            if (v31 >= v30) {
              size_t v32 = v30;
            }
            else {
              size_t v32 = v31;
            }
            memcpy(*(void **)a1, (char *)v6 + v20, v32);
            size_t v33 = *(void *)(a1 + 8) - v32;
            *(void *)a1 += v32;
            *(void *)(a1 + 8) = v33;
            LODWORD(v33) = *(_DWORD *)(v2 + 40);
            int v34 = *(_DWORD *)(v2 + 36) + v32;
            *(_DWORD *)(v2 + 36) = v34;
            if (v34 != (_DWORD)v33) {
              return 0LL;
            }
            int v35 = *v6;
            if (*v6 == 607417954)
            {
              int v8 = 8;
            }

            else if (v35 == 825521762)
            {
              int v8 = 2;
            }

            else
            {
              if (v35 != 758412898) {
                return 0xFFFFFFFFLL;
              }
              int v8 = 3;
            }

            goto LABEL_46;
          case 2:
            uint64_t v21 = *(unsigned int *)(v2 + 56);
            else {
              size_t v22 = *(void *)(a1 + 8);
            }
            memcpy(*(void **)a1, (const void *)(v2 + 131260 + v21), v22);
            size_t v23 = *(void *)(a1 + 8) - v22;
            *(void *)a1 += v22;
            *(void *)(a1 + 8) = v23;
            unsigned int v24 = *(_DWORD *)(v2 + 52);
            unsigned int v25 = *(_DWORD *)(v2 + 56) + v22;
            *(_DWORD *)(v2 + 56) = v25;
            goto LABEL_25;
          case 3:
            uint64_t v26 = *(unsigned int *)(v2 + 48);
            else {
              size_t v27 = *(void *)(a1 + 8);
            }
            memcpy(*(void **)a1, (const void *)(v5 + v26), v27);
            size_t v28 = *(void *)(a1 + 8) - v27;
            *(void *)a1 += v27;
            *(void *)(a1 + 8) = v28;
            unsigned int v24 = *(_DWORD *)(v2 + 44);
            unsigned int v25 = *(_DWORD *)(v2 + 48) + v27;
            *(_DWORD *)(v2 + 48) = v25;
LABEL_25:
            if (v25 < v24) {
              return 0LL;
            }
            int v8 = 4;
            goto LABEL_46;
          case 4:
            if (*(void *)(a1 + 24))
            {
              memcpy((void *)(v2 + 60), (const void *)(v2 + 65596), 0x10000uLL);
              *(_DWORD *)(v2 + 44) = 0;
              if (*(_DWORD *)(v2 + 20))
              {
                for (uint64_t i = 0LL; i != 0x8000; i += 8LL)
                  *(_DWORD *)(v2 + 262460 + i) -= 0x10000;
              }

              int v8 = 0;
              *(_DWORD *)(v2 + 20) = 1;
            }

            else
            {
              if (!a2) {
                return 0LL;
              }
              *(_DWORD *)(v2 + 24) = 607417954;
              *(void *)(v2 + 36) = 0x400000000LL;
              int v8 = 1;
            }

BOOL lz4_stream_identify_algorithm(int *a1)
{
  int v1 = *a1;
  return *a1 == 607417954 || v1 == 758412898 || v1 == 825521762;
}

uint64_t lz4_stream_get_state_size()
{
  return 295228LL;
}

unint64_t smb_lz77_decode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = 15LL;
  if (a2 > 0xF) {
    uint64_t v4 = a2;
  }
  if (a4 < 4) {
    return 0LL;
  }
  unint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  unint64_t v9 = a1 + v4 - 15;
  unsigned int v10 = 1;
  unint64_t v11 = 4LL;
  do
  {
    int v12 = *(_DWORD *)(a3 + v7);
    v7 += 36LL;
    if (v12) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v7 > a4;
    }
    unint64_t v14 = v8 + 32;
    if (v13 || v14 > a2)
    {
      int v16 = 1;
      while (1)
      {
        if (v12 < 0)
        {
          unint64_t v7 = v11 + 2;
          if (v11 + 2 > a4)
          {
            if (v11 == a4) {
              return v8;
            }
            else {
              return 0LL;
            }
          }

          unint64_t v17 = *(unsigned __int16 *)(a3 + v11);
          uint64_t v18 = v17 & 7;
          if ((v17 & 7) == 7)
          {
            if (v10 == 1)
            {
              if (v7 >= a4) {
                return 0LL;
              }
              int v19 = *(unsigned __int8 *)(a3 + v7);
              unint64_t v7 = v11 + 3;
              unsigned int v10 = v19 | 0x100;
            }

            unint64_t v20 = v10 & 0xF;
            if ((_DWORD)v20 == 15)
            {
              if (v7 >= a4) {
                return 0LL;
              }
              unint64_t v21 = v7 + 1;
              unint64_t v22 = *(unsigned __int8 *)(a3 + v7);
              if (v22 == 255)
              {
                unint64_t v23 = v7 + 3;
                if (v7 + 3 > a4) {
                  return 0LL;
                }
                unint64_t v24 = *(unsigned __int16 *)(a3 + v21);
                if (!*(_WORD *)(a3 + v21))
                {
                  unint64_t v25 = v7 + 7;
                  if (v25 > a4) {
                    return 0LL;
                  }
                  unint64_t v24 = *(unsigned int *)(a3 + v23);
                  unint64_t v23 = v25;
                }

                BOOL v26 = v24 >= 0x16;
                unint64_t v22 = v24 - 22;
                if (!v26) {
                  return 0LL;
                }
              }

              else
              {
                unint64_t v23 = v7 + 1;
              }

              unint64_t v20 = v22 + 15;
              unint64_t v7 = v23;
            }

            v10 >>= 4;
            uint64_t v18 = v20 + 7;
          }

          unint64_t v27 = (v17 >> 3) + 1;
          if (v8 < v27) {
            return 0LL;
          }
          unint64_t v28 = v18 + 3;
          uint64_t v29 = (_BYTE *)(a1 + v8);
          unint64_t v30 = a1 + v8 + v28;
          if (v17 < 0x78 || v30 > v9)
          {
            if (v28 > a2 - v8) {
              return 0LL;
            }
            do
            {
              *uint64_t v29 = v29[-v27];
              ++v29;
            }

            while ((unint64_t)v29 < v30);
          }

          else
          {
            do
            {
              *(_OWORD *)uint64_t v29 = *(_OWORD *)&v29[-v27];
              v29 += 16;
            }

            while ((unint64_t)v29 < v30);
          }

          v8 += v28;
        }

        else
        {
          uint64_t v5 = 0LL;
          if (v11 >= a4 || a2 <= v8) {
            return v5;
          }
          unint64_t v7 = v11 + 1;
          *(_BYTE *)(a1 + v8++) = *(_BYTE *)(a3 + v11);
        }

        v12 *= 2;
        ++v16;
        unint64_t v11 = v7;
        if (v16 == 33) {
          goto LABEL_46;
        }
      }
    }

    __int128 v31 = *(_OWORD *)(a3 + v11 + 16);
    size_t v32 = (_OWORD *)(a1 + v8);
    *size_t v32 = *(_OWORD *)(a3 + v11);
    v32[1] = v31;
    unint64_t v8 = v14;
LABEL_46:
    uint64_t v5 = 0LL;
    unint64_t v11 = v7 + 4;
  }

  while (v7 + 4 <= a4);
  return v5;
}

uint64_t smb_lz77_encode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  if (a4 <= 7) {
    uint64_t v10 = 7LL;
  }
  else {
    uint64_t v10 = a4;
  }
  bzero(a5, 0x10000uLL);
  if (a2 < 0x12) {
    return 0LL;
  }
  unint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  unint64_t v14 = v10 - 7;
  unint64_t v15 = a2 - 1;
  unsigned int v16 = 256;
  unint64_t v17 = 1LL;
  uint64_t v18 = 4LL;
  while (2)
  {
    __int16 v19 = 8 - 8 * v12;
    for (uint64_t result = v18; ; ++result)
    {
      if (HIDWORD(v17))
      {
        *(_DWORD *)(a1 + v13) = v17;
        uint64_t v13 = result;
        result += 4LL;
        unint64_t v17 = 1LL;
      }

      v17 *= 2LL;
      if (v12 + 4 <= a4) {
        break;
      }
      if (a4 == v12)
      {
        do
        {
          int v45 = v17 | 1;
          unint64_t v46 = HIDWORD(v17);
          unint64_t v17 = 2 * (v17 | 1);
        }

        while (!v46);
        *(_DWORD *)(a1 + v13) = v45;
        do
        {
          unsigned int v47 = v16;
          v16 *= 16;
        }

        while (v47 < 0x100);
        *(_BYTE *)(a1 + v15) = (v47 >> 4) | v16;
        return result;
      }

      char v20 = *(_BYTE *)(a3 + v12++);
      *(_BYTE *)(a1 + result) = v20;
      unint64_t v21 = result + 15;
      v19 -= 8;
      if (v21 > a2) {
        return 0LL;
      }
    }

    unsigned int v22 = *(_DWORD *)(a3 + v12);
    unsigned int v23 = v22 >> 8;
    unsigned int v24 = (-1640531535 * (v22 & 0xFFFFFF)) >> 18;
    uint64_t v25 = (-1640531535 * (v22 >> 8)) >> 18;
    unsigned int v26 = *((_DWORD *)a5 + v24);
    unsigned int v27 = *((_DWORD *)a5 + v25);
    unint64_t v28 = v12 & 0xFFFFE000 | v26 & 0x1FFF;
    unint64_t v29 = v12 & 0xFFFFE000 | v27 & 0x1FFF;
    if (v12 <= v28) {
      unint64_t v28 = (v28 - 0x2000);
    }
    else {
      unint64_t v28 = v28;
    }
    if (v12 < v29) {
      LODWORD(v29) = v29 - 0x2000;
    }
    *((_DWORD *)a5 + v24) = v12 & 0x1FFF | (v22 << 13);
    if ((v22 & 0x7FFFF) != v26 >> 13 || (v12 > v28 ? (BOOL v30 = v12 >= v14) : (BOOL v30 = 1), v30))
    {
      LODWORD(v33) = 0;
    }

    else
    {
      unint64_t v33 = 0LL;
      unsigned int v34 = 0;
      while (1)
      {
        unint64_t v33 = *(void *)(a3 + v28 + v33) ^ *(void *)(a3 + v34 + v12);
        if (v33) {
          break;
        }
        v34 += 8;
        unint64_t v33 = v34;
        if (v12 + v34 >= v14) {
          goto LABEL_26;
        }
      }

      LODWORD(v33) = v34 + (__clz(__rbit64(v33)) >> 3);
    }

LABEL_69:
    uint64_t result = 0LL;
    if (v18 + 14 <= a2) {
      continue;
    }
    return result;
  }

void BrotliPopulationCostLiteral(uint64_t a1)
{
  v35[5] = *MEMORY[0x1895F89C0];
  unint64_t v1 = *(void *)(a1 + 1024);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0LL; i != 256; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }

  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0LL; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4LL * v35[j]);
      unint64_t v7 = 0LL;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }

            ++v10;
          }

          while (v10 != 4);
        }
      }

      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0LL;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0LL;
      double v15 = 0.0;
      unint64_t v16 = 1LL;
      break;
  }

  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if ((_DWORD)v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }

      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }

      double v23 = v12 - v18;
      unint64_t v24 = (unint64_t)(v23 + 0.5);
      double v15 = v15 + v19 * v23;
      if (v24 >= 0xF) {
        unint64_t v24 = 15LL;
      }
      if (v24 > v16) {
        unint64_t v16 = v24;
      }
      ++*((_DWORD *)v33 + v24);
      ++v14;
      continue;
    }

    if (v14 == 255) {
      break;
    }
    uint64_t v20 = 0LL;
    do
    {
      if (*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20)) {
        break;
      }
      ++v20;
    }

    while (255 - v14 != v20);
    unsigned int v21 = v20 + 1;
    v14 += (v20 + 1);
    if (v14 == 256) {
      break;
    }
    unsigned int v22 = v20 - 1;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v22 > 7;
        v22 >>= 3;
      }

      while (v5);
    }

    else
    {
      LODWORD(v33[0]) += v21;
    }
  }

  while (v14 < 0x100);
  uint64_t v25 = 0LL;
  unint64_t v26 = 0LL;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v25);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }

    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }

    uint64_t v31 = *((unsigned int *)v33 + v25 + 1);
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v25 += 2LL;
    v26 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }

  while ((unint64_t)(v25 - 2) < 0x10);
  if (v26 >= 0x100) {
    log2((double)v26);
  }
}

void BrotliPopulationCostCommand(uint64_t a1)
{
  v35[5] = *MEMORY[0x1895F89C0];
  unint64_t v1 = *(void *)(a1 + 2816);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0LL; i != 704; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }

  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0LL; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4LL * v35[j]);
      unint64_t v7 = 0LL;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }

            ++v10;
          }

          while (v10 != 4);
        }
      }

      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0LL;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0LL;
      double v15 = 0.0;
      unint64_t v16 = 1LL;
      break;
  }

  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if ((_DWORD)v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }

      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }

      double v22 = v12 - v18;
      unint64_t v23 = (unint64_t)(v22 + 0.5);
      double v15 = v15 + v19 * v22;
      if (v23 >= 0xF) {
        unint64_t v23 = 15LL;
      }
      if (v23 > v16) {
        unint64_t v16 = v23;
      }
      ++*((_DWORD *)v33 + v23);
      ++v14;
      continue;
    }

    if (v14 > 0x2BE)
    {
      if (++v14 == 704) {
        break;
      }
      unsigned int v21 = 1;
      goto LABEL_41;
    }

    uint64_t v20 = 0LL;
    unsigned int v21 = 704 - v14;
    while (!*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20))
    {
      if (703 - v14 == ++v20) {
        goto LABEL_39;
      }
    }

    unsigned int v21 = v20 + 1;
LABEL_39:
    v14 += v21;
    if (v14 == 704) {
      break;
    }
    unsigned int v24 = v21 - 2;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v24 > 7;
        v24 >>= 3;
      }

      while (v5);
      continue;
    }

LABEL_41:
    LODWORD(v33[0]) += v21;
  }

  while (v14 < 0x2C0);
  uint64_t v25 = 0LL;
  unint64_t v26 = 0LL;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v25);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }

    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }

    uint64_t v31 = *((unsigned int *)v33 + v25 + 1);
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v25 += 2LL;
    v26 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }

  while ((unint64_t)(v25 - 2) < 0x10);
  if (v26 >= 0x100) {
    log2((double)v26);
  }
}

    LODWORD(v33[0]) += v21;
  }

  while (v14 < 0x220);
  uint64_t v25 = 0LL;
  unint64_t v26 = 0LL;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v25);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }

    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }

    uint64_t v31 = *((unsigned int *)v33 + v25 + 1);
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v25 += 2LL;
    v26 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }

  while ((unint64_t)(v25 - 2) < 0x10);
  if (v26 >= 0x100) {
    log2((double)v26);
  }
}

            unsigned int v9 = 0LL;
            unint64_t v10 = 0LL;
            double v12 = *(_DWORD *)(a1 + 72) - 1;
            unsigned int v11 = *(_DWORD *)(a1 + 76) - 1;
            goto LABEL_45;
          case 3:
            goto LABEL_88;
        }

void BrotliPopulationCostDistance(uint64_t a1)
{
  v35[5] = *MEMORY[0x1895F89C0];
  unint64_t v1 = *(void *)(a1 + 2176);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0LL; i != 544; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }

  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0LL; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4LL * v35[j]);
      unint64_t v7 = 0LL;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }

            ++v10;
          }

          while (v10 != 4);
        }
      }

      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0LL;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0LL;
      double v15 = 0.0;
      unint64_t v16 = 1LL;
      break;
  }

  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if ((_DWORD)v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }

      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }

      double v22 = v12 - v18;
      unint64_t v23 = (unint64_t)(v22 + 0.5);
      double v15 = v15 + v19 * v22;
      if (v23 >= 0xF) {
        unint64_t v23 = 15LL;
      }
      if (v23 > v16) {
        unint64_t v16 = v23;
      }
      ++*((_DWORD *)v33 + v23);
      ++v14;
      continue;
    }

    if (v14 > 0x21E)
    {
      if (++v14 == 544) {
        break;
      }
      unsigned int v21 = 1;
      goto LABEL_41;
    }

    uint64_t v20 = 0LL;
    unsigned int v21 = 544 - v14;
    while (!*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20))
    {
      if (543 - v14 == ++v20) {
        goto LABEL_39;
      }
    }

    unsigned int v21 = v20 + 1;
LABEL_39:
    v14 += v21;
    if (v14 == 544) {
      break;
    }
    unsigned int v24 = v21 - 2;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v24 > 7;
        v24 >>= 3;
      }

      while (v5);
      continue;
    }

uint64_t cosmix_model_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = 0LL;
    unsigned int v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    uint64_t v93 = *(void *)(result + 589824);
    unsigned int v10 = 32;
    int v92 = 32 - *(_DWORD *)(result + 589832);
    do
    {
      unsigned int v96 = v10 << 8;
      uint64_t v11 = result + 9LL * (v10 << 8);
      uint64_t v12 = v93 + 9LL * (v9 >> v92);
      uint64_t v13 = v93 + 9LL * (v8 >> v92);
      uint64_t v103 = v93 + 9LL * (v7 >> v92);
      uint64_t v14 = v93 + 9LL * (v6 >> v92);
      uint64_t v15 = v93 + 9LL * (v5 >> v92);
      uint64_t v16 = v93 + 9LL * (v4 >> v92);
      unsigned int v97 = v9;
      unsigned int v98 = v8;
      unsigned __int8 v17 = v9;
      unsigned __int8 v18 = v8;
      unsigned int v99 = v7;
      unsigned int v100 = v6;
      unsigned __int8 v19 = v7;
      unsigned __int8 v20 = v6;
      unsigned __int8 v21 = v5;
      unsigned int v101 = v4;
      unsigned __int8 v22 = v4;
      unsigned int v23 = 1;
      int v24 = 7;
      uint64_t v102 = v3;
      unsigned int v10 = *(unsigned __int8 *)(a2 + v3);
      unsigned int v105 = v10;
      uint64_t v104 = v12;
      uint64_t v106 = v13;
      do
      {
        uint64_t v25 = v23;
        unint64_t v26 = (unsigned int *)(v11 + 9LL * v23);
        if (((*((_BYTE *)v26 + 8) ^ v23) & 0xF) != 0)
        {
          LODWORD(v27) = *(_DWORD *)(v11 + 9LL * v23 + 4);
          LODWORD(v28) = *v26;
          unsigned int v29 = 8;
        }

        else
        {
          uint64_t v28 = *v26;
          unint64_t v27 = *(unsigned int *)(v11 + 9LL * v23 + 4);
          unsigned int v29 = tc_quant16[((v28 << 16) / v27) >> 11];
        }

        int v30 = (v10 >> v24) & 1;
        uint64_t v31 = 9LL * v23;
        unsigned int v32 = v27 >> 1;
        *unint64_t v26 = (v28 >> (v27 > 0xFFFF0000)) + 4 * v30;
        *(_DWORD *)(v11 + 9LL * v23 + 4) = v27 - v32 + 4;
        *((_BYTE *)v26 + 8) = v23;
        unint64_t v33 = (unsigned int *)(v12 + v31);
        uint64_t v34 = (unsigned __int8 *)(v12 + v31 + 8);
        if (((*v34 ^ v17) & 0xF) != 0)
        {
          LODWORD(v35) = *v33;
          LODWORD(v36) = v33[1];
          unsigned int v37 = 8;
        }

        else
        {
          uint64_t v35 = *v33;
          unint64_t v36 = v33[1];
          unsigned int v37 = tc_quant16[((v35 << 16) / v36) >> 11];
        }

        int v38 = 4 * v30;
        uint64_t v39 = 9 * v25;
        unsigned int v40 = v36 >> 1;
        *unint64_t v33 = (v35 >> (v36 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v12 + 9 * v25 + 4) = v36 - v40 + 4;
        *uint64_t v34 = v17;
        unsigned int v41 = (unsigned int *)(v13 + v39);
        char v42 = (unsigned __int8 *)(v13 + v39 + 8);
        if (((*v42 ^ v18) & 0xF) != 0)
        {
          LODWORD(v43) = *v41;
          LODWORD(v44) = v41[1];
          unsigned int v45 = 8;
        }

        else
        {
          uint64_t v43 = *v41;
          unint64_t v44 = v41[1];
          unsigned int v45 = tc_quant16[((v43 << 16) / v44) >> 11];
        }

        uint64_t v46 = 9 * v25;
        unsigned int v47 = v44 >> 1;
        unsigned int *v41 = (v43 >> (v44 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v13 + 9 * v25 + 4) = v44 - v47 + 4;
        *char v42 = v18;
        uint64_t v48 = (unsigned int *)(v103 + v46);
        size_t v49 = (unsigned __int8 *)(v103 + v46 + 8);
        if (((*v49 ^ v19) & 0xF) != 0)
        {
          LODWORD(v50) = *v48;
          LODWORD(v51) = v48[1];
          uint64_t v52 = 8LL;
        }

        else
        {
          uint64_t v50 = *v48;
          unint64_t v51 = v48[1];
          uint64_t v52 = tc_quant16[((v50 << 16) / v51) >> 11];
        }

        uint64_t v53 = 9 * v25;
        unsigned int v54 = v51 >> 1;
        *uint64_t v48 = (v50 >> (v51 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v103 + 9 * v25 + 4) = v51 - v54 + 4;
        *size_t v49 = v19;
        size_t v55 = (unsigned int *)(v14 + v53);
        uint64_t v56 = (unsigned __int8 *)(v14 + v53 + 8);
        if (((*v56 ^ v20) & 0xF) != 0)
        {
          LODWORD(v57) = *v55;
          LODWORD(v58) = v55[1];
          unsigned int v59 = 8;
        }

        else
        {
          uint64_t v57 = *v55;
          unint64_t v58 = v55[1];
          unsigned int v59 = tc_quant16[((v57 << 16) / v58) >> 11];
        }

        uint64_t v60 = 9 * v25;
        unsigned int v61 = v58 >> 1;
        *size_t v55 = (v57 >> (v58 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v14 + 9 * v25 + 4) = v58 - v61 + 4;
        unsigned __int8 *v56 = v20;
        unsigned int v62 = (unsigned int *)(v15 + v60);
        __int16 v63 = (unsigned __int8 *)(v15 + v60 + 8);
        if (((*v63 ^ v21) & 0xF) != 0)
        {
          LODWORD(v64) = *v62;
          LODWORD(v65) = v62[1];
          unsigned int v66 = 8;
        }

        else
        {
          uint64_t v64 = *v62;
          unint64_t v65 = v62[1];
          unsigned int v66 = tc_quant16[((v64 << 16) / v65) >> 11];
        }

        uint64_t v67 = 9 * v25;
        unsigned int v68 = v65 >> 1;
        *unsigned int v62 = (v64 >> (v65 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v15 + 9 * v25 + 4) = v65 - v68 + 4;
        *__int16 v63 = v21;
        int v69 = (unsigned int *)(v16 + v67);
        uint64_t v70 = (unsigned __int8 *)(v16 + v67 + 8);
        if (((*v70 ^ v22) & 0xF) != 0)
        {
          LODWORD(v71) = *v69;
          LODWORD(v72) = v69[1];
          uint64_t v73 = 8LL;
        }

        else
        {
          uint64_t v71 = *v69;
          unint64_t v72 = v69[1];
          uint64_t v73 = tc_quant16[((v71 << 16) / v72) >> 11];
        }

        unsigned int v74 = v72 >> 1;
        *int v69 = (v71 >> (v72 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v16 + 9 * v25 + 4) = v72 - v74 + 4;
        *uint64_t v70 = v22;
        uint64_t v75 = result + 2304LL * v37 + 144LL * v45 + 589848;
        unint64_t v76 = (unsigned int *)(v75 + 9 * v52);
        if ((v76[2] & 0xF) != 0)
        {
          LODWORD(v77) = *v76;
          LODWORD(v78) = v76[1];
          unsigned int v79 = 8;
        }

        else
        {
          uint64_t v77 = *v76;
          unint64_t v78 = v76[1];
          unsigned int v79 = tc_quant16[((v77 << 16) / v78) >> 11];
        }

        uint64_t v80 = v75 + 9 * v52;
        unsigned int v81 = v78 >> 1;
        unsigned int *v76 = (v77 >> (v78 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v80 + 4) = v78 - v81 + 4;
        *((_BYTE *)v76 + 8) = 0;
        uint64_t v82 = result + 2304LL * v59 + 144LL * v66 + 626712;
        unint64_t v83 = (unsigned int *)(v82 + 9 * v73);
        if ((v83[2] & 0xF) != 0)
        {
          LODWORD(v85) = *v83;
          LODWORD(v84) = v83[1];
          uint64_t v86 = 8LL;
        }

        else
        {
          uint64_t v85 = *v83;
          unint64_t v84 = v83[1];
          uint64_t v86 = tc_quant16[((v85 << 16) / v84) >> 11];
        }

        unsigned int v10 = v105;
        uint64_t v12 = v104;
        uint64_t v87 = v82 + 9 * v73;
        unsigned int v88 = v84 >> 1;
        *unint64_t v83 = (v85 >> (v84 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v87 + 4) = v84 - v88 + 4;
        *((_BYTE *)v83 + 8) = 0;
        uint64_t v89 = result + 2304LL * v29 + 144LL * v79 + 9 * v86 + 663576;
        unsigned int v90 = *(_DWORD *)(v89 + 4);
        unsigned int v91 = v90 >> 1;
        if (v90 <= 0xFFFF0000) {
          unsigned int v91 = 0;
        }
        *(_DWORD *)uint64_t v89 = (*(_DWORD *)v89 >> (v90 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v89 + 4) = v90 - v91 + 4;
        *(_BYTE *)(v89 + 8) = 0;
        unsigned int v23 = v30 | (2 * v25);
        --v24;
        uint64_t v13 = v106;
      }

      while (v24 != -1);
      if (v105 >= 0x21) {
        unsigned int v4 = -1640531535 * (v101 + v105);
      }
      else {
        unsigned int v4 = 0;
      }
      unsigned int v5 = -1640531535 * (v100 + v105);
      unsigned int v6 = -1640531535 * (v99 + v105);
      unsigned int v7 = -1640531535 * (v98 + v105);
      unsigned int v8 = -1640531535 * (v97 + v105);
      unsigned int v9 = -1640531535 * (v96 | v105);
      uint64_t v3 = v102 + 1;
    }

    while (v102 + 1 != a3);
  }

  return result;
}

unint64_t cosmix_codec_encode( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!a5) {
    return 0LL;
  }
  int v5 = 0;
  unint64_t v6 = 0LL;
  unint64_t v7 = 1LL;
  do
  {
    unint64_t v8 = v6;
    unint64_t v6 = v7;
    v7 += v8;
    ++v5;
  }

  while (a5 - v6 >= v7);
  unint64_t v9 = 1LL << v5;
  if (v5)
  {
    unsigned int v10 = v5 - 1;
    unint64_t v11 = a5;
    do
    {
      uint64_t v12 = 1LL << v10;
      if (v11 >= v7) {
        unint64_t v13 = v7;
      }
      else {
        unint64_t v13 = 0LL;
      }
      if (v11 < v7) {
        uint64_t v12 = 0LL;
      }
      v11 -= v13;
      v9 |= v12;
      unint64_t v14 = v7 - v6;
      unint64_t v7 = v6;
      unint64_t v6 = v14;
    }

    while ((unint64_t)v10--);
  }

  int v16 = 0;
  unint64_t v17 = 0LL;
  unint64_t v18 = a5 + ((73 - __clz(v9)) >> 3);
  unint64_t v19 = 1LL;
  do
  {
    unint64_t v20 = v17;
    unint64_t v17 = v19;
    v19 += v20;
    ++v16;
  }

  while (a5 - v17 >= v19);
  unint64_t v21 = 1LL << v16;
  unint64_t v145 = v18;
  if (!v16) {
    goto LABEL_23;
  }
  unsigned int v22 = v16 - 1;
  unint64_t v23 = a5;
  do
  {
    uint64_t v24 = 1LL << v22;
    if (v23 >= v19) {
      unint64_t v25 = v19;
    }
    else {
      unint64_t v25 = 0LL;
    }
    if (v23 < v19) {
      uint64_t v24 = 0LL;
    }
    v23 -= v25;
    v21 |= v24;
    unint64_t v26 = v19 - v17;
    unint64_t v19 = v17;
    unint64_t v17 = v26;
  }

  while ((unint64_t)v22--);
  if (!v21)
  {
    unsigned int v29 = 0;
    unint64_t v28 = 0LL;
    int v30 = -1;
  }

  else
  {
LABEL_23:
    unint64_t v28 = 0LL;
    unsigned int v29 = 0;
    int v30 = -1;
    do
    {
      if ((v21 & 1) != 0) {
        int v31 = v29 + ((v30 - v29) >> 1);
      }
      else {
        int v31 = v30;
      }
      if ((v21 & 1) == 0) {
        v29 += ((v30 - v29) >> 1) + 1;
      }
      if ((v29 ^ v31) >> 24)
      {
        int v30 = v31;
      }

      else
      {
        do
        {
          unint64_t v33 = (unint64_t)v29 << 8;
          int v32 = HIDWORD(v33);
          unsigned int v29 = v33;
          int v30 = (v31 << 8) | 0xFF;
          if (v28 >= a3) {
            unint64_t v34 = 0LL;
          }
          else {
            unint64_t v34 = v28;
          }
          *(_BYTE *)(a2 + v34) = v32;
          ++v28;
          unsigned int v35 = (v29 ^ (v31 << 8)) >> 24;
          int v31 = (v31 << 8) | 0xFF;
        }

        while (!v35);
      }

      BOOL v36 = v21 > 1;
      v21 >>= 1;
    }

    while (v36);
  }

  int v38 = v29 + ((v30 - v29) >> 1);
  if ((v29 ^ v38) >> 24)
  {
    unsigned int v41 = v29 + ((v30 - v29) >> 1);
  }

  else
  {
    do
    {
      unint64_t v40 = (unint64_t)v29 << 8;
      int v39 = HIDWORD(v40);
      unsigned int v29 = v40;
      unsigned int v41 = (v38 << 8) | 0xFF;
      if (v28 >= a3) {
        unint64_t v42 = 0LL;
      }
      else {
        unint64_t v42 = v28;
      }
      *(_BYTE *)(a2 + v42) = v39;
      ++v28;
      unsigned int v43 = (v29 ^ (v38 << 8)) >> 24;
      int v38 = (v38 << 8) | 0xFF;
    }

    while (!v43);
  }

  uint64_t v44 = 0LL;
  unsigned int v45 = 0;
  unsigned int v46 = 0;
  unsigned int v47 = 0;
  unsigned int v48 = 0;
  unsigned int v49 = 0;
  unsigned int v50 = 0;
  if (a5 <= 1) {
    uint64_t v51 = 1LL;
  }
  else {
    uint64_t v51 = a5;
  }
  uint64_t v147 = v51;
  LODWORD(v52) = 32;
  do
  {
    char v53 = 32 - *(_DWORD *)(a1 + 16);
    uint64_t v54 = *(void *)(a1 + 8);
    uint64_t v159 = v54 + ((unint64_t)v50 >> v53);
    uint64_t v158 = v54 + ((unint64_t)v49 >> v53);
    uint64_t v157 = v54 + ((unint64_t)v48 >> v53);
    uint64_t v156 = v54 + ((unint64_t)v47 >> v53);
    uint64_t v155 = v54 + ((unint64_t)v46 >> v53);
    uint64_t v55 = v54 + ((unint64_t)v45 >> v53);
    unsigned int v150 = v49;
    char v56 = v49;
    int v149 = (_DWORD)v52 << 8;
    unsigned int v151 = v48;
    unsigned int v152 = v47;
    char v57 = v48;
    char v58 = v47;
    char v59 = v46;
    unsigned int v153 = v45;
    char v60 = v45;
    unint64_t v61 = *(void *)a1 + ((unint64_t)v52 << 8);
    unsigned int v62 = 1;
    int v63 = 8;
    uint64_t v154 = v44;
    uint64_t v52 = *(unsigned __int8 *)(a4 + v44);
    do
    {
      --v63;
      uint64_t v64 = v52;
      unsigned int v65 = v52 >> v63;
      unsigned int v66 = *(unsigned __int8 *)(v61 + v62);
      char v67 = v66 ^ v62;
      unsigned int v68 = v66 >> 4;
      if ((v67 & 0xF) != 0) {
        uint64_t v69 = 8LL;
      }
      else {
        uint64_t v69 = v68;
      }
      unsigned int v70 = *(unsigned __int8 *)(v159 + v62);
      char v71 = v70 ^ v50;
      LODWORD(v72) = v70 >> 4;
      if ((v71 & 0xF) != 0) {
        uint64_t v72 = 8LL;
      }
      else {
        uint64_t v72 = v72;
      }
      unsigned int v73 = *(unsigned __int8 *)(v158 + v62);
      char v74 = v73 ^ v56;
      unsigned int v75 = v73 >> 4;
      if ((v74 & 0xF) != 0) {
        unsigned int v75 = 8;
      }
      unsigned int v76 = *(unsigned __int8 *)(v157 + v62);
      char v77 = v76 ^ v57;
      unsigned int v78 = v76 >> 4;
      if ((v77 & 0xF) != 0) {
        unsigned int v79 = 8;
      }
      else {
        unsigned int v79 = v78;
      }
      unsigned int v80 = *(unsigned __int8 *)(v156 + v62);
      char v81 = v80 ^ v58;
      LODWORD(v82) = v80 >> 4;
      if ((v81 & 0xF) != 0) {
        uint64_t v82 = 8LL;
      }
      else {
        uint64_t v82 = v82;
      }
      unsigned int v83 = *(unsigned __int8 *)(v155 + v62);
      char v84 = v83 ^ v59;
      unsigned int v85 = v83 >> 4;
      if ((v84 & 0xF) != 0) {
        unsigned int v85 = 8;
      }
      unsigned int v86 = *(unsigned __int8 *)(v55 + v62);
      char v87 = v86 ^ v60;
      unsigned int v88 = v86 >> 4;
      if ((v87 & 0xF) != 0) {
        unsigned int v89 = 8;
      }
      else {
        unsigned int v89 = v88;
      }
      uint64_t v90 = *(void *)(a1 + 32) + (v72 << 8);
      int v91 = v65 & 1;
      int v92 = v29
          + ((*(unsigned __int8 *)(*(void *)(a1 + 48)
                                 + (v69 << 8)
                                 + (*(_BYTE *)(v90 + 16LL * v75 + v79) & 0xF0)
                                 + ((unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 40)
                                                                         + (v82 << 8)
                                                                         + 16LL * v85
                                                                         + v89) >> 4))
            * (unint64_t)(v41 - v29)) >> 8);
      if ((v65 & 1) != 0) {
        int v93 = v92;
      }
      else {
        int v93 = v41;
      }
      if (!v91) {
        unsigned int v29 = v92 + 1;
      }
      if ((v29 ^ v93) >> 24)
      {
        unsigned int v41 = v93;
        uint64_t v52 = v64;
      }

      else
      {
        uint64_t v52 = v64;
        do
        {
          unint64_t v95 = (unint64_t)v29 << 8;
          int v94 = HIDWORD(v95);
          unsigned int v29 = v95;
          unsigned int v41 = (v93 << 8) | 0xFF;
          if (v28 >= a3) {
            unint64_t v96 = 0LL;
          }
          else {
            unint64_t v96 = v28;
          }
          *(_BYTE *)(a2 + v96) = v94;
          ++v28;
          unsigned int v97 = (v29 ^ (v93 << 8)) >> 24;
          int v93 = (v93 << 8) | 0xFF;
        }

        while (!v97);
      }

      unsigned int v62 = v91 | (2 * v62);
    }

    while (v63);
    else {
      unsigned int v45 = 0;
    }
    unsigned int v46 = -1640531535 * (v152 + v52);
    unsigned int v47 = -1640531535 * (v151 + v52);
    unsigned int v48 = -1640531535 * (v150 + v52);
    unsigned int v49 = -1640531535 * (v50 + v52);
    unsigned int v50 = -1640531535 * (v149 | v52);
    uint64_t v44 = v154 + 1;
  }

  while (v154 + 1 != v147);
  while (1)
  {
    int v103 = HIBYTE(v29) + 1;
    if (v103 != HIBYTE(v41)) {
      break;
    }
    int v98 = v29 | 0xFFFFFF;
    if ((v41 & 0xFFFFFF) > (v29 | 0xFFFFFF) - v29)
    {
      int v98 = v41;
      unsigned int v29 = v41 & 0xFF000000;
    }

    if ((v29 ^ v98) >> 24)
    {
      unsigned int v41 = v98;
    }

    else
    {
      do
      {
        unint64_t v100 = (unint64_t)v29 << 8;
        int v99 = HIDWORD(v100);
        unsigned int v29 = v100;
        unsigned int v41 = (v98 << 8) | 0xFF;
        if (v28 >= a3) {
          unint64_t v101 = 0LL;
        }
        else {
          unint64_t v101 = v28;
        }
        *(_BYTE *)(a2 + v101) = v99;
        ++v28;
        unsigned int v102 = (v29 ^ (v98 << 8)) >> 24;
        int v98 = (v98 << 8) | 0xFF;
      }

      while (!v102);
    }
  }

  if (v28 >= a3) {
    unint64_t v104 = 0LL;
  }
  else {
    unint64_t v104 = v28;
  }
  *(_BYTE *)(a2 + v104) = v103;
  if (v28 + 1 <= a3) {
    unint64_t result = v28 + 1;
  }
  else {
    unint64_t result = 0LL;
  }
  unint64_t v105 = a5;
  if (result > v145)
  {
    int v106 = 0;
    unint64_t v107 = 0LL;
    unint64_t v108 = 1LL;
    do
    {
      unint64_t v109 = v107;
      unint64_t v107 = v108;
      v108 += v109;
      ++v106;
    }

    while (a5 - v107 >= v108);
    unint64_t v110 = 1LL << v106;
    if (!v106) {
      goto LABEL_118;
    }
    unsigned int v111 = v106 - 1;
    do
    {
      uint64_t v112 = 1LL << v111;
      if (v105 >= v108) {
        unint64_t v113 = v108;
      }
      else {
        unint64_t v113 = 0LL;
      }
      if (v105 < v108) {
        uint64_t v112 = 0LL;
      }
      v105 -= v113;
      v110 |= v112;
      unint64_t v114 = v108 - v107;
      unint64_t v108 = v107;
      unint64_t v107 = v114;
    }

    while ((unint64_t)v111--);
    if (!v110)
    {
      unsigned int v117 = 0;
      unint64_t v116 = 0LL;
      int v118 = -1;
    }

    else
    {
LABEL_118:
      unint64_t v116 = 0LL;
      unsigned int v117 = 0;
      int v118 = -1;
      do
      {
        if ((v110 & 1) != 0) {
          int v119 = v117 + ((v118 - v117) >> 1);
        }
        else {
          int v119 = v118;
        }
        if ((v110 & 1) == 0) {
          v117 += ((v118 - v117) >> 1) + 1;
        }
        if ((v117 ^ v119) >> 24)
        {
          int v118 = v119;
        }

        else
        {
          do
          {
            unint64_t v121 = (unint64_t)v117 << 8;
            int v120 = HIDWORD(v121);
            unsigned int v117 = v121;
            int v118 = (v119 << 8) | 0xFF;
            if (v116 >= a3) {
              unint64_t v122 = 0LL;
            }
            else {
              unint64_t v122 = v116;
            }
            *(_BYTE *)(a2 + v122) = v120;
            ++v116;
            unsigned int v123 = (v117 ^ (v119 << 8)) >> 24;
            int v119 = (v119 << 8) | 0xFF;
          }

          while (!v123);
        }

        BOOL v36 = v110 > 1;
        v110 >>= 1;
      }

      while (v36);
    }

    unsigned int v124 = v117 + ((v118 - v117) >> 1) + 1;
    if ((v124 ^ v118) >> 24)
    {
      unsigned int v127 = v118;
    }

    else
    {
      do
      {
        unint64_t v126 = (unint64_t)v124 << 8;
        int v125 = HIDWORD(v126);
        unsigned int v124 = v126;
        unsigned int v127 = (v118 << 8) | 0xFF;
        if (v116 >= a3) {
          unint64_t v128 = 0LL;
        }
        else {
          unint64_t v128 = v116;
        }
        *(_BYTE *)(a2 + v128) = v125;
        ++v116;
        unsigned int v129 = (v124 ^ (v118 << 8)) >> 24;
        int v118 = (v118 << 8) | 0xFF;
      }

      while (!v129);
    }

    for (uint64_t i = 0LL; i != v147; ++i)
    {
      unsigned int v131 = *(unsigned __int8 *)(a4 + i) | 0x100;
      do
      {
        if ((v131 & 0x80) != 0) {
          int v132 = v124 + ((v127 - v124) >> 1);
        }
        else {
          int v132 = v127;
        }
        if ((v131 & 0x80) == 0) {
          v124 += ((v127 - v124) >> 1) + 1;
        }
        if ((v124 ^ v132) >> 24)
        {
          unsigned int v127 = v132;
        }

        else
        {
          do
          {
            unint64_t v134 = (unint64_t)v124 << 8;
            int v133 = HIDWORD(v134);
            unsigned int v124 = v134;
            unsigned int v127 = (v132 << 8) | 0xFF;
            if (v116 >= a3) {
              unint64_t v135 = 0LL;
            }
            else {
              unint64_t v135 = v116;
            }
            *(_BYTE *)(a2 + v135) = v133;
            ++v116;
            unsigned int v136 = (v124 ^ (v132 << 8)) >> 24;
            int v132 = (v132 << 8) | 0xFF;
          }

          while (!v136);
        }

        BOOL v137 = v131 >= 0x8000;
        v131 *= 2;
      }

      while (!v137);
    }

    while (1)
    {
      int v143 = HIBYTE(v124) + 1;
      if (v143 != HIBYTE(v127)) {
        break;
      }
      int v138 = v124 | 0xFFFFFF;
      if ((v127 & 0xFFFFFF) > (v124 | 0xFFFFFF) - v124)
      {
        int v138 = v127;
        unsigned int v124 = v127 & 0xFF000000;
      }

      if ((v124 ^ v138) >> 24)
      {
        unsigned int v127 = v138;
      }

      else
      {
        do
        {
          unint64_t v140 = (unint64_t)v124 << 8;
          int v139 = HIDWORD(v140);
          unsigned int v124 = v140;
          unsigned int v127 = (v138 << 8) | 0xFF;
          if (v116 >= a3) {
            unint64_t v141 = 0LL;
          }
          else {
            unint64_t v141 = v116;
          }
          *(_BYTE *)(a2 + v141) = v139;
          ++v116;
          unsigned int v142 = (v124 ^ (v138 << 8)) >> 24;
          int v138 = (v138 << 8) | 0xFF;
        }

        while (!v142);
      }
    }

    if (v116 >= a3) {
      unint64_t v144 = 0LL;
    }
    else {
      unint64_t v144 = v116;
    }
    *(_BYTE *)(a2 + v144) = v143;
    if (v116 + 1 <= a3) {
      return v116 + 1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t cosmix_codec_get_decoded_size(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = 0LL;
  unint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  unsigned int v7 = 0;
  int v8 = 0;
  do
  {
    if ((v7 ^ v8) >> 24)
    {
      int v9 = v8;
      int v11 = v7;
    }

    else
    {
      do
      {
        int v9 = v8 << 8;
        unsigned int v10 = v7 << 8;
        int v11 = (v7 << 8) | 0xFF;
        if (v6 >= a3) {
          unint64_t v12 = 0LL;
        }
        else {
          unint64_t v12 = v6;
        }
        unsigned int v3 = *(unsigned __int8 *)(a2 + v12) | (v3 << 8);
        ++v6;
        unsigned int v13 = (v10 ^ (v8 << 8)) >> 24;
        unsigned int v7 = v11;
        v8 <<= 8;
      }

      while (!v13);
    }

    unsigned int v14 = v9 + ((v11 - v9) >> 1);
    v5 |= (unint64_t)(v3 <= v14) << v4;
    if ((2 * v5) >> v4 == 3) {
      break;
    }
    unsigned int v7 = v3 > v14 ? v11 : v9 + ((v11 - v9) >> 1);
    int v8 = v3 > v14 ? v14 + 1 : v9;
    ++v4;
  }

  while (v4 != 64);
  if (v5 < 2) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v16 = 1LL;
  uint64_t v17 = 2LL;
  do
  {
    uint64_t v18 = v17;
    result += ((uint64_t)(v5 << 63) >> 63) & v16;
    v17 += v16;
    uint64_t v16 = v18;
    BOOL v19 = v5 > 3;
    v5 >>= 1;
  }

  while (v19);
  return result;
}

unint64_t cosmix_codec_decode( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = 0LL;
  unint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  unsigned int v9 = 0;
  unsigned int v10 = 0;
  do
  {
    if ((v9 ^ v10) >> 24)
    {
      unsigned int v11 = v10;
      int v13 = v9;
    }

    else
    {
      do
      {
        unsigned int v11 = v10 << 8;
        unsigned int v12 = v9 << 8;
        int v13 = (v9 << 8) | 0xFF;
        if (v8 >= a5) {
          unint64_t v14 = 0LL;
        }
        else {
          unint64_t v14 = v8;
        }
        unsigned int v5 = *(unsigned __int8 *)(a4 + v14) | (v5 << 8);
        ++v8;
        unsigned int v15 = (v12 ^ (v10 << 8)) >> 24;
        unsigned int v9 = v13;
        v10 <<= 8;
      }

      while (!v15);
    }

    unsigned int v9 = v11 + ((v13 - v11) >> 1);
    uint64_t v16 = v5 <= v9;
    if (v5 > v9) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = v11;
    }
    if (v5 > v9) {
      unsigned int v9 = v13;
    }
    v7 |= v16 << v6;
    if ((2 * v7) >> v6 == 3) {
      break;
    }
    ++v6;
  }

  while (v6 != 64);
  if (v7 < 2)
  {
    unint64_t v17 = 0LL;
  }

  else
  {
    unint64_t v17 = 0LL;
    uint64_t v18 = 1LL;
    uint64_t v19 = 2LL;
    do
    {
      uint64_t v20 = v19;
      v17 += ((uint64_t)(v7 << 63) >> 63) & v18;
      v19 += v18;
      uint64_t v18 = v20;
      BOOL v21 = v7 > 3;
      v7 >>= 1;
    }

    while (v21);
  }

  if (v17 >= a3) {
    unint64_t result = a3;
  }
  else {
    unint64_t result = v17;
  }
  if ((v9 ^ v10) >> 24)
  {
    unsigned int v23 = v10;
    unsigned int v25 = v9;
  }

  else
  {
    do
    {
      unsigned int v23 = v10 << 8;
      unsigned int v24 = v9 << 8;
      unsigned int v25 = (v9 << 8) | 0xFF;
      if (v8 >= a5) {
        unint64_t v26 = 0LL;
      }
      else {
        unint64_t v26 = v8;
      }
      unsigned int v5 = *(unsigned __int8 *)(a4 + v26) | (v5 << 8);
      ++v8;
      unsigned int v27 = (v24 ^ (v10 << 8)) >> 24;
      unsigned int v9 = v25;
      v10 <<= 8;
    }

    while (!v27);
  }

  unsigned int v28 = v23 + ((v25 - v23) >> 1);
  if (v5 <= v28)
  {
    if (result)
    {
      uint64_t v38 = 0LL;
      unsigned int v39 = 0;
      unsigned int v40 = 0;
      unsigned int v41 = 0;
      unsigned int v42 = 0;
      unsigned int v43 = 0;
      unsigned int v44 = 0;
      unsigned int v45 = 32;
      unint64_t v88 = result;
      do
      {
        uint64_t v95 = v38;
        char v46 = 32 - *(_DWORD *)(a1 + 16);
        uint64_t v47 = *(void *)(a1 + 8);
        uint64_t v101 = v47 + ((unint64_t)v44 >> v46);
        uint64_t v100 = v47 + ((unint64_t)v43 >> v46);
        uint64_t v99 = v47 + ((unint64_t)v42 >> v46);
        uint64_t v98 = v47 + ((unint64_t)v41 >> v46);
        uint64_t v97 = v47 + ((unint64_t)v40 >> v46);
        uint64_t v96 = v47 + ((unint64_t)v39 >> v46);
        unsigned int v92 = v44;
        unsigned int v93 = v43;
        char v48 = v44;
        char v49 = v43;
        unsigned int v94 = v42;
        char v50 = v42;
        unint64_t v51 = *(void *)a1 + ((unint64_t)v45 << 8);
        int v52 = 8;
        unsigned int v53 = 1;
        unsigned int v91 = v45 << 8;
        do
        {
          unsigned int v54 = *(unsigned __int8 *)(v51 + v53);
          char v55 = v54 ^ v53;
          unsigned int v56 = v54 >> 4;
          if ((v55 & 0xF) != 0) {
            uint64_t v57 = 8LL;
          }
          else {
            uint64_t v57 = v56;
          }
          unsigned int v58 = *(unsigned __int8 *)(v101 + v53);
          char v59 = v58 ^ v48;
          unsigned int v60 = v58 >> 4;
          if ((v59 & 0xF) != 0) {
            uint64_t v61 = 8LL;
          }
          else {
            uint64_t v61 = v60;
          }
          unsigned int v62 = *(unsigned __int8 *)(v100 + v53);
          char v63 = v62 ^ v49;
          unsigned int v64 = v62 >> 4;
          if ((v63 & 0xF) != 0) {
            unsigned int v65 = 8;
          }
          else {
            unsigned int v65 = v64;
          }
          unsigned int v66 = *(unsigned __int8 *)(v99 + v53);
          char v67 = v66 ^ v50;
          unsigned int v68 = v66 >> 4;
          if ((v67 & 0xF) != 0) {
            unsigned int v69 = 8;
          }
          else {
            unsigned int v69 = v68;
          }
          unsigned int v70 = *(unsigned __int8 *)(v98 + v53);
          char v71 = v70 ^ v41;
          unsigned int v72 = v70 >> 4;
          if ((v71 & 0xF) != 0) {
            uint64_t v73 = 8LL;
          }
          else {
            uint64_t v73 = v72;
          }
          unsigned int v74 = *(unsigned __int8 *)(v97 + v53);
          char v75 = v74 ^ v40;
          unsigned int v76 = v74 >> 4;
          if ((v75 & 0xF) != 0) {
            unsigned int v77 = 8;
          }
          else {
            unsigned int v77 = v76;
          }
          unsigned int v78 = *(unsigned __int8 *)(v96 + v53);
          char v79 = v78 ^ v39;
          unsigned int v80 = v78 >> 4;
          if ((v79 & 0xF) != 0) {
            unsigned int v81 = 8;
          }
          else {
            unsigned int v81 = v80;
          }
          if ((v28 ^ v23) >> 24)
          {
            unsigned int v82 = v23;
            int v84 = v28;
          }

          else
          {
            do
            {
              unsigned int v82 = v23 << 8;
              unsigned int v83 = v28 << 8;
              int v84 = (v28 << 8) | 0xFF;
              if (v8 >= a5) {
                unint64_t v85 = 0LL;
              }
              else {
                unint64_t v85 = v8;
              }
              unsigned int v5 = *(unsigned __int8 *)(a4 + v85) | (v5 << 8);
              ++v8;
              unsigned int v86 = (v83 ^ (v23 << 8)) >> 24;
              unsigned int v28 = v84;
              v23 <<= 8;
            }

            while (!v86);
          }

          unsigned int v87 = v82
              + ((*(unsigned __int8 *)(*(void *)(a1 + 48)
                                     + (v57 << 8)
                                     + (*(_BYTE *)(*(void *)(a1 + 32) + (v61 << 8) + 16LL * v65 + v69) & 0xF0)
                                     + ((unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 40)
                                                                             + (v73 << 8)
                                                                             + 16LL * v77
                                                                             + v81) >> 4))
                * (unint64_t)(v84 - v82)) >> 8);
          if (v5 > v87) {
            unsigned int v23 = v87 + 1;
          }
          else {
            unsigned int v23 = v82;
          }
          if (v5 > v87) {
            unsigned int v28 = v84;
          }
          else {
            unsigned int v28 = v87;
          }
          unsigned int v53 = (v5 <= v87) | (2 * v53);
          --v52;
        }

        while (v52);
        unsigned int v45 = v53;
        else {
          unsigned int v39 = 0;
        }
        unsigned int v40 = -1640531535 * (v41 + v53);
        unsigned int v41 = -1640531535 * (v94 + v53);
        unsigned int v42 = -1640531535 * (v93 + v53);
        unsigned int v43 = -1640531535 * (v92 + v53);
        unsigned int v44 = -1640531535 * (v53 | v91);
        unint64_t result = v88;
        *(_BYTE *)(a2 + v95) = v53;
        uint64_t v38 = v95 + 1;
      }

      while (v95 + 1 != v88);
    }
  }

  else if (result)
  {
    uint64_t v29 = 0LL;
    unsigned int v30 = v28 + 1;
    do
    {
      for (unsigned int i = 1; i < 0x100; unsigned int i = v37 | (2 * i))
      {
        if ((v25 ^ v30) >> 24)
        {
          unsigned int v32 = v30;
          int v34 = v25;
        }

        else
        {
          do
          {
            unsigned int v32 = v30 << 8;
            unsigned int v33 = v25 << 8;
            int v34 = (v25 << 8) | 0xFF;
            if (v8 >= a5) {
              unint64_t v35 = 0LL;
            }
            else {
              unint64_t v35 = v8;
            }
            unsigned int v5 = *(unsigned __int8 *)(a4 + v35) | (v5 << 8);
            ++v8;
            unsigned int v36 = (v33 ^ (v30 << 8)) >> 24;
            unsigned int v25 = v34;
            v30 <<= 8;
          }

          while (!v36);
        }

        unsigned int v25 = v32 + ((v34 - v32) >> 1);
        BOOL v37 = v5 <= v25;
        if (v5 > v25) {
          unsigned int v30 = v25 + 1;
        }
        else {
          unsigned int v30 = v32;
        }
        if (v5 > v25) {
          unsigned int v25 = v34;
        }
      }

      *(_BYTE *)(a2 + v29++) = i;
    }

    while (v29 != result);
  }

  return result;
}

void **cosmix_model_create(unsigned int a1)
{
  if (a1 > 5) {
    return 0LL;
  }
  uint64_t v2 = (void **)calloc(1uLL, 0xAB020uLL);
  unsigned int v3 = v2;
  if (!v2 || (*((_BYTE *)v2 + 700440) = a1, (uint64_t v4 = (char *)malloc(9LL * ((0x100000 << a1) | 0x100u))) == 0LL))
  {
    cosmix_model_destroy(v3);
    return 0LL;
  }

  uint64_t v5 = a1 + 20LL;
  v3[73728] = v4;
  v3[73729] = (void *)v5;
  unint64_t v6 = ((1 << v5) + 256);
  v3[73730] = (void *)v6;
  do
  {
    *(void *)uint64_t v4 = 0x200000001LL;
    v4[8] = 0;
    v4 += 9;
    --v6;
  }

  while (v6);
  do
  {
    unint64_t v7 = (char *)v3 + v6;
    *(void *)unint64_t v7 = 0x200000001LL;
    v7[8] = 0;
    v6 += 9LL;
  }

  while (v6 != 589824);
  for (uint64_t i = 0LL; i != 36864; i += 9LL)
  {
    unsigned int v9 = (char *)v3 + i + 589848;
    *(void *)unsigned int v9 = 0x800000004LL;
    v9[8] = 0;
  }

  for (uint64_t j = 0LL; j != 36864; j += 9LL)
  {
    unsigned int v11 = (char *)v3 + j + 626712;
    *(void *)unsigned int v11 = 0x800000004LL;
    v11[8] = 0;
  }

  for (uint64_t k = 0LL; k != 36864; k += 9LL)
  {
    int v13 = (char *)v3 + k + 663576;
    *(void *)int v13 = 0x800000004LL;
    v13[8] = 0;
  }

  return v3;
}

void cosmix_model_destroy(void **a1)
{
  if (a1)
  {
    free(a1[73728]);
    free(a1);
  }

uint64_t cosmix_model_save_codec(uint64_t a1, const char *a2, int a3)
{
  unsigned int v3 = (unsigned __int8 *)(a1 + 700440);
  unint64_t v4 = *(unsigned __int8 *)(a1 + 700440);
  uint64_t v5 = (0x100000 << v4) | 0x100u;
  else {
    size_t v6 = 0LL;
  }
  if (v4 > 5) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v10 = malloc((0x100000 << v4) | 0x100u);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = v10;
  unsigned int v12 = fopen(a2, "wb");
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  int v13 = v12;
  int __ptr_4 = 1;
  int __ptr = a3;
  HIWORD(__ptr_4) = *v3;
  if (fwrite(&__ptr, 1uLL, 8uLL, v12) != 8) {
    goto LABEL_23;
  }
  uint64_t v14 = 0LL;
  unsigned int v15 = (unsigned int *)(a1 + 663580);
  uint64_t v16 = (_BYTE *)(a1 + 626720);
  unint64_t v17 = (_BYTE *)(*(void *)(a1 + 589824) + 8LL);
  do
  {
    v11[v14++] = *v17 & 0xF | (16
    v17 += 9;
  }

  while (v5 != v14);
  if (fwrite(v11, 1uLL, v6, v13) == v6)
  {
    uint64_t v18 = 0LL;
    uint64_t v19 = (_BYTE *)(a1 + 8);
    do
    {
      v11[v18++] = *v19 & 0xF | (16
      v19 += 9;
    }

    while (v18 != 0x10000);
    uint64_t v20 = (_BYTE *)(a1 + 589856);
    uint64_t v21 = 0x10000LL;
    uint64_t v22 = 69632LL;
    do
    {
      v11[v21] = *v20 & 0xF | (16
      v20 += 9;
      ++v21;
    }

    while (v21 != 69632);
    uint64_t v23 = 73728LL;
    do
    {
      v11[v22] = *v16 & 0xF | (16
      v16 += 9;
      ++v22;
    }

    while (v22 != 73728);
    do
    {
      unint64_t v24 = ((unint64_t)*(v15 - 1) << 16) / *v15;
      v11[v23] = ((int)((v24 >> 8) - 1) < 0) + BYTE1(v24);
      unsigned int v15 = (unsigned int *)((char *)v15 + 9);
      ++v23;
    }

    while (v23 != 77824);
    if (fwrite(v11, 1uLL, 0x13000uLL, v13) == 77824) {
      uint64_t v25 = 0LL;
    }
    else {
      uint64_t v25 = 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_23:
    uint64_t v25 = 0xFFFFFFFFLL;
  }

  free(v11);
  fclose(v13);
  return v25;
}

void *cosmix_codec_map(const char *a1)
{
  uint64_t v2 = calloc(1uLL, 0x58uLL);
  unsigned int v3 = v2;
  if (!v2) {
    goto LABEL_3;
  }
  *((_DWORD *)v2 + 20) = -1;
  if (stat(a1, &v12)) {
    goto LABEL_3;
  }
  v3[9] = v12.st_size;
  int v5 = open(a1, 0);
  *((_DWORD *)v3 + 20) = v5;
  if (v5 < 0) {
    goto LABEL_3;
  }
  size_t v6 = mmap(0LL, v3[9], 1, 2, v5, 0LL);
  v3[8] = v6;
  if (v6 == (_WORD *)-1LL)
  {
    v3[8] = 0LL;
LABEL_3:
    cosmix_codec_unmap(v3);
    return 0LL;
  }

  uint64_t v7 = v3[9];
  v3[7] = v6;
  if (v7 < 8) {
    goto LABEL_3;
  }
  if (v6[2] != 1) {
    goto LABEL_3;
  }
  unint64_t v8 = (unsigned __int16)v6[3];
  if (v8 > 5) {
    goto LABEL_3;
  }
  uint64_t v9 = (0x100000 << v8) | 0x100u;
  unint64_t v10 = v8 + 20;
  v3[2] = v10;
  v3[3] = ((1 << v10) + 256);
  unsigned int v11 = (char *)v6 + v9 + 8;
  *unsigned int v3 = v11;
  v3[1] = v6 + 4;
  v3[4] = v11 + 0x10000;
  v3[5] = v11 + 69632;
  v3[6] = v11 + 73728;
  return v3;
}

void cosmix_codec_unmap(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 20);
    if ((v2 & 0x80000000) == 0)
    {
      if (*((void *)a1 + 8))
      {
        munmap(*((void **)a1 + 8), *((void *)a1 + 9));
        *((void *)a1 + 8) = 0LL;
        int v2 = *((_DWORD *)a1 + 20);
      }

      close(v2);
    }
  }

  free(a1);
}

uint64_t cosmix_codec_get_id(uint64_t a1)
{
  return **(unsigned int **)(a1 + 56);
}

uint64_t zlib_decode_scratch_size()
{
  return 131216LL;
}

size_t zlib_decode_buffer( const Bytef *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5, int a6)
{
  if (a6)
  {
    BOOL v9 = a4 >= 2;
    a4 -= 2LL;
    if (!v9) {
      return 0LL;
    }
    int v10 = *a3;
    int v11 = a3[1];
    unsigned int v12 = v11 | (v10 << 8);
    int v13 = v11 & 0x20;
    int v14 = v12 - 31 * ((138547333 * (unint64_t)v12) >> 32);
    BOOL v15 = (v10 & 0xF) == 8 && v13 == 0;
    if (!v15 || v14 != 0) {
      return 0LL;
    }
    a3 += 2;
  }

  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(void *)(a5 + 32) = 8 * a4;
  *(void *)(a5 + 40) = 0LL;
  *(void *)a5 = a1;
  *(void *)(a5 + 8) = a2;
  *(void *)(a5 + 16) = a4;
  *(void *)(a5 + 24) = a3;
  *(void *)(a5 + 56) = &a1[a2];
  *(void *)(a5 + 64) = a1;
  if (a4 >= 9)
  {
    *(void *)(a5 + 16) = a4 - 8;
    *(void *)(a5 + 32) = 8 * a4 - 64;
    size_t v18 = zlibDecodeBuffer(a5);
    *(void *)(a5 + 16) += 8LL;
    *(void *)(a5 + 32) += 64LL;
    if (*(_DWORD *)(a5 + 48) == 11)
    {
      size_t v19 = v18;
      if (v18) {
        goto LABEL_25;
      }
    }
  }

  size_t result = zlibDecodeBufferSafe(a5);
  size_t v19 = result;
  if (result)
  {
LABEL_25:
    unint64_t v20 = (*(void *)(a5 + 40) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)(a5 + 40) = v20;
    if (!a6) {
      return v19;
    }
    unint64_t v21 = *(void *)(a5 + 32);
    BOOL v9 = v21 >= v20;
    unint64_t v22 = v21 - v20;
    if (!v9) {
      unint64_t v22 = 0LL;
    }
    if (v22 < 0x20) {
      return v19;
    }
    uLong v23 = adler32(0LL, 0LL, 0);
    int v24 = adler32(v23, a1, v19);
    size_t result = 0LL;
    if (bswap32(*(_DWORD *)(*(void *)(a5 + 24) + (*(void *)(a5 + 40) >> 3))) == v24) {
      return v19;
    }
  }

  return result;
}

size_t zlibDecodeBuffer(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  if (v1 == 11) {
    return 0LL;
  }
  unint64_t v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = a1 + 144;
  uint64_t v6 = a1 + 65680;
  unint64_t v8 = *(void *)(a1 + 128);
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v9 = *(void *)(a1 + 120);
  int v12 = *(_DWORD *)(a1 + 88);
  int v11 = *(_DWORD *)(a1 + 92);
  switch(v1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_15;
    case 2:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v15 = *(void *)(a1 + 40);
      size_t v16 = *(void *)(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 24);
      goto LABEL_19;
    case 3:
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_29;
    case 4:
      goto LABEL_32;
    case 5:
      goto LABEL_36;
    case 6:
      unint64_t v18 = *(void *)(a1 + 96);
      goto LABEL_41;
    case 7:
      goto LABEL_45;
    case 9:
      goto LABEL_53;
    case 10:
      break;
    default:
      goto LABEL_71;
  }

  while (2)
  {
    unint64_t v51 = *(void *)(a1 + 8);
    unint64_t v52 = v51 - v7;
    if (v51 < v7)
    {
      uint64_t v59 = *(void *)(a1 + 64);
      if (v51)
      {
        unint64_t v60 = 0LL;
        do
        {
          *(_BYTE *)(v59 + v60) = *(_BYTE *)(v59 - v8 + v60);
          ++v60;
          unint64_t v61 = *(void *)(a1 + 8);
        }

        while (v61 > v60);
        uint64_t v59 = *(void *)(a1 + 64);
      }

      else
      {
        unint64_t v61 = 0LL;
      }

      uint64_t v62 = v59 + v61;
      *(void *)(a1 + 64) = v62;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      *(void *)(a1 + 128) = v8;
      *(void *)(a1 + 136) = v7 - v61;
      *(void *)(a1 + 8) = 0LL;
      *(_DWORD *)(a1 + 48) = 10;
      return v62 - *(void *)a1;
    }

    unint64_t v53 = *(void *)(a1 + 64);
    uint64_t v54 = -(uint64_t)v8;
    if (v51 < v7 + 31)
    {
      if (v7)
      {
        uint64_t v55 = v7;
        do
        {
          *(_BYTE *)unint64_t v53 = *(_BYTE *)(v53 + v54);
          ++v53;
          --v55;
        }

        while (v55);
        unint64_t v53 = *(void *)(a1 + 64);
        unint64_t v51 = *(void *)(a1 + 8);
      }

      *(void *)(a1 + 64) = v53 + v7;
      uint64_t v38 = v51 - v7;
      goto LABEL_61;
    }

    unint64_t v56 = v53 + v7;
    *(void *)(a1 + 64) = v53 + v7;
    *(void *)(a1 + 8) = v52;
    if (v8 < 8)
    {
      if (v8 == 1)
      {
        if (v7 >= 1)
        {
          uint64_t v57 = 0x101010101010101LL * *(unsigned __int8 *)(v53 - v8);
          do
          {
            *(void *)unint64_t v53 = v57;
            v53 += 8LL;
          }

          while (v53 < v56);
        }
      }

      else if (v7 >= 1)
      {
        do
        {
          *(_WORD *)unint64_t v53 = *(_WORD *)(v53 - v8);
          *(_WORD *)(v53 + 2) = *(_WORD *)(v53 - v8 + 2);
          v53 += 4LL;
        }

        while (v53 < v56);
      }
    }

    else if (v7 >= 1)
    {
      do
      {
        *(void *)unint64_t v53 = *(void *)(v53 - v8);
        *(void *)(v53 + 8) = *(void *)(v53 - v8 + 8);
        v53 += 16LL;
      }

      while (v53 < v56);
    }

    while (1)
    {
LABEL_36:
      if (v9 >= v12)
      {
        unint64_t v34 = *(void *)(a1 + 40);
      }

      else
      {
        unint64_t v34 = *(void *)(a1 + 40);
        if (*(void *)(a1 + 32) <= v34)
        {
          size_t result = 0LL;
          int v58 = 5;
          goto LABEL_82;
        }

        unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> (v34 & 7);
        unint64_t v10 = *(void *)(*v4 + (v34 >> 3)) >> (v34 & 7);
      }

      unint64_t v35 = *(unsigned __int16 *)(v5 + 2 * (v10 & v12));
      uint64_t v36 = (v35 & 0xF) + 1;
      unint64_t v18 = v35 >> 4;
      *(void *)(a1 + 96) = v18;
      v10 >>= v36;
      v9 >>= v36;
      *(void *)(a1 + 40) = v36 + v34;
LABEL_41:
      if (v18 > 0xFF) {
        break;
      }
      if (!*(void *)(a1 + 8))
      {
        *(_DWORD *)(a1 + 48) = 6;
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 120) = v9;
        *(_DWORD *)(a1 + 88) = v12;
        *(_DWORD *)(a1 + 92) = v11;
LABEL_84:
        size_t v29 = *(void *)(a1 + 64);
        return v29 - *(void *)a1;
      }

      BOOL v37 = *(_BYTE **)(a1 + 64);
      *(void *)(a1 + 64) = v37 + 1;
      *BOOL v37 = v18;
      uint64_t v38 = *(void *)(a1 + 8) - 1LL;
LABEL_61:
      *(void *)(a1 + 8) = v38;
    }

    unint64_t v39 = v18 - 256;
    *(void *)(a1 + 96) = v39;
    if (!v39)
    {
LABEL_8:
      while (!*(_DWORD *)(a1 + 52))
      {
        unint64_t v13 = *(void *)(a1 + 32);
        unint64_t v19 = *(void *)(a1 + 40);
        unint64_t v20 = v13 - v19;
        if (v13 < v19) {
          unint64_t v20 = 0LL;
        }
        if (v20 <= 2)
        {
          size_t result = 0LL;
          *(_DWORD *)(a1 + 48) = 0;
          return result;
        }

        *(void *)(a1 + 72) = 0x800000008000LL;
        uint64_t v21 = *(void *)(a1 + 24);
        *(_DWORD *)(a1 + 52) = (*(void *)(v21 + (v19 >> 3)) >> (v19 & 7)) & 1;
        uint64_t v22 = *(void *)(v21 + ((v19 + 1) >> 3)) >> ((v19 + 1) & 7);
        unint64_t v14 = v19 + 3;
        *(void *)(a1 + 40) = v19 + 3;
        int v23 = v22 & 3;
        switch(v23)
        {
          case 1:
            goto LABEL_32;
          case 2:
LABEL_29:
            if (readHuffmanTable(v4, (int *)(a1 + 72), v5, (int *)(a1 + 76), v6))
            {
              size_t result = 0LL;
              *(void *)(a1 + 40) = v14;
              int v33 = 3;
              goto LABEL_72;
            }

LABEL_32:
            unint64_t v9 = 0LL;
            unint64_t v10 = 0LL;
            int v12 = *(_DWORD *)(a1 + 72) - 1;
            int v11 = *(_DWORD *)(a1 + 76) - 1;
            goto LABEL_36;
          case 3:
            goto LABEL_71;
        }

            v37.i64[0] = v23;
            v37.i64[1] = v24;
            size_t v27 = v21 + v1 - v23;
            LODWORD(v38) = v27;
            if (v27 >= 0x28)
            {
              int v33 = v10;
              unint64_t v34 = v9;
              goto LABEL_34;
            }

            size_t v30 = *(unsigned int *)(a1 + 96);
            if (!(_DWORD)v30)
            {
              unint64_t v4 = v37;
              *(int8x16_t *)unsigned int v3 = v37;
              *(void *)(v3 + 16) = v38;
              goto LABEL_38;
            }

            int v33 = v10;
            unint64_t v34 = v9;
            if (*(void *)v3 + v30 <= v23)
            {
              unint64_t v4 = v37;
              *(int8x16_t *)unsigned int v3 = v37;
              *(void *)(v3 + 16) = v38;
            }

            else
            {
              if (v27 <= v30)
              {
LABEL_7:
                int v12 = (uint64_t *)a1;
                unint64_t v13 = (int *)v3;
              }

              else
              {
LABEL_34:
                unint64_t v13 = (int *)&v37;
                int v12 = (uint64_t *)a1;
              }

              *(void *)unsigned int v3 = 0LL;
              *(void *)(v3 + 8) = 0LL;
              *(void *)(v3 + 16) = 0LL;
            }

            unint64_t v10 = v33;
            unint64_t v9 = v34;
            goto LABEL_38;
          }
        }

        if (v1 - v11 >= 946)
        {
          int v33 = v10;
          unint64_t v34 = v9;
          if (*(_DWORD *)(a1 + 96)) {
            goto LABEL_7;
          }
          unint64_t v39 = vaddq_s64(vdupq_n_s64(v11), (int64x2_t)xmmword_1810D3B90);
          unint64_t v40 = 0;
          unint64_t v26 = lzfseBackendMatch((uint64_t *)a1, v39.i32);
          unint64_t v10 = v33;
          unint64_t v9 = v34;
          if (v26) {
            return 4294967294LL;
          }
        }
      }

LABEL_45:
    unint64_t v40 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 32) <= v40)
    {
      size_t result = 0LL;
      int v58 = 7;
LABEL_82:
      *(_DWORD *)(a1 + 48) = v58;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      return result;
    }

    unint64_t v41 = *(void *)(a1 + 96);
    if (v41 < 0x1E)
    {
      unint64_t v42 = 0xFFFFFFFFFFFFFFFFLL >> (v40 & 7);
      unint64_t v43 = *(void *)(*(void *)(a1 + 24) + (v40 >> 3)) >> (v40 & 7);
      uint64_t v7 = zlibDecodeBufferSafe_litlen_base[v41];
      if (v41 >= 9 && v41 != 29)
      {
        unint64_t v44 = (v41 - 5) >> 2;
        v7 += v43 & ~(-1 << v44);
        v43 >>= v44;
        v42 >>= v44;
        v40 += v44;
        *(void *)(a1 + 40) = v40;
      }

      unint64_t v45 = *(unsigned __int16 *)(v6 + 2 * (v43 & v11));
      if (v45 < 0x1E0)
      {
        unint64_t v46 = v45 >> 4;
        unint64_t v8 = zlibDecodeBufferSafe_distance_base[v45 >> 4];
        uint64_t v47 = (v45 & 0xF) + 1;
        unint64_t v10 = v43 >> v47;
        unint64_t v9 = v42 >> v47;
        unint64_t v48 = v40 + v47;
        *(void *)(a1 + 40) = v48;
        if (v45 >= 0x40)
        {
          unint64_t v49 = v46 - 2;
          unint64_t v50 = (v46 - 2) >> 1;
          v8 += v10 & ~(-1 << v50);
          v10 >>= v50;
          v9 >>= v50;
          *(void *)(a1 + 40) = v48 + (v49 >> 1);
        }

  unint64_t v50 = v45 * v47;
  if (v45 * v47)
  {
    char v79 = (void *)BrotliAllocate(v30);
    if (*(_DWORD *)(v30 + 24)) {
      return;
    }
    unint64_t v51 = v50;
    unint64_t v52 = v79;
    do
    {
      bzero(v52, 0x408uLL);
      v52[129] = 0x7FF0000000000000LL;
      v52 += 130;
      --v51;
    }

    while (v51);
    unint64_t v43 = (uint64_t)a11;
  }

  else
  {
    if (*(_DWORD *)(v30 + 24)) {
      return;
    }
    char v79 = 0LL;
  }

  unint64_t v53 = 4LL * *v44;
  if (v53)
  {
    unsigned int v76 = (void *)BrotliAllocate(v30);
    if (*(_DWORD *)(v30 + 24)) {
      return;
    }
    uint64_t v54 = v76;
    do
    {
      bzero(v54, 0x888uLL);
      v54[273] = 0x7FF0000000000000LL;
      v54 += 274;
      --v53;
    }

    while (v53);
    unint64_t v43 = (uint64_t)a11;
  }

  else
  {
    if (*(_DWORD *)(v30 + 24)) {
      return;
    }
    unsigned int v76 = 0LL;
  }

  uint64_t v55 = *(void *)(v43 + 48);
  *(void *)(v43 + 200) = v55;
  if (v55) {
    unint64_t v56 = (void *)BrotliAllocate(v30);
  }
  else {
    unint64_t v56 = 0LL;
  }
  *(void *)(v43 + 192) = v56;
  if (!*(_DWORD *)(v30 + 24))
  {
    uint64_t v57 = *(void *)(v43 + 200);
    if (v57)
    {
      do
      {
        bzero(v56, 0xB08uLL);
        v56[353] = 0x7FF0000000000000LL;
        v56 += 354;
        --v57;
      }

      while (v57);
      unint64_t v43 = (uint64_t)a11;
      unint64_t v56 = (void *)a11[24];
    }

    BrotliBuildHistogramsWithContext( a8,  a9,  v43,  (uint64_t)(a11 + 6),  (uint64_t)v44,  a2,  a3,  a4,  a6,  a7,  v46,  (uint64_t)v79,  (uint64_t)v56,  (uint64_t)v76);
    BrotliFree(v30, v46);
    int v58 = *(void *)v43 << 6;
    *(void *)(v43 + 152) = v58;
    uint64_t v59 = v58 ? BrotliAllocate(v30) : 0LL;
    *(void *)(v43 + 144) = v59;
    if (!*(_DWORD *)(v30 + 24))
    {
      unint64_t v60 = *(void *)(v43 + 152);
      *(void *)(v43 + 184) = v60;
      if (v60)
      {
        unint64_t v61 = BrotliAllocate(v30);
        uint64_t v62 = *(_DWORD *)(v30 + 24);
        *(void *)(v43 + 176) = v61;
        if (v62) {
          return;
        }
        char v63 = (char *)v61;
      }

      else
      {
        char v63 = 0LL;
        *(void *)(v43 + 176) = 0LL;
      }

      BrotliClusterHistogramsLiteral( v30,  (uint64_t)v79,  v50,  0x100uLL,  v63,  (uint64_t *)(v43 + 184),  *(unsigned int **)(v43 + 144));
      if (!*(_DWORD *)(v30 + 24))
      {
        BrotliFree(v30, (unint64_t)v79);
        if (*((_DWORD *)a5 + 8))
        {
          unsigned int v64 = *(void *)v43;
          if (*(void *)v43)
          {
            unsigned int v65 = *(void *)(v43 + 144);
            unsigned int v66 = v65 + (v64 << 8);
            do
            {
              --v64;
              char v67 = -256LL;
              do
              {
                *(_DWORD *)(v66 + v67) = *(_DWORD *)(v65 + 4 * v64);
                v67 += 4LL;
              }

              while (v67);
              v66 -= 256LL;
            }

            while (v64);
          }
        }

        unsigned int v68 = *(void *)(v43 + 96);
        *(void *)(v43 + 168) = 4 * v68;
        unsigned int v69 = 4 * v68 ? BrotliAllocate(v30) : 0LL;
        *(void *)(v43 + 160) = v69;
        if (!*(_DWORD *)(v30 + 24))
        {
          unsigned int v70 = *(void *)(v43 + 168);
          *(void *)(v43 + 216) = v70;
          if (v70)
          {
            char v71 = BrotliAllocate(v30);
            unsigned int v72 = *(_DWORD *)(v30 + 24);
            *(void *)(v43 + 208) = v71;
            if (v72) {
              return;
            }
            uint64_t v73 = (char *)v71;
          }

          else
          {
            uint64_t v73 = 0LL;
            *(void *)(v43 + 208) = 0LL;
          }

          BrotliClusterHistogramsDistance( v30,  (uint64_t)v76,  *(void *)(v43 + 168),  0x100uLL,  v73,  (uint64_t *)(v43 + 216),  *(unsigned int **)(v43 + 160));
          if (!*(_DWORD *)(v30 + 24)) {
            BrotliFree(v30, (unint64_t)v76);
          }
        }
      }
    }
  }

size_t zlibDecodeBufferSafe(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  if (v1 == 11) {
    return 0LL;
  }
  unint64_t v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = a1 + 144;
  uint64_t v6 = a1 + 65680;
  unint64_t v8 = *(void *)(a1 + 128);
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v9 = *(void *)(a1 + 120);
  int v12 = *(_DWORD *)(a1 + 88);
  int v11 = *(_DWORD *)(a1 + 92);
  switch(v1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_21;
    case 2:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v15 = *(void *)(a1 + 40);
      size_t v16 = *(void *)(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 24);
      goto LABEL_28;
    case 3:
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_38;
    case 4:
      goto LABEL_41;
    case 5:
      goto LABEL_45;
    case 6:
      unint64_t v18 = *(void *)(a1 + 96);
      goto LABEL_54;
    case 7:
      goto LABEL_58;
    case 9:
      goto LABEL_70;
    case 10:
      goto LABEL_71;
    default:
      goto LABEL_88;
  }

  do
  {
LABEL_71:
    unint64_t v63 = *(void *)(a1 + 8);
    unint64_t v64 = v63 - v7;
    if (v63 < v7)
    {
      uint64_t v70 = *(void *)(a1 + 64);
      if (v63)
      {
        unint64_t v71 = 0LL;
        do
        {
          *(_BYTE *)(v70 + v71) = *(_BYTE *)(v70 - v8 + v71);
          ++v71;
          unint64_t v72 = *(void *)(a1 + 8);
        }

        while (v72 > v71);
        uint64_t v70 = *(void *)(a1 + 64);
      }

      else
      {
        unint64_t v72 = 0LL;
      }

      uint64_t v74 = v70 + v72;
      *(void *)(a1 + 64) = v74;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      *(void *)(a1 + 128) = v8;
      *(void *)(a1 + 136) = v7 - v72;
      *(void *)(a1 + 8) = 0LL;
      *(_DWORD *)(a1 + 48) = 10;
      return v74 - *(void *)a1;
    }

    unint64_t v65 = *(void *)(a1 + 64);
    uint64_t v66 = -(uint64_t)v8;
    if (v63 < v7 + 31)
    {
      if (v7)
      {
        uint64_t v67 = v7;
        do
        {
          *(_BYTE *)unint64_t v65 = *(_BYTE *)(v65 + v66);
          ++v65;
          --v67;
        }

        while (v67);
        unint64_t v65 = *(void *)(a1 + 64);
        unint64_t v63 = *(void *)(a1 + 8);
      }

      *(void *)(a1 + 64) = v65 + v7;
      uint64_t v47 = v63 - v7;
      goto LABEL_78;
    }

    unint64_t v68 = v65 + v7;
    *(void *)(a1 + 64) = v65 + v7;
    *(void *)(a1 + 8) = v64;
    if (v8 < 8)
    {
      if (v8 == 1)
      {
        if (v7 >= 1)
        {
          uint64_t v69 = 0x101010101010101LL * *(unsigned __int8 *)(v65 - v8);
          do
          {
            *(void *)unint64_t v65 = v69;
            v65 += 8LL;
          }

          while (v65 < v68);
        }
      }

      else if (v7 >= 1)
      {
        do
        {
          *(_WORD *)unint64_t v65 = *(_WORD *)(v65 - v8);
          *(_WORD *)(v65 + 2) = *(_WORD *)(v65 - v8 + 2);
          v65 += 4LL;
        }

        while (v65 < v68);
      }
    }

    else if (v7 >= 1)
    {
      do
      {
        *(void *)unint64_t v65 = *(void *)(v65 - v8);
        *(void *)(v65 + 8) = *(void *)(v65 - v8 + 8);
        v65 += 16LL;
      }

      while (v65 < v68);
    }

    while (1)
    {
LABEL_45:
      if (v9 >= v12)
      {
        unint64_t v40 = *(void *)(a1 + 40);
      }

      else
      {
        unint64_t v39 = *(void *)(a1 + 32);
        unint64_t v40 = *(void *)(a1 + 40);
        BOOL v36 = v39 > v40;
        unint64_t v41 = v39 - v40;
        if (!v36)
        {
          size_t result = 0LL;
          int v73 = 5;
LABEL_97:
          *(_DWORD *)(a1 + 48) = v73;
          *(void *)(a1 + 112) = v10;
          *(void *)(a1 + 120) = v9;
          *(_DWORD *)(a1 + 88) = v12;
          *(_DWORD *)(a1 + 92) = v11;
          return result;
        }

        char v42 = v40 & 7;
        size_t v43 = (v41 + 7) >> 3 >= 8 ? 8LL : (v41 + 7) >> 3;
        unint64_t __dst = 0LL;
        memcpy(&__dst, (const void *)(*v4 + (v40 >> 3)), v43);
        unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * v43) >> v42;
        unint64_t v10 = __dst >> v42;
      }

      unint64_t v44 = *(unsigned __int16 *)(v5 + 2 * (v10 & v12));
      uint64_t v45 = (v44 & 0xF) + 1;
      unint64_t v18 = v44 >> 4;
      *(void *)(a1 + 96) = v18;
      v10 >>= v45;
      v9 >>= v45;
      *(void *)(a1 + 40) = v45 + v40;
LABEL_54:
      if (v18 > 0xFF) {
        break;
      }
      if (!*(void *)(a1 + 8))
      {
        *(_DWORD *)(a1 + 48) = 6;
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 120) = v9;
        *(_DWORD *)(a1 + 88) = v12;
        *(_DWORD *)(a1 + 92) = v11;
LABEL_99:
        size_t v34 = *(void *)(a1 + 64);
        return v34 - *(void *)a1;
      }

      unint64_t v46 = *(_BYTE **)(a1 + 64);
      *(void *)(a1 + 64) = v46 + 1;
      *unint64_t v46 = v18;
      uint64_t v47 = *(void *)(a1 + 8) - 1LL;
LABEL_78:
      *(void *)(a1 + 8) = v47;
    }

    unint64_t v48 = v18 - 256;
    *(void *)(a1 + 96) = v48;
    if (!v48)
    {
LABEL_8:
      while (!*(_DWORD *)(a1 + 52))
      {
        unint64_t v13 = *(void *)(a1 + 32);
        unint64_t v19 = *(void *)(a1 + 40);
        unint64_t v20 = v13 - v19;
        if (v13 < v19) {
          unint64_t v20 = 0LL;
        }
        if (v20 <= 2)
        {
          size_t result = 0LL;
          *(_DWORD *)(a1 + 48) = 0;
          return result;
        }

        if ((v13 + 7 - v19) >> 3 >= 8) {
          size_t v21 = 8LL;
        }
        else {
          size_t v21 = (v13 + 7 - v19) >> 3;
        }
        unint64_t __dst = 0LL;
        uint64_t v22 = *(void *)(a1 + 24);
        memcpy(&__dst, (const void *)(v22 + (v19 >> 3)), v21);
        unint64_t v23 = __dst >> (v19 & 7);
        *(void *)(a1 + 40) = v19 + 1;
        *(_DWORD *)(a1 + 52) = v23 & 1;
        if ((v13 + 7 + ~v19) >> 3 >= 8) {
          size_t v24 = 8LL;
        }
        else {
          size_t v24 = (v13 + 7 + ~v19) >> 3;
        }
        unint64_t __dst = 0LL;
        memcpy(&__dst, (const void *)(v22 + ((v19 + 1) >> 3)), v24);
        unint64_t v25 = __dst >> ((v19 + 1) & 7);
        unint64_t v14 = v19 + 3;
        *(void *)(a1 + 40) = v14;
        int v26 = v25 & 3;
        *(void *)(a1 + 72) = 0x800000008000LL;
        switch(v26)
        {
          case 1:
            goto LABEL_41;
          case 2:
LABEL_38:
            if (readHuffmanTable(v4, (int *)(a1 + 72), v5, (int *)(a1 + 76), v6))
            {
              size_t result = 0LL;
              *(void *)(a1 + 40) = v14;
              int v38 = 3;
              goto LABEL_89;
            }

LABEL_21:
        unint64_t v27 = v13 - v14;
        if (v13 < v14) {
          unint64_t v27 = 0LL;
        }
        if (v27 <= 0xF)
        {
          size_t result = 0LL;
          int v38 = 1;
          goto LABEL_89;
        }

        unint64_t v28 = v14 + 7;
        unint64_t v29 = (v14 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        *(void *)(a1 + 40) = v29;
        if ((v13 - v29 + 7) >> 3 >= 8) {
          size_t v30 = 8LL;
        }
        else {
          size_t v30 = (v13 - v29 + 7) >> 3;
        }
        unint64_t __dst = 0LL;
        uint64_t v17 = *(void *)(a1 + 24);
        memcpy(&__dst, (const void *)(v17 + (v28 >> 3)), v30);
        size_t v16 = (unsigned __int16)__dst;
        *(void *)(a1 + 80) = (unsigned __int16)__dst;
        unint64_t v15 = v29 + 32;
        *(void *)(a1 + 40) = v29 + 32;
LABEL_28:
        unint64_t v31 = v13 - v15;
        if (v13 < v15) {
          unint64_t v31 = 0LL;
        }
        size_t v32 = v31 >> 3;
        if (v32 >= *(void *)(a1 + 8)) {
          size_t v32 = *(void *)(a1 + 8);
        }
        if (v32 >= v16) {
          size_t v33 = v16;
        }
        else {
          size_t v33 = v32;
        }
        memcpy(*(void **)(a1 + 64), (const void *)(v17 + (v15 >> 3)), v33);
        *(void *)(a1 + 40) += 8 * v33;
        *(void *)(a1 + 8) -= v33;
        size_t v34 = *(void *)(a1 + 64) + v33;
        *(void *)(a1 + 64) = v34;
        size_t v35 = *(void *)(a1 + 80);
        BOOL v36 = v35 > v33;
        size_t v37 = v35 - v33;
        if (v36)
        {
          *(void *)(a1 + 80) = v37;
          *(_DWORD *)(a1 + 48) = 2;
          return v34 - *(void *)a1;
        }
      }

      *(_DWORD *)(a1 + 48) = 11;
      goto LABEL_99;
    }

LABEL_58:
    unint64_t v49 = *(void *)(a1 + 32);
    unint64_t v50 = *(void *)(a1 + 40);
    BOOL v36 = v49 > v50;
    unint64_t v51 = v49 - v50;
    if (!v36)
    {
      size_t result = 0LL;
      int v73 = 7;
      goto LABEL_97;
    }

    if ((v51 + 7) >> 3 >= 8) {
      size_t v52 = 8LL;
    }
    else {
      size_t v52 = (v51 + 7) >> 3;
    }
    unint64_t __dst = 0LL;
    memcpy(&__dst, (const void *)(*(void *)(a1 + 24) + (v50 >> 3)), v52);
    unint64_t v53 = *(void *)(a1 + 96);
    if (v53 >= 0x1E) {
      break;
    }
    unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * v52) >> (v50 & 7);
    unint64_t v55 = __dst >> (v50 & 7);
    uint64_t v7 = zlibDecodeBufferSafe_litlen_base[v53];
    if (v53 >= 9 && v53 != 29)
    {
      unint64_t v56 = (v53 - 5) >> 2;
      v7 += v55 & ~(-1 << v56);
      v55 >>= v56;
      v54 >>= v56;
      v50 += v56;
      *(void *)(a1 + 40) = v50;
    }

    unint64_t v57 = *(unsigned __int16 *)(v6 + 2 * (v55 & v11));
    unint64_t v58 = v57 >> 4;
    unint64_t v8 = zlibDecodeBufferSafe_distance_base[v57 >> 4];
    uint64_t v59 = (v57 & 0xF) + 1;
    unint64_t v10 = v55 >> v59;
    unint64_t v9 = v54 >> v59;
    unint64_t v60 = v50 + v59;
    *(void *)(a1 + 40) = v60;
    if (v57 >= 0x40)
    {
      unint64_t v61 = v58 - 2;
      unint64_t v62 = (v58 - 2) >> 1;
      v8 += v10 & ~(-1 << v62);
      v10 >>= v62;
      v9 >>= v62;
      *(void *)(a1 + 40) = v60 + (v61 >> 1);
    }

uint64_t staticHuffmanTable(int *a1, uint64_t a2, int *a3, uint64_t a4)
{
  unint64_t v4 = 0LL;
  uint64_t v54 = *MEMORY[0x1895F89C0];
  do
  {
    if (v4 <= 0x8F)
    {
LABEL_3:
      *((_BYTE *)&v48[2] + v4) = 8;
      goto LABEL_8;
    }

    if (v4 > 0xFF)
    {
      if (v4 > 0x117) {
        goto LABEL_3;
      }
      *((_BYTE *)&v48[2] + v4) = 7;
    }

    else
    {
      *((_BYTE *)&v48[2] + v4) = 9;
    }

uint64_t readHuffmanTable(uint64_t *a1, int *a2, uint64_t a3, int *a4, uint64_t a5)
{
  v76[8] = *MEMORY[0x1895F89C0];
  unint64_t v6 = a1[1];
  unint64_t v5 = a1[2];
  unint64_t v7 = v6 - v5;
  if (v6 >= v5) {
    unint64_t v8 = v6 - v5;
  }
  else {
    unint64_t v8 = 0LL;
  }
  if (v8 >= 0xE)
  {
    char v13 = v5 & 7;
    unint64_t v71 = v6 + 7;
    if ((v6 + 7 - v5) >> 3 >= 8) {
      size_t v14 = 8LL;
    }
    else {
      size_t v14 = (v6 + 7 - v5) >> 3;
    }
    *(void *)&__dst[0] = 0LL;
    uint64_t v15 = *a1;
    memcpy(__dst, (const void *)(*a1 + (v5 >> 3)), v14);
    uint64_t v16 = *(void *)&__dst[0] >> v13;
    uint64_t v17 = (((*(void *)&__dst[0] >> v13) >> 10) & 0xF) + 4;
    unint64_t v18 = v5 + 14;
    a1[2] = v18;
    uint64_t v73 = 0LL;
    v74[0] = 0LL;
    *(_DWORD *)((char *)v74 + 7) = 0;
    unint64_t v19 = v6 - v18;
    if (v6 < v18) {
      unint64_t v19 = 0LL;
    }
    unint64_t v20 = (3 * v17);
    if (v19 >= v20)
    {
      uint64_t v67 = a5;
      int v68 = ((v16 >> 5) & 0x1F) + 1;
      unsigned int v69 = (v16 & 0x1F) + 257;
      size_t v21 = (v7 - 7) >> 3 >= 8 ? 8LL : (v7 - 7) >> 3;
      *(void *)&__dst[0] = 0LL;
      memcpy(__dst, (const void *)(v15 + (v18 >> 3)), v21);
      unint64_t v22 = *(void *)&__dst[0] >> (v18 & 7);
      unint64_t v23 = v18 + v20;
      a1[2] = v18 + v20;
      __int16 v24 = &byte_1810CB43C;
      do
      {
        unsigned int v25 = *v24++;
        *((_BYTE *)&v74[-1] + v25) = v22 & 7;
        v22 >>= 3;
        --v17;
      }

      while (v17);
      uint64_t v26 = 0LL;
      int v27 = 1;
      do
      {
        ++v26;
      }

      while (v26 != 19);
      int v28 = 1 << v27;
      if (v28 <= 128)
      {
        uint64_t v30 = 0LL;
        memset(v72, 0, 64);
        do
          ++*((_DWORD *)v72 + *((unsigned __int8 *)&v74[-1] + v30++));
        while (v30 != 19);
        uint64_t v31 = 0LL;
        int v32 = 0;
        LODWORD(v72[0]) = 0;
        LODWORD(v76[0]) = 0;
        do
        {
          int v32 = 2 * (*(_DWORD *)((char *)v72 + v31) + v32);
          *(_DWORD *)((char *)v76 + v31 + 4) = v32;
          v31 += 4LL;
        }

        while (v31 != 60);
        for (uint64_t i = 0LL; i != 19; ++i)
        {
          uint64_t v34 = *((unsigned __int8 *)&v74[-1] + i);
          int v35 = *((_DWORD *)v76 + v34);
          *((_DWORD *)v76 + v34) = v35 + 1;
          *((_WORD *)__dst + i) = (breverse_brev8[BYTE1(v35)] | (breverse_brev8[v35] << 8)) >> (16 - v34);
        }

        unint64_t v65 = a4;
        uint64_t v66 = a2;
        for (uint64_t j = 0LL; j != 19; ++j)
        {
          __int16 v37 = *((unsigned __int8 *)&v74[-1] + j);
          if (*((_BYTE *)&v74[-1] + j))
          {
            uint64_t v38 = *((unsigned __int16 *)__dst + j);
            if (v28 > (int)v38)
            {
              __int16 v39 = v37 + 16 * j - 1;
              uint64_t v40 = 1 << v37;
              do
              {
                *((_WORD *)v72 + v38) = v39;
                v38 += v40;
              }

              while (v38 < v28);
            }
          }
        }

        uint64_t v41 = 0LL;
        signed int v42 = 0;
        int v43 = v28 - 1;
        memset(__dst, 0, 320);
        while (1)
        {
          if (v6 >= v23) {
            unint64_t v44 = v6 - v23;
          }
          else {
            unint64_t v44 = 0LL;
          }
          v76[0] = 0LL;
          if ((v6 - v23 + 7) >> 3 >= 8) {
            size_t v45 = 8LL;
          }
          else {
            size_t v45 = (v6 - v23 + 7) >> 3;
          }
          memcpy(v76, (const void *)(v15 + (v23 >> 3)), v45);
          unsigned int v46 = *((unsigned __int16 *)v72 + (int)(v43 & (v76[0] >> (v23 & 7))));
          unint64_t v47 = (v46 & 0xF) + 1LL;
          if (v44 < v47) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v48 = v46 >> 4;
          v23 += v47;
          a1[2] = v23;
          if (v46 > 0xFF) {
            break;
          }
          *((_BYTE *)__dst + v42++) = v46 >> 4;
LABEL_71:
          uint64_t v41 = v48;
          if (v42 >= (int)(v68 + v69))
          {
            int DecoderTable = getDecoderTable(v69, (unsigned __int8 *)__dst, *v66, a3);
            if (DecoderTable)
            {
              int v62 = DecoderTable;
              int v63 = getDecoderTable(v68, (unsigned __int8 *)__dst + v69, *v65, v67);
              if (v63)
              {
                int v64 = v63;
                uint64_t result = 0LL;
                int *v66 = v62;
                int *v65 = v64;
                return result;
              }
            }

            return 0xFFFFFFFFLL;
          }
        }

        if ((_DWORD)v48 == 17)
        {
          unint64_t v53 = v6 - v23;
          if (v6 < v23) {
            unint64_t v53 = 0LL;
          }
          if (v53 < 3) {
            return 0xFFFFFFFFLL;
          }
          if ((v71 - v23) >> 3 >= 8) {
            size_t v54 = 8LL;
          }
          else {
            size_t v54 = (v71 - v23) >> 3;
          }
          v76[0] = 0LL;
          memcpy(v76, (const void *)(v15 + (v23 >> 3)), v54);
          uint64_t v55 = v76[0] >> (v23 & 7);
          v23 += 3LL;
          a1[2] = v23;
          size_t v56 = (v55 & 7) + 3;
        }

        else
        {
          if ((_DWORD)v48 == 16)
          {
            unint64_t v49 = v6 - v23;
            if (v6 < v23) {
              unint64_t v49 = 0LL;
            }
            if (v49 < 2) {
              return 0xFFFFFFFFLL;
            }
            size_t v50 = (v71 - v23) >> 3 >= 8 ? 8LL : (v71 - v23) >> 3;
            v76[0] = 0LL;
            memcpy(v76, (const void *)(v15 + (v23 >> 3)), v50);
            uint64_t v51 = v76[0] >> (v23 & 7);
            v23 += 2LL;
            a1[2] = v23;
            int v52 = v51 & 3;
            memset((char *)__dst + v42, v41, (v51 & 3) + 3);
            v42 += v52 + 3;
            goto LABEL_70;
          }

          unint64_t v57 = v6 - v23;
          if (v6 < v23) {
            unint64_t v57 = 0LL;
          }
          if (v57 < 7) {
            return 0xFFFFFFFFLL;
          }
          if ((v71 - v23) >> 3 >= 8) {
            size_t v58 = 8LL;
          }
          else {
            size_t v58 = (v71 - v23) >> 3;
          }
          v76[0] = 0LL;
          memcpy(v76, (const void *)(v15 + (v23 >> 3)), v58);
          uint64_t v59 = v76[0] >> (v23 & 7);
          v23 += 7LL;
          a1[2] = v23;
          size_t v56 = (v59 & 0x7F) + 11;
        }

        signed int v60 = v56 + v42;
        bzero((char *)__dst + v42, v56);
        signed int v42 = v60;
LABEL_70:
        uint64_t v48 = v41;
        goto LABEL_71;
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t getDecoderTable(int a1, unsigned __int8 *a2, int a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a1 < 1)
  {
    if (a3 > 1)
    {
      memset((char *)v28 + 4, 0, 60);
      uint64_t result = 2LL;
      goto LABEL_13;
    }

    return 0LL;
  }

  uint64_t v5 = a1;
  int v6 = 1;
  uint64_t v7 = a1;
  unint64_t v8 = a2;
  do
  {
    int v10 = *v8++;
    int v9 = v10;
    if (v6 <= v10) {
      int v6 = v9;
    }
    --v7;
  }

  while (v7);
  uint64_t result = (1 << v6);
  memset(v28, 0, sizeof(v28));
  uint16x8_t v12 = a2;
  do
  {
    unsigned int v13 = *v12++;
    ++*((_DWORD *)v28 + v13);
    --v5;
  }

  while (v5);
LABEL_13:
  uint64_t v14 = 0LL;
  int v15 = 0;
  LODWORD(v28[0]) = 0;
  v27[0] = 0;
  do
  {
    int v15 = 2 * (*(_DWORD *)((char *)v28 + v14 * 4) + v15);
    v27[++v14] = v15;
  }

  while (v14 != 15);
  if (a1 > 0)
  {
    uint64_t v16 = v26;
    uint64_t v17 = a2;
    uint64_t v18 = a1;
    do
    {
      int v19 = *v17++;
      int v20 = v27[v19];
      v27[v19] = v20 + 1;
      *v16++ = (breverse_brev8[BYTE1(v20)] | (breverse_brev8[v20] << 8)) >> (16 - v19);
      --v18;
    }

    while (v18);
    uint64_t v21 = 0LL;
    do
    {
      __int16 v22 = a2[v21];
      if (a2[v21])
      {
        uint64_t v23 = (unsigned __int16)v26[v21];
        if ((int)result > (int)v23)
        {
          __int16 v24 = v22 + 16 * v21 - 1;
          uint64_t v25 = 1 << v22;
          do
          {
            *(_WORD *)(a4 + 2 * v23) = v24;
            v23 += v25;
          }

          while (v23 < (int)result);
        }
      }

      ++v21;
    }

    while (v21 != a1);
  }

  return result;
}

uint64_t zlib_stream_init(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  unint64_t v4 = *(_DWORD **)(a1 + 32);
  if (a2)
  {
    uint64_t v5 = realloc_stream_state(v4, a2, 517, 0x70148u, 0x30001u);
    *(void *)(a1 + 32) = v5;
    if (v5) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v7 = realloc_stream_state(v4, 0, 517, 0x88u, 0);
    *(void *)(a1 + 32) = v7;
    if (v7)
    {
      if (!deflateInit2_((z_streamp)(v7 + 6), 5, 8, -15, 8, 0, "1.2.5", 112)) {
        return 0LL;
      }
      free(*(void **)(a1 + 32));
      *(void *)(a1 + 32) = 0LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t zlib_stream_process(void **a1, char a2)
{
  unsigned int v3 = (char *)a1[4];
  if (*(_DWORD *)v3 == 1)
  {
    uint64_t v17 = (unint64_t *)(v3 + 262448);
    uint64_t v18 = v3 + 328001;
    *((void *)v3 + 2) = v3 + 328001;
    int v19 = v3 + 262464;
    *((void *)v3 + 5) = v3 + 262464;
    while (1)
    {
      unint64_t v20 = *v17;
      if (*v17 > 0x10000) {
        break;
      }
      else {
        size_t v21 = 0x10000 - v20;
      }
      memcpy(&v19[v20], a1[2], v21);
      unint64_t v22 = (unint64_t)a1[1];
      size_t v23 = (size_t)a1[3] - v21;
      a1[2] = (char *)a1[2] + v21;
      a1[3] = (void *)v23;
      uint64_t v24 = *((void *)v3 + 32807);
      unint64_t v25 = *v17 + v21;
      unint64_t *v17 = v25;
      unint64_t v26 = 0x20000 - v24;
      if (0x20000 - v24 >= v22) {
        unint64_t v26 = v22;
      }
      *((void *)v3 + 3) = v26;
      *((void *)v3 + 9) = &v18[v24 + v26];
      *((void *)v3 + 10) = &v18[v24];
      if (v25 >= 9)
      {
        *((void *)v3 + 6) = 8 * v25 - 64;
        zlibDecodeBuffer((uint64_t)(v3 + 16));
        if (*((_DWORD *)v3 + 16) == 12) {
          return 0xFFFFFFFFLL;
        }
        unint64_t v25 = *v17;
      }

      memcpy(v3 + 131232, v3 + 16, 0x20090uLL);
      *((void *)v3 + 6) = 8 * v25;
      zlibDecodeBufferSafe((uint64_t)(v3 + 16));
      unint64_t v27 = *((void *)v3 + 7);
      if (v27 > *((void *)v3 + 6) || *((_DWORD *)v3 + 16) == 12)
      {
        memcpy(v3 + 16, v3 + 131232, 0x20090uLL);
        unint64_t v27 = *((void *)v3 + 7);
      }

      if (!*((void *)v3 + 3))
      {
        unint64_t v28 = ~(-1 << (*((_DWORD *)v3 + 12) - v27));
        if (*((void *)v3 + 17) < v28) {
          unint64_t v28 = *((void *)v3 + 17);
        }
        *((void *)v3 + 17) = v28;
      }

      if (v27 >= 8)
      {
        uint64_t result = 0xFFFFFFFFLL;
        if (v27 > 0x80007) {
          return result;
        }
        unint64_t v29 = v27 >> 3;
        unint64_t v30 = *v17 - (v27 >> 3);
        if (*v17 < v27 >> 3) {
          return result;
        }
        *((void *)v3 + 7) = v27 & 7;
        unint64_t *v17 = v30;
        if (v30 >= 0x10000 - v29) {
          size_t v31 = 0x10000 - v29;
        }
        else {
          size_t v31 = v30;
        }
        memmove(v3 + 262464, &v19[v29], v31);
      }

      int v32 = (_BYTE *)*((void *)v3 + 10);
      uint16x8_t v33 = &v18[*((void *)v3 + 32807)];
      size_t v34 = v32 - v33;
      if (v32 == v33)
      {
        if (*v17 == 0x10000) {
          return 0xFFFFFFFFLL;
        }
      }

      else
      {
        memcpy(*a1, v33, v34);
        size_t v35 = (size_t)a1[1] - v34;
        *a1 = (char *)*a1 + v34;
        a1[1] = (void *)v35;
        unint64_t v36 = *((void *)v3 + 32807) + v34;
        *((void *)v3 + 32807) = v36;
        if (v36 > 0x10000)
        {
          memmove(v3 + 328001, &v18[v36 - 0x10000], 0x10000uLL);
          *((void *)v3 + 32807) = 0x10000LL;
        }
      }

      int v37 = *((_DWORD *)v3 + 16);
      if (v37 == 11 || !a1[1] || !a1[3]) {
        return v37 == 11;
      }
    }
  }

  else
  {
    uint64_t result = 0xFFFFFFFFLL;
    if (*(_DWORD *)v3) {
      return result;
    }
    unint64_t v5 = (unint64_t)a1[3];
    *((void *)v3 + 3) = a1[2];
    int v6 = (z_stream *)(v3 + 24);
    int v7 = LODWORD(v6[-1].reserved) | a2 & 1;
    BOOL v8 = v7 != 0;
    LODWORD(v6[-1].reserved) = v7;
    LODWORD(v9) = -1;
    if (v5 >= 0xFFFFFFFF) {
      LODWORD(v5) = -1;
    }
    v6->avail_iuint64_t n = v5;
    int v10 = (Bytef *)*a1;
    v6->avail_out = v9;
    v6->next_out = v10;
    int v11 = deflate(v6, 4 * v8);
    next_out = v6->next_out;
    unsigned int v13 = (char *)*a1;
    uint64_t v14 = (char *)a1[1];
    unint64_t v15 = (unint64_t)a1[3] + (void)a1[2] - (unint64_t)v6->next_in;
    a1[2] = v6->next_in;
    a1[3] = (void *)v15;
    *a1 = next_out;
    a1[1] = &v14[v13 - (char *)next_out];
    if (v11 == -5 || v11 == 0) {
      return 0LL;
    }
    if (v11 == 1)
    {
      deflateEnd(v6);
      return 1LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t zlib_stream_identify_algorithm()
{
  return 0LL;
}

uint64_t zlib_stream_get_decode_state_size()
{
  return 459080LL;
}

uint64_t zlib_stream_get_state_size(uint64_t a1)
{
  if (**(_DWORD **)(a1 + 32)) {
    return 459080LL;
  }
  else {
    return 0LL;
  }
}

uint64_t lzx_decode_scratch_size()
{
  return 526320LL;
}

unint64_t lzx_decode_buffer( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int *a5)
{
  unint64_t v5 = a2 + 0x7FFF;
  unint64_t v6 = (a2 + 0x7FFF) >> 15;
  if (!(_DWORD)v6) {
    return 0LL;
  }
  unint64_t v7 = a4;
  unint64_t v8 = (4 * v6 - 4);
  if (v8 >= a4) {
    return 0LL;
  }
  uint64_t v9 = (v5 >> 15);
  uint64_t v11 = a3;
  unint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  __n_4 = (unsigned __int8 *)(a5 + 4);
  unint64_t v122 = (unsigned __int8 *)(a5 + 65792);
  unsigned int v117 = a5 + 98686;
  int v119 = (unsigned __int8 *)(a5 + 32898);
  int v111 = 4 * v6 - 4;
  uint64_t v115 = v9;
  do
  {
    if (v15) {
      int v16 = *(_DWORD *)(v11 + 4 * v15 - 4);
    }
    else {
      int v16 = 0;
    }
    unsigned int v17 = v7;
    if (v15 + 1 != v9) {
      unsigned int v17 = *(_DWORD *)(v11 + 4 * v15) + v8;
    }
    if (v17 > v7) {
      return 0LL;
    }
    uint64_t v116 = v15 + 1;
    __uint64_t n = v17 - (v16 + v8);
    unsigned int v123 = (unsigned __int16 *)(v11 + (v16 + v8));
    unint64_t v124 = (unint64_t)v123 + __n;
    unint64_t v125 = 0LL;
    int v126 = 0;
    lzx_decoder_init(a5);
    unint64_t v18 = v14;
    if (v14 + 0x8000 <= a2) {
      unsigned int v19 = 0x8000;
    }
    else {
      unsigned int v19 = a2 - v14;
    }
    unint64_t v20 = v18;
    if (!v19) {
      goto LABEL_139;
    }
    int v118 = 0;
    unint64_t v114 = v18;
    unint64_t v20 = v18;
    do
    {
      unint64_t v21 = v20;
      LODWORD(v22) = __n;
      if (__n == v19)
      {
        int v118 = 1;
        uint64_t v23 = 4LL;
      }

      else
      {
        int v24 = v126;
        unint64_t v25 = v125;
        if (v126 > 48)
        {
          unsigned int v29 = v126;
        }

        else
        {
          unint64_t v26 = (unint64_t)(v123 + 1);
          int v27 = 48 - v126;
          while (v26 <= v124)
          {
            uint64_t v28 = *(unsigned __int16 *)(v26 - 2);
            unsigned int v29 = v24 + 16;
            int v126 = v24 + 16;
            v25 |= v28 << v27;
            unsigned int v123 = (unsigned __int16 *)v26;
            unint64_t v125 = v25;
            v26 += 2LL;
            v27 -= 16;
            BOOL v106 = v24 < 33;
            v24 += 16;
            if (!v106) {
              goto LABEL_25;
            }
          }

          unsigned int v29 = v24;
          if (v24 < 3) {
            return 0LL;
          }
        }

LABEL_66:
            unint64_t v65 = v58 >> 61;
            v58 *= 8LL;
            unint64_t v125 = v58;
            int v57 = v64 - 3;
            int v126 = v64 - 3;
            v122[v56++] = v65;
            signed int v60 = v62;
          }

          while (v56 != 8);
          lzx_huffman_tree_compute_lookup_from_code_len(v122);
        }

        if (!lzx_huffman_tree_update_tree_using_pre_tree_encoding( (uint64_t)__n_4,  (uint64_t)&v123,  0LL,  256LL,  v117)
          && !lzx_huffman_tree_update_tree_using_pre_tree_encoding( (uint64_t)__n_4,  (uint64_t)&v123,  0x100uLL,  240LL,  v117)
          && !lzx_huffman_tree_compute_lookup_from_code_len(__n_4)
          && !lzx_huffman_tree_update_tree_using_pre_tree_encoding( (uint64_t)v119,  (uint64_t)&v123,  0LL,  249LL,  v117)
          && !lzx_huffman_tree_compute_lookup_from_code_len(v119))
        {
          size_t v66 = v46;
          while (1)
          {
            if (v128[0] <= 0xFFu)
            {
              *(_BYTE *)(a1 + v21++) = v128[0];
              --v66;
              goto LABEL_126;
            }

            uint64_t v67 = v128[0] & 7;
            if ((_DWORD)v67 == 7)
            {
              unint64_t v68 = v127 + 9LL;
            }

            else
            {
              unint64_t v68 = v67 + 2;
            }

            BOOL v90 = v66 >= v68;
            v66 -= v68;
            if (!v90) {
              return 0LL;
            }
            int v69 = v128[0] - 256;
            uint64_t v70 = (uint64_t)v69 >> 3;
            if (v70 == 2)
            {
              unsigned int v71 = a5[2];
              a5[2] = *a5;
            }

            else
            {
              if (v70 != 1)
              {
                if (v70)
                {
                  int v75 = position_slot_extra_bits[v70];
                  int v73 = position_slot_base_position[v70];
                  unsigned __int16 v127 = 0;
                  if (v23 == 2 && (unint64_t)(v70 - 8) <= 0x15)
                  {
                    int v76 = v75 - 3;
                    int v110 = v73;
                    if (v75 == 3)
                    {
                      LODWORD(v109) = 0;
                    }

                    else
                    {
                      int v77 = v126;
                      if (v126 <= 48)
                      {
                        unint64_t v78 = v125;
                        unint64_t v79 = (unint64_t)(v123 + 1);
                        int v80 = 48 - v126;
                        while (v79 <= v124)
                        {
                          uint64_t v81 = *(unsigned __int16 *)(v79 - 2);
                          int v82 = v77 + 16;
                          int v126 = v77 + 16;
                          v78 |= v81 << v80;
                          unsigned int v123 = (unsigned __int16 *)v79;
                          unint64_t v125 = v78;
                          v79 += 2LL;
                          v80 -= 16;
                          BOOL v106 = v77 < 33;
                          v77 += 16;
                          if (!v106) {
                            goto LABEL_110;
                          }
                        }
                      }

                      int v82 = v77;
LABEL_110:
                      if (v82 < v76) {
                        return 0LL;
                      }
                      unint64_t v109 = v125 >> (67 - v75);
                      v125 <<= v76;
                      int v126 = v82 - v76;
                    }

                    int v89 = lzx_huffman_tree_read_code(&v127, (uint64_t)&v123, (uint64_t)v122);
                    int v73 = v110;
                    if (v89) {
                      return 0LL;
                    }
                    LODWORD(v74) = 8 * v109;
                    int v72 = v127;
                  }

                  else if (v69 >= 0x20)
                  {
                    int v83 = v126;
                    if (v126 <= 48)
                    {
                      unint64_t v84 = v125;
                      unint64_t v85 = (unint64_t)(v123 + 1);
                      int v86 = 48 - v126;
                      while (v85 <= v124)
                      {
                        uint64_t v87 = *(unsigned __int16 *)(v85 - 2);
                        int v88 = v83 + 16;
                        int v126 = v83 + 16;
                        v84 |= v87 << v86;
                        unsigned int v123 = (unsigned __int16 *)v85;
                        unint64_t v125 = v84;
                        v85 += 2LL;
                        v86 -= 16;
                        BOOL v106 = v83 < 33;
                        v83 += 16;
                        if (!v106) {
                          goto LABEL_113;
                        }
                      }
                    }

                    int v88 = v83;
LABEL_113:
                    if (v88 < v75) {
                      return 0LL;
                    }
                    int v72 = 0;
                    unint64_t v74 = v125 >> -(char)v75;
                    v125 <<= v75;
                    int v126 = v88 - v75;
                  }

                  else
                  {
                    int v72 = 0;
LABEL_92:
                    LODWORD(v74) = 0;
                  }

                  unsigned int v71 = v73 + v72 + v74 - 2;
                  *(void *)(a5 + 1) = *(void *)a5;
                  *a5 = v71;
                  goto LABEL_119;
                }

                unsigned int v71 = *a5;
                if (!*a5) {
                  goto LABEL_91;
                }
                goto LABEL_119;
              }

              unsigned int v71 = a5[1];
              a5[1] = *a5;
            }

            *a5 = v71;
            if (!v71)
            {
LABEL_91:
              int v72 = 0;
              int v73 = 0;
              goto LABEL_92;
            }

LABEL_119:
            if (v71) {
              BOOL v90 = v21 >= v71;
            }
            else {
              BOOL v90 = 0;
            }
            if (!v90) {
              return 0LL;
            }
            uint64_t v91 = a1 - v71;
            do
            {
              *(_BYTE *)(a1 + v21) = *(_BYTE *)(v91 + v21);
              ++v21;
              --v68;
            }

            while (v68);
LABEL_126:
            if (!v66) {
              goto LABEL_137;
            }
          }
        }

        return 0LL;
      }

      int v49 = v126;
      int v50 = v126 & 0xF;
      if ((v126 & 0xF) == 0) {
        int v50 = 16;
      }
      if (v126 <= 48)
      {
        unint64_t v51 = v125;
        unint64_t v52 = (unint64_t)(v123 + 1);
        int v53 = 48 - v126;
        while (v52 <= v124)
        {
          uint64_t v54 = *(unsigned __int16 *)(v52 - 2);
          int v55 = v49 + 16;
          int v126 = v49 + 16;
          v51 |= v54 << v53;
          unsigned int v123 = (unsigned __int16 *)v52;
          unint64_t v125 = v51;
          v52 += 2LL;
          v53 -= 16;
          BOOL v106 = v49 < 33;
          v49 += 16;
          if (!v106) {
            goto LABEL_129;
          }
        }
      }

      int v55 = v49;
LABEL_129:
      BOOL v92 = __OFSUB__(v55, v50);
      int v93 = v55 - v50;
      if (v93 < 0 != v92) {
        return 0LL;
      }
      if ((v93 & 7) != 0) {
        return 0LL;
      }
      unint64_t v94 = v124;
      uint64_t v95 = (unsigned __int16 *)((char *)v123 - (v93 >> 3));
      unsigned int v123 = v95;
      unint64_t v125 = 0LL;
      int v126 = 0;
      uint64_t v96 = (char *)(v95 + 6);
      unsigned int v97 = *((_DWORD *)v95 + 2);
      *(void *)a5 = *(void *)v95;
      a5[2] = v97;
      unsigned int v123 = v95 + 6;
      unint64_t v125 = 0LL;
      int v126 = 0;
      uint64_t v98 = &v96[v46];
      memcpy((void *)(a1 + v21), v96, v46);
      unsigned int v123 = (unsigned __int16 *)v98;
      if ((v46 & 1) != 0 && (char *)v94 != v98)
      {
        unint64_t v125 = 0LL;
        int v126 = 0;
        unsigned int v123 = (unsigned __int16 *)(v98 + 1);
      }

        if (v63 <= v85 && v86)
        {
          v121[3] = v121[2];
          *(void *)(v121 + 1) = *(void *)v121;
          *unint64_t v121 = v63;
        }

        *(_DWORD *)int v120 = v12;
        *(_DWORD *)(v120 + 4) = v50;
        uint64_t v87 = *(unsigned int *)(v123 + 68);
        int v88 = v87 + 16;
        if (v87 + 16 <= v86)
        {
          uint64_t v91 = *(unsigned int *)(v123 + 64);
          BOOL v92 = v86 - v87 + (4LL << v91) - 16;
          int v93 = (__clz(v92) ^ 0x1F) - 1;
          unint64_t v94 = ((v92 >> v93) & 1 | 2) << v93;
          int v86 = ((v92 & ~(-1 << v91)) + v88 + ((((v92 >> v93) & 1 | (2 * (v93 - v91))) + 65534) << v91)) | ((v93 - v91) << 10);
          int v89 = (v92 - v94) >> v91;
        }

        else
        {
          LODWORD(v89) = 0;
        }

        goto LABEL_128;
      }

      unsigned int v101 = 4 * (v99 - v98);
      uint64_t v102 = 266017486;
    }

    else
    {
      unsigned int v101 = 4 * v100;
      uint64_t v102 = 158663784;
    }

    int v86 = (v102 >> v101) & 0xF;
    goto LABEL_119;
  }

  int v120 = a9;
  int v83 = a2;
LABEL_188:
  *a8 = v12 + v13 - v83;
  *a10 += (v120 - a9) >> 4;
  return result;
}

LABEL_137:
      v19 -= v46;
    }

    while (v19);
    uint64_t v11 = a3;
    unint64_t v7 = a4;
    LODWORD(v8) = v111;
    unint64_t v18 = v114;
    if (!v118)
    {
LABEL_139:
      int v99 = v20 - v18;
      if ((int)v20 - (int)v18 >= 11)
      {
        unint64_t v100 = v18;
        unsigned int v101 = 0;
        uint64_t v102 = a1 + v100;
        do
        {
          int v103 = (unsigned __int8 *)(v102 + v101);
          if (*v103 == 232)
          {
            int v104 = *(_DWORD *)(v103 + 1);
            int v105 = -v101;
            BOOL v106 = v104 >= (signed int)-v101 && v104 < 12000000;
            if (v106)
            {
              if (v104 < 0) {
                int v105 = 12000000;
              }
              *(_DWORD *)(v103 + 1) = v105 + v104;
            }

            int v107 = 5;
          }

          else
          {
            int v107 = 1;
          }

          v101 += v107;
        }

        while ((int)(v101 + 10) < v99);
      }
    }

    unint64_t v14 = v20;
    uint64_t v9 = v115;
    uint64_t v15 = v116;
  }

  while (v116 != v115);
  return v20;
}

unint64_t lzfse_encode_scratch_size(int a1)
{
  unint64_t ScratchSize = lzfseEncodeGetScratchSize(a1);
  if (a1 == 2050) {
    int v3 = 2305;
  }
  else {
    int v3 = 2304;
  }
  unint64_t result = lzvn_encode_scratch_size(v3);
  if (ScratchSize > result) {
    return ScratchSize;
  }
  return result;
}

char *lzfse_encode_buffer( uint64_t a1, unint64_t a2, const float *__src, size_t __n, int8x16_t *a5, int a6)
{
  int v10 = __n;
  if (__n >= 8)
  {
    if (__n > 0xFFF)
    {
      uint64_t v28 = 0LL;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v19 = 0u;
      int v10 = __n;
      if (!lzfseEncodeInitState((uint64_t)&v19, a6, (uint64_t)a5))
      {
        *((void *)&v21 + 1) = a1;
        *(void *)&__int128 v22 = a1;
        *((void *)&v22 + 1) = a1 + a2;
        size_t v16 = __n;
        int v10 = __n;
        *(void *)&__int128 v19 = __src;
        *((void *)&v20 + 1) = 0LL;
        if (__n < 0x7FFFFFFF)
        {
LABEL_21:
          *((void *)&v19 + 1) = v16;
          *(void *)&__int128 v21 = v16 - 8;
        }

        else
        {
          *((void *)&v19 + 1) = 0x40000LL;
          *(void *)&__int128 v21 = 262136LL;
          int v10 = __n;
          if (!lzfseEncodeBase((uint64_t)&v19))
          {
            size_t v17 = __n;
            while (1)
            {
              *((void *)&v19 + 1) = 0x80000LL;
              *(void *)&__int128 v21 = 524280LL;
              lzfseEncodeTranslateState((uint64_t)&v19, 0x40000uLL);
              size_t v16 = v17 - 0x40000;
              unint64_t v18 = (v17 - 0x80000) >> 18;
              v17 -= 0x40000LL;
              if (!v18)
              {
                int v10 = v16 - 0x40000;
                goto LABEL_21;
              }
            }

            int v10 = v17 - 0x40000;
          }
        }
      }
    }

    else
    {
      int v10 = __n;
      if (a2 >= 0x11)
      {
        uint64_t v11 = a1 + 12;
        unint64_t v12 = a2 - 16;
        int v13 = a6 == 2050 ? 2305 : 2304;
        unint64_t v14 = lzvn_encode_buffer((char *)(a1 + 12), v12, __src, __n, a5, v13);
        int v10 = __n;
        if (v14)
        {
          int v10 = __n;
          if ((unint64_t)v14 < __n)
          {
            *(_DWORD *)a1 = 1853388386;
            *(_DWORD *)(a1 + 4) = __n;
            *(_DWORD *)(a1 + 8) = (_DWORD)v14;
            *(_DWORD *)&v14[v11] = 611874402;
            return v14 + 16;
          }
        }
      }
    }
  }

  unint64_t result = 0LL;
  if (__n <= 0x7FFFFFFE && __n + 12 <= a2)
  {
    *(_DWORD *)a1 = 762869346;
    *(_DWORD *)(a1 + 4) = v10;
    memcpy((void *)(a1 + 8), __src, __n);
    *(_DWORD *)(a1 + 8 + __n) = 611874402;
    return (char *)(__n + 12);
  }

  return result;
}

unint64_t BrotliCreateBackwardReferences( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, double a5, double a6, int32x4_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int *a11, unint64_t *a12, _DWORD *a13, void *a14, void *a15)
{
  int v15 = *(_DWORD *)(a9 + 40);
  if (v15 <= 34)
  {
    switch(v15)
    {
      case 2:
        unint64_t result = CreateBackwardReferencesNH2(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 3:
        unint64_t result = CreateBackwardReferencesNH3(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 4:
        unint64_t result = CreateBackwardReferencesNH4(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 5:
        unint64_t result = CreateBackwardReferencesNH5(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 6:
        unint64_t result = CreateBackwardReferencesNH6(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      default:
        return result;
    }
  }

  else if (v15 > 53)
  {
    switch(v15)
    {
      case '6':
        return CreateBackwardReferencesNH54(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
      case '7':
        return CreateBackwardReferencesNH55(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
      case 'A':
        return CreateBackwardReferencesNH65(result, a2, a3, a4, a9, a10, a11, a12, a13, a14, a15);
    }
  }

  else
  {
    switch(v15)
    {
      case '#':
        unint64_t result = CreateBackwardReferencesNH35(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case '(':
        unint64_t result = CreateBackwardReferencesNH40(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case ')':
        unint64_t result = CreateBackwardReferencesNH41(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case '*':
        unint64_t result = CreateBackwardReferencesNH42(result, a2, a3, a4, a9, a10, a11, a12, a5, a6, a7, (uint64_t)a13, a14, a15);
        break;
      default:
        return result;
    }
  }

  return result;
}

unint64_t CreateBackwardReferencesNH2( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v14 = a2 + result - 7;
  if (result <= 7) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = a2 + result - 7;
  }
  unint64_t v147 = v15;
  else {
    uint64_t v16 = 64LL;
  }
  if (a2 + 8 >= v13)
  {
    uint64_t v150 = a9;
    unint64_t v99 = a2;
    goto LABEL_232;
  }

  uint64_t v145 = v16;
  unint64_t v17 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
  uint64_t v154 = *(void *)(a5 + 16);
  unint64_t v18 = v16 + a2;
  unint64_t v152 = a2 + result;
  uint64_t v19 = 4 * v16;
  uint64_t v20 = *(void *)(a6 + 56);
  uint64_t v150 = a9;
  uint64_t v21 = a6;
  uint64_t v146 = a2 + result - 7;
  uint64_t v144 = 4 * v16;
  int v149 = a7;
  do
  {
    unint64_t v22 = v13 - v11;
    if (v11 >= v17) {
      unint64_t result = v17;
    }
    else {
      unint64_t result = v11;
    }
    if (v11 + v154 >= v17) {
      unint64_t v23 = v17;
    }
    else {
      unint64_t v23 = v11 + v154;
    }
    unint64_t v24 = *(void *)(a5 + 80);
    unint64_t v25 = v11 & a4;
    __int128 v26 = (void *)(a3 + (v11 & a4));
    int v27 = *(unsigned __int8 *)v26;
    unint64_t v28 = (0xBD1E35A7BD000000LL * *v26) >> 48;
    unint64_t v29 = *a7;
    if (v11 < v29 || (uint64_t v30 = (unsigned __int8 *)(a3 + (a4 & (v11 - v29))), v27 != *v30))
    {
LABEL_27:
      uint64_t v39 = *(unsigned int *)(v20 + 4 * v28);
      *(_DWORD *)(v20 + 4 * v28) = v11;
      unint64_t v29 = v11 - v39;
      int v40 = (unsigned __int8 *)(a3 + (v39 & a4));
      if (v27 != *v40 || v11 == v39 || v29 > result) {
        goto LABEL_124;
      }
      if (v22 < 8)
      {
        unint64_t v33 = 0LL;
        int v45 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_214:
        unint64_t v136 = v22 & 7;
        if ((v22 & 7) != 0)
        {
          unint64_t v137 = v33 | v136;
          while (v40[v33] == *v45)
          {
            ++v45;
            ++v33;
            if (!--v136)
            {
              unint64_t v33 = v137;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v43 = 0LL;
        unint64_t v44 = v22 >> 3;
        unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFF8LL;
        int v45 = (unsigned __int8 *)(a3 + v25 + (v22 & 0xFFFFFFFFFFFFFFF8LL));
        while (1)
        {
          uint64_t v46 = v26[v43];
          uint64_t v47 = *(void *)&v40[v43 * 8];
          if (v46 != v47) {
            break;
          }
          ++v43;
          if (!--v44) {
            goto LABEL_214;
          }
        }

        unint64_t v33 = v43 * 8 + (__clz(__rbit64(v47 ^ v46)) >> 3);
      }

      if (v33 < 4 || (unint64_t v37 = 135 * v33 - 30 * (__clz(v29) ^ 0x1F) + 1920, v37 <= 0x7E4))
      {
        uint64_t v94 = *(void *)(v21 + 48);
        unint64_t v95 = *(void *)(v94 + 8);
        unint64_t result = *(void *)(v94 + 16);
        if (result < v95 >> 7) {
          goto LABEL_124;
        }
        uint64_t v96 = ((506832829 * *(_DWORD *)v26) >> 17) & 0x7FFELL;
        uint64_t v97 = *(void *)(a5 + 120);
        *(void *)(v94 + 8) = v95 + 1;
        unint64_t v98 = *(unsigned __int8 *)(v97 + v96);
        if (!*(_BYTE *)(v97 + v96) || v22 < v98) {
          goto LABEL_124;
        }
        uint64_t v113 = *(unsigned __int16 *)(*(void *)(a5 + 112) + 2 * v96);
        uint64_t v114 = *(void *)(a5 + 88);
        uint64_t v115 = *(unsigned int *)(v114 + 4 * v98 + 32);
        uint64_t v116 = *(void *)(v114 + 168);
        unsigned int v117 = (unsigned __int8 *)(v116 + v115 + v113 * *(unsigned __int8 *)(v97 + v96));
        if (v98 < 8)
        {
          unint64_t v33 = 0LL;
LABEL_226:
          unint64_t v140 = v98 & 7;
          if ((v98 & 7) != 0)
          {
            unint64_t v141 = v33 | v140;
            while (*((unsigned __int8 *)v26 + v33) == *v117)
            {
              ++v117;
              ++v33;
              if (!--v140)
              {
                unint64_t v33 = v141;
                break;
              }
            }
          }
        }

        else
        {
          unint64_t v118 = 0LL;
          unint64_t v33 = v98 & 0xF8;
          int v119 = (unsigned __int8 *)(v116 + v113 * (unint64_t)v98 + v33 + v115);
          while (1)
          {
            uint64_t v120 = *(void *)&v117[v118];
            uint64_t v121 = v26[v118 / 8];
            if (v120 != v121) {
              break;
            }
            v118 += 8LL;
            if (v33 == v118)
            {
              unsigned int v117 = v119;
              goto LABEL_226;
            }
          }

          unint64_t v33 = v118 + (__clz(__rbit64(v121 ^ v120)) >> 3);
        }

        uint64_t v21 = a6;
        if (!v33
          || v33 + *(unsigned int *)(a5 + 100) <= v98
          || (unint64_t v29 = v23
                  + 1
                  + v113
                  + ((((*(void *)(a5 + 104) >> (6 * (v98 - v33))) & 0x3FLL)
                    + 4 * (v98 - v33)) << *(_BYTE *)(v114 + v98)),
              v29 > v24)
          || (unint64_t v37 = 135 * v33 - 30 * (__clz(v29) ^ 0x1F) + 1920, v37 < 0x7E4)
          || (*(void *)(v94 + 16) = result + 1, v37 == 2020))
        {
LABEL_124:
          ++v12;
          unint64_t v99 = v11 + 1;
          if (v11 + 1 > v18)
          {
            if (v99 <= v18 + v19)
            {
              if (v11 + 9 >= v14) {
                unint64_t v101 = v14;
              }
              else {
                unint64_t v101 = v11 + 9;
              }
              while (v99 < v101)
              {
                *(_DWORD *)(v20 + (((0xBD1E35A7BD000000LL * *(void *)(a3 + (v99 & a4))) >> 46) & 0x3FFFC)) = v99;
                v12 += 2LL;
                v99 += 2LL;
              }
            }

            else
            {
              if (v11 + 17 >= v14) {
                unint64_t v100 = v14;
              }
              else {
                unint64_t v100 = v11 + 17;
              }
              while (v99 < v100)
              {
                *(_DWORD *)(v20 + (((0xBD1E35A7BD000000LL * *(void *)(a3 + (v99 & a4))) >> 46) & 0x3FFFC)) = v99;
                v12 += 4LL;
                v99 += 4LL;
              }
            }
          }

          goto LABEL_207;
        }

        unint64_t v148 = v24;
        int v38 = v98 - v33;
      }

      else
      {
        unint64_t v148 = v24;
        int v38 = 0;
      }

      goto LABEL_43;
    }

    if (v22 >= 8)
    {
      uint64_t v31 = 0LL;
      unint64_t v32 = v22 >> 3;
      unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFF8LL;
      unsigned int v34 = (unsigned __int8 *)(a3 + v25 + (v22 & 0xFFFFFFFFFFFFFFF8LL));
      while (1)
      {
        uint64_t v35 = v26[v31];
        uint64_t v36 = *(void *)&v30[v31 * 8];
        if (v35 != v36) {
          break;
        }
        ++v31;
        if (!--v32)
        {
          uint64_t v21 = a6;
          goto LABEL_220;
        }
      }

      unint64_t v33 = v31 * 8 + (__clz(__rbit64(v36 ^ v35)) >> 3);
      goto LABEL_23;
    }

    unint64_t v33 = 0LL;
    unsigned int v34 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_220:
    unint64_t v138 = v22 & 7;
    if ((v22 & 7) != 0)
    {
      unint64_t v139 = v33 | v138;
      while (v30[v33] == *v34)
      {
        ++v34;
        ++v33;
        if (!--v138)
        {
          unint64_t v33 = v139;
          break;
        }
      }

LABEL_141:
    if (v67 <= v54 && v102)
    {
      v149[3] = v149[2];
      *(void *)(v149 + 1) = *(void *)v149;
      int *v149 = v67;
    }

LABEL_146:
    *(_DWORD *)uint64_t v150 = v12;
    *(_DWORD *)(v150 + 4) = v60 | (v66 << 25);
    uint64_t v104 = *(unsigned int *)(v49 + 68);
    uint64_t v105 = v104 + 16;
    if (v104 + 16 <= v102)
    {
      uint64_t v107 = *(unsigned int *)(v49 + 64);
      unint64_t v108 = v102 - v104 + (4LL << v107) - 16;
      uint64_t v109 = (__clz(v108) ^ 0x1F) - 1;
      uint64_t v110 = ((v108 >> v109) & 1 | 2) << v109;
      unint64_t result = 65534LL;
      unint64_t v102 = ((v108 & ~(-1 << v107))
            + v105
            + ((((v108 >> v109) & 1 | (2 * (v109 - v107))) + 65534) << v107)) | ((v109 - v107) << 10);
      unint64_t v106 = (v108 - v110) >> v107;
    }

    else
    {
      LODWORD(v106) = 0;
    }

    *(_WORD *)(v150 + 14) = v102;
    *(_DWORD *)(v150 + 8) = v106;
    if (v12 > 5)
    {
      if (v12 > 0x81)
      {
        if (v12 > 0x841)
        {
          if (v12 >> 1 >= 0xC21)
          {
            if (v12 < 0x5842) {
              LOWORD(v111) = 22;
            }
            else {
              LOWORD(v111) = 23;
            }
          }

          else
          {
            LOWORD(v111) = 21;
          }
        }

        else
        {
          unsigned int v111 = (__clz(v12 - 66) ^ 0x1F) + 10;
        }
      }

      else
      {
        unsigned int v112 = (__clz(v12 - 2) ^ 0x1F) - 1;
        unsigned int v111 = ((v12 - 2) >> v112) + 2 * v112 + 2;
      }
    }

    else
    {
      LOWORD(v111) = v12;
    }

    int v127 = v66 + v60;
    unsigned int v128 = v66 + v60;
    if ((v66 + v60) > 9)
    {
      a7 = v149;
      unint64_t v14 = v146;
      if (v128 > 0x85)
      {
        if (v128 > 0x845) {
          LOWORD(v128) = 23;
        }
        else {
          unsigned int v128 = (__clz(v128 - 70) ^ 0x1F) + 12;
        }
      }

      else
      {
        unsigned int v129 = __clz(v128 - 6);
        unsigned int v128 = ((unint64_t)(v127 - 6LL) >> ((v129 ^ 0x1F) - 1)) + 2 * ((v129 ^ 0x1F) - 1) + 4;
      }
    }

    else
    {
      LOWORD(v128) = v128 - 2;
      a7 = v149;
      unint64_t v14 = v146;
    }

    int v130 = v128 & 7 | (8 * (v111 & 7));
    if ((v102 & 0x3FF) != 0 || (unsigned __int16)v111 > 7u || (unsigned __int16)v128 > 0xFu)
    {
      int v132 = 3 * ((unsigned __int16)v111 >> 3) + ((unsigned __int16)(v128 & 0xFFF8) >> 3);
      unsigned int v131 = ((((0x520D40u >> (2 * v132)) & 0xC0) + (v132 << 6)) | v130) + 64;
    }

    else
    {
      LOWORD(v131) = v130 | 0x40;
      if ((v128 & 0xFFF8) == 0) {
        LOWORD(v131) = v128 & 7 | (8 * (v111 & 7));
      }
    }

    *(_WORD *)(v150 + 12) = v131;
    *a11 += v12;
    unint64_t v133 = v52 + 2;
    unint64_t v99 = v52 + v60;
    if (v52 + v60 >= v147) {
      unint64_t v134 = v147;
    }
    else {
      unint64_t v134 = v52 + v60;
    }
    if (v67 < v60 >> 2)
    {
      unint64_t v135 = v99 - 4 * v67;
      if (v133 > v135) {
        unint64_t v135 = v52 + 2;
      }
      if (v134 >= v135) {
        unint64_t v133 = v135;
      }
      else {
        unint64_t v133 = v134;
      }
    }

    unint64_t v18 = v145 + 2 * v60 + v52;
    v150 += 16LL;
    if (v133 >= v134)
    {
      unint64_t v12 = 0LL;
      uint64_t v19 = v144;
    }

    else
    {
      uint64_t v19 = v144;
      do
      {
        *(_DWORD *)(v20 + (((0xBD1E35A7BD000000LL * *(void *)(a3 + (v133 & a4))) >> 46) & 0x3FFFC)) = v133;
        ++v133;
      }

      while (v134 != v133);
      unint64_t v12 = 0LL;
    }

                      int v119 = 135 * v112 - 30 * (__clz(v111) ^ 0x1F) + 1920;
                      if (v119 > v87)
                      {
                        uint64_t v120 = v112;
                      }

                      else
                      {
                        int v119 = v87;
                        unsigned int v111 = v79;
                        uint64_t v120 = v73;
                      }

                      uint64_t v121 = v112 >= 4 && v112 > v73;
                      if (v121) {
                        unint64_t v87 = v119;
                      }
                      if (v121) {
                        uint64_t v79 = v111;
                      }
                      if (v121) {
                        uint64_t v73 = v120;
                      }
                    }
                  }
                }

                unint64_t v106 = v108 + v104 * v106 + v105 * ~v107 + 1;
                v103 += 4LL;
              }

              while (v103 <= v74);
              a6 = v169;
              *(_DWORD *)(v169 + 64) = v106;
            }

            *(void *)(a6 + 80) = v11 + 5;
          }
        }

        if (v87 < v32 + 175) {
          break;
        }
        ++v12;
        if (v70 <= 2)
        {
          uint64_t v122 = v11 + 9;
          ++v70;
          unint64_t v71 = v168 + 7;
          unint64_t v32 = v87;
          uint64_t v167 = v79;
          int v27 = v73;
          ++v11;
          if (v122 < v163) {
            continue;
          }
        }

        goto LABEL_181;
      }

      uint64_t v79 = v167;
      uint64_t v73 = v27;
      unint64_t v74 = v11;
LABEL_181:
      a7 = v165;
      unint64_t v126 = v166;
      if (v74 + v159 < v166) {
        unint64_t v126 = v74 + v159;
      }
      if (v79 > v126) {
        goto LABEL_184;
      }
      unsigned int v131 = *v165;
      if (v79 != v131) {
        break;
      }
      LOWORD(v127) = 0;
      LODWORD(v130) = 0;
      *(_DWORD *)__int16 v162 = v12;
      *(_DWORD *)(v162 + 4) = v73;
      unint64_t result = 0xBD1E35A7BD000000LL;
LABEL_194:
      *(_WORD *)(v162 + 14) = v127;
      *(_DWORD *)(v162 + 8) = v130;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v136) = 22;
              }
              else {
                LOWORD(v136) = 23;
              }
            }

            else
            {
              LOWORD(v136) = 21;
            }
          }

          else
          {
            unint64_t v136 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unint64_t v137 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unint64_t v136 = ((v12 - 2) >> v137) + 2 * v137 + 2;
        }
      }

      else
      {
        LOWORD(v136) = v12;
      }

      uint64_t v144 = (unint64_t)v73 >> 1;
      if (v144 > 4)
      {
        if (v144 > 0x42)
        {
          if (v144 > 0x422) {
            LOWORD(v145) = 23;
          }
          else {
            uint64_t v145 = (__clz(v73 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          uint64_t v146 = (int)v73 - 6LL;
          unint64_t v147 = (__clz(v146) ^ 0x1F) - 1;
          uint64_t v145 = (v146 >> v147) + 2 * v147 + 4;
        }
      }

      else
      {
        LOWORD(v145) = v73 - 2;
      }

      unint64_t v148 = v145 & 7 | (8 * (v136 & 7));
      if ((v127 & 0x3FF) != 0 || (unsigned __int16)v136 > 7u || (unsigned __int16)v145 > 0xFu)
      {
        uint64_t v150 = 3 * ((unsigned __int16)v136 >> 3) + ((unsigned __int16)(v145 & 0xFFF8) >> 3);
        int v149 = ((((0x520D40u >> (2 * v150)) & 0xC0) + (v150 << 6)) | v148) + 64;
      }

      else
      {
        LOWORD(v149) = v148 | 0x40;
        if ((v145 & 0xFFF8) == 0) {
          LOWORD(v149) = v145 & 7 | (8 * (v136 & 7));
        }
      }

      *(_WORD *)(v162 + 12) = v149;
      *a11 += v12;
      unsigned int v151 = v74 + 2;
      char v124 = v74 + v73;
      unint64_t v152 = v161;
      if (v74 + v73 < v161) {
        unint64_t v152 = v74 + v73;
      }
      if (v79 < v73 >> 2)
      {
        if (v151 <= v124 - 4 * v79) {
          unsigned int v151 = v124 - 4 * v79;
        }
        if (v152 < v151) {
          unsigned int v151 = v152;
        }
      }

      uint64_t v16 = v160 + 2 * v73 + v74;
      unint64_t v18 = v162 + 16;
      if (v151 >= v152)
      {
        unint64_t v12 = 0LL;
        unint64_t v13 = v163;
      }

      else
      {
        unint64_t v13 = v163;
        do
        {
          *(_DWORD *)(v17
                    + 4LL
                    * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v151 & a4))) >> 48) + (v151 & 8))) = v151;
          ++v151;
        }

        while (v152 != v151);
        unint64_t v12 = 0LL;
      }

LABEL_207:
    unint64_t v11 = v99;
  }

  while (v99 + 8 < v13);
LABEL_232:
  *a8 = v12 + v13 - v99;
  *a10 += (v150 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH3( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v132 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v119 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v122 = v14;
  else {
    uint64_t v15 = 64LL;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v16 = a5;
    unint64_t v128 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v120 = *(void *)(a5 + 16);
    unint64_t result = v15 + a2;
    uint64_t v121 = v15;
    uint64_t v118 = 4 * v15;
    uint64_t v17 = *(void *)(a6 + 56);
    unint64_t v123 = a7;
    uint64_t v124 = a9;
    unint64_t v126 = v13;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v128) {
        unint64_t v19 = v128;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      uint64_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *a7;
      if (v11 < v23) {
        goto LABEL_22;
      }
      unint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0LL;
        int v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_184:
        unint64_t v115 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v116 = v26 | v115;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v115)
            {
              unint64_t v26 = v116;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v25 = 0LL;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8LL;
        int v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8LL));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_184;
          }
        }

        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }

      if (v26 >= 4 && (v129 = *a7, unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        unint64_t v32 = result;
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }

      else
      {
LABEL_22:
        unint64_t v32 = result;
        unint64_t v129 = 0LL;
        unint64_t v26 = 0LL;
        unint64_t v31 = 2020LL;
      }

      uint64_t v33 = 0LL;
      unint64_t v130 = (0xBD1E35A7BD000000LL * *v21) >> 48;
      uint64_t v131 = (unsigned __int16)(v130 + 8);
      char v34 = 1;
      do
      {
        char v35 = v34;
        uint64_t v36 = *(unsigned int *)(v17 + 4 * *(&v130 + v33));
        unint64_t v37 = v11 - v36;
        if (v22 == *(unsigned __int8 *)(a3 + (v36 & a4) + v26) && v11 != v36 && v37 <= v19)
        {
          uint64_t v40 = a3 + (v36 & a4);
          if (v18 < 8)
          {
            unint64_t v45 = 0LL;
            uint64_t v46 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            unint64_t v48 = v18 & 7;
            if ((v18 & 7) != 0)
            {
              unint64_t v49 = v18 & 7 | v45;
              while (*(unsigned __int8 *)(v40 + v45) == *v46)
              {
                ++v46;
                ++v45;
                if (!--v48)
                {
                  unint64_t v45 = v49;
                  break;
                }
              }

              a7 = v123;
              uint64_t v16 = a5;
              unint64_t v13 = v126;
            }
          }

          else
          {
            uint64_t v41 = 0LL;
            unint64_t v42 = v18 >> 3;
            while (1)
            {
              uint64_t v43 = v21[v41];
              uint64_t v44 = *(void *)(v40 + v41 * 8);
              if (v43 != v44) {
                break;
              }
              ++v41;
              if (!--v42)
              {
                unint64_t v45 = v18 & 0xFFFFFFFFFFFFFFF8LL;
                uint64_t v46 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8LL);
                goto LABEL_43;
              }
            }

            unint64_t v45 = v41 * 8 + (__clz(__rbit64(v44 ^ v43)) >> 3);
          }

          if (v45 >= 4)
          {
            unsigned int v47 = __clz(v37) ^ 0x1F;
            if (v31 < 135 * v45 - 30 * v47 + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v45 + v20);
              unint64_t v31 = 135 * v45 - 30 * v47 + 1920;
              unint64_t v129 = v37;
              unint64_t v26 = v45;
            }
          }
        }

        char v34 = 0;
        uint64_t v33 = 1LL;
      }

      while ((v35 & 1) != 0);
      *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v130 + (v11 & 8))) = v11;
      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v85 = v11 + 1;
        unint64_t result = v32;
        if (v11 + 1 > v32)
        {
          if (v85 <= v32 + v118)
          {
            unint64_t v99 = v11 + 9;
            if (v11 + 9 >= v119) {
              unint64_t v99 = v119;
            }
            for (; v85 < v99; v85 += 2LL)
            {
              *(_DWORD *)(v17
                        + 4LL
                        * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v85 & a4))) >> 48) + (v85 & 8))) = v85;
              v12 += 2LL;
            }
          }

          else
          {
            unint64_t v86 = v11 + 17;
            if (v11 + 17 >= v119) {
              unint64_t v86 = v119;
            }
            for (; v85 < v86; v85 += 4LL)
            {
              *(_DWORD *)(v17
                        + 4LL
                        * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v85 & a4))) >> 48) + (v85 & 8))) = v85;
              v12 += 4LL;
            }
          }
        }

        goto LABEL_177;
      }

      unsigned int v50 = 0;
      unint64_t v127 = *a7;
      while (1)
      {
        --v18;
        unint64_t v51 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v51 = v18;
        }
        unint64_t v52 = *(int *)(v16 + 4) >= 5 ? 0LL : v51;
        unint64_t v53 = v11 + 1;
        unint64_t v54 = v11 + 1 < v128 ? v11 + 1 : v128;
        unint64_t v55 = v53 & a4;
        int v56 = *(unsigned __int8 *)(a3 + v52 + (v53 & a4));
        unint64_t v57 = (void *)(a3 + (v53 & a4));
        if (v53 < v127) {
          goto LABEL_70;
        }
        unint64_t v58 = a4 & (v53 - v127);
        uint64_t v59 = a3 + v58;
        if (v18 < 8)
        {
          unint64_t v60 = 0LL;
          int v64 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_102:
          unint64_t v84 = v18 & 7;
          if ((v18 & 7) != 0)
          {
            do
            {
              ++v64;
              ++v60;
              --v84;
            }

            while (v84);
          }
        }

        else
        {
          unint64_t v60 = 0LL;
          unint64_t v61 = v18 >> 3;
          while (1)
          {
            uint64_t v62 = *(void *)((char *)v57 + v60);
            uint64_t v63 = *(void *)(v59 + v60);
            if (v62 != v63) {
              break;
            }
            v60 += 8LL;
            if (!--v61)
            {
              int v64 = (unsigned __int8 *)v57 + v60;
              goto LABEL_102;
            }
          }

          v60 += __clz(__rbit64(v63 ^ v62)) >> 3;
        }

        if (v60 >= 4 && (unint64_t v65 = 135 * v60 + 1935, v65 >= 0x7E5))
        {
          int v56 = *(unsigned __int8 *)(a3 + v60 + v55);
          unint64_t v66 = v127;
          unint64_t v52 = v60;
        }

        else
        {
LABEL_70:
          unint64_t v66 = 0LL;
          unint64_t v65 = 2020LL;
        }

        uint64_t v67 = 0LL;
        unint64_t v130 = (0xBD1E35A7BD000000LL * *v57) >> 48;
        uint64_t v131 = (unsigned __int16)(v130 + 8);
        unint64_t v68 = v18 & 7;
        char v69 = 1;
        do
        {
          char v70 = v69;
          uint64_t v71 = *(unsigned int *)(v17 + 4 * *(&v130 + v67));
          unint64_t v72 = v53 - v71;
          if (v56 == *(unsigned __int8 *)(a3 + (v71 & a4) + v52) && v53 != v71 && v72 <= v54)
          {
            uint64_t v75 = a3 + (v71 & a4);
            if (v18 < 8)
            {
              unint64_t v76 = 0LL;
              unint64_t v80 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_91:
              if (v68)
              {
                unint64_t v82 = v68;
                while (*(unsigned __int8 *)(v75 + v76) == *v80)
                {
                  ++v80;
                  ++v76;
                  --v82;
                  unint64_t v68 = v18 & 7;
                  if (!v82) {
                    goto LABEL_85;
                  }
                }

                unint64_t v68 = v18 & 7;
              }
            }

            else
            {
              unint64_t v76 = 0LL;
              unint64_t v77 = v18 >> 3;
              while (1)
              {
                uint64_t v78 = *(void *)((char *)v57 + v76);
                uint64_t v79 = *(void *)(v75 + v76);
                if (v78 != v79) {
                  break;
                }
                v76 += 8LL;
                if (!--v77)
                {
                  unint64_t v80 = (unsigned __int8 *)v57 + v76;
                  goto LABEL_91;
                }
              }

              v76 += __clz(__rbit64(v79 ^ v78)) >> 3;
            }

LABEL_177:
      unint64_t v11 = v85;
      if (v85 + 8 >= v13) {
        goto LABEL_190;
      }
    }

    uint64_t v100 = v123[1];
    if (v66 == v100)
    {
      unint64_t v88 = 1LL;
      goto LABEL_118;
    }

    unint64_t v101 = v66 + 3;
    unint64_t v102 = v66 + 3 - v92;
    if (v102 > 6)
    {
      if (v101 - v100 > 6)
      {
        if (v66 == v123[2])
        {
          unint64_t v88 = 2LL;
        }

        else if (v66 == v123[3])
        {
          unint64_t v88 = 3LL;
        }

        else
        {
LABEL_117:
          unint64_t v88 = v66 + 15;
        }

LABEL_118:
        if (v66 <= v87 && v88)
        {
          v123[3] = v123[2];
          *(void *)(v123 + 1) = *(void *)v123;
          int *v123 = v66;
        }

        *(_DWORD *)uint64_t v124 = v12;
        *(_DWORD *)(v124 + 4) = v52;
        uint64_t v89 = *(unsigned int *)(v16 + 68);
        uint64_t v90 = v89 + 16;
        if (v89 + 16 <= v88)
        {
          uint64_t v93 = *(unsigned int *)(v16 + 64);
          unint64_t v94 = v88 - v89 + (4LL << v93) - 16;
          uint64_t v95 = (__clz(v94) ^ 0x1F) - 1;
          uint64_t v96 = ((v94 >> v95) & 1 | 2) << v95;
          unint64_t v88 = ((v94 & ~(-1 << v93)) + v90 + ((((v94 >> v95) & 1 | (2 * (v95 - v93))) + 65534) << v93)) | ((v95 - v93) << 10);
          unint64_t v91 = (v94 - v96) >> v93;
        }

        else
        {
          LODWORD(v91) = 0;
        }

        goto LABEL_127;
      }

      char v103 = 4 * (v101 - v100);
      unsigned int v104 = 266017486;
    }

    else
    {
      char v103 = 4 * v102;
      unsigned int v104 = 158663784;
    }

    unint64_t v88 = (v104 >> v103) & 0xF;
    goto LABEL_118;
  }

  uint64_t v124 = a9;
  unint64_t v85 = a2;
LABEL_190:
  *a8 = v12 + v13 - v85;
  *a10 += (v124 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH4( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v173 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v157 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v155 = v14;
  else {
    uint64_t v15 = 64LL;
  }
  if (a2 + 8 >= v13)
  {
    uint64_t v158 = a9;
    unint64_t v114 = a2;
    goto LABEL_242;
  }

  uint64_t v154 = v15;
  uint64_t v166 = *(void *)(a5 + 16);
  unint64_t v167 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
  unint64_t v16 = v15 + a2;
  uint64_t v17 = *(void *)(a6 + 56);
  uint64_t v156 = 4 * v15;
  int8x16_t v18 = (int8x16_t)vdupq_n_s64(0x1FFFFuLL);
  uint64_t v158 = a9;
  uint64_t i = a7;
  unint64_t v165 = a2 + result;
  uint64_t v168 = a5;
  do
  {
    unint64_t v20 = v13 - v11;
    if (v11 >= v167) {
      unint64_t v21 = v167;
    }
    else {
      unint64_t v21 = v11;
    }
    if (v11 + v166 >= v167) {
      unint64_t v22 = v167;
    }
    else {
      unint64_t v22 = v11 + v166;
    }
    unint64_t result = v11 & a4;
    unint64_t v23 = (void *)(a3 + (v11 & a4));
    int v24 = *(unsigned __int8 *)v23;
    unint64_t v25 = *i;
    unint64_t v170 = v12;
    if (v11 < v25) {
      goto LABEL_25;
    }
    unint64_t v26 = (unsigned __int8 *)(a3 + (a4 & (v11 - v25)));
    if (v24 != *v26) {
      goto LABEL_25;
    }
    if (v20 < 8)
    {
      unint64_t v28 = 0LL;
      uint64_t v29 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_230:
      unint64_t v150 = v20 & 7;
      if ((v20 & 7) != 0)
      {
        unint64_t v151 = v28 | v150;
        while (v26[v28] == *v29)
        {
          ++v29;
          ++v28;
          if (!--v150)
          {
            unint64_t v28 = v151;
            break;
          }
        }
      }
    }

    else
    {
      uint64_t v27 = 0LL;
      unint64_t v28 = v20 & 0xFFFFFFFFFFFFFFF8LL;
      uint64_t v29 = (unsigned __int8 *)(a3 + result + (v20 & 0xFFFFFFFFFFFFFFF8LL));
      unint64_t v30 = v20 >> 3;
      while (1)
      {
        uint64_t v31 = v23[v27];
        uint64_t v32 = *(void *)&v26[v27 * 8];
        if (v31 != v32) {
          break;
        }
        ++v27;
        if (!--v30) {
          goto LABEL_230;
        }
      }

      unint64_t v28 = v27 * 8 + (__clz(__rbit64(v32 ^ v31)) >> 3);
    }

    if (v28 >= 4 && (v169 = v25, unint64_t v33 = 135 * v28 + 1935, v33 >= 0x7E5))
    {
      int v24 = *(unsigned __int8 *)(a3 + v28 + result);
    }

    else
    {
LABEL_25:
      unint64_t v169 = 0LL;
      unint64_t v28 = 0LL;
      unint64_t v33 = 2020LL;
    }

    uint64_t v34 = 0LL;
    unint64_t v159 = *(void *)(a5 + 80);
    int64x2_t v35 = vdupq_n_s64((0xBD1E35A7BD000000LL * *v23) >> 47);
    int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v35, (int64x2_t)xmmword_1810CB550), v18);
    int8x16_t v172 = vandq_s8((int8x16_t)vaddq_s64(v35, (int64x2_t)xmmword_1810CB560), v18);
    uint64_t v36 = *(uint64_t *)((char *)v171.i64 + (v11 & 0x18));
    do
    {
      uint64_t v37 = *(unsigned int *)(v17 + 4 * v171.i64[v34]);
      unint64_t v38 = v11 - v37;
      if (v24 == *(unsigned __int8 *)(a3 + (v37 & a4) + v28) && v11 != v37 && v38 <= v21)
      {
        uint64_t v41 = a3 + (v37 & a4);
        if (v20 < 8)
        {
          unint64_t v46 = 0LL;
          unsigned int v47 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_46:
          if ((v20 & 7) != 0)
          {
            unint64_t v49 = v20 & 7 | v46;
            unint64_t v50 = v20 & 7;
            while (*(unsigned __int8 *)(v41 + v46) == *v47)
            {
              ++v47;
              ++v46;
              if (!--v50)
              {
                unint64_t v46 = v49;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v42 = 0LL;
          unint64_t v43 = v20 >> 3;
          while (1)
          {
            uint64_t v44 = v23[v42];
            uint64_t v45 = *(void *)(v41 + v42 * 8);
            if (v44 != v45) {
              break;
            }
            ++v42;
            if (!--v43)
            {
              unint64_t v46 = v20 & 0xFFFFFFFFFFFFFFF8LL;
              unsigned int v47 = (unsigned __int8 *)v23 + (v20 & 0xFFFFFFFFFFFFFFF8LL);
              goto LABEL_46;
            }
          }

          unint64_t v46 = v42 * 8 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }

        if (v46 >= 4)
        {
          unint64_t v48 = 135 * v46 - 30 * (__clz(v38) ^ 0x1F) + 1920;
          if (v33 < v48)
          {
            int v24 = *(unsigned __int8 *)(a3 + v46 + result);
            unint64_t v33 = v48;
            unint64_t v169 = v11 - v37;
            unint64_t v28 = v46;
          }
        }
      }

      ++v34;
    }

    while (v34 != 4);
    if (v33 == 2020)
    {
      uint64_t v51 = *(void *)(a6 + 48);
      unint64_t v53 = *(void *)(v51 + 8);
      unint64_t v52 = *(void *)(v51 + 16);
      a5 = v168;
      if (v52 < v53 >> 7) {
        goto LABEL_55;
      }
      uint64_t v54 = ((506832829 * *(_DWORD *)v23) >> 17) & 0x7FFELL;
      uint64_t v55 = *(void *)(v168 + 120);
      *(void *)(v51 + 8) = v53 + 1;
      unint64_t v56 = *(unsigned __int8 *)(v55 + v54);
      if (!*(_BYTE *)(v55 + v54) || v20 < v56) {
        goto LABEL_55;
      }
      uint64_t v129 = *(unsigned __int16 *)(*(void *)(v168 + 112) + 2 * v54);
      uint64_t v130 = *(void *)(v168 + 88);
      unint64_t result = *(unsigned int *)(v130 + 4 * v56 + 32);
      uint64_t v131 = *(void *)(v130 + 168);
      uint64_t v132 = (unsigned __int8 *)(v131 + result + v129 * (unint64_t)v56);
      if (v56 < 8)
      {
        unint64_t v28 = 0LL;
LABEL_236:
        unint64_t v152 = v56 & 7;
        if ((v56 & 7) != 0)
        {
          unint64_t result = v28 | v152;
          while (*((unsigned __int8 *)v23 + v28) == *v132)
          {
            ++v132;
            ++v28;
            if (!--v152)
            {
              unint64_t v28 = result;
              break;
            }
          }
        }
      }

      else
      {
        unint64_t v133 = 0LL;
        unint64_t v28 = v56 & 0xF8;
        result += v131 + v129 * (unint64_t)v56 + v28;
        while (1)
        {
          uint64_t v134 = *(void *)&v132[v133];
          uint64_t v135 = v23[v133 / 8];
          if (v134 != v135) {
            break;
          }
          v133 += 8LL;
          if (v28 == v133)
          {
            uint64_t v132 = (unsigned __int8 *)result;
            goto LABEL_236;
          }
        }

        unint64_t v28 = v133 + (__clz(__rbit64(v135 ^ v134)) >> 3);
      }

      if (!v28
        || v28 + *(unsigned int *)(v168 + 100) <= v56
        || (unint64_t result = 6 * (v56 - v28),
            unint64_t v136 = v22
                 + 1
                 + v129
                 + ((((*(void *)(v168 + 104) >> result) & 0x3FLL) + 4 * (v56 - v28)) << *(_BYTE *)(v130 + v56)),
            v136 > v159)
        || (unint64_t v33 = 135 * v28 - 30 * (__clz(v136) ^ 0x1F) + 1920, v33 < 0x7E4))
      {
LABEL_55:
        *(_DWORD *)(v17 + 4 * v36) = v11;
LABEL_141:
        unint64_t v12 = v170 + 1;
        unint64_t v114 = v11 + 1;
        if (v11 + 1 <= v16)
        {
          uint64_t i = a7;
          unint64_t v13 = v165;
        }

        else
        {
          unint64_t v13 = v165;
          if (v114 <= v16 + v156)
          {
            unint64_t v116 = v11 + 9;
            if (v11 + 9 >= v157) {
              unint64_t v116 = v157;
            }
            for (uint64_t i = a7; v114 < v116; v114 += 2LL)
            {
              *(_DWORD *)(v17
                        + 4
              v12 += 2LL;
            }
          }

          else
          {
            unint64_t v115 = v11 + 17;
            if (v11 + 17 >= v157) {
              unint64_t v115 = v157;
            }
            for (uint64_t i = a7; v114 < v115; v114 += 4LL)
            {
              *(_DWORD *)(v17
                        + 4
              v12 += 4LL;
            }
          }
        }

        goto LABEL_223;
      }

      unint64_t v169 = v136;
      int v57 = v56 - v28;
      *(void *)(v51 + 16) = v52 + 1;
    }

    else
    {
      int v57 = 0;
      a5 = v168;
    }

    *(_DWORD *)(v17 + 4 * v36) = v11;
    if (v33 < 0x7E5) {
      goto LABEL_141;
    }
    unsigned int v58 = 0;
    unint64_t v163 = *a7;
    while (1)
    {
      --v20;
      unint64_t v59 = v28 - 1;
      if (v28 - 1 >= v20) {
        unint64_t v59 = v20;
      }
      else {
        unint64_t v60 = v59;
      }
      unint64_t v61 = v11 + 1;
      if (v11 + 1 < v167) {
        unint64_t v62 = v11 + 1;
      }
      else {
        unint64_t v62 = v167;
      }
      if (v61 + v166 >= v167) {
        unint64_t v63 = v167;
      }
      else {
        unint64_t v63 = v61 + v166;
      }
      unint64_t v64 = v61 & a4;
      int v65 = *(unsigned __int8 *)(a3 + v60 + (v61 & a4));
      unint64_t v66 = (void *)(a3 + (v61 & a4));
      unint64_t v164 = v63;
      int v162 = v57;
      if (v61 < v163)
      {
        unint64_t v74 = 0LL;
        unint64_t v75 = 2020LL;
      }

      else
      {
        unint64_t v67 = a4 & (v61 - v163);
        uint64_t v68 = a3 + v67;
        if (v20 < 8)
        {
          unint64_t v69 = 0LL;
          uint64_t v73 = (unsigned __int8 *)(a3 + (v61 & a4));
LABEL_131:
          unint64_t v111 = v20 & 7;
          if ((v20 & 7) != 0)
          {
            do
            {
              ++v73;
              ++v69;
              --v111;
            }

            while (v111);
          }
        }

        else
        {
          unint64_t v69 = 0LL;
          unint64_t v70 = v20 >> 3;
          while (1)
          {
            uint64_t v71 = *(void *)((char *)v66 + v69);
            uint64_t v72 = *(void *)(v68 + v69);
            if (v71 != v72) {
              break;
            }
            v69 += 8LL;
            if (!--v70)
            {
              uint64_t v73 = (unsigned __int8 *)v66 + v69;
              goto LABEL_131;
            }
          }

          v69 += __clz(__rbit64(v72 ^ v71)) >> 3;
        }

        if (v69 >= 4 && (unint64_t v75 = 135 * v69 + 1935, v75 >= 0x7E5))
        {
          int v65 = *(unsigned __int8 *)(a3 + v69 + v64);
          unint64_t v74 = v163;
          unint64_t v60 = v69;
        }

        else
        {
LABEL_82:
          unint64_t v74 = 0LL;
          unint64_t v75 = 2020LL;
        }
      }

      uint64_t v76 = 0LL;
      int64x2_t v77 = vdupq_n_s64((0xBD1E35A7BD000000LL * *v66) >> 47);
      int8x16_t v78 = (int8x16_t)vdupq_n_s64(0x1FFFFuLL);
      int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v77, (int64x2_t)xmmword_1810CB550), v78);
      int8x16_t v172 = vandq_s8((int8x16_t)vaddq_s64(v77, (int64x2_t)xmmword_1810CB560), v78);
      uint64_t v79 = *(uint64_t *)((char *)v171.i64 + (v61 & 0x18));
      do
      {
        uint64_t v80 = *(unsigned int *)(v17 + 4 * v171.i64[v76]);
        unint64_t v81 = v61 - v80;
        if (v65 == *(unsigned __int8 *)(a3 + (v80 & a4) + v60) && v61 != v80 && v81 <= v62)
        {
          uint64_t v84 = a3 + (v80 & a4);
          if (v20 < 8)
          {
            unint64_t v85 = 0LL;
            uint64_t v89 = (unsigned __int8 *)(a3 + (v61 & a4));
LABEL_103:
            if ((v20 & 7) != 0)
            {
              unint64_t v91 = v20 & 7;
              do
              {
                ++v89;
                ++v85;
                --v91;
              }

              while (v91);
            }
          }

          else
          {
            unint64_t v85 = 0LL;
            unint64_t v86 = v20 >> 3;
            while (1)
            {
              uint64_t v87 = *(void *)((char *)v66 + v85);
              uint64_t v88 = *(void *)(v84 + v85);
              if (v87 != v88) {
                break;
              }
              v85 += 8LL;
              if (!--v86)
              {
                uint64_t v89 = (unsigned __int8 *)v66 + v85;
                goto LABEL_103;
              }
            }

            v85 += __clz(__rbit64(v88 ^ v87)) >> 3;
          }

          if (v85 >= 4)
          {
            unsigned int v90 = __clz(v81);
            if (v75 < 135 * v85 - 30 * (v90 ^ 0x1F) + 1920)
            {
              int v65 = *(unsigned __int8 *)(a3 + v85 + v64);
              unint64_t v75 = 135 * v85 - 30 * (v90 ^ 0x1F) + 1920;
              unint64_t v74 = v81;
              unint64_t v60 = v85;
            }
          }
        }

        ++v76;
      }

      while (v76 != 4);
      if (v75 != 2020)
      {
        int v108 = 0;
        a5 = v168;
        goto LABEL_125;
      }

      uint64_t v92 = *(void *)(a6 + 48);
      unint64_t v93 = *(void *)(v92 + 8);
      unint64_t v94 = *(void *)(v92 + 16);
      a5 = v168;
      if (v94 < v93 >> 7
        || (uint64_t v95 = ((506832829 * *(_DWORD *)v66) >> 17) & 0x7FFELL,
            uint64_t v96 = *(void *)(v168 + 120),
            *(void *)(v92 + 8) = v93 + 1,
            unint64_t v97 = *(unsigned __int8 *)(v96 + v95),
            !*(_BYTE *)(v96 + v95))
        || v20 < v97)
      {
LABEL_123:
        int v108 = 0;
LABEL_124:
        unint64_t v75 = 2020LL;
        goto LABEL_125;
      }

      uint64_t v98 = *(unsigned __int16 *)(*(void *)(v168 + 112) + 2 * v95);
      uint64_t v99 = *(void *)(v168 + 88);
      uint64_t v100 = *(unsigned int *)(v99 + 4 * v97 + 32);
      uint64_t v101 = *(void *)(v99 + 168);
      unint64_t v102 = (unsigned __int8 *)(v101 + v100 + v98 * (unint64_t)v97);
      if (v97 < 8)
      {
        unint64_t v104 = 0LL;
LABEL_136:
        unint64_t v112 = v97 & 7;
        if ((v97 & 7) != 0)
        {
          unint64_t v113 = v104 | v112;
          while (*((unsigned __int8 *)v66 + v104) == *v102)
          {
            ++v102;
            ++v104;
            if (!--v112)
            {
              unint64_t v104 = v113;
              break;
            }
          }
        }
      }

      else
      {
        unint64_t v103 = 0LL;
        unint64_t v104 = v97 & 0xF8;
        unint64_t v105 = (unsigned __int8 *)(v101 + v98 * (unint64_t)v97 + v104 + v100);
        while (1)
        {
          uint64_t v106 = *(void *)&v102[v103];
          uint64_t v107 = v66[v103 / 8];
          if (v106 != v107) {
            break;
          }
          v103 += 8LL;
          if (v104 == v103)
          {
            unint64_t v102 = v105;
            goto LABEL_136;
          }
        }

        unint64_t v104 = v103 + (__clz(__rbit64(v107 ^ v106)) >> 3);
      }

      int v108 = 0;
      a5 = v168;
      unint64_t v109 = v164
           + 1
           + v98
      if (v109 > v159) {
        goto LABEL_123;
      }
      unint64_t v75 = 135 * v104 - 30 * (__clz(v109) ^ 0x1F) + 1920;
      if (v75 < 0x7E4) {
        goto LABEL_123;
      }
      int v108 = v97 - v104;
      *(void *)(v92 + 16) = v94 + 1;
      unint64_t v74 = v109;
      unint64_t v60 = v104;
LABEL_125:
      *(_DWORD *)(v17 + 4 * v79) = v61;
      if (v75 < v33 + 175) {
        break;
      }
      ++v170;
      if (v58 <= 2)
      {
        unint64_t v110 = v11 + 9;
        ++v58;
        unint64_t v33 = v75;
        unint64_t v169 = v74;
        unint64_t v28 = v60;
        int v57 = v108;
        ++v11;
        if (v110 < v165) {
          continue;
        }
      }

      goto LABEL_157;
    }

    unint64_t v117 = v11 + v166;
    if (v11 + v166 >= v167) {
      unint64_t v117 = v167;
    }
    unint64_t v164 = v117;
    unint64_t v74 = v169;
    unint64_t v60 = v28;
    int v108 = v162;
    unint64_t v61 = v11;
LABEL_157:
    unint64_t v13 = v165;
    uint64_t i = a7;
    unint64_t result = v170;
    if (v74 > v164)
    {
LABEL_158:
      unint64_t v118 = v74 + 15;
      goto LABEL_159;
    }

    uint64_t v119 = *a7;
    if (v74 == v119)
    {
      unint64_t v118 = 0LL;
      goto LABEL_164;
    }

    uint64_t v137 = a7[1];
    if (v74 == v137)
    {
      unint64_t v118 = 1LL;
    }

    else
    {
      unint64_t v138 = v74 + 3 - v119;
      if (v138 > 6)
      {
        unint64_t v141 = v74 + 3 - v137;
        if (v141 > 6)
        {
          if (v74 == a7[2])
          {
            unint64_t v118 = 2LL;
          }

          else
          {
            if (v74 != a7[3]) {
              goto LABEL_158;
            }
            unint64_t v118 = 3LL;
          }

          goto LABEL_159;
        }

        char v139 = 4 * v141;
        unsigned int v140 = 266017486;
      }

      else
      {
        char v139 = 4 * v138;
        unsigned int v140 = 158663784;
      }

      unint64_t v118 = (v140 >> v139) & 0xF;
    }

LABEL_223:
    unint64_t v11 = v114;
  }

  while (v114 + 8 < v13);
LABEL_242:
  *a8 = v12 + v13 - v114;
  *a10 += (v158 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH5( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v239 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v226 = a2 + result - 3;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = a2 + result - 3;
  }
  int v15 = *(_DWORD *)(a5 + 8);
  uint64_t v16 = 512LL;
  unint64_t v227 = v14;
  uint64_t v228 = v16;
  int v17 = *(_DWORD *)(a6 + 76);
  if (v17 >= 5)
  {
    int32x4_t v18 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v18, (int32x4_t)xmmword_1810CB570);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v17 >= 0xB)
    {
      unint64_t v19 = (const float *)(a7 + 1);
      int32x4_t v20 = (int32x4_t)vld1q_dup_f32(v19);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v20, (int32x4_t)xmmword_1810CB570);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }

  if (a2 + 4 < v13)
  {
    unint64_t v21 = v228 + a2;
    unint64_t v238 = (1LL << v15) - 16;
    uint64_t v22 = *(void *)(a6 + 88);
    uint64_t v23 = *(void *)(a6 + 96);
    unint64_t v225 = v13 - 4;
    uint64_t v229 = a9;
    unint64_t v230 = v13;
    uint64_t v252 = v22;
    uint64_t v240 = v23;
    while (1)
    {
      unint64_t v253 = v12;
      unint64_t v24 = v13 - v11;
      if (v11 >= v238) {
        unint64_t v25 = v238;
      }
      else {
        unint64_t v25 = v11;
      }
      unint64_t v26 = v11 + v239;
      if (v11 + v239 >= v238) {
        unint64_t v26 = v238;
      }
      unint64_t v247 = v26;
      unint64_t v250 = v21;
      unint64_t v27 = v11 & a4;
      uint64_t v28 = *(int *)(a6 + 76);
      if ((_DWORD)v28)
      {
        unint64_t v29 = 0LL;
        unint64_t v30 = 0LL;
        unint64_t v31 = 0LL;
        unint64_t v244 = 0LL;
        unint64_t v32 = 2020LL;
        uint64_t v33 = 2020LL;
        do
        {
          unint64_t v34 = a7[v30];
          unint64_t v35 = v11 - v34;
          BOOL v36 = v25 < v34 || v35 >= v11;
          unint64_t v37 = v35 & a4;
          unint64_t v38 = v29 + v27;
          BOOL v39 = v36 || v38 > a4;
          unint64_t result = v37 + v29;
          BOOL v40 = v39 || result > a4;
          if (!v40 && *(unsigned __int8 *)(a3 + v38) == *(unsigned __int8 *)(a3 + result))
          {
            uint64_t v41 = a3 + v37;
            if (v24 < 8)
            {
              unint64_t result = 0LL;
              unint64_t v46 = (unsigned __int8 *)(a3 + v27);
LABEL_52:
              if ((v24 & 7) != 0)
              {
                unint64_t v50 = v24 & 7 | result;
                unint64_t v51 = v24 & 7;
                while (*(unsigned __int8 *)(v41 + result) == *v46)
                {
                  ++v46;
                  ++result;
                  if (!--v51)
                  {
                    unint64_t result = v50;
                    break;
                  }
                }

                uint64_t v22 = v252;
                uint64_t v23 = v240;
              }
            }

            else
            {
              uint64_t v42 = 0LL;
              unint64_t v43 = v24 >> 3;
              while (1)
              {
                uint64_t v44 = *(void *)(a3 + v27 + v42);
                uint64_t v45 = *(void *)(v41 + v42);
                if (v44 != v45) {
                  break;
                }
                v42 += 8LL;
                if (!--v43)
                {
                  unint64_t result = v24 & 0xFFFFFFFFFFFFFFF8LL;
                  unint64_t v46 = (unsigned __int8 *)(a3 + v27 + (v24 & 0xFFFFFFFFFFFFFFF8LL));
                  goto LABEL_52;
                }
              }

              unint64_t result = v42 + (__clz(__rbit64(v45 ^ v44)) >> 3);
            }

            if (result > 2 || v30 <= 1 && result == 2)
            {
              unint64_t v47 = 135 * result + 1935;
              if (v32 < v47)
              {
                unint64_t v48 = v47 - (((0x1CA10u >> (v30 & 0xE)) & 0xE) + 39);
                if (!v30) {
                  unint64_t v48 = 135 * result + 1935;
                }
                if (v32 < v48) {
                  uint64_t v33 = v48;
                }
                unint64_t v49 = v244;
                if (v32 < v48) {
                  unint64_t v49 = a7[v30];
                }
                unint64_t v244 = v49;
                if (v32 < v48)
                {
                  unint64_t v31 = result;
                  unint64_t v29 = result;
                  unint64_t v32 = v48;
                }
              }
            }
          }

          ++v30;
        }

        while (v30 != v28);
      }

      else
      {
        unint64_t v244 = 0LL;
        unint64_t v31 = 0LL;
        unint64_t v29 = 0LL;
        uint64_t v33 = 2020LL;
        unint64_t v32 = 2020LL;
      }

      unint64_t v52 = v31;
      unint64_t v246 = *(void *)(a5 + 80);
      unint64_t v53 = (_DWORD *)(a3 + v27);
      uint64_t v54 = *(unsigned int *)(a6 + 68);
      uint64_t v55 = (506832829 * *(_DWORD *)(a3 + v27)) >> *(_DWORD *)(a6 + 64);
      uint64_t v56 = v23 + 4LL * ((_DWORD)v55 << *(_DWORD *)(a6 + 72));
      unint64_t v57 = *(unsigned __int16 *)(v22 + 2LL * v55);
      unint64_t v237 = *(void *)(a6 + 56);
      if (v57 >= v237) {
        unint64_t v58 = v57 - v237;
      }
      else {
        unint64_t v58 = 0LL;
      }
      if (v58 < v57)
      {
        unint64_t v59 = *(unsigned __int16 *)(v22 + 2LL * v55);
        do
        {
          uint64_t v60 = *(unsigned int *)(v56 + 4 * (--v59 & v54));
          unint64_t v61 = v11 - v60;
          if (v11 - v60 > v25) {
            break;
          }
          if (v29 + v27 <= a4)
          {
            unint64_t v62 = v60 & a4;
            if (v62 + v29 <= a4 && *(unsigned __int8 *)(a3 + v29 + v27) == *(unsigned __int8 *)(a3 + v62 + v29))
            {
              uint64_t v63 = a3 + v62;
              if (v24 < 8)
              {
                unint64_t v68 = v13;
                unint64_t result = 0LL;
                unint64_t v69 = (unsigned __int8 *)(a3 + v27);
LABEL_80:
                if ((v24 & 7) != 0)
                {
                  unint64_t v71 = v24 & 7;
                  unint64_t v241 = v71 | result;
                  while (*(unsigned __int8 *)(v63 + result) == *v69)
                  {
                    ++v69;
                    ++result;
                    if (!--v71)
                    {
                      unint64_t result = v241;
                      break;
                    }
                  }
                }

                unint64_t v13 = v68;
              }

              else
              {
                uint64_t v64 = 0LL;
                unint64_t v65 = v24 >> 3;
                while (1)
                {
                  uint64_t v66 = *(void *)&v53[v64];
                  uint64_t v67 = *(void *)(v63 + v64 * 4);
                  if (v66 != v67) {
                    break;
                  }
                  v64 += 2LL;
                  if (!--v65)
                  {
                    unint64_t v68 = v13;
                    unint64_t result = v24 & 0xFFFFFFFFFFFFFFF8LL;
                    unint64_t v69 = (unsigned __int8 *)v53 + (v24 & 0xFFFFFFFFFFFFFFF8LL);
                    goto LABEL_80;
                  }
                }

                unint64_t result = v64 * 4 + (__clz(__rbit64(v67 ^ v66)) >> 3);
              }

              if (result >= 4)
              {
                unint64_t v70 = 135 * result - 30 * (__clz(v61) ^ 0x1F) + 1920;
                if (v32 < v70)
                {
                  uint64_t v33 = v70;
                  unint64_t v244 = v61;
                  unint64_t v52 = result;
                  unint64_t v29 = result;
                  unint64_t v32 = v70;
                }
              }
            }
          }
        }

        while (v59 > v58);
      }

      *(_DWORD *)(v56 + 4LL * (v54 & v57)) = v11;
      uint64_t v22 = v252;
      *(_WORD *)(v252 + 2 * v55) = v57 + 1;
      if (v33 == 2020)
      {
        uint64_t v72 = *(void *)(a6 + 80);
        unint64_t v74 = *(void *)(v72 + 8);
        unint64_t v73 = *(void *)(v72 + 16);
        uint64_t v75 = a5;
        uint64_t v23 = v240;
        unint64_t v76 = v244;
        if (v73 < v74 >> 7) {
          goto LABEL_223;
        }
        int v236 = 0;
        uint64_t v77 = ((506832829 * *v53) >> 17) & 0x7FFE;
        uint64_t v78 = *(void *)(a5 + 120);
        unint64_t v248 = v247 + 1;
        char v79 = 1;
        unint64_t v80 = v52;
        unint64_t v81 = 2020LL;
        do
        {
          char v82 = v79;
          *(void *)(v72 + 8) = ++v74;
          unint64_t v83 = *(unsigned __int8 *)(v78 + v77);
          if (!*(_BYTE *)(v78 + v77) || v24 < v83) {
            goto LABEL_101;
          }
          uint64_t v84 = *(unsigned __int16 *)(*(void *)(v75 + 112) + 2 * v77);
          uint64_t v85 = *(void *)(v75 + 88);
          uint64_t v86 = *(unsigned int *)(v85 + 4 * v83 + 32);
          uint64_t v87 = *(void *)(v85 + 168);
          unint64_t result = v87 + v86 + v84 * *(unsigned __int8 *)(v78 + v77);
          if (v83 < 8)
          {
            unint64_t v52 = 0LL;
LABEL_106:
            unint64_t v94 = v83 & 7;
            if ((v83 & 7) != 0)
            {
              unint64_t v95 = v52;
              unint64_t v96 = v81;
              unint64_t v97 = v95 | v94;
              while (*((unsigned __int8 *)v53 + v95) == *(unsigned __int8 *)result)
              {
                ++result;
                ++v95;
                if (!--v94)
                {
                  unint64_t v98 = v97;
                  unint64_t v81 = v96;
                  unint64_t v52 = v98;
                  goto LABEL_97;
                }
              }

              unint64_t v81 = v96;
              unint64_t v52 = v95;
            }
          }

          else
          {
            unint64_t v88 = 0LL;
            unint64_t v89 = v87
                + v84 * (unint64_t)*(unsigned __int8 *)(v78 + v77)
                + (*(_BYTE *)(v78 + v77) & 0xF8)
                + v86;
            while (1)
            {
              uint64_t v90 = *(void *)(result + v88);
              uint64_t v91 = *(void *)&v53[v88 / 4];
              if (v90 != v91) {
                break;
              }
              v88 += 8LL;
              if ((v83 & 0xF8) == v88)
              {
                unint64_t result = v89;
                unint64_t v52 = v83 & 0xF8;
                goto LABEL_106;
              }
            }

            unint64_t v52 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
          }

LABEL_97:
          uint64_t v75 = a5;
          if (v52
            && v52 + *(unsigned int *)(a5 + 100) > v83
            && (unint64_t result = 6 * (v83 - v52),
                unint64_t v92 = v248
                    + v84
                    + ((((*(void *)(a5 + 104) >> result) & 0x3FLL) + 4 * (v83 - v52)) << *(_BYTE *)(v85 + v83)),
                v92 <= v246)
            && (unint64_t v93 = 135 * v52 - 30 * (__clz(v92) ^ 0x1F) + 1920, v93 >= v81))
          {
            int v236 = v83 - v52;
            *(void *)(v72 + 16) = ++v73;
            unint64_t v81 = v93;
          }

          else
          {
LABEL_101:
            unint64_t v92 = v76;
            unint64_t v52 = v80;
          }

          char v79 = 0;
          ++v77;
          unint64_t v80 = v52;
          unint64_t v76 = v92;
        }

        while ((v82 & 1) != 0);
      }

      else
      {
        unint64_t v81 = v33;
        int v236 = 0;
        uint64_t v75 = a5;
        uint64_t v23 = v240;
        unint64_t v92 = v244;
      }

      if (v81 < 0x7E5)
      {
LABEL_223:
        unint64_t v12 = v253 + 1;
        unint64_t v175 = v11 + 1;
        unint64_t v21 = v250;
        if (v11 + 1 > v250)
        {
          if (v175 <= v250 + 4 * v228)
          {
            unint64_t v198 = v11 + 9;
            if (v11 + 9 >= v226) {
              unint64_t v198 = v226;
            }
            if (v175 < v198)
            {
              int v199 = *(_DWORD *)(a6 + 64);
              int v200 = *(_DWORD *)(a6 + 68);
              int v201 = *(_DWORD *)(a6 + 72);
              do
              {
                unsigned int v202 = (506832829 * *(_DWORD *)(a3 + (v175 & a4))) >> v199;
                unsigned int v203 = *(unsigned __int16 *)(v252 + 2LL * v202);
                *(_DWORD *)(v23 + 4 * ((v202 << v201) + (unint64_t)(v200 & v203))) = v175;
                *(_WORD *)(v252 + 2LL * v202) = v203 + 1;
                v12 += 2LL;
                v175 += 2LL;
              }

              while (v175 < v198);
            }
          }

          else
          {
            unint64_t v176 = v11 + 17;
            if (v11 + 17 >= v225) {
              unint64_t v176 = v225;
            }
            if (v175 < v176)
            {
              int v177 = *(_DWORD *)(a6 + 64);
              int v178 = *(_DWORD *)(a6 + 68);
              int v179 = *(_DWORD *)(a6 + 72);
              do
              {
                unsigned int v180 = (506832829 * *(_DWORD *)(a3 + (v175 & a4))) >> v177;
                unsigned int v181 = *(unsigned __int16 *)(v252 + 2LL * v180);
                *(_DWORD *)(v23 + 4 * ((v180 << v179) + (unint64_t)(v178 & v181))) = v175;
                *(_WORD *)(v252 + 2LL * v180) = v181 + 1;
                v12 += 4LL;
                v175 += 4LL;
              }

              while (v175 < v176);
            }
          }
        }

        goto LABEL_297;
      }

      unint64_t v245 = v92;
      unint64_t v251 = v81;
      unsigned int v99 = 0;
      int v232 = *(_DWORD *)(a6 + 64);
      int v233 = *(_DWORD *)(a6 + 72);
      uint64_t v100 = *(unsigned int *)(a6 + 68);
      unsigned int v234 = *(_DWORD *)(a6 + 76);
      if (v234 <= 1) {
        int v101 = 1;
      }
      else {
        int v101 = *(_DWORD *)(a6 + 76);
      }
      uint64_t v102 = v101;
      unint64_t v103 = v52;
      while (1)
      {
        --v24;
        unint64_t v231 = v103;
        unint64_t v104 = v103 - 1;
        if (v103 - 1 >= v24) {
          unint64_t v104 = v24;
        }
        else {
          unint64_t v105 = v104;
        }
        unint64_t v106 = v11 + 1;
        if (v11 + 1 < v238) {
          unint64_t v107 = v11 + 1;
        }
        else {
          unint64_t v107 = v238;
        }
        unint64_t v108 = v106 + v239;
        if (v106 + v239 >= v238) {
          unint64_t v108 = v238;
        }
        unint64_t v242 = v108;
        unint64_t v109 = v106 & a4;
        unsigned int v249 = v99;
        if (v234)
        {
          unint64_t v110 = 0LL;
          unint64_t v111 = 0LL;
          unint64_t v112 = 0LL;
          uint64_t v113 = a3 + v109;
          unint64_t v114 = 2020LL;
          unint64_t v115 = 2020LL;
          do
          {
            unint64_t v116 = a7[v110];
            unint64_t v117 = v106 - v116;
            BOOL v118 = v107 < v116 || v117 >= v106;
            unint64_t v119 = v117 & a4;
            unint64_t v120 = v105 + v109;
            BOOL v121 = v118 || v120 > a4;
            unint64_t v122 = v119 + v105;
            BOOL v123 = v121 || v122 > a4;
            if (!v123 && *(unsigned __int8 *)(a3 + v120) == *(unsigned __int8 *)(a3 + v122))
            {
              uint64_t v124 = a3 + v119;
              if (v24 < 8)
              {
                unint64_t v125 = 0LL;
                uint64_t v129 = (unsigned __int8 *)(a3 + v109);
LABEL_160:
                if ((v24 & 7) != 0)
                {
                  unint64_t v132 = v24 & 7;
                  do
                  {
                    ++v129;
                    ++v125;
                    --v132;
                  }

                  while (v132);
                }
              }

              else
              {
                unint64_t v125 = 0LL;
                unint64_t v126 = v24 >> 3;
                while (1)
                {
                  uint64_t v127 = *(void *)(v113 + v125);
                  uint64_t v128 = *(void *)(v124 + v125);
                  if (v127 != v128) {
                    break;
                  }
                  v125 += 8LL;
                  if (!--v126)
                  {
                    uint64_t v129 = (unsigned __int8 *)(v113 + v125);
                    goto LABEL_160;
                  }
                }

                v125 += __clz(__rbit64(v128 ^ v127)) >> 3;
              }

              if (v125 > 2 || v110 <= 1 && v125 == 2)
              {
                unint64_t v130 = 135 * v125 + 1935;
                if (v114 < v130)
                {
                  unint64_t v131 = v130 - (((0x1CA10u >> (v110 & 0xE)) & 0xE) + 39);
                  if (!v110) {
                    unint64_t v131 = 135 * v125 + 1935;
                  }
                  if (v114 < v131)
                  {
                    unint64_t v115 = v131;
                    unint64_t v112 = a7[v110];
                    unint64_t v111 = v125;
                    unint64_t v105 = v125;
                    unint64_t v114 = v131;
                  }
                }
              }
            }

            ++v110;
          }

          while (v110 != v102);
        }

        else
        {
          unint64_t v112 = 0LL;
          unint64_t v111 = 0LL;
          unint64_t v115 = 2020LL;
          unint64_t v114 = 2020LL;
        }

        unint64_t v133 = (_DWORD *)(a3 + v109);
        uint64_t v134 = (506832829 * *(_DWORD *)(a3 + v109)) >> v232;
        uint64_t v135 = v240 + 4LL * ((_DWORD)v134 << v233);
        unint64_t v136 = *(unsigned __int16 *)(v252 + 2LL * v134);
        if (v136 >= v237) {
          unint64_t v137 = v136 - v237;
        }
        else {
          unint64_t v137 = 0LL;
        }
        if (v137 < v136)
        {
          unint64_t v138 = v24 & 7;
          unint64_t v139 = *(unsigned __int16 *)(v252 + 2LL * v134);
          do
          {
            uint64_t v140 = *(unsigned int *)(v135 + 4 * (--v139 & v100));
            unint64_t v141 = v106 - v140;
            if (v106 - v140 > v107) {
              break;
            }
            if (v105 + v109 <= a4)
            {
              unint64_t v142 = v140 & a4;
              if (v142 + v105 <= a4 && *(unsigned __int8 *)(a3 + v105 + v109) == *(unsigned __int8 *)(a3 + v142 + v105))
              {
                uint64_t v143 = a3 + v142;
                if (v24 < 8)
                {
                  unint64_t v145 = 0LL;
                  uint64_t v243 = (unsigned __int8 *)(a3 + v109);
LABEL_187:
                  if (v138)
                  {
                    unint64_t v150 = v138;
                    do
                    {
                      ++v243;
                      ++v145;
                      --v150;
                    }

                    while (v150);
                  }
                }

                else
                {
                  unint64_t v144 = v138;
                  unint64_t v145 = 0LL;
                  unint64_t v146 = v24 >> 3;
                  while (1)
                  {
                    uint64_t v147 = *(void *)((char *)v133 + v145);
                    uint64_t v148 = *(void *)(v143 + v145);
                    if (v147 != v148) {
                      break;
                    }
                    v145 += 8LL;
                    if (!--v146)
                    {
                      uint64_t v243 = (unsigned __int8 *)v133 + v145;
                      unint64_t v138 = v144;
                      goto LABEL_187;
                    }
                  }

                  v145 += __clz(__rbit64(v148 ^ v147)) >> 3;
                  unint64_t v138 = v144;
                }

                if (v145 >= 4)
                {
                  unint64_t v149 = 135 * v145 - 30 * (__clz(v141) ^ 0x1F) + 1920;
                  if (v114 < v149)
                  {
                    unint64_t v115 = v149;
                    unint64_t v112 = v141;
                    unint64_t v111 = v145;
                    unint64_t v105 = v145;
                    unint64_t v114 = v149;
                  }
                }
              }
            }
          }

          while (v139 > v137);
        }

        *(_DWORD *)(v135 + 4LL * (v100 & v136)) = v106;
        *(_WORD *)(v252 + 2 * v134) = v136 + 1;
        if (v115 == 2020)
        {
          uint64_t v151 = *(void *)(a6 + 80);
          unint64_t v152 = *(void *)(v151 + 8);
          unint64_t v153 = *(void *)(v151 + 16);
          uint64_t v75 = a5;
          int v154 = 0;
          if (v153 >= v152 >> 7)
          {
            uint64_t v156 = ((506832829 * *v133) >> 17) & 0x7FFE;
            uint64_t v157 = *(void *)(a5 + 120);
            char v158 = 1;
            unint64_t v159 = v111;
            unint64_t v160 = v112;
            unint64_t v115 = 2020LL;
            do
            {
              char v161 = v158;
              *(void *)(v151 + 8) = ++v152;
              unint64_t v162 = *(unsigned __int8 *)(v157 + v156);
              if (!*(_BYTE *)(v157 + v156) || v24 < v162) {
                goto LABEL_213;
              }
              uint64_t v163 = *(unsigned __int16 *)(*(void *)(v75 + 112) + 2 * v156);
              uint64_t v164 = *(void *)(v75 + 88);
              uint64_t v165 = *(unsigned int *)(v164 + 4 * v162 + 32);
              uint64_t v166 = *(void *)(v164 + 168);
              unint64_t v167 = (unsigned __int8 *)(v166 + v165 + v163 * *(unsigned __int8 *)(v157 + v156));
              if (v162 < 8)
              {
                unint64_t v111 = 0LL;
LABEL_218:
                unint64_t v173 = v162 & 7;
                if ((v162 & 7) != 0)
                {
                  unint64_t v174 = v111 | v173;
                  while (*((unsigned __int8 *)v133 + v111) == *v167)
                  {
                    ++v167;
                    ++v111;
                    if (!--v173)
                    {
                      unint64_t v111 = v174;
                      break;
                    }
                  }
                }
              }

              else
              {
                unint64_t v168 = 0LL;
                unint64_t v111 = v162 & 0xF8;
                unint64_t v169 = (unsigned __int8 *)(v166
                                         + v163 * (unint64_t)*(unsigned __int8 *)(v157 + v156)
                                         + (*(_BYTE *)(v157 + v156) & 0xF8)
                                         + v165);
                while (1)
                {
                  uint64_t v170 = *(void *)&v167[v168];
                  uint64_t v171 = *(void *)&v133[v168 / 4];
                  if (v170 != v171) {
                    break;
                  }
                  v168 += 8LL;
                  if (v111 == v168)
                  {
                    unint64_t v167 = v169;
                    goto LABEL_218;
                  }
                }

                unint64_t v111 = v168 + (__clz(__rbit64(v171 ^ v170)) >> 3);
              }

              uint64_t v75 = a5;
              if (v111
                && v111 + *(unsigned int *)(a5 + 100) > v162
                && (unint64_t v112 = v242
                         + 1
                         + v163
                         + ((((*(void *)(a5 + 104) >> (6 * (v162 - v111))) & 0x3FLL)
                           + 4 * (v162 - v111)) << *(_BYTE *)(v164 + v162)),
                    v112 <= v246)
                && (unint64_t v172 = 135 * v111 - 30 * (__clz(v112) ^ 0x1F) + 1920, v172 >= v115))
              {
                int v154 = v162 - v111;
                *(void *)(v151 + 16) = ++v153;
                unint64_t v115 = v172;
              }

              else
              {
LABEL_213:
                unint64_t v112 = v160;
                unint64_t v111 = v159;
              }

              char v158 = 0;
              ++v156;
              unint64_t v159 = v111;
              unint64_t v160 = v112;
            }

            while ((v161 & 1) != 0);
          }

          else
          {
            unint64_t v115 = 2020LL;
          }
        }

        else
        {
          int v154 = 0;
          uint64_t v75 = a5;
        }

        if (v115 < v251 + 175) {
          break;
        }
        ++v253;
        unint64_t v13 = v230;
        if (v249 <= 2)
        {
          unint64_t v155 = v11 + 5;
          unsigned int v99 = v249 + 1;
          unint64_t v251 = v115;
          unint64_t v245 = v112;
          unint64_t v103 = v111;
          int v236 = v154;
          ++v11;
          if (v155 < v230) {
            continue;
          }
        }

        goto LABEL_234;
      }

      unint64_t v182 = v11 + v239;
      if (v11 + v239 >= v238) {
        unint64_t v182 = v238;
      }
      unint64_t v242 = v182;
      unint64_t v112 = v245;
      unint64_t v13 = v230;
      unint64_t v111 = v231;
      int v154 = v236;
      unint64_t v106 = v11;
LABEL_234:
      uint64_t v22 = v252;
      if (v112 > v242) {
        goto LABEL_235;
      }
      uint64_t v188 = *a7;
      if (v112 != v188) {
        break;
      }
      unint64_t v183 = 0LL;
LABEL_243:
      *(_DWORD *)uint64_t v229 = v253;
      *(_DWORD *)(v229 + 4) = v111 | (v154 << 25);
      uint64_t v189 = *(unsigned int *)(v75 + 68);
      uint64_t v190 = v189 + 16;
      if (v189 + 16 <= v183)
      {
        uint64_t v192 = *(unsigned int *)(v75 + 64);
        unint64_t v193 = v183 - v189 + (4LL << v192) - 16;
        uint64_t v194 = (__clz(v193) ^ 0x1F) - 1;
        uint64_t v195 = ((v193 >> v194) & 1 | 2) << v194;
        unint64_t v183 = ((v193 & ~(-1 << v192))
              + v190
              + ((((v193 >> v194) & 1 | (2 * (v194 - v192))) + 65534) << v192)) | ((v194 - v192) << 10);
        unint64_t v191 = (v193 - v195) >> v192;
      }

      else
      {
        LODWORD(v191) = 0;
      }

      *(_WORD *)(v229 + 14) = v183;
      *(_DWORD *)(v229 + 8) = v191;
      if (v253 > 5)
      {
        if (v253 > 0x81)
        {
          if (v253 > 0x841)
          {
            if (v253 >> 1 >= 0xC21)
            {
              if (v253 < 0x5842) {
                LOWORD(v196) = 22;
              }
              else {
                LOWORD(v196) = 23;
              }
            }

            else
            {
              LOWORD(v196) = 21;
            }
          }

          else
          {
            unsigned int v196 = (__clz(v253 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v197 = (__clz(v253 - 2) ^ 0x1F) - 1;
          unsigned int v196 = ((v253 - 2) >> v197) + 2 * v197 + 2;
        }
      }

      else
      {
        LOWORD(v196) = v253;
      }

      uint64_t v209 = v154 + (int)v111;
      if (v209 > 9)
      {
        if (v209 > 0x85)
        {
          else {
            unsigned int v210 = (__clz(v209 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v211 = v209 - 6;
          unsigned int v212 = (__clz(v211) ^ 0x1F) - 1;
          unsigned int v210 = (v211 >> v212) + 2 * v212 + 4;
        }
      }

      else
      {
        LOWORD(v210) = v154 + v111 - 2;
      }

      int v213 = v210 & 7 | (8 * (v196 & 7));
      if ((v183 & 0x3FF) != 0 || (unsigned __int16)v196 > 7u || (unsigned __int16)v210 > 0xFu)
      {
        int v215 = 3 * ((unsigned __int16)v196 >> 3) + ((unsigned __int16)(v210 & 0xFFF8) >> 3);
        unsigned int v214 = ((((0x520D40u >> (2 * v215)) & 0xC0) + (v215 << 6)) | v213) + 64;
      }

      else
      {
        LOWORD(v214) = v213 | 0x40;
        if ((v210 & 0xFFF8) == 0) {
          LOWORD(v214) = v210 & 7 | (8 * (v196 & 7));
        }
      }

      *(_WORD *)(v229 + 12) = v214;
      unint64_t v216 = v227;
      *a11 += v253;
      unint64_t v217 = v106 + 2;
      unint64_t v175 = v106 + v111;
      if (v106 + v111 < v227) {
        unint64_t v216 = v106 + v111;
      }
      if (v112 < v111 >> 2)
      {
        unint64_t v218 = v175 - 4 * v112;
        if (v217 > v218) {
          unint64_t v218 = v106 + 2;
        }
        if (v216 >= v218) {
          unint64_t v217 = v218;
        }
        else {
          unint64_t v217 = v216;
        }
      }

      unint64_t v21 = v228 + 2 * v111 + v106;
      unint64_t result = v229 + 16;
      v229 += 16LL;
      if (v217 >= v216)
      {
        unint64_t v12 = 0LL;
        uint64_t v23 = v240;
      }

      else
      {
        int v219 = *(_DWORD *)(a6 + 64);
        int v220 = *(_DWORD *)(a6 + 68);
        int v221 = *(_DWORD *)(a6 + 72);
        uint64_t v23 = v240;
        do
        {
          unsigned int v222 = (506832829 * *(_DWORD *)(a3 + (v217 & a4))) >> v219;
          unsigned int v223 = *(unsigned __int16 *)(v252 + 2LL * v222);
          *(_DWORD *)(v240 + 4 * ((v222 << v221) + (unint64_t)(v220 & v223))) = v217;
          *(_WORD *)(v252 + 2LL * v222) = v223 + 1;
          ++v217;
        }

        while (v216 != v217);
        unint64_t v12 = 0LL;
      }

LABEL_297:
      unint64_t v11 = v175;
      if (v175 + 4 >= v13) {
        goto LABEL_304;
      }
    }

    uint64_t v204 = a7[1];
    if (v112 == v204)
    {
      unint64_t v183 = 1LL;
      goto LABEL_236;
    }

    unint64_t v205 = v112 + 3 - v188;
    if (v205 > 6)
    {
      unint64_t v208 = v112 + 3 - v204;
      if (v208 > 6)
      {
        if (v112 == a7[2])
        {
          unint64_t v183 = 2LL;
        }

        else if (v112 == a7[3])
        {
          unint64_t v183 = 3LL;
        }

        else
        {
LABEL_235:
          unint64_t v183 = v112 + 15;
        }

LABEL_236:
        if (v112 <= v242)
        {
          if (v183)
          {
            a7[3] = a7[2];
            int32x2_t v184 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v112;
            int v185 = *(_DWORD *)(a6 + 76);
            if (v185 >= 5)
            {
              int32x4_t v186 = vdupq_n_s32(v112);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v186, (int32x4_t)xmmword_1810CB570);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v186.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v185 >= 0xB)
              {
                int32x4_t v187 = vdupq_lane_s32(v184, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v187, (int32x4_t)xmmword_1810CB570);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v187.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }

        goto LABEL_243;
      }

      char v206 = 4 * v208;
      unsigned int v207 = 266017486;
    }

    else
    {
      char v206 = 4 * v205;
      unsigned int v207 = 158663784;
    }

    unint64_t v183 = (v207 >> v206) & 0xF;
    goto LABEL_236;
  }

  uint64_t v229 = a9;
  unint64_t v175 = a2;
LABEL_304:
  *a8 = v12 + v13 - v175;
  *a10 += (v229 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH6( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v233 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v217 = v13 - 7;
  if (result <= 7) {
    unint64_t v14 = v11;
  }
  else {
    unint64_t v14 = v13 - 7;
  }
  int v15 = *(_DWORD *)(a5 + 8);
  uint64_t v16 = 512LL;
  unint64_t v218 = v14;
  uint64_t v219 = v16;
  int v17 = *(_DWORD *)(a6 + 88);
  if (v17 >= 5)
  {
    int32x4_t v18 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v18, (int32x4_t)xmmword_1810CB570);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v17 >= 0xB)
    {
      unint64_t v19 = (const float *)(a7 + 1);
      int32x4_t v20 = (int32x4_t)vld1q_dup_f32(v19);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v20, (int32x4_t)xmmword_1810CB570);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }

  if (v11 + 8 < v13)
  {
    unint64_t v21 = v219 + v11;
    unint64_t v232 = (1LL << v15) - 16;
    uint64_t v22 = *(void *)(a6 + 104);
    uint64_t v220 = a9;
    uint64_t v244 = a5;
    uint64_t v241 = v22;
    unint64_t v228 = v13;
    unint64_t v234 = *(void *)(a6 + 72);
    unint64_t v235 = *(void *)(a6 + 112);
    while (1)
    {
      unint64_t v242 = v12;
      unint64_t v23 = v13 - v11;
      if (v11 >= v232) {
        unint64_t v24 = v232;
      }
      else {
        unint64_t v24 = v11;
      }
      unint64_t v25 = v11 + v233;
      if (v11 + v233 >= v232) {
        unint64_t v25 = v232;
      }
      unint64_t v239 = v25;
      unint64_t v26 = v11 & a4;
      uint64_t v27 = *(int *)(a6 + 88);
      if ((_DWORD)v27)
      {
        unint64_t result = 0LL;
        unint64_t v28 = 0LL;
        unint64_t v29 = 0LL;
        unint64_t v30 = 0LL;
        unint64_t v31 = 2020LL;
        unint64_t v243 = 2020LL;
        do
        {
          unint64_t v32 = a7[v28];
          unint64_t v33 = v11 - v32;
          BOOL v34 = v24 < v32 || v33 >= v11;
          unint64_t v35 = v33 & a4;
          unint64_t v36 = result + v26;
          BOOL v37 = v34 || v36 > a4;
          unint64_t v38 = v35 + result;
          BOOL v39 = v37 || v38 > a4;
          if (!v39 && *(unsigned __int8 *)(a3 + v36) == *(unsigned __int8 *)(a3 + v38))
          {
            uint64_t v40 = a3 + v35;
            if (v23 < 8)
            {
              unint64_t v45 = 0LL;
              unint64_t v46 = (unsigned __int8 *)(a3 + v26);
LABEL_49:
              if ((v23 & 7) != 0)
              {
                unint64_t v49 = v23 & 7 | v45;
                unint64_t v50 = v23 & 7;
                while (*(unsigned __int8 *)(v40 + v45) == *v46)
                {
                  ++v46;
                  ++v45;
                  if (!--v50)
                  {
                    unint64_t v45 = v49;
                    break;
                  }
                }

                a5 = v244;
                uint64_t v22 = v241;
              }
            }

            else
            {
              uint64_t v41 = 0LL;
              unint64_t v42 = v23 >> 3;
              while (1)
              {
                uint64_t v43 = *(void *)(a3 + v26 + v41);
                uint64_t v44 = *(void *)(v40 + v41);
                if (v43 != v44) {
                  break;
                }
                v41 += 8LL;
                if (!--v42)
                {
                  unint64_t v45 = v23 & 0xFFFFFFFFFFFFFFF8LL;
                  unint64_t v46 = (unsigned __int8 *)(a3 + v26 + (v23 & 0xFFFFFFFFFFFFFFF8LL));
                  goto LABEL_49;
                }
              }

              unint64_t v45 = v41 + (__clz(__rbit64(v44 ^ v43)) >> 3);
            }

            if (v45 > 2 || v28 <= 1 && v45 == 2)
            {
              unint64_t v47 = 135 * v45 + 1935;
              if (v31 < v47)
              {
                if (v28) {
                  v47 -= ((0x1CA10u >> (v28 & 0xE)) & 0xE) + 39;
                }
                unint64_t v48 = v243;
                if (v31 < v47) {
                  unint64_t v48 = v47;
                }
                unint64_t v243 = v48;
                if (v31 < v47)
                {
                  unint64_t v30 = a7[v28];
                  unint64_t v29 = v45;
                  unint64_t result = v45;
                  unint64_t v31 = v47;
                }
              }
            }
          }

          ++v28;
        }

        while (v28 != v27);
      }

      else
      {
        unint64_t v30 = 0LL;
        unint64_t v29 = 0LL;
        unint64_t result = 0LL;
        unint64_t v243 = 2020LL;
        unint64_t v31 = 2020LL;
      }

      unint64_t v238 = *(void *)(a5 + 80);
      unint64_t v51 = (_DWORD *)(a3 + v26);
      unint64_t v52 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + v26) & v234)) >> *(_DWORD *)(a6 + 64);
      uint64_t v53 = *(unsigned int *)(a6 + 80);
      unint64_t v54 = v235 + 4LL * ((_DWORD)v52 << *(_DWORD *)(a6 + 84));
      unint64_t v55 = *(unsigned __int16 *)(v22 + 2LL * v52);
      unint64_t v231 = *(void *)(a6 + 56);
      if (v55 >= v231) {
        unint64_t v56 = v55 - v231;
      }
      else {
        unint64_t v56 = 0LL;
      }
      if (v56 < v55)
      {
        unint64_t v57 = v23 & 7;
        unint64_t v58 = *(unsigned __int16 *)(v22 + 2LL * v52);
        do
        {
          uint64_t v59 = *(unsigned int *)(v54 + 4 * (--v58 & v53));
          unint64_t v60 = v11 - v59;
          if (v11 - v59 > v24) {
            break;
          }
          if (result + v26 <= a4)
          {
            uint64_t v61 = v59 & a4;
            if (v61 + result <= a4
              && *(unsigned __int8 *)(a3 + result + v26) == *(unsigned __int8 *)(a3 + v61 + result))
            {
              unint64_t v62 = v57;
              uint64_t v63 = a3 + v61;
              if (v23 < 8)
              {
                unint64_t v236 = v21;
                unint64_t v68 = 0LL;
                unint64_t v69 = (unsigned __int8 *)(a3 + v26);
LABEL_77:
                if (v62)
                {
                  unint64_t v71 = v62;
                  unint64_t v229 = v62 | v68;
                  while (*(unsigned __int8 *)(v63 + v68) == *v69)
                  {
                    ++v69;
                    ++v68;
                    if (!--v71)
                    {
                      unint64_t v68 = v229;
                      break;
                    }
                  }
                }

                unint64_t v21 = v236;
              }

              else
              {
                uint64_t v64 = 0LL;
                unint64_t v65 = v23 >> 3;
                while (1)
                {
                  uint64_t v66 = *(void *)&v51[v64];
                  uint64_t v67 = *(void *)(v63 + v64 * 4);
                  if (v66 != v67) {
                    break;
                  }
                  v64 += 2LL;
                  if (!--v65)
                  {
                    unint64_t v236 = v21;
                    unint64_t v68 = v23 & 0xFFFFFFFFFFFFFFF8LL;
                    unint64_t v69 = (unsigned __int8 *)v51 + (v23 & 0xFFFFFFFFFFFFFFF8LL);
                    goto LABEL_77;
                  }
                }

                unint64_t v68 = v64 * 4 + (__clz(__rbit64(v67 ^ v66)) >> 3);
              }

              unint64_t v57 = v62;
              if (v68 >= 4)
              {
                unsigned int v70 = __clz(v60) ^ 0x1F;
                if (v31 < 135 * v68 - 30 * v70 + 1920)
                {
                  unint64_t v243 = 135 * v68 - 30 * v70 + 1920;
                  unint64_t v30 = v60;
                  unint64_t v29 = v68;
                  unint64_t result = v68;
                  unint64_t v31 = v243;
                }
              }
            }
          }
        }

        while (v58 > v56);
      }

      *(_DWORD *)(v54 + 4LL * (v53 & v55)) = v11;
      uint64_t v22 = v241;
      *(_WORD *)(v241 + 2LL * v52) = v55 + 1;
      if (v243 == 2020)
      {
        uint64_t v72 = *(void *)(a6 + 96);
        unint64_t v74 = *(void *)(v72 + 8);
        unint64_t v73 = *(void *)(v72 + 16);
        a5 = v244;
        if (v73 < v74 >> 7) {
          goto LABEL_220;
        }
        unint64_t v75 = v30;
        int v230 = 0;
        unint64_t result = ((506832829 * *v51) >> 17) & 0x7FFE;
        uint64_t v76 = *(void *)(v244 + 120);
        char v77 = 1;
        unint64_t v78 = v29;
        unint64_t v243 = 2020LL;
        do
        {
          char v79 = v77;
          *(void *)(v72 + 8) = ++v74;
          unint64_t v80 = *(unsigned __int8 *)(v76 + result);
          if (!*(_BYTE *)(v76 + result) || v23 < v80) {
            goto LABEL_98;
          }
          uint64_t v81 = *(unsigned __int16 *)(*(void *)(v244 + 112) + 2 * result);
          uint64_t v82 = *(void *)(v244 + 88);
          uint64_t v83 = *(unsigned int *)(v82 + 4 * v80 + 32);
          uint64_t v84 = *(void *)(v82 + 168);
          uint64_t v85 = (unsigned __int8 *)(v84 + v83 + v81 * *(unsigned __int8 *)(v76 + result));
          if (v80 < 8)
          {
            unint64_t v29 = 0LL;
LABEL_103:
            unint64_t v92 = v80 & 7;
            if ((v80 & 7) != 0)
            {
              unint64_t v93 = v29;
              v29 |= v92;
              while (*((unsigned __int8 *)v51 + v93) == *v85)
              {
                ++v85;
                ++v93;
                if (!--v92) {
                  goto LABEL_94;
                }
              }

              unint64_t v29 = v93;
            }
          }

          else
          {
            unint64_t v86 = 0LL;
            unint64_t v29 = v80 & 0xF8;
            uint64_t v87 = (unsigned __int8 *)(v84
                                    + v81 * (unint64_t)*(unsigned __int8 *)(v76 + result)
                                    + (*(_BYTE *)(v76 + result) & 0xF8)
                                    + v83);
            while (1)
            {
              uint64_t v88 = *(void *)&v85[v86];
              uint64_t v89 = *(void *)&v51[v86 / 4];
              if (v88 != v89) {
                break;
              }
              v86 += 8LL;
              if (v29 == v86)
              {
                uint64_t v85 = v87;
                goto LABEL_103;
              }
            }

            unint64_t v29 = v86 + (__clz(__rbit64(v89 ^ v88)) >> 3);
          }

LABEL_94:
          if (v29
            && v29 + *(unsigned int *)(v244 + 100) > v80
            && (unint64_t v90 = v239
                    + 1
                    + v81
                    + ((((*(void *)(v244 + 104) >> (6 * (v80 - v29))) & 0x3FLL)
                      + 4 * (v80 - v29)) << *(_BYTE *)(v82 + v80)),
                v90 <= v238)
            && (unint64_t v91 = 135 * v29 - 30 * (__clz(v90) ^ 0x1F) + 1920, v91 >= v243))
          {
            int v230 = v80 - v29;
            *(void *)(v72 + 16) = ++v73;
            unint64_t v243 = v91;
          }

          else
          {
LABEL_98:
            unint64_t v90 = v75;
            unint64_t v29 = v78;
          }

          char v77 = 0;
          ++result;
          unint64_t v78 = v29;
          unint64_t v75 = v90;
        }

        while ((v79 & 1) != 0);
      }

      else
      {
        int v230 = 0;
        a5 = v244;
        unint64_t v90 = v30;
      }

      if (v243 < 0x7E5)
      {
LABEL_220:
        unint64_t v12 = v242 + 1;
        unint64_t v167 = v11 + 1;
        if (v11 + 1 > v21)
        {
          unint64_t v13 = v228;
          unint64_t result = v235;
          if (v167 <= v21 + 4 * v219)
          {
            unint64_t v175 = v217;
            if (v11 + 9 < v217) {
              unint64_t v175 = v11 + 9;
            }
            if (v167 < v175)
            {
              int v176 = *(_DWORD *)(a6 + 64);
              int v177 = *(_DWORD *)(a6 + 80);
              int v178 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v179 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v167 & a4)) & v234)) >> v176;
                unsigned int v180 = *(unsigned __int16 *)(v241 + 2LL * v179);
                *(_WORD *)(v241 + 2LL * v179) = v180 + 1;
                *(_DWORD *)(v235 + 4 * (((_DWORD)v179 << v178) + (unint64_t)(v177 & v180))) = v167;
                v12 += 2LL;
                v167 += 2LL;
              }

              while (v167 < v175);
            }
          }

          else
          {
            unint64_t v168 = v217;
            if (v11 + 17 < v217) {
              unint64_t v168 = v11 + 17;
            }
            if (v167 < v168)
            {
              int v169 = *(_DWORD *)(a6 + 64);
              int v170 = *(_DWORD *)(a6 + 80);
              int v171 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v172 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v167 & a4)) & v234)) >> v169;
                unsigned int v173 = *(unsigned __int16 *)(v241 + 2LL * v172);
                *(_WORD *)(v241 + 2LL * v172) = v173 + 1;
                *(_DWORD *)(v235 + 4 * (((_DWORD)v172 << v171) + (unint64_t)(v170 & v173))) = v167;
                v12 += 4LL;
                v167 += 4LL;
              }

              while (v167 < v168);
            }
          }

          goto LABEL_295;
        }

        goto LABEL_294;
      }

      unsigned int v94 = 0;
      int v225 = *(_DWORD *)(a6 + 64);
      int v224 = *(_DWORD *)(a6 + 84);
      uint64_t v95 = *(unsigned int *)(a6 + 80);
      unsigned int v226 = *(_DWORD *)(a6 + 88);
      if (v226 <= 1) {
        int v96 = 1;
      }
      else {
        int v96 = *(_DWORD *)(a6 + 88);
      }
      uint64_t v97 = v96;
      while (1)
      {
        unsigned int v240 = v94;
        unint64_t v222 = v90;
        unint64_t v223 = v29;
        --v23;
        unint64_t v98 = v29 - 1;
        if (v29 - 1 >= v23) {
          unint64_t v98 = v23;
        }
        else {
          unint64_t v99 = v98;
        }
        unint64_t v100 = v11 + 1;
        if (v11 + 1 < v232) {
          unint64_t v101 = v11 + 1;
        }
        else {
          unint64_t v101 = v232;
        }
        unint64_t v102 = v100 + v233;
        if (v100 + v233 >= v232) {
          unint64_t v102 = v232;
        }
        unint64_t v237 = v102;
        unint64_t v103 = v100 & a4;
        if (v226)
        {
          unint64_t v104 = 0LL;
          unint64_t v105 = 0LL;
          unint64_t v106 = 0LL;
          uint64_t v107 = a3 + v103;
          unint64_t v108 = 2020LL;
          unint64_t v109 = 2020LL;
          do
          {
            unint64_t v110 = a7[v104];
            unint64_t v111 = v100 - v110;
            BOOL v112 = v101 < v110 || v111 >= v100;
            uint64_t v113 = v111 & a4;
            unint64_t v114 = v99 + v103;
            BOOL v115 = v112 || v114 > a4;
            unint64_t v116 = v113 + v99;
            BOOL v117 = v115 || v116 > a4;
            if (!v117 && *(unsigned __int8 *)(a3 + v114) == *(unsigned __int8 *)(a3 + v116))
            {
              uint64_t v118 = a3 + v113;
              if (v23 < 8)
              {
                unint64_t v119 = 0LL;
                BOOL v123 = (unsigned __int8 *)(a3 + v103);
LABEL_157:
                if ((v23 & 7) != 0)
                {
                  unint64_t v125 = v23 & 7;
                  do
                  {
                    ++v123;
                    ++v119;
                    --v125;
                  }

                  while (v125);
                }
              }

              else
              {
                unint64_t v119 = 0LL;
                unint64_t v120 = v23 >> 3;
                while (1)
                {
                  uint64_t v121 = *(void *)(v107 + v119);
                  uint64_t v122 = *(void *)(v118 + v119);
                  if (v121 != v122) {
                    break;
                  }
                  v119 += 8LL;
                  if (!--v120)
                  {
                    BOOL v123 = (unsigned __int8 *)(v107 + v119);
                    goto LABEL_157;
                  }
                }

                v119 += __clz(__rbit64(v122 ^ v121)) >> 3;
              }

              if (v119 > 2 || v104 <= 1 && v119 == 2)
              {
                unint64_t v124 = 135 * v119 + 1935;
                if (v108 < v124)
                {
                  if (v104) {
                    v124 -= ((0x1CA10u >> (v104 & 0xE)) & 0xE) + 39;
                  }
                  if (v108 < v124)
                  {
                    unint64_t v109 = v124;
                    unint64_t v106 = a7[v104];
                    unint64_t v105 = v119;
                    unint64_t v99 = v119;
                    unint64_t v108 = v124;
                  }
                }
              }
            }

            ++v104;
          }

          while (v104 != v97);
        }

        else
        {
          unint64_t v106 = 0LL;
          unint64_t v105 = 0LL;
          unint64_t v109 = 2020LL;
          unint64_t v108 = 2020LL;
        }

        unint64_t v126 = (_DWORD *)(a3 + v103);
        unint64_t v127 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + v103) & v234)) >> v225;
        unint64_t v128 = v235 + 4LL * ((_DWORD)v127 << v224);
        unint64_t v129 = *(unsigned __int16 *)(v241 + 2LL * v127);
        if (v129 >= v231) {
          unint64_t v130 = v129 - v231;
        }
        else {
          unint64_t v130 = 0LL;
        }
        if (v130 < v129)
        {
          unint64_t v131 = *(unsigned __int16 *)(v241 + 2LL * v127);
          do
          {
            uint64_t v132 = *(unsigned int *)(v128 + 4 * (--v131 & v95));
            unint64_t v133 = v100 - v132;
            if (v100 - v132 > v101) {
              break;
            }
            if (v99 + v103 <= a4)
            {
              uint64_t v134 = v132 & a4;
              if (v134 + v99 <= a4 && *(unsigned __int8 *)(a3 + v99 + v103) == *(unsigned __int8 *)(a3 + v134 + v99))
              {
                uint64_t v135 = a3 + v134;
                if (v23 < 8)
                {
                  unint64_t v136 = 0LL;
                  uint64_t v140 = (unsigned __int8 *)(a3 + v103);
LABEL_184:
                  if ((v23 & 7) != 0)
                  {
                    unint64_t v142 = v23 & 7;
                    do
                    {
                      unint64_t v216 = v142;
                      ++v140;
                      ++v136;
                      --v142;
                    }

                    while (v216 != 1);
                  }
                }

                else
                {
                  unint64_t v136 = 0LL;
                  unint64_t v137 = v23 >> 3;
                  while (1)
                  {
                    uint64_t v138 = *(void *)((char *)v126 + v136);
                    uint64_t v139 = *(void *)(v135 + v136);
                    if (v138 != v139) {
                      break;
                    }
                    v136 += 8LL;
                    if (!--v137)
                    {
                      uint64_t v140 = (unsigned __int8 *)v126 + v136;
                      goto LABEL_184;
                    }
                  }

                  v136 += __clz(__rbit64(v139 ^ v138)) >> 3;
                }

                if (v136 >= 4)
                {
                  unsigned int v141 = __clz(v133) ^ 0x1F;
                  if (v108 < 135 * v136 - 30 * v141 + 1920)
                  {
                    unint64_t v109 = 135 * v136 - 30 * v141 + 1920;
                    unint64_t v106 = v133;
                    unint64_t v105 = v136;
                    unint64_t v99 = v136;
                    unint64_t v108 = v109;
                  }
                }
              }
            }
          }

          while (v131 > v130);
        }

        *(_DWORD *)(v128 + 4LL * (v95 & v129)) = v100;
        *(_WORD *)(v241 + 2LL * v127) = v129 + 1;
        if (v109 == 2020)
        {
          uint64_t v143 = *(void *)(a6 + 96);
          unint64_t v144 = *(void *)(v143 + 8);
          if (*(void *)(v143 + 16) >= v144 >> 7)
          {
            uint64_t v221 = *(void *)(v143 + 16);
            int v145 = 0;
            uint64_t v148 = ((506832829 * *v126) >> 17) & 0x7FFE;
            uint64_t v149 = *(void *)(v244 + 120);
            char v150 = 1;
            unint64_t v151 = v105;
            unint64_t v152 = v106;
            unint64_t v109 = 2020LL;
            do
            {
              char v153 = v150;
              *(void *)(v143 + 8) = ++v144;
              unint64_t v154 = *(unsigned __int8 *)(v149 + v148);
              if (!*(_BYTE *)(v149 + v148) || v23 < v154) {
                goto LABEL_210;
              }
              uint64_t v155 = *(unsigned __int16 *)(*(void *)(v244 + 112) + 2 * v148);
              uint64_t v156 = *(void *)(v244 + 88);
              uint64_t v157 = *(unsigned int *)(v156 + 4 * v154 + 32);
              uint64_t v158 = *(void *)(v156 + 168);
              unint64_t v159 = (unsigned __int8 *)(v158 + v157 + v155 * *(unsigned __int8 *)(v149 + v148));
              if (v154 < 8)
              {
                unint64_t v105 = 0LL;
LABEL_215:
                unint64_t v165 = v154 & 7;
                if ((v154 & 7) != 0)
                {
                  unint64_t v166 = v105 | v165;
                  while (*((unsigned __int8 *)v126 + v105) == *v159)
                  {
                    ++v159;
                    ++v105;
                    if (!--v165)
                    {
                      unint64_t v105 = v166;
                      break;
                    }
                  }
                }
              }

              else
              {
                unint64_t v160 = 0LL;
                unint64_t v105 = v154 & 0xF8;
                char v161 = (unsigned __int8 *)(v158
                                         + v155 * (unint64_t)*(unsigned __int8 *)(v149 + v148)
                                         + (*(_BYTE *)(v149 + v148) & 0xF8)
                                         + v157);
                while (1)
                {
                  uint64_t v162 = *(void *)&v159[v160];
                  uint64_t v163 = *(void *)&v126[v160 / 4];
                  if (v162 != v163) {
                    break;
                  }
                  v160 += 8LL;
                  if (v105 == v160)
                  {
                    unint64_t v159 = v161;
                    goto LABEL_215;
                  }
                }

                unint64_t v105 = v160 + (__clz(__rbit64(v163 ^ v162)) >> 3);
              }

              if (v105
                && v105 + *(unsigned int *)(v244 + 100) > v154
                && (unint64_t v106 = v237
                         + 1
                         + v155
                         + ((((*(void *)(v244 + 104) >> (6 * (v154 - v105))) & 0x3FLL)
                           + 4 * (v154 - v105)) << *(_BYTE *)(v156 + v154)),
                    v106 <= v238)
                && (unint64_t v164 = 135 * v105 - 30 * (__clz(v106) ^ 0x1F) + 1920, v164 >= v109))
              {
                int v145 = v154 - v105;
                *(void *)(v143 + 16) = ++v221;
                unint64_t v109 = v164;
              }

              else
              {
LABEL_210:
                unint64_t v106 = v152;
                unint64_t v105 = v151;
              }

              char v150 = 0;
              ++v148;
              unint64_t v151 = v105;
              unint64_t v152 = v106;
            }

            while ((v153 & 1) != 0);
          }

          else
          {
            int v145 = 0;
            unint64_t v109 = 2020LL;
          }
        }

        else
        {
          int v145 = 0;
        }

        if (v109 < v243 + 175) {
          break;
        }
        ++v242;
        if (v240 > 2)
        {
          a5 = v244;
          int v147 = v145;
          goto LABEL_238;
        }

        unint64_t v146 = v11 + 9;
        unsigned int v94 = v240 + 1;
        unint64_t v243 = v109;
        unint64_t v90 = v106;
        unint64_t v29 = v105;
        int v147 = v145;
        int v230 = v145;
        ++v11;
        a5 = v244;
        if (v146 >= v228) {
          goto LABEL_238;
        }
      }

      unint64_t v174 = v11 + v233;
      if (v11 + v233 >= v232) {
        unint64_t v174 = v232;
      }
      unint64_t v237 = v174;
      unint64_t v106 = v222;
      unint64_t v105 = v223;
      int v147 = v230;
      unint64_t v100 = v11;
      a5 = v244;
LABEL_238:
      unint64_t result = v235;
      uint64_t v22 = v241;
      if (v106 > v237) {
        goto LABEL_239;
      }
      uint64_t v186 = *a7;
      if (v106 != v186) {
        break;
      }
      unint64_t v181 = 0LL;
LABEL_247:
      *(_DWORD *)uint64_t v220 = v242;
      *(_DWORD *)(v220 + 4) = v105 | (v147 << 25);
      uint64_t v187 = *(unsigned int *)(a5 + 68);
      uint64_t v188 = v187 + 16;
      if (v187 + 16 <= v181)
      {
        uint64_t v190 = *(unsigned int *)(a5 + 64);
        unint64_t v191 = v181 - v187 + (4LL << v190) - 16;
        uint64_t v192 = (__clz(v191) ^ 0x1F) - 1;
        uint64_t v193 = ((v191 >> v192) & 1 | 2) << v192;
        unint64_t v181 = ((v191 & ~(-1 << v190))
              + v188
              + ((((v191 >> v192) & 1 | (2 * (v192 - v190))) + 65534) << v190)) | ((v192 - v190) << 10);
        unint64_t v189 = (v191 - v193) >> v190;
      }

      else
      {
        LODWORD(v189) = 0;
      }

      *(_WORD *)(v220 + 14) = v181;
      *(_DWORD *)(v220 + 8) = v189;
      if (v242 > 5)
      {
        if (v242 > 0x81)
        {
          if (v242 > 0x841)
          {
            if (v242 >> 1 >= 0xC21)
            {
              if (v242 < 0x5842) {
                LOWORD(v194) = 22;
              }
              else {
                LOWORD(v194) = 23;
              }
            }

            else
            {
              LOWORD(v194) = 21;
            }
          }

          else
          {
            unsigned int v194 = (__clz(v242 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v195 = (__clz(v242 - 2) ^ 0x1F) - 1;
          unsigned int v194 = ((v242 - 2) >> v195) + 2 * v195 + 2;
        }
      }

      else
      {
        LOWORD(v194) = v242;
      }

      uint64_t v201 = v147 + (int)v105;
      if (v201 > 9)
      {
        if (v201 > 0x85)
        {
          else {
            unsigned int v202 = (__clz(v201 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v203 = v201 - 6;
          unsigned int v204 = (__clz(v203) ^ 0x1F) - 1;
          unsigned int v202 = (v203 >> v204) + 2 * v204 + 4;
        }
      }

      else
      {
        LOWORD(v202) = v147 + v105 - 2;
      }

      int v205 = v202 & 7 | (8 * (v194 & 7));
      if ((v181 & 0x3FF) != 0 || (unsigned __int16)v194 > 7u || (unsigned __int16)v202 > 0xFu)
      {
        int v207 = 3 * ((unsigned __int16)v194 >> 3) + ((unsigned __int16)(v202 & 0xFFF8) >> 3);
        unsigned int v206 = ((((0x520D40u >> (2 * v207)) & 0xC0) + (v207 << 6)) | v205) + 64;
      }

      else
      {
        LOWORD(v206) = v205 | 0x40;
        if ((v202 & 0xFFF8) == 0) {
          LOWORD(v206) = v202 & 7 | (8 * (v194 & 7));
        }
      }

      *(_WORD *)(v220 + 12) = v206;
      unint64_t v208 = v218;
      *a11 += v242;
      unint64_t v209 = v100 + 2;
      unint64_t v167 = v100 + v105;
      if (v100 + v105 < v218) {
        unint64_t v208 = v100 + v105;
      }
      if (v106 < v105 >> 2)
      {
        if (v209 <= v167 - 4 * v106) {
          unint64_t v209 = v167 - 4 * v106;
        }
        if (v208 < v209) {
          unint64_t v209 = v208;
        }
      }

      unint64_t v21 = v219 + 2 * v105 + v100;
      v220 += 16LL;
      if (v209 < v208)
      {
        unint64_t v13 = v228;
        int v210 = *(_DWORD *)(a6 + 64);
        int v211 = *(_DWORD *)(a6 + 80);
        int v212 = *(_DWORD *)(a6 + 84);
        do
        {
          unint64_t v213 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v209 & a4)) & v234)) >> v210;
          unsigned int v214 = *(unsigned __int16 *)(v241 + 2LL * v213);
          *(_WORD *)(v241 + 2LL * v213) = v214 + 1;
          *(_DWORD *)(v235 + 4 * (((_DWORD)v213 << v212) + (unint64_t)(v211 & v214))) = v209++;
        }

        while (v208 != v209);
        unint64_t v12 = 0LL;
        goto LABEL_295;
      }

      unint64_t v12 = 0LL;
LABEL_294:
      unint64_t v13 = v228;
LABEL_295:
      unint64_t v11 = v167;
      if (v167 + 8 >= v13) {
        goto LABEL_302;
      }
    }

    uint64_t v196 = a7[1];
    if (v106 == v196)
    {
      unint64_t v181 = 1LL;
      goto LABEL_240;
    }

    unint64_t v197 = v106 + 3 - v186;
    if (v197 > 6)
    {
      unint64_t v200 = v106 + 3 - v196;
      if (v200 > 6)
      {
        if (v106 == a7[2])
        {
          unint64_t v181 = 2LL;
        }

        else if (v106 == a7[3])
        {
          unint64_t v181 = 3LL;
        }

        else
        {
LABEL_239:
          unint64_t v181 = v106 + 15;
        }

LABEL_240:
        if (v106 <= v237)
        {
          if (v181)
          {
            a7[3] = a7[2];
            int32x2_t v182 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v106;
            int v183 = *(_DWORD *)(a6 + 88);
            if (v183 >= 5)
            {
              int32x4_t v184 = vdupq_n_s32(v106);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v184, (int32x4_t)xmmword_1810CB570);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v184.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v183 >= 0xB)
              {
                int32x4_t v185 = vdupq_lane_s32(v182, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v185, (int32x4_t)xmmword_1810CB570);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v185.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }

        goto LABEL_247;
      }

      char v198 = 4 * v200;
      unsigned int v199 = 266017486;
    }

    else
    {
      char v198 = 4 * v197;
      unsigned int v199 = 158663784;
    }

    unint64_t v181 = (v199 >> v198) & 0xF;
    goto LABEL_240;
  }

  uint64_t v220 = a9;
  unint64_t v167 = v11;
LABEL_302:
  *a8 = v12 + v13 - v167;
  *a10 += (v220 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH40( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  uint64_t v11 = a9;
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 3;
  unint64_t v220 = v14;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  unint64_t v223 = v14;
  uint64_t v15 = 64LL;
  if (a2 + 4 < v13)
  {
    unint64_t v16 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v222 = v15;
    unint64_t v17 = v15 + a2;
    uint64_t v229 = a5;
    uint64_t v230 = *(void *)(a5 + 16);
    uint64_t v221 = 4 * v15;
    unint64_t v219 = v13 - 4;
    uint64_t v18 = a9;
    unint64_t v226 = a2 + result;
    uint64_t v245 = a3;
    unint64_t v228 = v16;
    while (1)
    {
      unint64_t v237 = v17;
      unint64_t v242 = v12;
      unint64_t v243 = 0LL;
      uint64_t v224 = v18;
      unint64_t v19 = 0LL;
      uint64_t v20 = 0LL;
      unint64_t v21 = 0LL;
      unint64_t v22 = v13 - a2;
      if (a2 >= v16) {
        unint64_t v23 = v16;
      }
      else {
        unint64_t v23 = a2;
      }
      unint64_t v240 = *(void *)(a5 + 80);
      uint64_t v24 = *(void *)(a6 + 64);
      uint64_t v25 = v24 + 196608;
      unint64_t v26 = a2 & a4;
      uint64_t v27 = (unsigned __int8 *)(a3 + (a2 & a4));
      uint64_t v28 = (506832829 * *(_DWORD *)v27) >> 17;
      unint64_t v29 = 2020LL;
      uint64_t v30 = 2020LL;
      do
      {
        unint64_t v31 = a7[v20];
        unint64_t result = a2 - v31;
        if ((!v20 || *(unsigned __int8 *)(v25 + (unsigned __int16)(a2 - v31)) == v28)
          && v23 >= v31
          && result < a2)
        {
          uint64_t v33 = a3 + (result & a4);
          if (v22 < 8)
          {
            unint64_t v37 = 0LL;
            unint64_t v38 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_36:
            if ((v22 & 7) != 0)
            {
              unint64_t v41 = v22 & 7 | v37;
              unint64_t v42 = v22 & 7;
              while (1)
              {
                unint64_t result = *v38;
                ++v38;
                ++v37;
                if (!--v42)
                {
                  unint64_t v37 = v41;
                  break;
                }
              }
            }
          }

          else
          {
            unint64_t result = 0LL;
            unint64_t v34 = v22 >> 3;
            while (1)
            {
              uint64_t v35 = *(void *)&v27[result];
              uint64_t v36 = *(void *)(v33 + result);
              if (v35 != v36) {
                break;
              }
              result += 8LL;
              if (!--v34)
              {
                unint64_t v38 = &v27[v22 & 0xFFFFFFFFFFFFFFF8LL];
                unint64_t v37 = v22 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_36;
              }
            }

            unint64_t v37 = result + (__clz(__rbit64(v36 ^ v35)) >> 3);
          }

          if (v37 >= 2)
          {
            unint64_t v39 = 135 * v37 + 1935;
            if (v29 < v39)
            {
              unint64_t v40 = v39 - (((0x1CA10u >> (v20 & 0xE)) & 0xE) + 39);
              if (!v20) {
                unint64_t v40 = 135 * v37 + 1935;
              }
              if (v29 < v40) {
                uint64_t v30 = v40;
              }
              unint64_t result = v243;
              if (v29 < v40) {
                unint64_t result = a7[v20];
              }
              unint64_t v243 = result;
              if (v29 < v40)
              {
                unint64_t v21 = v37;
                unint64_t v19 = v37;
                unint64_t v29 = v40;
              }
            }
          }
        }

        ++v20;
      }

      while (v20 != 4);
      unint64_t v43 = v21;
      if (a2 + v230 >= v16) {
        unint64_t v44 = v16;
      }
      else {
        unint64_t v44 = a2 + v230;
      }
      unint64_t v235 = v44;
      uint64_t v45 = v24 + 0x40000;
      uint64_t v46 = a6;
      uint64_t v47 = *(void *)(a6 + 56);
      unint64_t v48 = a2;
      unint64_t v49 = a2 - *(unsigned int *)(v24 + 4LL * v28);
      uint64_t v50 = *(unsigned __int16 *)(v24 + 0x20000 + 2LL * v28);
      __int16 v238 = *(_WORD *)(v24 + 0x20000 + 2LL * v28);
      if (v47)
      {
        unint64_t v51 = 0LL;
        unint64_t v52 = v49;
        unint64_t v53 = v22 & 7;
        do
        {
          v51 += v52;
          if (v51 > v23) {
            break;
          }
          if (v19 + v26 <= a4)
          {
            unint64_t v54 = (v48 - v51) & a4;
            if (v54 + v19 <= a4)
            {
              unint64_t result = *(unsigned __int8 *)(v245 + v54 + v19);
              if (*(unsigned __int8 *)(v245 + v19 + v26) == (_DWORD)result)
              {
                uint64_t v55 = v245 + v54;
                if (v22 < 8)
                {
                  unint64_t v61 = 0LL;
                  unint64_t v60 = v27;
LABEL_80:
                  uint64_t v46 = a6;
                  if (v53)
                  {
                    unint64_t v231 = v53 | v61;
                    unint64_t v69 = v53;
                    while (*(unsigned __int8 *)(v55 + v61) == *v60)
                    {
                      ++v60;
                      ++v61;
                      if (!--v69)
                      {
                        unint64_t v61 = v231;
                        break;
                      }
                    }
                  }
                }

                else
                {
                  uint64_t v56 = 0LL;
                  unint64_t v57 = v22 >> 3;
                  uint64_t v46 = a6;
                  while (1)
                  {
                    uint64_t v58 = *(void *)&v27[v56];
                    uint64_t v59 = *(void *)(v55 + v56);
                    if (v58 != v59) {
                      break;
                    }
                    v56 += 8LL;
                    if (!--v57)
                    {
                      unint64_t v60 = &v27[v22 & 0xFFFFFFFFFFFFFFF8LL];
                      unint64_t v61 = v22 & 0xFFFFFFFFFFFFFFF8LL;
                      goto LABEL_80;
                    }
                  }

                  unint64_t v61 = v56 + (__clz(__rbit64(v59 ^ v58)) >> 3);
                }

                uint64_t v62 = 30 * (__clz(v51) ^ 0x1F);
                unint64_t v63 = 135 * v61 - v62 + 1920;
                if (v29 < v63) {
                  unint64_t result = 135 * v61 - v62 + 1920;
                }
                else {
                  unint64_t result = v30;
                }
                unint64_t v64 = v243;
                if (v29 < v63) {
                  unint64_t v65 = v51;
                }
                else {
                  unint64_t v65 = v243;
                }
                if (v29 < v63) {
                  unint64_t v66 = v61;
                }
                else {
                  unint64_t v66 = v43;
                }
                if (v29 < v63) {
                  unint64_t v67 = v61;
                }
                else {
                  unint64_t v67 = v19;
                }
                if (v29 >= v63) {
                  unint64_t v63 = v29;
                }
                if (v61 >= 4)
                {
                  uint64_t v30 = result;
                  unint64_t v64 = v65;
                }

                unint64_t v243 = v64;
                if (v61 >= 4)
                {
                  unint64_t v43 = v66;
                  unint64_t v19 = v67;
                  unint64_t v29 = v63;
                }

                unint64_t v53 = v22 & 7;
              }

              else
              {
                uint64_t v46 = a6;
              }
            }
          }

          unint64_t v68 = (unsigned __int16 *)(v45 + 4 * v50);
          uint64_t v50 = v68[1];
          unint64_t v52 = *v68;
          --v47;
        }

        while (v47);
      }

      uint64_t v70 = *(unsigned __int16 *)(v46 + 48);
      *(_WORD *)(v46 + 48) = v70 + 1;
      *(_BYTE *)(v25 + (unsigned __int16)v48) = v28;
      __int16 v71 = -1;
      if (v49 < 0xFFFF) {
        __int16 v71 = v49;
      }
      uint64_t v72 = (__int16 *)(v45 + 4 * v70);
      *uint64_t v72 = v71;
      v72[1] = v238;
      *(_DWORD *)(v24 + 4 * v28) = v48;
      *(_WORD *)(v24 + 0x20000 + 2 * v28) = v70;
      if (v30 == 2020)
      {
        uint64_t v73 = *(void *)(v46 + 72);
        unint64_t v75 = *(void *)(v73 + 8);
        unint64_t v74 = *(void *)(v73 + 16);
        unint64_t v16 = v228;
        a5 = v229;
        unint64_t v76 = v243;
        a3 = v245;
        if (v74 < v75 >> 7) {
          goto LABEL_222;
        }
        int v227 = 0;
        uint64_t v77 = ((506832829 * *(_DWORD *)v27) >> 17) & 0x7FFE;
        uint64_t v78 = *(void *)(v229 + 120);
        char v79 = 1;
        unint64_t result = v43;
        unint64_t v80 = 2020LL;
        do
        {
          char v81 = v79;
          *(void *)(v73 + 8) = ++v75;
          unint64_t v82 = *(unsigned __int8 *)(v78 + v77);
          if (!*(_BYTE *)(v78 + v77) || v22 < v82) {
            goto LABEL_102;
          }
          uint64_t v83 = *(unsigned __int16 *)(*(void *)(v229 + 112) + 2 * v77);
          uint64_t v84 = *(void *)(v229 + 88);
          uint64_t v85 = *(unsigned int *)(v84 + 4 * v82 + 32);
          uint64_t v86 = *(void *)(v84 + 168);
          uint64_t v87 = (unsigned __int8 *)(v86 + v85 + v83 * *(unsigned __int8 *)(v78 + v77));
          if (v82 < 8)
          {
            unint64_t v43 = 0LL;
LABEL_107:
            unint64_t v96 = v82 & 7;
            if ((v82 & 7) != 0)
            {
              unint64_t v97 = v43 | v96;
              while (v27[v43] == *v87)
              {
                ++v87;
                ++v43;
                if (!--v96)
                {
                  unint64_t v43 = v97;
                  break;
                }
              }
            }
          }

          else
          {
            unint64_t v88 = 0LL;
            unint64_t v43 = v82 & 0xF8;
            uint64_t v89 = (unsigned __int8 *)(v86
                                    + v83 * (unint64_t)*(unsigned __int8 *)(v78 + v77)
                                    + (*(_BYTE *)(v78 + v77) & 0xF8)
                                    + v85);
            while (1)
            {
              uint64_t v90 = *(void *)&v87[v88];
              uint64_t v91 = *(void *)&v27[v88];
              if (v90 != v91) {
                break;
              }
              v88 += 8LL;
              if (v43 == v88)
              {
                uint64_t v87 = v89;
                goto LABEL_107;
              }
            }

            unint64_t v43 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
          }

          if (v43
            && v43 + *(unsigned int *)(v229 + 100) > v82
            && (unint64_t v92 = v235
                    + 1
                    + v83
                    + ((((*(void *)(v229 + 104) >> (6 * (v82 - v43))) & 0x3FLL)
                      + 4 * (v82 - v43)) << *(_BYTE *)(v84 + v82)),
                v92 <= v240)
            && (unint64_t v93 = v92, v94 = 135 * v43 - 30 * (__clz(v92) ^ 0x1F) + 1920, v94 >= v80))
          {
            int v227 = v82 - v43;
            *(void *)(v73 + 16) = ++v74;
            unint64_t v80 = v94;
            unint64_t v95 = v93;
          }

          else
          {
LABEL_102:
            unint64_t v95 = v76;
            unint64_t v43 = result;
          }

          char v79 = 0;
          ++v77;
          unint64_t result = v43;
          unint64_t v76 = v95;
        }

        while ((v81 & 1) != 0);
      }

      else
      {
        unint64_t v80 = v30;
        int v227 = 0;
        unint64_t v16 = v228;
        a5 = v229;
        unint64_t v95 = v243;
        a3 = v245;
      }

      if (v80 >= 0x7E5)
      {
        unint64_t v239 = v80;
        unsigned int v98 = 0;
        unint64_t result = *(unsigned __int16 *)(a6 + 48);
        while (1)
        {
          unsigned int v233 = v98;
          unint64_t v244 = v95;
          uint64_t v99 = 0LL;
          unint64_t v100 = 0LL;
          unint64_t v101 = 0LL;
          --v22;
          unint64_t v225 = v43;
          unint64_t v102 = v43 - 1;
          if (v43 - 1 >= v22) {
            unint64_t v102 = v22;
          }
          unint64_t v103 = *(int *)(a5 + 4) >= 5 ? 0LL : v102;
          unint64_t v104 = v48 + 1;
          unint64_t v234 = v48;
          unint64_t v105 = v48 + 1 < v16 ? v48 + 1 : v16;
          unint64_t v241 = *(void *)(a5 + 80);
          uint64_t v106 = *(void *)(a6 + 64);
          uint64_t v107 = v106 + 196608;
          uint64_t v108 = v104 & a4;
          unint64_t v109 = (unsigned __int8 *)(a3 + (v104 & a4));
          uint64_t v110 = (506832829 * *(_DWORD *)v109) >> 17;
          unint64_t v111 = 2020LL;
          unint64_t v112 = 2020LL;
          do
          {
            unint64_t v113 = a7[v99];
            unint64_t v114 = v104 - v113;
            if ((!v99 || *(unsigned __int8 *)(v107 + (unsigned __int16)(v104 - v113)) == v110)
              && v105 >= v113
              && v114 < v104)
            {
              uint64_t v116 = a3 + (v114 & a4);
              if (v22 < 8)
              {
                unint64_t v117 = 0LL;
                uint64_t v121 = (unsigned __int8 *)(a3 + (v104 & a4));
LABEL_145:
                unint64_t v124 = v22 & 7;
                if ((v22 & 7) != 0)
                {
                  do
                  {
                    ++v121;
                    ++v117;
                    --v124;
                  }

                  while (v124);
                }
              }

              else
              {
                unint64_t v117 = 0LL;
                unint64_t v118 = v22 >> 3;
                while (1)
                {
                  uint64_t v119 = *(void *)&v109[v117];
                  uint64_t v120 = *(void *)(v116 + v117);
                  if (v119 != v120) {
                    break;
                  }
                  v117 += 8LL;
                  if (!--v118)
                  {
                    uint64_t v121 = &v109[v117];
                    goto LABEL_145;
                  }
                }

                v117 += __clz(__rbit64(v120 ^ v119)) >> 3;
              }

              if (v117 >= 2)
              {
                unint64_t v122 = 135 * v117 + 1935;
                if (v111 < v122)
                {
                  unint64_t v123 = v122 - (((0x1CA10u >> (v99 & 0xE)) & 0xE) + 39);
                  if (!v99) {
                    unint64_t v123 = 135 * v117 + 1935;
                  }
                  if (v111 < v123)
                  {
                    unint64_t v112 = v123;
                    unint64_t v101 = a7[v99];
                    unint64_t v100 = v117;
                    unint64_t v103 = v117;
                    unint64_t v111 = v123;
                  }
                }
              }
            }

            ++v99;
          }

          while (v99 != 4);
          if (v104 + v230 >= v16) {
            unint64_t v125 = v16;
          }
          else {
            unint64_t v125 = v104 + v230;
          }
          unint64_t v232 = v125;
          uint64_t v126 = v106 + 0x40000;
          uint64_t v127 = a6;
          uint64_t v128 = *(void *)(a6 + 56);
          uint64_t v129 = *(unsigned int *)(v106 + 4LL * v110);
          unint64_t v130 = v104 - v129;
          uint64_t v131 = *(unsigned __int16 *)(v106 + 0x20000 + 2LL * v110);
          __int16 v236 = *(_WORD *)(v106 + 0x20000 + 2LL * v110);
          if (v128)
          {
            unint64_t v132 = 0LL;
            uint64_t v133 = v104 - v129;
            do
            {
              v132 += v133;
              if (v132 > v105) {
                break;
              }
              if (v103 + v108 <= a4)
              {
                unint64_t v134 = (v104 - v132) & a4;
                if (v134 + v103 <= a4
                  && *(unsigned __int8 *)(v245 + v103 + v108) == *(unsigned __int8 *)(v245 + v134 + v103))
                {
                  uint64_t v135 = v245 + v134;
                  if (v22 < 8)
                  {
                    unint64_t v136 = 0LL;
                    unsigned int v141 = v109;
                    unint64_t v138 = v22 & 7;
LABEL_185:
                    while (v138)
                    {
                      ++v141;
                      ++v136;
                      --v138;
                    }
                  }

                  else
                  {
                    unint64_t v136 = 0LL;
                    unint64_t v137 = v22 >> 3;
                    unint64_t v138 = v22 & 7;
                    while (1)
                    {
                      uint64_t v139 = *(void *)&v109[v136];
                      uint64_t v140 = *(void *)(v135 + v136);
                      if (v139 != v140) {
                        break;
                      }
                      v136 += 8LL;
                      if (!--v137)
                      {
                        unsigned int v141 = &v109[v136];
                        goto LABEL_185;
                      }
                    }

                    v136 += __clz(__rbit64(v140 ^ v139)) >> 3;
                  }

                  uint64_t v142 = 30 * (__clz(v132) ^ 0x1F);
                  unint64_t v143 = 135 * v136 - v142 + 1920;
                  if (v111 < v143) {
                    uint64_t v144 = 135 * v136 - v142 + 1920;
                  }
                  else {
                    uint64_t v144 = v112;
                  }
                  if (v111 < v143) {
                    unint64_t v145 = v132;
                  }
                  else {
                    unint64_t v145 = v101;
                  }
                  if (v111 < v143) {
                    unint64_t v146 = v136;
                  }
                  else {
                    unint64_t v146 = v100;
                  }
                  if (v111 < v143) {
                    unint64_t v147 = v136;
                  }
                  else {
                    unint64_t v147 = v103;
                  }
                  if (v111 >= v143) {
                    unint64_t v143 = v111;
                  }
                  if (v136 >= 4)
                  {
                    unint64_t v112 = v144;
                    unint64_t v101 = v145;
                    unint64_t v100 = v146;
                    unint64_t v103 = v147;
                    unint64_t v111 = v143;
                  }

                  uint64_t v127 = a6;
                }
              }

              uint64_t v148 = (unsigned __int16 *)(v126 + 4 * v131);
              uint64_t v131 = v148[1];
              uint64_t v133 = *v148;
              --v128;
            }

            while (v128);
          }

          unint64_t v149 = (result + 1);
          *(_WORD *)(v127 + 48) = result + 1;
          *(_BYTE *)(v107 + (unsigned __int16)v104) = v110;
          __int16 v150 = -1;
          if (v130 < 0xFFFF) {
            __int16 v150 = v130;
          }
          unint64_t v151 = (__int16 *)(v126 + 4LL * (unsigned __int16)result);
          __int16 *v151 = v150;
          v151[1] = v236;
          *(_DWORD *)(v106 + 4 * v110) = v104;
          *(_WORD *)(v106 + 0x20000 + 2 * v110) = result;
          if (v112 == 2020)
          {
            uint64_t v152 = *(void *)(v127 + 72);
            unint64_t v154 = *(void *)(v152 + 8);
            unint64_t v153 = *(void *)(v152 + 16);
            a5 = v229;
            int v155 = 0;
            if (v153 >= v154 >> 7)
            {
              uint64_t v156 = ((506832829 * *(_DWORD *)v109) >> 17) & 0x7FFE;
              unint64_t result = *(void *)(v229 + 120);
              char v157 = 1;
              unint64_t v158 = v100;
              unint64_t v159 = v101;
              unint64_t v112 = 2020LL;
              do
              {
                char v160 = v157;
                *(void *)(v152 + 8) = ++v154;
                unint64_t v161 = *(unsigned __int8 *)(result + v156);
                if (!*(_BYTE *)(result + v156) || v22 < v161) {
                  goto LABEL_212;
                }
                uint64_t v162 = *(unsigned __int16 *)(*(void *)(v229 + 112) + 2 * v156);
                uint64_t v163 = *(void *)(v229 + 88);
                uint64_t v164 = *(unsigned int *)(v163 + 4 * v161 + 32);
                uint64_t v165 = *(void *)(v163 + 168);
                unint64_t v166 = (unsigned __int8 *)(v165 + v164 + v162 * *(unsigned __int8 *)(result + v156));
                if (v161 < 8)
                {
                  unint64_t v100 = 0LL;
LABEL_217:
                  unint64_t v172 = v161 & 7;
                  if ((v161 & 7) != 0)
                  {
                    unint64_t v173 = v100 | v172;
                    while (v109[v100] == *v166)
                    {
                      ++v166;
                      ++v100;
                      if (!--v172)
                      {
                        unint64_t v100 = v173;
                        break;
                      }
                    }
                  }
                }

                else
                {
                  unint64_t v167 = 0LL;
                  unint64_t v100 = v161 & 0xF8;
                  unint64_t v168 = (unsigned __int8 *)(v165
                                           + v162 * (unint64_t)*(unsigned __int8 *)(result + v156)
                                           + (*(_BYTE *)(result + v156) & 0xF8)
                                           + v164);
                  while (1)
                  {
                    uint64_t v169 = *(void *)&v166[v167];
                    uint64_t v170 = *(void *)&v109[v167];
                    if (v169 != v170) {
                      break;
                    }
                    v167 += 8LL;
                    if (v100 == v167)
                    {
                      unint64_t v166 = v168;
                      goto LABEL_217;
                    }
                  }

                  unint64_t v100 = v167 + (__clz(__rbit64(v170 ^ v169)) >> 3);
                }

                if (v100
                  && v100 + *(unsigned int *)(v229 + 100) > v161
                  && (unint64_t v101 = v232
                           + 1
                           + v162
                           + ((((*(void *)(v229 + 104) >> (6 * (v161 - v100))) & 0x3FLL)
                             + 4 * (v161 - v100)) << *(_BYTE *)(v163 + v161)),
                      v101 <= v241)
                  && (unsigned int v171 = __clz(v101), 135 * v100 - 30 * (v171 ^ 0x1F) + 1920 >= v112))
                {
                  int v155 = v161 - v100;
                  *(void *)(v152 + 16) = ++v153;
                  unint64_t v112 = 135 * v100 - 30 * (v171 ^ 0x1F) + 1920;
                }

                else
                {
LABEL_212:
                  unint64_t v101 = v159;
                  unint64_t v100 = v158;
                }

                char v157 = 0;
                ++v156;
                unint64_t v158 = v100;
                unint64_t v159 = v101;
              }

              while ((v160 & 1) != 0);
            }

            else
            {
              unint64_t v112 = 2020LL;
            }
          }

          else
          {
            int v155 = 0;
            a5 = v229;
          }

          if (v112 < v239 + 175) {
            break;
          }
          ++v242;
          a3 = v245;
          unint64_t v16 = v228;
          if (v233 <= 2)
          {
            unsigned int v98 = v233 + 1;
            unint64_t result = v149;
            unint64_t v239 = v112;
            unint64_t v95 = v101;
            unint64_t v43 = v100;
            int v227 = v155;
            unint64_t v48 = v104;
            if (v234 + 5 < v226) {
              continue;
            }
          }

          goto LABEL_236;
        }

        unint64_t v104 = v234;
        unint64_t v182 = v234 + v230;
        unint64_t v16 = v228;
        if (v234 + v230 >= v228) {
          unint64_t v182 = v228;
        }
        unint64_t v232 = v182;
        unint64_t v101 = v244;
        a3 = v245;
        unint64_t v100 = v225;
        int v155 = v227;
LABEL_236:
        if (v101 > v232)
        {
LABEL_237:
          unint64_t v183 = v101 + 15;
          goto LABEL_238;
        }

        uint64_t v184 = *a7;
        if (v101 == v184)
        {
          unint64_t v183 = 0LL;
LABEL_243:
          *(_DWORD *)uint64_t v224 = v242;
          *(_DWORD *)(v224 + 4) = v100 | (v155 << 25);
          uint64_t v185 = *(unsigned int *)(a5 + 68);
          uint64_t v186 = v185 + 16;
          if (v185 + 16 <= v183)
          {
            uint64_t v188 = *(unsigned int *)(a5 + 64);
            unint64_t v189 = v183 - v185 + (4LL << v188) - 16;
            uint64_t v190 = (__clz(v189) ^ 0x1F) - 1;
            uint64_t v191 = ((v189 >> v190) & 1 | 2) << v190;
            unint64_t v183 = ((v189 & ~(-1 << v188))
                  + v186
                  + ((((v189 >> v190) & 1 | (2 * (v190 - v188))) + 65534) << v188)) | ((v190 - v188) << 10);
            unint64_t v187 = (v189 - v191) >> v188;
          }

          else
          {
            LODWORD(v187) = 0;
          }

          *(_WORD *)(v224 + 14) = v183;
          *(_DWORD *)(v224 + 8) = v187;
          if (v242 > 5)
          {
            if (v242 > 0x81)
            {
              if (v242 > 0x841)
              {
                if (v242 >> 1 >= 0xC21)
                {
                  if (v242 < 0x5842) {
                    LOWORD(v192) = 22;
                  }
                  else {
                    LOWORD(v192) = 23;
                  }
                }

                else
                {
                  LOWORD(v192) = 21;
                }
              }

              else
              {
                unsigned int v192 = (__clz(v242 - 66) ^ 0x1F) + 10;
              }
            }

            else
            {
              unsigned int v193 = (__clz(v242 - 2) ^ 0x1F) - 1;
              unsigned int v192 = ((v242 - 2) >> v193) + 2 * v193 + 2;
            }
          }

          else
          {
            LOWORD(v192) = v242;
          }

          unint64_t v205 = v155 + (int)v100;
          if (v205 > 9)
          {
            if (v205 > 0x85)
            {
              else {
                LODWORD(v205) = (__clz(v205 - 70) ^ 0x1F) + 12;
              }
            }

            else
            {
              v205 -= 6LL;
              unsigned int v206 = (__clz(v205) ^ 0x1F) - 1;
              LODWORD(v205) = (v205 >> v206) + 2 * v206 + 4;
            }
          }

          else
          {
            LOWORD(v205) = v205 - 2;
          }

          int v207 = v205 & 7 | (8 * (v192 & 7));
          if ((v183 & 0x3FF) != 0 || (unsigned __int16)v192 > 7u || (unsigned __int16)v205 > 0xFu)
          {
            int v209 = 3 * ((unsigned __int16)v192 >> 3) + ((unsigned __int16)(v205 & 0xFFF8) >> 3);
            unsigned int v208 = ((((0x520D40u >> (2 * v209)) & 0xC0) + (v209 << 6)) | v207) + 64;
          }

          else
          {
            LOWORD(v208) = v207 | 0x40;
            if ((v205 & 0xFFF8) == 0) {
              LOWORD(v208) = v205 & 7 | (8 * (v192 & 7));
            }
          }

          *(_WORD *)(v224 + 12) = v208;
          *a11 += v242;
          unint64_t v210 = v104 + 2;
          unint64_t v174 = v104 + v100;
          if (v104 + v100 >= v223) {
            unint64_t v211 = v223;
          }
          else {
            unint64_t v211 = v104 + v100;
          }
          if (v101 < v100 >> 2)
          {
            unint64_t v212 = v174 - 4 * v101;
            if (v210 > v212) {
              unint64_t v212 = v104 + 2;
            }
            if (v211 >= v212) {
              unint64_t v210 = v212;
            }
            else {
              unint64_t v210 = v211;
            }
          }

          unint64_t v17 = v222 + 2 * v100 + v104;
          uint64_t v18 = v224 + 16;
          if (v210 >= v211)
          {
            unint64_t v12 = 0LL;
            uint64_t v11 = a9;
            goto LABEL_304;
          }

          uint64_t v213 = *(void *)(a6 + 64);
          uint64_t v214 = v213 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v215 = (506832829 * *(_DWORD *)(a3 + (v210 & a4))) >> 17;
            *(_BYTE *)(v213 + 196608 + (unsigned __int16)v210) = v215;
            unint64_t v216 = (_WORD *)(v213 + 0x40000 + 4LL * v178);
            unint64_t result = *(unsigned __int16 *)(v214 + 2LL * v215);
            *(_WORD *)(v214 + 2LL * v215) = v178++;
            unint64_t v217 = v210 - *(unsigned int *)(v213 + 4LL * v215);
            if (v217 >= 0xFFFF) {
              LOWORD(v217) = -1;
            }
            *unint64_t v216 = v217;
            v216[1] = result;
            *(_DWORD *)(v213 + 4LL * v215) = v210++;
          }

          while (v211 != v210);
          unint64_t v12 = 0LL;
          uint64_t v11 = a9;
          unint64_t v13 = v226;
          goto LABEL_302;
        }

        uint64_t v200 = a7[1];
        if (v101 == v200)
        {
          unint64_t v183 = 1LL;
        }

        else
        {
          unint64_t v201 = v101 + 3 - v184;
          if (v201 > 6)
          {
            unint64_t v204 = v101 + 3 - v200;
            if (v204 > 6)
            {
              if (v101 == a7[2])
              {
                unint64_t v183 = 2LL;
              }

              else
              {
                if (v101 != a7[3]) {
                  goto LABEL_237;
                }
                unint64_t v183 = 3LL;
              }

              goto LABEL_238;
            }

            char v202 = 4 * v204;
            unsigned int v203 = 266017486;
          }

          else
          {
            char v202 = 4 * v201;
            unsigned int v203 = 158663784;
          }

          unint64_t v183 = (v203 >> v202) & 0xF;
        }

LABEL_238:
        if (v101 <= v232 && v183)
        {
          a7[3] = a7[2];
          *(void *)(a7 + 1) = *(void *)a7;
          *a7 = v101;
        }

        goto LABEL_243;
      }

LABEL_222:
      unint64_t v12 = v242 + 1;
      unint64_t v174 = v48 + 1;
      unint64_t v17 = v237;
      if (v48 + 1 <= v237)
      {
        uint64_t v11 = a9;
        uint64_t v18 = v224;
LABEL_304:
        unint64_t v13 = v226;
        goto LABEL_305;
      }

      unint64_t v13 = v226;
      uint64_t v18 = v224;
      if (v174 <= v237 + v221)
      {
        unint64_t v194 = v220;
        if (v48 + 9 < v220) {
          unint64_t v194 = v48 + 9;
        }
        if (v174 < v194)
        {
          uint64_t v195 = *(void *)(a6 + 64);
          uint64_t v196 = v195 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v197 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            char v198 = (_WORD *)(v195 + 0x40000 + 4LL * v178);
            __int16 v199 = *(_WORD *)(v196 + 2LL * v197);
            *(_WORD *)(v196 + 2LL * v197) = v178++;
            *(_BYTE *)(v195 + 196608 + (unsigned __int16)v174) = v197;
            unint64_t result = v174 - *(unsigned int *)(v195 + 4LL * v197);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *char v198 = result;
            v198[1] = v199;
            *(_DWORD *)(v195 + 4LL * v197) = v174;
            v12 += 2LL;
            v174 += 2LL;
          }

          while (v174 < v194);
LABEL_257:
          uint64_t v11 = a9;
LABEL_302:
          *(_WORD *)(a6 + 48) = v178;
          goto LABEL_305;
        }
      }

      else
      {
        unint64_t v175 = v219;
        if (v48 + 17 < v219) {
          unint64_t v175 = v48 + 17;
        }
        if (v174 < v175)
        {
          uint64_t v176 = *(void *)(a6 + 64);
          uint64_t v177 = v176 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v179 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            unsigned int v180 = (_WORD *)(v176 + 0x40000 + 4LL * v178);
            __int16 v181 = *(_WORD *)(v177 + 2LL * v179);
            *(_WORD *)(v177 + 2LL * v179) = v178++;
            *(_BYTE *)(v176 + 196608 + (unsigned __int16)v174) = v179;
            unint64_t result = v174 - *(unsigned int *)(v176 + 4LL * v179);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *unsigned int v180 = result;
            v180[1] = v181;
            *(_DWORD *)(v176 + 4LL * v179) = v174;
            v12 += 4LL;
            v174 += 4LL;
          }

          while (v174 < v175);
          goto LABEL_257;
        }
      }

      uint64_t v11 = a9;
LABEL_305:
      a2 = v174;
      if (v174 + 4 >= v13) {
        goto LABEL_312;
      }
    }
  }

  uint64_t v18 = a9;
  unint64_t v174 = a2;
LABEL_312:
  *a8 = v12 + v13 - v174;
  *a10 += (v18 - v11) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH41( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  uint64_t v11 = a9;
  uint64_t v233 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 3;
  unint64_t v221 = v14;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  unint64_t v224 = v14;
  int v15 = *(_DWORD *)(a5 + 8);
  else {
    uint64_t v16 = 64LL;
  }
  int32x4_t v17 = (int32x4_t)vld1q_dup_f32((const float *)a7);
  *((int32x4_t *)a7 + 1) = vaddq_s32(v17, (int32x4_t)xmmword_1810CB570);
  *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v17.i8, (int32x2_t)0x3FFFFFFFDLL);
  if (a2 + 4 < v13)
  {
    unint64_t v18 = (1LL << v15) - 16;
    unint64_t v19 = v16 + a2;
    uint64_t v222 = 4 * v16;
    unint64_t v220 = v13 - 4;
    uint64_t v20 = a9;
    unint64_t v231 = v18;
    uint64_t v232 = a5;
    uint64_t v247 = a3;
    unint64_t v228 = a2 + result;
    uint64_t v223 = v16;
    while (1)
    {
      unint64_t v240 = v19;
      uint64_t v225 = v20;
      unint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      unint64_t v23 = 0LL;
      unint64_t v24 = 0LL;
      unint64_t v25 = v13 - a2;
      if (a2 >= v18) {
        unint64_t v26 = v18;
      }
      else {
        unint64_t v26 = a2;
      }
      unint64_t v244 = *(void *)(a5 + 80);
      unint64_t v246 = v12;
      uint64_t v243 = *(void *)(a6 + 64);
      uint64_t v27 = v243 + 196608;
      unint64_t v28 = a2 & a4;
      unint64_t v29 = (unsigned __int8 *)(a3 + (a2 & a4));
      uint64_t v30 = (506832829 * *(_DWORD *)v29) >> 17;
      unint64_t v236 = v25 & 7;
      unint64_t v31 = 2020LL;
      uint64_t v32 = 2020LL;
      do
      {
        unint64_t v33 = a7[v22];
        unint64_t result = a2 - v33;
        if ((!v22 || *(unsigned __int8 *)(v27 + (unsigned __int16)(a2 - v33)) == v30)
          && v26 >= v33
          && result < a2)
        {
          uint64_t v35 = a3 + (result & a4);
          if (v25 < 8)
          {
            unint64_t v39 = 0LL;
            unint64_t v40 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_33:
            if ((v25 & 7) != 0)
            {
              unint64_t v43 = v236 | v39;
              unint64_t v44 = v25 & 7;
              while (1)
              {
                unint64_t result = *v40;
                ++v40;
                ++v39;
                if (!--v44)
                {
                  unint64_t v39 = v43;
                  break;
                }
              }
            }
          }

          else
          {
            unint64_t result = 0LL;
            unint64_t v36 = v25 >> 3;
            while (1)
            {
              uint64_t v37 = *(void *)&v29[result];
              uint64_t v38 = *(void *)(v35 + result);
              if (v37 != v38) {
                break;
              }
              result += 8LL;
              if (!--v36)
              {
                unint64_t v40 = &v29[v25 & 0xFFFFFFFFFFFFFFF8LL];
                unint64_t v39 = v25 & 0xFFFFFFFFFFFFFFF8LL;
                goto LABEL_33;
              }
            }

            unint64_t v39 = result + (__clz(__rbit64(v38 ^ v37)) >> 3);
          }

          if (v39 >= 2)
          {
            unint64_t v41 = 135 * v39 + 1935;
            if (v31 < v41)
            {
              unint64_t v42 = v41 - (((0x1CA10u >> (v22 & 0xE)) & 0xE) + 39);
              if (!v22) {
                unint64_t v42 = 135 * v39 + 1935;
              }
              if (v31 < v42)
              {
                uint64_t v32 = v42;
                unint64_t v24 = a7[v22];
                unint64_t v23 = v39;
                unint64_t v21 = v39;
                unint64_t v31 = v42;
              }
            }
          }
        }

        ++v22;
      }

      while (v22 != 10);
      unint64_t v45 = v23;
      if (a2 + v233 >= v18) {
        unint64_t v46 = v18;
      }
      else {
        unint64_t v46 = a2 + v233;
      }
      unint64_t v238 = v46;
      uint64_t v47 = v243 + 0x40000;
      uint64_t v48 = a6;
      uint64_t v49 = *(void *)(a6 + 56);
      unint64_t v50 = a2;
      unint64_t v51 = a2 - *(unsigned int *)(v243 + 4LL * v30);
      uint64_t v52 = *(unsigned __int16 *)(v243 + 0x20000 + 2LL * v30);
      __int16 v241 = *(_WORD *)(v243 + 0x20000 + 2LL * v30);
      if (v49)
      {
        unint64_t v53 = 0LL;
        unint64_t v54 = v51;
        do
        {
          v53 += v54;
          if (v53 > v26) {
            break;
          }
          if (v21 + v28 <= a4)
          {
            unint64_t v55 = (v50 - v53) & a4;
            if (v55 + v21 <= a4)
            {
              unint64_t result = *(unsigned __int8 *)(v247 + v55 + v21);
              if (*(unsigned __int8 *)(v247 + v21 + v28) == (_DWORD)result)
              {
                uint64_t v56 = v247 + v55;
                if (v25 < 8)
                {
                  unint64_t v62 = 0LL;
                  unint64_t v61 = v29;
LABEL_74:
                  uint64_t v48 = a6;
                  unint64_t v69 = v25 & 7;
                  if ((v25 & 7) != 0)
                  {
                    unint64_t v229 = v236 | v62;
                    while (*(unsigned __int8 *)(v56 + v62) == *v61)
                    {
                      ++v61;
                      ++v62;
                      if (!--v69)
                      {
                        unint64_t v62 = v229;
                        break;
                      }
                    }
                  }
                }

                else
                {
                  uint64_t v57 = 0LL;
                  unint64_t v58 = v25 >> 3;
                  uint64_t v48 = a6;
                  while (1)
                  {
                    uint64_t v59 = *(void *)&v29[v57];
                    uint64_t v60 = *(void *)(v56 + v57);
                    if (v59 != v60) {
                      break;
                    }
                    v57 += 8LL;
                    if (!--v58)
                    {
                      unint64_t v61 = &v29[v25 & 0xFFFFFFFFFFFFFFF8LL];
                      unint64_t v62 = v25 & 0xFFFFFFFFFFFFFFF8LL;
                      goto LABEL_74;
                    }
                  }

                  unint64_t v62 = v57 + (__clz(__rbit64(v60 ^ v59)) >> 3);
                }

                uint64_t v63 = 30 * (__clz(v53) ^ 0x1F);
                unint64_t v64 = 135 * v62 - v63 + 1920;
                if (v31 < v64) {
                  unint64_t result = 135 * v62 - v63 + 1920;
                }
                else {
                  unint64_t result = v32;
                }
                if (v31 < v64) {
                  unint64_t v65 = v53;
                }
                else {
                  unint64_t v65 = v24;
                }
                if (v31 < v64) {
                  unint64_t v66 = v62;
                }
                else {
                  unint64_t v66 = v45;
                }
                if (v31 < v64) {
                  unint64_t v67 = v62;
                }
                else {
                  unint64_t v67 = v21;
                }
                if (v31 >= v64) {
                  unint64_t v64 = v31;
                }
                if (v62 >= 4)
                {
                  uint64_t v32 = result;
                  unint64_t v24 = v65;
                  unint64_t v45 = v66;
                  unint64_t v21 = v67;
                  unint64_t v31 = v64;
                }
              }

              else
              {
                uint64_t v48 = a6;
              }
            }
          }

          unint64_t v68 = (unsigned __int16 *)(v47 + 4 * v52);
          uint64_t v52 = v68[1];
          unint64_t v54 = *v68;
          --v49;
        }

        while (v49);
      }

      uint64_t v70 = *(unsigned __int16 *)(v48 + 48);
      *(_WORD *)(v48 + 48) = v70 + 1;
      *(_BYTE *)(v27 + (unsigned __int16)v50) = v30;
      __int16 v71 = -1;
      if (v51 < 0xFFFF) {
        __int16 v71 = v51;
      }
      uint64_t v72 = (__int16 *)(v47 + 4 * v70);
      *uint64_t v72 = v71;
      v72[1] = v241;
      *(_DWORD *)(v243 + 4 * v30) = v50;
      *(_WORD *)(v243 + 0x20000 + 2 * v30) = v70;
      if (v32 == 2020)
      {
        uint64_t v73 = *(void *)(v48 + 72);
        unint64_t v75 = *(void *)(v73 + 8);
        unint64_t v74 = *(void *)(v73 + 16);
        unint64_t v18 = v231;
        a5 = v232;
        a3 = v247;
        if (v74 < v75 >> 7) {
          goto LABEL_216;
        }
        unint64_t v76 = v24;
        int v230 = 0;
        uint64_t v77 = ((506832829 * *(_DWORD *)v29) >> 17) & 0x7FFE;
        uint64_t v78 = *(void *)(v232 + 120);
        char v79 = 1;
        unint64_t result = v45;
        unint64_t v80 = 2020LL;
        do
        {
          char v81 = v79;
          *(void *)(v73 + 8) = ++v75;
          unint64_t v82 = *(unsigned __int8 *)(v78 + v77);
          if (!*(_BYTE *)(v78 + v77) || v25 < v82) {
            goto LABEL_96;
          }
          uint64_t v83 = *(unsigned __int16 *)(*(void *)(v232 + 112) + 2 * v77);
          uint64_t v84 = *(void *)(v232 + 88);
          uint64_t v85 = *(unsigned int *)(v84 + 4 * v82 + 32);
          uint64_t v86 = *(void *)(v84 + 168);
          uint64_t v87 = (unsigned __int8 *)(v86 + v85 + v83 * *(unsigned __int8 *)(v78 + v77));
          if (v82 < 8)
          {
            unint64_t v45 = 0LL;
LABEL_101:
            unint64_t v96 = v82 & 7;
            if ((v82 & 7) != 0)
            {
              unint64_t v97 = v45 | v96;
              while (v29[v45] == *v87)
              {
                ++v87;
                ++v45;
                if (!--v96)
                {
                  unint64_t v45 = v97;
                  break;
                }
              }
            }
          }

          else
          {
            unint64_t v88 = 0LL;
            unint64_t v45 = v82 & 0xF8;
            uint64_t v89 = (unsigned __int8 *)(v86
                                    + v83 * (unint64_t)*(unsigned __int8 *)(v78 + v77)
                                    + (*(_BYTE *)(v78 + v77) & 0xF8)
                                    + v85);
            while (1)
            {
              uint64_t v90 = *(void *)&v87[v88];
              uint64_t v91 = *(void *)&v29[v88];
              if (v90 != v91) {
                break;
              }
              v88 += 8LL;
              if (v45 == v88)
              {
                uint64_t v87 = v89;
                goto LABEL_101;
              }
            }

            unint64_t v45 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
          }

          if (v45
            && v45 + *(unsigned int *)(v232 + 100) > v82
            && (unint64_t v92 = v238
                    + 1
                    + v83
                    + ((((*(void *)(v232 + 104) >> (6 * (v82 - v45))) & 0x3FLL)
                      + 4 * (v82 - v45)) << *(_BYTE *)(v84 + v82)),
                v92 <= v244)
            && (unint64_t v93 = v92, v94 = 135 * v45 - 30 * (__clz(v92) ^ 0x1F) + 1920, v94 >= v80))
          {
            int v230 = v82 - v45;
            *(void *)(v73 + 16) = ++v74;
            unint64_t v80 = v94;
            unint64_t v95 = v93;
          }

          else
          {
LABEL_96:
            unint64_t v95 = v76;
            unint64_t v45 = result;
          }

          char v79 = 0;
          ++v77;
          unint64_t result = v45;
          unint64_t v76 = v95;
        }

        while ((v81 & 1) != 0);
      }

      else
      {
        unint64_t v80 = v32;
        int v230 = 0;
        unint64_t v18 = v231;
        a5 = v232;
        a3 = v247;
        unint64_t v95 = v24;
      }

      if (v80 >= 0x7E5)
      {
        unint64_t v242 = v80;
        unsigned int v98 = 0;
        int v99 = *(unsigned __int16 *)(a6 + 48);
        while (1)
        {
          unsigned int v235 = v98;
          unint64_t v226 = v95;
          unint64_t v227 = v45;
          uint64_t v100 = 0LL;
          unint64_t v101 = 0LL;
          unint64_t v102 = 0LL;
          --v25;
          unint64_t v103 = v45 - 1;
          if (v45 - 1 >= v25) {
            unint64_t v103 = v25;
          }
          unint64_t v104 = *(int *)(a5 + 4) >= 5 ? 0LL : v103;
          unint64_t v105 = v50 + 1;
          unint64_t v237 = v50;
          unint64_t v106 = v50 + 1 < v18 ? v50 + 1 : v18;
          unint64_t v245 = *(void *)(a5 + 80);
          uint64_t v107 = *(void *)(a6 + 64);
          unint64_t result = v107 + 196608;
          uint64_t v108 = v105 & a4;
          unint64_t v109 = (unsigned __int8 *)(a3 + (v105 & a4));
          uint64_t v110 = (506832829 * *(_DWORD *)v109) >> 17;
          unint64_t v111 = 2020LL;
          unint64_t v112 = 2020LL;
          do
          {
            unint64_t v113 = a7[v100];
            unint64_t v114 = v105 - v113;
            if ((!v100 || *(unsigned __int8 *)(result + (unsigned __int16)(v105 - v113)) == v110)
              && v106 >= v113
              && v114 < v105)
            {
              uint64_t v116 = a3 + (v114 & a4);
              if (v25 < 8)
              {
                unint64_t v117 = 0LL;
                uint64_t v121 = (unsigned __int8 *)(a3 + (v105 & a4));
LABEL_139:
                unint64_t v124 = v25 & 7;
                if ((v25 & 7) != 0)
                {
                  do
                  {
                    ++v121;
                    ++v117;
                    --v124;
                  }

                  while (v124);
                }
              }

              else
              {
                unint64_t v117 = 0LL;
                unint64_t v118 = v25 >> 3;
                while (1)
                {
                  uint64_t v119 = *(void *)&v109[v117];
                  uint64_t v120 = *(void *)(v116 + v117);
                  if (v119 != v120) {
                    break;
                  }
                  v117 += 8LL;
                  if (!--v118)
                  {
                    uint64_t v121 = &v109[v117];
                    goto LABEL_139;
                  }
                }

                v117 += __clz(__rbit64(v120 ^ v119)) >> 3;
              }

              if (v117 >= 2)
              {
                unint64_t v122 = 135 * v117 + 1935;
                if (v111 < v122)
                {
                  unint64_t v123 = v122 - (((0x1CA10u >> (v100 & 0xE)) & 0xE) + 39);
                  if (!v100) {
                    unint64_t v123 = 135 * v117 + 1935;
                  }
                  if (v111 < v123)
                  {
                    unint64_t v112 = v123;
                    unint64_t v102 = a7[v100];
                    unint64_t v101 = v117;
                    unint64_t v104 = v117;
                    unint64_t v111 = v123;
                  }
                }
              }
            }

            ++v100;
          }

          while (v100 != 10);
          if (v105 + v233 >= v18) {
            unint64_t v125 = v18;
          }
          else {
            unint64_t v125 = v105 + v233;
          }
          unint64_t v234 = v125;
          uint64_t v126 = v107 + 0x40000;
          uint64_t v127 = a6;
          uint64_t v128 = *(void *)(a6 + 56);
          uint64_t v129 = *(unsigned int *)(v107 + 4LL * v110);
          unint64_t v130 = v105 - v129;
          uint64_t v131 = *(unsigned __int16 *)(v107 + 0x20000 + 2LL * v110);
          __int16 v239 = *(_WORD *)(v107 + 0x20000 + 2LL * v110);
          if (v128)
          {
            unint64_t v132 = 0LL;
            uint64_t v133 = v105 - v129;
            do
            {
              v132 += v133;
              if (v132 > v106) {
                break;
              }
              if (v104 + v108 <= a4)
              {
                unint64_t v134 = (v105 - v132) & a4;
                if (v134 + v104 <= a4
                  && *(unsigned __int8 *)(v247 + v104 + v108) == *(unsigned __int8 *)(v247 + v134 + v104))
                {
                  uint64_t v135 = v247 + v134;
                  if (v25 < 8)
                  {
                    unint64_t v136 = 0LL;
                    unsigned int v141 = v109;
                    unint64_t v138 = v25 & 7;
LABEL_179:
                    while (v138)
                    {
                      ++v141;
                      ++v136;
                      --v138;
                    }
                  }

                  else
                  {
                    unint64_t v136 = 0LL;
                    unint64_t v137 = v25 >> 3;
                    unint64_t v138 = v25 & 7;
                    while (1)
                    {
                      uint64_t v139 = *(void *)&v109[v136];
                      uint64_t v140 = *(void *)(v135 + v136);
                      if (v139 != v140) {
                        break;
                      }
                      v136 += 8LL;
                      if (!--v137)
                      {
                        unsigned int v141 = &v109[v136];
                        goto LABEL_179;
                      }
                    }

                    v136 += __clz(__rbit64(v140 ^ v139)) >> 3;
                  }

                  uint64_t v142 = 30 * (__clz(v132) ^ 0x1F);
                  unint64_t v143 = 135 * v136 - v142 + 1920;
                  if (v111 < v143) {
                    uint64_t v144 = 135 * v136 - v142 + 1920;
                  }
                  else {
                    uint64_t v144 = v112;
                  }
                  if (v111 < v143) {
                    unint64_t v145 = v132;
                  }
                  else {
                    unint64_t v145 = v102;
                  }
                  if (v111 < v143) {
                    unint64_t v146 = v136;
                  }
                  else {
                    unint64_t v146 = v101;
                  }
                  if (v111 < v143) {
                    unint64_t v147 = v136;
                  }
                  else {
                    unint64_t v147 = v104;
                  }
                  if (v111 >= v143) {
                    unint64_t v143 = v111;
                  }
                  if (v136 >= 4)
                  {
                    unint64_t v112 = v144;
                    unint64_t v102 = v145;
                    unint64_t v101 = v146;
                    unint64_t v104 = v147;
                    unint64_t v111 = v143;
                  }

                  uint64_t v127 = a6;
                }
              }

              uint64_t v148 = (unsigned __int16 *)(v126 + 4 * v131);
              uint64_t v131 = v148[1];
              uint64_t v133 = *v148;
              --v128;
            }

            while (v128);
          }

          int v149 = v99 + 1;
          *(_WORD *)(v127 + 48) = v99 + 1;
          *(_BYTE *)(result + (unsigned __int16)v105) = v110;
          __int16 v150 = -1;
          if (v130 < 0xFFFF) {
            __int16 v150 = v130;
          }
          unint64_t v151 = (__int16 *)(v126 + 4LL * (unsigned __int16)v99);
          __int16 *v151 = v150;
          v151[1] = v239;
          *(_DWORD *)(v107 + 4 * v110) = v105;
          *(_WORD *)(v107 + 0x20000 + 2 * v110) = v99;
          if (v112 == 2020)
          {
            uint64_t v152 = *(void *)(v127 + 72);
            unint64_t v154 = *(void *)(v152 + 8);
            unint64_t v153 = *(void *)(v152 + 16);
            a5 = v232;
            int v155 = 0;
            if (v153 >= v154 >> 7)
            {
              uint64_t v156 = ((506832829 * *(_DWORD *)v109) >> 17) & 0x7FFE;
              unint64_t result = *(void *)(v232 + 120);
              char v157 = 1;
              unint64_t v158 = v101;
              unint64_t v159 = v102;
              unint64_t v112 = 2020LL;
              do
              {
                char v160 = v157;
                *(void *)(v152 + 8) = ++v154;
                unint64_t v161 = *(unsigned __int8 *)(result + v156);
                if (!*(_BYTE *)(result + v156) || v25 < v161) {
                  goto LABEL_206;
                }
                uint64_t v162 = *(unsigned __int16 *)(*(void *)(v232 + 112) + 2 * v156);
                uint64_t v163 = *(void *)(v232 + 88);
                uint64_t v164 = *(unsigned int *)(v163 + 4 * v161 + 32);
                uint64_t v165 = *(void *)(v163 + 168);
                unint64_t v166 = (unsigned __int8 *)(v165 + v164 + v162 * *(unsigned __int8 *)(result + v156));
                if (v161 < 8)
                {
                  unint64_t v101 = 0LL;
LABEL_211:
                  unint64_t v172 = v161 & 7;
                  if ((v161 & 7) != 0)
                  {
                    unint64_t v173 = v101 | v172;
                    while (v109[v101] == *v166)
                    {
                      ++v166;
                      ++v101;
                      if (!--v172)
                      {
                        unint64_t v101 = v173;
                        break;
                      }
                    }
                  }
                }

                else
                {
                  unint64_t v167 = 0LL;
                  unint64_t v101 = v161 & 0xF8;
                  unint64_t v168 = (unsigned __int8 *)(v165
                                           + v162 * (unint64_t)*(unsigned __int8 *)(result + v156)
                                           + (*(_BYTE *)(result + v156) & 0xF8)
                                           + v164);
                  while (1)
                  {
                    uint64_t v169 = *(void *)&v166[v167];
                    uint64_t v170 = *(void *)&v109[v167];
                    if (v169 != v170) {
                      break;
                    }
                    v167 += 8LL;
                    if (v101 == v167)
                    {
                      unint64_t v166 = v168;
                      goto LABEL_211;
                    }
                  }

                  unint64_t v101 = v167 + (__clz(__rbit64(v170 ^ v169)) >> 3);
                }

                if (v101
                  && v101 + *(unsigned int *)(v232 + 100) > v161
                  && (unint64_t v102 = v234
                           + 1
                           + v162
                           + ((((*(void *)(v232 + 104) >> (6 * (v161 - v101))) & 0x3FLL)
                             + 4 * (v161 - v101)) << *(_BYTE *)(v163 + v161)),
                      v102 <= v245)
                  && (unsigned int v171 = __clz(v102), 135 * v101 - 30 * (v171 ^ 0x1F) + 1920 >= v112))
                {
                  int v155 = v161 - v101;
                  *(void *)(v152 + 16) = ++v153;
                  unint64_t v112 = 135 * v101 - 30 * (v171 ^ 0x1F) + 1920;
                }

                else
                {
LABEL_206:
                  unint64_t v102 = v159;
                  unint64_t v101 = v158;
                }

                char v157 = 0;
                ++v156;
                unint64_t v158 = v101;
                unint64_t v159 = v102;
              }

              while ((v160 & 1) != 0);
            }

            else
            {
              unint64_t v112 = 2020LL;
            }
          }

          else
          {
            int v155 = 0;
            a5 = v232;
          }

          if (v112 < v242 + 175) {
            break;
          }
          a3 = v247;
          ++v246;
          unint64_t v18 = v231;
          if (v235 <= 2)
          {
            unsigned int v98 = v235 + 1;
            int v99 = v149;
            unint64_t v242 = v112;
            unint64_t v95 = v102;
            unint64_t v45 = v101;
            int v230 = v155;
            unint64_t v50 = v105;
            if (v237 + 5 < v228) {
              continue;
            }
          }

          goto LABEL_230;
        }

        unint64_t v105 = v237;
        unint64_t v182 = v237 + v233;
        unint64_t v18 = v231;
        if (v237 + v233 >= v231) {
          unint64_t v182 = v231;
        }
        unint64_t v234 = v182;
        unint64_t v102 = v226;
        unint64_t v101 = v227;
        int v155 = v230;
        a3 = v247;
LABEL_230:
        unint64_t v13 = v228;
        if (v102 > v234)
        {
LABEL_231:
          unint64_t v183 = v102 + 15;
          goto LABEL_232;
        }

        uint64_t v185 = *a7;
        if (v102 == v185)
        {
          unint64_t v183 = 0LL;
LABEL_237:
          *(_DWORD *)uint64_t v225 = v246;
          *(_DWORD *)(v225 + 4) = v101 | (v155 << 25);
          uint64_t v186 = *(unsigned int *)(a5 + 68);
          uint64_t v187 = v186 + 16;
          if (v186 + 16 <= v183)
          {
            uint64_t v189 = *(unsigned int *)(a5 + 64);
            unint64_t v190 = v183 - v186 + (4LL << v189) - 16;
            uint64_t v191 = (__clz(v190) ^ 0x1F) - 1;
            uint64_t v192 = ((v190 >> v191) & 1 | 2) << v191;
            unint64_t v183 = ((v190 & ~(-1 << v189))
                  + v187
                  + ((((v190 >> v191) & 1 | (2 * (v191 - v189))) + 65534) << v189)) | ((v191 - v189) << 10);
            unint64_t v188 = (v190 - v192) >> v189;
          }

          else
          {
            LODWORD(v188) = 0;
          }

          *(_WORD *)(v225 + 14) = v183;
          *(_DWORD *)(v225 + 8) = v188;
          if (v246 > 5)
          {
            if (v246 > 0x81)
            {
              if (v246 > 0x841)
              {
                if (v246 >> 1 >= 0xC21)
                {
                  if (v246 < 0x5842) {
                    LOWORD(v193) = 22;
                  }
                  else {
                    LOWORD(v193) = 23;
                  }
                }

                else
                {
                  LOWORD(v193) = 21;
                }
              }

              else
              {
                unsigned int v193 = (__clz(v246 - 66) ^ 0x1F) + 10;
              }
            }

            else
            {
              unsigned int v194 = (__clz(v246 - 2) ^ 0x1F) - 1;
              unsigned int v193 = ((v246 - 2) >> v194) + 2 * v194 + 2;
            }
          }

          else
          {
            LOWORD(v193) = v246;
          }

          unint64_t v206 = v155 + (int)v101;
          if (v206 > 9)
          {
            if (v206 > 0x85)
            {
              else {
                LODWORD(v206) = (__clz(v206 - 70) ^ 0x1F) + 12;
              }
            }

            else
            {
              v206 -= 6LL;
              unsigned int v207 = (__clz(v206) ^ 0x1F) - 1;
              LODWORD(v206) = (v206 >> v207) + 2 * v207 + 4;
            }
          }

          else
          {
            LOWORD(v206) = v206 - 2;
          }

          int v208 = v206 & 7 | (8 * (v193 & 7));
          if ((v183 & 0x3FF) != 0 || (unsigned __int16)v193 > 7u || (unsigned __int16)v206 > 0xFu)
          {
            int v210 = 3 * ((unsigned __int16)v193 >> 3) + ((unsigned __int16)(v206 & 0xFFF8) >> 3);
            unsigned int v209 = ((((0x520D40u >> (2 * v210)) & 0xC0) + (v210 << 6)) | v208) + 64;
          }

          else
          {
            LOWORD(v209) = v208 | 0x40;
            if ((v206 & 0xFFF8) == 0) {
              LOWORD(v209) = v206 & 7 | (8 * (v193 & 7));
            }
          }

          *(_WORD *)(v225 + 12) = v209;
          *a11 += v246;
          unint64_t v211 = v105 + 2;
          unint64_t v174 = v105 + v101;
          if (v105 + v101 >= v224) {
            unint64_t v212 = v224;
          }
          else {
            unint64_t v212 = v105 + v101;
          }
          if (v102 < v101 >> 2)
          {
            unint64_t v213 = v174 - 4 * v102;
            if (v211 > v213) {
              unint64_t v213 = v105 + 2;
            }
            if (v212 >= v213) {
              unint64_t v211 = v213;
            }
            else {
              unint64_t v211 = v212;
            }
          }

          unint64_t v19 = v223 + 2 * v101 + v105;
          uint64_t v20 = v225 + 16;
          if (v211 >= v212)
          {
            unint64_t v12 = 0LL;
            uint64_t v11 = a9;
            goto LABEL_297;
          }

          uint64_t v214 = *(void *)(a6 + 64);
          uint64_t v215 = v214 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v216 = (506832829 * *(_DWORD *)(a3 + (v211 & a4))) >> 17;
            *(_BYTE *)(v214 + 196608 + (unsigned __int16)v211) = v216;
            unint64_t v217 = (_WORD *)(v214 + 0x40000 + 4LL * v178);
            unint64_t result = *(unsigned __int16 *)(v215 + 2LL * v216);
            *(_WORD *)(v215 + 2LL * v216) = v178++;
            unint64_t v218 = v211 - *(unsigned int *)(v214 + 4LL * v216);
            if (v218 >= 0xFFFF) {
              LOWORD(v218) = -1;
            }
            *unint64_t v217 = v218;
            v217[1] = result;
            *(_DWORD *)(v214 + 4LL * v216) = v211++;
          }

          while (v212 != v211);
          unint64_t v12 = 0LL;
          uint64_t v11 = a9;
          goto LABEL_295;
        }

        uint64_t v201 = a7[1];
        if (v102 == v201)
        {
          unint64_t v183 = 1LL;
        }

        else
        {
          unint64_t v202 = v102 + 3 - v185;
          if (v202 > 6)
          {
            unint64_t v205 = v102 + 3 - v201;
            if (v205 > 6)
            {
              if (v102 == a7[2])
              {
                unint64_t v183 = 2LL;
              }

              else
              {
                if (v102 != a7[3]) {
                  goto LABEL_231;
                }
                unint64_t v183 = 3LL;
              }

              goto LABEL_232;
            }

            char v203 = 4 * v205;
            unsigned int v204 = 266017486;
          }

          else
          {
            char v203 = 4 * v202;
            unsigned int v204 = 158663784;
          }

          unint64_t v183 = (v204 >> v203) & 0xF;
        }

LABEL_232:
        if (v102 <= v234 && v183)
        {
          a7[3] = a7[2];
          *(void *)(a7 + 1) = *(void *)a7;
          *a7 = v102;
          int32x4_t v184 = vdupq_n_s32(v102);
          *((int32x4_t *)a7 + 1) = vaddq_s32(v184, (int32x4_t)xmmword_1810CB570);
          *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v184.i8, (int32x2_t)0x3FFFFFFFDLL);
        }

        goto LABEL_237;
      }

LABEL_216:
      unint64_t v12 = v246 + 1;
      unint64_t v174 = v50 + 1;
      unint64_t v19 = v240;
      if (v50 + 1 > v240)
      {
        uint64_t v11 = a9;
        uint64_t v20 = v225;
        unint64_t v13 = v228;
        if (v174 <= v240 + v222)
        {
          unint64_t v195 = v221;
          if (v50 + 9 < v221) {
            unint64_t v195 = v50 + 9;
          }
          if (v174 >= v195) {
            goto LABEL_297;
          }
          uint64_t v196 = *(void *)(a6 + 64);
          uint64_t v197 = v196 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v198 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            __int16 v199 = (_WORD *)(v196 + 0x40000 + 4LL * v178);
            __int16 v200 = *(_WORD *)(v197 + 2LL * v198);
            *(_WORD *)(v197 + 2LL * v198) = v178++;
            *(_BYTE *)(v196 + 196608 + (unsigned __int16)v174) = v198;
            unint64_t result = v174 - *(unsigned int *)(v196 + 4LL * v198);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *__int16 v199 = result;
            v199[1] = v200;
            *(_DWORD *)(v196 + 4LL * v198) = v174;
            v12 += 2LL;
            v174 += 2LL;
          }

          while (v174 < v195);
        }

        else
        {
          unint64_t v175 = v220;
          if (v50 + 17 < v220) {
            unint64_t v175 = v50 + 17;
          }
          if (v174 >= v175) {
            goto LABEL_297;
          }
          uint64_t v176 = *(void *)(a6 + 64);
          uint64_t v177 = v176 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v179 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            unsigned int v180 = (_WORD *)(v176 + 0x40000 + 4LL * v178);
            __int16 v181 = *(_WORD *)(v177 + 2LL * v179);
            *(_WORD *)(v177 + 2LL * v179) = v178++;
            *(_BYTE *)(v176 + 196608 + (unsigned __int16)v174) = v179;
            unint64_t result = v174 - *(unsigned int *)(v176 + 4LL * v179);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *unsigned int v180 = result;
            v180[1] = v181;
            *(_DWORD *)(v176 + 4LL * v179) = v174;
            v12 += 4LL;
            v174 += 4LL;
          }

          while (v174 < v175);
        }

LABEL_295:
        *(_WORD *)(a6 + 48) = v178;
        goto LABEL_297;
      }

      uint64_t v11 = a9;
      uint64_t v20 = v225;
      unint64_t v13 = v228;
LABEL_297:
      a2 = v174;
      if (v174 + 4 >= v13) {
        goto LABEL_304;
      }
    }
  }

  uint64_t v20 = a9;
  unint64_t v174 = a2;
LABEL_304:
  *a8 = v12 + v13 - v174;
  *a10 += (v20 - v11) >> 4;
  return result;
}

    a2 = v184;
  }

  while (v184 + 4 < v16);
LABEL_302:
  *a8 = v15 + v16 - v184;
  *a13 += (v23 - v14) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH42( unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, double a9, double a10, int32x4_t a11, uint64_t a12, void *a13, void *a14)
{
  uint64_t v14 = a12;
  uint64_t v253 = *(void *)(a5 + 16);
  unint64_t v15 = *a8;
  unint64_t v16 = a2 + result;
  uint64_t v17 = a2 + result - 3;
  unint64_t v241 = v17;
  if (result <= 3) {
    uint64_t v17 = a2;
  }
  unint64_t v244 = v17;
  int v18 = *(_DWORD *)(a5 + 8);
  uint64_t v19 = 64LL;
  a11.i64[0] = *(void *)a7;
  int32x4_t v20 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)a7, 0), (int32x4_t)xmmword_1810CB570);
  *((int32x4_t *)a7 + 1) = v20;
  *((int32x4_t *)a7 + 2) = vaddq_s32(vzip1q_s32(a11, a11), (int32x4_t)xmmword_1810CB580);
  int32x4_t v21 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)a11.i8, 1), (int32x4_t)xmmword_1810CB590);
  *((int32x4_t *)a7 + 3) = v21;
  if (a2 + 4 >= v16)
  {
    uint64_t v23 = a12;
    unint64_t v184 = a2;
    goto LABEL_302;
  }

  uint64_t v243 = v19;
  unint64_t v267 = (1LL << v18) - 16;
  uint64_t v268 = a3;
  unint64_t v22 = v19 + a2;
  uint64_t v242 = 4 * v19;
  unint64_t v240 = v16 - 4;
  uint64_t v23 = a12;
  uint64_t v251 = a5;
  uint64_t v252 = a6;
  unint64_t v248 = a2 + result;
  uint64_t v254 = a6 + 48;
  do
  {
    unint64_t v259 = v22;
    uint64_t v245 = v23;
    unint64_t v24 = 0LL;
    uint64_t v25 = 0LL;
    unint64_t v26 = 0LL;
    unint64_t v27 = 0LL;
    unint64_t v28 = v16 - a2;
    if (a2 >= v267) {
      unint64_t result = v267;
    }
    else {
      unint64_t result = a2;
    }
    unint64_t v264 = *(void *)(a5 + 80);
    unint64_t v266 = v15;
    uint64_t v29 = *(void *)(a6 + 1080);
    uint64_t v30 = v29 + 196608;
    unint64_t v31 = a2 & a4;
    uint64_t v32 = (unsigned __int8 *)(a3 + (a2 & a4));
    uint64_t v33 = (506832829 * *(_DWORD *)v32) >> 17;
    unint64_t v34 = v28 & 7;
    unint64_t v35 = 2020LL;
    uint64_t v36 = 2020LL;
    do
    {
      unint64_t v37 = a7[v25];
      unint64_t v38 = a2 - v37;
      if ((!v25 || *(unsigned __int8 *)(v30 + (unsigned __int16)(a2 - v37)) == v33)
        && result >= v37
        && v38 < a2)
      {
        uint64_t v40 = v268 + (v38 & a4);
        if (v28 < 8)
        {
          unint64_t v46 = 0LL;
          unint64_t v45 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_32:
          if (v34)
          {
            uint64_t v49 = v29;
            unint64_t v50 = v34 | v46;
            while (*(unsigned __int8 *)(v40 + v46) == *v45)
            {
              ++v45;
              ++v46;
              if (!--v34)
              {
                unint64_t v46 = v50;
                break;
              }
            }

            uint64_t v29 = v49;
            unint64_t v34 = v28 & 7;
          }
        }

        else
        {
          uint64_t v41 = 0LL;
          unint64_t v42 = v28 >> 3;
          while (1)
          {
            uint64_t v43 = *(void *)&v32[v41];
            uint64_t v44 = *(void *)(v40 + v41);
            if (v43 != v44) {
              break;
            }
            v41 += 8LL;
            if (!--v42)
            {
              unint64_t v45 = &v32[v28 & 0xFFFFFFFFFFFFFFF8LL];
              unint64_t v46 = v28 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_32;
            }
          }

          unint64_t v46 = v41 + (__clz(__rbit64(v44 ^ v43)) >> 3);
        }

        if (v46 >= 2)
        {
          unint64_t v47 = 135 * v46 + 1935;
          if (v35 < v47)
          {
            unint64_t v48 = v47 - (((0x1CA10u >> (v25 & 0xE)) & 0xE) + 39);
            if (!v25) {
              unint64_t v48 = 135 * v46 + 1935;
            }
            if (v35 < v48)
            {
              uint64_t v36 = v48;
              unint64_t v27 = a7[v25];
              unint64_t v26 = v46;
              unint64_t v24 = v46;
              unint64_t v35 = v48;
            }
          }
        }
      }

      ++v25;
    }

    while (v25 != 16);
    unint64_t v51 = v267;
    if (a2 + v253 < v267) {
      unint64_t v51 = a2 + v253;
    }
    unint64_t v257 = v51;
    uint64_t v52 = v29 + 0x40000;
    uint64_t v53 = ((unsigned __int16)((506832829 * *(_DWORD *)v32) >> 16) >> 1) & 0x1FF;
    uint64_t v54 = *(void *)(a6 + 1072);
    uint64_t v260 = v29 + 0x20000;
    uint64_t v262 = v29;
    unint64_t v55 = a2;
    unint64_t v56 = a2 - *(unsigned int *)(v29 + 4LL * v33);
    __int16 v57 = *(_WORD *)(v29 + 0x20000 + 2LL * v33);
    if (v54)
    {
      unint64_t v58 = 0LL;
      uint64_t v59 = *(unsigned __int16 *)(v29 + 0x20000 + 2LL * v33);
      unint64_t v60 = v56;
      uint64_t v61 = v52;
      uint64_t v62 = v52 + (v53 << 11);
      do
      {
        v58 += v60;
        if (v58 > result) {
          break;
        }
        if (v24 + v31 <= a4)
        {
          unint64_t v63 = (v55 - v58) & a4;
          if (v63 + v24 <= a4 && *(unsigned __int8 *)(v268 + v24 + v31) == *(unsigned __int8 *)(v268 + v63 + v24))
          {
            uint64_t v64 = v268 + v63;
            if (v28 < 8)
            {
              unint64_t v70 = 0LL;
              unint64_t v69 = v32;
LABEL_71:
              unint64_t v78 = v28 & 7;
              if ((v28 & 7) != 0)
              {
                unint64_t v249 = v28 & 7 | v70;
                while (*(unsigned __int8 *)(v64 + v70) == *v69)
                {
                  ++v69;
                  ++v70;
                  if (!--v78)
                  {
                    unint64_t v70 = v249;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v65 = 0LL;
              unint64_t v66 = v28 >> 3;
              while (1)
              {
                uint64_t v67 = *(void *)&v32[v65];
                uint64_t v68 = *(void *)(v64 + v65);
                if (v67 != v68) {
                  break;
                }
                v65 += 8LL;
                if (!--v66)
                {
                  unint64_t v69 = &v32[v28 & 0xFFFFFFFFFFFFFFF8LL];
                  unint64_t v70 = v28 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_71;
                }
              }

              unint64_t v70 = v65 + (__clz(__rbit64(v68 ^ v67)) >> 3);
            }

            uint64_t v71 = 30 * (__clz(v58) ^ 0x1F);
            unint64_t v72 = 135 * v70 - v71 + 1920;
            if (v35 < v72) {
              uint64_t v73 = 135 * v70 - v71 + 1920;
            }
            else {
              uint64_t v73 = v36;
            }
            if (v35 < v72) {
              unint64_t v74 = v58;
            }
            else {
              unint64_t v74 = v27;
            }
            if (v35 < v72) {
              unint64_t v75 = v70;
            }
            else {
              unint64_t v75 = v26;
            }
            if (v35 < v72) {
              unint64_t v76 = v70;
            }
            else {
              unint64_t v76 = v24;
            }
            if (v35 >= v72) {
              unint64_t v72 = v35;
            }
            if (v70 >= 4)
            {
              uint64_t v36 = v73;
              unint64_t v27 = v74;
              unint64_t v26 = v75;
              unint64_t v24 = v76;
              unint64_t v35 = v72;
            }
          }
        }

        uint64_t v77 = (unsigned __int16 *)(v62 + 4 * v59);
        uint64_t v59 = v77[1];
        unint64_t v60 = *v77;
        --v54;
      }

      while (v54);
    }

    else
    {
      uint64_t v61 = v29 + 0x40000;
    }

    __int16 v79 = *(_WORD *)(v254 + 2 * v53);
    *(_WORD *)(v254 + 2 * v53) = v79 + 1;
    *(_BYTE *)(v30 + (unsigned __int16)v55) = v33;
    uint64_t v80 = v79 & 0x1FF;
    __int16 v81 = -1;
    if (v56 < 0xFFFF) {
      __int16 v81 = v56;
    }
    unint64_t v82 = (__int16 *)(v61 + (v53 << 11) + 4 * v80);
    *unint64_t v82 = v81;
    v82[1] = v57;
    *(_DWORD *)(v262 + 4 * v33) = v55;
    *(_WORD *)(v260 + 2 * v33) = v80;
    if (v36 == 2020)
    {
      a5 = v251;
      a6 = v252;
      uint64_t v83 = *(void *)(v252 + 1088);
      unint64_t v85 = *(void *)(v83 + 8);
      unint64_t v84 = *(void *)(v83 + 16);
      unint64_t v86 = v55;
      if (v84 < v85 >> 7) {
        goto LABEL_215;
      }
      int v250 = 0;
      unint64_t result = ((506832829 * *(_DWORD *)v32) >> 17) & 0x7FFE;
      uint64_t v87 = *(void *)(v251 + 120);
      char v88 = 1;
      unint64_t v89 = v26;
      unint64_t v90 = v27;
      unint64_t v91 = 2020LL;
      do
      {
        char v92 = v88;
        *(void *)(v83 + 8) = ++v85;
        unint64_t v93 = *(unsigned __int8 *)(v87 + result);
        if (!*(_BYTE *)(v87 + result) || v28 < v93) {
          goto LABEL_94;
        }
        uint64_t v94 = *(unsigned __int16 *)(*(void *)(v251 + 112) + 2 * result);
        uint64_t v95 = *(void *)(v251 + 88);
        uint64_t v96 = *(unsigned int *)(v95 + 4 * v93 + 32);
        uint64_t v97 = *(void *)(v95 + 168);
        unsigned int v98 = (unsigned __int8 *)(v97 + v96 + v94 * *(unsigned __int8 *)(v87 + result));
        if (v93 < 8)
        {
          unint64_t v26 = 0LL;
LABEL_99:
          unint64_t v105 = v93 & 7;
          if ((v93 & 7) != 0)
          {
            unint64_t v106 = v26 | v105;
            while (v32[v26] == *v98)
            {
              ++v98;
              ++v26;
              if (!--v105)
              {
                unint64_t v26 = v106;
                break;
              }
            }
          }
        }

        else
        {
          unint64_t v99 = 0LL;
          unint64_t v26 = v93 & 0xF8;
          uint64_t v100 = (unsigned __int8 *)(v97
                                   + v94 * (unint64_t)*(unsigned __int8 *)(v87 + result)
                                   + (*(_BYTE *)(v87 + result) & 0xF8)
                                   + v96);
          while (1)
          {
            uint64_t v101 = *(void *)&v98[v99];
            uint64_t v102 = *(void *)&v32[v99];
            if (v101 != v102) {
              break;
            }
            v99 += 8LL;
            if (v26 == v99)
            {
              unsigned int v98 = v100;
              goto LABEL_99;
            }
          }

          unint64_t v26 = v99 + (__clz(__rbit64(v102 ^ v101)) >> 3);
        }

        if (v26
          && v26 + *(unsigned int *)(v251 + 100) > v93
          && (unint64_t v103 = v257
                   + 1
                   + v94
                   + ((((*(void *)(v251 + 104) >> (6 * (v93 - v26))) & 0x3FLL)
                     + 4 * (v93 - v26)) << *(_BYTE *)(v95 + v93)),
              v103 <= v264)
          && (unsigned int v104 = __clz(v103), 135 * v26 - 30 * (v104 ^ 0x1F) + 1920 >= v91))
        {
          int v250 = v93 - v26;
          *(void *)(v83 + 16) = ++v84;
          unint64_t v91 = 135 * v26 - 30 * (v104 ^ 0x1F) + 1920;
        }

        else
        {
LABEL_94:
          unint64_t v103 = v90;
          unint64_t v26 = v89;
        }

        char v88 = 0;
        ++result;
        unint64_t v89 = v26;
        unint64_t v90 = v103;
      }

      while ((v92 & 1) != 0);
    }

    else
    {
      unint64_t v91 = v36;
      int v250 = 0;
      a5 = v251;
      a6 = v252;
      unint64_t v86 = v55;
      unint64_t v103 = v27;
    }

    if (v91 < 0x7E5)
    {
LABEL_215:
      unint64_t v15 = v266 + 1;
      unint64_t v184 = v86 + 1;
      unint64_t v22 = v259;
      a3 = v268;
      if (v86 + 1 <= v259)
      {
        uint64_t v14 = a12;
        uint64_t v23 = v245;
        unint64_t v16 = v248;
      }

      else
      {
        uint64_t v14 = a12;
        uint64_t v23 = v245;
        unint64_t v16 = v248;
        if (v184 <= v259 + v242)
        {
          unint64_t v208 = v86 + 9;
          if (v86 + 9 >= v241) {
            unint64_t v208 = v241;
          }
          if (v184 < v208)
          {
            uint64_t v209 = *(void *)(a6 + 1080);
            uint64_t v210 = v209 + 0x20000;
            do
            {
              unsigned int v211 = (506832829 * *(_DWORD *)(v268 + (v184 & a4))) >> 17;
              __int16 v212 = *(_WORD *)(v254 + 2LL * (v211 & 0x1FF));
              *(_WORD *)(v254 + 2LL * (v211 & 0x1FF)) = v212 + 1;
              uint64_t v213 = v212 & 0x1FF;
              unint64_t v214 = v184 - *(unsigned int *)(v209 + 4LL * v211);
              unint64_t result = (unsigned __int16)v184;
              *(_BYTE *)(v209 + 196608 + (unsigned __int16)v184) = v211;
              if (v214 >= 0xFFFF) {
                LOWORD(v214) = -1;
              }
              uint64_t v215 = (_WORD *)(v209 + 0x40000 + ((unint64_t)(v211 & 0x1FF) << 11) + 4 * v213);
              *uint64_t v215 = v214;
              __int16 v216 = *(_WORD *)(v210 + 2LL * v211);
              *(_DWORD *)(v209 + 4LL * v211) = v184;
              v215[1] = v216;
              *(_WORD *)(v210 + 2LL * v211) = v213;
              v15 += 2LL;
              v184 += 2LL;
            }

            while (v184 < v208);
          }
        }

        else
        {
          unint64_t v185 = v86 + 17;
          if (v86 + 17 >= v240) {
            unint64_t v185 = v240;
          }
          if (v184 < v185)
          {
            uint64_t v186 = *(void *)(a6 + 1080);
            uint64_t v187 = v186 + 0x20000;
            do
            {
              unsigned int v188 = (506832829 * *(_DWORD *)(v268 + (v184 & a4))) >> 17;
              __int16 v189 = *(_WORD *)(v254 + 2LL * (v188 & 0x1FF));
              *(_WORD *)(v254 + 2LL * (v188 & 0x1FF)) = v189 + 1;
              uint64_t v190 = v189 & 0x1FF;
              unint64_t v191 = v184 - *(unsigned int *)(v186 + 4LL * v188);
              unint64_t result = (unsigned __int16)v184;
              *(_BYTE *)(v186 + 196608 + (unsigned __int16)v184) = v188;
              if (v191 >= 0xFFFF) {
                LOWORD(v191) = -1;
              }
              uint64_t v192 = (_WORD *)(v186 + 0x40000 + ((unint64_t)(v188 & 0x1FF) << 11) + 4 * v190);
              *uint64_t v192 = v191;
              __int16 v193 = *(_WORD *)(v187 + 2LL * v188);
              *(_DWORD *)(v186 + 4LL * v188) = v184;
              v192[1] = v193;
              *(_WORD *)(v187 + 2LL * v188) = v190;
              v15 += 4LL;
              v184 += 4LL;
            }

            while (v184 < v185);
          }
        }
      }

      goto LABEL_295;
    }

    unint64_t v263 = v91;
    unsigned int v107 = 0;
    a3 = v268;
    while (1)
    {
      unsigned int v256 = v107;
      unint64_t v246 = v103;
      unint64_t v247 = v26;
      uint64_t v108 = 0LL;
      unint64_t v109 = 0LL;
      unint64_t v110 = 0LL;
      --v28;
      unint64_t v111 = v26 - 1;
      if (v26 - 1 >= v28) {
        unint64_t v111 = v28;
      }
      else {
        unint64_t result = v111;
      }
      unint64_t v112 = v86 + 1;
      unint64_t v261 = v86;
      if (v86 + 1 < v267) {
        unint64_t v113 = v86 + 1;
      }
      else {
        unint64_t v113 = v267;
      }
      unint64_t v265 = *(void *)(a5 + 80);
      uint64_t v114 = *(void *)(a6 + 1080);
      uint64_t v115 = v114 + 196608;
      uint64_t v116 = v112 & a4;
      unint64_t v117 = (unsigned __int8 *)(a3 + (v112 & a4));
      uint64_t v118 = (506832829 * *(_DWORD *)v117) >> 17;
      unint64_t v119 = 2020LL;
      unint64_t v120 = 2020LL;
      do
      {
        unint64_t v121 = a7[v108];
        unint64_t v122 = v112 - v121;
        if ((!v108 || *(unsigned __int8 *)(v115 + (unsigned __int16)(v112 - v121)) == v118)
          && v113 >= v121
          && v122 < v112)
        {
          uint64_t v124 = a3 + (v122 & a4);
          if (v28 < 8)
          {
            unint64_t v125 = 0LL;
            uint64_t v129 = (unsigned __int8 *)(a3 + (v112 & a4));
LABEL_137:
            if ((v28 & 7) != 0)
            {
              unint64_t v132 = v28 & 7;
              do
              {
                ++v129;
                ++v125;
                --v132;
              }

              while (v132);
            }
          }

          else
          {
            unint64_t v125 = 0LL;
            unint64_t v126 = v28 >> 3;
            while (1)
            {
              uint64_t v127 = *(void *)&v117[v125];
              uint64_t v128 = *(void *)(v124 + v125);
              if (v127 != v128) {
                break;
              }
              v125 += 8LL;
              if (!--v126)
              {
                uint64_t v129 = &v117[v125];
                goto LABEL_137;
              }
            }

            v125 += __clz(__rbit64(v128 ^ v127)) >> 3;
          }

          if (v125 >= 2)
          {
            unint64_t v130 = 135 * v125 + 1935;
            if (v119 < v130)
            {
              unint64_t v131 = v130 - (((0x1CA10u >> (v108 & 0xE)) & 0xE) + 39);
              if (!v108) {
                unint64_t v131 = 135 * v125 + 1935;
              }
              if (v119 < v131)
              {
                unint64_t v120 = v131;
                unint64_t v110 = a7[v108];
                unint64_t v109 = v125;
                unint64_t result = v125;
                unint64_t v119 = v131;
              }
            }
          }
        }

        ++v108;
      }

      while (v108 != 16);
      unint64_t v133 = v267;
      if (v112 + v253 < v267) {
        unint64_t v133 = v112 + v253;
      }
      unint64_t v255 = v133;
      uint64_t v134 = ((unsigned __int16)((506832829 * *(_DWORD *)v117) >> 16) >> 1) & 0x1FF;
      uint64_t v135 = *(void *)(a6 + 1072);
      uint64_t v136 = *(unsigned int *)(v114 + 4LL * v118);
      unint64_t v137 = v112 - v136;
      uint64_t v138 = *(unsigned __int16 *)(v114 + 0x20000 + 2LL * v118);
      __int16 v258 = *(_WORD *)(v114 + 0x20000 + 2LL * v118);
      if (v135)
      {
        unint64_t v139 = 0LL;
        uint64_t v140 = v112 - v136;
        unint64_t v141 = v28 & 7;
        do
        {
          v139 += v140;
          if (v139 > v113) {
            break;
          }
          if (result + v116 <= a4)
          {
            unint64_t v142 = (v112 - v139) & a4;
            if (v142 + result <= a4
              && *(unsigned __int8 *)(a3 + result + v116) == *(unsigned __int8 *)(a3 + v142 + result))
            {
              uint64_t v143 = a3 + v142;
              if (v28 < 8)
              {
                unint64_t v144 = 0LL;
                uint64_t v148 = v117;
LABEL_176:
                while (v141)
                {
                  ++v148;
                  ++v144;
                  --v141;
                }
              }

              else
              {
                unint64_t v144 = 0LL;
                unint64_t v145 = v28 >> 3;
                while (1)
                {
                  uint64_t v146 = *(void *)&v117[v144];
                  uint64_t v147 = *(void *)(v143 + v144);
                  if (v146 != v147) {
                    break;
                  }
                  v144 += 8LL;
                  if (!--v145)
                  {
                    uint64_t v148 = &v117[v144];
                    unint64_t v141 = v28 & 7;
                    goto LABEL_176;
                  }
                }

                v144 += __clz(__rbit64(v147 ^ v146)) >> 3;
              }

              uint64_t v149 = 30 * (__clz(v139) ^ 0x1F);
              unint64_t v150 = 135 * v144 - v149 + 1920;
              if (v119 < v150) {
                uint64_t v151 = 135 * v144 - v149 + 1920;
              }
              else {
                uint64_t v151 = v120;
              }
              if (v119 < v150) {
                unint64_t v152 = v139;
              }
              else {
                unint64_t v152 = v110;
              }
              if (v119 < v150) {
                unint64_t v153 = v144;
              }
              else {
                unint64_t v153 = v109;
              }
              if (v119 < v150) {
                unint64_t v154 = v144;
              }
              else {
                unint64_t v154 = result;
              }
              if (v119 >= v150) {
                unint64_t v150 = v119;
              }
              if (v144 >= 4)
              {
                unint64_t v120 = v151;
                unint64_t v110 = v152;
                unint64_t v109 = v153;
                unint64_t result = v154;
                unint64_t v119 = v150;
              }

              a3 = v268;
              unint64_t v141 = v28 & 7;
            }
          }

          int v155 = (unsigned __int16 *)(v114 + 0x40000 + (v134 << 11) + 4 * v138);
          uint64_t v138 = v155[1];
          uint64_t v140 = *v155;
          --v135;
        }

        while (v135);
      }

      __int16 v156 = *(_WORD *)(v254 + 2 * v134);
      *(_WORD *)(v254 + 2 * v134) = v156 + 1;
      *(_BYTE *)(v115 + (unsigned __int16)v112) = v118;
      uint64_t v157 = v156 & 0x1FF;
      __int16 v158 = -1;
      if (v137 < 0xFFFF) {
        __int16 v158 = v137;
      }
      unint64_t v159 = (__int16 *)(v114 + 0x40000 + (v134 << 11) + 4 * v157);
      *unint64_t v159 = v158;
      v159[1] = v258;
      *(_DWORD *)(v114 + 4 * v118) = v112;
      *(_WORD *)(v114 + 0x20000 + 2 * v118) = v157;
      if (v120 == 2020)
      {
        a5 = v251;
        a6 = v252;
        uint64_t v160 = *(void *)(v252 + 1088);
        unint64_t result = *(void *)(v160 + 8);
        unint64_t v161 = *(void *)(v160 + 16);
        unint64_t v162 = v261;
        int v163 = 0;
        if (v161 < result >> 7)
        {
          unint64_t v120 = 2020LL;
          goto LABEL_186;
        }

        uint64_t v165 = ((506832829 * *(_DWORD *)v117) >> 17) & 0x7FFE;
        uint64_t v166 = *(void *)(v251 + 120);
        char v167 = 1;
        unint64_t v168 = v109;
        unint64_t v169 = v110;
        unint64_t v120 = 2020LL;
        while (1)
        {
          char v170 = v167;
          *(void *)(v160 + 8) = ++result;
          unint64_t v171 = *(unsigned __int8 *)(v166 + v165);
          if (!*(_BYTE *)(v166 + v165) || v28 < v171) {
            goto LABEL_204;
          }
          uint64_t v172 = *(unsigned __int16 *)(*(void *)(v251 + 112) + 2 * v165);
          uint64_t v173 = *(void *)(v251 + 88);
          uint64_t v174 = *(unsigned int *)(v173 + 4 * v171 + 32);
          uint64_t v175 = *(void *)(v173 + 168);
          uint64_t v176 = (unsigned __int8 *)(v175 + v174 + v172 * *(unsigned __int8 *)(v166 + v165));
          if (v171 < 8)
          {
            unint64_t v109 = 0LL;
LABEL_209:
            unint64_t v182 = v171 & 7;
            if ((v171 & 7) != 0)
            {
              unint64_t v183 = v109 | v182;
              while (v117[v109] == *v176)
              {
                ++v176;
                ++v109;
                if (!--v182)
                {
                  unint64_t v109 = v183;
                  break;
                }
              }

              a3 = v268;
            }
          }

          else
          {
            unint64_t v177 = 0LL;
            unint64_t v109 = v171 & 0xF8;
            unsigned __int16 v178 = (unsigned __int8 *)(v175
                                     + v172 * (unint64_t)*(unsigned __int8 *)(v166 + v165)
                                     + (*(_BYTE *)(v166 + v165) & 0xF8)
                                     + v174);
            while (1)
            {
              uint64_t v179 = *(void *)&v176[v177];
              uint64_t v180 = *(void *)&v117[v177];
              if (v179 != v180) {
                break;
              }
              v177 += 8LL;
              if (v109 == v177)
              {
                uint64_t v176 = v178;
                goto LABEL_209;
              }
            }

            unint64_t v109 = v177 + (__clz(__rbit64(v180 ^ v179)) >> 3);
          }

          unint64_t v110 = v255
               + 1
               + v172
          if (v110 <= v265) {
            break;
          }
          unint64_t v110 = v169;
          unint64_t v109 = v168;
          a3 = v268;
LABEL_205:
          char v167 = 0;
          ++v165;
          unint64_t v168 = v109;
          unint64_t v169 = v110;
          if ((v170 & 1) == 0) {
            goto LABEL_186;
          }
        }

        unint64_t v181 = 135 * v109 - 30 * (__clz(v110) ^ 0x1F) + 1920;
        a3 = v268;
        if (v181 >= v120)
        {
          int v163 = v171 - v109;
          *(void *)(v160 + 16) = ++v161;
          unint64_t v120 = v181;
          goto LABEL_205;
        }

LABEL_204:
        unint64_t v110 = v169;
        unint64_t v109 = v168;
        goto LABEL_205;
      }

      int v163 = 0;
      a5 = v251;
      a6 = v252;
      unint64_t v162 = v261;
LABEL_186:
      if (v120 < v263 + 175) {
        break;
      }
      ++v266;
      if (v256 <= 2)
      {
        unint64_t v164 = v162 + 5;
        unsigned int v107 = v256 + 1;
        unint64_t v263 = v120;
        unint64_t v103 = v110;
        unint64_t v26 = v109;
        int v250 = v163;
        unint64_t v86 = v112;
        if (v164 < v248) {
          continue;
        }
      }

      goto LABEL_229;
    }

    unint64_t v194 = v162 + v253;
    if (v162 + v253 >= v267) {
      unint64_t v194 = v267;
    }
    unint64_t v255 = v194;
    unint64_t v110 = v246;
    unint64_t v109 = v247;
    int v163 = v250;
    unint64_t v112 = v162;
LABEL_229:
    unint64_t v16 = v248;
    if (v110 > v255)
    {
LABEL_230:
      unint64_t v195 = v110 + 15;
      goto LABEL_231;
    }

    uint64_t v198 = *a7;
    if (v110 == v198)
    {
      unint64_t v195 = 0LL;
LABEL_236:
      uint64_t v196 = v254;
      goto LABEL_237;
    }

    uint64_t v217 = a7[1];
    if (v110 == v217)
    {
      unint64_t v195 = 1LL;
    }

    else
    {
      unint64_t v218 = v110 + 3 - v198;
      if (v218 > 6)
      {
        unint64_t v221 = v110 + 3 - v217;
        if (v221 > 6)
        {
          if (v110 == a7[2])
          {
            unint64_t v195 = 2LL;
          }

          else
          {
            if (v110 != a7[3]) {
              goto LABEL_230;
            }
            unint64_t v195 = 3LL;
          }

          goto LABEL_231;
        }

        char v219 = 4 * v221;
        unsigned int v220 = 266017486;
      }

      else
      {
        char v219 = 4 * v218;
        unsigned int v220 = 158663784;
      }

      unint64_t v195 = (v220 >> v219) & 0xF;
    }

LABEL_231:
    if (v110 > v255) {
      goto LABEL_236;
    }
    uint64_t v196 = v254;
    if (v195)
    {
      a7[3] = a7[2];
      v21.i64[0] = *(void *)a7;
      *(void *)(a7 + 1) = *(void *)a7;
      *a7 = v110;
      v20.i32[0] = v110;
      int32x4_t v197 = vzip1q_s32(v20, v21);
      int32x4_t v20 = vaddq_s32(vzip1q_s32(v197, v197), (int32x4_t)xmmword_1810CB580);
      *((int32x4_t *)a7 + 1) = vaddq_s32(vdupq_n_s32(v110), (int32x4_t)xmmword_1810CB570);
      *((int32x4_t *)a7 + 2) = v20;
      int32x4_t v21 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v21.i8, 0), (int32x4_t)xmmword_1810CB590);
      *((int32x4_t *)a7 + 3) = v21;
    }

LABEL_237:
    *(_DWORD *)uint64_t v245 = v266;
    *(_DWORD *)(v245 + 4) = v109 | (v163 << 25);
    uint64_t v199 = *(unsigned int *)(a5 + 68);
    uint64_t v200 = v199 + 16;
    if (v199 + 16 <= v195)
    {
      uint64_t v202 = *(unsigned int *)(a5 + 64);
      unint64_t v203 = v195 - v199 + (4LL << v202) - 16;
      uint64_t v204 = (__clz(v203) ^ 0x1F) - 1;
      uint64_t v205 = ((v203 >> v204) & 1 | 2) << v204;
      unint64_t v195 = ((v203 & ~(-1 << v202))
            + v200
            + ((((v203 >> v204) & 1 | (2 * (v204 - v202))) + 65534) << v202)) | ((v204 - v202) << 10);
      unint64_t v201 = (v203 - v205) >> v202;
    }

    else
    {
      LODWORD(v201) = 0;
    }

    *(_WORD *)(v245 + 14) = v195;
    *(_DWORD *)(v245 + 8) = v201;
    if (v266 > 5)
    {
      if (v266 > 0x81)
      {
        if (v266 > 0x841)
        {
          if (v266 >> 1 >= 0xC21)
          {
            if (v266 < 0x5842) {
              LOWORD(v206) = 22;
            }
            else {
              LOWORD(v206) = 23;
            }
          }

          else
          {
            LOWORD(v206) = 21;
          }
        }

        else
        {
          unsigned int v206 = (__clz(v266 - 66) ^ 0x1F) + 10;
        }
      }

      else
      {
        unsigned int v207 = (__clz(v266 - 2) ^ 0x1F) - 1;
        unsigned int v206 = ((v266 - 2) >> v207) + 2 * v207 + 2;
      }
    }

    else
    {
      LOWORD(v206) = v266;
    }

    uint64_t v222 = v163 + (int)v109;
    if (v222 > 9)
    {
      if (v222 > 0x85)
      {
        else {
          unsigned int v223 = (__clz(v222 - 70) ^ 0x1F) + 12;
        }
      }

      else
      {
        unint64_t v224 = v222 - 6;
        unsigned int v225 = (__clz(v224) ^ 0x1F) - 1;
        unsigned int v223 = (v224 >> v225) + 2 * v225 + 4;
      }
    }

    else
    {
      LOWORD(v223) = v163 + v109 - 2;
    }

    int v226 = v223 & 7 | (8 * (v206 & 7));
    if ((v195 & 0x3FF) != 0 || (unsigned __int16)v206 > 7u || (unsigned __int16)v223 > 0xFu)
    {
      int v228 = 3 * ((unsigned __int16)v206 >> 3) + ((unsigned __int16)(v223 & 0xFFF8) >> 3);
      unsigned int v227 = ((((0x520D40u >> (2 * v228)) & 0xC0) + (v228 << 6)) | v226) + 64;
    }

    else
    {
      LOWORD(v227) = v226 | 0x40;
      if ((v223 & 0xFFF8) == 0) {
        LOWORD(v227) = v223 & 7 | (8 * (v206 & 7));
      }
    }

    *(_WORD *)(v245 + 12) = v227;
    *a14 += v266;
    unint64_t v229 = v112 + 2;
    unint64_t v184 = v112 + v109;
    unint64_t v230 = v244;
    if (v112 + v109 < v244) {
      unint64_t v230 = v112 + v109;
    }
    if (v110 < v109 >> 2)
    {
      unint64_t v231 = v184 - 4 * v110;
      if (v229 > v231) {
        unint64_t v231 = v112 + 2;
      }
      if (v230 >= v231) {
        unint64_t v229 = v231;
      }
      else {
        unint64_t v229 = v230;
      }
    }

    unint64_t v22 = v243 + 2 * v109 + v112;
    uint64_t v23 = v245 + 16;
    if (v229 >= v230)
    {
      unint64_t v15 = 0LL;
      uint64_t v14 = a12;
    }

    else
    {
      uint64_t v232 = *(void *)(a6 + 1080);
      uint64_t v233 = v232 + 0x20000;
      do
      {
        unsigned int v234 = (506832829 * *(_DWORD *)(a3 + (v229 & a4))) >> 17;
        __int16 v235 = *(_WORD *)(v196 + 2LL * (v234 & 0x1FF));
        *(_WORD *)(v196 + 2LL * (v234 & 0x1FF)) = v235 + 1;
        uint64_t v236 = v235 & 0x1FF;
        unint64_t v237 = v229 - *(unsigned int *)(v232 + 4LL * v234);
        *(_BYTE *)(v232 + 196608 + (unsigned __int16)v229) = v234;
        if (v237 >= 0xFFFF) {
          LOWORD(v237) = -1;
        }
        unint64_t v238 = (_WORD *)(v232 + 0x40000 + ((unint64_t)(v234 & 0x1FF) << 11) + 4 * v236);
        *unint64_t v238 = v237;
        unint64_t result = *(unsigned __int16 *)(v233 + 2LL * v234);
        v238[1] = result;
        *(_DWORD *)(v232 + 4LL * v234) = v229;
        *(_WORD *)(v233 + 2LL * v234) = v236;
        ++v229;
      }

      while (v230 != v229);
      unint64_t v15 = 0LL;
      uint64_t v14 = a12;
    }

unint64_t CreateBackwardReferencesNH54( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *i, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v130 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v116 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v119 = v14;
  else {
    uint64_t v15 = 64LL;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v118 = v15;
    unint64_t v126 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v117 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    unint64_t result = *(void *)(a6 + 56);
    uint64_t v115 = 4 * v15;
    int8x16_t v17 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
    uint64_t v120 = a9;
    unint64_t v121 = i;
    unint64_t v122 = v13;
    uint64_t v123 = a5;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v126) {
        unint64_t v19 = v126;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      int32x4_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *i;
      if (v11 < v23) {
        goto LABEL_22;
      }
      unint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0LL;
        unint64_t v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_182:
        unint64_t v112 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v113 = v26 | v112;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v112)
            {
              unint64_t v26 = v113;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v25 = 0LL;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8LL));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_182;
          }
        }

        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }

      if (v26 >= 4 && (unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }

      else
      {
LABEL_22:
        unint64_t v23 = 0LL;
        unint64_t v26 = 0LL;
        unint64_t v31 = 2020LL;
      }

      uint64_t v32 = 0LL;
      int64x2_t v33 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00LL * *v21) >> 44);
      int8x16_t v128 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_1810CB550), v17);
      int8x16_t v129 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_1810CB560), v17);
      do
      {
        uint64_t v34 = *(unsigned int *)(result + 4 * v128.i64[v32]);
        unint64_t v35 = v11 - v34;
        if (v22 == *(unsigned __int8 *)(a3 + (v34 & a4) + v26) && v11 != v34 && v35 <= v19)
        {
          uint64_t v38 = a3 + (v34 & a4);
          if (v18 < 8)
          {
            unint64_t v43 = 0LL;
            uint64_t v44 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            unint64_t v46 = v18 & 7;
            if ((v18 & 7) != 0)
            {
              unint64_t v47 = v18 & 7 | v43;
              while (*(unsigned __int8 *)(v38 + v43) == *v44)
              {
                ++v44;
                ++v43;
                if (!--v46)
                {
                  unint64_t v43 = v47;
                  break;
                }
              }

              unint64_t v13 = v122;
              a5 = v123;
            }
          }

          else
          {
            uint64_t v39 = 0LL;
            unint64_t v40 = v18 >> 3;
            while (1)
            {
              uint64_t v41 = v21[v39];
              uint64_t v42 = *(void *)(v38 + v39 * 8);
              if (v41 != v42) {
                break;
              }
              ++v39;
              if (!--v40)
              {
                unint64_t v43 = v18 & 0xFFFFFFFFFFFFFFF8LL;
                uint64_t v44 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8LL);
                goto LABEL_43;
              }
            }

            unint64_t v43 = v39 * 8 + (__clz(__rbit64(v42 ^ v41)) >> 3);
          }

          if (v43 >= 4)
          {
            unsigned int v45 = __clz(v35) ^ 0x1F;
            if (v31 < 135 * v43 - 30 * v45 + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v43 + v20);
              unint64_t v31 = 135 * v43 - 30 * v45 + 1920;
              unint64_t v23 = v35;
              unint64_t v26 = v43;
            }
          }
        }

        ++v32;
      }

      while (v32 != 4);
      *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v128.i64 + (v11 & 0x18))) = v11;
      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v83 = v11 + 1;
        if (v11 + 1 <= v16)
        {
          uint64_t i = v121;
        }

        else if (v83 <= v16 + v115)
        {
          unint64_t v97 = v11 + 9;
          if (v11 + 9 >= v116) {
            unint64_t v97 = v116;
          }
          for (uint64_t i = v121; v83 < v97; v83 += 2LL)
          {
            *(_DWORD *)(result
                      + 4
            v12 += 2LL;
          }
        }

        else
        {
          unint64_t v84 = v11 + 17;
          if (v11 + 17 >= v116) {
            unint64_t v84 = v116;
          }
          for (uint64_t i = v121; v83 < v84; v83 += 4LL)
          {
            *(_DWORD *)(result
                      + 4
            v12 += 4LL;
          }
        }

        goto LABEL_175;
      }

      unsigned int v48 = 0;
      unint64_t v124 = v23;
      uint64_t v125 = *v121;
      while (1)
      {
        --v18;
        unint64_t v49 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v49 = v18;
        }
        unint64_t v50 = *(int *)(a5 + 4) >= 5 ? 0LL : v49;
        unint64_t v51 = v11 + 1;
        unint64_t v52 = v11 + 1 < v126 ? v11 + 1 : v126;
        unint64_t v53 = v51 & a4;
        int v54 = *(unsigned __int8 *)(a3 + v50 + (v51 & a4));
        unint64_t v55 = (void *)(a3 + (v51 & a4));
        unint64_t v127 = v12;
        if (v51 - v125 >= v51)
        {
          unint64_t v63 = 0LL;
          unint64_t v64 = 2020LL;
        }

        else
        {
          unint64_t v56 = a4 & (v51 - v125);
          uint64_t v57 = a3 + v56;
          if (v18 < 8)
          {
            unint64_t v58 = 0LL;
            uint64_t v62 = (unsigned __int8 *)(a3 + (v51 & a4));
LABEL_103:
            unint64_t v82 = v18 & 7;
            if ((v18 & 7) != 0)
            {
              do
              {
                ++v62;
                ++v58;
                --v82;
              }

              while (v82);
            }
          }

          else
          {
            unint64_t v58 = 0LL;
            unint64_t v59 = v18 >> 3;
            while (1)
            {
              uint64_t v60 = *(void *)((char *)v55 + v58);
              uint64_t v61 = *(void *)(v57 + v58);
              if (v60 != v61) {
                break;
              }
              v58 += 8LL;
              if (!--v59)
              {
                uint64_t v62 = (unsigned __int8 *)v55 + v58;
                goto LABEL_103;
              }
            }

            v58 += __clz(__rbit64(v61 ^ v60)) >> 3;
          }

          if (v58 >= 4 && (unint64_t v64 = 135 * v58 + 1935, v64 >= 0x7E5))
          {
            int v54 = *(unsigned __int8 *)(a3 + v58 + v53);
            unint64_t v63 = v125;
            unint64_t v50 = v58;
          }

          else
          {
LABEL_71:
            unint64_t v63 = 0LL;
            unint64_t v64 = 2020LL;
          }
        }

        uint64_t v65 = 0LL;
        int64x2_t v66 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00LL * *v55) >> 44);
        int8x16_t v67 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
        int8x16_t v128 = vandq_s8((int8x16_t)vaddq_s64(v66, (int64x2_t)xmmword_1810CB550), v67);
        int8x16_t v129 = vandq_s8((int8x16_t)vaddq_s64(v66, (int64x2_t)xmmword_1810CB560), v67);
        unint64_t v68 = v18 & 7;
        do
        {
          uint64_t v69 = *(unsigned int *)(result + 4 * v128.i64[v65]);
          unint64_t v70 = v51 - v69;
          if (v54 == *(unsigned __int8 *)(a3 + (v69 & a4) + v50) && v51 != v69 && v70 <= v52)
          {
            uint64_t v73 = a3 + (v69 & a4);
            if (v18 < 8)
            {
              unint64_t v74 = 0LL;
              unint64_t v78 = (unsigned __int8 *)(a3 + (v51 & a4));
LABEL_92:
              if (v68)
              {
                unint64_t v80 = v68;
                while (*(unsigned __int8 *)(v73 + v74) == *v78)
                {
                  ++v78;
                  ++v74;
                  --v80;
                  unint64_t v68 = v18 & 7;
                  if (!v80) {
                    goto LABEL_86;
                  }
                }

                unint64_t v68 = v18 & 7;
              }
            }

            else
            {
              unint64_t v74 = 0LL;
              unint64_t v75 = v18 >> 3;
              while (1)
              {
                uint64_t v76 = *(void *)((char *)v55 + v74);
                uint64_t v77 = *(void *)(v73 + v74);
                if (v76 != v77) {
                  break;
                }
                v74 += 8LL;
                if (!--v75)
                {
                  unint64_t v78 = (unsigned __int8 *)v55 + v74;
                  goto LABEL_92;
                }
              }

              v74 += __clz(__rbit64(v77 ^ v76)) >> 3;
            }

LABEL_86:
            if (v74 >= 4)
            {
              unint64_t v79 = 135 * v74 - 30 * (__clz(v70) ^ 0x1F) + 1920;
              unint64_t v68 = v18 & 7;
              if (v64 < v79)
              {
                int v54 = *(unsigned __int8 *)(a3 + v74 + v53);
                unint64_t v64 = v79;
                unint64_t v63 = v70;
                unint64_t v50 = v74;
              }
            }
          }

          ++v65;
        }

        while (v65 != 4);
        *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v128.i64 + (v51 & 0x18))) = v51;
        a5 = v123;
        if (v64 < v31 + 175) {
          break;
        }
        unint64_t v12 = v127 + 1;
        unint64_t v13 = v122;
        if (v48 <= 2)
        {
          unint64_t v81 = v11 + 9;
          ++v48;
          unint64_t v31 = v64;
          unint64_t v124 = v63;
          unint64_t v26 = v50;
          ++v11;
          if (v81 < v122) {
            continue;
          }
        }

        goto LABEL_115;
      }

      unint64_t v63 = v124;
      unint64_t v50 = v26;
      unint64_t v51 = v11;
      unint64_t v13 = v122;
      unint64_t v12 = v127;
LABEL_115:
      unint64_t v85 = v126;
      if (v51 + v117 < v126) {
        unint64_t v85 = v51 + v117;
      }
      uint64_t i = v121;
      if (v63 > v85) {
        goto LABEL_118;
      }
      uint64_t v90 = *v121;
      if (v63 != v90) {
        break;
      }
      LOWORD(v86) = 0;
      LODWORD(v89) = 0;
      *(_DWORD *)uint64_t v120 = v12;
      *(_DWORD *)(v120 + 4) = v50;
LABEL_128:
      *(_WORD *)(v120 + 14) = v86;
      *(_DWORD *)(v120 + 8) = v89;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v95) = 22;
              }
              else {
                LOWORD(v95) = 23;
              }
            }

            else
            {
              LOWORD(v95) = 21;
            }
          }

          else
          {
            unsigned int v95 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v96 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v95 = ((v12 - 2) >> v96) + 2 * v96 + 2;
        }
      }

      else
      {
        LOWORD(v95) = v12;
      }

      unint64_t v103 = (unint64_t)v50 >> 1;
      if (v103 > 4)
      {
        if (v103 > 0x42)
        {
          if (v103 > 0x422) {
            LOWORD(v104) = 23;
          }
          else {
            unsigned int v104 = (__clz(v50 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v105 = (int)v50 - 6LL;
          unsigned int v106 = (__clz(v105) ^ 0x1F) - 1;
          unsigned int v104 = (v105 >> v106) + 2 * v106 + 4;
        }
      }

      else
      {
        LOWORD(v104) = v50 - 2;
      }

      int v107 = v104 & 7 | (8 * (v95 & 7));
      if ((v86 & 0x3FF) != 0 || (unsigned __int16)v95 > 7u || (unsigned __int16)v104 > 0xFu)
      {
        int v109 = 3 * ((unsigned __int16)v95 >> 3) + ((unsigned __int16)(v104 & 0xFFF8) >> 3);
        unsigned int v108 = ((((0x520D40u >> (2 * v109)) & 0xC0) + (v109 << 6)) | v107) + 64;
      }

      else
      {
        LOWORD(v108) = v107 | 0x40;
        if ((v104 & 0xFFF8) == 0) {
          LOWORD(v108) = v104 & 7 | (8 * (v95 & 7));
        }
      }

      *(_WORD *)(v120 + 12) = v108;
      *a11 += v12;
      unint64_t v110 = v51 + 2;
      unint64_t v83 = v51 + v50;
      unint64_t v111 = v119;
      if (v51 + v50 < v119) {
        unint64_t v111 = v51 + v50;
      }
      if (v63 < v50 >> 2)
      {
        if (v110 <= v83 - 4 * v63) {
          unint64_t v110 = v83 - 4 * v63;
        }
        if (v111 < v110) {
          unint64_t v110 = v111;
        }
      }

      unint64_t v16 = v118 + 2 * v50 + v51;
      v120 += 16LL;
      if (v110 < v111)
      {
        do
        {
          *(_DWORD *)(result
                    + 4
          ++v110;
        }

        while (v111 != v110);
      }

      unint64_t v12 = 0LL;
LABEL_175:
      unint64_t v11 = v83;
      if (v83 + 8 >= v13) {
        goto LABEL_188;
      }
    }

    uint64_t v98 = v121[1];
    if (v63 == v98)
    {
      unint64_t v86 = 1LL;
      goto LABEL_119;
    }

    unint64_t v99 = v63 + 3;
    unint64_t v100 = v63 + 3 - v90;
    if (v100 > 6)
    {
      if (v99 - v98 > 6)
      {
        if (v63 == v121[2])
        {
          unint64_t v86 = 2LL;
        }

        else if (v63 == v121[3])
        {
          unint64_t v86 = 3LL;
        }

        else
        {
LABEL_118:
          unint64_t v86 = v63 + 15;
        }

unint64_t CreateBackwardReferencesNH35( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v172 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v157 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v161 = v14;
  else {
    uint64_t v15 = 64LL;
  }
  if (a2 + 8 < v13)
  {
    unint64_t v166 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v165 = a7;
    uint64_t v159 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    uint64_t v156 = 4 * v15;
    char v158 = v13 - 1;
    uint64_t v17 = *(void *)(a6 + 56);
    uint64_t v18 = a9;
    uint64_t v169 = a6;
    unint64_t v163 = v13;
    uint64_t v160 = v15;
    while (1)
    {
      unint64_t v19 = v13 - v11;
      if (v11 >= v166) {
        unint64_t v20 = v166;
      }
      else {
        unint64_t v20 = v11;
      }
      unint64_t v21 = v11 & a4;
      int v22 = (void *)(a3 + (v11 & a4));
      int v23 = *(unsigned __int8 *)v22;
      unint64_t v24 = *a7;
      uint64_t v162 = v18;
      if (v11 < v24) {
        goto LABEL_22;
      }
      uint64_t v25 = (unsigned __int8 *)(a3 + (a4 & (v11 - v24)));
      if (v23 != *v25) {
        goto LABEL_22;
      }
      unint64_t v167 = *a7;
      if (v19 < 8)
      {
        unint64_t v27 = 0LL;
        unint64_t v28 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_249:
        unint64_t v153 = v19 & 7;
        if ((v19 & 7) != 0)
        {
          unint64_t v154 = v27 | v153;
          while (v25[v27] == *v28)
          {
            ++v28;
            ++v27;
            if (!--v153)
            {
              unint64_t v27 = v154;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v26 = 0LL;
        unint64_t v27 = v19 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v28 = (unsigned __int8 *)(a3 + v21 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
        unint64_t v29 = v19 >> 3;
        while (1)
        {
          uint64_t v30 = v22[v26];
          uint64_t v31 = *(void *)&v25[v26 * 8];
          if (v30 != v31) {
            break;
          }
          ++v26;
          if (!--v29) {
            goto LABEL_249;
          }
        }

        unint64_t v27 = v26 * 8 + (__clz(__rbit64(v31 ^ v30)) >> 3);
      }

      if (v27 >= 4 && (unint64_t v32 = 135 * v27 + 1935, v32 >= 0x7E5))
      {
        int v23 = *(unsigned __int8 *)(a3 + v27 + v21);
      }

      else
      {
LABEL_22:
        unint64_t v167 = 0LL;
        unint64_t v27 = 0LL;
        unint64_t v32 = 2020LL;
      }

      uint64_t v33 = 0LL;
      unint64_t v170 = (0xBD1E35A7BD000000LL * *v22) >> 48;
      uint64_t v171 = (unsigned __int16)(v170 + 8);
      char v34 = 1;
      do
      {
        char v35 = v34;
        uint64_t v36 = *(unsigned int *)(v17 + 4 * *(&v170 + v33));
        unint64_t v37 = v11 - v36;
        if (v23 == *(unsigned __int8 *)(a3 + (v36 & a4) + v27) && v11 != v36 && v37 <= v20)
        {
          uint64_t v40 = a3 + (v36 & a4);
          if (v19 < 8)
          {
            unint64_t v45 = 0LL;
            unint64_t v46 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            if ((v19 & 7) != 0)
            {
              unint64_t v48 = v19 & 7 | v45;
              unint64_t v49 = v19 & 7;
              while (*(unsigned __int8 *)(v40 + v45) == *v46)
              {
                ++v46;
                ++v45;
                if (!--v49)
                {
                  unint64_t v45 = v48;
                  break;
                }
              }

              a6 = v169;
            }

            else
            {
              a6 = v169;
            }
          }

          else
          {
            uint64_t v41 = 0LL;
            unint64_t v42 = v19 >> 3;
            while (1)
            {
              uint64_t v43 = v22[v41];
              uint64_t v44 = *(void *)(v40 + v41 * 8);
              if (v43 != v44) {
                break;
              }
              ++v41;
              if (!--v42)
              {
                unint64_t v45 = v19 & 0xFFFFFFFFFFFFFFF8LL;
                unint64_t v46 = (unsigned __int8 *)v22 + (v19 & 0xFFFFFFFFFFFFFFF8LL);
                goto LABEL_43;
              }
            }

            unint64_t v45 = v41 * 8 + (__clz(__rbit64(v44 ^ v43)) >> 3);
          }

          if (v45 >= 4)
          {
            unint64_t v47 = 135 * v45 - 30 * (__clz(v37) ^ 0x1F) + 1920;
            if (v32 < v47)
            {
              int v23 = *(unsigned __int8 *)(a3 + v45 + v21);
              unint64_t v32 = v47;
              unint64_t v167 = v37;
              unint64_t v27 = v45;
            }
          }
        }

        char v34 = 0;
        uint64_t v33 = 1LL;
      }

      while ((v35 & 1) != 0);
      *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v170 + (v11 & 8))) = v11;
      if ((v11 & 3) != 0)
      {
        unint64_t result = 0xBD1E35A7BD000000LL;
      }

      else
      {
        unint64_t result = 0xBD1E35A7BD000000LL;
        if (v19 >= 0x20)
        {
          unint64_t v50 = *(void *)(a6 + 80);
          if (v50 <= v11)
          {
            int v52 = *(_DWORD *)(a6 + 92);
            int v51 = *(_DWORD *)(a6 + 96);
            int v53 = *(_DWORD *)(a6 + 64);
            do
            {
              int v54 = *(unsigned __int8 *)(a3 + (v50 & a4));
              int v55 = *(unsigned __int8 *)(a3 + ((v50 + 32) & a4));
              if ((v53 & 0x3F000000) == 0)
              {
                uint64_t v56 = *(void *)(a6 + 72);
                uint64_t v57 = *(unsigned int *)(v56 + 4LL * (v53 & 0x3FFFFFFF));
                *(_DWORD *)(v56 + 4LL * (v53 & 0x3FFFFFFF)) = v50;
                if (v50 == v11 && (_DWORD)v57 != -1)
                {
                  unint64_t v58 = (v11 - v57);
                  if (v20 >= v58)
                  {
                    uint64_t v59 = 0LL;
                    uint64_t v60 = a3 + (v57 & a4);
                    unint64_t v61 = v19 >> 3;
                    do
                    {
                      uint64_t v62 = v22[v59];
                      uint64_t v63 = *(void *)(v60 + v59 * 8);
                      if (v62 != v63)
                      {
                        unint64_t v64 = v59 * 8 + (__clz(__rbit64(v63 ^ v62)) >> 3);
                        goto LABEL_67;
                      }

                      ++v59;
                      --v61;
                    }

                    while (v61);
                    unint64_t v64 = v19 & 0xFFFFFFFFFFFFFFF8LL;
                    if ((v19 & 7) != 0)
                    {
                      unint64_t v65 = v19 & 7;
                      unint64_t v64 = v19 & 0xFFFFFFFFFFFFFFF8LL;
                      while (*(unsigned __int8 *)(v60 + v64) == *((unsigned __int8 *)v22 + v64))
                      {
                        ++v64;
                        if (!--v65)
                        {
                          unint64_t v64 = v13 - v11;
                          break;
                        }
                      }
                    }

LABEL_67:
                    unint64_t v66 = 135 * v64 - 30 * (__clz(v58) ^ 0x1F) + 1920;
                    BOOL v67 = v66 > v32;
                    if (v66 <= v32) {
                      unint64_t v66 = v32;
                    }
                    unint64_t v68 = v167;
                    if (v67)
                    {
                      unint64_t v69 = v64;
                    }

                    else
                    {
                      unint64_t v58 = v167;
                      unint64_t v69 = v27;
                    }

                    if (v64 <= v27)
                    {
                      unint64_t v66 = v32;
                      unint64_t v58 = v167;
                      unint64_t v69 = v27;
                    }

                    if (v64 >= 4)
                    {
                      unint64_t v32 = v66;
                      unint64_t v68 = v58;
                    }

                    unint64_t v167 = v68;
                    if (v64 >= 4) {
                      unint64_t v27 = v69;
                    }
                    a6 = v169;
                  }
                }
              }

              int v53 = v55 + v52 * v53 + v51 * ~v54 + 1;
              v50 += 4LL;
            }

            while (v50 <= v11);
            *(_DWORD *)(a6 + 64) = v53;
            unint64_t result = 0xBD1E35A7BD000000LL;
          }

          *(void *)(a6 + 80) = v11 + 4;
        }
      }

      if (v32 < 0x7E5)
      {
        ++v12;
        unint64_t v124 = v11 + 1;
        uint64_t v18 = v162;
        if (v11 + 1 <= v16)
        {
          a7 = v165;
        }

        else
        {
          a7 = v165;
          if (v124 <= v16 + v156)
          {
            unint64_t v138 = v11 + 9;
            if (v138 >= v157) {
              unint64_t v138 = v157;
            }
            while (v124 < v138)
            {
              *(_DWORD *)(v17
                        + 4LL
                        * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v124 & a4))) >> 48) + (v124 & 8))) = v124;
              v12 += 2LL;
              v124 += 2LL;
            }
          }

          else
          {
            unint64_t v125 = v11 + 17;
            if (v125 >= v157) {
              unint64_t v125 = v157;
            }
            while (v124 < v125)
            {
              *(_DWORD *)(v17
                        + 4LL
                        * (unsigned __int16)(((0xBD1E35A7BD000000LL * *(void *)(a3 + (v124 & a4))) >> 48) + (v124 & 8))) = v124;
              v12 += 4LL;
              v124 += 4LL;
            }
          }
        }

        goto LABEL_242;
      }

      unsigned int v70 = 0;
      char v71 = v158 - v11;
      while (1)
      {
        --v19;
        unint64_t v72 = v27 - 1;
        if (v27 - 1 >= v19) {
          unint64_t v72 = v19;
        }
        unint64_t v73 = *(int *)(a5 + 4) >= 5 ? 0LL : v72;
        unint64_t v74 = v11 + 1;
        uint64_t v75 = (v11 + 1) & a4;
        int v76 = *(unsigned __int8 *)(a3 + v73 + v75);
        unint64_t v77 = v11 + 1 < v166 ? v11 + 1 : v166;
        unint64_t v78 = (void *)(a3 + v75);
        unint64_t v79 = *v165;
        if (v74 < v79) {
          goto LABEL_104;
        }
        unint64_t v80 = a4 & (v74 - v79);
        uint64_t v81 = a3 + v80;
        if (v19 < 8)
        {
          unint64_t v82 = 0LL;
          unint64_t v86 = (unsigned __int8 *)(a3 + v75);
LABEL_170:
          unint64_t v123 = v19 & 7;
          if ((v19 & 7) != 0)
          {
            do
            {
              ++v86;
              ++v82;
              --v123;
            }

            while (v123);
          }
        }

        else
        {
          unint64_t v82 = 0LL;
          unint64_t v83 = v19 >> 3;
          while (1)
          {
            uint64_t v84 = *(void *)((char *)v78 + v82);
            uint64_t v85 = *(void *)(v81 + v82);
            if (v84 != v85) {
              break;
            }
            v82 += 8LL;
            if (!--v83)
            {
              unint64_t v86 = (unsigned __int8 *)v78 + v82;
              goto LABEL_170;
            }
          }

          v82 += __clz(__rbit64(v85 ^ v84)) >> 3;
        }

        if (v82 >= 4 && (unint64_t v87 = 135 * v82 + 1935, v87 >= 0x7E5))
        {
          int v76 = *(unsigned __int8 *)(a3 + v82 + v75);
          unint64_t v73 = v82;
        }

        else
        {
LABEL_104:
          unint64_t v79 = 0LL;
          unint64_t v87 = 2020LL;
        }

        uint64_t v88 = 0LL;
        uint64_t v168 = v71 & 7;
        unint64_t v170 = (0xBD1E35A7BD000000LL * *v78) >> 48;
        uint64_t v171 = (unsigned __int16)(v170 + 8);
        char v89 = 1;
        do
        {
          char v90 = v89;
          uint64_t v91 = *(unsigned int *)(v17 + 4 * *(&v170 + v88));
          unint64_t v92 = v74 - v91;
          if (v76 == *(unsigned __int8 *)(a3 + (v91 & a4) + v73) && v74 != v91 && v92 <= v77)
          {
            uint64_t v95 = a3 + (v91 & a4);
            if (v19 < 8)
            {
              unint64_t v96 = 0LL;
              unint64_t v100 = (unsigned __int8 *)(a3 + v75);
LABEL_125:
              unint64_t v102 = v19 & 7;
              if ((v19 & 7) != 0)
              {
                do
                {
                  ++v100;
                  ++v96;
                  --v102;
                }

                while (v102);
              }
            }

            else
            {
              unint64_t v96 = 0LL;
              unint64_t v97 = v19 >> 3;
              while (1)
              {
                uint64_t v98 = *(void *)((char *)v78 + v96);
                uint64_t v99 = *(void *)(v95 + v96);
                if (v98 != v99) {
                  break;
                }
                v96 += 8LL;
                if (!--v97)
                {
                  unint64_t v100 = (unsigned __int8 *)v78 + v96;
                  goto LABEL_125;
                }
              }

              v96 += __clz(__rbit64(v99 ^ v98)) >> 3;
            }

            if (v96 >= 4)
            {
              unint64_t v101 = 135 * v96 - 30 * (__clz(v92) ^ 0x1F) + 1920;
              if (v87 < v101)
              {
                int v76 = *(unsigned __int8 *)(a3 + v96 + v75);
                unint64_t v87 = v101;
                unint64_t v79 = v92;
                unint64_t v73 = v96;
              }
            }
          }

          char v89 = 0;
          uint64_t v88 = 1LL;
        }

        while ((v90 & 1) != 0);
        *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v170 + (v74 & 8))) = v74;
        if (v19 < 0x20)
        {
          a6 = v169;
        }

        else
        {
          a6 = v169;
          if ((v74 & 3) == 0)
          {
            unint64_t v103 = *(void *)(v169 + 80);
            if (v103 <= v74)
            {
              int v104 = *(_DWORD *)(v169 + 92);
              int v105 = *(_DWORD *)(v169 + 96);
              int v106 = *(_DWORD *)(v169 + 64);
              do
              {
                int v107 = *(unsigned __int8 *)(a3 + (v103 & a4));
                int v108 = *(unsigned __int8 *)(a3 + ((v103 + 32) & a4));
                if ((v106 & 0x3F000000) == 0)
                {
                  uint64_t v109 = *(void *)(v169 + 72);
                  uint64_t v110 = *(unsigned int *)(v109 + 4LL * (v106 & 0x3FFFFFFF));
                  *(_DWORD *)(v109 + 4LL * (v106 & 0x3FFFFFFF)) = v103;
                  if (v103 == v74 && (_DWORD)v110 != -1)
                  {
                    unint64_t v111 = (v74 - v110);
                    if (v77 >= v111)
                    {
                      unint64_t v112 = 0LL;
                      uint64_t v113 = a3 + (v110 & a4);
                      unint64_t v114 = v19 >> 3;
                      do
                      {
                        uint64_t v115 = *(void *)((char *)v78 + v112);
                        uint64_t v116 = *(void *)(v113 + v112);
                        if (v115 != v116)
                        {
                          v112 += __clz(__rbit64(v116 ^ v115)) >> 3;
                          goto LABEL_146;
                        }

                        v112 += 8LL;
                        --v114;
                      }

                      while (v114);
                      if ((v19 & 7) != 0)
                      {
                        uint64_t v117 = 0LL;
                        uint64_t v118 = v113 + v112;
                        do
                        {
                          ++v117;
                        }

                        while (v168 != v117);
                        v112 += v117;
                      }

LABEL_242:
      unint64_t v11 = v124;
      if (v124 + 8 >= v13) {
        goto LABEL_255;
      }
    }

    uint64_t v139 = v165[1];
    if (v79 == v139)
    {
      unint64_t v127 = 1LL;
      goto LABEL_185;
    }

    unint64_t v140 = v79 + 3;
    unint64_t v141 = v79 + 3 - v131;
    if (v141 > 6)
    {
      if (v140 - v139 > 6)
      {
        if (v79 == v165[2])
        {
          unint64_t v127 = 2LL;
        }

        else if (v79 == v165[3])
        {
          unint64_t v127 = 3LL;
        }

        else
        {
LABEL_184:
          unint64_t v127 = v79 + 15;
        }

unint64_t CreateBackwardReferencesNH55( unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v172 = *MEMORY[0x1895F89C0];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v156 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v160 = v14;
  else {
    uint64_t v15 = 64LL;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v159 = v15;
    unint64_t v166 = (1LL << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v158 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    unint64_t result = *(void *)(a6 + 56);
    uint64_t v155 = 4 * v15;
    char v157 = v13 - 1;
    int8x16_t v17 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
    unint64_t v161 = a7;
    uint64_t v162 = a9;
    uint64_t v169 = a6;
    unint64_t v163 = v13;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v166) {
        unint64_t v19 = v166;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      unint64_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *a7;
      if (v11 < v23) {
        goto LABEL_22;
      }
      unint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0LL;
        unint64_t v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_253:
        unint64_t v152 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v153 = v26 | v152;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v152)
            {
              unint64_t v26 = v153;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v25 = 0LL;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8LL));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_253;
          }
        }

        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }

      if (v26 >= 4 && (v167 = *a7, unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }

      else
      {
LABEL_22:
        unint64_t v167 = 0LL;
        unint64_t v26 = 0LL;
        unint64_t v31 = 2020LL;
      }

      uint64_t v32 = 0LL;
      int64x2_t v33 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00LL * *v21) >> 44);
      int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_1810CB550), v17);
      int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_1810CB560), v17);
      do
      {
        uint64_t v34 = *(unsigned int *)(result + 4 * v170.i64[v32]);
        unint64_t v35 = v11 - v34;
        if (v22 == *(unsigned __int8 *)(a3 + (v34 & a4) + v26) && v11 != v34 && v35 <= v19)
        {
          uint64_t v38 = a3 + (v34 & a4);
          if (v18 < 8)
          {
            unint64_t v43 = 0LL;
            uint64_t v44 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            if ((v18 & 7) != 0)
            {
              unint64_t v46 = v18 & 7 | v43;
              unint64_t v47 = v18 & 7;
              while (*(unsigned __int8 *)(v38 + v43) == *v44)
              {
                ++v44;
                ++v43;
                if (!--v47)
                {
                  unint64_t v43 = v46;
                  break;
                }
              }

              a7 = v161;
              a6 = v169;
              unint64_t v13 = v163;
            }

            else
            {
              a6 = v169;
            }
          }

          else
          {
            uint64_t v39 = 0LL;
            unint64_t v40 = v18 >> 3;
            while (1)
            {
              uint64_t v41 = v21[v39];
              uint64_t v42 = *(void *)(v38 + v39 * 8);
              if (v41 != v42) {
                break;
              }
              ++v39;
              if (!--v40)
              {
                unint64_t v43 = v18 & 0xFFFFFFFFFFFFFFF8LL;
                uint64_t v44 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8LL);
                goto LABEL_43;
              }
            }

            unint64_t v43 = v39 * 8 + (__clz(__rbit64(v42 ^ v41)) >> 3);
          }

          if (v43 >= 4)
          {
            unsigned int v45 = __clz(v35);
            if (v31 < 135 * v43 - 30 * (v45 ^ 0x1F) + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v43 + v20);
              unint64_t v31 = 135 * v43 - 30 * (v45 ^ 0x1F) + 1920;
              unint64_t v167 = v35;
              unint64_t v26 = v43;
            }
          }
        }

        ++v32;
      }

      while (v32 != 4);
      *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v170.i64 + (v11 & 0x18))) = v11;
      if ((v11 & 3) == 0 && v18 >= 0x20)
      {
        unint64_t v48 = *(void *)(a6 + 80);
        if (v48 <= v11)
        {
          int v49 = *(_DWORD *)(a6 + 92);
          int v50 = *(_DWORD *)(a6 + 96);
          int v51 = *(_DWORD *)(a6 + 64);
          do
          {
            int v52 = *(unsigned __int8 *)(a3 + (v48 & a4));
            int v53 = *(unsigned __int8 *)(a3 + ((v48 + 32) & a4));
            if ((v51 & 0x3F000000) == 0)
            {
              uint64_t v54 = *(void *)(a6 + 72);
              uint64_t v55 = *(unsigned int *)(v54 + 4LL * (v51 & 0x3FFFFFFF));
              *(_DWORD *)(v54 + 4LL * (v51 & 0x3FFFFFFF)) = v48;
              if (v48 == v11 && (_DWORD)v55 != -1)
              {
                unint64_t v56 = (v11 - v55);
                if (v19 >= v56)
                {
                  uint64_t v57 = 0LL;
                  uint64_t v58 = a3 + (v55 & a4);
                  unint64_t v59 = v18 >> 3;
                  do
                  {
                    uint64_t v60 = v21[v57];
                    uint64_t v61 = *(void *)(v58 + v57 * 8);
                    if (v60 != v61)
                    {
                      unint64_t v62 = v57 * 8 + (__clz(__rbit64(v61 ^ v60)) >> 3);
                      goto LABEL_68;
                    }

                    ++v57;
                    --v59;
                  }

                  while (v59);
                  unint64_t v62 = v18 & 0xFFFFFFFFFFFFFFF8LL;
                  if ((v18 & 7) != 0)
                  {
                    unint64_t v63 = v18 & 7;
                    unint64_t v62 = v18 & 0xFFFFFFFFFFFFFFF8LL;
                    while (*(unsigned __int8 *)(v58 + v62) == *((unsigned __int8 *)v21 + v62))
                    {
                      ++v62;
                      if (!--v63)
                      {
                        unint64_t v62 = v18;
                        break;
                      }
                    }

                    a7 = v161;
                  }

LABEL_68:
                  unint64_t v64 = 135 * v62 - 30 * (__clz(v56) ^ 0x1F) + 1920;
                  BOOL v65 = v64 > v31;
                  if (v64 <= v31) {
                    unint64_t v64 = v31;
                  }
                  unint64_t v66 = v167;
                  if (v65) {
                    unint64_t v67 = v56;
                  }
                  else {
                    unint64_t v67 = v167;
                  }
                  if (v65) {
                    unint64_t v68 = v62;
                  }
                  else {
                    unint64_t v68 = v26;
                  }
                  if (v62 <= v26)
                  {
                    unint64_t v64 = v31;
                    unint64_t v67 = v167;
                    unint64_t v68 = v26;
                  }

                  if (v62 >= 4)
                  {
                    unint64_t v31 = v64;
                    unint64_t v66 = v67;
                  }

                  unint64_t v167 = v66;
                  if (v62 >= 4) {
                    unint64_t v26 = v68;
                  }
                  a6 = v169;
                }
              }
            }

            int v51 = v53 + v49 * v51 + v50 * ~v52 + 1;
            v48 += 4LL;
          }

          while (v48 <= v11);
          *(_DWORD *)(a6 + 64) = v51;
          unint64_t v13 = v163;
        }

        *(void *)(a6 + 80) = v11 + 4;
      }

      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v123 = v11 + 1;
        if (v11 + 1 > v16)
        {
          if (v123 <= v16 + v155)
          {
            unint64_t v137 = v11 + 9;
            if (v11 + 9 >= v156) {
              unint64_t v137 = v156;
            }
            for (; v123 < v137; v123 += 2LL)
            {
              *(_DWORD *)(result
                        + 4
              v12 += 2LL;
            }
          }

          else
          {
            unint64_t v124 = v11 + 17;
            if (v11 + 17 >= v156) {
              unint64_t v124 = v156;
            }
            for (; v123 < v124; v123 += 4LL)
            {
              *(_DWORD *)(result
                        + 4
              v12 += 4LL;
            }
          }
        }

        goto LABEL_246;
      }

      unsigned int v69 = 0;
      unint64_t v165 = *a7;
      char v70 = v157 - v11;
      while (1)
      {
        --v18;
        unint64_t v71 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v71 = v18;
        }
        unint64_t v72 = *(int *)(a5 + 4) >= 5 ? 0LL : v71;
        unint64_t v73 = v11 + 1;
        unint64_t v74 = v11 + 1 < v166 ? v11 + 1 : v166;
        unint64_t v75 = v73 & a4;
        int v76 = *(unsigned __int8 *)(a3 + v72 + (v73 & a4));
        unint64_t v77 = (void *)(a3 + (v73 & a4));
        if (v73 < v165) {
          goto LABEL_107;
        }
        unint64_t v78 = a4 & (v73 - v165);
        uint64_t v79 = a3 + v78;
        if (v18 < 8)
        {
          unint64_t v80 = 0LL;
          uint64_t v84 = (unsigned __int8 *)(a3 + (v73 & a4));
LABEL_173:
          unint64_t v122 = v18 & 7;
          if ((v18 & 7) != 0)
          {
            do
            {
              ++v84;
              ++v80;
              --v122;
            }

            while (v122);
          }
        }

        else
        {
          unint64_t v80 = 0LL;
          unint64_t v81 = v18 >> 3;
          while (1)
          {
            uint64_t v82 = *(void *)((char *)v77 + v80);
            uint64_t v83 = *(void *)(v79 + v80);
            if (v82 != v83) {
              break;
            }
            v80 += 8LL;
            if (!--v81)
            {
              uint64_t v84 = (unsigned __int8 *)v77 + v80;
              goto LABEL_173;
            }
          }

          v80 += __clz(__rbit64(v83 ^ v82)) >> 3;
        }

        if (v80 >= 4 && (unint64_t v85 = 135 * v80 + 1935, v85 >= 0x7E5))
        {
          int v76 = *(unsigned __int8 *)(a3 + v80 + v75);
          unint64_t v86 = v165;
          unint64_t v72 = v80;
        }

        else
        {
LABEL_107:
          unint64_t v86 = 0LL;
          unint64_t v85 = 2020LL;
        }

        uint64_t v87 = 0LL;
        uint64_t v168 = v70 & 7;
        int64x2_t v88 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00LL * *v77) >> 44);
        int8x16_t v89 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
        int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v88, (int64x2_t)xmmword_1810CB550), v89);
        int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v88, (int64x2_t)xmmword_1810CB560), v89);
        do
        {
          uint64_t v90 = *(unsigned int *)(result + 4 * v170.i64[v87]);
          unint64_t v91 = v73 - v90;
          if (v76 == *(unsigned __int8 *)(a3 + (v90 & a4) + v72) && v73 != v90 && v91 <= v74)
          {
            uint64_t v94 = a3 + (v90 & a4);
            if (v18 < 8)
            {
              unint64_t v95 = 0LL;
              uint64_t v99 = (unsigned __int8 *)(a3 + (v73 & a4));
LABEL_128:
              unint64_t v101 = v18 & 7;
              if ((v18 & 7) != 0)
              {
                do
                {
                  ++v99;
                  ++v95;
                  --v101;
                }

                while (v101);
              }
            }

            else
            {
              unint64_t v95 = 0LL;
              unint64_t v96 = v18 >> 3;
              while (1)
              {
                uint64_t v97 = *(void *)((char *)v77 + v95);
                uint64_t v98 = *(void *)(v94 + v95);
                if (v97 != v98) {
                  break;
                }
                v95 += 8LL;
                if (!--v96)
                {
                  uint64_t v99 = (unsigned __int8 *)v77 + v95;
                  goto LABEL_128;
                }
              }

              v95 += __clz(__rbit64(v98 ^ v97)) >> 3;
            }

            if (v95 >= 4)
            {
              unsigned int v100 = __clz(v91) ^ 0x1F;
              if (v85 < 135 * v95 - 30 * v100 + 1920)
              {
                int v76 = *(unsigned __int8 *)(a3 + v95 + v75);
                unint64_t v85 = 135 * v95 - 30 * v100 + 1920;
                unint64_t v86 = v91;
                unint64_t v72 = v95;
              }
            }
          }

          ++v87;
        }

        while (v87 != 4);
        *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v170.i64 + (v73 & 0x18))) = v73;
        if (v18 < 0x20)
        {
          a6 = v169;
        }

        else
        {
          a6 = v169;
          if ((v73 & 3) == 0)
          {
            unint64_t v102 = *(void *)(v169 + 80);
            if (v102 <= v73)
            {
              int v103 = *(_DWORD *)(v169 + 92);
              int v104 = *(_DWORD *)(v169 + 96);
              int v105 = *(_DWORD *)(v169 + 64);
              do
              {
                int v106 = *(unsigned __int8 *)(a3 + (v102 & a4));
                int v107 = *(unsigned __int8 *)(a3 + ((v102 + 32) & a4));
                if ((v105 & 0x3F000000) == 0)
                {
                  uint64_t v108 = *(void *)(v169 + 72);
                  uint64_t v109 = *(unsigned int *)(v108 + 4LL * (v105 & 0x3FFFFFFF));
                  *(_DWORD *)(v108 + 4LL * (v105 & 0x3FFFFFFF)) = v102;
                  if (v102 == v73 && (_DWORD)v109 != -1)
                  {
                    unint64_t v110 = (v73 - v109);
                    if (v74 >= v110)
                    {
                      unint64_t v111 = 0LL;
                      uint64_t v112 = a3 + (v109 & a4);
                      unint64_t v113 = v18 >> 3;
                      do
                      {
                        uint64_t v114 = *(void *)((char *)v77 + v111);
                        uint64_t v115 = *(void *)(v112 + v111);
                        if (v114 != v115)
                        {
                          v111 += __clz(__rbit64(v115 ^ v114)) >> 3;
                          goto LABEL_149;
                        }

                        v111 += 8LL;
                        --v113;
                      }

                      while (v113);
                      if ((v18 & 7) != 0)
                      {
                        uint64_t v116 = 0LL;
                        uint64_t v117 = v112 + v111;
                        do
                        {
                          ++v116;
                        }

                        while (v168 != v116);
                        v111 += v116;
                      }

LABEL_149:
                      unint64_t v118 = 135 * v111 - 30 * (__clz(v110) ^ 0x1F) + 1920;
                      if (v118 > v85)
                      {
                        unint64_t v119 = v111;
                      }

                      else
                      {
                        unint64_t v118 = v85;
                        unint64_t v110 = v86;
                        unint64_t v119 = v72;
                      }

                      BOOL v120 = v111 >= 4 && v111 > v72;
                      if (v120) {
                        unint64_t v85 = v118;
                      }
                      if (v120) {
                        unint64_t v86 = v110;
                      }
                      if (v120) {
                        unint64_t v72 = v119;
                      }
                    }
                  }
                }

                int v105 = v107 + v103 * v105 + v104 * ~v106 + 1;
                v102 += 4LL;
              }

              while (v102 <= v73);
              a6 = v169;
              *(_DWORD *)(v169 + 64) = v105;
            }

            *(void *)(a6 + 80) = v11 + 5;
          }
        }

        if (v85 < v31 + 175) {
          break;
        }
        ++v12;
        if (v69 <= 2)
        {
          unint64_t v121 = v11 + 9;
          ++v69;
          char v70 = v168 + 7;
          unint64_t v31 = v85;
          unint64_t v167 = v86;
          unint64_t v26 = v72;
          ++v11;
          if (v121 < v163) {
            continue;
          }
        }

        goto LABEL_185;
      }

      unint64_t v86 = v167;
      unint64_t v72 = v26;
      unint64_t v73 = v11;
LABEL_185:
      unint64_t v125 = v166;
      if (v73 + v158 < v166) {
        unint64_t v125 = v73 + v158;
      }
      if (v86 > v125) {
        goto LABEL_188;
      }
      uint64_t v130 = *v161;
      if (v86 != v130) {
        break;
      }
      LOWORD(v126) = 0;
      LODWORD(v129) = 0;
      *(_DWORD *)uint64_t v162 = v12;
      *(_DWORD *)(v162 + 4) = v72;
LABEL_197:
      *(_WORD *)(v162 + 14) = v126;
      *(_DWORD *)(v162 + 8) = v129;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v135) = 22;
              }
              else {
                LOWORD(v135) = 23;
              }
            }

            else
            {
              LOWORD(v135) = 21;
            }
          }

          else
          {
            unsigned int v135 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v136 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v135 = ((v12 - 2) >> v136) + 2 * v136 + 2;
        }
      }

      else
      {
        LOWORD(v135) = v12;
      }

      unint64_t v143 = (unint64_t)v72 >> 1;
      if (v143 > 4)
      {
        if (v143 > 0x42)
        {
          if (v143 > 0x422) {
            LOWORD(v144) = 23;
          }
          else {
            unsigned int v144 = (__clz(v72 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v145 = (int)v72 - 6LL;
          unsigned int v146 = (__clz(v145) ^ 0x1F) - 1;
          unsigned int v144 = (v145 >> v146) + 2 * v146 + 4;
        }
      }

      else
      {
        LOWORD(v144) = v72 - 2;
      }

      int v147 = v144 & 7 | (8 * (v135 & 7));
      if ((v126 & 0x3FF) != 0 || (unsigned __int16)v135 > 7u || (unsigned __int16)v144 > 0xFu)
      {
        int v149 = 3 * ((unsigned __int16)v135 >> 3) + ((unsigned __int16)(v144 & 0xFFF8) >> 3);
        unsigned int v148 = ((((0x520D40u >> (2 * v149)) & 0xC0) + (v149 << 6)) | v147) + 64;
      }

      else
      {
        LOWORD(v148) = v147 | 0x40;
        if ((v144 & 0xFFF8) == 0) {
          LOWORD(v148) = v144 & 7 | (8 * (v135 & 7));
        }
      }

      *(_WORD *)(v162 + 12) = v148;
      *a11 += v12;
      unint64_t v150 = v73 + 2;
      unint64_t v123 = v73 + v72;
      unint64_t v151 = v160;
      if (v73 + v72 < v160) {
        unint64_t v151 = v73 + v72;
      }
      if (v86 < v72 >> 2)
      {
        if (v150 <= v123 - 4 * v86) {
          unint64_t v150 = v123 - 4 * v86;
        }
        if (v151 < v150) {
          unint64_t v150 = v151;
        }
      }

      unint64_t v16 = v159 + 2 * v72 + v73;
      v162 += 16LL;
      if (v150 >= v151)
      {
        unint64_t v12 = 0LL;
        a7 = v161;
        unint64_t v13 = v163;
      }

      else
      {
        a7 = v161;
        unint64_t v13 = v163;
        do
        {
          *(_DWORD *)(result
                    + 4
          ++v150;
        }

        while (v151 != v150);
        unint64_t v12 = 0LL;
      }

    uint64_t v168 = *(unsigned int *)(v1 + 104);
    if ((_DWORD)v168)
    {
      uint64_t v169 = 0LL;
      int8x16_t v170 = 0LL;
      int8x16_t v171 = *(void *)(v1 + 136);
      do
      {
        uint64_t v172 = *(unsigned int *)(v171 + 4 * v169);
        if (!(_DWORD)v172)
        {
          *(_DWORD *)(v171 + 4 * v169) = v170;
          uint64_t v168 = *(unsigned int *)(v1 + 104);
          uint64_t v172 = v170;
        }

        ++v169;
        int8x16_t v170 = v172;
      }

      while (v169 < v168);
    }

    *(_DWORD *)(v1 + 108) = v231;
    *(void *)(v1 + 40) = v230;
    return 4294967294LL;
  }

  uint64_t v179 = 0;
  unsigned __int16 v178 = 0LL;
  unsigned int v223 = 0LL;
  unint64_t v224 = 0LL;
  unsigned int v225 = 0LL;
LABEL_180:
  unint64_t result = 0LL;
  *unint64_t v167 = v178;
  int v226 = (char *)v167 + ((v179 + 7) >> 3);
  unsigned int v227 = ((_DWORD)v226 - *(_DWORD *)(v1 + 40));
  *(void *)(v1 + 40) = v226;
  *(void *)(v1 + 104) = 0LL;
  int v228 = v234;
  *(_DWORD *)uint64_t v232 = 846755426;
  *(_DWORD *)(v232 + 4) = v228;
  unint64_t v229 = (unsigned __int16)v239 | (unint64_t)(v227 << 40) | ((unint64_t)WORD1(v239) << 10) | ((unint64_t)WORD2(v239) << 20) | ((unint64_t)HIWORD(v239) << 30);
  *(void *)(v232 + 8) = v235 | ((unint64_t)v237 << 20) | ((unint64_t)v236 << 40) | ((unint64_t)(v238 + 7) << 60);
  *(void *)(v232 + 16) = v229 | ((unint64_t)(v179 - ((v179 + 7) & 8u) + 7) << 60);
  *(void *)(v232 + 24) |= v223 | v224 | v225;
  return result;
}

LABEL_246:
      unint64_t v11 = v123;
      if (v123 + 8 >= v13) {
        goto LABEL_259;
      }
    }

    uint64_t v138 = v161[1];
    if (v86 == v138)
    {
      unint64_t v126 = 1LL;
      goto LABEL_189;
    }

    unint64_t v139 = v86 + 3;
    unint64_t v140 = v86 + 3 - v130;
    if (v140 > 6)
    {
      if (v139 - v138 > 6)
      {
        if (v86 == v161[2])
        {
          unint64_t v126 = 2LL;
        }

        else if (v86 == v161[3])
        {
          unint64_t v126 = 3LL;
        }

        else
        {
LABEL_188:
          unint64_t v126 = v86 + 15;
        }

LABEL_189:
        if (v86 <= v125 && v126)
        {
          v161[3] = v161[2];
          *(void *)(v161 + 1) = *(void *)v161;
          *unint64_t v161 = v86;
        }

        *(_DWORD *)uint64_t v162 = v12;
        *(_DWORD *)(v162 + 4) = v72;
        uint64_t v127 = *(unsigned int *)(a5 + 68);
        uint64_t v128 = v127 + 16;
        if (v127 + 16 <= v126)
        {
          uint64_t v131 = *(unsigned int *)(a5 + 64);
          unint64_t v132 = v126 - v127 + (4LL << v131) - 16;
          uint64_t v133 = (__clz(v132) ^ 0x1F) - 1;
          uint64_t v134 = ((v132 >> v133) & 1 | 2) << v133;
          unint64_t v126 = ((v132 & ~(-1 << v131))
                + v128
                + ((((v132 >> v133) & 1 | (2 * (v133 - v131))) + 65534) << v131)) | ((v133 - v131) << 10);
          unint64_t v129 = (v132 - v134) >> v131;
        }

        else
        {
          LODWORD(v129) = 0;
        }

        goto LABEL_197;
      }

      char v141 = 4 * (v139 - v138);
      unsigned int v142 = 266017486;
    }

    else
    {
      char v141 = 4 * v140;
      unsigned int v142 = 158663784;
    }

    unint64_t v126 = (v142 >> v141) & 0xF;
    goto LABEL_189;
  }

  uint64_t v162 = a9;
  unint64_t v123 = a2;
LABEL_259:
  *a8 = v12 + v13 - v123;
  *a10 += (v162 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH65( unint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, _DWORD *a9, void *a10, void *a11)
{
  uint64_t v12 = a5;
  unint64_t v13 = a2;
  uint64_t v274 = *(void *)(a5 + 16);
  unint64_t v14 = *a8;
  unint64_t v15 = a2 + result;
  unint64_t v265 = a2 + result - 7;
  if (result <= 7) {
    uint64_t v16 = a2;
  }
  else {
    uint64_t v16 = a2 + result - 7;
  }
  int v17 = *(_DWORD *)(v12 + 8);
  uint64_t v18 = 512LL;
  unint64_t v267 = v16;
  uint64_t v268 = v18;
  int v19 = *(_DWORD *)(a6 + 88);
  if (v19 >= 5)
  {
    int32x4_t v20 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v20, (int32x4_t)xmmword_1810CB570);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v19 >= 0xB)
    {
      unint64_t v21 = (const float *)(a7 + 1);
      int32x4_t v22 = (int32x4_t)vld1q_dup_f32(v21);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v22, (int32x4_t)xmmword_1810CB570);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v22.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }

  if (a2 + 8 < v15)
  {
    unint64_t v23 = v18 + a2;
    unint64_t v273 = (1LL << v17) - 16;
    uint64_t v264 = 4 * v18;
    char v266 = v13 + result - 1;
    uint64_t v269 = a9;
    uint64_t v287 = v12;
    uint64_t v279 = a6;
    unint64_t v271 = v15;
    uint64_t v285 = *(void *)(a6 + 104);
    unint64_t v275 = *(void *)(a6 + 72);
    uint64_t v276 = *(void *)(a6 + 112);
    while (1)
    {
      unint64_t v288 = v23;
      unint64_t v284 = v14;
      unint64_t v24 = v15 - v13;
      if (v13 >= v273) {
        unint64_t v25 = v273;
      }
      else {
        unint64_t v25 = v13;
      }
      if (v13 + v274 >= v273) {
        unint64_t v26 = v273;
      }
      else {
        unint64_t v26 = v13 + v274;
      }
      unint64_t v27 = v13 & a4;
      uint64_t v28 = *(int *)(a6 + 88);
      if ((_DWORD)v28)
      {
        unint64_t v29 = 0LL;
        unint64_t v30 = 0LL;
        unint64_t v31 = 0LL;
        unint64_t v32 = 0LL;
        unint64_t result = 2020LL;
        unint64_t v286 = 2020LL;
        do
        {
          unint64_t v33 = a7[v30];
          unint64_t v34 = v13 - v33;
          BOOL v35 = v25 < v33 || v34 >= v13;
          uint64_t v36 = v34 & a4;
          unint64_t v37 = v29 + v27;
          BOOL v38 = v35 || v37 > a4;
          unint64_t v39 = v36 + v29;
          BOOL v40 = v38 || v39 > a4;
          if (!v40 && *(unsigned __int8 *)(a3 + v37) == *(unsigned __int8 *)(a3 + v39))
          {
            uint64_t v41 = a3 + v36;
            if (v24 < 8)
            {
              unint64_t v46 = 0LL;
              unint64_t v47 = (unsigned __int8 *)(a3 + v27);
LABEL_50:
              if ((v24 & 7) != 0)
              {
                unint64_t v50 = v32;
                unint64_t v51 = v31;
                unint64_t v52 = v24 & 7 | v46;
                unint64_t v53 = v24 & 7;
                while (*(unsigned __int8 *)(v41 + v46) == *v47)
                {
                  ++v47;
                  ++v46;
                  if (!--v53)
                  {
                    unint64_t v46 = v52;
                    break;
                  }
                }

                unint64_t v31 = v51;
                unint64_t v32 = v50;
              }
            }

            else
            {
              uint64_t v42 = 0LL;
              unint64_t v43 = v24 >> 3;
              while (1)
              {
                uint64_t v44 = *(void *)(a3 + v27 + v42);
                uint64_t v45 = *(void *)(v41 + v42);
                if (v44 != v45) {
                  break;
                }
                v42 += 8LL;
                if (!--v43)
                {
                  unint64_t v46 = v24 & 0xFFFFFFFFFFFFFFF8LL;
                  unint64_t v47 = (unsigned __int8 *)(a3 + v27 + (v24 & 0xFFFFFFFFFFFFFFF8LL));
                  goto LABEL_50;
                }
              }

              unint64_t v46 = v42 + (__clz(__rbit64(v45 ^ v44)) >> 3);
            }

            if (v46 > 2 || v30 <= 1 && v46 == 2)
            {
              unint64_t v48 = 135 * v46 + 1935;
              if (result < v48)
              {
                if (v30) {
                  v48 -= ((0x1CA10u >> (v30 & 0xE)) & 0xE) + 39;
                }
                unint64_t v49 = v286;
                if (result < v48) {
                  unint64_t v49 = v48;
                }
                unint64_t v286 = v49;
                if (result < v48)
                {
                  unint64_t v32 = a7[v30];
                  unint64_t v31 = v46;
                  unint64_t v29 = v46;
                  unint64_t result = v48;
                }
              }
            }
          }

          ++v30;
        }

        while (v30 != v28);
      }

      else
      {
        unint64_t v32 = 0LL;
        unint64_t v31 = 0LL;
        unint64_t v29 = 0LL;
        unint64_t v286 = 2020LL;
        unint64_t result = 2020LL;
      }

      unint64_t v280 = *(void *)(v12 + 80);
      uint64_t v54 = (_DWORD *)(a3 + v27);
      unint64_t v55 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + v27) & v275)) >> *(_DWORD *)(a6 + 64);
      uint64_t v56 = *(unsigned int *)(a6 + 80);
      uint64_t v57 = v276 + 4LL * ((_DWORD)v55 << *(_DWORD *)(a6 + 84));
      unint64_t v58 = *(unsigned __int16 *)(v285 + 2LL * v55);
      unint64_t v272 = *(void *)(a6 + 56);
      if (v58 >= v272) {
        unint64_t v59 = v58 - v272;
      }
      else {
        unint64_t v59 = 0LL;
      }
      if (v59 < v58)
      {
        unint64_t v60 = *(unsigned __int16 *)(v285 + 2LL * v55);
        do
        {
          uint64_t v61 = *(unsigned int *)(v57 + 4 * (--v60 & v56));
          unint64_t v62 = v13 - v61;
          if (v13 - v61 > v25) {
            break;
          }
          if (v29 + v27 <= a4)
          {
            uint64_t v63 = v61 & a4;
            if (v63 + v29 <= a4 && *(unsigned __int8 *)(a3 + v29 + v27) == *(unsigned __int8 *)(a3 + v63 + v29))
            {
              uint64_t v64 = a3 + v63;
              if (v24 < 8)
              {
                unint64_t v69 = 0LL;
                char v70 = (unsigned __int8 *)(a3 + v27);
LABEL_78:
                if ((v24 & 7) != 0)
                {
                  unint64_t v281 = v24 & 7 | v69;
                  unint64_t v72 = v24 & 7;
                  while (*(unsigned __int8 *)(v64 + v69) == *v70)
                  {
                    ++v70;
                    ++v69;
                    if (!--v72)
                    {
                      unint64_t v69 = v281;
                      break;
                    }
                  }

                  a6 = v279;
                }
              }

              else
              {
                uint64_t v65 = 0LL;
                unint64_t v66 = v24 >> 3;
                while (1)
                {
                  uint64_t v67 = *(void *)&v54[v65];
                  uint64_t v68 = *(void *)(v64 + v65 * 4);
                  if (v67 != v68) {
                    break;
                  }
                  v65 += 2LL;
                  if (!--v66)
                  {
                    unint64_t v69 = v24 & 0xFFFFFFFFFFFFFFF8LL;
                    char v70 = (unsigned __int8 *)v54 + (v24 & 0xFFFFFFFFFFFFFFF8LL);
                    goto LABEL_78;
                  }
                }

                unint64_t v69 = v65 * 4 + (__clz(__rbit64(v68 ^ v67)) >> 3);
              }

              uint64_t v12 = v287;
              if (v69 >= 4)
              {
                unsigned int v71 = __clz(v62) ^ 0x1F;
                if (result < 135 * v69 - 30 * v71 + 1920)
                {
                  unint64_t v286 = 135 * v69 - 30 * v71 + 1920;
                  unint64_t v32 = v62;
                  unint64_t v31 = v69;
                  unint64_t v29 = v69;
                  unint64_t result = v286;
                }
              }
            }
          }
        }

        while (v60 > v59);
      }

      *(_DWORD *)(v57 + 4LL * (v56 & v58)) = v13;
      *(_WORD *)(v285 + 2LL * v55) = v58 + 1;
      unint64_t v73 = v31;
      if (v286 == 2020)
      {
        uint64_t v74 = *(void *)(a6 + 96);
        unint64_t result = *(void *)(v74 + 8);
        unint64_t v75 = *(void *)(v74 + 16);
        if (v75 >= result >> 7)
        {
          int v278 = 0;
          uint64_t v208 = ((506832829 * *v54) >> 17) & 0x7FFE;
          uint64_t v209 = *(void *)(v12 + 120);
          unint64_t v210 = v26 + 1;
          char v211 = 1;
          unint64_t v212 = v31;
          unint64_t v213 = v32;
          unint64_t v286 = 2020LL;
          do
          {
            char v214 = v211;
            *(void *)(v74 + 8) = ++result;
            unint64_t v215 = *(unsigned __int8 *)(v209 + v208);
            if (!*(_BYTE *)(v209 + v208) || v24 < v215) {
              goto LABEL_295;
            }
            uint64_t v216 = *(unsigned __int16 *)(*(void *)(v12 + 112) + 2 * v208);
            uint64_t v217 = *(void *)(v12 + 88);
            uint64_t v218 = *(unsigned int *)(v217 + 4 * v215 + 32);
            uint64_t v219 = *(void *)(v217 + 168);
            unsigned int v220 = (unsigned __int8 *)(v219 + v218 + v216 * *(unsigned __int8 *)(v209 + v208));
            if (v215 < 8)
            {
              unint64_t v73 = 0LL;
LABEL_310:
              unint64_t v226 = v215 & 7;
              if ((v215 & 7) != 0)
              {
                unint64_t v227 = v73 | v226;
                while (*((unsigned __int8 *)v54 + v73) == *v220)
                {
                  ++v220;
                  ++v73;
                  if (!--v226)
                  {
                    unint64_t v73 = v227;
                    break;
                  }
                }
              }
            }

            else
            {
              unint64_t v221 = 0LL;
              uint64_t v222 = (unsigned __int8 *)(v219
                                       + v216 * (unint64_t)*(unsigned __int8 *)(v209 + v208)
                                       + (*(_BYTE *)(v209 + v208) & 0xF8)
                                       + v218);
              while (1)
              {
                uint64_t v223 = *(void *)&v220[v221];
                uint64_t v224 = *(void *)&v54[v221 / 4];
                if (v223 != v224) {
                  break;
                }
                v221 += 8LL;
                if ((v215 & 0xF8) == v221)
                {
                  unsigned int v220 = v222;
                  unint64_t v73 = v215 & 0xF8;
                  goto LABEL_310;
                }
              }

              unint64_t v73 = v221 + (__clz(__rbit64(v224 ^ v223)) >> 3);
            }

            if (v73
              && v73 + *(unsigned int *)(v12 + 100) > v215
              && (unint64_t v32 = v210
                      + v216
                      + ((((*(void *)(v12 + 104) >> (6 * (v215 - v73))) & 0x3FLL)
                        + 4 * (v215 - v73)) << *(_BYTE *)(v217 + v215)),
                  v32 <= v280)
              && (unint64_t v225 = 135 * v73 - 30 * (__clz(v32) ^ 0x1F) + 1920, v225 >= v286))
            {
              int v278 = v215 - v73;
              *(void *)(v74 + 16) = ++v75;
              unint64_t v286 = v225;
            }

            else
            {
LABEL_295:
              unint64_t v32 = v213;
              unint64_t v73 = v212;
            }

            char v211 = 0;
            ++v208;
            unint64_t v212 = v73;
            unint64_t v213 = v32;
          }

          while ((v214 & 1) != 0);
        }

        else
        {
          int v278 = 0;
          unint64_t v286 = 2020LL;
        }
      }

      else
      {
        int v278 = 0;
      }

      if (v24 >= 0x20)
      {
        unint64_t v76 = *(void *)(a6 + 136);
        if (v76 <= v13)
        {
          int v77 = *(_DWORD *)(a6 + 148);
          int v78 = *(_DWORD *)(a6 + 152);
          int v79 = *(_DWORD *)(a6 + 120);
          do
          {
            unint64_t result = *(unsigned __int8 *)(a3 + (v76 & a4));
            int v80 = *(unsigned __int8 *)(a3 + ((v76 + 32) & a4));
            if ((v79 & 0x3F000000) == 0)
            {
              uint64_t v81 = *(void *)(a6 + 128);
              uint64_t v82 = *(unsigned int *)(v81 + 4LL * (v79 & 0x3FFFFFFF));
              *(_DWORD *)(v81 + 4LL * (v79 & 0x3FFFFFFF)) = v76;
              if (v76 == v13 && (_DWORD)v82 != -1)
              {
                unint64_t v83 = (v13 - v82);
                if (v25 >= v83)
                {
                  uint64_t v84 = 0LL;
                  uint64_t v85 = a3 + (v82 & a4);
                  unint64_t v86 = v24 >> 3;
                  do
                  {
                    uint64_t v87 = *(void *)&v54[v84];
                    uint64_t v88 = *(void *)(v85 + v84 * 4);
                    if (v87 != v88)
                    {
                      unint64_t v89 = v84 * 4 + (__clz(__rbit64(v88 ^ v87)) >> 3);
                      goto LABEL_105;
                    }

                    v84 += 2LL;
                    --v86;
                  }

                  while (v86);
                  unint64_t v89 = v24 & 0xFFFFFFFFFFFFFFF8LL;
                  if ((v24 & 7) != 0)
                  {
                    unint64_t v90 = v24 & 7;
                    unint64_t v89 = v24 & 0xFFFFFFFFFFFFFFF8LL;
                    while (*(unsigned __int8 *)(v85 + v89) == *((unsigned __int8 *)v54 + v89))
                    {
                      ++v89;
                      if (!--v90)
                      {
                        unint64_t v89 = v24;
                        break;
                      }
                    }

                    uint64_t v12 = v287;
                  }

LABEL_105:
                  unint64_t v91 = 135 * v89 - 30 * (__clz(v83) ^ 0x1F) + 1920;
                  unint64_t v92 = v286;
                  BOOL v93 = v91 > v286;
                  if (v91 > v286)
                  {
                    unint64_t v94 = v83;
                  }

                  else
                  {
                    unint64_t v91 = v286;
                    unint64_t v94 = v32;
                  }

                  if (v93) {
                    unint64_t v95 = v89;
                  }
                  else {
                    unint64_t v95 = v73;
                  }
                  int v96 = v278;
                  if (v93) {
                    int v97 = 0;
                  }
                  else {
                    int v97 = v278;
                  }
                  if (v89 <= v73)
                  {
                    unint64_t v91 = v286;
                    unint64_t v94 = v32;
                    unint64_t v95 = v73;
                    int v97 = v278;
                  }

                  if (v89 >= 4) {
                    unint64_t v92 = v91;
                  }
                  unint64_t v286 = v92;
                  if (v89 >= 4)
                  {
                    unint64_t v32 = v94;
                    unint64_t v73 = v95;
                    int v96 = v97;
                  }

                  int v278 = v96;
                }
              }
            }

            int v79 = v80 + v77 * v79 + v78 * ~(_DWORD)result + 1;
            ++v76;
          }

          while (v76 <= v13);
          *(_DWORD *)(a6 + 120) = v79;
        }

        *(void *)(a6 + 136) = v13 + 1;
      }

      if (v286 < 0x7E5)
      {
        unint64_t v14 = v284 + 1;
        unint64_t v194 = v13 + 1;
        unint64_t v23 = v288;
        if (v13 + 1 <= v288)
        {
          unint64_t v15 = v271;
        }

        else
        {
          unint64_t v15 = v271;
          if (v194 <= v288 + v264)
          {
            unint64_t v238 = v13 + 9;
            if (v13 + 9 >= v265) {
              unint64_t v238 = v265;
            }
            if (v194 < v238)
            {
              int v239 = *(_DWORD *)(a6 + 64);
              int v240 = *(_DWORD *)(a6 + 80);
              int v241 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v242 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v194 & a4)) & v275)) >> v239;
                unsigned int v243 = *(unsigned __int16 *)(v285 + 2LL * v242);
                *(_WORD *)(v285 + 2LL * v242) = v243 + 1;
                *(_DWORD *)(v276 + 4 * (((_DWORD)v242 << v241) + (unint64_t)(v240 & v243))) = v194;
                v14 += 2LL;
                v194 += 2LL;
              }

              while (v194 < v238);
            }
          }

          else
          {
            unint64_t v195 = v13 + 17;
            if (v13 + 17 >= v265) {
              unint64_t v195 = v265;
            }
            if (v194 < v195)
            {
              int v196 = *(_DWORD *)(a6 + 64);
              int v197 = *(_DWORD *)(a6 + 80);
              int v198 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v199 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v194 & a4)) & v275)) >> v196;
                unsigned int v200 = *(unsigned __int16 *)(v285 + 2LL * v199);
                *(_WORD *)(v285 + 2LL * v199) = v200 + 1;
                *(_DWORD *)(v276 + 4 * (((_DWORD)v199 << v198) + (unint64_t)(v197 & v200))) = v194;
                v14 += 4LL;
                v194 += 4LL;
              }

              while (v194 < v195);
            }
          }
        }

        goto LABEL_371;
      }

      unint64_t v270 = v32;
      unsigned int v98 = 0;
      char v99 = v266 - v13;
      while (1)
      {
        char v282 = v99;
        unint64_t v283 = v73;
        --v24;
        unint64_t v100 = v73 - 1;
        if (v73 - 1 >= v24) {
          unint64_t v100 = v24;
        }
        else {
          unint64_t v101 = v100;
        }
        unint64_t v102 = v13 + 1;
        if (v13 + 1 < v273) {
          unint64_t v103 = v13 + 1;
        }
        else {
          unint64_t v103 = v273;
        }
        unint64_t v104 = v102 + v274;
        if (v102 + v274 >= v273) {
          unint64_t v104 = v273;
        }
        unint64_t v277 = v104;
        uint64_t v105 = v102 & a4;
        uint64_t v106 = *(int *)(a6 + 88);
        if ((_DWORD)v106)
        {
          unint64_t v107 = 0LL;
          unint64_t v108 = 0LL;
          unint64_t v109 = 0LL;
          uint64_t v110 = a3 + v105;
          unint64_t v111 = 2020LL;
          unint64_t v112 = 2020LL;
          do
          {
            unint64_t v113 = a7[v107];
            unint64_t v114 = v102 - v113;
            BOOL v115 = v103 < v113 || v114 >= v102;
            uint64_t v116 = v114 & a4;
            unint64_t v117 = v101 + v105;
            BOOL v118 = v115 || v117 > a4;
            unint64_t v119 = v116 + v101;
            BOOL v120 = v118 || v119 > a4;
            if (!v120 && *(unsigned __int8 *)(a3 + v117) == *(unsigned __int8 *)(a3 + v119))
            {
              uint64_t v121 = a3 + v116;
              if (v24 < 8)
              {
                unint64_t v122 = 0LL;
                unint64_t v126 = (unsigned __int8 *)(a3 + v105);
LABEL_168:
                if ((v24 & 7) != 0)
                {
                  unint64_t v129 = v24 & 7;
                  do
                  {
                    ++v126;
                    ++v122;
                    --v129;
                  }

                  while (v129);
                }
              }

              else
              {
                unint64_t v122 = 0LL;
                unint64_t v123 = v24 >> 3;
                while (1)
                {
                  uint64_t v124 = *(void *)(v110 + v122);
                  uint64_t v125 = *(void *)(v121 + v122);
                  if (v124 != v125) {
                    break;
                  }
                  v122 += 8LL;
                  if (!--v123)
                  {
                    unint64_t v126 = (unsigned __int8 *)(v110 + v122);
                    goto LABEL_168;
                  }
                }

                v122 += __clz(__rbit64(v125 ^ v124)) >> 3;
              }

              if (v122 > 2 || v107 <= 1 && v122 == 2)
              {
                unint64_t v127 = 135 * v122 + 1935;
                if (v111 < v127)
                {
                  unint64_t v128 = v127 - (((0x1CA10u >> (v107 & 0xE)) & 0xE) + 39);
                  if (!v107) {
                    unint64_t v128 = 135 * v122 + 1935;
                  }
                  if (v111 < v128)
                  {
                    unint64_t v112 = v128;
                    unint64_t v109 = a7[v107];
                    unint64_t v108 = v122;
                    unint64_t v101 = v122;
                    unint64_t v111 = v128;
                  }
                }
              }
            }

            ++v107;
          }

          while (v107 != v106);
        }

        else
        {
          unint64_t v109 = 0LL;
          unint64_t v108 = 0LL;
          unint64_t v112 = 2020LL;
          unint64_t v111 = 2020LL;
        }

        uint64_t v130 = (_DWORD *)(a3 + v105);
        unint64_t v131 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + v105) & v275)) >> *(_DWORD *)(a6 + 64);
        uint64_t v132 = *(unsigned int *)(a6 + 80);
        uint64_t v133 = v276 + 4LL * ((_DWORD)v131 << *(_DWORD *)(a6 + 84));
        unint64_t v134 = *(unsigned __int16 *)(v285 + 2LL * v131);
        if (v134 >= v272) {
          unint64_t v135 = v134 - v272;
        }
        else {
          unint64_t v135 = 0LL;
        }
        if (v135 < v134)
        {
          unint64_t v136 = *(unsigned __int16 *)(v285 + 2LL * v131);
          do
          {
            uint64_t v137 = *(unsigned int *)(v133 + 4 * (--v136 & v132));
            unint64_t v138 = v102 - v137;
            if (v102 - v137 > v103) {
              break;
            }
            if (v101 + v105 <= a4)
            {
              uint64_t v139 = v137 & a4;
              if (v139 + v101 <= a4 && *(unsigned __int8 *)(a3 + v101 + v105) == *(unsigned __int8 *)(a3 + v139 + v101))
              {
                uint64_t v140 = a3 + v139;
                if (v24 < 8)
                {
                  unint64_t v141 = 0LL;
                  unint64_t v145 = (unsigned __int8 *)(a3 + v105);
LABEL_196:
                  unint64_t v147 = v24 & 7;
                  if ((v24 & 7) != 0)
                  {
                    do
                    {
                      ++v145;
                      ++v141;
                      --v147;
                    }

                    while (v147);
                  }
                }

                else
                {
                  unint64_t v141 = 0LL;
                  unint64_t v142 = v24 >> 3;
                  while (1)
                  {
                    uint64_t v143 = *(void *)((char *)v130 + v141);
                    uint64_t v144 = *(void *)(v140 + v141);
                    if (v143 != v144) {
                      break;
                    }
                    v141 += 8LL;
                    if (!--v142)
                    {
                      unint64_t v145 = (unsigned __int8 *)v130 + v141;
                      goto LABEL_196;
                    }
                  }

                  v141 += __clz(__rbit64(v144 ^ v143)) >> 3;
                }

                if (v141 < 4)
                {
                  uint64_t v12 = v287;
                }

                else
                {
                  unint64_t v146 = 135 * v141 - 30 * (__clz(v138) ^ 0x1F) + 1920;
                  uint64_t v12 = v287;
                  if (v111 < v146)
                  {
                    unint64_t v112 = v146;
                    unint64_t v109 = v138;
                    unint64_t v108 = v141;
                    unint64_t v101 = v141;
                    unint64_t v111 = v146;
                  }
                }
              }
            }
          }

          while (v136 > v135);
        }

        *(_DWORD *)(v133 + 4LL * (v132 & v134)) = v102;
        *(_WORD *)(v285 + 2LL * v131) = v134 + 1;
        if (v112 == 2020)
        {
          uint64_t v148 = *(void *)(v279 + 96);
          unint64_t v149 = *(void *)(v148 + 8);
          unint64_t v150 = *(void *)(v148 + 16);
          if (v150 >= v149 >> 7)
          {
            int v151 = 0;
            uint64_t v175 = ((506832829 * *v130) >> 17) & 0x7FFE;
            uint64_t v176 = *(void *)(v12 + 120);
            char v177 = 1;
            unint64_t v178 = v108;
            unint64_t v179 = v109;
            unint64_t v112 = 2020LL;
            do
            {
              char v180 = v177;
              *(void *)(v148 + 8) = ++v149;
              unint64_t v181 = *(unsigned __int8 *)(v176 + v175);
              if (!*(_BYTE *)(v176 + v175) || v24 < v181) {
                goto LABEL_264;
              }
              uint64_t v182 = *(unsigned __int16 *)(*(void *)(v12 + 112) + 2 * v175);
              uint64_t v183 = *(void *)(v12 + 88);
              uint64_t v184 = *(unsigned int *)(v183 + 4 * v181 + 32);
              uint64_t v185 = *(void *)(v183 + 168);
              uint64_t v186 = (unsigned __int8 *)(v185 + v184 + v182 * *(unsigned __int8 *)(v176 + v175));
              if (v181 < 8)
              {
                unint64_t v108 = 0LL;
LABEL_269:
                unint64_t v192 = v181 & 7;
                if ((v181 & 7) != 0)
                {
                  unint64_t v193 = v108 | v192;
                  while (*((unsigned __int8 *)v130 + v108) == *v186)
                  {
                    ++v186;
                    ++v108;
                    if (!--v192)
                    {
                      unint64_t v108 = v193;
                      break;
                    }
                  }
                }
              }

              else
              {
                unint64_t v187 = 0LL;
                unint64_t v108 = v181 & 0xF8;
                unsigned int v188 = (unsigned __int8 *)(v185
                                         + v182 * (unint64_t)*(unsigned __int8 *)(v176 + v175)
                                         + (*(_BYTE *)(v176 + v175) & 0xF8)
                                         + v184);
                while (1)
                {
                  uint64_t v189 = *(void *)&v186[v187];
                  uint64_t v190 = *(void *)&v130[v187 / 4];
                  if (v189 != v190) {
                    break;
                  }
                  v187 += 8LL;
                  if (v108 == v187)
                  {
                    uint64_t v186 = v188;
                    goto LABEL_269;
                  }
                }

                unint64_t v108 = v187 + (__clz(__rbit64(v190 ^ v189)) >> 3);
              }

              uint64_t v12 = v287;
              if (v108
                && v108 + *(unsigned int *)(v287 + 100) > v181
                && (unint64_t v109 = v277
                         + 1
                         + v182
                         + ((((*(void *)(v287 + 104) >> (6 * (v181 - v108))) & 0x3FLL)
                           + 4 * (v181 - v108)) << *(_BYTE *)(v183 + v181)),
                    v109 <= v280)
                && (unint64_t v191 = 135 * v108 - 30 * (__clz(v109) ^ 0x1F) + 1920, v191 >= v112))
              {
                int v151 = v181 - v108;
                *(void *)(v148 + 16) = ++v150;
                unint64_t v112 = v191;
              }

              else
              {
LABEL_264:
                unint64_t v109 = v179;
                unint64_t v108 = v178;
              }

              char v177 = 0;
              ++v175;
              unint64_t v178 = v108;
              unint64_t v179 = v109;
            }

            while ((v180 & 1) != 0);
          }

          else
          {
            int v151 = 0;
            unint64_t v112 = 2020LL;
          }
        }

        else
        {
          int v151 = 0;
        }

        uint64_t v152 = v282 & 7;
        if (v24 >= 0x20)
        {
          a6 = v279;
          unint64_t v154 = *(void *)(v279 + 136);
          if (v154 <= v102)
          {
            int v155 = *(_DWORD *)(v279 + 148);
            int v156 = *(_DWORD *)(v279 + 152);
            int v157 = *(_DWORD *)(v279 + 120);
            do
            {
              int v158 = *(unsigned __int8 *)(a3 + (v154 & a4));
              int v159 = *(unsigned __int8 *)(a3 + ((v154 + 32) & a4));
              if ((v157 & 0x3F000000) == 0)
              {
                uint64_t v160 = *(void *)(v279 + 128);
                uint64_t v161 = *(unsigned int *)(v160 + 4LL * (v157 & 0x3FFFFFFF));
                *(_DWORD *)(v160 + 4LL * (v157 & 0x3FFFFFFF)) = v154;
                if (v154 == v102 && (_DWORD)v161 != -1)
                {
                  unint64_t v162 = (v102 - v161);
                  if (v103 >= v162)
                  {
                    unint64_t v163 = 0LL;
                    uint64_t v164 = a3 + (v161 & a4);
                    unint64_t v165 = v24 >> 3;
                    do
                    {
                      uint64_t v166 = *(void *)((char *)v130 + v163);
                      uint64_t v167 = *(void *)(v164 + v163);
                      if (v166 != v167)
                      {
                        v163 += __clz(__rbit64(v167 ^ v166)) >> 3;
                        goto LABEL_221;
                      }

                      v163 += 8LL;
                      --v165;
                    }

                    while (v165);
                    if ((v24 & 7) != 0)
                    {
                      uint64_t v168 = 0LL;
                      do
                      {
                        ++v168;
                      }

                      while (v152 != v168);
                      v163 += v168;
                      a6 = v279;
                      uint64_t v12 = v287;
                    }

  FooterID = codecGetFooterID(a1);
  unint64_t v101 = HIDWORD(v124);
  unint64_t v102 = v124 | (FooterID << SBYTE4(v124));
  unint64_t v103 = HIDWORD(v124) + 12;
  LODWORD(v124) = v102;
  HIDWORD(v124) += 12;
  if (v101 >= 5)
  {
    unint64_t v104 = v121;
    uint64_t v105 = v122;
    uint64_t v106 = ++v122;
    if (v105 < v121)
    {
      unint64_t v107 = v123++;
      *(_BYTE *)(v120 + v107) = v102;
      unint64_t v102 = v124;
      unint64_t v103 = HIDWORD(v124);
      unint64_t v104 = v121;
      uint64_t v106 = v122;
    }

    unint64_t v108 = v102 >> 8;
    unint64_t v109 = v103 - 8;
    uint64_t v124 = __PAIR64__(v109, v108);
    unint64_t v122 = v106 + 1;
    if (v106 < v104)
    {
      uint64_t v110 = v123++;
      *(_BYTE *)(v120 + v110) = v108;
      unint64_t v108 = v124;
      unint64_t v109 = HIDWORD(v124);
    }

    unint64_t v102 = v108 >> 8;
    unint64_t v103 = v109 - 8;
    uint64_t v124 = __PAIR64__(v103, v102);
  }

  if (v103 >= 1)
  {
    do
    {
      unint64_t v111 = v122++;
      if (v111 < v121)
      {
        unint64_t v112 = v123++;
        *(_BYTE *)(v120 + v112) = v102;
        unint64_t v102 = v124;
        unint64_t v103 = HIDWORD(v124);
      }

      v102 >>= 8;
      unint64_t v113 = __OFSUB__(v103, 8);
      v103 -= 8;
      uint64_t v124 = __PAIR64__(v103, v102);
    }

    while (!((v103 < 0) ^ v113 | (v103 == 0)));
  }

  unint64_t result = v122;
  if (!v122 || v122 != v123)
  {
LABEL_120:
    codecResetModel(a1);
    return 0LL;
  }

  ++*(void *)(a1 + 656);
  return result;
}

LABEL_221:
                    unint64_t v169 = 135 * v163 - 30 * (__clz(v162) ^ 0x1F) + 1920;
                    BOOL v170 = v169 > v112;
                    if (v169 > v112) {
                      int v171 = 0;
                    }
                    else {
                      int v171 = v151;
                    }
                    if (v169 <= v112)
                    {
                      unint64_t v169 = v112;
                      unint64_t v162 = v109;
                    }

                    if (v170) {
                      unint64_t v172 = v163;
                    }
                    else {
                      unint64_t v172 = v108;
                    }
                    BOOL v173 = v163 >= 4 && v163 > v108;
                    if (v173) {
                      int v151 = v171;
                    }
                    if (v173) {
                      unint64_t v112 = v169;
                    }
                    if (v173) {
                      unint64_t v109 = v162;
                    }
                    if (v173) {
                      unint64_t v108 = v172;
                    }
                  }
                }
              }

              int v157 = v159 + v155 * v157 + v156 * ~v158 + 1;
              ++v154;
            }

            while (v154 <= v102);
            *(_DWORD *)(v279 + 120) = v157;
          }

          unint64_t v153 = v283;
          *(void *)(v279 + 136) = v13 + 2;
        }

        else
        {
          a6 = v279;
          unint64_t v153 = v283;
        }

        if (v112 < v286 + 175) {
          break;
        }
        ++v284;
        if (v98 <= 2)
        {
          unint64_t v174 = v13 + 9;
          ++v98;
          char v99 = v152 + 7;
          unint64_t v286 = v112;
          unint64_t v270 = v109;
          unint64_t v73 = v108;
          int v278 = v151;
          ++v13;
          if (v174 < v271) {
            continue;
          }
        }

        goto LABEL_285;
      }

      unint64_t v201 = v13 + v274;
      if (v13 + v274 >= v273) {
        unint64_t v201 = v273;
      }
      unint64_t v277 = v201;
      unint64_t v109 = v270;
      unint64_t v108 = v153;
      int v151 = v278;
      unint64_t v102 = v13;
LABEL_285:
      unint64_t v15 = v271;
      unint64_t result = 0x1FE35A7BD3579BD3LL;
      uint64_t v202 = v269;
      if (v109 > v277) {
        goto LABEL_286;
      }
      uint64_t v228 = *a7;
      if (v109 != v228) {
        break;
      }
      unint64_t v203 = 0LL;
LABEL_319:
      *uint64_t v269 = v284;
      v269[1] = v108 | (v151 << 25);
      uint64_t v229 = *(unsigned int *)(v12 + 68);
      uint64_t v230 = v229 + 16;
      if (v229 + 16 <= v203)
      {
        uint64_t v232 = *(unsigned int *)(v12 + 64);
        unint64_t v233 = v203 - v229 + (4LL << v232) - 16;
        uint64_t v234 = (__clz(v233) ^ 0x1F) - 1;
        uint64_t v235 = ((v233 >> v234) & 1 | 2) << v234;
        uint64_t v202 = v269;
        unint64_t v203 = ((v233 & ~(-1 << v232))
              + v230
              + ((((v233 >> v234) & 1 | (2 * (v234 - v232))) + 65534) << v232)) | ((v234 - v232) << 10);
        unint64_t v231 = (v233 - v235) >> v232;
      }

      else
      {
        LODWORD(v231) = 0;
      }

      *((_WORD *)v202 + 7) = v203;
      v202[2] = v231;
      if (v284 > 5)
      {
        if (v284 > 0x81)
        {
          if (v284 > 0x841)
          {
            if (v284 >> 1 >= 0xC21)
            {
              if (v284 < 0x5842) {
                LOWORD(v236) = 22;
              }
              else {
                LOWORD(v236) = 23;
              }
            }

            else
            {
              LOWORD(v236) = 21;
            }
          }

          else
          {
            unsigned int v236 = (__clz(v284 - 66) ^ 0x1F) + 10;
          }
        }

        else
        {
          unsigned int v237 = (__clz(v284 - 2) ^ 0x1F) - 1;
          unsigned int v236 = ((v284 - 2) >> v237) + 2 * v237 + 2;
        }
      }

      else
      {
        LOWORD(v236) = v284;
      }

      uint64_t v249 = v151 + (int)v108;
      if (v249 > 9)
      {
        if (v249 > 0x85)
        {
          else {
            unsigned int v250 = (__clz(v249 - 70) ^ 0x1F) + 12;
          }
        }

        else
        {
          unint64_t v251 = v249 - 6;
          unsigned int v252 = (__clz(v251) ^ 0x1F) - 1;
          unsigned int v250 = (v251 >> v252) + 2 * v252 + 4;
        }
      }

      else
      {
        LOWORD(v250) = v151 + v108 - 2;
      }

      int v253 = v250 & 7 | (8 * (v236 & 7));
      if ((v203 & 0x3FF) != 0 || (unsigned __int16)v236 > 7u || (unsigned __int16)v250 > 0xFu)
      {
        int v255 = 3 * ((unsigned __int16)v236 >> 3) + ((unsigned __int16)(v250 & 0xFFF8) >> 3);
        unsigned int v254 = ((((0x520D40u >> (2 * v255)) & 0xC0) + (v255 << 6)) | v253) + 64;
      }

      else
      {
        LOWORD(v254) = v253 | 0x40;
        if ((v250 & 0xFFF8) == 0) {
          LOWORD(v254) = v250 & 7 | (8 * (v236 & 7));
        }
      }

      *((_WORD *)v202 + 6) = v254;
      unint64_t v256 = v267;
      *a11 += v284;
      unint64_t v257 = v102 + 2;
      unint64_t v194 = v102 + v108;
      if (v102 + v108 < v267) {
        unint64_t v256 = v102 + v108;
      }
      if (v109 < v108 >> 2)
      {
        if (v257 <= v194 - 4 * v109) {
          unint64_t v257 = v194 - 4 * v109;
        }
        if (v256 < v257) {
          unint64_t v257 = v256;
        }
      }

      unint64_t v23 = v268 + 2 * v108 + v102;
      uint64_t v269 = v202 + 4;
      if (v257 < v256)
      {
        int v258 = *(_DWORD *)(v279 + 64);
        int v259 = *(_DWORD *)(v279 + 80);
        int v260 = *(_DWORD *)(v279 + 84);
        do
        {
          unint64_t v261 = (0x1FE35A7BD3579BD3LL * (*(void *)(a3 + (v257 & a4)) & v275)) >> v258;
          unsigned int v262 = *(unsigned __int16 *)(v285 + 2LL * v261);
          *(_WORD *)(v285 + 2LL * v261) = v262 + 1;
          *(_DWORD *)(v276 + 4 * (((_DWORD)v261 << v260) + (unint64_t)(v259 & v262))) = v257++;
        }

        while (v256 != v257);
      }

      unint64_t v14 = 0LL;
LABEL_371:
      unint64_t v13 = v194;
      if (v194 + 8 >= v15) {
        goto LABEL_378;
      }
    }

    uint64_t v244 = a7[1];
    if (v109 == v244)
    {
      unint64_t v203 = 1LL;
      goto LABEL_287;
    }

    unint64_t v245 = v109 + 3 - v228;
    if (v245 > 6)
    {
      unint64_t v248 = v109 + 3 - v244;
      if (v248 > 6)
      {
        if (v109 == a7[2])
        {
          unint64_t v203 = 2LL;
        }

        else if (v109 == a7[3])
        {
          unint64_t v203 = 3LL;
        }

        else
        {
LABEL_286:
          unint64_t v203 = v109 + 15;
        }

LABEL_287:
        if (v109 <= v277)
        {
          if (v203)
          {
            a7[3] = a7[2];
            int32x2_t v204 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v109;
            int v205 = *(_DWORD *)(v279 + 88);
            if (v205 >= 5)
            {
              int32x4_t v206 = vdupq_n_s32(v109);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v206, (int32x4_t)xmmword_1810CB570);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v206.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v205 >= 0xB)
              {
                int32x4_t v207 = vdupq_lane_s32(v204, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v207, (int32x4_t)xmmword_1810CB570);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v207.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }

        goto LABEL_319;
      }

      char v246 = 4 * v248;
      unsigned int v247 = 266017486;
    }

    else
    {
      char v246 = 4 * v245;
      unsigned int v247 = 158663784;
    }

    unint64_t v203 = (v247 >> v246) & 0xF;
    goto LABEL_287;
  }

  uint64_t v269 = a9;
  unint64_t v194 = a2;
LABEL_378:
  *a8 = v14 + v15 - v194;
  *a10 += ((char *)v269 - (char *)a9) >> 4;
  return result;
}

uint64_t BrotliFindAllStaticDictionaryMatches( uint64_t *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5 = a1[5];
  unsigned int v6 = (506832829 * *(_DWORD *)a2) >> 17;
  uint64_t v7 = *(unsigned __int16 *)(v5 + 2LL * v6);
  if (*(_WORD *)(v5 + 2LL * v6))
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = a2 + 1;
    uint64_t v10 = a1[6];
    uint64_t v11 = *a1;
    while (1)
    {
      uint64_t v12 = (char *)(v10 + 4 * v7);
      char v13 = *v12;
      int v14 = v12[1];
      int v15 = *((unsigned __int16 *)v12 + 1);
      unint64_t v16 = *v12 & 0x1F;
      char v17 = *(_BYTE *)(v11 + v16);
      if (!v12[1])
      {
        unint64_t v27 = *(void *)(v11 + 168)
        if (v16 >= a4) {
          unint64_t v28 = a4;
        }
        else {
          unint64_t v28 = v13 & 0x1F;
        }
        if (v28 < 8)
        {
          unint64_t v30 = 0LL;
          unint64_t v31 = a2;
LABEL_241:
          unint64_t v96 = v28 & 7;
          if (v96)
          {
            unint64_t v97 = v30 | v96;
            while (*(unsigned __int8 *)(v27 + v30) == *v31)
            {
              ++v31;
              ++v30;
              if (!--v96)
              {
                unint64_t v30 = v97;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v29 = 0LL;
          unint64_t v30 = v28 & 0x18;
          unint64_t v31 = &a2[v30];
          while (1)
          {
            uint64_t v32 = *(void *)&a2[v29];
            uint64_t v33 = *(void *)(v27 + v29);
            if (v32 != v33) {
              break;
            }
            v29 += 8LL;
            if ((v28 & 0xFFFFFFFFFFFFFFF8LL) == v29) {
              goto LABEL_241;
            }
          }

          unint64_t v30 = v29 + (__clz(__rbit64(v33 ^ v32)) >> 3);
        }

        if (v30 == v16)
        {
          unsigned int v34 = *(_DWORD *)(a5 + 4 * v16);
          *(_DWORD *)(a5 + 4 * v16) = v34;
          uint64_t v8 = 1LL;
        }

        unint64_t v35 = v16 - 1;
        if (v30 >= v16 - 1)
        {
          unsigned int v36 = v16 | (32 * ((12LL << v17) + v15));
          if (*(_DWORD *)(a5 + 4 * v35) < v36) {
            unsigned int v36 = *(_DWORD *)(a5 + 4 * v35);
          }
          *(_DWORD *)(a5 + 4 * v35) = v36;
          if (v16 + 2 < a4 && a2[v35] == 105 && a2[v16] == 110 && a2[v16 + 1] == 103 && a2[v16 + 2] == 32)
          {
            unsigned int v37 = v16 | (32 * ((49LL << v17) + v15));
            uint64_t v38 = a5 + 4 * v16;
            if (*(_DWORD *)(v38 + 12) < v37) {
              unsigned int v37 = *(_DWORD *)(v38 + 12);
            }
            *(_DWORD *)(v38 + 12) = v37;
          }

          uint64_t v8 = 1LL;
        }

        unint64_t v39 = v16 - 9;
        if (a3 > v16 - 9) {
          unint64_t v39 = a3;
        }
        else {
          unint64_t v40 = v39;
        }
        unint64_t v41 = v16 - 2;
        if (v30 < v16 - 2) {
          unint64_t v41 = v30;
        }
        if (v40 <= v41)
        {
          unint64_t v42 = a1[2];
          uint64_t v43 = v41 - v40 + 1;
          int v44 = 4 * v16 - 4 * v40;
          char v45 = 6 * v16 - 6 * v40;
          unint64_t v46 = (unsigned int *)(a5 + 4 * v40);
          do
          {
            unsigned int v47 = v16 | (32 * (((unint64_t)(v44 + ((v42 >> v45) & 0x3F)) << v17) + v15));
            if (*v46 < v47) {
              unsigned int v47 = *v46;
            }
            *v46++ = v47;
            v44 -= 4;
            v45 -= 6;
            --v43;
          }

          while (v43);
          uint64_t v8 = 1LL;
        }

        if (v30 >= v16)
        {
          unint64_t v48 = v16 + 6;
          if (v16 + 6 < a4)
          {
            unint64_t v49 = &a2[v16];
            unsigned int v50 = a2[v16];
            if (v50 > 0x3C)
            {
              switch(a2[v16])
              {
                case 'a':
                  if (v49[1] == 108 && v49[2] == 32)
                  {
                    unint64_t v48 = v16 + 3;
                    uint64_t v55 = 84LL;
                    goto LABEL_176;
                  }

                  break;
                case 'b':
                case 'c':
                case 'd':
                case 'g':
                case 'h':
                case 'j':
                case 'k':
                case 'm':
                case 'n':
                  goto LABEL_179;
                case 'e':
                  int v84 = v49[1];
                  if (v84 == 115)
                  {
                    if (v49[2] == 116 && v49[3] == 32)
                    {
                      unint64_t v48 = v16 + 4;
                      uint64_t v55 = 95LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v84 == 114)
                  {
                    if (v49[2] == 32)
                    {
                      unint64_t v48 = v16 + 3;
                      uint64_t v55 = 82LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v84 == 100 && v49[2] == 32)
                  {
                    unint64_t v48 = v16 + 3;
                    uint64_t v55 = 53LL;
                    goto LABEL_176;
                  }

                  break;
                case 'f':
                  if (v49[1] == 117 && v49[2] == 108 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 90LL;
                    goto LABEL_176;
                  }

                  break;
                case 'i':
                  int v85 = v49[1];
                  if (v85 == 122)
                  {
                    if (v49[2] == 101 && v49[3] == 32)
                    {
                      unint64_t v48 = v16 + 4;
                      uint64_t v55 = 100LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v85 == 118 && v49[2] == 101 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 92LL;
                    goto LABEL_176;
                  }

                  break;
                case 'l':
                  int v86 = v49[1];
                  if (v86 == 121)
                  {
                    if (v49[2] == 32)
                    {
                      unint64_t v48 = v16 + 3;
                      uint64_t v55 = 61LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v86 == 101 && v49[2] == 115 && v49[3] == 115 && v49[4] == 32)
                  {
                    unint64_t v48 = v16 + 5;
                    uint64_t v55 = 93LL;
                    goto LABEL_176;
                  }

                  break;
                case 'o':
                  if (v49[1] == 117 && v49[2] == 115 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 106LL;
                    goto LABEL_176;
                  }

                  break;
                default:
                  if (v50 == 61)
                  {
                    int v89 = v49[1];
                    if (v89 == 39)
                    {
                      unint64_t v48 = v16 + 2;
                      uint64_t v55 = 86LL;
                      goto LABEL_176;
                    }

                    if (v89 == 34)
                    {
                      unint64_t v48 = v16 + 2;
                      uint64_t v55 = 70LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v50 == 93)
                  {
                    unint64_t v48 = v16 + 1;
                    uint64_t v55 = 24LL;
                    goto LABEL_176;
                  }

                  break;
              }
            }

            else
            {
              switch(a2[v16])
              {
                case ' ':
                  unsigned int v51 = v16 | (32 * ((1LL << v17) + v15));
                  uint64_t v52 = a5 + 4 * v16;
                  if (*(_DWORD *)(v52 + 4) < v51) {
                    unsigned int v51 = *(_DWORD *)(v52 + 4);
                  }
                  *(_DWORD *)(v52 + 4) = v51;
                  int v53 = v49[1];
                  switch(v49[1])
                  {
                    case 'a':
                      unsigned int v54 = v49[2];
                      if (v54 > 0x72)
                      {
                        if (v54 == 115)
                        {
                          if (v49[3] == 32)
                          {
                            unint64_t v48 = v16 + 4;
                            uint64_t v55 = 46LL;
                            goto LABEL_176;
                          }
                        }

                        else if (v54 == 116 && v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 60LL;
                          goto LABEL_176;
                        }
                      }

                      else
                      {
                        if (v54 == 32)
                        {
                          unint64_t v48 = v16 + 3;
                          uint64_t v55 = 28LL;
                          goto LABEL_176;
                        }

                        if (v54 == 110 && v49[3] == 100 && v49[4] == 32)
                        {
                          unint64_t v48 = v16 + 5;
                          uint64_t v55 = 10LL;
                          goto LABEL_176;
                        }
                      }

                      break;
                    case 'b':
                      if (v49[2] == 121 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 38LL;
                        goto LABEL_176;
                      }

                      break;
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'g':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'm':
                      goto LABEL_179;
                    case 'f':
                      int v91 = v49[2];
                      if (v91 == 114)
                      {
                        if (v49[3] == 111 && v49[4] == 109 && v49[5] == 32)
                        {
                          uint64_t v55 = 37LL;
                          goto LABEL_176;
                        }
                      }

                      else if (v91 == 111 && v49[3] == 114 && v49[4] == 32)
                      {
                        unint64_t v48 = v16 + 5;
                        uint64_t v55 = 25LL;
                        goto LABEL_176;
                      }

                      break;
                    case 'i':
                      int v92 = v49[2];
                      if (v92 == 115)
                      {
                        if (v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 47LL;
                          goto LABEL_176;
                        }
                      }

                      else if (v92 == 110 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 16LL;
                        goto LABEL_176;
                      }

                      break;
                    case 'n':
                      if (v49[2] == 111 && v49[3] == 116 && v49[4] == 32)
                      {
                        unint64_t v48 = v16 + 5;
                        uint64_t v55 = 80LL;
                        goto LABEL_176;
                      }

                      break;
                    case 'o':
                      int v93 = v49[2];
                      if (v93 == 110)
                      {
                        if (v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 45LL;
                          goto LABEL_176;
                        }
                      }

                      else if (v93 == 102 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 8LL;
                        goto LABEL_176;
                      }

                      break;
                    default:
                      if (v53 == 116)
                      {
                        int v94 = v49[2];
                        if (v94 == 111)
                        {
                          if (v49[3] == 32)
                          {
                            unint64_t v48 = v16 + 4;
                            uint64_t v55 = 17LL;
                            goto LABEL_176;
                          }
                        }

                        else if (v94 == 104)
                        {
                          int v95 = v49[3];
                          if (v95 == 97)
                          {
                            if (v49[4] == 116 && v49[5] == 32)
                            {
                              uint64_t v55 = 29LL;
                              goto LABEL_176;
                            }
                          }

                          else if (v95 == 101 && v49[4] == 32)
                          {
                            unint64_t v48 = v16 + 5;
                            uint64_t v55 = 5LL;
                            goto LABEL_176;
                          }
                        }
                      }

                      else if (v53 == 119 && v49[2] == 105 && v49[3] == 116 && v49[4] == 104 && v49[5] == 32)
                      {
                        uint64_t v55 = 35LL;
                        goto LABEL_176;
                      }

                      break;
                  }

                  goto LABEL_179;
                case '!':
                case '#':
                case '$':
                case '%':
                case '&':
                case ')':
                case '*':
                case '+':
                case '-':
                  goto LABEL_179;
                case '""':
                  unsigned int v76 = v16 | (32 * ((19LL << v17) + v15));
                  uint64_t v77 = a5 + 4 * v16;
                  if (*(_DWORD *)(v77 + 4) < v76) {
                    unsigned int v76 = *(_DWORD *)(v77 + 4);
                  }
                  *(_DWORD *)(v77 + 4) = v76;
                  if (v49[1] != 62) {
                    goto LABEL_179;
                  }
                  unint64_t v48 = v16 + 2;
                  uint64_t v55 = 21LL;
                  goto LABEL_176;
                case '\'':
                  unint64_t v48 = v16 + 1;
                  uint64_t v55 = 36LL;
                  goto LABEL_176;
                case '(':
                  unint64_t v48 = v16 + 1;
                  uint64_t v55 = 57LL;
                  goto LABEL_176;
                case ',':
                  unsigned int v78 = v16 | (32 * ((76LL << v17) + v15));
                  uint64_t v79 = a5 + 4 * v16;
                  if (*(_DWORD *)(v79 + 4) < v78) {
                    unsigned int v78 = *(_DWORD *)(v79 + 4);
                  }
                  *(_DWORD *)(v79 + 4) = v78;
                  if (v49[1] != 32) {
                    goto LABEL_179;
                  }
                  unint64_t v48 = v16 + 2;
                  uint64_t v55 = 14LL;
                  goto LABEL_176;
                case '.':
                  unsigned int v80 = v16 | (32 * ((20LL << v17) + v15));
                  uint64_t v81 = a5 + 4 * v16;
                  if (*(_DWORD *)(v81 + 4) < v80) {
                    unsigned int v80 = *(_DWORD *)(v81 + 4);
                  }
                  *(_DWORD *)(v81 + 4) = v80;
                  if (v49[1] != 32) {
                    goto LABEL_179;
                  }
                  unsigned int v82 = v16 | (32 * ((31LL << v17) + v15));
                  if (*(_DWORD *)(v81 + 8) < v82) {
                    unsigned int v82 = *(_DWORD *)(v81 + 8);
                  }
                  *(_DWORD *)(v81 + 8) = v82;
                  if (v49[2] != 84 || v49[3] != 104) {
                    goto LABEL_179;
                  }
                  int v83 = v49[4];
                  if (v83 == 105)
                  {
                    if (v49[5] == 115 && v49[6] == 32)
                    {
                      unint64_t v48 = v16 + 7;
                      uint64_t v55 = 75LL;
                      goto LABEL_176;
                    }
                  }

                  else if (v83 == 101 && v49[5] == 32)
                  {
                    uint64_t v55 = 43LL;
                    goto LABEL_176;
                  }

                  goto LABEL_179;
                default:
                  if (v50 != 10)
                  {
                    if (v50 != 58) {
                      goto LABEL_179;
                    }
                    unint64_t v48 = v16 + 1;
                    uint64_t v55 = 51LL;
                    goto LABEL_176;
                  }

                  unsigned int v87 = v16 | (32 * ((22LL << v17) + v15));
                  uint64_t v88 = a5 + 4 * v16;
                  if (*(_DWORD *)(v88 + 4) < v87) {
                    unsigned int v87 = *(_DWORD *)(v88 + 4);
                  }
                  *(_DWORD *)(v88 + 4) = v87;
                  if (v49[1] == 9)
                  {
                    unint64_t v48 = v16 + 2;
                    uint64_t v55 = 50LL;
                    goto LABEL_176;
                  }

                  break;
              }
            }
          }
        }

        goto LABEL_179;
      }

      if (v16 <= a4)
      {
        uint64_t v18 = (unsigned __int8 *)(*(void *)(v11 + 168)
        if (v14 == 10)
        {
          int v19 = *v18;
          int v20 = v16 - 1;
          unint64_t v21 = (v16 - 1);
          if (v21 < 8)
          {
            uint64_t v23 = 0LL;
            unint64_t v24 = a2 + 1;
LABEL_255:
            uint64_t v98 = v20 & 7;
            if (v98)
            {
              uint64_t v99 = v23 | v98;
              uint64_t v100 = v23 + 1;
              while (v18[v100] == *v24)
              {
                ++v24;
                ++v100;
                if (!--v98)
                {
                  uint64_t v23 = v99;
                  goto LABEL_80;
                }
              }

              uint64_t v23 = v100 - 1;
            }
          }

          else
          {
            uint64_t v22 = 0LL;
            uint64_t v23 = v20 & 0xFFFFFFF8;
            unint64_t v24 = &v9[v23];
            while (1)
            {
              uint64_t v25 = *(void *)&v9[v22];
              uint64_t v26 = *(void *)&v18[v22 + 1];
              if (v25 != v26) {
                break;
              }
              v22 += 8LL;
              if ((v21 & 0xFFFFFFF8) == v22) {
                goto LABEL_255;
              }
            }

            uint64_t v23 = v22 + (__clz(__rbit64(v26 ^ v25)) >> 3);
          }

LABEL_80:
          if (v23 != v21) {
            goto LABEL_179;
          }
          uint64_t v60 = 9LL;
        }

        else
        {
          uint64_t v56 = v13 & 0x1F;
          uint64_t v57 = a2;
          if ((_DWORD)v16)
          {
            do
            {
              int v59 = *v18++;
              int v58 = v59;
              if (v58 != *v57) {
                goto LABEL_179;
              }
              ++v57;
            }

            while (--v56);
          }

          uint64_t v60 = 44LL;
        }

        unsigned int v61 = v16 | (32 * ((v60 << v17) + v15));
        if (*(_DWORD *)(a5 + 4 * v16) < v61) {
          unsigned int v61 = *(_DWORD *)(a5 + 4 * v16);
        }
        *(_DWORD *)(a5 + 4 * v16) = v61;
        unint64_t v48 = v16 + 1;
        if (v16 + 1 >= a4)
        {
LABEL_117:
          uint64_t v8 = 1LL;
        }

        else
        {
          unint64_t v62 = &a2[v16];
          uint64_t v8 = 1LL;
          switch(a2[v16])
          {
            case ' ':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 68LL;
              uint64_t v65 = 4LL;
              goto LABEL_102;
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case ')':
            case '*':
            case '+':
            case '-':
              goto LABEL_179;
            case '""':
              uint64_t v67 = 87LL;
              if (v14 == 10) {
                uint64_t v67 = 66LL;
              }
              unsigned int v68 = v16 | (32 * ((v67 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v68) {
                unsigned int v68 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v68;
              if (v62[1] != 62) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 97LL;
              uint64_t v71 = 69LL;
              goto LABEL_171;
            case '\'':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 94LL;
              uint64_t v65 = 74LL;
              goto LABEL_102;
            case '(':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 113LL;
              uint64_t v65 = 78LL;
LABEL_102:
              if (v63) {
                uint64_t v55 = v65;
              }
              else {
                uint64_t v55 = v64;
              }
              goto LABEL_175;
            case ',':
              uint64_t v72 = 112LL;
              if (v14 == 10) {
                uint64_t v72 = 99LL;
              }
              unsigned int v73 = v16 | (32 * ((v72 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v73) {
                unsigned int v73 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v73;
              if (v62[1] != 32) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 107LL;
              uint64_t v71 = 58LL;
              goto LABEL_171;
            case '.':
              uint64_t v74 = 101LL;
              if (v14 == 10) {
                uint64_t v74 = 79LL;
              }
              unsigned int v75 = v16 | (32 * ((v74 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v75) {
                unsigned int v75 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v75;
              if (v62[1] != 32) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 114LL;
              uint64_t v71 = 88LL;
              goto LABEL_171;
            default:
              if (a2[v16] != 61) {
                goto LABEL_179;
              }
              int v66 = v62[1];
              if (v66 == 39)
              {
                BOOL v69 = v14 == 10;
                uint64_t v70 = 116LL;
                uint64_t v71 = 108LL;
LABEL_171:
                if (v69) {
                  uint64_t v55 = v71;
                }
                else {
                  uint64_t v55 = v70;
                }
              }

              else
              {
                if (v66 != 34) {
                  goto LABEL_117;
                }
                if (v14 == 10) {
                  uint64_t v55 = 104LL;
                }
                else {
                  uint64_t v55 = 105LL;
                }
              }

              unint64_t v48 = v16 + 2;
LABEL_175:
              uint64_t v8 = 1LL;
              break;
          }

LABEL_176:
          unsigned int v90 = v16 | (32 * ((v55 << v17) + v15));
          if (*(_DWORD *)(a5 + 4 * v48) < v90) {
            unsigned int v90 = *(_DWORD *)(a5 + 4 * v48);
          }
          *(_DWORD *)(a5 + 4 * v48) = v90;
        }
      }

LABEL_179:
      ++v7;
      if (v13 < 0) {
        goto LABEL_262;
      }
    }
  }

  uint64_t v8 = 0LL;
LABEL_262:
  unint64_t v101 = a4 - 5;
  if (a4 < 5) {
    return v8;
  }
  int v102 = *a2;
  if (v102 == 46 || v102 == 32)
  {
    unint64_t v103 = a2 + 1;
    uint64_t v104 = *(unsigned __int16 *)(v5 + 2LL * ((506832829 * *(_DWORD *)(a2 + 1)) >> 17));
    if (v104)
    {
      unint64_t v105 = a4 - 1;
      uint64_t v106 = a1[6];
      uint64_t v107 = *a1;
      if (v102 == 32) {
        uint64_t v108 = 6LL;
      }
      else {
        uint64_t v108 = 32LL;
      }
      if (v102 == 32) {
        uint64_t v109 = 89LL;
      }
      else {
        uint64_t v109 = 67LL;
      }
      if (v102 == 32) {
        uint64_t v110 = 2LL;
      }
      else {
        uint64_t v110 = 77LL;
      }
      while (1)
      {
        unint64_t v111 = (char *)(v106 + 4 * v104);
        char v112 = *v111;
        int v113 = v111[1];
        int v114 = *((unsigned __int16 *)v111 + 1);
        unint64_t v115 = *v111 & 0x1F;
        char v116 = *(_BYTE *)(v107 + v115);
        if (!v111[1]) {
          break;
        }
        if (v102 != 32 || v105 < v115) {
          goto LABEL_351;
        }
        unint64_t v117 = (unsigned __int8 *)(*(void *)(v107 + 168)
        if (v113 == 10)
        {
          int v118 = *v117;
          uint64_t v119 = v108;
          unint64_t v120 = v101;
          uint64_t v121 = v110;
          int v122 = v115 - 1;
          unint64_t v123 = (v115 - 1);
          if (v123 < 8)
          {
            uint64_t v125 = 0LL;
            unint64_t v221 = a2 + 2;
LABEL_371:
            uint64_t v163 = v122 & 7;
            if (v163)
            {
              uint64_t v164 = v125 | v163;
              uint64_t v165 = v125 + 1;
              uint64_t v166 = v221;
              while (v117[v165] == *v166)
              {
                ++v166;
                ++v165;
                if (!--v163)
                {
                  uint64_t v125 = v164;
                  goto LABEL_319;
                }
              }

              uint64_t v125 = v165 - 1;
            }
          }

          else
          {
            uint64_t v124 = 0LL;
            uint64_t v125 = v122 & 0xFFFFFFF8;
            unint64_t v126 = a2 + 2;
            unint64_t v221 = &a2[v125 + 2];
            while (1)
            {
              uint64_t v127 = *(void *)&v126[v124];
              uint64_t v128 = *(void *)&v117[v124 + 1];
              if (v127 != v128) {
                break;
              }
              v124 += 8LL;
              unint64_t v126 = a2 + 2;
              if ((v123 & 0xFFFFFFF8) == v124) {
                goto LABEL_371;
              }
            }

            uint64_t v125 = v124 + (__clz(__rbit64(v128 ^ v127)) >> 3);
          }

LABEL_319:
          uint64_t v110 = v121;
          unint64_t v101 = v120;
          uint64_t v108 = v119;
          if (v125 != v123) {
            goto LABEL_351;
          }
          uint64_t v145 = 30LL;
        }

        else
        {
          uint64_t v141 = v112 & 0x1F;
          unint64_t v142 = a2 + 1;
          if ((_DWORD)v115)
          {
            do
            {
              int v144 = *v117++;
              int v143 = v144;
              if (v143 != *v142) {
                goto LABEL_351;
              }
              ++v142;
            }

            while (--v141);
          }

          uint64_t v145 = 85LL;
        }

        int v146 = (v145 << v116) + v114;
        unint64_t v147 = v115 + 1;
        unsigned int v148 = v115 | (32 * v146);
        if (*(_DWORD *)(a5 + 4 * (v115 + 1)) < v148) {
          unsigned int v148 = *(_DWORD *)(a5 + 4 * (v115 + 1));
        }
        *(_DWORD *)(a5 + 4 * v147) = v148;
        unint64_t v137 = v115 + 2;
        if (v115 + 2 >= a4) {
          goto LABEL_350;
        }
        unint64_t v149 = &a2[v147];
        int v150 = a2[v147];
        uint64_t v8 = 1LL;
        if (v150 > 45)
        {
          if (v150 == 46)
          {
            uint64_t v156 = 115LL;
            if (v113 == 10) {
              uint64_t v156 = 96LL;
            }
            unsigned int v157 = v115 | (32 * ((v156 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v157) {
              unsigned int v157 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v157;
            if (v149[1] == 32)
            {
              BOOL v152 = v113 == 10;
              uint64_t v140 = 117LL;
              uint64_t v153 = 91LL;
              goto LABEL_344;
            }

            goto LABEL_350;
          }

          if (v150 == 61)
          {
            int v154 = v149[1];
            if (v154 != 39)
            {
              if (v154 == 34)
              {
                BOOL v152 = v113 == 10;
                uint64_t v140 = 110LL;
                uint64_t v153 = 118LL;
                goto LABEL_344;
              }

LABEL_350:
              uint64_t v8 = 1LL;
              goto LABEL_351;
            }

            uint64_t v140 = 119LL;
            if (v113 == 10) {
              uint64_t v140 = 120LL;
            }
LABEL_346:
            unint64_t v137 = v115 + 3;
LABEL_347:
            unsigned int v158 = v115 | (32 * ((v140 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v158) {
              unsigned int v158 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v158;
            goto LABEL_350;
          }
        }

        else
        {
          if (v150 == 32)
          {
            uint64_t v140 = 83LL;
            if (v113 == 10) {
              uint64_t v140 = 15LL;
            }
            goto LABEL_347;
          }

          if (v150 == 44)
          {
            if (v113 == 10)
            {
              unsigned int v151 = v115 | (32 * ((109LL << v116) + v114));
              if (*(_DWORD *)(a5 + 4 * v137) < v151) {
                unsigned int v151 = *(_DWORD *)(a5 + 4 * v137);
              }
              *(_DWORD *)(a5 + 4 * v137) = v151;
            }

            if (v149[1] != 32) {
              goto LABEL_350;
            }
            BOOL v152 = v113 == 10;
            uint64_t v140 = 111LL;
            uint64_t v153 = 65LL;
LABEL_344:
            if (v152) {
              uint64_t v140 = v153;
            }
            goto LABEL_346;
          }
        }

LABEL_351:
        ++v104;
        if (v112 < 0) {
          goto LABEL_377;
        }
      }

      if (v105 < v115) {
        goto LABEL_351;
      }
      unint64_t v129 = *(void *)(v107 + 168)
      if (v115 < 8)
      {
        unint64_t v131 = 0LL;
        uint64_t v132 = a2 + 1;
LABEL_365:
        unint64_t v161 = v115 & 7;
        if ((v115 & 7) != 0)
        {
          uint64_t v162 = v131 | v161;
          while (*(unsigned __int8 *)(v129 + v131) == *v132)
          {
            ++v132;
            ++v131;
            if (!--v161)
            {
              unint64_t v131 = v162;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v130 = 0LL;
        unint64_t v131 = v115 & 0x18;
        uint64_t v132 = &v103[v131];
        while (1)
        {
          uint64_t v133 = *(void *)&v103[v130];
          uint64_t v134 = *(void *)(v129 + v130);
          if (v133 != v134) {
            break;
          }
          v130 += 8LL;
          if (v131 == v130) {
            goto LABEL_365;
          }
        }

        unint64_t v131 = v130 + (__clz(__rbit64(v134 ^ v133)) >> 3);
      }

      if (v131 != v115) {
        goto LABEL_351;
      }
      unint64_t v135 = v115 + 1;
      unsigned int v136 = v115 | (32 * ((v108 << v116) + v114));
      if (*(_DWORD *)(a5 + 4 * (v115 + 1)) < v136) {
        unsigned int v136 = *(_DWORD *)(a5 + 4 * (v115 + 1));
      }
      *(_DWORD *)(a5 + 4 * v135) = v136;
      unint64_t v137 = v115 + 2;
      if (v115 + 2 >= a4) {
        goto LABEL_350;
      }
      unint64_t v138 = &a2[v135];
      int v139 = *v138;
      if (v139 == 32)
      {
        uint64_t v140 = v110;
      }

      else if (v139 == 40)
      {
        uint64_t v140 = v109;
      }

      else
      {
        if (v102 != 32) {
          goto LABEL_350;
        }
        switch(v139)
        {
          case '=':
            int v159 = v138[1];
            if (v159 == 39)
            {
              unint64_t v137 = v115 + 3;
              uint64_t v140 = 98LL;
            }

            else
            {
              if (v159 != 34) {
                goto LABEL_350;
              }
              unint64_t v137 = v115 + 3;
              uint64_t v140 = 81LL;
            }

            break;
          case '.':
            unsigned int v160 = v115 | (32 * ((71LL << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v160) {
              unsigned int v160 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v160;
            if (v138[1] != 32) {
              goto LABEL_350;
            }
            unint64_t v137 = v115 + 3;
            uint64_t v140 = 52LL;
            break;
          case ',':
            unsigned int v155 = v115 | (32 * ((103LL << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v155) {
              unsigned int v155 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v155;
            if (v138[1] != 32) {
              goto LABEL_350;
            }
            unint64_t v137 = v115 + 3;
            uint64_t v140 = 33LL;
            break;
          default:
            goto LABEL_350;
        }
      }

      goto LABEL_347;
    }
  }

LABEL_377:
  if (a4 < 6) {
    return v8;
  }
  int v167 = a2[1];
  int v168 = *a2;
  if (v167 == 32)
  {
    if (v168 != 44 && v168 != 101 && v168 != 115) {
      goto LABEL_420;
    }
  }

  else if (v167 != 160 || v168 != 194)
  {
    goto LABEL_420;
  }

  uint64_t v169 = a1[5];
  BOOL v170 = a2 + 2;
  uint64_t v171 = *(unsigned __int16 *)(v169 + 2LL * ((506832829 * *(_DWORD *)(a2 + 2)) >> 17));
  if (*(_WORD *)(v169 + 2LL * ((506832829 * *(_DWORD *)(a2 + 2)) >> 17)))
  {
    uint64_t v172 = a1[6];
    uint64_t v173 = *a1;
    while (1)
    {
      unint64_t v174 = (char *)(v172 + 4 * v171);
      char v175 = *v174;
      unint64_t v176 = *v174 & 0x1F;
      if (v174[1]) {
        BOOL v177 = 0;
      }
      else {
        BOOL v177 = a4 - 2 >= v176;
      }
      if (!v177) {
        goto LABEL_412;
      }
      int v178 = *((unsigned __int16 *)v174 + 1);
      unint64_t v179 = *(void *)(v173 + 168)
      if (v176 < 8)
      {
        unint64_t v181 = 0LL;
        uint64_t v182 = a2 + 2;
LABEL_415:
        unint64_t v190 = v176 & 7;
        if ((v176 & 7) != 0)
        {
          unint64_t v191 = v181 | v190;
          while (*(unsigned __int8 *)(v179 + v181) == *v182)
          {
            ++v182;
            ++v181;
            if (!--v190)
            {
              unint64_t v181 = v191;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v180 = 0LL;
        unint64_t v181 = *v174 & 0x18;
        uint64_t v182 = &v170[v181];
        while (1)
        {
          uint64_t v183 = *(void *)&v170[v180];
          uint64_t v184 = *(void *)(v179 + v180);
          if (v183 != v184) {
            break;
          }
          v180 += 8LL;
          if (v181 == v180) {
            goto LABEL_415;
          }
        }

        unint64_t v181 = v180 + (__clz(__rbit64(v184 ^ v183)) >> 3);
      }

      if (v181 != v176) {
        goto LABEL_412;
      }
      int v185 = *a2;
      if (v185 == 194) {
        break;
      }
      if (v176 + 2 < a4 && a2[v176 + 2] == 32)
      {
        if (v185 == 115) {
          uint64_t v186 = 7LL;
        }
        else {
          uint64_t v186 = 13LL;
        }
        if (v185 == 101) {
          uint64_t v186 = 18LL;
        }
        uint64_t v187 = 3LL;
        goto LABEL_401;
      }

LABEL_412:
      ++v171;
      if (v175 < 0) {
        goto LABEL_420;
      }
    }

    uint64_t v186 = 102LL;
    uint64_t v187 = 2LL;
LABEL_401:
    unint64_t v188 = v187 + v176;
    unsigned int v189 = v176 | (32 * ((v186 << *(_BYTE *)(v173 + v176)) + v178));
    if (*(_DWORD *)(a5 + 4 * v188) < v189) {
      unsigned int v189 = *(_DWORD *)(a5 + 4 * v188);
    }
    *(_DWORD *)(a5 + 4 * v188) = v189;
    uint64_t v8 = 1LL;
    goto LABEL_412;
  }

LABEL_420:
  if (a4 < 9) {
    return v8;
  }
  int v192 = *a2;
  if (v192 != 46)
  {
    if (v192 != 32 || a2[1] != 116 || a2[2] != 104 || a2[3] != 101 || a2[4] != 32) {
      return v8;
    }
    goto LABEL_432;
  }

  if (a2[1] == 99 && a2[2] == 111 && a2[3] == 109 && a2[4] == 47)
  {
LABEL_432:
    unint64_t v193 = a2 + 5;
    unsigned int v194 = (506832829 * *(_DWORD *)(a2 + 5)) >> 17;
    uint64_t v195 = *(unsigned __int16 *)(a1[5] + 2LL * v194);
    if (!*(_WORD *)(a1[5] + 2LL * v194)) {
      return v8;
    }
    uint64_t v196 = a1[6];
    uint64_t v197 = *a1;
    do
    {
      int v198 = (char *)(v196 + 4 * v195);
      char v199 = *v198;
      unint64_t v200 = *v198 & 0x1F;
      if (v198[1]) {
        BOOL v201 = 0;
      }
      else {
        BOOL v201 = v101 >= v200;
      }
      if (!v201) {
        goto LABEL_469;
      }
      unsigned int v202 = *((unsigned __int16 *)v198 + 1);
      unint64_t v203 = *(void *)(v197 + 168)
      if (v200 < 8)
      {
        unint64_t v205 = 0LL;
        int32x4_t v206 = a2 + 5;
LABEL_472:
        unint64_t v218 = v200 & 7;
        if ((v200 & 7) != 0)
        {
          uint64_t v219 = v205 | v218;
          while (*(unsigned __int8 *)(v203 + v205) == *v206)
          {
            ++v206;
            ++v205;
            if (!--v218)
            {
              unint64_t v205 = v219;
              break;
            }
          }
        }
      }

      else
      {
        uint64_t v204 = 0LL;
        unint64_t v205 = v200 & 0x18;
        int32x4_t v206 = &v193[v205];
        while (1)
        {
          uint64_t v207 = *(void *)&v193[v204];
          uint64_t v208 = *(void *)(v203 + v204);
          if (v207 != v208) {
            break;
          }
          v204 += 8LL;
          if (v205 == v204) {
            goto LABEL_472;
          }
        }

        unint64_t v205 = v204 + (__clz(__rbit64(v208 ^ v207)) >> 3);
      }

      if (v205 != v200) {
        goto LABEL_469;
      }
      char v209 = *(_BYTE *)(v197 + v200);
      if (*a2 == 32) {
        uint64_t v210 = 41LL;
      }
      else {
        uint64_t v210 = 72LL;
      }
      unint64_t v211 = v200 + 5;
      unsigned int v212 = v200 | (32 * ((v210 << v209) + v202));
      if (*(_DWORD *)(a5 + 4 * (v200 + 5)) < v212) {
        unsigned int v212 = *(_DWORD *)(a5 + 4 * (v200 + 5));
      }
      *(_DWORD *)(a5 + 4 * v211) = v212;
      if (v211 < a4)
      {
        uint64_t v8 = 1LL;
        if (*a2 != 32 || v200 + 8 >= a4) {
          goto LABEL_469;
        }
        unint64_t v213 = &a2[v211];
        if (a2[v211] == 32 && v213[1] == 111 && v213[2] == 102 && v213[3] == 32)
        {
          unsigned int v214 = v200 | (32 * ((62LL << v209) + v202));
          uint64_t v215 = a5 + 4 * v200;
          if (*(_DWORD *)(v215 + 36) < v214) {
            unsigned int v214 = *(_DWORD *)(v215 + 36);
          }
          *(_DWORD *)(v215 + 36) = v214;
          if (v200 + 12 < a4 && v213[4] == 116 && v213[5] == 104 && v213[6] == 101 && v213[7] == 32)
          {
            unsigned int v216 = v200 | (32 * ((73LL << v209) + v202));
            uint64_t v217 = a5 + 4 * v200;
            if (*(_DWORD *)(v217 + 52) < v216) {
              unsigned int v216 = *(_DWORD *)(v217 + 52);
            }
            *(_DWORD *)(v217 + 52) = v216;
          }
        }
      }

      uint64_t v8 = 1LL;
LABEL_469:
      ++v195;
    }

    while ((v199 & 0x80) == 0);
  }

  return v8;
}

uint64_t lzfseStreamEncodeStateSize(int a1)
{
  return lzfseEncodeGetScratchSize(a1) + 1573080;
}

uint64_t lzfseStreamEncodeInit(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }

  int ScratchSize = lzfseEncodeGetScratchSize(a2);
  unsigned int v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, a2, ScratchSize + 1573080, ScratchSize + 1572864);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  uint64_t result = 0LL;
  v7[8] = 216LL;
  v7[13] = 786648LL;
  v7[14] = 786648LL;
  v7[15] = 1573080LL;
  v7[2] = 216LL;
  v7[3] = 786648LL;
  v7[4] = 1573080LL;
  return result;
}

uint64_t lzfseStreamEncode(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = (uint64_t *)(v3 + 64);
  *(void *)(v3 + 64) += v3;
  int64x2_t v5 = vdupq_n_s64(v3);
  *(int64x2_t *)(v3 + 104) = vaddq_s64(v5, *(int64x2_t *)(v3 + 104));
  *(void *)(v3 + 120) += v3;
  int64x2_t v37 = v5;
  *(int64x2_t *)(v3 + 16) = vaddq_s64(v5, *(int64x2_t *)(v3 + 16));
  *(void *)(v3 + 32) += v3;
  if ((a2 & 1) != 0) {
    *(_DWORD *)(v3 + 44) = 1;
  }
  while (1)
  {
    if (*(_DWORD *)(v3 + 48))
    {
      int64_t v6 = 0LL;
    }

    else
    {
      uint64_t v7 = *(void *)(v3 + 72);
      unint64_t v8 = *(void *)(a1 + 24);
      if (v8 >= 786432 - v7) {
        int64_t v6 = 786432 - v7;
      }
      else {
        int64_t v6 = *(void *)(a1 + 24);
      }
      if (v6 >= 1)
      {
        memcpy((void *)(*(void *)(v3 + 16) + v7), *(const void **)(a1 + 16), v6);
        *(void *)(v3 + 72) += v6;
        unint64_t v8 = *(void *)(a1 + 24) - v6;
        *(void *)(a1 + 16) += v6;
        *(void *)(a1 + 24) = v8;
      }

      if (!v8 && *(_DWORD *)(v3 + 44)) {
        *(_DWORD *)(v3 + 48) = 1;
      }
    }

    uint64_t v9 = *(char **)(v3 + 112);
    uint64_t v10 = *(char **)(v3 + 24);
    if (v9 >= v10 + 393216)
    {
      uint64_t v11 = *(_BYTE **)(v3 + 104);
      uint64_t v12 = v11 - v9;
      if (v11 != v9)
      {
        memmove(v10, v9, v11 - v9);
        uint64_t v10 = *(char **)(v3 + 24);
      }

      *(void *)(v3 + 104) = &v10[v12];
      *(void *)(v3 + 112) = v10;
    }

    if (*(_DWORD *)(v3 + 48)) {
      break;
    }
LABEL_28:
    if (!*(_DWORD *)(v3 + 52))
    {
LABEL_29:
      if (*(_DWORD *)(v3 + 40))
      {
LABEL_30:
        lzfseEncodeSetStateScratch((uint64_t)v4, *(void *)(v3 + 32));
      }

      else
      {
LABEL_31:
        lzfseEncodeInitState((uint64_t)v4, *(_DWORD *)(v3 + 4), *(void *)(v3 + 32));
        *(_DWORD *)(v3 + 40) = 1;
      }

      uint64_t v25 = *(void *)(v3 + 72);
      *(void *)(v3 + 96) = v25 - 400;
      if (*(_DWORD *)(v3 + 48)) {
        *(void *)(v3 + 96) = v25 - 8;
      }
      lzfseEncodeBase((uint64_t)v4);
      if (*(_DWORD *)(v3 + 48) && *(void *)(v3 + 88) >= *(void *)(v3 + 72) - 8LL)
      {
        *(_DWORD *)(v3 + 52) = 1;
      }

      else if (!*(_DWORD *)(v3 + 52))
      {
        goto LABEL_42;
      }
    }

_DWORD *yzip_codec_create(int a1)
{
  uint64_t result = calloc(1uLL, 0x28uLL);
  if (result) {
    result[8] = a1 == 1;
  }
  return result;
}

void yzip_codec_destroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }

uint64_t yzip_codec_pool_init(void **a1, size_t a2)
{
  if ((unint64_t)a1[3] >= a2)
  {
    unint64_t v3 = (char *)*a1;
    if (*a1) {
      goto LABEL_3;
    }
  }

  else
  {
    a1[3] = (void *)a2;
    unint64_t v3 = (char *)reallocf(*a1, a2);
    *a1 = v3;
    if (v3)
    {
LABEL_3:
      uint64_t result = 0LL;
      int64x2_t v5 = &v3[(void)a1[3]];
      a1[1] = v3;
      a1[2] = v5;
      return result;
    }
  }

  return 0xFFFFFFFFLL;
}

BOOL BrotliIsMostlyUTF8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, double a5)
{
  if (!a4)
  {
    double v20 = 0.0;
    return (double)a4 * a5 < v20;
  }

  unint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  do
  {
    uint64_t v7 = (char *)(a1 + ((v6 + a2) & a3));
    unsigned int v8 = *v7;
    if (*v7 <= 0)
    {
      unint64_t v9 = a4 - v6;
      if (a4 - v6 >= 2)
      {
        if ((v8 & 0xE0) == 0xC0)
        {
          unsigned __int8 v10 = v7[1];
          if ((v10 & 0xC0) == 0x80)
          {
            unsigned int v11 = v10 & 0x3F | ((v8 & 0x1F) << 6);
            if (v11 > 0x7F)
            {
              unsigned int v8 = v11;
              uint64_t v12 = 2LL;
              goto LABEL_24;
            }
          }
        }

        if (v9 >= 3)
        {
          if ((v8 & 0xF0) == 0xE0)
          {
            unsigned __int8 v13 = v7[1];
            if ((v13 & 0xC0) == 0x80)
            {
              unsigned __int8 v14 = v7[2];
              if ((v14 & 0xC0) == 0x80 && (((v8 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F) > 0x7FF)
              {
                unsigned int v8 = ((v8 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F;
                uint64_t v12 = 3LL;
                goto LABEL_24;
              }
            }
          }

          if (v9 >= 4 && (v8 & 0xF8) == 0xF0)
          {
            unsigned __int8 v15 = v7[1];
            if ((v15 & 0xC0) == 0x80)
            {
              unsigned __int8 v16 = v7[2];
              if ((v16 & 0xC0) == 0x80)
              {
                unsigned __int8 v17 = v7[3];
                if ((v17 & 0xC0) == 0x80)
                {
                  int v18 = ((v8 & 7) << 18) | ((v15 & 0x3F) << 12);
                  if ((v18 - 0x10000) < 0x100000)
                  {
                    unsigned int v8 = v17 & 0x3F | ((v16 & 0x3F) << 6) | v18;
                    uint64_t v12 = 4LL;
                    goto LABEL_24;
                  }
                }
              }
            }
          }
        }
      }

      v8 |= 0x110000u;
    }

    uint64_t v12 = 1LL;
LABEL_24:
    v6 += v12;
    if (v8 >= 0x110000) {
      uint64_t v19 = 0LL;
    }
    else {
      uint64_t v19 = v12;
    }
    v5 += v19;
  }

  while (v6 < a4);
  double v20 = (double)v5;
  return (double)a4 * a5 < v20;
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  if (algorithm - 512 >= 0xA) {
    compression_algorithm v1 = algorithm;
  }
  else {
    compression_algorithm v1 = COMPRESSION_ZLIB;
  }
  if (v1 - 1280 >= 0xA) {
    int v2 = v1;
  }
  else {
    int v2 = 1285;
  }
  if (v2 > 2192)
  {
    if (v2 > 3071)
    {
      return 0LL;
    }

    if (v2 != 2193)
    {
      if (v2 == 2209) {
        return lzfse_decode_buffer_scratch_size_iboot();
      }
      return 0LL;
    }

    return lzfse_decode_scratch_size(v2);
  }

  if (v2 > 1284)
  {
    if ((v2 - 2049) >= 2)
    {
      if (v2 != 1285) {
        return 0LL;
      }
      return zlib_decode_scratch_size();
    }

    return lzfse_decode_scratch_size(v2);
  }

  switch(v2)
  {
    case 517:
      return zlib_decode_scratch_size();
    case 774:
      return lzma_xz_buffer_decode_scratch_size();
    case 1031:
      return lzx_decode_scratch_size();
  }

  return 0LL;
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v1 = algorithm;
  }
  else {
    compression_algorithm v1 = 2584;
  }
  if (v1 - 512 >= 0xA) {
    int v2 = v1;
  }
  else {
    int v2 = 517;
  }
  else {
    int v3 = 1285;
  }
  if (v3 > 2048)
  {
    if (v3 <= 2303)
    {
      return 0LL;
    }

    if (v3 != 2584) {
      return 0LL;
    }
    return lz24_encode_scratch_buffer_size();
  }

  else
  {
    if (v3 > 1284)
    {
      if (v3 != 1285) {
        return 0LL;
      }
      return zlib_encode_scratch_size();
    }

    if (v3 <= 773)
    {
      if (v3 != 517) {
        return 0LL;
      }
      return zlib_encode_scratch_size();
    }

    if (v3 != 774) {
      return 0LL;
    }
    return lzvn_decode_scratch_size();
  }

size_t compression_encode_buffer( uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  unsigned __int8 v6 = algorithm;
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v11 = algorithm;
  }
  else {
    compression_algorithm v11 = 2584;
  }
  if (v11 - 2816 >= 0xA) {
    int v12 = 2;
  }
  else {
    int v12 = v11 & 0xF;
  }
  if (v11 - 2816 < 0xA) {
    compression_algorithm v11 = 2818;
  }
  if (v11 - 512 >= 0xA) {
    int v13 = 5;
  }
  else {
    int v13 = v11 & 0xF;
  }
  if (v11 - 512 < 0xA) {
    compression_algorithm v11 = COMPRESSION_ZLIB;
  }
  if (v11 - 1280 >= 0xA) {
    int v14 = v13;
  }
  else {
    int v14 = v11 & 0xF;
  }
  if (v11 - 1280 >= 0xA) {
    compression_algorithm v15 = v11;
  }
  else {
    compression_algorithm v15 = 1285;
  }
  size_t v16 = compression_encode_scratch_buffer_size(v15);
  rsize_t v17 = v16;
  if (scratch_buffer) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = v16 == 0;
  }
  char v19 = v18;
  if (!v18)
  {
    scratch_buffer = malloc(v16);
    if (!scratch_buffer) {
      return 0LL;
    }
  }

  char v31 = v19;
  size_t v20 = 0LL;
  if ((int)v15 <= 2048)
  {
    if ((int)v15 <= 1284)
    {
      if ((int)v15 <= 516)
      {
        if (v15 == COMPRESSION_LZ4)
        {
          unint64_t v21 = lz4_encode_buffer( (int32x4_t *)dst_buffer,  dst_size,  (char *)src_buffer,  src_size,  (char *)scratch_buffer);
        }

        else
        {
          if (v15 != COMPRESSION_LZ4_RAW) {
            goto LABEL_66;
          }
          unint64_t v21 = lz4raw_encode_buffer((int32x4_t *)dst_buffer, dst_size, (char *)src_buffer, src_size, scratch_buffer);
        }

        goto LABEL_65;
      }

      if (v15 != COMPRESSION_ZLIB)
      {
        if (v15 != COMPRESSION_LZMA) {
          goto LABEL_66;
        }
        unint64_t v21 = lzma_encode_buffer();
        goto LABEL_65;
      }

      uint64_t v23 = dst_buffer;
      size_t v24 = dst_size;
      uint64_t v25 = src_buffer;
      size_t v26 = src_size;
      unint64_t v27 = scratch_buffer;
      int v28 = v14;
      int v29 = 0;
    }

    else
    {
      if (v15 - 1536 < 3)
      {
        unint64_t v21 = lzbitmap_fast_encode_buffer( (uint64_t)dst_buffer,  dst_size,  (char *)src_buffer,  src_size,  scratch_buffer,  v15 & 0xF);
        goto LABEL_65;
      }

      if (v15 - 1792 < 3)
      {
        unint64_t v21 = lzbitmap_encode_buffer( (int *)dst_buffer,  dst_size,  (uint64_t)src_buffer,  src_size,  (uint64_t)scratch_buffer,  v15 & 0xF);
LABEL_65:
        size_t v20 = v21;
        goto LABEL_66;
      }

      if (v15 != 1285) {
        goto LABEL_66;
      }
      uint64_t v23 = dst_buffer;
      size_t v24 = dst_size;
      uint64_t v25 = src_buffer;
      size_t v26 = src_size;
      unint64_t v27 = scratch_buffer;
      int v28 = v14;
      int v29 = 1;
    }

    unint64_t v21 = (unint64_t)zlib_encode_buffer((uint64_t)v23, v24, (uint64_t)v25, v26, (uint64_t)v27, v28, v29);
    goto LABEL_65;
  }

  if ((int)v15 > 2583)
  {
    if (v15 - 3072 > 0x20 || ((1LL << v15) & 0x100010001LL) == 0)
    {
      if (v15 == 2584)
      {
        unint64_t v21 = lz24_encode_buffer((char *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char *)scratch_buffer, v6);
      }

      else
      {
        if (v15 != 2818) {
          goto LABEL_66;
        }
        unint64_t v21 = brotli_encode_buffer(dst_buffer, dst_size, (uint64_t *)src_buffer, src_size, (uint64_t)scratch_buffer, v12);
      }
    }

    else
    {
      unint64_t v21 = smb_encode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, v15);
    }

    goto LABEL_65;
  }

  if ((int)v15 > 2208)
  {
    if (v15 - 2304 < 2)
    {
      unint64_t v21 = (unint64_t)lzvn_encode_buffer( (char *)dst_buffer,  dst_size,  (const float *)src_buffer,  src_size,  (int8x16_t *)scratch_buffer,  v15);
      goto LABEL_65;
    }

    if (v15 != 2209) {
      goto LABEL_66;
    }
LABEL_60:
    unint64_t v21 = (unint64_t)lzfse_encode_buffer( (uint64_t)dst_buffer,  dst_size,  (const float *)src_buffer,  src_size,  (int8x16_t *)scratch_buffer,  v15);
    goto LABEL_65;
  }

  if (v15 - 2049 < 2 || v15 == 2193) {
    goto LABEL_60;
  }
LABEL_66:
  if ((v31 & 1) == 0)
  {
    memset_s(scratch_buffer, v17, 0, v17);
    free(scratch_buffer);
  }

  return v20;
}

size_t compression_decode_buffer( uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v11 = algorithm;
  }
  else {
    compression_algorithm v11 = 2584;
  }
  if (v11 - 2816 < 0xA) {
    compression_algorithm v11 = 2818;
  }
  if (v11 - 512 < 0xA) {
    compression_algorithm v11 = COMPRESSION_ZLIB;
  }
  if (v11 - 1280 >= 0xA) {
    compression_algorithm v12 = v11;
  }
  else {
    compression_algorithm v12 = 1285;
  }
  size_t v13 = compression_decode_scratch_buffer_size(v12);
  rsize_t v18 = v13;
  if (scratch_buffer) {
    BOOL v19 = 1;
  }
  else {
    BOOL v19 = v13 == 0;
  }
  char v20 = v19;
  if (!v19)
  {
    scratch_buffer = malloc(v13);
    if (!scratch_buffer) {
      return 0LL;
    }
  }

  size_t v21 = 0LL;
  if ((int)v12 <= 2048)
  {
    if ((int)v12 <= 1284)
    {
      if ((int)v12 <= 516)
      {
        if (v12 == COMPRESSION_LZ4)
        {
          unint64_t v22 = lz4_decode_buffer((char *)dst_buffer, (_BYTE *)dst_size, (unsigned __int8 *)src_buffer, src_size);
        }

        else
        {
          if (v12 != COMPRESSION_LZ4_RAW) {
            goto LABEL_60;
          }
          unint64_t v22 = (unint64_t)lz4raw_decode_buffer( (char *)dst_buffer,  dst_size,  (unsigned __int8 *)src_buffer,  src_size);
        }

        goto LABEL_59;
      }

      if (v12 != COMPRESSION_ZLIB)
      {
        if (v12 == COMPRESSION_LZMA)
        {
          size_t v21 = lzma_xz_buffer_decode((uint64_t)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, scratch_buffer);
          if (v21) {
            goto LABEL_60;
          }
          unint64_t v22 = lzma_decode_buffer();
        }

        else
        {
          if (v12 != 1031) {
            goto LABEL_60;
          }
          unint64_t v22 = lzx_decode_buffer( (uint64_t)dst_buffer,  dst_size,  (uint64_t)src_buffer,  src_size,  (unsigned int *)scratch_buffer);
        }

        goto LABEL_59;
      }

      size_t v24 = dst_buffer;
      size_t v25 = dst_size;
      size_t v26 = (unsigned __int8 *)src_buffer;
      size_t v27 = src_size;
      int v28 = scratch_buffer;
      int v29 = 0;
      goto LABEL_57;
    }

    if (v12 - 1536 < 3)
    {
      unint64_t v22 = lzbitmap_fast_decode_buffer((uint64_t)dst_buffer, dst_size, (int8x16_t *)src_buffer, src_size, v14);
    }

    else
    {
      if (v12 - 1792 >= 3)
      {
        if (v12 != 1285) {
          goto LABEL_60;
        }
        size_t v24 = dst_buffer;
        size_t v25 = dst_size;
        size_t v26 = (unsigned __int8 *)src_buffer;
        size_t v27 = src_size;
        int v28 = scratch_buffer;
        int v29 = 1;
LABEL_57:
        unint64_t v22 = zlib_decode_buffer(v24, v25, v26, v27, (uint64_t)v28, v29);
        goto LABEL_59;
      }

      unint64_t v22 = lzbitmap_decode_buffer( (uint64_t)dst_buffer,  dst_size,  src_buffer,  src_size,  (uint64_t)scratch_buffer,  *(double *)v14.i64,  v15,  v16,  v17);
    }

LABEL_59:
    size_t v21 = v22;
    goto LABEL_60;
  }

  if ((int)v12 > 2583)
  {
    if (v12 - 3072 > 0x20 || ((1LL << v12) & 0x100010001LL) == 0)
    {
      if (v12 == 2584)
      {
        unint64_t v22 = lz24_decode_buffer((char *)dst_buffer, dst_size, (unsigned int *)src_buffer, src_size);
      }

      else
      {
        if (v12 != 2818) {
          goto LABEL_60;
        }
        unint64_t v22 = brotli_decode_buffer((uint64_t)dst_buffer, dst_size);
      }
    }

    else
    {
      unint64_t v22 = smb_decode_buffer((char *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char *)scratch_buffer, v12);
    }

    goto LABEL_59;
  }

  if ((int)v12 > 2208)
  {
    if (v12 - 2304 >= 2)
    {
      if (v12 != 2209) {
        goto LABEL_60;
      }
      unint64_t v22 = (unint64_t)lzfse_decode_buffer_iboot( (char *)dst_buffer,  dst_size,  (char *)src_buffer,  src_size,  (char **)scratch_buffer);
    }

    else
    {
      unint64_t v22 = lzvn_decode_buffer((uint64_t)dst_buffer, dst_size, (unint64_t)src_buffer, src_size);
    }

    goto LABEL_59;
  }

  if (v12 - 2049 < 2 || v12 == 2193)
  {
    unint64_t v22 = lzfse_decode_buffer((uint64_t)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, scratch_buffer, v12);
    goto LABEL_59;
  }

LABEL_60:
  if ((v20 & 1) == 0)
  {
    memset_s(scratch_buffer, v18, 0, v18);
    free(scratch_buffer);
  }

  return v21;
}

uint64_t BrotliCompressFragmentTwoPass( uint64_t result, char *__src, unint64_t a3, int a4, unsigned int *a5, char *__dst, uint64_t a7, unsigned int a8, unint64_t *a9, uint64_t a10)
{
  unint64_t v13 = *a9;
  switch(__clz(a8) ^ 0x1F)
  {
    case 8u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl8(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 9u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl9(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xAu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl10(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xBu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl11(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xCu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl12(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xDu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl13(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xEu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl14(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xFu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl15(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0x10u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl16(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0x11u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl17(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    default:
      break;
  }

  if (*a9 - v13 > 8 * a3 + 31)
  {
    *(_BYTE *)(a10 + (v13 >> 3)) &= ~(-1 << (v13 & 7));
    *a9 = v13;
    BrotliStoreMetaBlockHeader(a3, 1u, a9, a10);
    unint64_t v14 = (*(_DWORD *)a9 + 7) & 0xFFFFFFF8;
    *a9 = v14;
    uint64_t result = (uint64_t)memcpy((void *)(a10 + (v14 >> 3)), __src, a3);
    unint64_t v15 = *a9 + 8 * a3;
    *a9 = v15;
    *(_BYTE *)(a10 + (v15 >> 3)) = 0;
  }

  if (a4)
  {
    unint64_t v16 = *a9;
    *(void *)(a10 + (*a9 >> 3)) = (1LL << (*a9 & 7)) | *(unsigned __int8 *)(a10 + (*a9 >> 3));
    *a9 = v16 + 1;
    *(void *)(a10 + ((v16 + 1) >> 3)) = (1LL << ((v16 + 1) & 7)) | *(unsigned __int8 *)(a10 + ((v16 + 1) >> 3));
    *a9 = ((_DWORD)v16 + 9) & 0xFFFFFFF8;
  }

  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl8( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 56;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 54) & 0x3FC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 54) & 0x3FC)) = (_DWORD)v16
                                                                                           - (_DWORD)__src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 54) & 0x3FC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 54) & 0x3FC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 54) & 0x3FC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 54) & 0x3FC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 54) & 0x3FC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

LABEL_19:
      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

      unint64_t v22 = v24;
    }
  }

  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl9( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 55;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 53) & 0x7FC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 53) & 0x7FC)) = (_DWORD)v16
                                                                                           - (_DWORD)__src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 53) & 0x7FC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 53) & 0x7FC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 53) & 0x7FC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 53) & 0x7FC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 53) & 0x7FC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl10( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 54;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 52) & 0xFFC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 52) & 0xFFC)) = (_DWORD)v16
                                                                                           - (_DWORD)__src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 52) & 0xFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 52) & 0xFFC)) = (_DWORD)v16
                                                                                               - (_DWORD)__src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 52) & 0xFFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 52) & 0xFFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 52) & 0xFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl11( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 53;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 51) & 0x1FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 51) & 0x1FFC)) = (_DWORD)v16
                                                                                            - (_DWORD)__src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 51) & 0x1FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 51) & 0x1FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 51) & 0x1FFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 51) & 0x1FFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 51) & 0x1FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl12( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 52;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 50) & 0x3FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 50) & 0x3FFC)) = (_DWORD)v16
                                                                                            - (_DWORD)__src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 50) & 0x3FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 50) & 0x3FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 50) & 0x3FFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 50) & 0x3FFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 50) & 0x3FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl13( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 51;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 49) & 0x7FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 49) & 0x7FFC)) = (_DWORD)v16
                                                                                            - (_DWORD)__src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 49) & 0x7FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 49) & 0x7FFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 49) & 0x7FFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 49) & 0x7FFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 49) & 0x7FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl14( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 50;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 48) & 0xFFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 48) & 0xFFFC)) = (_DWORD)v16
                                                                                            - (_DWORD)__src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 48) & 0xFFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 48) & 0xFFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 48) & 0xFFFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 48) & 0xFFFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 48) & 0xFFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl15( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    compression_algorithm v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000LL : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = (_DWORD)v13 - (_DWORD)v16;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }

        else
        {
          unsigned int v77 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }

      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(_BYTE *)(a8 + (v84 >> 3)) = 0;
        compression_algorithm v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }

    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        compression_algorithm v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000LL * v21) >> 49;
      uint64_t v21 = *(void *)v24;
      size_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }

      else
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if ((char *)v22 - v26 <= 262128)
      {
        int v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_79;
            }
          }

          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v96 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v96 - 68) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | (((_DWORD)v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000LL)) >> 47) & 0x1FFFC)) = (_DWORD)v16
                                                                                                 - (_DWORD)__src
                                                                                                 - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v51) >> 47) & 0x1FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000LL)) >> 47) & 0x1FFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v54 = v16 - &__src[v53];
        BOOL v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0LL;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8LL;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_73;
                }
              }

              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }

            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = ((_DWORD)v63 << 8) - 542145;
                }

                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1LL << v68) + v67) << 8)) + 52;
                }
              }

              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | (((_DWORD)v65 - (v65 >> v66 << v66)) << 8);
              }
            }

            else
            {
              unsigned int v64 = v60 + 42;
            }

            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000LL * v70) >> 47) & 0x1FFFC)) = (_DWORD)v16
                                                                                                 - (_DWORD)__src
                                                                                                 - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000LL)) >> 47) & 0x1FFFC)) = (_DWORD)v16 - (_DWORD)__src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000LL)) >> 47) & 0x1FFFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000LL)) >> 47) & 0x1FFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl16( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v91 = result;
  if (a3)
  {
    unint64_t v9 = a3;
    compression_algorithm v11 = __src;
    unint64_t v96 = __dst;
    while (1)
    {
      unint64_t v12 = v9 >= 0x20000 ? 0x20000LL : v9;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = __dst;
      unint64_t v16 = v11;
      unint64_t v97 = v9;
      uint64_t v98 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_93:
      if (v16 < v13)
      {
        unsigned int v80 = (_DWORD)v13 - (_DWORD)v16;
        uint64_t v81 = v11;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v83 = (v80 << 8) - 1589738;
          if (v80 > 0x5841) {
            int v83 = (v80 << 8) - 5784041;
          }
          if (v80 >> 1 <= 0xC20) {
            unsigned int v82 = (v80 << 8) - 541163;
          }
          else {
            unsigned int v82 = v83;
          }
          unsigned int v84 = __clz(v80 - 66) ^ 0x1F;
          if (v80 <= 0x841) {
            unsigned int v82 = (v84 | (((-1 << v84) + v80 - 66) << 8)) + 10;
          }
          unsigned int v85 = (__clz(v80 - 2) ^ 0x1F) - 1;
          if (v80 <= 0x81) {
            unsigned int v82 = (((v80 - 2) >> v85) + 2 * v85 + 2) | ((v80 - 2 - ((v80 - 2) >> v85 << v85)) << 8);
          }
        }

        else
        {
          unsigned int v82 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v82;
        int v86 = v15;
        memcpy(v15, v16, v80);
        unint64_t v15 = &v86[v80];
        unint64_t __dst = v96;
        compression_algorithm v11 = v81;
      }

      unsigned int v87 = v11;
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - __dst))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v88 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v88 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v91 + 24)) {
          return result;
        }
        unint64_t __dst = v96;
        compression_algorithm v11 = v98;
        unint64_t v9 = v97 - v12;
        if (v97 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v89 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v89;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v89 >> 3)), v87, v12);
        unint64_t v90 = *a7 + 8 * v12;
        *a7 = v90;
        *(_BYTE *)(a8 + (v90 >> 3)) = 0;
        compression_algorithm v11 = v98;
        v9 -= v12;
        unint64_t __dst = v96;
        if (!v9) {
          return result;
        }
      }
    }

    int v94 = v11;
    unint64_t v95 = v12;
    unint64_t v17 = v12 - 6;
    if (v12 - 6 >= v9 - 16) {
      unint64_t v17 = v9 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 6;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = __dst;
    unint64_t v16 = v11;
    uint64_t v100 = v13 - 6;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = &v22[i >> 5];
      if (v24 > v18)
      {
LABEL_92:
        unint64_t __dst = v96;
        unint64_t v9 = v97;
        compression_algorithm v11 = v94;
        unint64_t v12 = v95;
        unint64_t v13 = v98;
        goto LABEL_93;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD0000LL * v21) >> 48;
      uint64_t v21 = *(void *)v24;
      size_t v26 = &v22[-v20];
      if (*(_DWORD *)v22 == *(_DWORD *)v26
        && v22[4] == v26[4]
        && (v22[5] == v26[5] ? (BOOL v27 = v20 < 1) : (BOOL v27 = 1), !v27))
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      else
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*(_DWORD *)v22 != *(_DWORD *)v26 || v22[4] != v26[4] || v22[5] != v26[5]) {
          goto LABEL_24;
        }
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if (v22 - v26 <= 262128)
      {
        int v29 = v26 + 6;
        uint64_t v30 = (unsigned __int8 *)(v22 + 6);
        unint64_t v31 = v19 - v22;
        if ((unint64_t)(v19 - v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_87:
          uint64_t v78 = v31 & 7;
          if (v78)
          {
            unint64_t v79 = v34 | v78;
            while (v29[v34] == *v30)
            {
              ++v30;
              ++v34;
              if (!--v78)
              {
                unint64_t v34 = v79;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 8LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_87;
            }
          }

          unint64_t v34 = v32 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v101 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v101 + 6;
        v14[1] = v43;
        if (v101 + 6 <= 0xB)
        {
          unsigned int v46 = v101 + 26;
          goto LABEL_50;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v101 - 66) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v101 - 66) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v101 - 2) >> 5) + 54) | ((((_BYTE)v101 - 2) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v101 - 2) ^ 0x1F) - 1;
          unsigned int v46 = (((v101 - 2) >> v47) + 2 * v47 + 28) | (((_DWORD)v101 - 2 - ((v101 - 2) >> v47 << v47)) << 8);
LABEL_50:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = &v22[v45];
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if (&v22[v45] >= v18) {
          goto LABEL_92;
        }
        uint64_t v51 = *(void *)(v16 - 5);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v51) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 5;
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 4;
        *(_DWORD *)(a6 + (((506832829 * (v51 & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 3;
        uint64_t v52 = *(void *)(v16 - 2);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v52) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 2;
        *(_DWORD *)(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 1;
        unint64_t v53 = ((506832829 * (v52 & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC;
        uint64_t v54 = *(int *)(a6 + v53);
        *(_DWORD *)(a6 + v53) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v55 = &__src[v54];
        LODWORD(v56) = (_DWORD)v16 - (_DWORD)v55;
        BOOL v19 = v100;
        if (v16 - v55 < 262129 && *(_DWORD *)v16 == *(_DWORD *)v55)
        {
          while (1)
          {
            int v57 = v56;
            if (v16[4] != v55[4] || v16[5] != v55[5]) {
              break;
            }
            uint64_t v58 = v55 + 6;
            unint64_t v59 = (unsigned __int8 *)(v16 + 6);
            unint64_t v60 = v100 - v16;
            if ((unint64_t)(v100 - v16) < 8)
            {
              unint64_t v63 = 0LL;
LABEL_80:
              uint64_t v76 = v60 & 7;
              if (v76)
              {
                unint64_t v77 = v63 | v76;
                while (v58[v63] == *v59)
                {
                  ++v59;
                  ++v63;
                  if (!--v76)
                  {
                    unint64_t v63 = v77;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v61 = 0LL;
              unint64_t v62 = v60 >> 3;
              unint64_t v63 = v60 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v64 = *(void *)&v59[v61];
                uint64_t v65 = *(void *)&v58[v61];
                if (v64 != v65) {
                  break;
                }
                v61 += 8LL;
                if (!--v62)
                {
                  v59 += v60 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_80;
                }
              }

              unint64_t v63 = v61 + (__clz(__rbit64(v65 ^ v64)) >> 3);
            }

            unint64_t v66 = v63 + 6;
            if (v63 + 6 > 9)
            {
              if (v66 > 0x85)
              {
                if (v66 > 0x845)
                {
                  unsigned int v67 = ((_DWORD)v66 << 8) - 542145;
                }

                else
                {
                  unsigned int v69 = v63 - 64;
                  unsigned int v70 = __clz(v69) ^ 0x1F;
                  unsigned int v67 = (v70 | (((-1LL << v70) + v69) << 8)) + 52;
                }
              }

              else
              {
                unsigned int v68 = (__clz(v63) ^ 0x1F) - 1;
                unsigned int v67 = ((v63 >> v68) + 2 * v68 + 44) | (((_DWORD)v63 - (v63 >> v68 << v68)) << 8);
              }
            }

            else
            {
              unsigned int v67 = v63 + 44;
            }

            v16 += v66;
            unsigned int v71 = __clz(v57 + 3);
            *unint64_t v14 = v67;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_92;
            }
            uint64_t v72 = *(void *)(v16 - 5);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v72) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 5;
            *(_DWORD *)(a6 + (((506832829 * ((v72 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16 - (_DWORD)__src - 4;
            *(_DWORD *)(a6 + (((506832829 * (v72 & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 3;
            uint64_t v73 = *(void *)(v16 - 2);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v73) >> 46) & 0x3FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v73 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v74 = ((506832829 * (v73 & 0xFFFFFFFFFFFF0000LL)) >> 46) & 0x3FFFC;
            uint64_t v75 = *(int *)(a6 + v74);
            *(_DWORD *)(a6 + v74) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v55 = &__src[v75];
            uint64_t v56 = v16 - &__src[v75];
            if (v56 < 262129)
            {
              int v20 = v57;
              if (*(_DWORD *)v16 == *(_DWORD *)v55) {
                continue;
              }
            }

            int v20 = v57;
            goto LABEL_10;
          }
        }

        goto LABEL_10;
      }

uint64_t BrotliCompressFragmentTwoPassImpl17( uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v91 = result;
  if (a3)
  {
    unint64_t v9 = a3;
    compression_algorithm v11 = __src;
    unint64_t v96 = __dst;
    while (1)
    {
      unint64_t v12 = v9 >= 0x20000 ? 0x20000LL : v9;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = __dst;
      unint64_t v16 = v11;
      unint64_t v97 = v9;
      uint64_t v98 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_93:
      if (v16 < v13)
      {
        unsigned int v80 = (_DWORD)v13 - (_DWORD)v16;
        uint64_t v81 = v11;
        if (((_DWORD)v13 - (_DWORD)v16) >= 6)
        {
          int v83 = (v80 << 8) - 1589738;
          if (v80 > 0x5841) {
            int v83 = (v80 << 8) - 5784041;
          }
          if (v80 >> 1 <= 0xC20) {
            unsigned int v82 = (v80 << 8) - 541163;
          }
          else {
            unsigned int v82 = v83;
          }
          unsigned int v84 = __clz(v80 - 66) ^ 0x1F;
          if (v80 <= 0x841) {
            unsigned int v82 = (v84 | (((-1 << v84) + v80 - 66) << 8)) + 10;
          }
          unsigned int v85 = (__clz(v80 - 2) ^ 0x1F) - 1;
          if (v80 <= 0x81) {
            unsigned int v82 = (((v80 - 2) >> v85) + 2 * v85 + 2) | ((v80 - 2 - ((v80 - 2) >> v85 << v85)) << 8);
          }
        }

        else
        {
          unsigned int v82 = (_DWORD)v13 - (_DWORD)v16;
        }

        *unint64_t v14 = v82;
        int v86 = v15;
        memcpy(v15, v16, v80);
        unint64_t v15 = &v86[v80];
        unint64_t __dst = v96;
        compression_algorithm v11 = v81;
      }

      unsigned int v87 = v11;
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - __dst))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v88 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v88 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v91 + 24)) {
          return result;
        }
        unint64_t __dst = v96;
        compression_algorithm v11 = v98;
        unint64_t v9 = v97 - v12;
        if (v97 == v12) {
          return result;
        }
      }

      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v89 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v89;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v89 >> 3)), v87, v12);
        unint64_t v90 = *a7 + 8 * v12;
        *a7 = v90;
        *(_BYTE *)(a8 + (v90 >> 3)) = 0;
        compression_algorithm v11 = v98;
        v9 -= v12;
        unint64_t __dst = v96;
        if (!v9) {
          return result;
        }
      }
    }

    int v94 = v11;
    unint64_t v95 = v12;
    unint64_t v17 = v12 - 6;
    if (v12 - 6 >= v9 - 16) {
      unint64_t v17 = v9 - 16;
    }
    rsize_t v18 = &v11[v17];
    BOOL v19 = v13 - 6;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = __dst;
    unint64_t v16 = v11;
    uint64_t v100 = v13 - 6;
LABEL_10:
    unint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      size_t v24 = &v22[i >> 5];
      if (v24 > v18)
      {
LABEL_92:
        unint64_t __dst = v96;
        unint64_t v9 = v97;
        compression_algorithm v11 = v94;
        unint64_t v12 = v95;
        unint64_t v13 = v98;
        goto LABEL_93;
      }

      unint64_t v25 = (unint64_t)(0x1E35A7BD0000LL * v21) >> 47;
      uint64_t v21 = *(void *)v24;
      size_t v26 = &v22[-v20];
      if (*(_DWORD *)v22 == *(_DWORD *)v26
        && v22[4] == v26[4]
        && (v22[5] == v26[5] ? (BOOL v27 = v20 < 1) : (BOOL v27 = 1), !v27))
      {
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
      }

      else
      {
        size_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = (_DWORD)v22 - (_DWORD)__src;
        if (*(_DWORD *)v22 != *(_DWORD *)v26 || v22[4] != v26[4] || v22[5] != v26[5]) {
          goto LABEL_24;
        }
      }

      int v28 = (_DWORD)v22 - (_DWORD)v26;
      if (v22 - v26 <= 262128)
      {
        int v29 = v26 + 6;
        uint64_t v30 = (unsigned __int8 *)(v22 + 6);
        unint64_t v31 = v19 - v22;
        if ((unint64_t)(v19 - v22) < 8)
        {
          unint64_t v34 = 0LL;
LABEL_87:
          uint64_t v78 = v31 & 7;
          if (v78)
          {
            unint64_t v79 = v34 | v78;
            while (v29[v34] == *v30)
            {
              ++v30;
              ++v34;
              if (!--v78)
              {
                unint64_t v34 = v79;
                break;
              }
            }
          }
        }

        else
        {
          uint64_t v32 = 0LL;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8LL;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 8LL;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8LL;
              goto LABEL_87;
            }
          }

          unint64_t v34 = v32 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }

        unsigned int v37 = (_DWORD)v22 - (_DWORD)v16;
        unint64_t v101 = v34;
        if (((_DWORD)v22 - (_DWORD)v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }

              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }

            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }

          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }

        else
        {
          unsigned int v38 = (_DWORD)v22 - (_DWORD)v16;
        }

        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }

        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          int v20 = v28;
        }

        unint64_t v45 = v101 + 6;
        v14[1] = v43;
        if (v101 + 6 <= 0xB)
        {
          unsigned int v46 = v101 + 26;
          goto LABEL_50;
        }

        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = ((_DWORD)v45 << 8) - 542657;
            }

            else
            {
              unsigned int v50 = __clz(v101 - 66) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1LL << v50) + (_DWORD)v101 - 66) << 8)) + 52;
            }
          }

          else
          {
            unsigned int v49 = (((v101 - 2) >> 5) + 54) | ((((_BYTE)v101 - 2) & 0x1F) << 8);
          }

          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4LL;
        }

        else
        {
          unsigned int v47 = (__clz(v101 - 2) ^ 0x1F) - 1;
          unsigned int v46 = (((v101 - 2) >> v47) + 2 * v47 + 28) | (((_DWORD)v101 - 2 - ((v101 - 2) >> v47 << v47)) << 8);
LABEL_50:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3LL;
        }

        unint64_t v16 = &v22[v45];
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if (&v22[v45] >= v18) {
          goto LABEL_92;
        }
        uint64_t v51 = *(void *)(v16 - 5);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v51) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 5;
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 4;
        *(_DWORD *)(a6 + (((506832829 * (v51 & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 3;
        uint64_t v52 = *(void *)(v16 - 2);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v52) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                         - (_DWORD)__src
                                                                                         - 2;
        *(_DWORD *)(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                                - (_DWORD)__src
                                                                                                - 1;
        unint64_t v53 = ((506832829 * (v52 & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC;
        uint64_t v54 = *(int *)(a6 + v53);
        *(_DWORD *)(a6 + v53) = (_DWORD)v16 - (_DWORD)__src;
        uint64_t v55 = &__src[v54];
        LODWORD(v56) = (_DWORD)v16 - (_DWORD)v55;
        BOOL v19 = v100;
        if (v16 - v55 < 262129 && *(_DWORD *)v16 == *(_DWORD *)v55)
        {
          while (1)
          {
            int v57 = v56;
            if (v16[4] != v55[4] || v16[5] != v55[5]) {
              break;
            }
            uint64_t v58 = v55 + 6;
            unint64_t v59 = (unsigned __int8 *)(v16 + 6);
            unint64_t v60 = v100 - v16;
            if ((unint64_t)(v100 - v16) < 8)
            {
              unint64_t v63 = 0LL;
LABEL_80:
              uint64_t v76 = v60 & 7;
              if (v76)
              {
                unint64_t v77 = v63 | v76;
                while (v58[v63] == *v59)
                {
                  ++v59;
                  ++v63;
                  if (!--v76)
                  {
                    unint64_t v63 = v77;
                    break;
                  }
                }
              }
            }

            else
            {
              uint64_t v61 = 0LL;
              unint64_t v62 = v60 >> 3;
              unint64_t v63 = v60 & 0xFFFFFFFFFFFFFFF8LL;
              while (1)
              {
                uint64_t v64 = *(void *)&v59[v61];
                uint64_t v65 = *(void *)&v58[v61];
                if (v64 != v65) {
                  break;
                }
                v61 += 8LL;
                if (!--v62)
                {
                  v59 += v60 & 0xFFFFFFFFFFFFFFF8LL;
                  goto LABEL_80;
                }
              }

              unint64_t v63 = v61 + (__clz(__rbit64(v65 ^ v64)) >> 3);
            }

            unint64_t v66 = v63 + 6;
            if (v63 + 6 > 9)
            {
              if (v66 > 0x85)
              {
                if (v66 > 0x845)
                {
                  unsigned int v67 = ((_DWORD)v66 << 8) - 542145;
                }

                else
                {
                  unsigned int v69 = v63 - 64;
                  unsigned int v70 = __clz(v69) ^ 0x1F;
                  unsigned int v67 = (v70 | (((-1LL << v70) + v69) << 8)) + 52;
                }
              }

              else
              {
                unsigned int v68 = (__clz(v63) ^ 0x1F) - 1;
                unsigned int v67 = ((v63 >> v68) + 2 * v68 + 44) | (((_DWORD)v63 - (v63 >> v68 << v68)) << 8);
              }
            }

            else
            {
              unsigned int v67 = v63 + 44;
            }

            v16 += v66;
            unsigned int v71 = __clz(v57 + 3);
            *unint64_t v14 = v67;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_92;
            }
            uint64_t v72 = *(void *)(v16 - 5);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v72) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 5;
            *(_DWORD *)(a6 + (((506832829 * ((v72 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16 - (_DWORD)__src - 4;
            *(_DWORD *)(a6 + (((506832829 * (v72 & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 3;
            uint64_t v73 = *(void *)(v16 - 2);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000LL * v73) >> 45) & 0x7FFFC)) = (_DWORD)v16
                                                                                             - (_DWORD)__src
                                                                                             - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v73 << 8) & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC)) = (_DWORD)v16 - (_DWORD)__src - 1;
            unint64_t v74 = ((506832829 * (v73 & 0xFFFFFFFFFFFF0000LL)) >> 45) & 0x7FFFC;
            uint64_t v75 = *(int *)(a6 + v74);
            *(_DWORD *)(a6 + v74) = (_DWORD)v16 - (_DWORD)__src;
            uint64_t v55 = &__src[v75];
            uint64_t v56 = v16 - &__src[v75];
            if (v56 < 262129)
            {
              int v20 = v57;
              if (*(_DWORD *)v16 == *(_DWORD *)v55) {
                continue;
              }
            }

            int v20 = v57;
            goto LABEL_10;
          }
        }

        goto LABEL_10;
      }

BOOL ShouldCompress_0(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  double v3 = (double)a2;
  bzero(v20, 0x400uLL);
  if (a2)
  {
    unint64_t v7 = 0LL;
    do
    {
      ++v20[*(unsigned __int8 *)(a1 + v7)];
      v7 += 43LL;
    }

    while (v7 < a2);
  }

  uint64_t v8 = 0LL;
  unint64_t v9 = 0LL;
  double v10 = 0.0;
  double v11 = v3 * 8.0 * 0.98 / 43.0;
  do
  {
    uint64_t v12 = v20[v8];
    if (v12 > 0xFF)
    {
      double v14 = (double)v12;
      double v13 = log2((double)v12);
    }

    else
    {
      double v13 = kBrotliLog2Table[v12];
      double v14 = (double)v12;
    }

    uint64_t v15 = v20[v8 + 1];
    else {
      double v16 = kBrotliLog2Table[v15];
    }
    v8 += 2LL;
    v9 += v12 + v15;
    double v10 = v10 - v14 * v13 - (double)v15 * v16;
  }

  while ((unint64_t)(v8 - 2) < 0xFE);
  double v17 = (double)v9;
  if (v9)
  {
    if (v9 > 0xFF) {
      double v18 = log2((double)v9);
    }
    else {
      double v18 = kBrotliLog2Table[v9];
    }
    double v10 = v10 + v17 * v18;
  }

  if (v10 >= v17) {
    double v19 = v10;
  }
  else {
    double v19 = (double)v9;
  }
  return v19 < v11;
}

unint64_t StoreCommands()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  unint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  unint64_t v13 = v0;
  uint64_t v66 = *MEMORY[0x1895F89C0];
  bzero(v56, 0x400uLL);
  memset(v55, 0, sizeof(v55));
  __int128 v54 = 0u;
  __int128 v52 = 0u;
  memset(v53, 0, sizeof(v53));
  memset(v51, 0, sizeof(v51));
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v39 = 0u;
  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  if (v10)
  {
    double v14 = v12;
    uint64_t v15 = v10;
    do
    {
      int v16 = *v14++;
      ++v56[v16];
      --v15;
    }

    while (v15);
  }

  unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v13, (uint64_t)v56, v10, 8LL, v58, (uint64_t)v57, v4, v2);
  if (!*(_DWORD *)(v13 + 24))
  {
    if (v6)
    {
      double v18 = v8;
      uint64_t v19 = v6;
      do
      {
        unsigned int v20 = *v18;
        v18 += 4;
        ++*((_DWORD *)v37 + v20);
        --v19;
      }

      while (v19);
      int32x2_t v21 = vadd_s32(*(int32x2_t *)((char *)v37 + 4), (int32x2_t)0x100000001LL);
      int v22 = LODWORD(v38[0]) + 1;
      int v23 = v39 + 1;
    }

    else
    {
      int32x2_t v21 = (int32x2_t)0x100000001LL;
      int v23 = 1;
      int v22 = 1;
    }

    *(int32x2_t *)((char *)v37 + 4) = v21;
    LODWORD(v38[0]) = v22;
    LODWORD(v39) = v23;
    bzero(v64, 0x280uLL);
    BrotliCreateHuffmanTree((uint64_t)v37, 64LL, 15, (uint64_t)v65, (uint64_t)&v52);
    BrotliCreateHuffmanTree((uint64_t)v38, 64LL, 14, (uint64_t)v65, (uint64_t)v55);
    *(void *)&v60[16] = *((void *)&v53[1] + 1);
    *(void *)&__int128 v61 = v52;
    *(_OWORD *)unint64_t v60 = *(_OWORD *)((char *)v53 + 8);
    *((void *)&v61 + 1) = v54;
    *(void *)&__int128 v62 = *((void *)&v52 + 1);
    size_t v24 = (char *)v53;
    *((void *)&v62 + 1) = *((void *)&v54 + 1);
    uint64_t v63 = *(void *)&v53[0];
    BrotliConvertBitDepthsToSymbols(v60, 64LL, (uint64_t)v59);
    v50[0] = v59[3];
    v50[1] = v59[5];
    v50[2] = v59[7];
    v50[3] = v59[0];
    v50[4] = v59[1];
    v50[5] = v59[2];
    v50[6] = v59[4];
    v50[7] = v59[6];
    BrotliConvertBitDepthsToSymbols((unsigned __int8 *)v55, 64LL, (uint64_t)v51);
    __int128 v62 = 0u;
    __int128 v61 = 0u;
    *(_OWORD *)&v60[8] = 0u;
    uint64_t v63 = 0LL;
    *(void *)unint64_t v60 = *((void *)&v53[0] + 1);
    v64[8] = *((void *)&v53[1] + 1);
    v64[0] = *(void *)&v53[1];
    v64[40] = *((void *)&v54 + 1);
    v64[16] = v54;
    for (uint64_t i = 256LL; i != 320; i += 8LL)
    {
      size_t v26 = &v60[i];
      *(v26 - 128) = *(v24 - 16);
      *size_t v26 = *(v24 - 8);
      char v27 = *v24++;
      v26[192] = v27;
    }

    BrotliStoreHuffmanTree((uint64_t)v60, 0x2C0uLL, (uint64_t)v65, v4, v2);
    unint64_t result = BrotliStoreHuffmanTree((uint64_t)v55, 0x40uLL, (uint64_t)v65, v4, v2);
    if (v6)
    {
      uint64_t v28 = 0LL;
      unint64_t v29 = *v4;
      do
      {
        unint64_t v30 = *(unsigned int *)&v8[4 * v28];
        uint64_t v31 = *(_DWORD *)&v8[4 * v28];
        uint64_t v32 = *((unsigned __int8 *)&v53[-1] + v31);
        *(void *)(v2 + (v29 >> 3)) = ((unint64_t)*((unsigned __int16 *)v50 + v31) << (v29 & 7)) | *(unsigned __int8 *)(v2 + (v29 >> 3));
        unint64_t v33 = v29 + v32;
        *unint64_t v4 = v33;
        unint64_t result = StoreCommands_kNumExtraBits[v31];
        unint64_t v34 = v30 >> 8;
        *(void *)(v2 + (v33 >> 3)) = (v34 << (v33 & 7)) | *(unsigned __int8 *)(v2 + (v33 >> 3));
        unint64_t v29 = v33 + result;
        *unint64_t v4 = v29;
        if (v31 <= 0x17)
        {
          for (int j = StoreCommands_kInsertOffset[v31] + v34; j; --j)
          {
            int v36 = *v12++;
            unint64_t result = v58[v36];
            *(void *)(v2 + (v29 >> 3)) = ((unint64_t)(unsigned __int16)v57[v36] << (v29 & 7)) | *(unsigned __int8 *)(v2 + (v29 >> 3));
            v29 += result;
            *unint64_t v4 = v29;
          }
        }

        ++v28;
      }

      while (v28 != v6);
    }
  }

  return result;
}

const z_crc_t *get_crc_table(void)
{
  return (const z_crc_t *)&crc_table;
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  if (!buf) {
    return 0LL;
  }
  unsigned int v3 = ~(_DWORD)crc;
  if (len && (buf & 3) != 0)
  {
    unint64_t v4 = buf + 1;
    do
    {
      char v5 = *buf++;
      unsigned int v3 = *((void *)&crc_table + (v5 ^ v3)) ^ (v3 >> 8);
      if (!--len) {
        break;
      }
    }

    while ((unint64_t)(v4++ & 3));
  }

  if (len >= 0x20)
  {
    unint64_t v7 = (char *)&crc_table + 6144;
    do
    {
      unsigned int v8 = *(_DWORD *)buf ^ v3;
      int v9 = qword_1810CC8A0[BYTE1(v8) + 256] ^ *(void *)&v7[8 * (*buf ^ v3)];
      unsigned int v10 = *((_DWORD *)buf + 1) ^ v9 ^ qword_1810CC8A0[BYTE2(v8)] ^ *((void *)&crc_table + HIBYTE(v8));
      unsigned int v11 = *((_DWORD *)buf + 2) ^ qword_1810CC8A0[BYTE1(v10) + 256] ^ *(void *)&v7[8
                                                                                    * (buf[4] ^ v9 ^ qword_1810CC8A0[BYTE2(v8)] ^ *((void *)&crc_table + HIBYTE(v8)))] ^ qword_1810CC8A0[BYTE2(v10)] ^ *((void *)&crc_table + HIBYTE(v10));
      unsigned int v12 = *((_DWORD *)buf + 3) ^ qword_1810CC8A0[BYTE1(v11) + 256] ^ *(void *)&v7[8 * v11] ^ qword_1810CC8A0[BYTE2(v11)] ^ *((void *)&crc_table + HIBYTE(v11));
      unsigned int v13 = *((_DWORD *)buf + 4) ^ qword_1810CC8A0[BYTE1(v12) + 256] ^ *(void *)&v7[8 * v12] ^ qword_1810CC8A0[BYTE2(v12)] ^ *((void *)&crc_table + HIBYTE(v12));
      unsigned int v14 = *((_DWORD *)buf + 5) ^ qword_1810CC8A0[BYTE1(v13) + 256] ^ *(void *)&v7[8 * v13] ^ qword_1810CC8A0[BYTE2(v13)] ^ *((void *)&crc_table + HIBYTE(v13));
      unsigned int v15 = *((_DWORD *)buf + 6) ^ qword_1810CC8A0[BYTE1(v14) + 256] ^ *(void *)&v7[8 * v14] ^ qword_1810CC8A0[BYTE2(v14)] ^ *((void *)&crc_table + HIBYTE(v14));
      int v16 = qword_1810CC8A0[BYTE1(v15) + 256] ^ *(void *)&v7[8 * v15] ^ qword_1810CC8A0[BYTE2(v15)] ^ *((void *)&crc_table + HIBYTE(v15));
      double v17 = buf + 32;
      unsigned int v18 = *((_DWORD *)buf + 7) ^ v16;
      unsigned int v3 = qword_1810CC8A0[BYTE1(v18) + 256] ^ *(void *)&v7[8 * v18] ^ qword_1810CC8A0[BYTE2(v18)] ^ *((void *)&crc_table + HIBYTE(v18));
      len -= 32;
      buf += 32;
    }

    while (len > 0x1F);
    buf = v17;
  }

  if (len >= 4)
  {
    do
    {
      int v19 = *(_DWORD *)buf;
      buf += 4;
      unsigned int v3 = *((_DWORD *)&crc_table + 2 * ((unsigned __int16)(v19 ^ v3) >> 8) + 1024) ^ *((_DWORD *)&crc_table + 2 * (v19 ^ v3) + 1536) ^ *((_DWORD *)&crc_table + 2 * ((v19 ^ v3) >> 16) + 512) ^ *((void *)&crc_table + ((v19 ^ v3) >> 24));
      len -= 4;
    }

    while (len > 3);
  }

  for (; len; --len)
  {
    char v20 = *buf++;
    unsigned int v3 = *((void *)&crc_table + (v20 ^ v3)) ^ (v3 >> 8);
  }

  return ~v3;
}

uint64_t touchpadGetInfoWithCompressedBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0LL;
  v6[0] = a3;
  v6[1] = a4;
  memset(&v6[2], 0, 24);
  if (a2 == 9)
  {
    if (codecReadHeader(v6, a1)) {
      return 9LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

BOOL codecReadHeader(uint64_t *a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 8) = 0;
  *(void *)a2 = 0LL;
  int v2 = *((_DWORD *)a1 + 9);
  if (v2 <= 15)
  {
    unint64_t v4 = a1[1];
    unint64_t v3 = a1[2];
    a1[2] = v3 + 1;
    if (v3 < v4)
    {
      uint64_t v5 = *a1;
      uint64_t v6 = a1[3];
      a1[3] = v6 + 1;
      LODWORD(v5) = (*(unsigned __int8 *)(v5 + v6) << v2) | *((_DWORD *)a1 + 8);
      v2 += 8;
      *((_DWORD *)a1 + 8) = v5;
      *((_DWORD *)a1 + 9) = v2;
    }

    a1[2] = v3 + 2;
    if (v3 + 1 < v4)
    {
      uint64_t v7 = *a1;
      uint64_t v8 = a1[3];
      a1[3] = v8 + 1;
      *((_DWORD *)a1 + 8) |= *(unsigned __int8 *)(v7 + v8) << v2;
      v2 += 8;
    }
  }

  unsigned int v9 = a1[4] & 0x1F;
  unsigned int v10 = *((_DWORD *)a1 + 8) >> 5;
  int v11 = v2 - 5;
  *((_DWORD *)a1 + 8) = v10;
  *((_DWORD *)a1 + 9) = v2 - 5;
  unsigned int v12 = v9 - 16;
  if (v9 > 0x10)
  {
    if (v2 <= 20)
    {
      unint64_t v24 = a1[1];
      unint64_t v23 = a1[2];
      a1[2] = v23 + 1;
      if (v23 < v24)
      {
        uint64_t v25 = *a1;
        uint64_t v26 = a1[3];
        a1[3] = v26 + 1;
        v10 |= *(unsigned __int8 *)(v25 + v26) << v11;
        int v11 = v2 + 3;
        *((_DWORD *)a1 + 8) = v10;
        *((_DWORD *)a1 + 9) = v2 + 3;
      }

      a1[2] = v23 + 2;
      if (v23 + 1 < v24)
      {
        uint64_t v27 = *a1;
        uint64_t v28 = a1[3];
        a1[3] = v28 + 1;
        v10 |= *(unsigned __int8 *)(v27 + v28) << v11;
        v11 += 8;
      }
    }

    unsigned int v29 = HIWORD(v10);
    int v30 = v11 - 16;
    *((_DWORD *)a1 + 8) = HIWORD(v10);
    *((_DWORD *)a1 + 9) = v11 - 16;
    if (v11 <= 31)
    {
      unint64_t v32 = a1[1];
      unint64_t v31 = a1[2];
      a1[2] = v31 + 1;
      if (v31 < v32)
      {
        uint64_t v33 = *a1;
        uint64_t v34 = a1[3];
        a1[3] = v34 + 1;
        v29 |= *(unsigned __int8 *)(v33 + v34) << v30;
        int v30 = v11 - 8;
        *((_DWORD *)a1 + 8) = v29;
        *((_DWORD *)a1 + 9) = v11 - 8;
      }

      a1[2] = v31 + 2;
      if (v31 + 1 < v32)
      {
        uint64_t v35 = *a1;
        uint64_t v36 = a1[3];
        a1[3] = v36 + 1;
        v29 |= *(unsigned __int8 *)(v35 + v36) << v30;
        v30 += 8;
      }
    }

    int v37 = v29 & ~(-1 << v12);
    unsigned int v20 = v29 >> v12;
    int v21 = v30 - v12;
    *((_DWORD *)a1 + 8) = v20;
    *((_DWORD *)a1 + 9) = v30 - v12;
    int v22 = (unsigned __int16)v10 | (v37 << 16);
    int v19 = -1 << v9;
  }

  else
  {
    if (v2 <= 20)
    {
      unint64_t v14 = a1[1];
      unint64_t v13 = a1[2];
      a1[2] = v13 + 1;
      if (v13 < v14)
      {
        uint64_t v15 = *a1;
        uint64_t v16 = a1[3];
        a1[3] = v16 + 1;
        v10 |= *(unsigned __int8 *)(v15 + v16) << v11;
        int v11 = v2 + 3;
        *((_DWORD *)a1 + 8) = v10;
        *((_DWORD *)a1 + 9) = v2 + 3;
      }

      a1[2] = v13 + 2;
      if (v13 + 1 < v14)
      {
        uint64_t v17 = *a1;
        uint64_t v18 = a1[3];
        a1[3] = v18 + 1;
        v10 |= *(unsigned __int8 *)(v17 + v18) << v11;
        v11 += 8;
      }
    }

    int v19 = -1 << v9;
    unsigned int v20 = v10 >> v9;
    int v21 = v11 - v9;
    *((_DWORD *)a1 + 8) = v10 >> v9;
    *((_DWORD *)a1 + 9) = v21;
    int v22 = v10 & (unsigned __int16)~(unsigned __int16)(-1 << v9);
  }

  int v38 = v22 + ~v19;
  *(_DWORD *)a2 = v38;
  if ((v38 & 1) != 0)
  {
    if (v21 <= 15)
    {
      unint64_t v40 = a1[1];
      unint64_t v39 = a1[2];
      a1[2] = v39 + 1;
      if (v39 < v40)
      {
        uint64_t v41 = *a1;
        uint64_t v42 = a1[3];
        a1[3] = v42 + 1;
        v20 |= *(unsigned __int8 *)(v41 + v42) << v21;
        v21 += 8;
        *((_DWORD *)a1 + 8) = v20;
        *((_DWORD *)a1 + 9) = v21;
      }

      a1[2] = v39 + 2;
      if (v39 + 1 < v40)
      {
        uint64_t v43 = *a1;
        uint64_t v44 = a1[3];
        a1[3] = v44 + 1;
        v20 |= *(unsigned __int8 *)(v43 + v44) << v21;
        v21 += 8;
      }
    }

    int v45 = v20 & 0xF;
    unsigned int v46 = v20 >> 4;
    int v47 = v21 - 4;
    *((_DWORD *)a1 + 8) = v46;
    *((_DWORD *)a1 + 9) = v21 - 4;
    int v48 = v45 + 1;
    if (v21 <= 19)
    {
      unint64_t v50 = a1[1];
      unint64_t v49 = a1[2];
      a1[2] = v49 + 1;
      if (v49 < v50)
      {
        uint64_t v51 = *a1;
        uint64_t v52 = a1[3];
        a1[3] = v52 + 1;
        v46 |= *(unsigned __int8 *)(v51 + v52) << v47;
        int v47 = v21 + 4;
        *((_DWORD *)a1 + 8) = v46;
        *((_DWORD *)a1 + 9) = v21 + 4;
      }

      a1[2] = v49 + 2;
      if (v49 + 1 < v50)
      {
        uint64_t v53 = *a1;
        uint64_t v54 = a1[3];
        a1[3] = v54 + 1;
        v46 |= *(unsigned __int8 *)(v53 + v54) << v47;
        v47 += 8;
      }
    }

    __int16 v55 = ~(unsigned __int16)(-2 << v45);
    __int16 v56 = v46 & v55;
    unsigned int v57 = v46 >> v48;
    int v58 = v47 - v48;
    *((_DWORD *)a1 + 8) = v57;
    *((_DWORD *)a1 + 9) = v47 - v48;
    *(_WORD *)(a2 + 4) = v56;
    if (v47 - v48 <= 15)
    {
      unint64_t v60 = a1[1];
      unint64_t v59 = a1[2];
      a1[2] = v59 + 1;
      if (v59 < v60)
      {
        uint64_t v61 = *a1;
        uint64_t v62 = a1[3];
        a1[3] = v62 + 1;
        v57 |= *(unsigned __int8 *)(v61 + v62) << v58;
        v58 += 8;
        *((_DWORD *)a1 + 8) = v57;
        *((_DWORD *)a1 + 9) = v58;
      }

      a1[2] = v59 + 2;
      if (v59 + 1 < v60)
      {
        uint64_t v63 = *a1;
        uint64_t v64 = a1[3];
        a1[3] = v64 + 1;
        v57 |= *(unsigned __int8 *)(v63 + v64) << v58;
        v58 += 8;
      }
    }

    __int16 v65 = v57 & v55;
    unsigned int v66 = v57 >> v48;
    int v67 = v58 - v48;
    *((_DWORD *)a1 + 8) = v66;
    *((_DWORD *)a1 + 9) = v67;
    *(_WORD *)(a2 + 6) = v65;
    if (v67 <= 15)
    {
      unint64_t v69 = a1[1];
      unint64_t v68 = a1[2];
      a1[2] = v68 + 1;
      if (v68 < v69)
      {
        uint64_t v70 = *a1;
        uint64_t v71 = a1[3];
        a1[3] = v71 + 1;
        v66 |= *(unsigned __int8 *)(v70 + v71) << v67;
        v67 += 8;
        *((_DWORD *)a1 + 8) = v66;
        *((_DWORD *)a1 + 9) = v67;
      }

      a1[2] = v68 + 2;
      if (v68 + 1 < v69)
      {
        uint64_t v72 = *a1;
        uint64_t v73 = a1[3];
        a1[3] = v73 + 1;
        v66 |= *(unsigned __int8 *)(v72 + v73) << v67;
        v67 += 8;
      }
    }

    char v74 = v66 & 0x1F;
    unsigned int v75 = v66 >> 5;
    int v21 = v67 - 5;
    *((_DWORD *)a1 + 8) = v75;
    *((_DWORD *)a1 + 9) = v67 - 5;
    *(_BYTE *)(a2 + 8) = v74 + 1;
  }

  return (v21 & 0x80000000) == 0 && a1[3] != v21 >> 3;
}

uint64_t *codecWriteHeader(uint64_t *result, int a2, int a3, __int16 a4, int a5)
{
  unsigned int v5 = __clz(a5 + 1);
  unsigned int v6 = 31 - v5;
  int v7 = *((_DWORD *)result + 9);
  unsigned int v8 = *((_DWORD *)result + 8) | ((unsigned __int16)(31 - v5) << v7);
  int v9 = v7 + 5;
  *((_DWORD *)result + 8) = v8;
  *((_DWORD *)result + 9) = v7 + 5;
  if (v7 >= 12)
  {
    unint64_t v10 = result[1];
    unint64_t v11 = result[2];
    unint64_t v12 = v11 + 1;
    result[2] = v11 + 1;
    if (v11 < v10)
    {
      uint64_t v13 = *result;
      uint64_t v14 = result[3];
      result[3] = v14 + 1;
      *(_BYTE *)(v13 + v14) = v8;
      unsigned int v8 = *((_DWORD *)result + 8);
      int v9 = *((_DWORD *)result + 9);
      unint64_t v10 = result[1];
      unint64_t v12 = result[2];
    }

    unsigned int v15 = v8 >> 8;
    int v16 = v9 - 8;
    *((_DWORD *)result + 8) = v15;
    *((_DWORD *)result + 9) = v16;
    result[2] = v12 + 1;
    if (v12 < v10)
    {
      uint64_t v17 = *result;
      uint64_t v18 = result[3];
      result[3] = v18 + 1;
      *(_BYTE *)(v17 + v18) = v15;
      unsigned int v15 = *((_DWORD *)result + 8);
      int v16 = *((_DWORD *)result + 9);
    }

    unsigned int v8 = v15 >> 8;
    int v9 = v16 - 8;
  }

  unsigned int v19 = v8 | ((unsigned __int16)(a5 + 1 - (0x80000000 >> v5)) << v9);
  int v20 = v9 + v6;
  *((_DWORD *)result + 8) = v19;
  *((_DWORD *)result + 9) = v9 + v6;
  if ((int)(v9 + v6) >= 17)
  {
    unint64_t v21 = result[1];
    unint64_t v22 = result[2];
    unint64_t v23 = v22 + 1;
    result[2] = v22 + 1;
    if (v22 < v21)
    {
      uint64_t v24 = *result;
      uint64_t v25 = result[3];
      result[3] = v25 + 1;
      *(_BYTE *)(v24 + v25) = v19;
      unsigned int v19 = *((_DWORD *)result + 8);
      int v20 = *((_DWORD *)result + 9);
      unint64_t v21 = result[1];
      unint64_t v23 = result[2];
    }

    unsigned int v26 = v19 >> 8;
    int v27 = v20 - 8;
    *((_DWORD *)result + 8) = v26;
    *((_DWORD *)result + 9) = v27;
    result[2] = v23 + 1;
    if (v23 < v21)
    {
      uint64_t v28 = *result;
      uint64_t v29 = result[3];
      result[3] = v29 + 1;
      *(_BYTE *)(v28 + v29) = v26;
      unsigned int v26 = *((_DWORD *)result + 8);
      int v27 = *((_DWORD *)result + 9);
    }

    unsigned int v19 = v26 >> 8;
    int v20 = v27 - 8;
    *((_DWORD *)result + 8) = v19;
    *((_DWORD *)result + 9) = v20;
  }

  if ((a5 & 1) != 0)
  {
    unsigned int v30 = __clz(a3 | a2);
    unsigned int v31 = v19 | ((unsigned __int16)(31 - v30) << v20);
    int v32 = v20 + 4;
    *((_DWORD *)result + 8) = v31;
    *((_DWORD *)result + 9) = v20 + 4;
    if (v20 >= 13)
    {
      unint64_t v33 = result[1];
      unint64_t v34 = result[2];
      unint64_t v35 = v34 + 1;
      result[2] = v34 + 1;
      if (v34 < v33)
      {
        uint64_t v36 = *result;
        uint64_t v37 = result[3];
        result[3] = v37 + 1;
        *(_BYTE *)(v36 + v37) = v31;
        unsigned int v31 = *((_DWORD *)result + 8);
        int v32 = *((_DWORD *)result + 9);
        unint64_t v33 = result[1];
        unint64_t v35 = result[2];
      }

      unsigned int v38 = v31 >> 8;
      int v39 = v32 - 8;
      *((_DWORD *)result + 8) = v38;
      *((_DWORD *)result + 9) = v39;
      result[2] = v35 + 1;
      if (v35 < v33)
      {
        uint64_t v40 = *result;
        uint64_t v41 = result[3];
        result[3] = v41 + 1;
        *(_BYTE *)(v40 + v41) = v38;
        unsigned int v38 = *((_DWORD *)result + 8);
        int v39 = *((_DWORD *)result + 9);
      }

      unsigned int v31 = v38 >> 8;
      int v32 = v39 - 8;
    }

    unsigned int v42 = 32 - v30;
    unsigned int v43 = v31 | ((unsigned __int16)a2 << v32);
    unsigned int v44 = v32 + v42;
    *((_DWORD *)result + 8) = v43;
    *((_DWORD *)result + 9) = v32 + v42;
    if ((int)(v32 + v42) >= 17)
    {
      unint64_t v45 = result[1];
      unint64_t v46 = result[2];
      unint64_t v47 = v46 + 1;
      result[2] = v46 + 1;
      if (v46 < v45)
      {
        uint64_t v48 = *result;
        uint64_t v49 = result[3];
        result[3] = v49 + 1;
        *(_BYTE *)(v48 + v49) = v43;
        unsigned int v43 = *((_DWORD *)result + 8);
        unsigned int v44 = *((_DWORD *)result + 9);
        unint64_t v45 = result[1];
        unint64_t v47 = result[2];
      }

      unsigned int v50 = v43 >> 8;
      unsigned int v51 = v44 - 8;
      *((_DWORD *)result + 8) = v50;
      *((_DWORD *)result + 9) = v51;
      result[2] = v47 + 1;
      if (v47 < v45)
      {
        uint64_t v52 = *result;
        uint64_t v53 = result[3];
        result[3] = v53 + 1;
        *(_BYTE *)(v52 + v53) = v50;
        unsigned int v50 = *((_DWORD *)result + 8);
        unsigned int v51 = *((_DWORD *)result + 9);
      }

      unsigned int v43 = v50 >> 8;
      unsigned int v44 = v51 - 8;
    }

    unsigned int v54 = v43 | ((unsigned __int16)a3 << v44);
    int v55 = v44 + v42;
    *((_DWORD *)result + 8) = v54;
    *((_DWORD *)result + 9) = v55;
    if (v55 >= 17)
    {
      unint64_t v56 = result[1];
      unint64_t v57 = result[2];
      unint64_t v58 = v57 + 1;
      result[2] = v57 + 1;
      if (v57 < v56)
      {
        uint64_t v59 = *result;
        uint64_t v60 = result[3];
        result[3] = v60 + 1;
        *(_BYTE *)(v59 + v60) = v54;
        unsigned int v54 = *((_DWORD *)result + 8);
        int v55 = *((_DWORD *)result + 9);
        unint64_t v56 = result[1];
        unint64_t v58 = result[2];
      }

      unsigned int v61 = v54 >> 8;
      int v62 = v55 - 8;
      *((_DWORD *)result + 8) = v61;
      *((_DWORD *)result + 9) = v62;
      result[2] = v58 + 1;
      if (v58 < v56)
      {
        uint64_t v63 = *result;
        uint64_t v64 = result[3];
        result[3] = v64 + 1;
        *(_BYTE *)(v63 + v64) = v61;
        unsigned int v61 = *((_DWORD *)result + 8);
        int v62 = *((_DWORD *)result + 9);
      }

      unsigned int v54 = v61 >> 8;
      int v55 = v62 - 8;
    }

    unsigned int v65 = v54 | ((unsigned __int16)(a4 - 1) << v55);
    int v66 = v55 + 5;
    *((_DWORD *)result + 8) = v65;
    *((_DWORD *)result + 9) = v55 + 5;
    if (v55 >= 12)
    {
      unint64_t v67 = result[1];
      unint64_t v68 = result[2];
      unint64_t v69 = v68 + 1;
      result[2] = v68 + 1;
      if (v68 < v67)
      {
        uint64_t v70 = *result;
        uint64_t v71 = result[3];
        result[3] = v71 + 1;
        *(_BYTE *)(v70 + v71) = v65;
        unsigned int v65 = *((_DWORD *)result + 8);
        int v66 = *((_DWORD *)result + 9);
        unint64_t v67 = result[1];
        unint64_t v69 = result[2];
      }

      unsigned int v72 = v65 >> 8;
      int v73 = v66 - 8;
      *((_DWORD *)result + 8) = v72;
      *((_DWORD *)result + 9) = v73;
      result[2] = v69 + 1;
      if (v69 < v67)
      {
        uint64_t v74 = *result;
        uint64_t v75 = result[3];
        result[3] = v75 + 1;
        *(_BYTE *)(v74 + v75) = v72;
        unsigned int v72 = *((_DWORD *)result + 8);
        int v73 = *((_DWORD *)result + 9);
      }

      *((_DWORD *)result + 8) = v72 >> 8;
      *((_DWORD *)result + 9) = v73 - 8;
    }
  }

  return result;
}

void *touchpadCodecCreate(int a1, int a2, int a3, int a4, uint64_t a5)
{
  unsigned int v5 = 0LL;
  if (a1)
  {
    if (a2)
    {
      if (a3 == 16 && !a4 && !a5)
      {
        unsigned int v8 = calloc(1uLL, 0x2A8uLL);
        unsigned int v5 = v8;
        if (v8)
        {
          v8[81] = (a2 * a1);
          v8[80] = 2LL * (a2 * a1);
          v8[82] = 0LL;
          *((_DWORD *)v8 + 166) = a1;
          *((_DWORD *)v8 + 167) = a2;
          *((_BYTE *)v8 + 672) = 16;
          int v9 = malloc(2LL * (a2 * a1));
          v5[79] = v9;
          if (v9)
          {
            bzero(v9, 2LL * (a2 * a1));
            for (uint64_t i = 0LL; i != 630; i += 10LL)
            {
              unint64_t v11 = (char *)v5 + i;
              *(void *)unint64_t v11 = 32LL;
              *((_WORD *)v11 + 4) = 261;
            }

            v5[82] = 0LL;
          }

          else
          {
            free(v5);
            return 0LL;
          }
        }
      }
    }
  }

  return v5;
}

void codecResetModel(uint64_t a1)
{
  for (uint64_t i = 0LL; i != 630; i += 10LL)
  {
    uint64_t v3 = a1 + i;
    *(void *)uint64_t v3 = 32LL;
    *(_WORD *)(v3 + 8) = 261;
  }

  *(void *)(a1 + 656) = 0LL;
}

void touchpadCodecDestroy(void **a1)
{
  if (a1)
  {
    free(a1[79]);
    free(a1);
  }

uint64_t codecGetFooterID(uint64_t a1)
{
  uint64_t v1 = 0LL;
  int v2 = 0;
  do
  {
    int v2 = *(_DWORD *)(a1 + v1) ^ __ROR4__(v2, 31);
    v1 += 10LL;
  }

  while (v1 != 630);
  return (-1640531535 * v2) >> 20;
}

double lzx_decoder_init(void *a1)
{
  *((_DWORD *)a1 + 2) = 1;
  *(void *)&double result = 0x100000001LL;
  *a1 = 0x100000001LL;
  a1[16448] = 496LL;
  a1[32895] = 249LL;
  a1[49342] = 8LL;
  return result;
}

uint64_t brotli_decode_buffer(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

unint64_t brotli_encode_buffer( _BYTE *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, int a6)
{
  unint64_t v7 = a2;
  else {
    return 0LL;
  }
}

uint64_t brotli_stream_process(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(v3 + 24) | a2 & 1;
  *(_DWORD *)(v3 + 24) = v4;
  uint64_t v5 = *(void *)(v3 + 16);
  if (*(_DWORD *)v3)
  {
    unsigned int v6 = BrotliDecoderDecompressStream( v5,  (void *)(a1 + 24),  (_BYTE **)(a1 + 16),  (size_t *)(a1 + 8),  (void **)a1,  0LL)
       - 1;
    if (v6 <= 2) {
      return dword_1810D00A8[v6];
    }
    return 0xFFFFFFFFLL;
  }

  if (!BrotliEncoderCompressStream( v5,  2 * (v4 != 0),  (unint64_t *)(a1 + 24),  (const void **)(a1 + 16),  (size_t *)(a1 + 8),  (void **)a1,  0LL)) {
    return 0xFFFFFFFFLL;
  }
  return *(_DWORD *)(v3 + 24) && BrotliEncoderIsFinished(*(void *)(v3 + 16));
}

uint64_t brotli_stream_init(uint64_t a1, int a2)
{
  int v4 = malloc(0x20uLL);
  if (v4)
  {
    uint64_t v5 = v4;
    *int v4 = 0u;
    v4[1] = 0u;
    if (a2 == 1)
    {
      Instance = BrotliDecoderCreateInstance(0LL, 0LL, 0LL);
      v5[2] = Instance;
      if (Instance)
      {
        BrotliDecoderSetParameter((uint64_t)Instance, 1, 1);
        goto LABEL_8;
      }
    }

    else if (!a2)
    {
      unsigned int v6 = BrotliEncoderCreateInstance(0LL, 0LL, 0LL);
      v5[2] = v6;
      if (v6)
      {
        uint64_t v7 = (uint64_t)v6;
        BrotliEncoderSetParameter((uint64_t)v6, 1, 2u);
        BrotliEncoderSetParameter(v7, 2, 0x16u);
LABEL_8:
        uint64_t result = 0LL;
        *(_DWORD *)uint64_t v5 = a2;
        *((_DWORD *)v5 + 1) = 2818;
        *(void *)(a1 + 32) = v5;
        return result;
      }
    }

    free(v5);
  }

  return 0xFFFFFFFFLL;
}

uint64_t brotli_stream_end(uint64_t a1)
{
  int v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = v2[2];
    if (*(_DWORD *)v2) {
      BrotliDecoderDestroyInstance(v3);
    }
    else {
      BrotliEncoderDestroyInstance(v3);
    }
    free(v2);
  }

  *(void *)(a1 + 32) = 0LL;
  return 0LL;
}

unint64_t yzip_plane_encoder_allocate( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t format_convert_at_once = get_format_convert_at_once(a5);
  unsigned int format_process_at_once = get_format_process_at_once(a5);
  uint64_t v14 = a4 * a2 + 16;
  uint64_t v15 = v14 * format_process_at_once;
  a1[8] = 0LL;
  uint64_t v16 = v14 * format_convert_at_once;
  unint64_t v17 = (((a6 + 15) | 0xE) + 2 * v16) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v18 = (v17 + 2 * v16 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  *a1 = v18;
  a1[1] = ((a6 + 15) & 0xFFFFFFFFFFFFFFF0LL) + 16;
  unint64_t v19 = (v18 + 2 * v15 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  a1[2] = v17 + 16;
  a1[3] = v19;
  v15 += 15LL;
  unint64_t v20 = (v15 + v19) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v21 = (v15 + v20) & 0xFFFFFFFFFFFFFFF0LL;
  a1[4] = v20;
  a1[5] = v21;
  unint64_t v22 = (v21 + 1039) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v23 = (v22 + 15999) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t result = v23 + 4 * a4 * a2 * a3;
  a1[6] = v22;
  a1[7] = v23;
  return result;
}

unint64_t yzip_plane_decoder_allocate(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v7 = (((a5 + 15) | 0xE) + (2 * a3 * a2 + 32) * get_format_convert_at_once(a4)) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t result = v7 + 1024;
  *a1 = ((a5 + 15) & 0xFFFFFFFFFFFFFFF0LL) + 16;
  a1[1] = v7;
  return result;
}

uint64_t yzip_plane_encoder_phase1(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 16LL);
  uint64_t v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 9LL);
  unsigned int format_convert_at_once = get_format_convert_at_once(v2);
  int format_process_at_once = get_format_process_at_once(v2);
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = *(unsigned int *)(a1 + 20);
  unsigned int v6 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 8LL);
  int v103 = is_format_msb_layout(v2);
  uint64_t result = 0xFFFFFFFFLL;
  if (!(_DWORD)v4 || !(_DWORD)v5) {
    return result;
  }
  if (v6 < 8 || v6 > 0x10) {
    return result;
  }
  get_conversion_set((void *(**)(void *, const void *, uint64_t))&v111, v2, v6, v3);
  if (!v111) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = *(void *)(a1 + 104) + (*(void *)(a1 + 144) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v101 = *(void *)(a1 + 104);
  unint64_t v98 = (v4 * v3 * format_process_at_once);
  uint64_t v10 = (v98 + 2) + 15LL;
  uint64_t v102 = v10 & 0x1FFFFFFF0LL;
  unint64_t v11 = v4 + (v5 << 16);
  *(_DWORD *)(v9 - 4) = v11;
  unint64_t v12 = v6 - 1 + HIDWORD(v11);
  uint64_t v94 = a1;
  unsigned int v93 = v5;
  yzip_plane_encoder_allocate(&v112, v4, v5, v3, v2, *(void *)(a1 + 96));
  uint64_t v13 = 0LL;
  uint64_t v14 = v116;
  *(void *)&__int128 v15 = -1LL;
  *((void *)&v15 + 1) = -1LL;
  *char v116 = v15;
  v14[1] = v15;
  _OWORD v14[2] = v15;
  v14[3] = v15;
  v14[4] = v15;
  v14[5] = v15;
  v14[6] = v15;
  v14[7] = v15;
  v14[8] = v15;
  v14[9] = v15;
  v14[10] = v15;
  v14[11] = v15;
  v14[12] = v15;
  v14[13] = v15;
  v14[14] = v15;
  v14[15] = v15;
  v14[16] = v15;
  v14[17] = v15;
  v14[18] = v15;
  v14[19] = v15;
  v14[20] = v15;
  v14[21] = v15;
  v14[22] = v15;
  v14[23] = v15;
  v14[24] = v15;
  v14[25] = v15;
  v14[26] = v15;
  v14[27] = v15;
  v14[28] = v15;
  v14[29] = v15;
  v14[30] = v15;
  v14[31] = v15;
  *(void *)&__int128 v15 = 0x101010101010101LL;
  *((void *)&v15 + 1) = 0x101010101010101LL;
  v14[62] = v15;
  v14[63] = v15;
  v14[60] = v15;
  v14[61] = v15;
  v14[58] = v15;
  v14[59] = v15;
  v14[56] = v15;
  v14[57] = v15;
  v14[54] = v15;
  v14[55] = v15;
  v14[52] = v15;
  v14[53] = v15;
  v14[50] = v15;
  v14[51] = v15;
  v14[48] = v15;
  v14[49] = v15;
  v14[46] = v15;
  v14[47] = v15;
  v14[44] = v15;
  v14[45] = v15;
  v14[42] = v15;
  v14[43] = v15;
  v14[40] = v15;
  v14[41] = v15;
  v14[38] = v15;
  v14[39] = v15;
  v14[36] = v15;
  v14[37] = v15;
  v14[34] = v15;
  v14[35] = v15;
  uint64_t v16 = (char *)v14 + 477;
  v14[32] = v15;
  v14[33] = v15;
  unint64_t v96 = v14;
  do
  {
    v16[v13] = quantize_slow((int)v13 - 35);
    ++v13;
  }

  while (v13 != 71);
  unint64_t v97 = v117;
  bzero(v117, 0x3E70uLL);
  unsigned int v17 = 0;
  unsigned int v18 = 0;
  int v19 = 0;
  unsigned int v20 = 0u;
  int v119 = 0;
  unint64_t v21 = (__int16 *)(v113 - 4);
  *(_DWORD *)(v113 - 6) = 0;
  unint64_t v92 = v9;
  unint64_t v22 = (_DWORD *)(v9 - 8);
  uint64_t v100 = (2 * v10) & 0x3FFFFFFE0LL;
  unsigned int v23 = 4;
  uint64_t v24 = format_convert_at_once;
  do
  {
    int v95 = v19;
    uint64_t v107 = *(&v112 + (v19 & 1) + 1);
    v111();
    uint64_t v25 = v24;
    if ((_DWORD)v24)
    {
      LODWORD(v26) = 0;
      uint64_t v28 = v114;
      uint64_t v27 = v115;
      unint64_t v29 = v112;
      unsigned int v31 = v97;
      unint64_t v30 = v98;
      unint64_t v33 = v96;
      char v32 = v6 - 1;
      char v34 = 32 - v6;
      v35.i64[0] = 0x22002200220022LL;
      v35.i64[1] = 0x22002200220022LL;
      v36.i64[0] = 0x23002300230023LL;
      v36.i64[1] = 0x23002300230023LL;
      v37.i64[0] = 0xFFFF0000FFFFLL;
      v37.i64[1] = 0xFFFF0000FFFFLL;
      v38.i64[0] = 0x1000000010000LL;
      v38.i64[1] = 0x1000000010000LL;
      v39.i64[0] = 0x2200000022LL;
      v39.i64[1] = 0x2200000022LL;
      v40.i64[0] = 0x2300000023LL;
      v40.i64[1] = 0x2300000023LL;
      v41.i64[0] = 0x4700000047LL;
      v41.i64[1] = 0x4700000047LL;
      unint64_t v109 = v112;
      uint64_t v110 = v115;
      while (1)
      {
        int v106 = v26;
        uint64_t v26 = v26;
        unsigned int v42 = (uint16x8_t *)(v107 + 2 * v102 * v26);
        uint64_t v108 = v42;
        if (v103)
        {
          uint64_t v104 = v26;
          convert_row_to_lsb(v42, v30, 16 - v6);
          uint64_t v26 = v104;
          unsigned int v42 = v108;
          unint64_t v29 = v109;
          uint64_t v27 = v110;
          v41.i64[0] = 0x4700000047LL;
          v41.i64[1] = 0x4700000047LL;
          v40.i64[0] = 0x2300000023LL;
          v40.i64[1] = 0x2300000023LL;
          v39.i64[0] = 0x2200000022LL;
          v39.i64[1] = 0x2200000022LL;
          v38.i64[0] = 0x1000000010000LL;
          v38.i64[1] = 0x1000000010000LL;
          v37.i64[0] = 0xFFFF0000FFFFLL;
          v37.i64[1] = 0xFFFF0000FFFFLL;
          v36.i64[0] = 0x23002300230023LL;
          v36.i64[1] = 0x23002300230023LL;
          v35.i64[0] = 0x22002200220022LL;
          v35.i64[1] = 0x22002200220022LL;
          char v34 = 32 - v6;
          unint64_t v33 = v96;
          char v32 = v6 - 1;
          unsigned int v31 = v97;
          unint64_t v30 = v98;
          uint64_t v25 = format_convert_at_once;
        }

        unsigned int v43 = (int16x8_t *)(v107 + v100 * v26);
        v42[-1].i16[7] = *v21;
        v42->i16[v30] = v42->i16[(v98 - 1)];
        if (v6 >= 0xF)
        {
          unint64_t v53 = 0LL;
          unsigned int v54 = (int16x8_t *)v29;
          do
          {
            uint16x8_t v55 = *(uint16x8_t *)(v21 - 1);
            int16x8_t v56 = *(int16x8_t *)v21;
            v21 += 8;
            int16x8_t v57 = v56;
            int16x8_t v58 = *(int16x8_t *)((char *)v43 - 2);
            int16x8_t v59 = *v43++;
            int32x4_t v60 = (int32x4_t)vsubl_u16(*(uint16x4_t *)v57.i8, *(uint16x4_t *)v55.i8);
            int32x4_t v61 = (int32x4_t)vsubl_high_u16((uint16x8_t)v57, v55);
            int32x4_t v62 = (int32x4_t)vaddw_high_u16((uint32x4_t)v61, (uint16x8_t)v58);
            int32x4_t v63 = (int32x4_t)vaddw_u16((uint32x4_t)v60, *(uint16x4_t *)v58.i8);
            int16x8_t v64 = vuzp1q_s16( (int16x8_t)vorrq_s8((int8x16_t)vcgtq_s32(v63, v37), (int8x16_t)vminq_u32((uint32x4_t)v63, v38)),  (int16x8_t)vorrq_s8((int8x16_t)vcgtq_s32(v62, v37), (int8x16_t)vminq_u32((uint32x4_t)v62, v38)));
            *(int8x8_t *)&v28[v53] = vmovn_s16( vuzp1q_s16( (int16x8_t)vorrq_s8( vorrq_s8( (int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v60) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)),  vandq_s8((int8x16_t)vcgtq_s32(v60, v40), (int8x16_t)v40)),  vandq_s8( (int8x16_t)v60,  (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v60, v40)))),  (int16x8_t)vorrq_s8( vorrq_s8( (int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v61) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)),  vandq_s8((int8x16_t)vcgtq_s32(v61, v40), (int8x16_t)v40)),  vandq_s8( (int8x16_t)v61,  (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v61, v40))))));
            int32x4_t v65 = (int32x4_t)vsubl_high_u16((uint16x8_t)v58, v55);
            int32x4_t v66 = (int32x4_t)vsubl_u16(*(uint16x4_t *)v58.i8, *(uint16x4_t *)v55.i8);
            *(int8x8_t *)(v27 + v53) = vmovn_s16( vuzp1q_s16( (int16x8_t)vorrq_s8( vorrq_s8( (int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v66) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)),  vandq_s8((int8x16_t)vcgtq_s32(v66, v40), (int8x16_t)v40)),  vandq_s8( (int8x16_t)v66,  (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v66, v40)))),  (int16x8_t)vorrq_s8( vorrq_s8( (int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v65) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)),  vandq_s8((int8x16_t)vcgtq_s32(v65, v40), (int8x16_t)v40)),  vandq_s8( (int8x16_t)v65,  (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v65, v40))))));
            *v54++ = vsubq_s16( vaddq_s16( vaddq_s16( vsubq_s16(v59, vaddq_s16(v58, v57)),  (int16x8_t)vminq_u16(vminq_u16((uint16x8_t)v58, (uint16x8_t)v57), (uint16x8_t)v64)),  (int16x8_t)vmaxq_u16(vmaxq_u16((uint16x8_t)v58, (uint16x8_t)v57), (uint16x8_t)v64)),  v64);
            v53 += 8LL;
          }

          while (v53 <= v30);
        }

        else
        {
          unint64_t v44 = 0LL;
          unint64_t v45 = (int16x8_t *)v29;
          do
          {
            int16x8_t v46 = *(int16x8_t *)(v21 - 1);
            int16x8_t v47 = *(int16x8_t *)v21;
            v21 += 8;
            int16x8_t v48 = v47;
            int16x8_t v49 = *(int16x8_t *)((char *)v43 - 2);
            int16x8_t v50 = *v43++;
            int16x8_t v51 = vsubq_s16(v48, v46);
            int16x8_t v52 = vaddq_s16(v51, v49);
            *(int8x8_t *)&v28[v44] = vmovn_s16(vminq_s16(vmaxq_s16(v51, v35), v36));
            *(int8x8_t *)(v27 + v44) = vmovn_s16(vminq_s16(vmaxq_s16(vsubq_s16(v49, v46), v35), v36));
            *v45++ = vaddq_s16( vsubq_s16(v50, vaddq_s16(vaddq_s16(v49, v48), v52)),  vaddq_s16(vminq_s16(vminq_s16(v49, v48), v52), vmaxq_s16(vmaxq_s16(v49, v48), v52)));
            v44 += 8LL;
          }

          while (v44 <= v30);
        }

        if ((_DWORD)v30) {
          break;
        }
LABEL_47:
        LODWORD(v26) = v106 + 1;
        unsigned int v85 = v108;
        unint64_t v21 = (__int16 *)v108;
      }

      uint64_t v67 = 0LL;
      int v68 = *((char *)v33 + *v28 + 512);
      uint64_t v69 = v118;
      while (1)
      {
        uint64_t v70 = v67 + 1;
        int v71 = *((char *)v33 + v28[v67 + 1] + 512);
        int v72 = *((char *)v33 + *(char *)(v27 + v67) + 512) + 11 * (v71 + 11 * v68);
        unsigned int v73 = *(__int16 *)(v29 + 2 * v67);
        if (v72 >= 0) {
          unsigned int v74 = v72;
        }
        else {
          unsigned int v74 = -v72;
        }
        if (v72 < 0) {
          unsigned int v73 = -v73;
        }
        if (!v18 && v72) {
          goto LABEL_42;
        }
        if (v73) {
          break;
        }
        ++v18;
LABEL_46:
        uint64_t v67 = v70;
        int v68 = v71;
        if (v70 == v30) {
          goto LABEL_47;
        }
      }

      int v75 = lut_rle[v20];
      if (v18 >> v75)
      {
        uint64_t v76 = &lut_rle[v20 + 1];
        do
        {
          *unint64_t v22 = v12;
          unint64_t v12 = (v12 >> (v23 & 0x20)) + (1LL << (v23 & 0x1F));
          unsigned int v77 = (v23 & 0x1F) + 1;
          v22 -= v23 >> 5;
          v18 += -1 << v75;
          int v78 = *v76++;
          int v75 = v78;
          ++v20;
          unsigned int v23 = v77;
        }

        while (v18 >> v78);
      }

      else
      {
        unsigned int v77 = v23;
      }

      v73 += (v73 >> v32) & 1;
      *unint64_t v22 = v12;
      unint64_t v12 = ((unint64_t)(2 * v18) << (v77 & 0x1F)) + (v12 >> (v77 & 0x20));
      unsigned int v17 = v119;
      unsigned int v23 = (v77 & 0x1F) + v75 + 1;
      v22 -= v77 >> 5;
      unsigned int v20 = v20 - 1 + ((v20 - 1) >> 31);
      unint64_t v29 = v109;
      uint64_t v27 = v110;
LABEL_42:
      unsigned int v18 = 0;
      int v79 = v73 << v34;
      *(_DWORD *)(v69 + 4LL * v17) = v79 + v74;
      uint64_t v80 = (uint64_t)v31 + 24 * v74;
      int v81 = v79 >> v34;
      if (v81 >= 0) {
        uint64_t v82 = v81;
      }
      else {
        uint64_t v82 = -v81;
      }
      uint64_t v83 = *(void *)(v80 + 8);
      uint64_t v84 = *(void *)v80 + v82;
      int v119 = ++v17;
      *(void *)uint64_t v80 = v84;
      *(void *)(v80 + 8) = v83 + v81;
      ++*(_DWORD *)(v80 + 16);
      goto LABEL_46;
    }

    unsigned int v85 = (uint16x8_t *)v21;
LABEL_50:
    int v19 = v95 + 1;
    unint64_t v21 = (__int16 *)v85;
    uint64_t v24 = v25;
  }

  while ((v95 + 1) * (int)v25 < v93);
  if (v18)
  {
    int v86 = lut_rle[v20];
    if (v18 >> v86)
    {
      unsigned int v87 = &lut_rle[v20 + 1];
      unint64_t v88 = v92;
      unint64_t v89 = v97;
      do
      {
        *unint64_t v22 = v12;
        unint64_t v12 = (v12 >> (v23 & 0x20)) + (1LL << (v23 & 0x1F));
        unsigned int v90 = (v23 & 0x1F) + 1;
        v22 -= v23 >> 5;
        v18 += -1 << v86;
        int v91 = *v87++;
        int v86 = v91;
        unsigned int v23 = v90;
      }

      while (v18 >> v91);
    }

    else
    {
      unsigned int v90 = v23;
      unint64_t v88 = v92;
      unint64_t v89 = v97;
    }

    *unint64_t v22 = v12;
    unint64_t v12 = ((unint64_t)(2 * v18) << (v90 & 0x1F)) + (v12 >> (v90 & 0x20));
    unsigned int v23 = (v90 & 0x1F) + v86 + 1;
    v22 -= v90 >> 5;
    unsigned int v17 = v119;
  }

  else
  {
    unint64_t v88 = v92;
    unint64_t v89 = v97;
  }

  uint64_t result = 0LL;
  *(void *)(v94 + 40) = 0LL;
  *(void *)(v94 + 48) = v12;
  *(_DWORD *)(v94 + 56) = 0;
  *(_DWORD *)(v94 + 60) = v23;
  *(void *)(v94 + 64) = v101;
  *(void *)(v94 + 72) = v88;
  *(void *)(v94 + 80) = v22;
  *(void *)(v94 + 88) = v101;
  *(void *)(v94 + 112) = v89;
  *(void *)(v94 + 128) = v118;
  *(_DWORD *)(v94 + 136) = v17;
  return result;
}

uint64_t yzip_plane_encoder_phase2(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 48);
  unsigned int v3 = *(_DWORD *)(a1 + 56);
  int v4 = *(_DWORD *)(a1 + 60);
  uint64_t v5 = *(_DWORD **)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  unsigned int v8 = *(char **)(a1 + 80);
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v9 = *(_DWORD *)(a1 + 136);
  if (v9)
  {
    unsigned int v10 = 0;
    char v11 = 32 - *(_BYTE *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v12 = *(void *)(a1 + 120);
    uint64_t v13 = *(void *)(a1 + 128);
    uint64_t v14 = (v4 + 31) >> 3;
    while (1)
    {
      uint64_t v15 = v8 - ((char *)v5 + v14 + ((v3 + 31) >> 3));
      if (v15 < 32) {
        return -1LL;
      }
      unsigned int v16 = v10 + ((unint64_t)v15 >> 2);
      if (v16 >= v9) {
        unsigned int v16 = v9;
      }
      if (v10 + 8 <= v16)
      {
        do
        {
          int v17 = *(_DWORD *)(v13 + 4LL * v10);
          int v18 = (__int16)v17;
          int v19 = (__int16 *)(v12 + 4LL * (__int16)v17);
          int v20 = ((v17 >> v11) - *v19) << v11 >> v11;
          unsigned int v21 = (2 * v20) ^ ~(~(2 * v20) >> 31);
          int v22 = *((unsigned __int8 *)v19 + 2);
          unsigned int v23 = v21 >> v22;
          int v24 = v3 & 0x1F;
          if (v21 >> v22 > 0xF)
          {
            unsigned int v25 = (v21 + (-16 << v22)) << 16;
            unsigned int v26 = v24 + *(unsigned __int8 *)(v12 + 4LL * v18 + 3) + 16;
          }

          else
          {
            unsigned int v25 = ((2 * (v21 & ~(-1 << v22))) | 1) << v23;
            unsigned int v26 = v24 + v22 + v23 + 1;
          }

          *uint64_t v5 = v1;
          int v27 = *(_DWORD *)(v13 + 4LL * (v10 + 1));
          int v28 = (__int16)v27;
          unint64_t v29 = (__int16 *)(v12 + 4LL * (__int16)v27);
          int v30 = ((v27 >> v11) - *v29) << v11 >> v11;
          unsigned int v31 = (2 * v30) ^ ~(~(2 * v30) >> 31);
          int v32 = *((unsigned __int8 *)v29 + 2);
          unsigned int v33 = v31 >> v32;
          int v34 = v26 & 0x1F;
          if (v31 >> v32 > 0xF)
          {
            int v37 = *(unsigned __int8 *)(v12 + 4LL * v28 + 3);
            unsigned int v35 = (v31 + (-16 << v32)) << 16;
            unsigned int v36 = v34 + v37 + 16;
          }

          else
          {
            unsigned int v35 = ((2 * (v31 & ~(-1 << v32))) | 1) << v33;
            unsigned int v36 = v34 + v32 + v33 + 1;
          }

          unint64_t v38 = ((unint64_t)v25 << v24) + (v1 >> (v3 & 0x20));
          int32x4_t v39 = &v5[v3 >> 5];
          *int32x4_t v39 = v38;
          int v40 = *(_DWORD *)(v13 + 4LL * (v10 + 2));
          int v41 = (__int16)v40;
          unsigned int v42 = (__int16 *)(v12 + 4LL * (__int16)v40);
          int v43 = ((v40 >> v11) - *v42) << v11 >> v11;
          unsigned int v44 = (2 * v43) ^ ~(~(2 * v43) >> 31);
          int v45 = *((unsigned __int8 *)v42 + 2);
          unsigned int v46 = v44 >> v45;
          int v47 = v36 & 0x1F;
          if (v44 >> v45 > 0xF)
          {
            int v50 = *(unsigned __int8 *)(v12 + 4LL * v41 + 3);
            unsigned int v48 = (v44 + (-16 << v45)) << 16;
            unsigned int v49 = v47 + v50 + 16;
          }

          else
          {
            unsigned int v48 = ((2 * (v44 & ~(-1 << v45))) | 1) << v46;
            unsigned int v49 = v47 + v45 + v46 + 1;
          }

          unint64_t v51 = ((unint64_t)v35 << v34) + (v38 >> (v26 & 0x20));
          int16x8_t v52 = &v39[v26 >> 5];
          *int16x8_t v52 = v51;
          int v53 = *(_DWORD *)(v13 + 4LL * (v10 + 3));
          int v54 = (__int16)v53;
          uint16x8_t v55 = (__int16 *)(v12 + 4LL * (__int16)v53);
          int v56 = ((v53 >> v11) - *v55) << v11 >> v11;
          unsigned int v57 = (2 * v56) ^ ~(~(2 * v56) >> 31);
          int v58 = *((unsigned __int8 *)v55 + 2);
          unsigned int v59 = v57 >> v58;
          int v60 = v49 & 0x1F;
          if (v57 >> v58 > 0xF)
          {
            int v63 = *(unsigned __int8 *)(v12 + 4LL * v54 + 3);
            unsigned int v61 = (v57 + (-16 << v58)) << 16;
            unsigned int v62 = v60 + v63 + 16;
          }

          else
          {
            unsigned int v61 = ((2 * (v57 & ~(-1 << v58))) | 1) << v59;
            unsigned int v62 = v60 + v58 + v59 + 1;
          }

          unint64_t v64 = ((unint64_t)v48 << v47) + (v51 >> (v36 & 0x20));
          int32x4_t v65 = &v52[v36 >> 5];
          _DWORD *v65 = v64;
          int v66 = *(_DWORD *)(v13 + 4LL * (v10 + 4));
          int v67 = (__int16)v66;
          int v68 = (__int16 *)(v12 + 4LL * (__int16)v66);
          int v69 = ((v66 >> v11) - *v68) << v11 >> v11;
          unsigned int v70 = (2 * v69) ^ ~(~(2 * v69) >> 31);
          int v71 = *((unsigned __int8 *)v68 + 2);
          unsigned int v72 = v70 >> v71;
          int v73 = v62 & 0x1F;
          if (v70 >> v71 > 0xF)
          {
            int v76 = *(unsigned __int8 *)(v12 + 4LL * v67 + 3);
            unsigned int v74 = (v70 + (-16 << v71)) << 16;
            unsigned int v75 = v73 + v76 + 16;
          }

          else
          {
            unsigned int v74 = ((2 * (v70 & ~(-1 << v71))) | 1) << v72;
            unsigned int v75 = v73 + v71 + v72 + 1;
          }

          unint64_t v77 = ((unint64_t)v61 << v60) + (v64 >> (v49 & 0x20));
          int v78 = &v65[v49 >> 5];
          *int v78 = v77;
          int v79 = *(_DWORD *)(v13 + 4LL * (v10 + 5));
          int v80 = (__int16)v79;
          int v81 = (__int16 *)(v12 + 4LL * (__int16)v79);
          int v82 = ((v79 >> v11) - *v81) << v11 >> v11;
          unsigned int v83 = (2 * v82) ^ ~(~(2 * v82) >> 31);
          int v84 = *((unsigned __int8 *)v81 + 2);
          unsigned int v85 = v83 >> v84;
          int v86 = v75 & 0x1F;
          if (v83 >> v84 > 0xF)
          {
            int v89 = *(unsigned __int8 *)(v12 + 4LL * v80 + 3);
            unsigned int v87 = (v83 + (-16 << v84)) << 16;
            unsigned int v88 = v86 + v89 + 16;
          }

          else
          {
            unsigned int v87 = ((2 * (v83 & ~(-1 << v84))) | 1) << v85;
            unsigned int v88 = v86 + v84 + v85 + 1;
          }

          unint64_t v90 = ((unint64_t)v74 << v73) + (v77 >> (v62 & 0x20));
          int v91 = &v78[v62 >> 5];
          *int v91 = v90;
          int v92 = *(_DWORD *)(v13 + 4LL * (v10 + 6));
          int v93 = (__int16)v92;
          uint64_t v94 = (__int16 *)(v12 + 4LL * (__int16)v92);
          int v95 = ((v92 >> v11) - *v94) << v11 >> v11;
          unsigned int v96 = (2 * v95) ^ ~(~(2 * v95) >> 31);
          int v97 = *((unsigned __int8 *)v94 + 2);
          unsigned int v98 = v96 >> v97;
          int v99 = v88 & 0x1F;
          if (v96 >> v97 > 0xF)
          {
            int v102 = *(unsigned __int8 *)(v12 + 4LL * v93 + 3);
            unsigned int v100 = (v96 + (-16 << v97)) << 16;
            unsigned int v101 = v99 + v102 + 16;
          }

          else
          {
            unsigned int v100 = ((2 * (v96 & ~(-1 << v97))) | 1) << v98;
            unsigned int v101 = v99 + v97 + v98 + 1;
          }

          unint64_t v103 = ((unint64_t)v87 << v86) + (v90 >> (v75 & 0x20));
          uint64_t v104 = &v91[v75 >> 5];
          *uint64_t v104 = v103;
          int v105 = *(_DWORD *)(v13 + 4LL * (v10 + 7));
          int v106 = (__int16)v105;
          uint64_t v107 = (__int16 *)(v12 + 4LL * (__int16)v105);
          int v108 = ((v105 >> v11) - *v107) << v11 >> v11;
          unsigned int v109 = (2 * v108) ^ ~(~(2 * v108) >> 31);
          int v110 = *((unsigned __int8 *)v107 + 2);
          unsigned int v111 = v109 >> v110;
          int v112 = v101 & 0x1F;
          if (v109 >> v110 > 0xF)
          {
            int v114 = *(unsigned __int8 *)(v12 + 4LL * v106 + 3);
            unsigned int v113 = (v109 + (-16 << v110)) << 16;
            unsigned int v3 = v112 + v114 + 16;
          }

          else
          {
            unsigned int v113 = ((2 * (v109 & ~(-1 << v110))) | 1) << v111;
            unsigned int v3 = v112 + v110 + v111 + 1;
          }

          unint64_t v115 = ((unint64_t)v100 << v99) + (v103 >> (v88 & 0x20));
          char v116 = &v104[v88 >> 5];
          unint64_t v1 = ((unint64_t)v113 << v112) + (v115 >> (v101 & 0x20));
          *char v116 = v115;
          LODWORD(v115) = v101 >> 5;
          unsigned int v117 = v10 + 16;
          v10 += 8;
          uint64_t v5 = &v116[v115];
        }

        while (v117 <= v16);
      }

      if (v10 < v16)
      {
        uint64_t v118 = v10;
        int v119 = (int *)(v13 + 4LL * v10);
        uint64_t v120 = v118 - v16;
        do
        {
          int v121 = *v119++;
          int v122 = (__int16)v121;
          unint64_t v123 = (__int16 *)(v12 + 4LL * (__int16)v121);
          int v124 = ((v121 >> v11) - *v123) << v11 >> v11;
          unsigned int v125 = (2 * v124) ^ ~(~(2 * v124) >> 31);
          int v126 = *((unsigned __int8 *)v123 + 2);
          unsigned int v127 = v125 >> v126;
          int v128 = v3 & 0x1F;
          if (v125 >> v126 > 0xF)
          {
            int v131 = *(unsigned __int8 *)(v12 + 4LL * v122 + 3);
            unsigned int v129 = (v125 + (-16 << v126)) << 16;
            int v130 = v128 + v131 + 16;
          }

          else
          {
            unsigned int v129 = ((2 * (v125 & ~(-1 << v126))) | 1) << v127;
            int v130 = v128 + v126 + v127 + 1;
          }

          unint64_t v132 = ((unint64_t)v129 << v128) + (v1 >> (v3 & 0x20));
          *uint64_t v5 = v1;
          v5 += v3 >> 5;
          unint64_t v1 = v132;
          unsigned int v3 = v130;
        }

        while (!__CFADD__(v120++, 1LL));
        unsigned int v3 = v130;
        unint64_t v1 = v132;
        unsigned int v10 = v16;
      }

      if (v10 >= v9) {
        goto LABEL_43;
      }
    }
  }

  else
  {
    LODWORD(v14) = (v4 + 31) >> 3;
LABEL_43:
    *(void *)uint64_t v5 = v1;
    *((_DWORD *)v8 - 1) = HIDWORD(v2);
    *(_DWORD *)unsigned int v8 = v2;
    uint64_t v134 = (v3 + 7) >> 3;
    unint64_t v135 = (unint64_t)v5 + v134 - v7;
    size_t v136 = v6 - (void)v8 + (v14 & 0x1FFFFFFC) - 4;
    if (v136 >= 4 || (v135 & 3) == 0) {
      unint64_t v138 = (unint64_t)v5 + v134 - v7;
    }
    else {
      unint64_t v138 = (v135 & 0xFFFFFFFFFFFFFFFCLL) + 4;
    }
    memmove((void *)(v7 + v138), (const void *)(v6 - v136), v136);
    return v138 + v136;
  }

uint64_t yzip_plane_decoder(uint64_t a1)
{
  uint64_t v91 = *(void *)(a1 + 120);
  int v2 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 16LL);
  unsigned int v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 9LL);
  unsigned int format_convert_at_once = get_format_convert_at_once(v2);
  int format_process_at_once = get_format_process_at_once(v2);
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  unsigned int v92 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 8LL);
  int v6 = is_format_msb_layout(v2);
  get_conversion_set(&v106, v2, v5, v3);
  if (!v107) {
    return -1LL;
  }
  uint64_t v7 = *(void *)(a1 + 104);
  unint64_t v8 = *(void *)(a1 + 144);
  uint64_t v9 = v8 + v7;
  if (v8 >= 4)
  {
    unint64_t v11 = v9 - 4;
    unint64_t v10 = *(unsigned int *)(v9 - 4);
  }

  else
  {
    unint64_t v10 = 0LL;
    unint64_t v11 = v8 + v7;
  }

  unint64_t v12 = v8 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v13 = v9 - v12;
  if (v11 <= v9 - v12)
  {
    uint64_t v14 = 0LL;
  }

  else
  {
    unsigned int v15 = *(_DWORD *)(v11 - 4);
    v11 -= 4LL;
    uint64_t v14 = v15;
  }

  if (v11 <= v13)
  {
    unint64_t v17 = 0LL;
  }

  else
  {
    unsigned int v16 = *(_DWORD *)(v11 - 4);
    v11 -= 4LL;
    unint64_t v17 = (unint64_t)v16 << 32;
  }

  if ((v14 & 0xF) != v5 - 1) {
    return -1LL;
  }
  unsigned int v89 = v5;
  uint64_t v102 = v4 * v3 * format_process_at_once;
  int v18 = *(unsigned int **)(a1 + 104);
  unint64_t v100 = v4 * v3;
  unint64_t v101 = v7 + v12;
  unint64_t v19 = (v17 | v14) >> 4;
  int v97 = (void *)a1;
  uint64_t v20 = *(void *)(a1 + 96);
  uint64_t v21 = 0LL;
  int v22 = (_OWORD *)((((v20 + 15) | 0xE)
                  + (2 * v3 * (unint64_t)v4 + 32) * get_format_convert_at_once(v2)) & 0xFFFFFFFFFFFFFFF0LL);
  *(void *)&__int128 v23 = -1LL;
  *((void *)&v23 + 1) = -1LL;
  *int v22 = v23;
  v22[1] = v23;
  v22[2] = v23;
  v22[3] = v23;
  v22[4] = v23;
  v22[5] = v23;
  unint64_t v24 = (v20 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  v22[6] = v23;
  v22[7] = v23;
  v22[8] = v23;
  v22[9] = v23;
  v22[10] = v23;
  v22[11] = v23;
  v22[12] = v23;
  v22[13] = v23;
  v22[14] = v23;
  v22[15] = v23;
  v22[16] = v23;
  v22[17] = v23;
  v22[18] = v23;
  v22[19] = v23;
  v22[20] = v23;
  v22[21] = v23;
  v22[22] = v23;
  v22[23] = v23;
  v22[24] = v23;
  v22[25] = v23;
  v22[26] = v23;
  v22[27] = v23;
  v22[28] = v23;
  v22[29] = v23;
  v22[30] = v23;
  v22[31] = v23;
  *(void *)&__int128 v23 = 0x101010101010101LL;
  *((void *)&v23 + 1) = 0x101010101010101LL;
  v22[62] = v23;
  v22[63] = v23;
  v22[60] = v23;
  v22[61] = v23;
  v22[58] = v23;
  v22[59] = v23;
  v22[56] = v23;
  v22[57] = v23;
  v22[54] = v23;
  v22[55] = v23;
  v22[52] = v23;
  v22[53] = v23;
  v22[50] = v23;
  v22[51] = v23;
  v22[48] = v23;
  v22[49] = v23;
  v22[46] = v23;
  v22[47] = v23;
  v22[44] = v23;
  v22[45] = v23;
  v22[42] = v23;
  v22[43] = v23;
  v22[40] = v23;
  v22[41] = v23;
  v22[38] = v23;
  v22[39] = v23;
  v22[36] = v23;
  v22[37] = v23;
  v22[34] = v23;
  v22[35] = v23;
  unsigned int v25 = (char *)v22 + 477;
  v22[32] = v23;
  v22[33] = v23;
  int v105 = v22;
  do
  {
    v25[v21] = quantize_slow((int)v21 - 35);
    ++v21;
  }

  while (v21 != 71);
  *(_DWORD *)(v24 + 10) = 0;
  *(_WORD *)(v24 + 14) = 0;
  uint64_t v26 = v91;
  unsigned int v27 = format_convert_at_once;
  int v28 = v100;
  if (v92)
  {
    unint64_t v29 = v18;
    unsigned int v30 = 0;
    int v31 = 0;
    unsigned int v32 = 0;
    unint64_t v33 = 0LL;
    unsigned int v104 = 0;
    uint64_t v34 = v24 + 12;
    if (v6) {
      BOOL v35 = format_convert_at_once == 0;
    }
    else {
      BOOL v35 = 1;
    }
    char v36 = v35;
    unsigned int v37 = 60;
    char v90 = v36;
    int v38 = -1;
    do
    {
      unsigned int v95 = v30;
      int v93 = v31;
      unint64_t v103 = v33;
      if (v27)
      {
        unsigned int v39 = 0;
        int v40 = *(unsigned __int16 *)(v34 - 2);
        int v41 = (unsigned __int16 *)v34;
        uint64_t v42 = v102;
        do
        {
          int v43 = *v41;
          unsigned int v44 = v43 - v40 + 512;
          if (v44 > 0x3FF) {
            int v45 = ((v43 - v40) >> 31) | 1;
          }
          else {
            int v45 = *((char *)v105 + v44);
          }
          uint64_t v34 = v24 + 16 + 2 * (((v102 + 2) + 15LL) & 0x1FFFFFFF0LL) * v39;
          if ((_DWORD)v42)
          {
            uint64_t v46 = 0LL;
            int v47 = *v41;
            int v48 = v47;
            do
            {
              int v49 = v48;
              uint64_t v50 = v46 + 1;
              int v48 = v41[v46 + 1];
              unsigned int v51 = v48 - v49 + 512;
              if (v51 > 0x3FF) {
                int v52 = ((v48 - v49) >> 31) | 1;
              }
              else {
                int v52 = *((char *)v105 + v51);
              }
              int v53 = v47 - v40;
              unsigned int v54 = v47 - v40 + 512;
              if (v54 > 0x3FF) {
                int v55 = (v53 >> 31) | 1;
              }
              else {
                int v55 = *((char *)v105 + v54);
              }
              int v56 = v55 + 11 * (v52 + 11 * v45);
              int v57 = v53 + v49;
              if (v53 + v49 <= v49) {
                int v58 = v49;
              }
              else {
                int v58 = v53 + v49;
              }
              if (v57 >= v49) {
                int v57 = v49;
              }
              if (v58 < v47) {
                int v47 = v58;
              }
              if (v57 > v47) {
                int v47 = v57;
              }
              if (!v56 && v38 < 0)
              {
                int v59 = 0;
                for (unsigned int i = v32 - 1; ; ++i)
                {
                  if (v37 > 0x20)
                  {
                    unsigned int v63 = v37;
                  }

                  else
                  {
                    if (v11 <= v13)
                    {
                      uint64_t v61 = 0LL;
                    }

                    else
                    {
                      unsigned int v62 = *(_DWORD *)(v11 - 4);
                      v11 -= 4LL;
                      uint64_t v61 = v62;
                    }

                    v19 += v61 << v37;
                    unsigned int v63 = v37 + 32;
                  }

                  char v64 = v19;
                  unsigned int v37 = v63 - 1;
                  v19 >>= 1;
                  int v65 = lut_rle[v32 & 0x3F];
                  if ((v64 & 1) == 0) {
                    break;
                  }
                  LOBYTE(v32) = v32 + 1;
                  v59 += 1 << v65;
                }

                if (v37 <= 0x20)
                {
                  if (v11 <= v13)
                  {
                    uint64_t v66 = 0LL;
                  }

                  else
                  {
                    unsigned int v67 = *(_DWORD *)(v11 - 4);
                    v11 -= 4LL;
                    uint64_t v66 = v67;
                  }

                  v19 += v66 << v37;
                  unsigned int v37 = v63 + 31;
                }

                int v68 = v19 & ~(-1 << v65);
                v37 -= v65;
                v19 >>= v65;
                int v38 = v68 + v59;
                unsigned int v32 = i + (i >> 31);
              }

              if (v38 <= 0)
              {
                if (v56 >= 0) {
                  uint64_t v69 = v56;
                }
                else {
                  uint64_t v69 = -v56;
                }
                if (v104 > 0x20)
                {
                  unint64_t v72 = v103;
                }

                else
                {
                  if ((unint64_t)v29 >= v101)
                  {
                    uint64_t v70 = 0LL;
                  }

                  else
                  {
                    unsigned int v71 = *v29++;
                    uint64_t v70 = v71;
                  }

                  unint64_t v72 = (v70 << v104) + v103;
                  v104 += 32;
                }

                unsigned int v73 = __clz(__rbit32(v72 | 0x10000));
                if (v73 > 0xF)
                {
                  uint64_t v78 = v26 + 4 * v69;
                  int v79 = *(unsigned __int8 *)(v78 + 3);
                  unsigned int v76 = (WORD1(v72) & ~(-1 << v79)) + (16 << *(_BYTE *)(v78 + 2));
                  int v77 = v79 + 16;
                }

                else
                {
                  unsigned int v74 = v73 + 1;
                  int v75 = *(unsigned __int8 *)(v26 + 4 * v69 + 2);
                  uint64_t v42 = v102;
                  unsigned int v76 = ((v72 >> (v73 + 1)) & ~(-1 << v75)) + (v73 << v75);
                  int v77 = v74 + v75;
                }

                v104 -= v77;
                unint64_t v103 = v72 >> v77;
                int v80 = (int)(((-(v76 & 1) ^ (v76 >> 1)) + *(__int16 *)(v26 + 4LL * v69)) << (32 - v89)) >> (32 - v89);
                if (v38) {
                  BOOL v81 = 0;
                }
                else {
                  BOOL v81 = v80 < 1;
                }
                int v82 = v81;
                int v83 = v80 - v82;
                if (v56 >= 0) {
                  int v84 = v83;
                }
                else {
                  int v84 = -v83;
                }
                int v47 = (v84 + v47) & ~(-1 << v89);
              }

              --v38;
              *(_WORD *)(v34 + 2 * v46++) = v47;
              int v45 = v52;
              int v40 = v49;
            }

            while (v50 != v42);
          }

          *(_WORD *)(v34 + 2 * v42) = *(_WORD *)(v34 + 2LL * (v102 - 1));
          *(_WORD *)(v34 - 2) = v43;
          ++v39;
          int v40 = v43;
          int v41 = (unsigned __int16 *)v34;
        }

        while (v39 * format_process_at_once < format_convert_at_once);
      }

      uint64_t v94 = v29;
      uint64_t v96 = *v97 + v97[1] * v95;
      v107();
      int v85 = v100;
      if ((v90 & 1) == 0)
      {
        int v86 = v97;
        uint64_t v87 = 0LL;
        do
        {
          convert_row_to_msb((uint16x8_t *)(v96 + v86[1] * v87), v100, 16 - v89);
          int v86 = v97;
          int v85 = v100;
          ++v87;
        }

        while (format_convert_at_once != v87);
      }

      int v31 = v93 + 1;
      unsigned int v27 = format_convert_at_once;
      unsigned int v30 = (v93 + 1) * format_convert_at_once;
      uint64_t v26 = v91;
      unint64_t v29 = v94;
      int v28 = v85;
      unint64_t v33 = v103;
    }

    while (v30 < v92);
  }

  return (v28 * v92) << (v89 > 8);
}

uint64_t quantize_slow(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0) {
    return -quantize_slow(-a1);
  }
  if (a1 == 1) {
    int v1 = 5;
  }
  else {
    int v1 = 0;
  }
  if (a1 <= 1) {
    int v2 = v1;
  }
  else {
    int v2 = 4;
  }
  if (a1 <= 4) {
    int v3 = v2;
  }
  else {
    int v3 = 3;
  }
  if (a1 <= 0xB) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 2;
  }
  if (a1 <= 0x22) {
    return v4;
  }
  else {
    return 1LL;
  }
}

double _tr_init(uint64_t a1)
{
  *(void *)(a1 + 2888) = a1 + 196;
  *(void *)(a1 + 2904) = &static_l_desc;
  *(void *)(a1 + 2912) = a1 + 2488;
  *(void *)(a1 + 2928) = &static_d_desc;
  *(void *)(a1 + 2936) = a1 + 2732;
  *(void *)(a1 + 2952) = &static_bl_desc;
  *(_WORD *)(a1 + 5920) = 0;
  *(_DWORD *)(a1 + 5924) = 0;
  *(_DWORD *)(a1 + 5916) = 8;
  return init_block(a1);
}

double init_block(uint64_t a1)
{
  for (uint64_t i = 196LL; i != 1340; i += 4LL)
    *(_WORD *)(a1 + i) = 0;
  for (uint64_t j = 0LL; j != 120; j += 4LL)
    *(_WORD *)(a1 + 2488 + j) = 0;
  for (uint64_t k = 0LL; k != 76; k += 4LL)
    *(_WORD *)(a1 + 2732 + k) = 0;
  *(_WORD *)(a1 + 1220) = 1;
  *(_DWORD *)(a1 + 5884) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 5896) = 0u;
  *(_DWORD *)(a1 + 5912) = 0;
  return result;
}

uint64_t _tr_stored_block(uint64_t a1, char *a2, int a3, int a4)
{
  int v4 = a3;
  int v7 = *(_DWORD *)(a1 + 5924);
  if (v7 < 14)
  {
    *(_WORD *)(a1 + 5920) |= (_WORD)a4 << v7;
    int v14 = v7 + 3;
  }

  else
  {
    __int16 v8 = *(_WORD *)(a1 + 5920) | (a4 << v7);
    *(_WORD *)(a1 + 5920) = v8;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v10 + 1;
    *(_BYTE *)(v9 + v10) = v8;
    LOBYTE(v8) = *(_BYTE *)(a1 + 5921);
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v12 + 1;
    *(_BYTE *)(v11 + v12) = v8;
    int v13 = *(_DWORD *)(a1 + 5924);
    *(_WORD *)(a1 + 5920) = (unsigned __int16)a4 >> (16 - v13);
    int v14 = v13 - 13;
  }

  *(_DWORD *)(a1 + 5924) = v14;
  __int16 v15 = ~(_WORD)a3;
  uint64_t result = bi_windup(a1);
  *(_DWORD *)(a1 + 5916) = 8;
  uint64_t v17 = *(void *)(a1 + 16);
  uint64_t v18 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v18 + 1;
  *(_BYTE *)(v17 + v18) = v4;
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v20 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v20 + 1;
  *(_BYTE *)(v19 + v20) = BYTE1(v4);
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v22 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v22 + 1;
  *(_BYTE *)(v21 + v22) = v15;
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v24 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v24 + 1;
  for (*(_BYTE *)(v23 + v24) = HIBYTE(v15); v4; --v4)
  {
    char v25 = *a2++;
    uint64_t v26 = *(void *)(a1 + 16);
    uint64_t v27 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v27 + 1;
    *(_BYTE *)(v26 + v27) = v25;
  }

  return result;
}

uint64_t _tr_align(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 5924);
  int v3 = *(unsigned __int16 *)(a1 + 5920);
  unsigned int v4 = v3 | (2 << v2);
  *(_WORD *)(a1 + 5920) = v3 | (2 << v2);
  if (v2 < 14)
  {
    int v10 = v2 + 3;
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v6 + 1;
    *(_BYTE *)(v5 + v6) = v4;
    char v7 = *(_BYTE *)(a1 + 5921);
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v9 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v9 + 1;
    *(_BYTE *)(v8 + v9) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 5924);
    unsigned int v4 = 2u >> (16 - v8);
    *(_WORD *)(a1 + 5920) = v4;
    int v10 = v8 - 13;
  }

  *(_DWORD *)(a1 + 5924) = v10;
  if (v10 < 10)
  {
    int v16 = v10 + 7;
  }

  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v12 + 1;
    *(_BYTE *)(v11 + v12) = v4;
    char v13 = *(_BYTE *)(a1 + 5921);
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v15 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v15 + 1;
    *(_BYTE *)(v14 + v15) = v13;
    *(_WORD *)(a1 + 5920) = 0;
    int v16 = *(_DWORD *)(a1 + 5924) - 9;
  }

  *(_DWORD *)(a1 + 5924) = v16;
  uint64_t result = bi_flush(a1);
  int v18 = *(_DWORD *)(a1 + 5924);
  if (*(_DWORD *)(a1 + 5916) - v18 + 11 <= 8)
  {
    int v19 = *(unsigned __int16 *)(a1 + 5920);
    unsigned int v20 = v19 | (2 << v18);
    *(_WORD *)(a1 + 5920) = v19 | (2 << v18);
    if (v18 < 14)
    {
      int v26 = v18 + 3;
    }

    else
    {
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v22 + 1;
      *(_BYTE *)(v21 + v22) = v20;
      char v23 = *(_BYTE *)(a1 + 5921);
      uint64_t v24 = *(void *)(a1 + 16);
      uint64_t v25 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v25 + 1;
      *(_BYTE *)(v24 + v25) = v23;
      LODWORD(v24) = *(_DWORD *)(a1 + 5924);
      unsigned int v20 = 2u >> (16 - v24);
      *(_WORD *)(a1 + 5920) = v20;
      int v26 = v24 - 13;
    }

    *(_DWORD *)(a1 + 5924) = v26;
    if (v26 < 10)
    {
      int v32 = v26 + 7;
    }

    else
    {
      uint64_t v27 = *(void *)(a1 + 16);
      uint64_t v28 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v28 + 1;
      *(_BYTE *)(v27 + v28) = v20;
      char v29 = *(_BYTE *)(a1 + 5921);
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v31 + 1;
      *(_BYTE *)(v30 + v31) = v29;
      *(_WORD *)(a1 + 5920) = 0;
      int v32 = *(_DWORD *)(a1 + 5924) - 9;
    }

    *(_DWORD *)(a1 + 5924) = v32;
    uint64_t result = bi_flush(a1);
  }

  *(_DWORD *)(a1 + 5916) = 7;
  return result;
}

uint64_t bi_flush(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 5924);
  if (v1 == 16)
  {
    int v2 = 0;
    char v3 = *(_BYTE *)(result + 5920);
    uint64_t v4 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v4 + 1;
    *(_BYTE *)(*(void *)(result + 16) + v4) = v3;
    char v5 = *(_BYTE *)(result + 5921);
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v7 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v7 + 1;
    *(_BYTE *)(v6 + v7) = v5;
    *(_WORD *)(result + 5920) = 0;
  }

  else
  {
    if (v1 < 8) {
      return result;
    }
    char v8 = *(_BYTE *)(result + 5920);
    uint64_t v9 = *(void *)(result + 16);
    uint64_t v10 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v10 + 1;
    *(_BYTE *)(v9 + v10) = v8;
    *(_WORD *)(result + 5920) = *(unsigned __int8 *)(result + 5921);
    int v2 = *(_DWORD *)(result + 5924) - 8;
  }

  *(_DWORD *)(result + 5924) = v2;
  return result;
}

void _tr_flush_block(int *a1, char *a2, uint64_t a3, int a4)
{
  if (a1[45] < 1)
  {
    unsigned int v11 = 0;
    unint64_t v12 = a3 + 5;
    unint64_t v13 = a3 + 5;
    if (!a2) {
      goto LABEL_24;
    }
  }

  else
  {
    if (*(_DWORD *)(*(void *)a1 + 88LL) == 2)
    {
      uint64_t v8 = 0LL;
      unint64_t v9 = 4093624447LL;
      do
      {
        if ((v9 & 1) != 0 && LOWORD(a1[v8 + 49]))
        {
          int v10 = 0;
          goto LABEL_14;
        }

        v9 >>= 1;
        ++v8;
      }

      while (v8 != 32);
      if (!*((_WORD *)a1 + 116) && !*((_WORD *)a1 + 118) && !*((_WORD *)a1 + 124))
      {
        uint64_t v71 = 0LL;
        unint64_t v72 = a1 + 81;
        while (1)
        {
          int v10 = (unsigned __int16)v72[v71];
          if (v72[v71]) {
            break;
          }
          v71 += 2LL;
          if (v71 == 448) {
            goto LABEL_14;
          }
        }
      }

      int v10 = 1;
LABEL_14:
      *(_DWORD *)(*(void *)a1 + 88LL) = v10;
    }

    build_tree((uint64_t)a1, (uint64_t)(a1 + 722));
    build_tree((uint64_t)a1, (uint64_t)(a1 + 728));
    scan_tree(a1, (uint64_t)(a1 + 49), a1[724]);
    scan_tree(a1, (uint64_t)(a1 + 622), a1[730]);
    build_tree((uint64_t)a1, (uint64_t)(a1 + 734));
    unsigned int v11 = 0x12u;
    while (!HIWORD(a1[bl_order[v11] + 683]))
    {
      if (v11-- <= 3)
      {
        unsigned int v11 = 2;
        break;
      }
    }

    uint64_t v15 = *((void *)a1 + 737) + (int)(3 * v11 + 17);
    *((void *)a1 + 737) = v15;
    unint64_t v13 = (unint64_t)(v15 + 10) >> 3;
    unint64_t v12 = (unint64_t)(*((void *)a1 + 738) + 10LL) >> 3;
    if (v12 < v13) {
      unint64_t v13 = (unint64_t)(*((void *)a1 + 738) + 10LL) >> 3;
    }
    if (!a2) {
      goto LABEL_24;
    }
  }

  if (a3 + 4 <= v13)
  {
    _tr_stored_block((uint64_t)a1, a2, a3, a4);
    goto LABEL_50;
  }

uint64_t build_tree(uint64_t a1, uint64_t a2)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)a2;
  char v5 = *(uint64_t **)(a2 + 16);
  uint64_t v6 = *v5;
  uint64_t v7 = *((unsigned int *)v5 + 5);
  uint64_t v8 = (int *)(a1 + 5284);
  *(void *)(a1 + 5284) = 0x23D00000000LL;
  if ((int)v7 < 1)
  {
    int v13 = 0;
    int v11 = -1;
  }

  else
  {
    uint64_t v9 = 0LL;
    int v10 = (_WORD *)(v4 + 2);
    int v11 = -1;
    do
    {
      if (*(v10 - 1))
      {
        uint64_t v12 = *(int *)(a1 + 5284) + 1LL;
        *(_DWORD *)(a1 + 5284) = v12;
        *(_DWORD *)(a1 + 4 * v12 + 2992) = v9;
        *(_BYTE *)(a1 + 5292 + v9) = 0;
        int v11 = v9;
      }

      else
      {
        *int v10 = 0;
      }

      v10 += 2;
      ++v9;
    }

    while (v7 != v9);
    int v13 = *v8;
    if (*v8 > 1) {
      goto LABEL_20;
    }
  }

  int v14 = v11;
  do
  {
    if (v14 >= 2) {
      int v11 = v14;
    }
    else {
      int v11 = v14 + 1;
    }
    if (v14 < 2) {
      int v15 = v14 + 1;
    }
    else {
      int v15 = 0;
    }
    uint64_t v16 = v13 + 1LL;
    *(_DWORD *)(a1 + 5284) = v16;
    *(_DWORD *)(a1 + 4 * v16 + 2992) = v15;
    *(_WORD *)(v4 + 4LL * v15) = 1;
    *(_BYTE *)(a1 + v15 + 5292) = 0;
    --*(void *)(a1 + 5896);
    if (v6) {
      *(void *)(a1 + 5904) -= *(unsigned __int16 *)(v6 + 4LL * v15 + 2);
    }
    int v13 = *v8;
    int v14 = v11;
  }

  while (*v8 < 2);
LABEL_20:
  *(_DWORD *)(a2 + 8) = v11;
  int v17 = v13 >> 1;
  do
  {
    pqdownheap(a1, v4, v17);
    BOOL v18 = v17-- != 0;
  }

  while (v17 != 0 && v18);
  int v19 = *(_DWORD *)(a1 + 5284);
  uint64_t v20 = (int)v7;
  uint64_t v21 = 4LL * (int)v7;
  do
  {
    uint64_t v22 = *(int *)(a1 + 2996);
    *(_DWORD *)(a1 + 5284) = v19 - 1;
    uint64_t v23 = a1 + 2992;
    *(_DWORD *)(a1 + 2996) = *(_DWORD *)(a1 + 2992 + 4LL * v19);
    pqdownheap(a1, v4, 1);
    uint64_t v24 = *(int *)(a1 + 2996);
    uint64_t v25 = *(int *)(a1 + 5288) - 1LL;
    *(_DWORD *)(a1 + 5288) = v25;
    *(_DWORD *)(v23 + 4 * v25) = v22;
    uint64_t v26 = *(int *)(a1 + 5288) - 1LL;
    *(_DWORD *)(a1 + 5288) = v26;
    *(_DWORD *)(v23 + 4 * v26) = v24;
    uint64_t v27 = (_WORD *)(v4 + 4 * v22);
    uint64_t v28 = (_WORD *)(v4 + 4 * v24);
    *(_WORD *)(v4 + v21) = *v28 + *v27;
    unsigned int v29 = *(unsigned __int8 *)(a1 + 5292 + v24);
    *(_BYTE *)(a1 + 5292 + v20) = v29 + 1;
    v28[1] = v20;
    v27[1] = v20;
    *(_DWORD *)(a1 + 2996) = v20;
    uint64_t result = pqdownheap(a1, v4, 1);
    int v19 = *(_DWORD *)(a1 + 5284);
    v21 += 4LL;
    ++v20;
  }

  while (v19 > 1);
  int v31 = *(_DWORD *)(a1 + 2996);
  uint64_t v32 = *(int *)(a1 + 5288) - 1LL;
  *(_DWORD *)(a1 + 5288) = v32;
  *(_DWORD *)(v23 + 4 * v32) = v31;
  uint64_t v33 = *(void *)a2;
  int v34 = *(_DWORD *)(a2 + 8);
  int v35 = *(uint64_t **)(a2 + 16);
  uint64_t v36 = *v35;
  uint64_t v37 = v35[1];
  int v38 = *((_DWORD *)v35 + 4);
  uint64_t v39 = *((int *)v35 + 6);
  *(_OWORD *)(a1 + 2976) = 0u;
  *(_OWORD *)(a1 + 2960) = 0u;
  *(_WORD *)(v33 + 4LL * *(int *)(v23 + 4LL * *(int *)(a1 + 5288)) + 2) = 0;
  uint64_t v40 = *(int *)(a1 + 5288);
  if ((int)v40 <= 571)
  {
    int v41 = 0;
    do
    {
      uint64_t v42 = *(int *)(a1 + 2996 + 4 * v40);
      uint64_t result = v33 + 4 * v42;
      int v43 = *(unsigned __int16 *)(v33 + 4LL * *(unsigned __int16 *)(result + 2) + 2);
      BOOL v44 = (int)v39 <= v43;
      else {
        int v45 = v39;
      }
      if (v44) {
        ++v41;
      }
      *(_WORD *)(result + 2) = v45;
      if ((int)v42 <= v34)
      {
        ++*(_WORD *)(a1 + 2LL * v45 + 2960);
        int v46 = (int)v42 >= v38 ? *(_DWORD *)(v37 + 4LL * ((int)v42 - v38)) : 0;
        uint64_t result = *(unsigned __int16 *)result;
        *(void *)(a1 + 5896) += (int)result * (uint64_t)(v46 + v45);
        if (v36) {
          *(void *)(a1 + 5904) += (*(unsigned __int16 *)(v36 + 4 * v42 + 2) + (uint64_t)v46) * result;
        }
      }
    }

    while ((_DWORD)v40++ != 571);
    if (v41)
    {
      do
      {
        uint64_t v48 = (_WORD *)(a1 + 2 * v39 + 2960);
        uint64_t v49 = (v39 << 32) + 0x100000000LL;
        do
        {
          int v51 = (unsigned __int16)*--v48;
          __int16 v50 = v51;
          v49 -= 0x100000000LL;
        }

        while (!v51);
        *uint64_t v48 = v50 - 1;
        *(_WORD *)(a1 + (v49 >> 31) + 2960) += 2;
        --*(_WORD *)(a1 + 2 * v39 + 2960);
        BOOL v52 = __OFSUB__(v41, 2);
        v41 -= 2;
      }

      while (!((v41 < 0) ^ v52 | (v41 == 0)));
      if ((_DWORD)v39)
      {
        int v53 = 573;
        do
        {
          int v54 = *(unsigned __int16 *)(a1 + 2 * v39 + 2960);
          if (*(_WORD *)(a1 + 2 * v39 + 2960))
          {
            do
            {
              __int16 v55 = (int *)(a1 + 2988 + 4LL * v53);
              do
              {
                uint64_t v57 = *v55--;
                uint64_t v56 = v57;
                --v53;
              }

              while ((int)v57 > v34);
              uint64_t v58 = v33 + 4 * v56;
              unsigned int v61 = *(unsigned __int16 *)(v58 + 2);
              uint64_t v59 = (_WORD *)(v58 + 2);
              uint64_t v60 = v61;
              if ((_DWORD)v39 != v61)
              {
                *(void *)(a1 + 5896) += (v39 - v60) * *(unsigned __int16 *)(v33 + 4 * v56);
                *uint64_t v59 = v39;
              }

              --v54;
            }

            while (v54);
          }

          --v39;
        }

        while ((_DWORD)v39);
      }
    }
  }

  uint64_t v62 = 0LL;
  unsigned __int16 v63 = 0;
  do
  {
    unsigned __int16 v63 = 2 * ((v63 & 0xFFFE) + *(_WORD *)(a1 + 2960 + v62 * 2));
    v71[++v62] = v63;
  }

  while (v62 != 15);
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v64 = 0LL;
    do
    {
      uint64_t v65 = v4 + 4 * v64;
      int v66 = *(unsigned __int16 *)(v65 + 2);
      if (*(_WORD *)(v65 + 2))
      {
        int v67 = 0;
        unsigned int v68 = v71[*(unsigned __int16 *)(v65 + 2)];
        v71[v66] = v68 + 1;
        unsigned int v69 = v66 + 1;
        do
        {
          int v70 = v67 | v68 & 1;
          v68 >>= 1;
          int v67 = 2 * v70;
          --v69;
        }

        while (v69 > 1);
        *(_WORD *)(v4 + 4 * v64) = v70;
      }

      ++v64;
    }

    while (v64 != v11 + 1);
  }

  return result;
}

uint64_t compress_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(result + 5884))
  {
    uint64_t v3 = 0LL;
    while (1)
    {
      unsigned int v4 = *(unsigned __int16 *)(*(void *)(result + 5888) + 2 * v3);
      uint64_t v5 = *(unsigned __int8 *)(*(void *)(result + 5872) + v3);
      if (*(_WORD *)(*(void *)(result + 5888) + 2 * v3)) {
        break;
      }
      int v19 = (unsigned __int16 *)(a2 + 4 * v5);
      int v20 = v19[1];
      int v21 = *(_DWORD *)(result + 5924);
      unsigned int v22 = *v19;
      int v23 = *(unsigned __int16 *)(result + 5920);
      int v24 = v23 | (v22 << v21);
      *(_WORD *)(result + 5920) = v23 | ((_WORD)v22 << v21);
      if (v21 > 16 - v20)
      {
        uint64_t v25 = *(void *)(result + 16);
        uint64_t v26 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v26 + 1;
        *(_BYTE *)(v25 + v26) = v24;
        char v27 = *(_BYTE *)(result + 5921);
        uint64_t v28 = *(void *)(result + 16);
        uint64_t v29 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v29 + 1;
        *(_BYTE *)(v28 + v29) = v27;
        int v30 = *(_DWORD *)(result + 5924);
        *(_WORD *)(result + 5920) = v22 >> (16 - v30);
        int v31 = v20 + v30;
LABEL_24:
        int v40 = v31 - 16;
        goto LABEL_26;
      }

      int v40 = v21 + v20;
LABEL_26:
      *(_DWORD *)(result + 5924) = v40;
LABEL_27:
    }

    uint64_t v6 = _length_code[v5];
    uint64_t v7 = a2 + 4 * v6;
    int v8 = *(unsigned __int16 *)(v7 + 1030);
    int v9 = *(_DWORD *)(result + 5924);
    unsigned int v10 = *(unsigned __int16 *)(v7 + 1028);
    int v11 = *(unsigned __int16 *)(result + 5920);
    int v12 = v11 | (v10 << v9);
    *(_WORD *)(result + 5920) = v11 | ((_WORD)v10 << v9);
    if (v9 <= 16 - v8)
    {
      int v18 = v9 + v8;
    }

    else
    {
      uint64_t v13 = *(void *)(result + 16);
      uint64_t v14 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v14 + 1;
      *(_BYTE *)(v13 + v14) = v12;
      char v15 = *(_BYTE *)(result + 5921);
      uint64_t v16 = *(void *)(result + 16);
      uint64_t v17 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v17 + 1;
      *(_BYTE *)(v16 + v17) = v15;
      LODWORD(v16) = *(_DWORD *)(result + 5924);
      int v12 = v10 >> (16 - v16);
      *(_WORD *)(result + 5920) = v12;
      int v18 = v8 + v16 - 16;
    }

    *(_DWORD *)(result + 5924) = v18;
    if ((unint64_t)(v6 - 28) >= 0xFFFFFFFFFFFFFFECLL)
    {
      int v32 = extra_lbits[v6];
      int v33 = v5 - base_length[v6];
      if (v18 <= 16 - v32)
      {
        v12 |= v33 << v18;
        *(_WORD *)(result + 5920) = v12;
        v18 += v32;
      }

      else
      {
        unsigned int v34 = (unsigned __int16)v33;
        __int16 v35 = v12 | (v33 << v18);
        *(_WORD *)(result + 5920) = v35;
        uint64_t v36 = *(void *)(result + 16);
        uint64_t v37 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v37 + 1;
        *(_BYTE *)(v36 + v37) = v35;
        LOBYTE(v35) = *(_BYTE *)(result + 5921);
        uint64_t v38 = *(void *)(result + 16);
        uint64_t v39 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v39 + 1;
        *(_BYTE *)(v38 + v39) = v35;
        LODWORD(v38) = *(_DWORD *)(result + 5924);
        int v12 = v34 >> (16 - v38);
        *(_WORD *)(result + 5920) = v12;
        int v18 = v32 + v38 - 16;
      }

      *(_DWORD *)(result + 5924) = v18;
    }

    unsigned int v41 = v4 - 1;
    if (v4 >= 0x101) {
      unsigned int v42 = ((v4 - 1) >> 7) + 256;
    }
    else {
      unsigned int v42 = v4 - 1;
    }
    uint64_t v43 = _dist_code[v42];
    BOOL v44 = (unsigned __int16 *)(a3 + 4 * v43);
    int v45 = v44[1];
    unsigned int v46 = *v44;
    int v47 = v12 | (v46 << v18);
    *(_WORD *)(result + 5920) = v47;
    if (v18 <= 16 - v45)
    {
      int v40 = v18 + v45;
    }

    else
    {
      uint64_t v48 = *(void *)(result + 16);
      uint64_t v49 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v49 + 1;
      *(_BYTE *)(v48 + v49) = v47;
      char v50 = *(_BYTE *)(result + 5921);
      uint64_t v51 = *(void *)(result + 16);
      uint64_t v52 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v52 + 1;
      *(_BYTE *)(v51 + v52) = v50;
      LODWORD(v51) = *(_DWORD *)(result + 5924);
      int v47 = v46 >> (16 - v51);
      *(_WORD *)(result + 5920) = v47;
      int v40 = v45 + v51 - 16;
    }

    *(_DWORD *)(result + 5924) = v40;
    int v53 = extra_dbits[v43];
    unsigned int v54 = v41 - base_dist[v43];
    if (v40 <= 16 - v53)
    {
      *(_WORD *)(result + 5920) = v47 | ((_WORD)v54 << v40);
      v40 += v53;
      goto LABEL_26;
    }

    unsigned int v55 = (unsigned __int16)v54;
    __int16 v56 = v47 | (v54 << v40);
    *(_WORD *)(result + 5920) = v56;
    uint64_t v57 = *(void *)(result + 16);
    uint64_t v58 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v58 + 1;
    *(_BYTE *)(v57 + v58) = v56;
    LOBYTE(v56) = *(_BYTE *)(result + 5921);
    uint64_t v59 = *(void *)(result + 16);
    uint64_t v60 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v60 + 1;
    *(_BYTE *)(v59 + v60) = v56;
    int v61 = *(_DWORD *)(result + 5924);
    *(_WORD *)(result + 5920) = v55 >> (16 - v61);
    int v31 = v53 + v61;
    goto LABEL_24;
  }

  int v40 = *(_DWORD *)(result + 5924);
LABEL_30:
  int v62 = *(unsigned __int16 *)(a2 + 1026);
  unsigned int v63 = *(unsigned __int16 *)(a2 + 1024);
  int v64 = *(unsigned __int16 *)(result + 5920);
  int v65 = v64 | (v63 << v40);
  *(_WORD *)(result + 5920) = v64 | ((_WORD)v63 << v40);
  if (v40 <= 16 - v62)
  {
    int v72 = v40 + v62;
  }

  else
  {
    uint64_t v66 = *(void *)(result + 16);
    uint64_t v67 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v67 + 1;
    *(_BYTE *)(v66 + v67) = v65;
    char v68 = *(_BYTE *)(result + 5921);
    uint64_t v69 = *(void *)(result + 16);
    uint64_t v70 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v70 + 1;
    *(_BYTE *)(v69 + v70) = v68;
    int v71 = *(_DWORD *)(result + 5924);
    *(_WORD *)(result + 5920) = v63 >> (16 - v71);
    int v72 = v62 + v71 - 16;
  }

  *(_DWORD *)(result + 5924) = v72;
  *(_DWORD *)(result + 5916) = *(unsigned __int16 *)(a2 + 1026);
  return result;
}

uint64_t bi_windup(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 5924);
  if (v1 >= 9)
  {
    int v2 = (uint64_t *)(result + 16);
    uint64_t v3 = *(void *)(result + 16);
    unsigned int v4 = (_DWORD *)(result + 40);
    uint64_t v5 = *(unsigned int *)(result + 40);
    char v6 = *(_BYTE *)(result + 5920);
    *(_DWORD *)(result + 40) = v5 + 1;
    *(_BYTE *)(v3 + v5) = v6;
    char v7 = *(_BYTE *)(result + 5921);
LABEL_5:
    uint64_t v8 = *v2;
    uint64_t v9 = *v4;
    *unsigned int v4 = v9 + 1;
    *(_BYTE *)(v8 + v9) = v7;
    goto LABEL_6;
  }

  if (v1 >= 1)
  {
    char v7 = *(_BYTE *)(result + 5920);
    int v2 = (uint64_t *)(result + 16);
    unsigned int v4 = (_DWORD *)(result + 40);
    goto LABEL_5;
  }

BOOL _tr_tally(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 5884);
  *(_WORD *)(*(void *)(a1 + 5888) + 2 * v3) = a2;
  uint64_t v4 = *(void *)(a1 + 5872);
  *(_DWORD *)(a1 + 5884) = v3 + 1;
  *(_BYTE *)(v4 + v3) = a3;
  if (a2)
  {
    ++*(_DWORD *)(a1 + 5912);
    unsigned int v5 = a2 - 1;
    uint64_t v6 = a1 + 4LL * _length_code[a3];
    ++*(_WORD *)(v6 + 1224);
    if (a2 >= 0x101) {
      unsigned int v5 = ((a2 - 1) >> 7) + 256;
    }
    char v7 = (_WORD *)(a1 + 4LL * _dist_code[v5] + 2488);
  }

  else
  {
    char v7 = (_WORD *)(a1 + 4LL * a3 + 196);
  }

  ++*v7;
  return *(_DWORD *)(a1 + 5884) == *(_DWORD *)(a1 + 5880) - 1;
}

uint64_t pqdownheap(uint64_t result, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(result + 4LL * a3 + 2992);
  int v4 = 2 * a3;
  int v5 = *(_DWORD *)(result + 5284);
  if (2 * a3 <= v5)
  {
    uint64_t v7 = result + 5292;
    while (1)
    {
      if (v4 >= v5)
      {
        int v6 = v4;
        uint64_t v8 = v4;
      }

      else
      {
        uint64_t v8 = v4;
        uint64_t v9 = *(int *)(result + 2992 + 4 * (v4 | 1LL));
        unsigned int v10 = *(unsigned __int16 *)(a2 + 4 * v9);
        uint64_t v11 = *(int *)(result + 2992 + 4LL * v4);
        unsigned int v12 = *(unsigned __int16 *)(a2 + 4 * v11);
        if (v10 >= v12)
        {
          if (v10 != v12)
          {
            int v6 = v4;
            goto LABEL_11;
          }

          unsigned int v13 = *(unsigned __int8 *)(v7 + v9);
          int v6 = v4;
        }

        uint64_t v8 = v4 | 1LL;
        int v6 = v4 | 1;
      }

_WORD *scan_tree(_WORD *result, uint64_t a2, int a3)
{
  int v3 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v4 = (a3 + 1);
  *(_WORD *)(a2 + 4LL * (int)v4 + 2) = -1;
  if ((a3 & 0x80000000) == 0)
  {
    int v5 = 0;
    if (v3) {
      int v6 = 4;
    }
    else {
      int v6 = 3;
    }
    if (v3) {
      int v7 = 7;
    }
    else {
      int v7 = 138;
    }
    uint64_t v8 = (unsigned __int16 *)(a2 + 6);
    int v9 = -1;
    do
    {
      int v11 = *v8;
      v8 += 2;
      int v10 = v11;
      int v12 = v5 + 1;
      if (v5 + 1 >= v7 || v3 != v10)
      {
        if (v12 >= v6)
        {
          if (v3)
          {
            if (v3 != v9) {
              ++result[2 * v3 + 1366];
            }
            ++result[1398];
          }

          else if (v5 > 9)
          {
            ++result[1402];
          }

          else
          {
            ++result[1400];
          }
        }

        else
        {
          result[2 * v3 + 1366] += v12;
        }

        if (v3 == v10) {
          int v14 = 6;
        }
        else {
          int v14 = 7;
        }
        if (v3 == v10) {
          int v15 = 3;
        }
        else {
          int v15 = 4;
        }
        int v12 = 0;
        if (v10) {
          int v7 = v14;
        }
        else {
          int v7 = 138;
        }
        if (v10) {
          int v6 = v15;
        }
        else {
          int v6 = 3;
        }
        int v9 = v3;
      }

      int v5 = v12;
      int v3 = v10;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t send_tree(uint64_t result, uint64_t a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v3 = 0LL;
    int v4 = 0;
    unsigned int v5 = *(unsigned __int16 *)(a2 + 2);
    if (*(_WORD *)(a2 + 2)) {
      int v6 = 7;
    }
    else {
      int v6 = 138;
    }
    if (*(_WORD *)(a2 + 2)) {
      int v7 = 4;
    }
    else {
      int v7 = 3;
    }
    int v8 = -1;
    do
    {
      ++v3;
      unsigned int v9 = *(unsigned __int16 *)(a2 + 4 * v3 + 2);
      int v10 = v4 + 1;
      if (v4 + 1 >= v6 || v5 != v9)
      {
        if (v10 >= v7)
        {
          int v23 = *(_DWORD *)(result + 5924);
          if (v5)
          {
            if (v5 != v8)
            {
              uint64_t v24 = result + 4LL * v5;
              int v25 = *(unsigned __int16 *)(v24 + 2734);
              unsigned int v26 = *(unsigned __int16 *)(v24 + 2732);
              int v27 = *(unsigned __int16 *)(result + 5920);
              int v28 = v27 | (v26 << v23);
              *(_WORD *)(result + 5920) = v27 | ((_WORD)v26 << v23);
              if (v23 <= 16 - v25)
              {
                v23 += v25;
              }

              else
              {
                uint64_t v29 = *(void *)(result + 16);
                uint64_t v30 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v30 + 1;
                *(_BYTE *)(v29 + v30) = v28;
                LOBYTE(v29) = *(_BYTE *)(result + 5921);
                uint64_t v31 = *(void *)(result + 16);
                uint64_t v32 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v32 + 1;
                *(_BYTE *)(v31 + v32) = v29;
                LODWORD(v29) = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = v26 >> (16 - v29);
                int v23 = v25 + v29 - 16;
              }

              *(_DWORD *)(result + 5924) = v23;
              int v10 = v4;
            }

            int v52 = *(unsigned __int16 *)(result + 2798);
            unsigned int v53 = *(unsigned __int16 *)(result + 2796);
            int v54 = *(unsigned __int16 *)(result + 5920) | (v53 << v23);
            if (v23 <= 16 - v52)
            {
              int v60 = v23 + v52;
            }

            else
            {
              *(_WORD *)(result + 5920) = v54;
              uint64_t v55 = *(void *)(result + 16);
              uint64_t v56 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v56 + 1;
              *(_BYTE *)(v55 + v56) = v54;
              char v57 = *(_BYTE *)(result + 5921);
              uint64_t v58 = *(void *)(result + 16);
              uint64_t v59 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v59 + 1;
              *(_BYTE *)(v58 + v59) = v57;
              LODWORD(v58) = *(_DWORD *)(result + 5924);
              int v54 = v53 >> (16 - v58);
              int v60 = v52 + v58 - 16;
            }

            *(_DWORD *)(result + 5924) = v60;
            int v61 = v10 + 65533;
            if (v60 < 15)
            {
              *(_WORD *)(result + 5920) = v54 | (v61 << v60);
              int v69 = v60 + 2;
            }

            else
            {
              __int16 v62 = v54 | (v61 << v60);
              *(_WORD *)(result + 5920) = v62;
              uint64_t v63 = *(void *)(result + 16);
              uint64_t v64 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v64 + 1;
              *(_BYTE *)(v63 + v64) = v62;
              LOBYTE(v62) = *(_BYTE *)(result + 5921);
              uint64_t v65 = *(void *)(result + 16);
              uint64_t v66 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v66 + 1;
              *(_BYTE *)(v65 + v66) = v62;
              unsigned int v67 = (unsigned __int16)v61;
              int v68 = *(_DWORD *)(result + 5924);
              *(_WORD *)(result + 5920) = v67 >> (16 - v68);
              int v69 = v68 - 14;
            }
          }

          else
          {
            int v33 = *(unsigned __int16 *)(result + 5920);
            if (v4 > 9)
            {
              int v43 = *(unsigned __int16 *)(result + 2806);
              unsigned int v44 = *(unsigned __int16 *)(result + 2804);
              int v45 = v33 | (v44 << v23);
              if (v23 <= 16 - v43)
              {
                int v51 = v23 + v43;
              }

              else
              {
                *(_WORD *)(result + 5920) = v45;
                uint64_t v46 = *(void *)(result + 16);
                uint64_t v47 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v47 + 1;
                *(_BYTE *)(v46 + v47) = v45;
                char v48 = *(_BYTE *)(result + 5921);
                uint64_t v49 = *(void *)(result + 16);
                uint64_t v50 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v50 + 1;
                *(_BYTE *)(v49 + v50) = v48;
                LODWORD(v49) = *(_DWORD *)(result + 5924);
                int v45 = v44 >> (16 - v49);
                int v51 = v43 + v49 - 16;
              }

              *(_DWORD *)(result + 5924) = v51;
              int v78 = v4 + 65526;
              int v79 = v78 << v51;
              if (v51 < 10)
              {
                *(_WORD *)(result + 5920) = v45 | v79;
                int v69 = v51 + 7;
              }

              else
              {
                __int16 v80 = v45 | v79;
                *(_WORD *)(result + 5920) = v80;
                uint64_t v81 = *(void *)(result + 16);
                uint64_t v82 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v82 + 1;
                *(_BYTE *)(v81 + v82) = v80;
                LOBYTE(v80) = *(_BYTE *)(result + 5921);
                uint64_t v83 = *(void *)(result + 16);
                uint64_t v84 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v84 + 1;
                *(_BYTE *)(v83 + v84) = v80;
                int v85 = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = (unsigned __int16)v78 >> (16 - v85);
                int v69 = v85 - 9;
              }
            }

            else
            {
              int v34 = *(unsigned __int16 *)(result + 2802);
              unsigned int v35 = *(unsigned __int16 *)(result + 2800);
              int v36 = v33 | (v35 << v23);
              if (v23 <= 16 - v34)
              {
                int v42 = v23 + v34;
              }

              else
              {
                *(_WORD *)(result + 5920) = v36;
                uint64_t v37 = *(void *)(result + 16);
                uint64_t v38 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v38 + 1;
                *(_BYTE *)(v37 + v38) = v36;
                char v39 = *(_BYTE *)(result + 5921);
                uint64_t v40 = *(void *)(result + 16);
                uint64_t v41 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v41 + 1;
                *(_BYTE *)(v40 + v41) = v39;
                LODWORD(v40) = *(_DWORD *)(result + 5924);
                int v36 = v35 >> (16 - v40);
                int v42 = v34 + v40 - 16;
              }

              *(_DWORD *)(result + 5924) = v42;
              int v70 = v4 + 65534;
              int v71 = v70 << v42;
              if (v42 < 14)
              {
                *(_WORD *)(result + 5920) = v36 | v71;
                int v69 = v42 + 3;
              }

              else
              {
                __int16 v72 = v36 | v71;
                *(_WORD *)(result + 5920) = v72;
                uint64_t v73 = *(void *)(result + 16);
                uint64_t v74 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v74 + 1;
                *(_BYTE *)(v73 + v74) = v72;
                LOBYTE(v72) = *(_BYTE *)(result + 5921);
                uint64_t v75 = *(void *)(result + 16);
                uint64_t v76 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v76 + 1;
                *(_BYTE *)(v75 + v76) = v72;
                int v77 = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = (unsigned __int16)v70 >> (16 - v77);
                int v69 = v77 - 13;
              }
            }
          }

          *(_DWORD *)(result + 5924) = v69;
        }

        else
        {
          uint64_t v11 = result + 4LL * v5;
          int v12 = (unsigned __int16 *)(v11 + 2732);
          unsigned int v13 = (unsigned __int16 *)(v11 + 2734);
          int v14 = *(_DWORD *)(result + 5924);
          do
          {
            int v15 = *v13;
            unsigned int v16 = *v12;
            int v17 = *(unsigned __int16 *)(result + 5920);
            int v18 = v17 | (v16 << v14);
            *(_WORD *)(result + 5920) = v17 | ((_WORD)v16 << v14);
            if (v14 <= 16 - v15)
            {
              v14 += v15;
            }

            else
            {
              uint64_t v19 = *(void *)(result + 16);
              uint64_t v20 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v20 + 1;
              *(_BYTE *)(v19 + v20) = v18;
              LOBYTE(v19) = *(_BYTE *)(result + 5921);
              uint64_t v21 = *(void *)(result + 16);
              uint64_t v22 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v22 + 1;
              *(_BYTE *)(v21 + v22) = v19;
              LODWORD(v19) = *(_DWORD *)(result + 5924);
              *(_WORD *)(result + 5920) = v16 >> (16 - v19);
              int v14 = v15 + v19 - 16;
            }

            *(_DWORD *)(result + 5924) = v14;
            --v10;
          }

          while (v10);
        }

        if (v5 == v9) {
          int v86 = 3;
        }
        else {
          int v86 = 4;
        }
        if (v5 == v9) {
          int v87 = 6;
        }
        else {
          int v87 = 7;
        }
        if (v9) {
          int v7 = v86;
        }
        else {
          int v7 = 3;
        }
        if (v9) {
          int v6 = v87;
        }
        else {
          int v6 = 138;
        }
        int v10 = 0;
        int v8 = v5;
      }

      unsigned int v5 = v9;
      int v4 = v10;
    }

    while (v3 != a3 + 1);
  }

  return result;
}

uint64_t BrotliInitDistanceParams(uint64_t result, int a2, unsigned int a3)
{
  *(_DWORD *)(result + 64) = a2;
  *(_DWORD *)(result + 68) = a3;
  unsigned int v3 = a3 + 16;
  char v4 = a2 + 1;
  if (*(_DWORD *)(result + 36))
  {
    if (a3 <= 0x7FFFFFFB)
    {
      char v7 = -1;
      int v8 = -1 << a2;
      int v9 = -5;
      unsigned int v10 = ((2147483644 - a3) >> a2) + 4;
      do
      {
        ++v7;
        v9 += 2;
        BOOL v11 = v10 > 3;
        v10 >>= 1;
      }

      while (v11);
      unsigned int v12 = (((((2147483644 - a3) >> a2) + 4) >> v7) & 1) + v9;
      if (v12 == -1)
      {
        int v5 = a3 + 16;
      }

      else
      {
        unsigned int v13 = v12 >> 1;
        int v14 = (v12 & 1) << ((v12 >> 1) + 1);
        int v5 = a3 + ((v12 << a2) | ~v8) + 17;
        a3 = a3 - v8 + (((6 << v13) + v14 - 5) << a2);
      }
    }

    else
    {
      int v5 = -2147483636;
      a3 = 2147483644;
    }

    int v6 = v3 + (62 << v4);
  }

  else
  {
    int v5 = v3 + (24 << v4);
    a3 += (1 << (a2 + 26)) + (-1 << (a2 + 2));
    int v6 = v5;
  }

  *(_DWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 76) = v5;
  *(void *)(result + 80) = a3;
  return result;
}

void BrotliBuildMetaBlock( uint64_t a1, uint64_t a2, size_t a3, size_t a4, __int128 *a5, unsigned __int8 a6, unsigned __int8 a7, uint64_t a8, size_t a9, int a10, uint64_t *a11)
{
  unsigned int v11 = 0;
  int v12 = 0;
  __int128 v13 = a5[6];
  __int128 v14 = a5[4];
  __int128 v96 = a5[5];
  __int128 v97 = v13;
  __int128 v15 = a5[6];
  __int128 v16 = a5[8];
  __int128 v98 = a5[7];
  __int128 v99 = v16;
  __int128 v17 = a5[2];
  __int128 v18 = *a5;
  __int128 v92 = a5[1];
  __int128 v93 = v17;
  __int128 v19 = a5[2];
  __int128 v20 = a5[4];
  __int128 v94 = a5[3];
  __int128 v95 = v20;
  __int128 v21 = *a5;
  __int128 v88 = v15;
  __int128 v89 = v98;
  __int128 v90 = a5[8];
  __int128 v91 = v21;
  v85[2] = v19;
  v85[3] = v94;
  __int128 v86 = v14;
  __int128 v87 = v96;
  uint64_t v22 = a5 + 4;
  v85[0] = v18;
  v85[1] = v92;
  int v23 = 1;
  double v24 = 1.0e99;
  int v25 = v20;
  int v26 = DWORD1(v20);
  do
  {
    if (v11 <= 0xF)
    {
      while (1)
      {
        BrotliInitDistanceParams((uint64_t)v85, v12, v11 << v12);
        if (v11 << v12 == v26 && v12 == v25) {
          int v23 = 0;
        }
        double v28 = v84;
        if (v84 > v24) {
          break;
        }
        *uint64_t v22 = v86;
        *((void *)v22 + 2) = v87;
        ++v11;
        double v24 = v28;
        if (v11 == 16)
        {
          double v24 = v28;
          break;
        }
      }
    }

    unsigned int v29 = v11 - 1;
    if (!v11) {
      unsigned int v29 = 0;
    }
    unsigned int v11 = v29 >> 1;
    ++v12;
  }

  while (v12 != 4);
  if (v23)
  {
    ComputeDistanceCost(a8, a9, (int *)&v95, (int *)&v95, &v84);
    if (v84 < v24)
    {
      *uint64_t v22 = v95;
      *((void *)v22 + 2) = v96;
    }
  }

  if (v25 == *(_DWORD *)v22)
  {
    uint64_t v30 = a1;
    if (!a9 || v26 == *((_DWORD *)a5 + 17)) {
      goto LABEL_33;
    }
  }

  else
  {
    uint64_t v30 = a1;
    if (!a9) {
      goto LABEL_33;
    }
  }

  unsigned int v31 = v26 + 16;
  uint64_t v32 = a8 + 8;
  size_t v33 = a9;
  do
  {
    if ((*(_DWORD *)(v32 - 4) & 0x1FFFFFF) != 0 && *(unsigned __int16 *)(v32 + 4) >= 0x80u)
    {
      unsigned int v34 = *(unsigned __int16 *)(v32 + 6);
      unsigned int v35 = v34 & 0x3FF;
      if (v35 >= v31) {
        unsigned int v35 = ((v35 - v26 - 16) & ~(-1 << v25))
      }
            + v31
            + ((((((v35 - v26 - 16) >> v25) & 1 | 2) << (v34 >> 10)) + *(_DWORD *)v32 - 4) << v25);
      LOWORD(v36) = v35;
      uint64_t v37 = *((unsigned int *)a5 + 17);
      int v38 = v37 + 16;
      if (v37 + 16 <= (unint64_t)v35)
      {
        unint64_t v40 = v35 - v37 + (4LL << *(_DWORD *)v22) - 16;
        unsigned int v41 = (__clz(v40) ^ 0x1F) - 1;
        uint64_t v42 = ((v40 >> v41) & 1 | 2) << v41;
        int v36 = ((v40 & ~(-1 << *(_DWORD *)v22))
             + v38
             + ((((v40 >> v41) & 1 | (2 * (v41 - *(_DWORD *)v22))) + 65534) << *(_DWORD *)v22)) | ((v41 - *(_DWORD *)v22) << 10);
        unint64_t v39 = (v40 - v42) >> *(_DWORD *)v22;
      }

      else
      {
        LODWORD(v39) = 0;
      }

      *(_WORD *)(v32 + 6) = v36;
      *(_DWORD *)uint64_t v32 = v39;
    }

    v32 += 16LL;
    --v33;
  }

  while (v33);
LABEL_33:
  uint64_t v43 = (uint64_t)a11;
  unsigned int v44 = a11 + 12;
  BrotliSplitBlock(v30, a8, a9, a2, a3, a4, (int *)a5, (uint64_t)a11, (uint64_t)(a11 + 6), (uint64_t)(a11 + 12));
  if (*(_DWORD *)(v30 + 24)) {
    return;
  }
  uint64_t v45 = *a11;
  if (*((_DWORD *)a5 + 8))
  {
    unint64_t v46 = 0LL;
    uint64_t v47 = 1LL;
  }

  else
  {
    if (v45)
    {
      uint64_t v48 = BrotliAllocate(v30);
      if (*(_DWORD *)(v30 + 24)) {
        return;
      }
      unint64_t v46 = v48;
      uint64_t v45 = *a11;
      if (*a11)
      {
        unint64_t v49 = 0LL;
        uint64_t v47 = 64LL;
        do
        {
          *(_DWORD *)(v48 + 4 * v49++) = a10;
          uint64_t v45 = *a11;
        }

        while (v49 < *a11);
        goto LABEL_45;
      }
    }

    else
    {
      unint64_t v46 = 0LL;
    }

    uint64_t v47 = 64LL;
  }

uint64_t ComputeDistanceCost(uint64_t a1, uint64_t a2, int *a3, int *a4, double *a5)
{
  uint64_t v27 = 0x7FF0000000000000LL;
  int v10 = *a3;
  int v11 = *a4;
  BOOL v12 = *a3 != *a4 || a3[1] != a4[1];
  uint64_t v13 = 0LL;
  if (a2)
  {
    __int128 v14 = (unsigned __int16 *)(a1 + 14);
    double v15 = 0.0;
    while (1)
    {
      if ((*(_DWORD *)(v14 - 5) & 0x1FFFFFF) != 0 && *(v14 - 1) >= 0x80u)
      {
        unsigned int v16 = *v14;
        if (v12)
        {
          unsigned int v17 = v16 & 0x3FF;
          int v18 = a3[1];
          if (v17 >= v18 + 16) {
            unsigned int v17 = v18
          }
                + 16
                + ((v17 - v18 - 16) & ~(-1 << v10))
                + ((((((v17 - v18 - 16) >> v10) & 1 | 2) << (v16 >> 10)) + *(_DWORD *)(v14 - 3) - 4) << v10);
          uint64_t v19 = a4[1];
          int v20 = v19 + 16;
          if (v19 + 16 <= (unint64_t)v17)
          {
            unint64_t v21 = (4LL << v11) - 16 + v17 - v19;
            unsigned int v22 = __clz(v21);
            unsigned int v16 = ((v21 & ~(-1 << v11))
                 + v20
                 + ((((v21 >> ((v22 ^ 0x1F) - 1)) & 1 | (2 * ((v22 ^ 0x1F) - 1 - v11))) + 65534) << v11)) | (((v22 ^ 0x1F) - 1 - v11) << 10);
          }

          else
          {
            LOWORD(v16) = v17;
          }
        }

        ++v25[v16 & 0x3FF];
        ++v13;
        double v15 = v15 + (double)((unsigned __int16)v16 >> 10);
      }

      v14 += 8;
      if (!--a2) {
        goto LABEL_19;
      }
    }
  }

  double v15 = 0.0;
LABEL_19:
  uint64_t v26 = v13;
  BrotliPopulationCostDistance((uint64_t)v25);
  *a5 = v15 + v23;
  return 1LL;
}

void BrotliBuildMetaBlockGreedy( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, uint64_t a9, unsigned int *a10, unint64_t a11, uint64_t a12)
{
  unint64_t v16 = a11;
  if (a8 == 1)
  {
    unint64_t v17 = 0LL;
    if (a11)
    {
      unint64_t v18 = a11;
      uint64_t v19 = a10;
      do
      {
        unsigned int v20 = *v19;
        v19 += 4;
        v17 += v20;
        --v18;
      }

      while (v18);
    }

    InitBlockSplitterLiteral(a1, (uint64_t)v70, v17, a12, (void *)(a12 + 176), (uint64_t *)(a12 + 184));
    if (!*(_DWORD *)(a1 + 24))
    {
      InitBlockSplitterCommand(a1, (uint64_t)v69, a11, a12 + 48, (void *)(a12 + 192), (uint64_t *)(a12 + 200));
      if (!*(_DWORD *)(a1 + 24))
      {
        InitBlockSplitterDistance(a1, (uint64_t)v68, a11, a12 + 96, (void *)(a12 + 208), (uint64_t *)(a12 + 216));
        if (!*(_DWORD *)(a1 + 24))
        {
          if (a11)
          {
            for (uint64_t i = 0LL; i != a11; ++i)
            {
              unsigned int v22 = &a10[4 * i];
              uint64_t v24 = *v22;
              unsigned int v23 = v22[1];
              unsigned int v25 = *((unsigned __int16 *)v22 + 6);
              __int16 v26 = *((_WORD *)v22 + 7);
              BlockSplitterAddSymbolCommand(v69, *((unsigned __int16 *)v22 + 6));
              if ((_DWORD)v24)
              {
                do
                {
                  BlockSplitterAddSymbolLiteral(v70, *(unsigned __int8 *)(a2 + (a3++ & a4)));
                  --v24;
                }

                while (v24);
              }

              uint64_t v27 = v23 & 0x1FFFFFF;
              if ((_DWORD)v27)
              {
                if (v25 >= 0x80) {
                  BlockSplitterAddSymbolDistance(v68, v26 & 0x3FF);
                }
              }

              a3 += v27;
            }
          }

          BlockSplitterFinishBlockLiteral(v70, 1);
          BlockSplitterFinishBlockCommand();
          BlockSplitterFinishBlockDistance();
        }
      }
    }

    return;
  }

  unint64_t v29 = 0LL;
  if (a11)
  {
    uint64_t v30 = a10;
    do
    {
      unsigned int v31 = *v30;
      v30 += 4;
      v29 += v31;
      --v16;
    }

    while (v16);
  }

  unint64_t v32 = v29 >> 9;
  unint64_t v33 = (v29 >> 9) + 1;
  v70[0] = 256LL;
  v70[1] = a8;
  v70[2] = 0x100 / a8;
  v70[3] = 512LL;
  v70[4] = 0x4079000000000000LL;
  v70[5] = 0LL;
  v70[6] = a12;
  uint64_t v72 = a12 + 184;
  uint64_t v73 = 512LL;
  if (v33 >= 0x100 / a8 + 1) {
    uint64_t v34 = 0x100 / a8 + 1;
  }
  else {
    uint64_t v34 = (v29 >> 9) + 1;
  }
  uint64_t v66 = v34;
  uint64_t v78 = 0LL;
  uint64_t v74 = 0LL;
  uint64_t v75 = 0LL;
  unint64_t v35 = *(void *)(a12 + 32);
  if (v35 <= v29 >> 9)
  {
    if (v35) {
      uint64_t v36 = *(void *)(a12 + 32);
    }
    else {
      uint64_t v36 = (v29 >> 9) + 1;
    }
    do
    {
      unint64_t v37 = v36;
      v36 *= 2LL;
    }

    while (v37 <= v32);
    int v38 = (void *)BrotliAllocate(a1);
    unint64_t v39 = v38;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v40 = *(void *)(a12 + 32);
      if (v40) {
        memcpy(v38, *(const void **)(a12 + 16), v40);
      }
    }

    BrotliFree(a1, *(void *)(a12 + 16));
    *(void *)(a12 + 16) = v39;
    *(void *)(a12 + 32) = v37;
  }

  unint64_t v41 = *(void *)(a12 + 40);
  if (v41 <= v32)
  {
    if (!v41) {
      unint64_t v41 = v33;
    }
    do
    {
      unint64_t v42 = v41;
      v41 *= 2LL;
    }

    while (v42 <= v32);
    uint64_t v43 = (void *)BrotliAllocate(a1);
    unsigned int v44 = v43;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v45 = *(void *)(a12 + 40);
      if (v45) {
        memcpy(v43, *(const void **)(a12 + 24), 4 * v45);
      }
    }

    BrotliFree(a1, *(void *)(a12 + 24));
    *(void *)(a12 + 24) = v44;
    *(void *)(a12 + 40) = v42;
  }

  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(a12 + 8) = v33;
    *(void *)(a12 + 184) = v66 * a8;
    if (v66 * a8)
    {
      uint64_t v46 = BrotliAllocate(a1);
      int v47 = *(_DWORD *)(a1 + 24);
      *(void *)(a12 + 176) = v46;
      uint64_t v71 = v46;
      if (v47) {
        return;
      }
      uint64_t v48 = (void *)v46;
      if (!a8) {
        goto LABEL_45;
      }
    }

    else
    {
      uint64_t v48 = 0LL;
      *(void *)(a12 + 176) = 0LL;
      uint64_t v71 = 0LL;
      if (!a8)
      {
LABEL_45:
        uint64_t v76 = 0LL;
        uint64_t v77 = 0LL;
LABEL_50:
        InitBlockSplitterCommand(a1, (uint64_t)v69, a11, a12 + 48, (void *)(a12 + 192), (uint64_t *)(a12 + 200));
        if (!*(_DWORD *)(a1 + 24))
        {
          InitBlockSplitterDistance(a1, (uint64_t)v68, a11, a12 + 96, (void *)(a12 + 208), (uint64_t *)(a12 + 216));
          if (!*(_DWORD *)(a1 + 24))
          {
            unint64_t v51 = a10;
            if (a11)
            {
              uint64_t v52 = 0LL;
              uint64_t v53 = a5;
              uint64_t v54 = a6;
              while (1)
              {
                uint64_t v55 = &v51[4 * v52];
                uint64_t v57 = *v55;
                unsigned int v56 = v55[1];
                __int16 v61 = *((_WORD *)v55 + 7);
                uint64_t v63 = *((unsigned __int16 *)v55 + 6);
                uint64_t v65 = v52;
                BlockSplitterAddSymbolCommand(v69, v63);
                if ((_DWORD)v57) {
                  break;
                }
LABEL_59:
                a3 += v56 & 0x1FFFFFF;
                unint64_t v51 = a10;
                uint64_t v60 = v65;
                if ((v56 & 0x1FFFFFF) != 0)
                {
                  uint64_t v54 = *(unsigned __int8 *)(a2 + ((a3 - 2) & a4));
                  uint64_t v53 = *(unsigned __int8 *)(a2 + ((a3 - 1) & a4));
                  if (v63 >= 0x80)
                  {
                    BlockSplitterAddSymbolDistance(v68, v61 & 0x3FF);
                    uint64_t v60 = v65;
                  }
                }

                uint64_t v52 = v60 + 1;
                if (v52 == a11) {
                  goto LABEL_63;
                }
              }

              while (1)
              {
                char v58 = *(_BYTE *)(a7 + 256 + v54);
                uint64_t v54 = v53;
                uint64_t v53 = *(unsigned __int8 *)(a2 + (a3 & a4));
                uint64_t v59 = v71 + 1040 * (v75 + *(unsigned int *)(a9 + 4LL * (v58 | *(_BYTE *)(a7 + v54))));
                ++*(_DWORD *)(v59 + 4 * v53);
                ++*(void *)(v59 + 1024);
                if (++v74 == v73) {
                  ContextBlockSplitterFinishBlock(v70, a1, 0);
                }
                if (*(_DWORD *)(a1 + 24)) {
                  break;
                }
                ++a3;
                if (!--v57) {
                  goto LABEL_59;
                }
              }
            }

            else
            {
LABEL_63:
              ContextBlockSplitterFinishBlock(v70, a1, 1);
              if (!*(_DWORD *)(a1 + 24))
              {
                BlockSplitterFinishBlockCommand();
                BlockSplitterFinishBlockDistance();
                if (a8 >= 2) {
                  MapStaticContexts(a1, a8, a9, (uint64_t *)a12);
                }
              }
            }
          }
        }

        return;
      }
    }

    unint64_t v49 = a8;
    do
    {
      bzero(v48, 0x408uLL);
      v48[129] = 0x7FF0000000000000LL;
      v48 += 130;
      --v49;
    }

    while (v49);
    int v50 = *(_DWORD *)(a1 + 24);
    uint64_t v76 = 0LL;
    uint64_t v77 = 0LL;
    if (v50) {
      return;
    }
    goto LABEL_50;
  }

void BrotliOptimizeHistograms(unsigned int a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a2[23])
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = 0LL;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(256LL, (int *)(a2[22] + v4), v10);
      ++v5;
      v4 += 1040LL;
    }

    while (v5 < a2[23]);
  }

  if (a2[25])
  {
    uint64_t v6 = 0LL;
    unint64_t v7 = 0LL;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(704LL, (int *)(a2[24] + v6), v10);
      ++v7;
      v6 += 2832LL;
    }

    while (v7 < a2[25]);
  }

  if (a2[27])
  {
    uint64_t v8 = 0LL;
    unint64_t v9 = 0LL;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(a1, (int *)(a2[26] + v8), v10);
      ++v9;
      v8 += 2192LL;
    }

    while (v9 < a2[27]);
  }

void InitBlockSplitterLiteral( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 9;
  unint64_t v12 = (a3 >> 9) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257LL;
  }
  *(_OWORD *)a2 = xmmword_1810D3B40;
  *(void *)(a2 + 16) = 0x4079000000000000LL;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 512LL;
  *(void *)(a2 + 112) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 9)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 9) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2LL;
    }

    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }

  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2LL;
    }

    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }

  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8LL) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0x408uLL);
      v25[129] = 0x7FF0000000000000LL;
      *(void *)(a2 + 80) = 0LL;
      *(void *)(a2 + 88) = 0LL;
    }
  }

void InitBlockSplitterCommand( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 10;
  unint64_t v12 = (a3 >> 10) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257LL;
  }
  *(_OWORD *)a2 = xmmword_1810D3B50;
  *(void *)(a2 + 16) = 0x407F400000000000LL;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 1024LL;
  *(void *)(a2 + 112) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 10)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 10) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2LL;
    }

    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }

  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2LL;
    }

    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }

  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8LL) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0xB08uLL);
      v25[353] = 0x7FF0000000000000LL;
      *(void *)(a2 + 80) = 0LL;
      *(void *)(a2 + 88) = 0LL;
    }
  }

void InitBlockSplitterDistance( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 9;
  unint64_t v12 = (a3 >> 9) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257LL;
  }
  *(_OWORD *)a2 = xmmword_1810D3B60;
  *(void *)(a2 + 16) = 0x4059000000000000LL;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 512LL;
  *(void *)(a2 + 112) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 9)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 9) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2LL;
    }

    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }

  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2LL;
    }

    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }

    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }

  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8LL) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0x888uLL);
      v25[273] = 0x7FF0000000000000LL;
      *(void *)(a2 + 80) = 0LL;
      *(void *)(a2 + 88) = 0LL;
    }
  }

void BlockSplitterAddSymbolCommand(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 2832LL * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 2816);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1LL;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockCommand();
  }
}

void BlockSplitterAddSymbolLiteral(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 1040LL * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 1024);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1LL;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockLiteral(a1, 0);
  }
}

void BlockSplitterAddSymbolDistance(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 2192LL * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 2176);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1LL;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockDistance();
  }
}

void BlockSplitterFinishBlockLiteral(void *a1, int a2)
{
  int v2 = a2;
  uint64_t v3 = (double *)a1;
  uint64_t v93 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (void *)a1[4];
  unint64_t v5 = (unsigned int *)a1[5];
  unint64_t v6 = a1[1];
  if (a1[8] > v6) {
    unint64_t v6 = a1[8];
  }
  a1[8] = v6;
  if (!a1[3])
  {
    unint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    *(_DWORD *)v4[3] = v6;
    *(_BYTE *)v4[2] = 0;
    unint64_t v15 = (unint64_t)&v5[*a1];
    double v16 = 0.0;
    unint64_t v17 = v5;
    if ((*a1 & 1) != 0) {
      goto LABEL_13;
    }
    while (1)
    {
      if ((unint64_t)v17 >= v15)
      {
        double v26 = (double)v13;
        if (v13)
        {
          if (v13 > 0xFF) {
            double v27 = log2((double)v13);
          }
          else {
            double v27 = kBrotliLog2Table[v13];
          }
          double v16 = v16 + v26 * v27;
        }

        if (v16 >= v26) {
          double v28 = v16;
        }
        else {
          double v28 = (double)v13;
        }
        v3[12] = v28;
        v3[13] = v28;
        ++*((void *)v3 + 3);
        ++*v4;
        unint64_t v29 = *((void *)v3 + 9) + 1LL;
        *((void *)v3 + 9) = v29;
        if (v29 < **((void **)v3 + 6))
        {
          uint64_t v30 = &v5[260 * v29];
          bzero(v30, 0x408uLL);
          *((void *)v30 + 129) = 0x7FF0000000000000LL;
        }

        v3[8] = 0.0;
        goto LABEL_83;
      }

      unsigned int v19 = *v17++;
      uint64_t v18 = v19;
      unint64_t v14 = v13 + v19;
      double v20 = (double)v19;
      if (v19 > 0xFF) {
        double v21 = log2(v20);
      }
      else {
        double v21 = kBrotliLog2Table[v18];
      }
      double v16 = v16 - v20 * v21;
LABEL_13:
      unsigned int v23 = *v17++;
      uint64_t v22 = v23;
      unint64_t v13 = v14 + v23;
      double v24 = (double)v23;
      if (v23 > 0xFF) {
        double v25 = log2(v24);
      }
      else {
        double v25 = kBrotliLog2Table[v22];
      }
      double v16 = v16 - v24 * v25;
    }
  }

  if (!v6) {
    goto LABEL_83;
  }
  uint64_t v82 = a1[3];
  int v83 = v6;
  unint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  unint64_t v9 = &v5[260 * a1[9]];
  double v10 = *(double *)a1;
  unint64_t v11 = &v9[*a1];
  double v12 = 0.0;
  char __src = v9;
  __int128 v87 = a1 + 12;
  if ((*a1 & 1) == 0) {
    goto LABEL_28;
  }
  while (1)
  {
    unsigned int v36 = *v9++;
    uint64_t v35 = v36;
    unint64_t v7 = v8 + v36;
    double v37 = (double)v36;
    double v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    double v12 = v12 - v37 * v38;
LABEL_28:
    if (v9 >= v11) {
      break;
    }
    unsigned int v32 = *v9++;
    uint64_t v31 = v32;
    unint64_t v8 = v7 + v32;
    double v33 = (double)v32;
    if (v32 > 0xFF) {
      double v34 = log2(v33);
    }
    else {
      double v34 = kBrotliLog2Table[v31];
    }
    double v12 = v12 - v33 * v34;
  }

  double v39 = (double)v7;
  double v84 = v4;
  if (v7)
  {
    if (v7 > 0xFF) {
      double v40 = log2((double)v7);
    }
    else {
      double v40 = kBrotliLog2Table[v7];
    }
    double v12 = v12 + v39 * v40;
  }

  uint64_t v41 = 0LL;
  char v42 = 1;
  if (v12 < v39) {
    double v12 = (double)v7;
  }
  do
  {
    char v43 = v42;
    unsigned int v44 = v3;
    double v45 = v3[v41 + 10];
    uint64_t v46 = (char *)&v91[65 * v41];
    memcpy(v46, __src, 0x410uLL);
    uint64_t v47 = 0LL;
    uint64_t v48 = v5;
    unint64_t v49 = &v5[260 * *(void *)&v45];
    *((void *)v46 + 128) += *((void *)v49 + 128);
    do
    {
      *(_DWORD *)&v46[v47 * 4] += v49[v47];
      ++v47;
    }

    while (v47 != 256);
    unint64_t v50 = 0LL;
    unint64_t v51 = 0LL;
    uint64_t v52 = &v46[4 * *(void *)&v10];
    double v53 = 0.0;
    if ((LOBYTE(v10) & 1) != 0) {
      goto LABEL_56;
    }
    while (v46 < v52)
    {
      unsigned int v55 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v54 = v55;
      unint64_t v51 = v50 + v55;
      double v56 = (double)v55;
      if (v55 > 0xFF) {
        double v57 = log2(v56);
      }
      else {
        double v57 = kBrotliLog2Table[v54];
      }
      double v53 = v53 - v56 * v57;
LABEL_56:
      unsigned int v61 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v60 = v61;
      unint64_t v50 = v51 + v61;
      double v62 = (double)v61;
      if (v61 > 0xFF) {
        double v63 = log2(v62);
      }
      else {
        double v63 = kBrotliLog2Table[v60];
      }
      double v53 = v53 - v62 * v63;
    }

    double v58 = (double)v50;
    if (v50)
    {
      if (v50 > 0xFF) {
        double v59 = log2((double)v50);
      }
      else {
        double v59 = kBrotliLog2Table[v50];
      }
      unint64_t v5 = v48;
      double v53 = v53 + v58 * v59;
    }

    else
    {
      unint64_t v5 = v48;
    }

    uint64_t v3 = v44;
    char v42 = 0;
    if (v53 >= v58) {
      double v64 = v53;
    }
    else {
      double v64 = v58;
    }
    *(double *)&v90[v41] = v64;
    *(&v88 + v41) = v64 - v12 - *(double *)&v87[v41];
    uint64_t v41 = 1LL;
  }

  while ((v43 & 1) != 0);
  uint64_t v4 = v84;
  uint64_t v65 = *v84;
  if (*v84 >= 0x100uLL)
  {
    double v68 = v88;
    double v67 = v89;
    int v2 = a2;
  }

  else
  {
    double v66 = v44[2];
    double v68 = v88;
    double v67 = v89;
    BOOL v69 = v88 <= v66 || v89 <= v66;
    int v2 = a2;
    if (!v69)
    {
      *(_DWORD *)(v84[3] + 4 * v82) = v83;
      *(_BYTE *)(v84[2] + v82) = v65;
      v44[11] = v44[10];
      *((void *)v44 + 10) = *(unsigned __int8 *)v84;
      uint64_t v70 = *((void *)v44 + 12);
      v44[12] = v12;
      *((void *)v44 + 13) = v70;
      ++*((void *)v44 + 3);
      ++*v84;
      unint64_t v71 = *((void *)v44 + 9) + 1LL;
      *((void *)v44 + 9) = v71;
      if (v71 < **((void **)v44 + 6))
      {
        uint64_t v72 = &v5[260 * v71];
        bzero(v72, 0x408uLL);
        *((void *)v72 + 129) = 0x7FF0000000000000LL;
      }

      v44[14] = 0.0;
      uint64_t v73 = *((void *)v44 + 1);
      v44[8] = 0.0;
LABEL_82:
      *((void *)v44 + 7) = v73;
      goto LABEL_83;
    }
  }

  uint64_t v74 = v84[3];
  if (v67 < v68 + -20.0)
  {
    *(_DWORD *)(v74 + 4 * v82) = v83;
    *(_BYTE *)(v84[2] + v82) = *(_BYTE *)(v84[2] + v82 - 2);
    uint64_t v75 = *((void *)v44 + 10);
    uint64_t v76 = *((void *)v44 + 11);
    *((void *)v44 + 10) = v76;
    *((void *)v44 + 11) = v75;
    memcpy(&v5[260 * v76], v92, 0x410uLL);
    uint64_t v77 = *((void *)v44 + 12);
    v44[12] = *(double *)&v90[1];
    *((void *)v44 + 13) = v77;
    ++*((void *)v44 + 3);
    v44[8] = 0.0;
    uint64_t v78 = &v5[260 * *((void *)v44 + 9)];
    bzero(v78, 0x408uLL);
    *((void *)v78 + 129) = 0x7FF0000000000000LL;
    v44[14] = 0.0;
    uint64_t v73 = *((void *)v44 + 1);
    goto LABEL_82;
  }

  *(_DWORD *)(v74 + 4 * v82 - 4) += v83;
  memcpy(&v5[260 * *((void *)v44 + 10)], v91, 0x410uLL);
  uint64_t v79 = v90[0];
  v44[12] = *(double *)v90;
  if (*v84 == 1LL) {
    *((void *)v44 + 13) = v79;
  }
  v44[8] = 0.0;
  __int16 v80 = &v5[260 * *((void *)v44 + 9)];
  bzero(v80, 0x408uLL);
  *((void *)v80 + 129) = 0x7FF0000000000000LL;
  unint64_t v81 = *((void *)v44 + 14) + 1LL;
  *((void *)v44 + 14) = v81;
  if (v81 >= 2)
  {
    uint64_t v73 = *((void *)v44 + 7) + *((void *)v44 + 1);
    goto LABEL_82;
  }

LABEL_83:
  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }

  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }

  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }

void ContextBlockSplitterFinishBlock(void *a1, uint64_t a2, int a3)
{
  int v3 = a3;
  unint64_t v5 = a1;
  v116[13] = *MEMORY[0x1895F89C0];
  uint64_t v6 = a1[1];
  unint64_t v7 = (double *)(a1 + 14);
  unint64_t v8 = (void *)a1[6];
  unint64_t v9 = (unsigned int *)a1[7];
  unint64_t v10 = a1[10];
  unint64_t v11 = a1[3];
  if (v10 < v11)
  {
    a1[10] = v11;
    unint64_t v10 = v11;
  }

  uint64_t v112 = v6;
  if (!a1[5])
  {
    *(_DWORD *)v8[3] = v10;
    unint64_t v103 = v8;
    *(_BYTE *)v8[2] = 0;
    if (!v6)
    {
LABEL_29:
      ++v5[5];
      unint64_t v8 = v103;
      ++*v103;
      unint64_t v32 = v5[11] + v6;
      v5[11] = v32;
      if (v32 < *(void *)v5[8])
      {
        uint64_t v33 = v5[1];
        if (v33)
        {
          double v34 = (void *)(v5[7] + 1040 * v32);
          do
          {
            bzero(v34, 0x408uLL);
            v34[129] = 0x7FF0000000000000LL;
            v34 += 130;
            --v33;
          }

          while (v33);
        }
      }

      v5[10] = 0LL;
      int v3 = a3;
LABEL_34:
      if (!v3) {
        return;
      }
LABEL_35:
      *(void *)v5[8] = *v8 * v6;
      v8[1] = v5[5];
      return;
    }

    uint64_t v12 = *a1;
    uint64_t v13 = *a1;
    uint64_t v14 = v6;
    while (1)
    {
      unint64_t v15 = 0LL;
      unint64_t v16 = 0LL;
      unint64_t v17 = &v9[v13];
      double v18 = 0.0;
      unsigned int v19 = v9;
      if ((v12 & 1) != 0) {
        goto LABEL_18;
      }
      while (v9 < v17)
      {
        unsigned int v21 = *v9++;
        uint64_t v20 = v21;
        unint64_t v16 = v15 + v21;
        double v22 = (double)v21;
        if (v21 > 0xFF) {
          double v23 = log2(v22);
        }
        else {
          double v23 = kBrotliLog2Table[v20];
        }
        double v18 = v18 - v22 * v23;
LABEL_18:
        unsigned int v28 = *v9++;
        uint64_t v27 = v28;
        unint64_t v15 = v16 + v28;
        double v29 = (double)v28;
        if (v28 > 0xFF) {
          double v30 = log2(v29);
        }
        else {
          double v30 = kBrotliLog2Table[v27];
        }
        double v18 = v18 - v29 * v30;
      }

      double v24 = (double)v15;
      if (v15)
      {
        uint64_t v6 = v112;
        double v25 = v19;
        if (v15 > 0xFF) {
          double v26 = log2((double)v15);
        }
        else {
          double v26 = kBrotliLog2Table[v15];
        }
        double v18 = v18 + v24 * v26;
      }

      else
      {
        uint64_t v6 = v112;
        double v25 = v19;
      }

      if (v18 >= v24) {
        double v31 = v18;
      }
      else {
        double v31 = (double)v15;
      }
      *unint64_t v7 = v31;
      v7[v6] = v31;
      ++v7;
      unint64_t v9 = v25 + 260;
      if (!--v14) {
        goto LABEL_29;
      }
    }
  }

  if (!v10) {
    goto LABEL_34;
  }
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    char __src = (char *)BrotliAllocate(a2);
  }
  else {
    char __src = 0LL;
  }
  double v113 = 0.0;
  double v114 = 0.0;
  if (!*(_DWORD *)(a2 + 24))
  {
    uint64_t v100 = a2;
    int v108 = v9;
    int v102 = v3;
    unsigned int v104 = v8;
    if (v6)
    {
      uint64_t v35 = 0LL;
      uint64_t v105 = 1040 * v6;
      uint64_t v36 = *v5;
      int v110 = v9;
      unsigned int v111 = __src;
      do
      {
        unint64_t v37 = 0LL;
        unint64_t v38 = 0LL;
        double v39 = &v108[260 * v5[11] + 260 * v35];
        double v40 = &v39[v36];
        double v41 = 0.0;
        uint64_t v107 = v39;
        if ((v36 & 1) != 0) {
          goto LABEL_50;
        }
        while (v39 < v40)
        {
          unsigned int v43 = *v39++;
          uint64_t v42 = v43;
          unint64_t v38 = v37 + v43;
          double v44 = (double)v43;
          if (v43 > 0xFF) {
            double v45 = log2(v44);
          }
          else {
            double v45 = kBrotliLog2Table[v42];
          }
          double v41 = v41 - v44 * v45;
LABEL_50:
          unsigned int v49 = *v39++;
          uint64_t v48 = v49;
          unint64_t v37 = v38 + v49;
          double v50 = (double)v49;
          if (v49 > 0xFF) {
            double v51 = log2(v50);
          }
          else {
            double v51 = kBrotliLog2Table[v48];
          }
          double v41 = v41 - v50 * v51;
        }

        double v46 = (double)v37;
        if (v37)
        {
          if (v37 > 0xFF) {
            double v47 = log2((double)v37);
          }
          else {
            double v47 = kBrotliLog2Table[v37];
          }
          double v41 = v41 + v46 * v47;
        }

        uint64_t v52 = 0LL;
        if (v41 < v46) {
          double v41 = (double)v37;
        }
        uint64_t v109 = v35;
        *(double *)&v116[v35] = v41;
        char v53 = 1;
        do
        {
          uint64_t v54 = v7;
          char v55 = v53;
          uint64_t v56 = v109 + v52 * v6;
          double v57 = v5;
          uint64_t v58 = v5[v52 + 12];
          double v59 = &__src[1040 * v56];
          memcpy(v59, v107, 0x410uLL);
          uint64_t v60 = 0LL;
          *((void *)v59 + 128) += *(void *)&v108[260 * v58 + 256 + 260 * v109];
          do
          {
            *(_DWORD *)&v111[v105 * v52 + v60 * 4] += v110[260 * v58 + v60];
            ++v60;
          }

          while (v60 != 256);
          unint64_t v61 = 0LL;
          unint64_t v62 = 0LL;
          uint64_t v36 = *v57;
          double v63 = &v59[4 * *v57];
          double v64 = 0.0;
          if ((*v57 & 1) != 0) {
            goto LABEL_70;
          }
          while (v59 < v63)
          {
            unsigned int v66 = *(_DWORD *)v59;
            v59 += 4;
            uint64_t v65 = v66;
            unint64_t v62 = v61 + v66;
            double v67 = (double)v66;
            if (v66 > 0xFF) {
              double v68 = log2(v67);
            }
            else {
              double v68 = kBrotliLog2Table[v65];
            }
            double v64 = v64 - v67 * v68;
LABEL_70:
            unsigned int v72 = *(_DWORD *)v59;
            v59 += 4;
            uint64_t v71 = v72;
            unint64_t v61 = v62 + v72;
            double v73 = (double)v72;
            if (v72 > 0xFF) {
              double v74 = log2(v73);
            }
            else {
              double v74 = kBrotliLog2Table[v71];
            }
            double v64 = v64 - v73 * v74;
          }

          double v69 = (double)v61;
          if (v61)
          {
            unint64_t v7 = v54;
            if (v61 > 0xFF) {
              double v70 = log2((double)v61);
            }
            else {
              double v70 = kBrotliLog2Table[v61];
            }
            unint64_t v5 = v57;
            double v64 = v64 + v69 * v70;
            uint64_t v6 = v112;
          }

          else
          {
            unint64_t v5 = v57;
            uint64_t v6 = v112;
            unint64_t v7 = v54;
          }

          char v53 = 0;
          if (v64 >= v69) {
            double v75 = v64;
          }
          else {
            double v75 = v69;
          }
          v115[v56] = v75;
          *(&v113 + v52) = *(&v113 + v52) + v75 - v41 - v7[v56];
          uint64_t v52 = 1LL;
        }

        while ((v55 & 1) != 0);
        uint64_t v35 = v109 + 1;
        v110 += 260;
        v111 += 1040;
      }

      while (v109 + 1 != v6);
    }

    unint64_t v8 = v104;
    uint64_t v76 = *v104;
    if (*v104 >= v5[2])
    {
      double v79 = v113;
      double v78 = v114;
    }

    else
    {
      double v77 = *((double *)v5 + 4);
      double v79 = v113;
      double v78 = v114;
      if (v113 > v77 && v114 > v77)
      {
        uint64_t v80 = v5[5];
        *(_DWORD *)(v104[3] + 4 * v80) = v5[10];
        *(_BYTE *)(v104[2] + v80) = v76;
        v5[13] = v5[12];
        v5[12] = *v104 * v6;
        uint64_t v81 = v100;
        if (v6)
        {
          uint64_t v82 = v116;
          uint64_t v83 = v6;
          do
          {
            v7[v6] = *v7;
            uint64_t v84 = *v82++;
            *(void *)v7++ = v84;
            --v83;
          }

          while (v83);
        }

        ++v5[5];
        ++*v104;
        unint64_t v85 = v5[11] + v6;
        v5[11] = v85;
        if (v85 < *(void *)v5[8])
        {
          uint64_t v86 = v5[1];
          if (v86)
          {
            __int128 v87 = (void *)(v5[7] + 1040 * v85);
            do
            {
              bzero(v87, 0x408uLL);
              v87[129] = 0x7FF0000000000000LL;
              v87 += 130;
              --v86;
            }

            while (v86);
          }
        }

        v5[40] = 0LL;
        uint64_t v88 = v5[3];
        v5[10] = 0LL;
        goto LABEL_106;
      }
    }

    int v89 = *((_DWORD *)v5 + 20);
    uint64_t v90 = v104[3];
    uint64_t v91 = v5[5];
    if (v78 >= v79 + -20.0)
    {
      *(_DWORD *)(v90 + 4 * v91 - 4) += v89;
      if (v6)
      {
        uint64_t v95 = 0LL;
        __int128 v96 = __src;
        do
        {
          memcpy(&v108[260 * v95 + 260 * v5[12]], v96, 0x410uLL);
          double v97 = v115[v95];
          v7[v95] = v97;
          if (*v104 == 1LL) {
            *(double *)&v5[v6 + 14 + v95] = v97;
          }
          __int128 v98 = &v108[260 * v95 + 260 * v5[11]];
          bzero(v98, 0x408uLL);
          *((void *)v98 + 129) = 0x7FF0000000000000LL;
          ++v95;
          v96 += 1040;
        }

        while (v6 != v95);
      }

      v5[10] = 0LL;
      unint64_t v99 = v5[40] + 1LL;
      v5[40] = v99;
      unint64_t v8 = v104;
      uint64_t v81 = v100;
      if (v99 >= 2)
      {
        uint64_t v88 = v5[9] + v5[3];
LABEL_106:
        v5[9] = v88;
      }
    }

    else
    {
      *(_DWORD *)(v90 + 4 * v91) = v89;
      *(_BYTE *)(v104[2] + v91) = *(_BYTE *)(v104[2] + v91 - 2);
      *((int8x16_t *)v5 + 6) = vextq_s8(*((int8x16_t *)v5 + 6), *((int8x16_t *)v5 + 6), 8uLL);
      if (v6)
      {
        uint64_t v92 = 0LL;
        uint64_t v93 = &__src[1040 * v6];
        do
        {
          memcpy(&v108[260 * v92 + 260 * v5[12]], v93, 0x410uLL);
          v7[v6 + v92] = v7[v92];
          v7[v92] = v115[v6 + v92];
          __int128 v94 = &v108[260 * v92 + 260 * v5[11]];
          bzero(v94, 0x408uLL);
          *((void *)v94 + 129) = 0x7FF0000000000000LL;
          ++v92;
          v93 += 1040;
        }

        while (v6 != v92);
      }

      ++v5[5];
      v5[40] = 0LL;
      v5[9] = v5[3];
      v5[10] = 0LL;
      unint64_t v8 = v104;
      uint64_t v81 = v100;
    }

    BrotliFree(v81, (unint64_t)__src);
    if (!v102) {
      return;
    }
    goto LABEL_35;
  }