void _dyld_start( uint64_t a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9)
{
  start((dyld4::KernelArgs *)&a9, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t dyld4::restartWithDyldInCache(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4();
}

void start( dyld4::KernelArgs *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  v71 = a1;
  dyld3::kdebug_trace_dyld_marker((void *)0x1F070034, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, a8, 0LL, 0LL);
  v70 = &dword_180058000;
  if ((dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_180058000) & 1) == 0)
  {
    if ((dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)&dword_180058000) & 1) == 0) {
      goto LABEL_44;
    }
    __darwin_time_t Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)&dword_180058000);
    v81 = 0LL;
    v82 = &v81;
    uint64_t v83 = 0x3002000000LL;
    v84 = __Block_byref_object_copy_;
    v85 = __Block_byref_object_dispose_;
    Diagnostics::Diagnostics((Diagnostics *)&v86);
    *(void *)&v88.fsobj_id st_dev = _NSConcreteStackBlock;
    v88.st_ino = 0x40000000LL;
    *(void *)&v88.st_uid = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke;
    *(void *)&v88.st_rdev = &unk_18961EEB0;
    v88.st_atimespec.tv_sec = (__darwin_time_t)&v81;
    v88.st_atimespec.tv_nsec = (uint64_t)&dword_180058000;
    v88.st_mtimespec.tv_sec = Slide;
    dyld3::MachOAnalyzer::withChainStarts((char *)&dword_180058000, (vm_address_t *)v82 + 5, 0LL, (uint64_t)&v88);
    Diagnostics::assertNoError((Diagnostics *)(v82 + 5));
    v74 = (DyldSharedCache *)_NSConcreteStackBlock;
    uint64_t v75 = 0x40000000LL;
    v76 = ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    v77 = &__block_descriptor_tmp_4;
    v78 = (lsl::Lock **)Slide;
    dyld3::MachOFile::forEachSegment(&dword_180058000, (uint64_t)&v74);
    _Block_object_dispose(&v81, 8);
    mach_o::Error::~Error((vm_address_t **)&v86);
    a3 = 0LL;
    a2 = 0LL;
  }

  mach_init();
  Envp = (const char **)dyld4::KernelArgs::findEnvp(a1);
  Apple = (const char **)dyld4::KernelArgs::findApple(a1);
  v14 = _simple_getenv(Apple, "vm_force_4k_pages");
  if (v14 && *v14 == 49) {
    vm_page_size = 4096LL;
  }
  lsl::MemoryManager::MemoryManager((lsl::MemoryManager *)&v88, Envp, Apple, a3);
  lsl::MemoryManager::lockGuard((lsl::Lock *)&v88, &v81);
  uint64_t v15 = *(void *)&v88.st_rdev;
  if (!*(void *)&v88.st_rdev)
  {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)&v88, 0);
    uint64_t v15 = *(void *)&v88.st_rdev;
  }

  *(void *)&v88.st_rdev = v15 + 1;
  lsl::Lock::unlock(v81);
  __guard_setup(Apple);
  lsl::MemoryManager::lockGuard((lsl::Lock *)&v88, &v81);
  if (!--*(void *)&v88.st_rdev) {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)&v88, 1);
  }
  lsl::Lock::unlock(v81);
  _subsystem_init(Apple);
  if (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_180058000))
  {
    mach_port_mod_refs(mach_task_self_, mach_task_self_, 0, -1);
    char v17 = dyld4::ExternallyViewableState::switchToDyldInDyldCache( (dyld4::ExternallyViewableState *)&dword_180058000,  v16);
    if (kdebug_is_enabled(0x1F050014u, v18, v19, v20, v21, v22, v23, v24))
    {
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_180058000, (unsigned __int8 *)&v81);
      int v33 = dyld3::stat((dyld3 *)"/usr/lib/dyld", &v88, v32);
      if (v33) {
        st_ino = 0LL;
      }
      else {
        st_ino = (unsigned __int8 (*)[16])v88.st_ino;
      }
      if (v33) {
        fsobj_id st_dev = 0LL;
      }
      else {
        fsobj_id st_dev = (fsobj_id)v88.st_dev;
      }
      fsid v37 = (fsid)a2;
      dyld3::kdebug_trace_dyld_image( (dyld3 *)5,  "/usr/lib/dyld",  (void **)&v81,  st_ino,  st_dev,  v37,  (const void *)a2[2],  v34,  v68);
    }

    if (kdebug_is_enabled(0x1F050000u, v25, v26, v27, v28, v29, v30, v31))
    {
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_180058000, (unsigned __int8 *)&v88);
      fsobj_id v38 = 0LL;
      fsid v39 = (fsid)&dword_180058000;
      dyld3::kdebug_trace_dyld_image(0LL, "/usr/lib/dyld", (void **)&v88, 0LL, v38, v39, 0LL, v40, v68);
    }

    v81 = 0LL;
    v82 = &v81;
    uint64_t v83 = 0x4002000000LL;
    v84 = __Block_byref_object_copy__7;
    v85 = (void (*)(uint64_t))__Block_byref_object_dispose__8;
    v86 = &v88;
    __int128 v87 = xmmword_1800B7B10;
    uint64_t v41 = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
    v74 = (DyldSharedCache *)_NSConcreteStackBlock;
    uint64_t v75 = 0x40000000LL;
    v76 = ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke;
    v77 = &unk_18961EEF8;
    char v80 = v17;
    v78 = &v81;
    uint64_t v79 = v41;
    dyld3::MachOFile::forEachSegment(a2, (uint64_t)&v74);
    v42 = v82[7];
    if (v42)
    {
      v43 = v82[5];
      v44 = (lsl::Lock *)((char *)v43 + 16 * (void)v42);
      do
      {
        v45 = *(void **)v43;
        size_t v46 = *((void *)v43 + 1);
        v43 = (lsl::Lock *)((char *)v43 + 16);
        munmap(v45, v46);
      }

      while (v43 != v44);
    }

    _Block_object_dispose(&v81, 8);
  }

  else
  {
    v47 = (const char **)dyld4::KernelArgs::findEnvp(a1);
    if (!_simple_getenv(v47, "DYLD_SHARED_REGION")
      && dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_180058000, (unsigned __int8 *)&v88)
      && dyld4::SyscallDelegate::hasExistingDyldCache( (dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate,  (unint64_t *)&v74,  &v73,  &v72))
    {
      v48 = v74;
      uint64_t v49 = DyldSharedCache::slide(v74);
      uint64_t v50 = *((void *)v48 + 15);
      if (v50)
      {
        uint64_t v51 = v49;
        uint64_t v52 = v50 + v49;
        if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)(v50 + v49), (unsigned __int8 *)&v81)
          && *(lsl::Lock **)&v88.st_dev == v81
          && v88.st_ino == (void)v82)
        {
          v54 = (const char **)dyld4::KernelArgs::findEnvp(a1);
          v55 = _simple_getenv(v54, "DYLD_IN_CACHE");
          if (!v55 || _platform_strcmp(v55, "0"))
          {
            dyld4::ExternallyViewableState::switchDyldLoadAddress(v52);
            fsobj_id v56 = (fsobj_id)v73;
            dyld3::kdebug_trace_dyld_cache((unsigned __int8 (*)[16])v72, v56, v74, (char *)v48 + 88, v57, v58, v59, v60);
            dyld4::restartWithDyldInCache( (uint64_t)a1,  (uint64_t)&dword_180058000,  (uint64_t)v48,  (uint64_t (*)(void))(*((void *)v48 + 16) + v51));
          }
        }
      }
    }
  }

  dyld4::RuntimeLocks::RuntimeLocks((dyld4::RuntimeLocks *)&v88);
  v61 = (const char **)dyld4::KernelArgs::findEnvp(a1);
  v62 = (const char **)dyld4::KernelArgs::findApple(a1);
  lsl::PreallocatedAllocatorLayout<278528ull>::init((lsl::AllocatorLayout *)&dyld4::preallocator, v61, v62, a3);
  v63 = (lsl::Allocator::Pool *)lsl::AllocatorLayout::allocator((lsl::AllocatorLayout *)&dyld4::preallocator);
  unint64_t v73 = 0LL;
  v74 = 0LL;
  v64 = (lsl::Lock *)lsl::Allocator::Pool::allocator(v63);
  v69[0] = v63;
  v69[1] = &v71;
  v69[2] = &v74;
  v69[3] = &v88;
  v69[4] = &v70;
  v69[5] = &v73;
  lsl::MemoryManager::lockGuard(v64, &v81);
  uint64_t v65 = *((void *)v64 + 3);
  if (!v65)
  {
    lsl::MemoryManager::writeProtect(v64, 0);
    uint64_t v65 = *((void *)v64 + 3);
  }

  *((void *)v64 + 3) = v65 + 1;
  lsl::Lock::unlock(v81);
  dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()((uint64_t)v69);
  lsl::MemoryManager::lockGuard(v64, &v81);
  uint64_t v66 = *((void *)v64 + 3) - 1LL;
  *((void *)v64 + 3) = v66;
  if (!v66) {
    lsl::MemoryManager::writeProtect(v64, 1);
  }
  lsl::Lock::Guard::~Guard(&v81);
  uint64_t v67 = ((uint64_t (*)(void, void, void, void))v73)( *(unsigned int *)(*((void *)v74 + 1) + 104LL),  *(void *)(*((void *)v74 + 1) + 112LL),  *(void *)(*((void *)v74 + 1) + 120LL),  *(void *)(*((void *)v74 + 1) + 128LL));
  (*(void (**)(void, uint64_t))(**((void **)v74 + 19) + 120LL))(*((void *)v74 + 19), v67);
LABEL_44:
  __assert_rtn("rebaseSelf", "dyldMain.cpp", 1116, "dyldMA->hasChainedFixups()");
}

os_unfair_lock_s *lsl::PreallocatedAllocatorLayout<278528ull>::init( lsl::AllocatorLayout *a1, const char **a2, const char **a3, void *a4)
{
  uint64_t v8 = v11;
  if (!v11)
  {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 0);
    uint64_t v8 = v11;
  }

  uint64_t v11 = v8 + 1;
  lsl::Lock::unlock(v12);
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  lsl::AllocatorLayout::init(a1, 0x44000uLL, a2, a3, a4);
  lsl::MemoryManager::lockGuard((lsl::Lock *)v10, &v12);
  if (!--v11) {
    lsl::MemoryManager::writeProtect((lsl::MemoryManager *)v10, 1);
  }
  return lsl::Lock::unlock(v12);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke(void *a1, unsigned int *a2)
{
  uint64_t v3 = a1[5];
  v4 = (vm_address_t *)(*(void *)(a1[4] + 8LL) + 40LL);
  uint64_t v5 = a1[6];
  uint64_t v8 = 0LL;
  __int128 v7 = 0uLL;
  return dyld3::MachOLoaded::fixupAllChainedFixups(v3, v4, a2, v5, &v7, 0LL);
}

uint64_t ___ZN5dyld4L10rebaseSelfEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0) {
    return dyld4::SyscallDelegate::mprotect( (dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate,  (void *)(*(void *)(result + 32) + *(void *)(a2 + 16)),  *(void *)(a2 + 24),  1);
  }
  return result;
}

void lsl::Lock::Guard::~Guard(lsl::Lock **this)
{
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke( uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(_BYTE *)(result + 48) || (__n128 result = _platform_strcmp(*(const char **)(a2 + 40), "__DATA_DIRTY"), (_DWORD)result))
  {
    v4 = *(void **)(*(void *)(v3 + 32) + 8LL);
    unint64_t v5 = v4[7];
    if (v5 >= v4[6]) {
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    }
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(v3 + 40) + *(void *)(a2 + 16);
    uint64_t v8 = v4[5];
    v4[7] = v5 + 1;
    v9 = (void *)(v8 + 16 * v5);
    void *v9 = v7;
    v9[1] = v6;
  }

  return result;
}

void dyld4::start(dyld4::KernelArgs *,void *,void *)::$_0::operator()(uint64_t a1)
{
  v2 = (lsl::AllocatorLayout *)lsl::Allocator::setBestFit(*(void *)a1, 1);
  uint64_t v3 = lsl::AllocatorLayout::minSize(v2);
  __chkstk_darwin(v3, v4, v5, v6, v7, v8, v9, v10, v30);
  v12 = (lsl::Allocator *)((char *)&v30 - v11);
  uint64_t v14 = lsl::AllocatorLayout::minSize(v13);
  char v17 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal(v12, (char *)(v14 + 0x10000), v15, v16);
  uint64_t v18 = (dyld4::ProcessConfig *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x220uLL);
  dyld4::ProcessConfig::ProcessConfig( v18,  **(const dyld4::KernelArgs ***)(a1 + 8),  (dyld4::SyscallDelegate *)&dyld4::sSyscallDelegate,  *(lsl::Allocator **)a1);
  v19 = (dyld4::RuntimeState *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x478uLL);
  v20 = dyld4::RuntimeState::RuntimeState(v19, v18, *(dyld4::RuntimeLocks **)(a1 + 24), *(lsl::Allocator **)a1);
  *(void *)v20 = &off_1896208A8;
  **(void **)(a1 + 16) = v20;
  uint64_t v21 = lsl::Allocator::Pool::allocator(*(lsl::Allocator::Pool **)a1);
  lsl::MemoryManager::setDyldCacheAddr(v21, *(void **)(*(void *)(**(void **)(a1 + 16) + 8LL) + 240LL));
  dyld4::ExternallyViewableState::init( (uint64_t *)(**(void **)(a1 + 16) + 536LL),  *(lsl::Lock ***)(**(void **)(a1 + 16) + 16LL),  v17,  (dyld4::FileManager *)(**(void **)(a1 + 16) + 512LL),  *(_DWORD *)(*(void *)(**(void **)(a1 + 16) + 8LL) + 68LL));
  uint64_t v22 = **(void **)(a1 + 16);
  uint64_t v23 = **(void **)(a1 + 32);
  uint64_t v24 = *(void *)(v22 + 8);
  uint64_t v25 = *(void *)(v24 + 240);
  if (v25)
  {
    uint64_t v26 = *(void *)(v24 + 264);
    __int128 v30 = *(_OWORD *)(v24 + 248);
    v31.i64[0] = *(void *)(v24 + 280);
    v31.i64[1] = v25;
    char v32 = 0;
    dyld4::ExternallyViewableState::setSharedCacheInfo( v22 + 536,  v17,  v26,  (uint64_t)&v30,  *(unsigned __int8 *)(v24 + 398));
    uint64_t v24 = *(void *)(v22 + 8);
  }

  __int128 v30 = *(_OWORD *)(v24 + 80);
  v31.i64[0] = *(void *)(v24 + 72);
  v31.i64[1] = v23;
  char v32 = 0;
  dyld4::ExternallyViewableState::setDyld(v22 + 536, v17, (uint64_t)&v30);
  uint64_t v27 = *(void *)(v22 + 8);
  __int128 v30 = *(_OWORD *)(v27 + 32);
  int8x16_t v31 = vextq_s8(*(int8x16_t *)(v27 + 8), *(int8x16_t *)(v27 + 8), 8uLL);
  char v32 = 0;
  dyld4::ExternallyViewableState::addImageInfo(v22 + 536, v17, (uint64_t)&v30);
  *(_DWORD *)(v22 + 1012) = 1;
  dyld4::ExternallyViewableState::setInitialImageCount((dyld4::ExternallyViewableState *)(v22 + 536), 1u);
  if ((dyld3::MachOFile::isSimulatorPlatform(*(_DWORD *)(*(void *)(v22 + 8) + 68LL), 0LL) & 1) == 0) {
    dyld4::ExternallyViewableState::commit( (os_unfair_lock_s *)(v22 + 536),  *(lsl::Lock ***)(v22 + 16),  (lsl::Allocator *)v17,  v29);
  }
  **(void **)(a1 + 40) = dyld4::prepare(**(dyld4 ***)(a1 + 16), **(vm_address_t ***)(a1 + 32), v28);
  lsl::Allocator::~Allocator((lsl::Allocator *)v17);
}

void (*dyld4::prepare( dyld4 *this, vm_address_t *a2, const dyld3::MachOAnalyzer *a3))(dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
  v216 = a2;
  if (dyld3::kdebug_trace_dyld_enabled((dyld3 *)0x1F070004, a2)) {
    v215 = dyld3::kdebug_trace_dyld_duration_start( (void *)0x1F070004,  *(void *)(*((void *)this + 1) + 8LL),  0LL,  0LL,  0LL,  0LL,  0LL,  v4);
  }
  else {
    v215 = 0LL;
  }
  uint64_t v5 = *((void *)this + 1);
  if (*(_BYTE *)(v5 + 208))
  {
    if (!*(_BYTE *)(v5 + 185))
    {
      dyld4::RuntimeState::log(this, "Note: DYLD_PRINT_* disabled by AMFI\n");
      uint64_t v5 = *((void *)this + 1);
    }

    if (!*(_BYTE *)(v5 + 190))
    {
      dyld4::RuntimeState::log(this, "Note: interposing disabled by AMFI\n");
      uint64_t v5 = *((void *)this + 1);
    }
  }

  if (*(_BYTE *)(v5 + 209))
  {
    uint64_t v6 = *(const char ***)(v5 + 120);
    uint64_t v7 = *v6;
    if (*v6)
    {
      uint64_t v8 = v6 + 1;
      do
      {
        dyld4::RuntimeState::log(this, "%s\n", v7);
        uint64_t v9 = *v8++;
        uint64_t v7 = v9;
      }

      while (v9);
    }
  }

  dyld4::RuntimeState::initializeClosureMode(this);
  uint64_t v10 = *((void *)this + 123);
  if (v10)
  {
    if (!*(_DWORD *)(v10 + 12)) {
      __assert_rtn("atIndex", "PrebuiltLoader.h", 336, "loaderIndex < loadersArrayCount");
    }
    LaunchLoader = (const dyld4::Loader *)(v10 + *(unsigned int *)(v10 + *(unsigned int *)(v10 + 16)));
    lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 32, *((unsigned int *)this + 253));
  }

  else
  {
    if (*((void *)this + 7) <= 0x1FFuLL) {
      lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)this + 32, 0x200uLL);
    }
    Diagnostics::Diagnostics((Diagnostics *)&v221);
    LaunchLoader = (const dyld4::Loader *)dyld4::JustInTimeLoader::makeLaunchLoader( (dyld4::JustInTimeLoader *)&v221,  this,  *(dyld4::RuntimeState **)(*((void *)this + 1) + 8LL),  *(const dyld3::MachOAnalyzer **)(*((void *)this + 1) + 16LL),  0LL,  v12);
    if (Diagnostics::hasError((Diagnostics *)&v221))
    {
      v213 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v221);
      dyld4::RuntimeState::log(this, "%s in %s\n", v213, *(const char **)(*((void *)this + 1) + 16LL));
      v208 = (vm_address_t **)&v221;
      goto LABEL_139;
    }

    mach_o::Error::~Error((vm_address_t **)&v221);
  }

  dyld4::RuntimeState::setMainLoader(this, LaunchLoader);
  dyld4::RuntimeState::notifyDebuggerLoad(this, LaunchLoader);
  if ((*((_WORD *)LaunchLoader + 2) & 1) != 0)
  {
    BOOL v13 = 0;
  }

  else if (*((_BYTE *)this + 1008))
  {
    BOOL v13 = 1;
  }

  else
  {
    BOOL v13 = *((_BYTE *)this + 1009) != 0;
  }

  uint64_t v247 = 0LL;
  v248 = &v247;
  uint64_t v249 = 0x5002000000LL;
  v250 = __Block_byref_object_copy__20;
  v251 = __Block_byref_object_dispose__21;
  v252[0] = &v258;
  v252[1] = 16LL;
  vm_size_t v255 = 0LL;
  uint64_t v253 = 0LL;
  vm_address_t v254 = 0LL;
  dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v252, 1LL);
  uint64_t v14 = v253++;
  *(void *)(v252[0] + 8 * v14) = LaunchLoader;
  v246[0] = 0LL;
  v246[1] = LaunchLoader;
  uint64_t v244 = 0LL;
  uint64_t v245 = 0LL;
  uint64_t v15 = *((void *)this + 1) + 400LL;
  v238[0] = _NSConcreteStackBlock;
  v238[1] = 0x40000000LL;
  v238[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v238[3] = &unk_18961EF20;
  __int16 v239 = 257;
  int v240 = 0;
  __int16 v241 = 257;
  uint64_t v242 = 0LL;
  v243 = v246;
  v238[4] = &v247;
  v238[5] = this;
  dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(v15, (uint64_t)v238);
  if (v248[7] != 1)
  {
    uint64_t v16 = *((void *)this + 6);
    if (v16 == 1)
    {
      unint64_t v17 = 1LL;
    }

    else
    {
      memmove(*((void **)this + 5), (const void *)(*((void *)this + 5) + 8LL), 8 * v16 - 8);
      unint64_t v17 = *((void *)this + 6);
    }

    *((void *)this + 6) = v17 - 1;
    lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 32, v17);
    uint64_t v18 = *((void *)this + 5);
    uint64_t v19 = *((void *)this + 6);
    *((void *)this + 6) = v19 + 1;
    *(void *)(v18 + 8 * v19) = LaunchLoader;
  }

  uint64_t v232 = 0LL;
  v233 = &v232;
  uint64_t v234 = 0x4002000000LL;
  v235 = __Block_byref_object_copy__26;
  v236 = __Block_byref_object_dispose__27;
  memset(v237, 0, sizeof(v237));
  v231[0] = _NSConcreteStackBlock;
  v231[1] = 0x40000000LL;
  v231[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_28;
  v231[3] = &unk_18961EF48;
  v231[4] = &v232;
  Diagnostics::Diagnostics((Diagnostics *)&v230);
  DWORD2(v226) = 0;
  uint64_t v228 = 0LL;
  v229 = 0LL;
  *(void *)&__int128 v226 = 0x100000000000101LL;
  v227 = v246;
  if (v13) {
    v229 = v231;
  }
  uint64_t v28 = v248[7];
  if (v28)
  {
    v29 = (uint64_t *)v248[5];
    uint64_t v30 = 8 * v28;
    while (1)
    {
      dyld4::Loader::loadDependents(*v29, (vm_address_t *)&v230, this, &v226);
      BOOL hasError = Diagnostics::hasError((Diagnostics *)&v230);
      if (hasError) {
        break;
      }
      ++v29;
      v30 -= 8LL;
      if (!v30)
      {
        uint64_t v31 = v248[7];
        goto LABEL_38;
      }
    }

    uint64_t v191 = v248[7];
    uint64_t v192 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)hasError);
    __chkstk_darwin(v192, v193, v194, v195, v196, v197, v198, v199, (uint64_t)v214);
    v201 = (lsl::Allocator *)((char *)&v214 - v200);
    uint64_t v202 = *((void *)this + 6);
    uint64_t v204 = lsl::AllocatorLayout::minSize(v203);
    *(void *)&v221.fsobj_id st_dev = lsl::Allocator::stackAllocatorInternal( v201,  (char *)(v204 - v191 + 8 * v202 + 64),  v205,  v206);
    memset(&v221.st_ino, 0, 24);
    lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v221, *((void *)this + 6) - v191);
    if (v191 == *((void *)this + 6))
    {
      unint64_t v207 = *(void *)&v221.st_uid;
    }

    else
    {
      unint64_t v207 = *(void *)&v221.st_uid;
      do
      {
        uint64_t v209 = *((void *)this + 5);
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v221, v207 + 1);
        uint64_t v210 = *(void *)(v209 + 8 * v191);
        uint64_t v211 = *(void *)&v221.st_uid;
        unint64_t v207 = ++*(void *)&v221.st_uid;
        *(void *)(v221.st_ino + 8 * v211) = v210;
        ++v191;
      }

      while (v191 != *((void *)this + 6));
    }

    __darwin_ino64_t st_ino = v221.st_ino;
    unint64_t v224 = v207;
    dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&st_ino);
    dyld4::ExternallyViewableState::disableCrashReportBacktrace((uint64_t)this + 536);
    v208 = &v230;
LABEL_139:
    v212 = (char *)Diagnostics::errorMessage((Diagnostics *)v208);
    dyld4::halt(v212, (uint64_t *)this + 77);
  }

  uint64_t v31 = 0LL;
LABEL_38:
  __chkstk_darwin(hasError, v21, v22, v23, v24, v25, v26, v27, (uint64_t)v214);
  uint64_t v34 = (char *)&v214 - ((v33 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v35 = *((void *)this + 6);
  __darwin_ino64_t st_ino = (__darwin_ino64_t)v34;
  unint64_t v224 = v35;
  unint64_t v225 = 0LL;
  if (v35)
  {
    unint64_t v36 = 0LL;
    fsid v37 = (uint64_t *)*((void *)this + 5);
    uint64_t v38 = 8 * v35;
    do
    {
      uint64_t v39 = *v37;
      if ((*(_WORD *)(*v37 + 4) & 2) == 0)
      {
        if (v36 >= v35) {
LABEL_131:
        }
          __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
        unint64_t v225 = v36 + 1;
        *(void *)(st_ino + 8 * v36++) = v39;
      }

      ++v37;
      v38 -= 8LL;
    }

    while (v38);
  }

  BOOL v218 = v13;
  uint64_t v217 = v32;
  dyld4::RuntimeState::addPermanentRanges((uint64_t)this, (uint64_t)&st_ino);
  if (*(_BYTE *)(*((void *)this + 1) + 161LL))
  {
    uint64_t v40 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x60uLL);
    uint64_t v41 = (lsl::AllocatorLayout *)dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v40);
    *((void *)this + 42) = v41;
    uint64_t v42 = lsl::AllocatorLayout::minSize(v41);
    __chkstk_darwin(v42, v43, v44, v45, v46, v47, v48, v49, (uint64_t)v214);
    uint64_t v51 = (lsl::Allocator *)((char *)&v214 - v50);
    uint64_t v52 = *((void *)this + 6);
    uint64_t v54 = lsl::AllocatorLayout::minSize(v53);
    v57 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v51, (char *)(v54 + 8 * v52 + 64), v55, v56);
    *(void *)&v221.fsobj_id st_dev = v57;
    memset(&v221.st_ino, 0, 24);
    lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v221, *((void *)this + 6));
    uint64_t v58 = *((void *)this + 6);
    uint64_t v59 = *(void *)&v221.st_uid;
    if (v58)
    {
      v60 = (uint64_t *)*((void *)this + 5);
      uint64_t v61 = 8 * v58;
      do
      {
        uint64_t v62 = *v60++;
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v221, v59 + 1);
        uint64_t v63 = *(void *)&v221.st_uid;
        uint64_t v59 = ++*(void *)&v221.st_uid;
        *(void *)(v221.st_ino + 8 * v63) = v62;
        v61 -= 8LL;
      }

      while (v61);
    }

    __darwin_ino64_t v256 = v221.st_ino;
    uint64_t v257 = v59;
    dyld4::Loader::addWeakDefsToMap(this, (uint64_t)&v256);
    if (v221.st_ino) {
      lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v221, 0LL);
    }
    lsl::Allocator::~Allocator(v57);
  }

  dyld4::RuntimeState::buildInterposingTables(this);
  v221.fsobj_id st_dev = 520552460;
  memset(&v221.st_ino, 0, 104);
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v221, v64, v65, v66, v67, v68, v69, v70);
  dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v256, this);
  dyld4::JustInTimeLoader::handleStrongWeakDefOverrides((uint64_t)this, (dyld4::RuntimeState *)&v256, v71);
  uint64_t v72 = *((void *)this + 6);
  if (v72)
  {
    unint64_t v73 = (dyld4::Loader **)*((void *)this + 5);
    uint64_t v74 = 8 * v72;
    while (1)
    {
      uint64_t v75 = *v73;
      Diagnostics::Diagnostics((Diagnostics *)v219);
      dyld4::Loader::applyFixups( (uint64_t)v75,  (Diagnostics *)v219,  (uint64_t)this,  (dyld4::DyldCacheDataConstLazyScopedWriter *)&v256,  1,  0LL);
      if (Diagnostics::hasError((Diagnostics *)v219)) {
        break;
      }
      dyld4::Loader::applyCachePatches(v75, this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v256);
      mach_o::Error::~Error(v219);
      ++v73;
      v74 -= 8LL;
      if (!v74) {
        goto LABEL_55;
      }
    }

    v208 = v219;
    goto LABEL_139;
  }

LABEL_55:
  dyld4::RuntimeState::doSingletonPatching(this, (dyld4::DyldCacheDataConstLazyScopedWriter *)&v256);
  dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v256);
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v221);
  if (*((void *)this + 22)) {
    dyld4::Loader::applyInterposingToDyldCache(this, v76);
  }
  if ((*((_WORD *)LaunchLoader + 2) & 1) != 0)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter((uint64_t)&v221, this);
    uint64_t v83 = *((void *)this + 123);
    v222[0] = _NSConcreteStackBlock;
    v222[1] = 0x40000000LL;
    v222[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
    v222[3] = &__block_descriptor_tmp_35;
    v222[4] = this;
    v222[5] = &v221;
    dyld4::PrebuiltLoaderSet::forEachCachePatch(v83, (uint64_t)v222);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)&v221);
  }

  if (kdebug_is_enabled(0x1F050000u, (uint64_t)v76, v77, v78, v79, v80, v81, v82)
    && (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)v216) & 1) == 0)
  {
    v84 = v216;
    dyld3::MachOFile::getUuid((dyld3::MachOFile *)v216, (unsigned __int8 *)&v256);
    int v86 = dyld3::stat(*(dyld3 **)(*((void *)this + 1) + 72LL), &v221, v85);
    if (v86) {
      stat v88 = 0LL;
    }
    else {
      stat v88 = (unsigned __int8 (*)[16])v221.st_ino;
    }
    if (v86) {
      fsobj_id st_dev = 0LL;
    }
    else {
      fsobj_id st_dev = (fsobj_id)v221.st_dev;
    }
    fsid v90 = (fsid)v84;
    dyld3::kdebug_trace_dyld_image( 0LL,  *(void **)(*((void *)this + 1) + 72LL),  (void **)&v256,  v88,  st_dev,  v90,  (const void *)*((unsigned int *)v84 + 2),  v87,  v214);
  }

  v91 = (dyld4::Loader *)*((void *)this + 13);
  if (!v91)
  {
    v190 = "libdyld.dylib not found";
    goto LABEL_143;
  }

  Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v91, this);
  uint64_t SectionContent = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v220);
  if (!SectionContent)
  {
    v190 = "compatible libdyld.dylib not found";
    goto LABEL_143;
  }

  uint64_t v94 = SectionContent;
  *(void *)uint64_t SectionContent = this;
  uint64_t v95 = dyld4::ExternallyViewableState::storeProcessInfoPointer( (uint64_t)this + 536,  (dyld_all_image_infos **)(SectionContent + 8));
  uint64_t v103 = *((void *)this + 1);
  *(void *)(v94 + 16) = *(void *)(v103 + 8);
  v94 += 16LL;
  *((void *)this + 18) = v94;
  **(void **)(v94 + 32) = *(void *)(v103 + 136);
  uint64_t v104 = *((void *)this + 1);
  uint64_t v105 = *((void *)this + 18);
  **(_DWORD **)(v105 + 8) = *(_DWORD *)(v104 + 104);
  **(void **)(v105 + 16) = *(void *)(v104 + 112);
  **(void **)(*((void *)this + 18) + 24LL) = *(void *)(*((void *)this + 1) + 120LL);
  if (!*((void *)this + 12))
  {
    v190 = "program does not link with libSystem.B.dylib";
    goto LABEL_143;
  }

  __chkstk_darwin(v95, v96, v97, v98, v99, v100, v101, v102, (uint64_t)v214);
  v108 = (dyld4::Loader **)((char *)&v214 - ((v107 + 23) & 0xFFFFFFFFFFFFFFF0LL));
  if (!v106) {
    __assert_rtn("operator[]", "Array.h", 56, "idx < _usedCount");
  }
  uint64_t v109 = 0LL;
  uint64_t v110 = *((void *)this + 5);
  do
  {
    if (v106 == v109) {
      goto LABEL_131;
    }
    uint64_t v111 = v109 + 1;
    v108[v109] = *(dyld4::Loader **)(v110 + 8 * v109);
    ++v109;
    v107 -= 8LL;
  }

  while (v107);
  v216 = (vm_address_t *)v237;
  if (v31 == -1) {
    uint64_t v112 = v111;
  }
  else {
    uint64_t v112 = v31;
  }
  dyld4::RuntimeState::partitionDelayLoads((uint64_t)this, v108, v111, v108, v112, 0LL);
  if (*(void *)(*((void *)this + 1) + 232LL)) {
    BOOL v120 = v112 == 0;
  }
  else {
    BOOL v120 = 1;
  }
  if (!v120)
  {
    uint64_t v121 = 8 * v112;
    do
    {
      v123 = *v108++;
      v122 = v123;
      v124 = (dyld3::MachOFile *)dyld4::Loader::mf(v123, this);
      if (dyld3::MachOFile::isMainExecutable(v124)) {
        v125 = "main";
      }
      else {
        v125 = "insert";
      }
      dyld4::Loader::logChainToLinksWith(v122, this, v125);
      v121 -= 8LL;
    }

    while (v121);
  }

  uint64_t is_enabled = kdebug_is_enabled(0x1F050000u, v113, v114, v115, v116, v117, v118, v119);
  if ((_DWORD)is_enabled)
  {
    uint64_t v134 = *((void *)this + 6);
    if (v134)
    {
      v135 = (dyld4::Loader **)*((void *)this + 5);
      uint64_t v136 = 8 * v134;
      do
      {
        v137 = *v135;
        fsid v138 = (fsid)dyld4::Loader::loadAddress(*v135, this);
        if ((*((_WORD *)v137 + 2) & 2) != 0
          || (v139 = (dyld3 *)dyld4::Loader::path(v137, this), dyld3::stat(v139, &v221, v140)))
        {
          fsobj_id v141 = 0LL;
          v142 = 0LL;
        }

        else
        {
          v142 = (unsigned __int8 (*)[16])v221.st_ino;
          fsobj_id v141 = (fsobj_id)v221.st_dev;
        }

        v143 = (void *)dyld4::Loader::path(v137, this);
        fsobj_id v144 = v141;
        fsid v145 = v138;
        uint64_t is_enabled = dyld3::kdebug_trace_dyld_image( 0LL,  v143,  (void **)v137 + 1,  v142,  v144,  v145,  (const void *)*((unsigned int *)v137 + 6),  v146,  v214);
        ++v135;
        v136 -= 8LL;
      }

      while (v136);
    }
  }

  if (v218)
  {
    v221.fsobj_id st_dev = 520552468;
    memset(&v221.st_ino, 0, 104);
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v221, v127, v128, v129, v130, v131, v132, v133);
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "building PrebuiltLoaderSet for main executable\n");
    }
    Diagnostics::Diagnostics((Diagnostics *)&v256);
    vm_address_t LaunchSet = dyld4::PrebuiltLoaderSet::makeLaunchSet(&v256, this, (dyld4::RuntimeState *)(v233 + 5), v147);
    if (LaunchSet && (v149 = (const dyld4::PrebuiltLoaderSet *)LaunchSet, Diagnostics::noError((Diagnostics *)&v256)))
    {
      if (*((_BYTE *)this + 1009))
      {
        v190 = "dyld: PrebuiltLoaderSet expected but not found";
        goto LABEL_143;
      }

      dyld4::PrebuiltLoaderSet::deallocate((vm_address_t)v149);
      *(_OWORD *)&v221.st_mtimespec.tv_nsec = xmmword_1800B7B20;
    }

    else if (*(_BYTE *)(*((void *)this + 1) + 207LL))
    {
      v150 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v256);
      dyld4::RuntimeState::log(this, "could not build PrebuiltLoaderSet: %s\n", v150);
    }

    mach_o::Error::~Error((vm_address_t **)&v256);
    uint64_t is_enabled = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v221);
  }

  if (*(_BYTE *)(*((void *)this + 1) + 194LL)) {
    goto LABEL_121;
  }
  uint64_t v151 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)is_enabled);
  __chkstk_darwin(v151, v152, v153, v154, v155, v156, v157, v158, (uint64_t)v214);
  v160 = (lsl::Allocator *)((char *)&v214 - v159);
  uint64_t v161 = *((void *)this + 6);
  uint64_t v163 = lsl::AllocatorLayout::minSize(v162);
  v166 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v160, (char *)(v163 + 8 * v161 + 64), v164, v165);
  *(void *)&v221.fsobj_id st_dev = v166;
  memset(&v221.st_ino, 0, 24);
  lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v221, *((void *)this + 6));
  uint64_t v167 = *((void *)this + 6);
  uint64_t v168 = *(void *)&v221.st_uid;
  if (v167)
  {
    v169 = (uint64_t *)*((void *)this + 5);
    uint64_t v170 = 8 * v167;
    do
    {
      uint64_t v171 = *v169++;
      lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v221, v168 + 1);
      uint64_t v172 = *(void *)&v221.st_uid;
      uint64_t v168 = ++*(void *)&v221.st_uid;
      *(void *)(v221.st_ino + 8 * v172) = v171;
      v170 -= 8LL;
    }

    while (v170);
  }

  __darwin_ino64_t v256 = v221.st_ino + 8 * v31;
  uint64_t v257 = v168 - v31;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)&v256);
  v219[0] = (vm_address_t *)v221.st_ino;
  v219[1] = *(vm_address_t **)&v221.st_uid;
  dyld4::RuntimeState::notifyDtrace((uint64_t)this, (uint64_t)v219);
  if (v221.st_ino) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v221, 0LL);
  }
  lsl::Allocator::~Allocator(v166);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 536))) {
    dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers( (dyld4 *)((char *)this + 536),  v173,  v174,  v175,  v176,  v177,  v178,  v179);
  }
  (*(void (**)(dyld4 *))(*(void *)this + 856LL))(this);
  if (dyld4::ExternallyViewableState::notifyMonitorNeeded((dyld4 *)((char *)this + 536))) {
    dyld4::ExternallyViewableState::notifyMonitorOfMainCalled( (dyld4 *)((char *)this + 536),  v180,  v181,  v182,  v183,  v184,  v185,  v186);
  }
  uint64_t v187 = *((void *)this + 1);
  if (*(_BYTE *)(v187 + 193))
  {
LABEL_121:
    v188 = dyld4::fake_main;
    goto LABEL_122;
  }

  if (*(_DWORD *)(v187 + 68) != 10)
  {
    if (dyld3::MachOFile::getEntry(*(dyld3::MachOFile **)(v187 + 8), (unint64_t *)&v221, (BOOL *)&v256))
    {
      if (!(_BYTE)v256)
      {
        v188 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))(*(void *)&v221.st_dev + *(void *)(*((void *)this + 1) + 8LL));
        goto LABEL_122;
      }

      v190 = "main executable is missing LC_MAIN";
    }

    else
    {
      v190 = "main executable has no entry point";
    }

  LOBYTE(v14) = v124;
  uint64_t v79 = v122;
  uint64_t v25 = v123;
  if ((v82 & 1) != 0)
  {
    fsobj_id v144 = 0LL;
    fsid v145 = 0LL;
  }

LABEL_143:
    dyld4::halt(v190, 0LL);
  }

  v188 = (void (*)(dyld4 *, int, const char *const *, const char *const *, const char *const *))*((void *)this + 128);
  if (!v188)
  {
    v190 = "DriverKit main entry point not set";
    goto LABEL_143;
  }

LABEL_122:
  mach_o::Error::~Error(&v230);
  _Block_object_dispose(&v232, 8);
  dyld4::BumpAllocator::~BumpAllocator(v216);
  _Block_object_dispose(&v247, 8);
  uint64_t v253 = 0LL;
  if (v254) {
    vm_deallocate(mach_task_self_, v254, v255);
  }
  return v188;
}

dyld4::RuntimeState *dyld4::RuntimeState::RuntimeState( dyld4::RuntimeState *this, const dyld4::ProcessConfig *a2, dyld4::RuntimeLocks *a3, lsl::Allocator *a4)
{
  *(void *)this = &unk_18961F6A8;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = a4;
  *((void *)this + 5) = 0LL;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = a4;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = 0LL;
  *((void *)this + 16) = lsl::Allocator::Pool::allocator(a4);
  *((void *)this + 17) = a3;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 20) = a4;
  *((void *)this + 21) = 0LL;
  *((_OWORD *)this + 11) = 0u;
  *((void *)this + 24) = a4;
  *((void *)this + 25) = 0LL;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 28) = a4;
  *((void *)this + 29) = 0LL;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 32) = a4;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((void *)this + 35) = 0LL;
  *((void *)this + 36) = a4;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((void *)this + 63) = 0LL;
  dyld4::FileManager::FileManager( (dyld4::RuntimeState *)((char *)this + 512),  *((lsl::Lock ***)this + 2),  *((const dyld4::SyscallDelegate **)this + 1));
  *((_DWORD *)this + 138) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((void *)this + 70) = 0LL;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((void *)this + 73) = a4;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *(_OWORD *)((char *)this + 633) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((void *)this + 86) = 0LL;
  *((void *)this + 87) = a4;
  *((void *)this + 88) = 0LL;
  *(_OWORD *)((char *)this + 712) = 0u;
  *((void *)this + 91) = a4;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = 0LL;
  *((void *)this + 95) = a4;
  *((void *)this + 98) = 0LL;
  *((_OWORD *)this + 48) = 0u;
  *((void *)this + 99) = a4;
  *((void *)this + 102) = 0LL;
  *((_OWORD *)this + 50) = 0u;
  *((void *)this + 103) = a4;
  *((void *)this + 106) = 0LL;
  *((_OWORD *)this + 52) = 0u;
  *((void *)this + 107) = a4;
  *((void *)this + 110) = 0LL;
  *((_OWORD *)this + 54) = 0u;
  *((void *)this + 111) = a4;
  *((void *)this + 114) = 0LL;
  *((_OWORD *)this + 56) = 0u;
  *((void *)this + 115) = a4;
  *((_OWORD *)this + 58) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((_OWORD *)this + 60) = 0u;
  *((_OWORD *)this + 61) = 0u;
  *((_OWORD *)this + 62) = 0u;
  *((_DWORD *)this + 253) = 256;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *((void *)this + 129) = a4;
  *((void *)this + 131) = 0LL;
  *((void *)this + 130) = 0LL;
  *((void *)this + 132) = 0LL;
  *((void *)this + 133) = a4;
  *((void *)this + 135) = 0LL;
  *((void *)this + 134) = 0LL;
  *((_DWORD *)this + 274) = 0;
  *((void *)this + 136) = 0LL;
  *((void *)this + 139) = -1LL;
  *((void *)this + 138) = -1LL;
  *((void *)this + 140) = 0xFFFFFFFFLL;
  *((void *)this + 142) = 0LL;
  *((_WORD *)this + 564) = 0;
  return this;
}

double __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__21(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke(uint64_t a1, const char *a2)
{
  Loader = dyld4::Loader::getLoader(&v16, *(DyldSharedCache ****)(a1 + 40), a2, a1 + 48);
  if (Loader)
  {
    uint64_t v5 = Loader;
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v7 = *(dyld4::Loader ***)(v6 + 40);
    uint64_t v8 = *(void *)(v6 + 56);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      while (*v7 != Loader)
      {
        ++v7;
        v9 -= 8LL;
        if (!v9) {
          goto LABEL_6;
        }
      }

      uint64_t v15 = *(dyld4::RuntimeState **)(a1 + 40);
      if (*(_BYTE *)(*((void *)v15 + 1) + 200LL)) {
        dyld4::RuntimeState::log(v15, "skipping duplicate inserted dylib '%s'\n", a2);
      }
    }

    else
    {
LABEL_6:
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v6 + 40), 1LL);
      uint64_t v10 = *(void *)(v6 + 40);
      uint64_t v11 = *(void *)(v6 + 56);
      *(void *)(v6 + 56) = v11 + 1;
      *(void *)(v10 + 8 * v11) = v5;
      dyld4::RuntimeState::notifyDebuggerLoad(*(dyld4::RuntimeState **)(a1 + 40), v5);
      if ((*((_WORD *)v5 + 2) & 1) != 0) {
        dyld4::RuntimeState::add(*(dyld4::RuntimeState **)(a1 + 40), v5);
      }
    }
  }

  else if (Diagnostics::hasError((Diagnostics *)&v16))
  {
    v12 = *(dyld4::RuntimeState **)(a1 + 40);
    if (!*(_BYTE *)(*((void *)v12 + 1) + 189LL))
    {
      BOOL v13 = (const char *)Diagnostics::errorMessageCStr((Diagnostics *)&v16);
      dyld4::RuntimeState::log(v12, "terminating because inserted dylib '%s' could not be loaded: %s\n", a2, v13);
      uint64_t v14 = (char *)Diagnostics::errorMessage((Diagnostics *)&v16);
      dyld4::halt(v14, 0LL);
    }
  }

  mach_o::Error::~Error(&v16);
}

__n128 __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
}

void *___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_28(uint64_t a1, const char *a2)
{
  return dyld4::MissingPaths::addPath((dyld4::MissingPaths *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
}

dyld3::MachOFile *___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_2( uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v5 = dyld4::PrebuiltLoader::BindTargetRef::value( (dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 2),  *(dyld4::RuntimeState **)(a1 + 32),  a3);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(dyld3::MachOFile **)(*(void *)(v6 + 8) + 240LL);
  unsigned int v9 = *a2;
  unsigned int v10 = a2[1];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_3;
  v12[3] = &__block_descriptor_tmp_33;
  v12[4] = v6;
  v12[5] = v5;
  v12[6] = v7;
  return DyldSharedCache::forEachPatchableUseOfExport(v8, v9, v10, (uint64_t)v12);
}

void ___ZN5dyld4L7prepareERNS_4APIsEPKN5dyld313MachOAnalyzerE_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 240LL) + a2);
  uint64_t v5 = *(void *)(a1 + 40) + a4;
  if (*v4 != v5)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
    uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 32);
    if (*(_BYTE *)(*((void *)v7 + 1) + 202LL)) {
      dyld4::RuntimeState::log(v7, "cache patch: %p = 0x%0lX\n", v4, v5);
    }
    uint64_t *v4 = v5;
  }
}

void dyld4::fake_main( dyld4 *this, int a2, const char *const *a3, const char *const *a4, const char *const *a5)
{
}

void *dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 8 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    __n128 result = memmove((void *)v4[3], *v4, 8LL * (void)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 3);
    uint64_t *v4 = v4[3];
    v4[1] = v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map( uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  uint64_t v3 = 32LL;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1LL);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }

  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  return a1;
}

void *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 4 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    __n128 result = memmove((void *)v3[3], *v3, 4LL * (void)v3[2]);
    uint64_t v11 = (const void *)((unint64_t)v3[4] >> 2);
    *uint64_t v3 = v3[3];
    v3[1] = v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve( void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 24 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    __n128 result = memmove((void *)v3[3], *v3, 24LL * (void)v3[2]);
    unint64_t v11 = (unint64_t)v3[4] / 0x18;
    *uint64_t v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    vm_address_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 4 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    __n128 result = memmove((void *)v4[3], *v4, 4LL * (void)v4[2]);
    v12 = (const void *)((unint64_t)v4[4] >> 2);
    uint64_t *v4 = v4[3];
    v4[1] = v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t dyld4::KernelArgs::findEnvp(dyld4::KernelArgs *this)
{
  return (uint64_t)this + 8 * *((void *)this + 1) + 24;
}

void *dyld4::KernelArgs::findApple(dyld4::KernelArgs *this)
{
  __n128 result = (void *)((char *)this + 8 * *((void *)this + 1) + 24);
  while (*result++)
    ;
  return result;
}

dyld4::ProcessConfig *dyld4::ProcessConfig::ProcessConfig( dyld4::ProcessConfig *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Lock **a4)
{
  unint64_t v7 = (const char ***)((char *)this + 8);
  dyld4::ProcessConfig::Process::Process((dyld4::ProcessConfig *)((char *)this + 8), a2, a3, a4);
  dyld4::ProcessConfig::Security::Security((dyld4::ProcessConfig *)((char *)this + 168), v7, a3);
  dyld4::ProcessConfig::Logging::Logging((uint64_t)this + 200, (uint64_t)v7, (uint64_t)this + 168, a3);
  dyld4::ProcessConfig::DyldCache::DyldCache( (uint64_t)this + 240,  (uint64_t)v7,  (uint64_t)this + 168,  (uint64_t)this + 200,  a3,  a4);
  vm_size_t v8 = dyld4::ProcessConfig::PathOverrides::PathOverrides( (dyld4::ProcessConfig *)((char *)this + 400),  (dyld4::ProcessConfig::Process *)v7,  (dyld4::ProcessConfig *)((char *)this + 168),  (uint64_t)this + 200,  (uint64_t)this + 240,  (uint64_t)a3,  a4);
  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(v8)) {
    *((_BYTE *)this + 399) = 1;
  }
  return this;
}

BOOL dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp(dyld4::ProcessConfig::PathOverrides *this)
{
  return *(void *)this
      || *((void *)this + 1)
      || *((void *)this + 4)
      || *((void *)this + 5)
      || *((void *)this + 12)
      || *((void *)this + 13)
      || *((void *)this + 11)
      || *((void *)this + 10)
      || *((void *)this + 6)
      || *((void *)this + 7) != 0LL;
}

const char *dyld4::ProcessConfig::Process::appleParam(const char ***this, char *a2)
{
  return _simple_getenv(this[15], a2);
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::Process( dyld4::ProcessConfig::Process *this, const dyld4::KernelArgs *a2, dyld4::SyscallDelegate *a3, lsl::Lock **a4)
{
  vm_size_t v8 = (void *)((char *)this + 88);
  dyld4::SyscallDelegate::DyldCommPage::DyldCommPage((dyld4::ProcessConfig::Process *)((char *)this + 88));
  uint64_t v9 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((_DWORD *)this + 24) = v9;
  uint64_t v10 = (void *)((char *)a2 + 8 * v9 + 24);
  *((void *)this + 13) = (char *)a2 + 16;
  *((void *)this + 14) = v10;
  while (*v10++)
    ;
  *((void *)this + 15) = v10;
  *((_DWORD *)this + 36) = dyld4::SyscallDelegate::getpid();
  *((void *)this + 11) = dyld4::SyscallDelegate::dyldCommPageFlags(a3);
  *((_BYTE *)this + 148) = dyld4::PrebuiltLoader::hiddenFromFlat(a3);
  *((void *)this + 3) = dyld4::ProcessConfig::Process::getMainFileID((const char ***)this);
  *((void *)this + 4) = v12;
  *((void *)this + 9) = dyld4::ProcessConfig::Process::getDyldFileID((const char ***)this);
  *((void *)this + 10) = v13;
  *((void *)this + 2) = dyld4::ProcessConfig::Process::getMainUnrealPath((const char ***)this, a3, a4);
  *((void *)this + 1) = dyld4::ProcessConfig::Process::getMainPath(this, a3, a4);
  uint64_t v14 = (const char *)*((void *)this + 2);
  uint64_t v15 = strrchr(v14, 47);
  if (v15) {
    uint64_t v16 = v15 + 1;
  }
  else {
    uint64_t v16 = v14;
  }
  *((void *)this + 16) = v16;
  *((void *)this + 8) = dyld4::ProcessConfig::Process::getDyldPath((fsid_t *)this, a3, a4);
  if (*((_DWORD *)this + 36) == 1) {
    *vm_size_t v8 = *(unsigned int *)v8;
  }
  *((_DWORD *)this + 15) = dyld4::ProcessConfig::Process::getMainPlatform(this);
  *((_BYTE *)this + 149) = 0;
  unint64_t v17 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
  *((void *)this + 17) = dyld4::SyscallDelegate::getGradedArchs(a3, v17, 0LL);
  *((_BYTE *)this + 150) = (*((void *)this + 11) & 0x200000LL) == 0;
  else {
    BOOL v18 = 0;
  }
  char v19 = v18;
  *((_BYTE *)this + 151) = v19;
  *((_BYTE *)this + 152) = (*((void *)this + 11) & 0xC0000LL) != 0x80000;
  *((_BYTE *)this + 153) = 0;
  *((_DWORD *)this + 39) = 2;
  if (!dyld4::SyscallDelegate::internalInstall(a3))
  {
LABEL_21:
LABEL_22:
    if (!dyld4::SyscallDelegate::sandboxBlockedPageInLinking(a3)) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }

  if ((*(_BYTE *)v8 & 0x80) == 0)
  {
    v20 = _simple_getenv(*((const char ***)this + 14), "DYLD_PAGEIN_LINKING");
    if (!v20) {
      goto LABEL_21;
    }
    uint64_t v21 = v20;
    if (_platform_strcmp(v20, "0"))
    {
      if (!_platform_strcmp(v21, "1"))
      {
        int v22 = 1;
        goto LABEL_24;
      }

      if (_platform_strcmp(v21, "2"))
      {
        if (_platform_strcmp(v21, "3")) {
          goto LABEL_21;
        }
        int v26 = 3;
      }

      else
      {
        int v26 = 2;
      }

      *((_DWORD *)this + 39) = v26;
      goto LABEL_22;
    }
  }

LABEL_23:
  int v22 = 0;
LABEL_24:
  *((_DWORD *)this + 39) = v22;
LABEL_25:
  if (MEMORY[0xFFFFF4025] != 14) {
    *((_DWORD *)this + 39) = 0;
  }
  if (*((_DWORD *)this + 15) == 3)
  {
    if (*((_BYTE *)this + 150))
    {
      unsigned int v23 = *((unsigned __int16 *)this + 21);
      int v24 = _platform_strcmp(*((const char **)this + 16), "ArgonTV");
      if (v23 <= 0xE && !v24) {
        *((_BYTE *)this + 150) = 0;
      }
    }
  }

  return this;
}

  if (*(_BYTE *)(a1 + 48))
  {
    if (*(_DWORD *)(a2 + 60) == 10) {
      uint64_t v16 = (*(void *)(a2 + 88) >> 5) & 1LL;
    }
    else {
      uint64_t v16 = *(void *)(a2 + 88) & 0x10LL;
    }
    if (!v16) {
      return a1;
    }
    if (*(_DWORD *)a1 != -1) {
      dyld4::SyscallDelegate::close(*(dyld4::SyscallDelegate **)(a1 + 8), *(_DWORD *)a1);
    }
    *(_DWORD *)a1 = -1;
    *(_BYTE *)(a1 + 48) = 0;
  }

        dyld4::RuntimeState::setDyldLoader(this, a2);
        return;
      }

      if (*(_BYTE *)(v9 + 169) && dyld3::MachOFile::isExclaveKitPlatform(v10, 0LL))
      {
        if (_platform_strlen(v8) < 0x13) {
          return;
        }
        if (!_platform_strcmp(v8 + 18, "/usr/lib/system/libdyld.dylib")
          || !_platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
        {
          goto LABEL_23;
        }

        if (!_platform_strcmp(v8 + 18, "/usr/lib/libSystem.dylib"))
        {
LABEL_21:
          *((void *)this + 12) = a2;
          return;
        }
      }

      else if (!_platform_strcmp(v8, "/usr/lib/system/libdyld.dylib"))
      {
        goto LABEL_23;
      }

      uint64_t v11 = "/usr/lib/libSystem.B.dylib";
LABEL_20:
      if (_platform_strcmp(v8, v11)) {
        return;
      }
      goto LABEL_21;
    }
  }

          if (++v17 == 2) {
            goto LABEL_24;
          }
        }

        uint64_t v21 = *(dyld4::Loader ***)(v19 + 8);
        int v22 = 8 * v20;
        while (1)
        {
          unsigned int v23 = *v21;
          ++v21;
          v22 -= 8LL;
          if (!v22) {
            goto LABEL_23;
          }
        }

        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v23;
        *a4 = 1;
        Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
        uint64_t v38 = *(const dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((void *)v38 + 1) + 208LL))
        {
          dyld4::Loader::path(v23, v38);
          dyld4::RuntimeState::log(v38, "  found: already-loaded-by-dylib-index: %s -> %s\n");
        }

        return;
      }

  if (a3 && v13) {
    kdebug_trace_string(a1, v13, 0LL, v29, v30, v31, v32, v33);
  }
  return v21;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getMainFileID(const char ***this)
{
  __n128 result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "executable_file");
  if (result) {
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings( result,  (const char *)result);
  }
  return result;
}

dyld4::ProcessConfig::Process *dyld4::ProcessConfig::Process::getDyldFileID(const char ***this)
{
  __n128 result = (dyld4::ProcessConfig::Process *)_simple_getenv(this[15], "dyld_file");
  if (result) {
    return (dyld4::ProcessConfig::Process *)dyld4::ProcessConfig::Process::fileIDFromFileHexStrings( result,  (const char *)result);
  }
  return result;
}

char *dyld4::ProcessConfig::Process::getMainUnrealPath( const char ***this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  vm_size_t v6 = _simple_getenv(this[15], "executable_path");
  if (!v6) {
    vm_size_t v6 = *this[13];
  }
  int v7 = *(unsigned __int8 *)v6;
  if (v7 != 47)
  {
    if (v7 == 46) {
      v6 += 2 * (v6[1] == 47);
    }
    if (dyld4::SyscallDelegate::getCWD(a2, __dst))
    {
      strlcat(__dst, "/", 0x400uLL);
      strlcat(__dst, v6, 0x400uLL);
      return lsl::Allocator::strdup(a3, __dst);
    }
  }

  return (char *)v6;
}

char *dyld4::ProcessConfig::Process::getMainPath( dyld4::ProcessConfig::Process *this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  fsid_t v6 = (fsid_t)*((void *)this + 3);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 4);
    if (v7)
    {
      if (dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v6, v7) != -1) {
        return lsl::Allocator::strdup(a3, __s);
      }
    }
  }

  if (dyld4::SyscallDelegate::realpath(a2, *((dyld3 **)this + 2), __s)) {
    return lsl::Allocator::strdup(a3, __s);
  }
  else {
    return (char *)*((void *)this + 2);
  }
}

char *dyld4::ProcessConfig::Process::getDyldPath(fsid_t *this, dyld4::SyscallDelegate *a2, lsl::Lock **a3)
{
  fsid_t v3 = this[9];
  if (*(void *)&v3
    && (uint64_t v4 = (uint64_t)this[10]) != 0
    && dyld4::SyscallDelegate::fsgetpath(a2, __s, 0x400uLL, v3, v4) != -1)
  {
    return lsl::Allocator::strdup(a3, __s);
  }

  else
  {
    return "/usr/lib/dyld";
  }

uint64_t dyld4::ProcessConfig::Process::getMainPlatform(dyld4::ProcessConfig::Process *this)
{
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  int v18 = 0;
  unint64_t v2 = *(_DWORD **)this;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  v14[2] = ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke;
  v14[3] = &unk_18961EFB0;
  v14[4] = &v15;
  v14[5] = this;
  dyld3::MachOFile::forEachSupportedPlatform(v2, (uint64_t)v14);
  if (*((_DWORD *)v16 + 6) != 1) {
    goto LABEL_20;
  }
  fsid_t v3 = _simple_getenv(*((const char ***)this + 14), "DYLD_FORCE_PLATFORM");
  if (!v3) {
    goto LABEL_20;
  }
  uint64_t v4 = v3;
  int v5 = *(unsigned __int8 *)v4;
  if (v5 == 54)
  {
    int v7 = 6;
    goto LABEL_9;
  }

  if (v5 == 50)
  {
    fsid_t v6 = dyld3::MachOFile::archName(*(dyld3::MachOFile **)this);
    if (!_platform_strcmp(v6, "arm64"))
    {
      int v7 = 2;
LABEL_9:
      *((_DWORD *)v16 + 6) = v7;
    }
  }

  uint64_t v8 = 0LL;
  while (dyld3::sVersionMap[v8 + 1] != *((_DWORD *)this + 10))
  {
    v8 += 9LL;
    if (v8 == 441) {
      goto LABEL_15;
    }
  }

  *((_DWORD *)this + 10) = dyld3::sVersionMap[v8 + 2];
LABEL_15:
  uint64_t v9 = 0LL;
  while (dyld3::sVersionMap[v9 + 1] != *((_DWORD *)this + 12))
  {
    v9 += 9LL;
    if (v9 == 441) {
      goto LABEL_20;
    }
  }

  *((_DWORD *)this + 12) = dyld3::sVersionMap[v9 + 2];
LABEL_20:
  uint64_t v10 = dyld3::MachOFile::basePlatform(*((unsigned int *)v16 + 6));
  *((_DWORD *)this + 14) = v10;
  uint64_t VersionSetEquivalent = dyld4::ProcessConfig::Process::findVersionSetEquivalent(v10, v10, *((_DWORD *)this + 10));
  *((_DWORD *)this + 11) = VersionSetEquivalent;
  *((_DWORD *)this + 13) = dyld4::ProcessConfig::Process::findVersionSetEquivalent( VersionSetEquivalent,  *((unsigned int *)this + 14),  *((_DWORD *)this + 12));
  uint64_t v12 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v12;
}

const char *dyld4::ProcessConfig::Process::environ(const char ***this, char *a2)
{
  return _simple_getenv(this[14], a2);
}

uint64_t dyld4::ProcessConfig::Process::fileIDFromFileHexStrings( dyld4::ProcessConfig::Process *this, const char *a2)
{
  int v5 = 0LL;
  uint64_t v2 = hexToUInt64(a2, (const char **)&v5);
  if (!v5) {
    return 0LL;
  }
  uint64_t v3 = v2;
  hexToUInt64(v5 + 1, (const char **)&v5);
  if (v5) {
    return v3;
  }
  else {
    return 0LL;
  }
}

uint64_t hexToUInt64(const char *a1, const char **a2)
{
  if (!a1) {
    return 0LL;
  }
  if (*a1 == 48) {
    a1 += 2 * (a1[1] == 120);
  }
  if (a2) {
    *a2 = a1 + 16;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = 0LL;
  while (1)
  {
    int v4 = a1[v2];
    unsigned __int8 v5 = v4 - 48;
LABEL_12:
    uint64_t v3 = 16 * v3 + v5;
    if (++v2 == 16) {
      return v3;
    }
  }

  if ((v4 - 65) <= 5)
  {
    unsigned __int8 v5 = v4 - 55;
    goto LABEL_12;
  }

  if ((v4 - 97) <= 5)
  {
    unsigned __int8 v5 = v4 - 87;
    goto LABEL_12;
  }

  if (a2) {
    *a2 = &a1[v2];
  }
  return v3;
}

uint64_t dyld4::ProcessConfig::Process::findVersionSetEquivalent(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = 0;
  unsigned int v7 = 0;
  uint64_t v8 = dyld3::sVersionMap;
  while (1)
  {
    int v9 = dyld3::MachOFile::basePlatform(a2);
    unsigned int v10 = -1;
    switch(v9)
    {
      case 1:
        uint64_t v11 = v8 + 1;
        goto LABEL_9;
      case 2:
        uint64_t v11 = v8 + 2;
        goto LABEL_9;
      case 3:
        uint64_t v11 = v8 + 4;
        goto LABEL_9;
      case 4:
        uint64_t v11 = v8 + 3;
        goto LABEL_9;
      case 5:
        uint64_t v11 = v8 + 5;
        goto LABEL_9;
      case 11:
        uint64_t v11 = &dyld3::sVersionMap[v5 + 7];
LABEL_9:
        unsigned int v10 = *v11;
        break;
      default:
        break;
    }

    if (v10 > a3) {
      break;
    }
    unsigned int v6 = dyld3::sVersionMap[v5];
    v8 += 9;
    v5 += 9LL;
    unsigned int v7 = v10;
    if (v5 == 441)
    {
      unsigned int v7 = v10;
      break;
    }
  }

  if (v10 == -1 && v7 == 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

uint64_t ___ZN5dyld413ProcessConfig7Process15getMainPlatformEv_block_invoke( uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  *(_DWORD *)(v4 + 40) = a4;
  *(_DWORD *)(v4 + 48) = a3;
  return result;
}

dyld4::ProcessConfig::Security *dyld4::ProcessConfig::Security::Security( dyld4::ProcessConfig::Security *this, const char ***a2, dyld4::SyscallDelegate *a3)
{
  int v6 = dyld4::SyscallDelegate::internalInstall(a3);
  *((_BYTE *)this + 1) = v6;
  *(_BYTE *)this = v6;
  if (v6) {
    BOOL v7 = _simple_getenv(a2[14], "DYLD_SKIP_MAIN") != 0LL;
  }
  else {
    BOOL v7 = 0;
  }
  *((_BYTE *)this + 25) = v7;
  *((_BYTE *)this + 26) = _simple_getenv(a2[14], "DYLD_JUST_BUILD_CLOSURE") != 0LL;
  if (*((_DWORD *)a2 + 36) == 1)
  {
    if (*((_BYTE *)this + 1))
    {
      uint64_t v8 = _simple_getenv(a2[15], "dyld_flags");
      if (v8) {
        *((_DWORD *)a2 + 22) = hexToUInt64(v8, 0LL);
      }
    }
  }

  unsigned int AMFI = dyld4::ProcessConfig::Security::getAMFI(this, (const dyld4::ProcessConfig::Process *)a2, a3);
  *((_BYTE *)this + 16) = AMFI & 1;
  v10.i64[0] = *(void *)&vshl_u16( (uint16x4_t)(*(void *)&vdup_n_s16(AMFI) & 0xFF00FF00FF00FFLL),  (uint16x4_t)0xFFFDFFFEFFFFFFFCLL) & 0xFF01FF01FF01FF01LL;
  *(_DWORD *)((char *)this + 17) = vmovn_s16(v10).u32[0];
  *((_BYTE *)this + 21) = (AMFI & 0x20) != 0;
  *((_BYTE *)this + 22) = (AMFI & 0x40) != 0;
  *((_BYTE *)this + 23) = (AMFI & 0x80) != 0;
  *((_BYTE *)this + 24) = BYTE1(AMFI) & 1;
  *((_WORD *)this + 1) = 0;
  *((void *)this + 1) = 0LL;
  uint64_t v11 = *a2;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke;
  v15[3] = &__block_descriptor_tmp_26;
  v15[4] = this;
  dyld3::MachOFile::forDyldEnv(v11, (uint64_t)v15);
  unsigned int v13 = *((_DWORD *)a2 + 15);
  if (v13 <= 0xA
    && ((1 << v13) & 0x442) != 0
    && !*((_BYTE *)this + 17)
    && !*((_BYTE *)this + 18)
    && !*((_BYTE *)this + 19))
  {
    dyld4::ProcessConfig::Security::pruneEnvVars(v12, (uint64_t)a2);
  }

  return this;
}

unint64_t dyld4::ProcessConfig::Security::getAMFI( dyld4::ProcessConfig::Security *this, const dyld4::ProcessConfig::Process *a2, dyld4::SyscallDelegate *a3)
{
  int isRestricted = dyld3::MachOFile::isRestricted(*(dyld3::MachOFile **)a2);
  uint64_t isFairPlayEncrypted = dyld3::MachOFile::isFairPlayEncrypted(*(dyld3::MachOFile **)a2, &v19, &v18);
  unint64_t v13 = dyld4::SyscallDelegate::amfiFlags(a3, isRestricted, isFairPlayEncrypted, v8, v9, v10, v11, v12);
  uint64_t v14 = *((void *)a2 + 11);
  uint64_t v15 = _simple_getenv(*((const char ***)a2 + 14), "DYLD_AMFI_FAKE");
  if (v15) {
    BOOL v16 = (v14 & 2) == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16 && *((_BYTE *)this + 1)) {
    return hexToUInt64(v15, 0LL);
  }
  return v13;
}

uint64_t ___ZN5dyld413ProcessConfig8SecurityC2ERNS0_7ProcessERNS_15SyscallDelegateE_block_invoke( uint64_t a1, char *__s1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = _platform_strncmp(__s1, "DYLD_DLSYM_RESULT=", 0x12uLL);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t result = _platform_strcmp(__s1 + 18, "null");
  if (!(_DWORD)result)
  {
    __int16 v6 = 1;
LABEL_10:
    *(_WORD *)(v3 + 2) = v6;
    return result;
  }

  uint64_t result = _platform_strcmp(__s1 + 18, "abort");
  if (!(_DWORD)result)
  {
    __int16 v6 = 257;
    goto LABEL_10;
  }

  uint64_t result = _platform_strncmp(__s1 + 18, "null-allow:", 0xBuLL);
  if ((_DWORD)result)
  {
    uint64_t result = _platform_strncmp(__s1 + 18, "abort-allow:", 0xCuLL);
    if ((_DWORD)result)
    {
      uint64_t result = _platform_strncmp(__s1 + 18, "allow:", 6uLL);
      if ((_DWORD)result) {
        return result;
      }
      *(_WORD *)(v3 + 2) = 0;
      uint64_t v5 = __s1 + 24;
    }

    else
    {
      *(_WORD *)(v3 + 2) = 257;
      uint64_t v5 = __s1 + 30;
    }
  }

  else
  {
    *(_WORD *)(v3 + 2) = 1;
    uint64_t v5 = __s1 + 29;
  }

  *(void *)(v3 + 8) = v5;
  return result;
}

void dyld4::ProcessConfig::Security::pruneEnvVars(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const char ***)(a2 + 112);
  uint64_t v3 = *v2;
  if (*v2)
  {
    int v5 = 0;
    __int16 v6 = v2 + 1;
    do
    {
      if (_platform_strncmp(v3, "DYLD_", 5uLL)) {
        *v2++ = v3;
      }
      else {
        ++v5;
      }
      BOOL v7 = *v6++;
      uint64_t v3 = v7;
    }

    while (v7);
    _DWORD *v2 = 0LL;
    if (v5 > 0)
    {
      uint64_t v8 = v2 + 1;
      *(void *)(a2 + 120) = v2 + 1;
      do
      {
        uint64_t v9 = v8[v5];
        *v8++ = v9;
      }

      while (v9);
      bzero(v8, 8LL * v5);
    }
  }

  else
  {
    _DWORD *v2 = 0LL;
  }

uint64_t dyld4::ProcessConfig::Logging::Logging( uint64_t a1, uint64_t a2, uint64_t a3, dyld4::SyscallDelegate *a4)
{
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  if (!*(_BYTE *)(a3 + 17))
  {
    *(_BYTE *)(a1 + 1) = 0;
    goto LABEL_14;
  }

  BOOL v8 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_SEGMENTS") != 0LL;
  int v9 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 1) = v8;
  if (!v9)
  {
LABEL_14:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 2) = 0;
    goto LABEL_15;
  }

  BOOL v10 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LIBRARIES") != 0LL;
  int v11 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)a1 = v10;
  if (!v11)
  {
    *(_WORD *)(a1 + 2) = 0;
    goto LABEL_20;
  }

  BOOL v12 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_BINDINGS") != 0LL;
  int v13 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 2) = v12;
  if (!v13)
  {
LABEL_15:
    *(_WORD *)(a1 + 3) = 0;
    goto LABEL_16;
  }

  BOOL v14 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_INITIALIZERS") != 0LL;
  int v15 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 3) = v14;
  if (!v15)
  {
LABEL_20:
    *(_WORD *)(a1 + 4) = 0;
    goto LABEL_21;
  }

  BOOL v16 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_APIS") != 0LL;
  int v17 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 4) = v16;
  if (!v17)
  {
LABEL_16:
    *(_WORD *)(a1 + 5) = 0;
    goto LABEL_17;
  }

  BOOL v18 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_NOTIFICATIONS") != 0LL;
  int v19 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 5) = v18;
  if (!v19)
  {
LABEL_21:
    *(_WORD *)(a1 + 6) = 0;
    goto LABEL_22;
  }

  BOOL v20 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_INTERPOSING") != 0LL;
  int v21 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 6) = v20;
  if (!v21)
  {
LABEL_17:
    *(_WORD *)(a1 + 7) = 0;
    goto LABEL_18;
  }

  BOOL v22 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LOADERS") != 0LL;
  int v23 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 7) = v22;
  if (!v23)
  {
LABEL_22:
    BOOL v28 = 0;
    *(_WORD *)(a1 + 8) = 0;
    goto LABEL_23;
  }

  BOOL v24 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_SEARCHING") != 0LL;
  int v25 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 8) = v24;
  if (!v25)
  {
LABEL_18:
    BOOL v28 = 0;
    *(_BYTE *)(a1 + 9) = 0;
LABEL_23:
    BOOL v29 = 1;
    goto LABEL_24;
  }

  BOOL v26 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_ENV") != 0LL;
  int v27 = *(unsigned __int8 *)(a3 + 17);
  *(_BYTE *)(a1 + 9) = v26;
  if (!v27)
  {
    BOOL v28 = 0;
    goto LABEL_23;
  }

  BOOL v28 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_TO_STDERR") != 0LL;
  BOOL v29 = *(_BYTE *)(a3 + 17) == 0;
LABEL_24:
  *(_BYTE *)(a1 + 16) = v28;
  *(_DWORD *)(a1 + 12) = 2;
  *(_BYTE *)(a1 + 17) = 0;
  if (!v29)
  {
    if (*(_BYTE *)(a3 + 19))
    {
      uint64_t v30 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_TO_FILE");
      if (v30)
      {
        int v31 = dyld4::SyscallDelegate::openLogFile(a4, v30);
        if (v31 != -1)
        {
          *(_BYTE *)(a1 + 17) = 1;
          *(_DWORD *)(a1 + 12) = v31;
        }
      }
    }
  }

  if (*(_BYTE *)(a3 + 17))
  {
    uint64_t v32 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_PRINT_LINKS_WITH");
    if (v32)
    {
      uint64_t v33 = v32;
      size_t v34 = _platform_strlen(v32);
      *(void *)(a1 + 24) = v33;
      *(void *)(a1 + 32) = v34;
    }
  }

  return a1;
}

uint64_t dyld4::CacheFinder::CacheFinder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)a1 = -1;
  *(void *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 16) = 4;
  *(void *)(a1 + 20) = -1LL;
  *(void *)(a1 + 28) = -1LL;
  *(void *)(a1 + 36) = -1LL;
  *(_DWORD *)(a1 + 44) = -1;
  *(_BYTE *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = -1;
  BOOL v7 = (dyld3 *)_simple_getenv(*(const char ***)(a2 + 112), "DYLD_SHARED_CACHE_DIR");
  if (v7)
  {
    int v8 = dyld4::SyscallDelegate::open(*(dyld4::SyscallDelegate **)(a1 + 8), v7, 0LL, 0LL);
    *(_DWORD *)a1 = v8;
    if (v8 == -1) {
      return a1;
    }
  }

  if ((*(_BYTE *)(a2 + 88) & 8) != 0) {
    goto LABEL_31;
  }
  LODWORD(v21) = 1;
  HIDWORD(v21) = *(_DWORD *)(a2 + 96);
  __int128 v22 = *(_OWORD *)(a2 + 104);
  uint64_t v23 = *(void *)(a2 + 120);
  LODWORD(v24) = -1;
  HIDWORD(v24) = *(_DWORD *)(a2 + 60);
  uint64_t v9 = ignite();
  if ((_DWORD)v9)
  {
    int v11 = v9;
    if (*(_DWORD *)(a2 + 144) == 1)
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v10, v9, v21, v22, v23, v24);
      if (v11 <= 84)
      {
        if (v11 == 8)
        {
          int v13 = "ignition disabled\n";
        }

        else
        {
          if (v11 != 19) {
            goto LABEL_23;
          }
          int v13 = "no shared cache available\n";
        }

        goto LABEL_22;
      }

      switch(v11)
      {
        case 'Y':
          int v13 = "ignition partially disabled\n";
LABEL_22:
          dyld4::console((dyld4 *)v13, v12, v20);
          break;
        case 'U':
          int v19 = "no shared cache in cryptex";
LABEL_41:
          dyld4::halt(v19, 0LL);
        case 'Z':
          int v19 = "ignition failed";
          goto LABEL_41;
      }
    }

    else if ((_DWORD)v9 == 85 && *(_BYTE *)(a3 + 1))
    {
      dyld4::console((dyld4 *)"ignite() returned %d\n", v10, 85LL);
    }
  }

  else
  {
    int v14 = *(_DWORD *)(a1 + 24);
    if ((v14 & 0x80000000) == 0)
    {
      if (*(_DWORD *)a1 == -1)
      {
        *(_DWORD *)a1 = v14;
        *(_BYTE *)(a1 + 48) = 1;
      }

      else
      {
        dyld4::SyscallDelegate::close(*(dyld4::SyscallDelegate **)(a1 + 8), v14);
      }
    }

    int v15 = *(_DWORD *)(a1 + 32);
    if ((v15 & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 52) = v15;
    }
  }

LABEL_31:
  if (*(_DWORD *)a1 == -1)
  {
    if (*(_DWORD *)(a2 + 60) == 10) {
      int v17 = "/System/DriverKit/System/Library/dyld/";
    }
    else {
      int v17 = "/System/Library/Caches/com.apple.dyld/";
    }
    *(_DWORD *)a1 = dyld4::SyscallDelegate::open(*(dyld4::SyscallDelegate **)(a1 + 8), (dyld3 *)v17, 0LL, 0LL);
  }

  return a1;
}

  fsid v37 = v51;
  if (v51 != -1)
  {
    LODWORD(v21) = dyld4::SyscallDelegate::getpath(a5, v51, __s);
    if ((_DWORD)v21)
    {
      uint64_t v38 = lsl::Allocator::strdup(a6, __s);
      uint64_t v21 = _platform_strlen(v38);
      *(void *)(a1 + 88) = v38;
      *(void *)(a1 + 96) = v21;
    }
  }

  if (*(_DWORD *)(a2 + 144) == 1) {
    dyld4::ProcessConfig::DyldCache::setupDyldCommPage(v21, a2, a3, a5);
  }
  dyld4::CacheFinder::~CacheFinder(v50, v37, v23, v24, v25, v26, v27, v28);
  return a1;
}

      if (++v16 >= *((unsigned __int16 *)v15 + 10))
      {
        int v11 = v36;
        BOOL v12 = *(unsigned int *)v36;
        goto LABEL_33;
      }
    }

    int v27 = v17 + v16 * *((unsigned __int16 *)this + 2);
    BOOL v28 = this;
    BOOL v29 = (const mwl_info_hdr *)v23;
    uint64_t v30 = 1;
    goto LABEL_25;
  }

  return 0LL;
}

  _Block_object_dispose(&v41, 8);
  return ImageMappedAt;
}

      uint64_t v62 = v73[5];
      if (!v62)
      {
LABEL_51:
        if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
LABEL_55:
        }
          dyld4::RuntimeState::log(this, "     dlsym(%s) => NULL\n", a3);
        goto LABEL_56;
      }

      int v14 = (const void *)v73[8];
      if (*((_BYTE *)v73 + 79))
      {
        if ((*(_WORD *)(v62 + 4) & 1) != 0) {
          uint64_t v62 = 0LL;
        }
        uint64_t v63 = *(uint64_t (****)(char *))(v62 + 104);
        uint64_t v64 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v63, (uint64_t)(v73 + 6), 1LL);
        if (v64)
        {
          uint64_t v65 = (char *)v64;
          if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
            dyld4::RuntimeState::log( this,  "     dlsym(%s) => NULL, error finalizing pseudo-dylib symbols: %s",  a3,  v64);
          }
          dyld4::APIs::setErrorString( (vm_address_t *)this,  "dlsym(%s): error finalizing pseudo-dylib symbols: %s",  a3,  v65);
          dyld4::PseudoDylib::disposeString(v63, v65);
LABEL_56:
          int v14 = 0LL;
          goto LABEL_57;
        }
      }

      if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
        dyld4::RuntimeState::log(this, "     dlsym(%s) => %p\n", a3, v14);
      }
      fsid v90 = (unint64_t)v14;
LABEL_57:
      _Block_object_dispose(&v72, 8);
      _Block_object_dispose(&v78, 8);
      mach_o::Error::~Error(&v83);
LABEL_13:
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v84);
      return v14;
  }

ssize_t dyld4::console(dyld4 *this, const char *a2, ...)
{
  if (getpid() == 1)
  {
    int v3 = open("/dev/console", 131073, 0LL);
    pid_t v4 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v5, v6, v7, v8, v9, v10, v4);
    _simple_vdprintf(v3, (char *)this, (int *)va);
    return close(v3);
  }

  else
  {
    pid_t v12 = getpid();
    _simple_dprintf(2, "dyld[%d]: ", v13, v14, v15, v16, v17, v18, v12);
    return _simple_vdprintf(2, (char *)this, (int *)va);
  }

void dyld4::halt(char *__source, uint64_t *a2)
{
  qword_18C509748 = (uint64_t)dyld4::error_string;
  dyld4::console((dyld4 *)"%s\n", v4, __source);
  int v12 = 1;
  uint64_t v14 = 0LL;
  uint64_t v13 = 0LL;
  if (a2)
  {
    uint64_t v6 = *a2;
    if (*a2 == 4 || v6 == 1) {
      LODWORD(v13) = 1;
    }
    uint64_t v8 = (const char *)a2[2];
    uint64_t v5 = 20LL;
    if (v8)
    {
      HIDWORD(v13) = 20;
      uint64_t v5 = strlcpy(v15, v8, 0x7ECuLL) + 21;
    }

    uint64_t v9 = (const char *)a2[1];
    if (v9)
    {
      LODWORD(v14) = v5;
      uint64_t v5 = v5 + strlcpy((char *)&v12 + (int)v5, v9, 2048LL - (int)v5) + 1;
    }

    uint64_t v10 = (const char *)a2[3];
    if (v10)
    {
      HIDWORD(v14) = v5;
      uint64_t v5 = v5 + strlcpy((char *)&v12 + (int)v5, v10, 2048LL - (int)v5) + 1;
    }
  }

  else
  {
    uint64_t v5 = 20LL;
    uint64_t v6 = 9LL;
  }

  strlcpy(__dst, __source, 0x400uLL);
  abort_with_payload((void *)6, (void *)v6, &v12, (void *)v5, __dst, 0LL);
}

void dyld4::CacheFinder::~CacheFinder( dyld4::SyscallDelegate **this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_BYTE *)this + 48))
  {
    uint64_t v8 = (int *)(this + 2);
    jettison(&v8, a2, a3, a4, a5, a6, a7, a8);
  }

  else if (*(_DWORD *)this != -1)
  {
    dyld4::SyscallDelegate::close(this[1], *(_DWORD *)this);
  }

uint64_t dyld4::ProcessConfig::DyldCache::DyldCache( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, dyld4::PrebuiltLoader *a5, lsl::Lock **a6)
{
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 128) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  unint64_t v12 = *(void *)(a2 + 88);
  dyld4::CacheFinder::CacheFinder((uint64_t)v50, a2, a4, (uint64_t)a5);
  if (*(_DWORD *)(a2 + 144) == 1)
  {
    if (*(_BYTE *)(a3 + 1))
    {
      unint64_t v13 = ((unint64_t)(*(void *)(a2 + 88) | v12) >> 2) & 1;
      BOOL v14 = (*(void *)(a2 + 88) & 5LL) == 1;
    }

    else
    {
      LOBYTE(v13) = 0;
      BOOL v14 = 1;
    }
  }

  else
  {
    BOOL v14 = v12 & 1;
    unint64_t v13 = (v12 >> 2) & 1;
  }

  uint64_t v15 = _simple_getenv(*(const char ***)(a2 + 112), "DYLD_SHARED_REGION");
  uint64_t v16 = v15;
  BOOL v17 = 0;
  LODWORD(v48) = v50[0];
  if (*(_BYTE *)(a3 + 19) && v15) {
    BOOL v17 = _platform_strcmp(v15, "private") == 0;
  }
  BYTE4(v48) = v17;
  char v18 = dyld4::PrebuiltLoader::hiddenFromFlat(a5);
  BOOL v19 = 0;
  BYTE5(v48) = v18;
  WORD3(v48) = *(unsigned __int8 *)(a4 + 1);
  BYTE8(v48) = *(_BYTE *)(a2 + 150);
  BYTE9(v48) = v14;
  BYTE10(v48) = v13;
  BYTE11(v48) = *(_BYTE *)(a2 + 148);
  BYTE12(v48) = v19;
  int v49 = *(_DWORD *)(a2 + 60);
  *(void *)a1 = 0LL;
  *(_WORD *)(a1 + 156) = 0;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(_BYTE *)(a1 + 159) = 1;
  *(_BYTE *)(a1 + 158) = v17;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v20 = (size_t *)(a1 + 40);
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v43 = 0LL;
  char v45 = 0;
  uint64_t v44 = 0LL;
  v46[0] = 0LL;
  v46[1] = 0LL;
  char v47 = 0;
  LODWORD(v21) = dyld4::SyscallDelegate::getDyldCache((uint64_t)a5, &v48, (uint64_t)&v42);
  uint64_t v29 = v42;
  if (v42)
  {
    *(void *)a1 = v42;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)v46;
    *(_BYTE *)(a1 + 156) = v47;
    *(_BYTE *)(a1 + 157) = *(_BYTE *)(v29 + 221) & 1;
    *(void *)(a1 + 24) = v43;
    dyld4::ProcessConfig::DyldCache::setPlatformOSVersion( (dyld4::ProcessConfig::DyldCache *)a1,  (const dyld4::ProcessConfig::Process *)a2);
    *(void *)(a1 + 32) = DyldSharedCache::unslidLoadAddress(*(DyldSharedCache **)a1);
    *(void *)(a1 + 48) = DyldSharedCache::objcHeaderInfoRO(*(DyldSharedCache **)a1);
    *(void *)(a1 + 56) = DyldSharedCache::objcHeaderInfoRW(*(DyldSharedCache **)a1);
    *(void *)(a1 + 64) = DyldSharedCache::objcSelectorHashTable(*(DyldSharedCache **)a1);
    *(void *)(a1 + 72) = DyldSharedCache::objcClassHashTable(*(DyldSharedCache **)a1);
    *(void *)(a1 + 80) = DyldSharedCache::objcProtocolHashTable(*(DyldSharedCache **)a1);
    *(void *)(a1 + 104) = DyldSharedCache::swiftOpt(*(DyldSharedCache **)a1);
    *(_DWORD *)(a1 + 152) = DyldSharedCache::imagesCount(*(DyldSharedCache **)a1);
    *(void *)(a1 + 112) = 0LL;
    uint64_t v30 = *(void *)(a1 + 48);
    int v31 = *(DyldSharedCache **)a1;
    if (v30) {
      *(void *)(a1 + 112) = v30 - (void)v31 + *(void *)(a1 + 32);
    }
    *(void *)(a1 + 120) = 0LL;
    uint64_t v32 = DyldSharedCache::patchTable(v31);
    uint64_t v33 = *(char **)a1;
    uint64_t v34 = *(void *)(*(void *)a1 + 152LL);
    *(void *)(a1 + 128) = v32;
    *(void *)(a1 + 136) = v34;
    if (!BYTE8(v48))
    {
      *(void *)__s = _NSConcreteStackBlock;
      uint64_t v53 = 0x40000000LL;
      uint64_t v54 = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
      v55 = &__block_descriptor_tmp_67;
      uint64_t v56 = a1;
      uint64_t v57 = a4;
      int v59 = 19;
      uint64_t v58 = a5;
      DyldSharedCache::forEachCache(v33, (uint64_t)__s);
    }

    if (!_simple_getenv(*(const char ***)(a2 + 120), "dyld_hw_tpro") || vm_page_size != 0x4000 || *(_BYTE *)(a1 + 158))
    {
      unint64_t v35 = *(unsigned int **)a1;
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 0x40000000LL;
      v41[2] = ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
      v41[3] = &__block_descriptor_tmp_52;
      v41[4] = a1;
      DyldSharedCache::forEachTPRORegion(v35, (uint64_t)v41);
    }

    if (!*(_BYTE *)(a1 + 156)) {
      *(_BYTE *)(a1 + 159) = 0;
    }
    fsid_t v36 = (fsid_t)v46[0];
    if (v46[0] && v46[1])
    {
      size_t v21 = dyld4::SyscallDelegate::fsgetpath(a5, __s, 0x400uLL, v36, v46[1]);
      if (v21 != -1LL)
      {
        size_t v21 = (size_t)lsl::Allocator::strdup(a6, __s);
        size_t *v20 = v21;
      }

      goto LABEL_31;
    }

    uint64_t v40 = "dyld shared region dynamic config data was not set\n";
LABEL_39:
    dyld4::halt(v40, 0LL);
  }

  if (v45) {
    LODWORD(v21) = dyld4::console((dyld4 *)"dyld cache '%s' not loaded: %s\n", v22, *v20, v44);
  }
  if (v16)
  {
    LODWORD(v21) = _platform_strcmp(v16, "private");
    if (!(_DWORD)v21 && !v45)
    {
      uint64_t v40 = "dyld private shared cache could not be found\n";
      goto LABEL_39;
    }
  }

void dyld4::ProcessConfig::DyldCache::setPlatformOSVersion( dyld4::ProcessConfig::DyldCache *this, const dyld4::ProcessConfig::Process *a2)
{
  uint64_t v3 = *(void *)this;
  int v4 = *((_DWORD *)a2 + 15);
  if (*(_DWORD *)(v3 + 16) < 0x170u)
  {
    if (v4 == 10) {
      uint64_t v7 = "/System/DriverKit/usr/lib/system/libdyld.dylib";
    }
    else {
      uint64_t v7 = "/usr/lib/system/libdyld.dylib";
    }
    ImageFromPath = (_DWORD *)DyldSharedCache::getImageFromPath((DyldSharedCache *)v3, v7);
    if (ImageFromPath)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000LL;
      v10[2] = ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke;
      v10[3] = &__block_descriptor_tmp_60;
      v10[4] = this;
      v10[5] = a2;
      dyld3::MachOFile::forEachSupportedPlatform(ImageFromPath, (uint64_t)v10);
    }

    else
    {
      dyld4::console((dyld4 *)"initializeCachePlatformOSVersion(): libdyld.dylib not found for OS version info\n", v9);
    }
  }

  else if (v4 == *(_DWORD *)(v3 + 216))
  {
    int v5 = *(_DWORD *)(v3 + 364);
    *((_DWORD *)this + 36) = v4;
    *((_DWORD *)this + 37) = v5;
  }

  else
  {
    *((void *)this + 18) = *(void *)(v3 + 368);
  }

uint64_t dyld4::ProcessConfig::DyldCache::makeDataConstWritable(char **a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *a1;
  v7[0] = _NSConcreteStackBlock;
  if (a4) {
    int v5 = 19;
  }
  else {
    int v5 = 1;
  }
  v7[1] = 0x40000000LL;
  v7[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke;
  v7[3] = &__block_descriptor_tmp_67;
  v7[4] = a1;
  v7[5] = a2;
  int v8 = v5;
  v7[6] = a3;
  return DyldSharedCache::forEachCache(v4, (uint64_t)v7);
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCacheC2ERNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke( uint64_t a1, int a2, uint64_t a3, vm_size_t size)
{
  return vm_protect(mach_task_self_, *(void *)(*(void *)(a1 + 32) + 24LL) + a3, size, 0, 19);
}

uint64_t dyld4::ProcessConfig::DyldCache::setupDyldCommPage( int a1, uint64_t a2, uint64_t a3, dyld4::SyscallDelegate *this)
{
  BOOL v7 = dyld4::SyscallDelegate::bootVolumeWritable(this);
  uint64_t v8 = *(void *)(a2 + 88);
  uint64_t v9 = 0x800000000LL;
  if (!v7) {
    uint64_t v9 = 0LL;
  }
  unint64_t v10 = v8 & 0xFFFFFFF7FFFFFFFFLL | v9;
  *(void *)(a2 + 88) = v10;
  if (!*(_BYTE *)(a3 + 1))
  {
    unint64_t v10 = v8 & 0xFFFFFFE7FFFFFFB8LL | 1;
    *(void *)(a2 + 88) = v10;
  }

  return dyld4::SyscallDelegate::setDyldCommPageFlags((uint64_t)this, v10);
}

uint64_t ___ZN5dyld413ProcessConfig9DyldCache20setPlatformOSVersionERKNS0_7ProcessE_block_invoke( uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(void *)(result + 32);
  uint64_t v4 = *(void *)(result + 40);
  if (*(_DWORD *)(v4 + 60) == a2) {
    goto LABEL_5;
  }
  if (a2 == 6 && *(_BYTE *)(v4 + 149))
  {
    a2 = 6;
LABEL_5:
    *(_DWORD *)(v3 + 144) = a2;
    *(_DWORD *)(v3 + 148) = a3;
  }

  return result;
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::indexOfPath( DyldSharedCache **this, const char *a2, unsigned int *a3)
{
  uint64_t result = *this;
  if (result) {
    return (DyldSharedCache *)DyldSharedCache::hasImagePath(result, a2, a3);
  }
  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex( DyldSharedCache **this, const mach_header *a2, unsigned int *a3)
{
  return DyldSharedCache::findMachHeaderImageIndex(*this, a2, a3);
}

uint64_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke( uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2;
  v3[3] = &__block_descriptor_tmp_65;
  __int128 v4 = *(_OWORD *)(a1 + 32);
  int v6 = *(_DWORD *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 48);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

ssize_t ___ZNK5dyld413ProcessConfig9DyldCache21makeDataConstWritableERKNS0_7LoggingERKNS_15SyscallDelegateEb_block_invoke_2( ssize_t result, const char *a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 0x40) == 0 && (a7 & 4) != 0)
  {
    ssize_t v8 = result;
    vm_address_t v9 = *(void *)(*(void *)(result + 32) + 24LL) + a3;
    if (*(_BYTE *)(*(void *)(result + 40) + 1LL)) {
      dyld4::console( (dyld4 *)"marking shared cache range 0x%x permissions: 0x%09lX -> 0x%09lX\n",  a2,  *(unsigned int *)(result + 56),  *(void *)(*(void *)(result + 32) + 24LL) + a3,  v9 + size);
    }
    uint64_t result = dyld4::SyscallDelegate::vm_protect( *(dyld4::SyscallDelegate **)(v8 + 48),  mach_task_self_,  v9,  size,  0,  *(_DWORD *)(v8 + 56));
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(*(void *)(v8 + 40) + 1LL)) {
        return dyld4::console((dyld4 *)"failed to mprotect shared cache due to: %d\n", v10, result);
      }
    }
  }

  return result;
}

BOOL dyld4::ProcessConfig::DyldCache::isAlwaysOverridablePath( dyld4::ProcessConfig::DyldCache *this, const char *a2)
{
  return _platform_strcmp((const char *)this, "/usr/lib/system/libdispatch.dylib") == 0;
}

BOOL dyld4::ProcessConfig::DyldCache::isOverridablePath( dyld4::ProcessConfig::DyldCache *this, const char *__s1)
{
  return *((_BYTE *)this + 156) || _platform_strcmp(__s1, "/usr/lib/system/libdispatch.dylib") == 0;
}

DyldSharedCache *dyld4::ProcessConfig::DyldCache::getCanonicalPath(DyldSharedCache **this, const char *a2)
{
  uint64_t result = *this;
  if (result)
  {
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImagePath(DyldSharedCache **this, int a2)
{
  return DyldSharedCache::getIndexedImagePath(*this, a2);
}

uint64_t dyld4::ProcessConfig::DyldCache::getIndexedImageEntry( DyldSharedCache **this, int a2, unint64_t *a3, unint64_t *a4)
{
  return DyldSharedCache::getIndexedImageEntry(*this, a2, a3, a4);
}

dyld4::ProcessConfig::PathOverrides *dyld4::ProcessConfig::PathOverrides::PathOverrides( dyld4::ProcessConfig::PathOverrides *this, dyld4::ProcessConfig::Process *a2, dyld4::ProcessConfig::Security *a3, uint64_t a4, uint64_t a5, uint64_t a6, lsl::Lock **a7)
{
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 34) = *((_BYTE *)a3 + 20) == 0;
  if (*((_BYTE *)a3 + 18))
  {
    strcpy((char *)&__s, "dyld config: ");
    BOOL v14 = (const char **)*((void *)a2 + 14);
    uint64_t v15 = *v14;
    if (*v14)
    {
      uint64_t v16 = v14 + 1;
      do
      {
        dyld4::ProcessConfig::PathOverrides::addEnvVar((char **)this, a2, a3, a7, v15, 0, (char *)&__s);
        BOOL v17 = *v16++;
        uint64_t v15 = v17;
      }

      while (v17);
    }
  }

  else if (*(_BYTE *)(a4 + 8))
  {
    char v18 = (const char **)*((void *)a2 + 14);
    BOOL v19 = *v18;
    if (*v18)
    {
      char v20 = 0;
      size_t v21 = v18 + 1;
      do
      {
        v20 |= _platform_strncmp(v19, "DYLD_", 5uLL) == 0;
        __int128 v22 = *v21++;
        BOOL v19 = v22;
      }

      while (v22);
      if ((v20 & 1) != 0) {
        dyld4::console((dyld4 *)"Note: DYLD_*_PATH env vars disabled by AMFI\n", (const char *)a2);
      }
    }
  }

  if (*((_BYTE *)a3 + 23))
  {
    uint64_t v23 = *(_DWORD **)a2;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 0x40000000LL;
    v28[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke;
    v28[3] = &__block_descriptor_tmp_71;
    v28[4] = this;
    v28[5] = a2;
    v28[6] = a3;
    v28[7] = a7;
    dyld3::MachOFile::forDyldEnv(v23, (uint64_t)v28);
  }

  else if (*(_BYTE *)(a4 + 8))
  {
    *(void *)&__int128 __s = 0LL;
    *((void *)&__s + 1) = &__s;
    uint64_t v30 = 0x2000000000LL;
    char v31 = 0;
    uint64_t v24 = *(_DWORD **)a2;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000LL;
    v27[2] = ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2;
    v27[3] = &unk_18961F098;
    v27[4] = &__s;
    dyld3::MachOFile::forDyldEnv(v24, (uint64_t)v27);
    if (*(_BYTE *)(*((void *)&__s + 1) + 24LL)) {
      dyld4::console((dyld4 *)"Note: LC_DYLD_ENVIRONMENT env vars disabled by AMFI\n", v25);
    }
    _Block_object_dispose(&__s, 8);
  }

  if (*(void *)(a5 + 96)) {
    *((void *)this + 15) = *(void *)(a5 + 88);
  }
  dyld4::ProcessConfig::PathOverrides::processVersionedPaths( this,  (uint64_t)a2,  a6,  a5,  *((_DWORD *)a2 + 15),  *((void *)a2 + 17),  (uint64_t)a7);
  return this;
}

size_t dyld4::ProcessConfig::PathOverrides::addEnvVar( char **this, const dyld4::ProcessConfig::Process *a2, const dyld4::ProcessConfig::Security *a3, lsl::Lock **a4, const char *__s, int a6, char *a7)
{
  size_t result = (size_t)_platform_strchr(__s, 61);
  if (!result) {
    return result;
  }
  uint64_t v15 = (char *)(result + 1);
  if (a6 && _platform_strchr((const char *)(result + 1), 64))
  {
    size_t v16 = _platform_strlen(__s);
    __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v34);
    uint64_t v25 = (char *)&v35[-1] - ((v24 + 1039) & 0xFFFFFFFFFFFFFFF0LL);
    v37[0] = 0LL;
    v37[1] = v37;
    v37[2] = 0x2000000000LL;
    char v38 = 0;
    *uint64_t v25 = 0;
    char v36 = 0;
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 0x40000000LL;
    v35[2] = ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke;
    v35[3] = &unk_18961F168;
    v35[4] = v37;
    v35[5] = a3;
    v35[6] = v25;
    v35[7] = v26;
    v35[8] = a2;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v15, 0LL, &v36, (uint64_t)v35);
    uint64_t v15 = lsl::Allocator::strdup(a4, v25);
    _Block_object_dispose(v37, 8);
  }

  size_t result = _platform_strncmp(__s, "DYLD_LIBRARY_PATH", 0x11uLL);
  if (!(_DWORD)result)
  {
    if (a6) {
      uint64_t v28 = this + 6;
    }
    else {
      uint64_t v28 = this;
    }
    goto LABEL_27;
  }

  size_t result = _platform_strncmp(__s, "DYLD_FRAMEWORK_PATH", 0x13uLL);
  if (!(_DWORD)result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 8LL;
    uint64_t v31 = 56LL;
LABEL_24:
    if (!v29) {
      uint64_t v30 = v31;
    }
    uint64_t v28 = (char **)((char *)this + v30);
    goto LABEL_27;
  }

  size_t result = _platform_strncmp(__s, "DYLD_FALLBACK_FRAMEWORK_PATH", 0x1CuLL);
  if (!(_DWORD)result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 24LL;
    uint64_t v31 = 72LL;
    goto LABEL_24;
  }

  size_t result = _platform_strncmp(__s, "DYLD_FALLBACK_LIBRARY_PATH", 0x1AuLL);
  if (!(_DWORD)result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 16LL;
    uint64_t v31 = 64LL;
    goto LABEL_24;
  }

  size_t result = _platform_strncmp(__s, "DYLD_VERSIONED_FRAMEWORK_PATH", 0x1CuLL);
  if (!(_DWORD)result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 40LL;
    uint64_t v31 = 80LL;
    goto LABEL_24;
  }

  size_t result = _platform_strncmp(__s, "DYLD_VERSIONED_LIBRARY_PATH", 0x1AuLL);
  if (!(_DWORD)result)
  {
    BOOL v29 = a6 == 0;
    uint64_t v30 = 32LL;
    uint64_t v31 = 88LL;
    goto LABEL_24;
  }

  uint64_t v27 = (dyld4::ProcessConfig::PathOverrides *)_platform_strncmp(__s, "DYLD_INSERT_LIBRARIES", 0x15uLL);
  if (!(_DWORD)v27)
  {
    size_t result = (size_t)dyld4::ProcessConfig::PathOverrides::setString(v27, a4, this + 12, v15);
    uint64_t v32 = this[12];
    if (*v32)
    {
      int v33 = 1;
      *((_DWORD *)this + 35) = 1;
      while (1)
      {
        if (*v32 == 58)
        {
          *((_DWORD *)this + 35) = ++v33;
        }

        else if (!*v32)
        {
          goto LABEL_28;
        }

        ++v32;
      }
    }

    goto LABEL_28;
  }

  size_t result = _platform_strncmp(__s, "DYLD_IMAGE_SUFFIX", 0x11uLL);
  if (!(_DWORD)result)
  {
    uint64_t v28 = this + 13;
    goto LABEL_27;
  }

  size_t result = _platform_strncmp(__s, "DYLD_ROOT_PATH", 0xEuLL);
  if (!(_DWORD)result)
  {
    size_t result = dyld3::MachOFile::isSimulatorPlatform(*((_DWORD *)a2 + 15), 0LL);
    if ((_DWORD)result)
    {
      uint64_t v28 = this + 14;
LABEL_27:
      size_t result = (size_t)dyld4::ProcessConfig::PathOverrides::setString( (dyld4::ProcessConfig::PathOverrides *)result,  a4,  v28,  v15);
    }
  }

LABEL_28:
  if (a7)
  {
    size_t result = _platform_strncmp(__s, "DYLD_", 5uLL);
    if (!(_DWORD)result)
    {
      strlcat(a7, __s, 0x800uLL);
      return strlcat(a7, " ", 0x800uLL);
    }
  }

  return result;
}

          size_t result = Diagnostics::error( *(vm_address_t **)(v5 + 56),  "terminator 0x%0X does not point within executable segment");
        }
      }
    }

    *a4 = 1;
  }

  return result;
}

size_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke( uint64_t a1, char *__s)
{
  return dyld4::ProcessConfig::PathOverrides::addEnvVar( *(char ***)(a1 + 32),  *(const dyld4::ProcessConfig::Process **)(a1 + 40),  *(const dyld4::ProcessConfig::Security **)(a1 + 48),  *(lsl::Lock ***)(a1 + 56),  __s,  1,  0LL);
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverridesC2ERKNS0_7ProcessERKNS0_8SecurityERKNS0_7LoggingERKNS0_9DyldCacheERNS_15SyscallDelegateERN3lsl9AllocatorE_block_invoke_2( uint64_t a1, char *__s1)
{
  uint64_t result = _platform_strncmp(__s1, "DYLD_", 5uLL);
  if (!(_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::processVersionedPaths( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  char v21 = 0;
  uint64_t v13 = a1[4];
  uint64_t v14 = a1[11];
  if (v13 | v14)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000LL;
    v19[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke;
    v19[3] = &__block_descriptor_tmp_81;
    v19[4] = a1;
    v19[5] = a3;
    v19[6] = a4;
    v19[7] = a7;
    int v20 = a5;
    v19[8] = a6;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList(v13, v14, &v21, (uint64_t)v19);
  }

  uint64_t result = a1[5];
  uint64_t v16 = a1[10];
  if (result | v16)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3;
    v17[3] = &__block_descriptor_tmp_84;
    v17[4] = a1;
    v17[5] = a3;
    v17[6] = a4;
    v17[7] = a7;
    int v18 = a5;
    v17[8] = a6;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v16, &v21, (uint64_t)v17);
  }

  return result;
}

size_t dyld4::ProcessConfig::PathOverrides::checkVersionedPath( dyld4::ProcessConfig::PathOverrides *a1, int a2, DyldSharedCache **a3, lsl::Lock **a4, dyld3 *a5, int a6, uint64_t a7)
{
  size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, a5, a6, a7, (uint64_t)&v23, (uint64_t)v26);
  if (!(_DWORD)result) {
    return result;
  }
  size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, (dyld3 *)v26, a6, a7, (uint64_t)&v22, (uint64_t)__s2);
  if ((result & 1) == 0)
  {
    if (!*a3
      || !DyldSharedCache::hasImagePath(*a3, v26, &v21)
      || (v24[0] = 0LL,
          unint64_t v20 = 0LL,
          IndexedImageEntry = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry(*a3, v21, v24, &v20),
          !dyld3::MachOFile::getDylibInstallName(IndexedImageEntry, (const char **)&__source, &v18, &v22)))
    {
      uint64_t v17 = v26;
      return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
    }

    size_t result = strlcpy(__s2, __source, 0x400uLL);
  }

  if (v23 > v22)
  {
    uint64_t v15 = (char *)a1 + 128;
    do
    {
      uint64_t v15 = *(char **)v15;
      if (!v15)
      {
        uint64_t v17 = __s2;
        return (size_t)dyld4::ProcessConfig::PathOverrides::addPathOverride(a1, a4, v17, (const char *)a5);
      }
    }

    while (_platform_strcmp(*((const char **)v15 + 1), __s2));
    size_t result = dyld4::SyscallDelegate::getDylibInfo(a2, *((dyld3 **)v15 + 2), a6, a7, (uint64_t)&v20, (uint64_t)v24);
    if ((_DWORD)result)
    {
      if (v23 > v20)
      {
        size_t result = (size_t)lsl::Allocator::strdup(a4, (const char *)a5);
        *((void *)v15 + 2) = result;
      }
    }
  }

  return result;
}

char *dyld4::ProcessConfig::PathOverrides::addPathOverride( dyld4::ProcessConfig::PathOverrides *this, lsl::Lock **a2, const char *a3, const char *a4)
{
  ssize_t v8 = lsl::Allocator::malloc(a2, 0x18uLL);
  *ssize_t v8 = 0LL;
  v8[1] = lsl::Allocator::strdup(a2, a3);
  size_t result = lsl::Allocator::strdup(a2, a4);
  v8[2] = result;
  unint64_t v12 = (void *)*((void *)this + 16);
  int v11 = (void *)((char *)this + 128);
  for (i = v12; i; i = (void *)*i)
    int v11 = i;
  *int v11 = v8;
  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachInColonList( uint64_t result, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v6 = 0LL;
  v21[0] = result;
  v21[1] = a2;
  while (2)
  {
    BOOL v7 = (char *)v21[v6];
    if (!v7) {
      goto LABEL_10;
    }
    size_t v8 = _platform_strlen((const char *)v21[v6]);
    __chkstk_darwin(v8, v9, v10, v11, v12, v13, v14, v15, v20);
    uint64_t v17 = (char *)&v21[-1] - ((v16 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v18 = v7 + 1;
    uint64_t v19 = v7;
    while (*(v18 - 1) == 58)
    {
      memmove(v17, v19, v7 - v19);
      v7[v17 - v19] = 0;
      size_t result = (*(uint64_t (**)(uint64_t, char *, _BYTE *))(a4 + 16))(a4, v17, a3);
      uint64_t v19 = v18;
      if (*a3) {
        return result;
      }
LABEL_8:
      ++v18;
      ++v7;
    }

    if (*(v18 - 1)) {
      goto LABEL_8;
    }
    size_t result = (*(uint64_t (**)(uint64_t, char *, _BYTE *))(a4 + 16))(a4, v19, a3);
    if (!*a3)
    {
LABEL_10:
      if (++v6 == 2) {
        return result;
      }
      continue;
    }

    return result;
  }

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke( uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_80;
  v4[4] = v2;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 72);
  __int128 v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 0, (uint64_t)v4);
}

size_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_2( uint64_t a1, dyld3 *a2)
{
  return dyld4::ProcessConfig::PathOverrides::checkVersionedPath( *(dyld4::ProcessConfig::PathOverrides **)(a1 + 32),  *(void *)(a1 + 40),  *(DyldSharedCache ***)(a1 + 48),  *(lsl::Lock ***)(a1 + 56),  a2,  *(_DWORD *)(a1 + 72),  *(void *)(a1 + 64));
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_3( uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4;
  v4[3] = &__block_descriptor_tmp_83;
  v4[4] = v2;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 72);
  __int128 v6 = *(_OWORD *)(a1 + 56);
  return dyld4::SyscallDelegate::forEachInDirectory(v5, a2, 1, (uint64_t)v4);
}

unint64_t ___ZN5dyld413ProcessConfig13PathOverrides21processVersionedPathsERKNS0_7ProcessERNS_15SyscallDelegateERKNS0_9DyldCacheEN5dyld38PlatformERKNSA_11GradedArchsERN3lsl9AllocatorE_block_invoke_4( uint64_t a1, char *__s)
{
  unsigned int v4 = *(dyld4::ProcessConfig::PathOverrides **)(a1 + 32);
  unint64_t result = _platform_strlen(__s);
  if (result >= 0xA)
  {
    unint64_t result = _platform_strcmp(&__s[result - 10], ".framework");
    if (!(_DWORD)result)
    {
      strlcpy(__dst, __s, 0x400uLL);
      __int128 v6 = strrchr(__s, 47);
      strlcat(__dst, v6, 0x400uLL);
      *strrchr(__dst, 46) = 0;
      return dyld4::ProcessConfig::PathOverrides::checkVersionedPath( v4,  *(void *)(a1 + 40),  *(DyldSharedCache ***)(a1 + 48),  *(lsl::Lock ***)(a1 + 56),  (dyld3 *)__dst,  *(_DWORD *)(a1 + 72),  *(void *)(a1 + 64));
    }
  }

  return result;
}

void dyld4::ProcessConfig::PathOverrides::forEachInsertedDylib(uint64_t a1, uint64_t a2)
{
  v4[0] = 0LL;
  v4[1] = v4;
  v4[2] = 0x2000000000LL;
  v5[0] = 0;
  uint64_t v2 = *(_BYTE **)(a1 + 96);
  if (v2 && *v2)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000LL;
    v3[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke;
    v3[3] = &unk_18961F140;
    void v3[4] = a2;
    v3[5] = v4;
    dyld4::ProcessConfig::PathOverrides::forEachInColonList((uint64_t)v2, 0LL, v5, (uint64_t)v3);
  }

  _Block_object_dispose(v4, 8);
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachInsertedDylibEU13block_pointerFvPKcRbE_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a2,  *(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

char *dyld4::ProcessConfig::PathOverrides::setString( dyld4::ProcessConfig::PathOverrides *this, lsl::Lock **a2, char **a3, const char *__s)
{
  if (*a3)
  {
    _platform_strlen(*a3);
    size_t v7 = _platform_strlen(__s);
    __chkstk_darwin(v7, v8, v9, v10, v11, v12, v13, v14, v19);
    uint64_t v16 = (char *)&v19 - v15;
    uint64_t v17 = strcpy((char *)&v19 - v15, *a3);
    *(_WORD *)&v16[_platform_strlen(v17)] = 58;
    strcat(v16, __s);
    unint64_t result = lsl::Allocator::strdup(a2, v16);
  }

  else
  {
    unint64_t result = lsl::Allocator::strdup(a2, __s);
  }

  *a3 = result;
  return result;
}

uint64_t ___ZN5dyld413ProcessConfig13PathOverrides9addEnvVarERKNS0_7ProcessERKNS0_8SecurityERN3lsl9AllocatorEPKcbPc_block_invoke( uint64_t result, char *__s1)
{
  uint64_t v3 = result;
  if (*(_BYTE *)(*(void *)(result + 40) + 16LL) || *__s1 != 64)
  {
    if (*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL)) {
      strlcat(*(char **)(result + 48), ":", *(void *)(result + 56));
    }
    if (_platform_strncmp(__s1, "@executable_path/", 0x11uLL))
    {
      int v4 = _platform_strncmp(__s1, "@loader_path/", 0xDuLL);
      size_t v5 = *(void *)(v3 + 56);
      __int128 v6 = *(const char **)(*(void *)(v3 + 64) + 8LL);
      size_t v7 = *(char **)(v3 + 48);
      if (v4)
      {
LABEL_12:
        unint64_t result = strlcpy(v7, v6, v5);
        *(_BYTE *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = 1;
        return result;
      }

      strlcat(v7, v6, v5);
      uint64_t v8 = *(const char **)(v3 + 48);
      unint64_t result = (uint64_t)strrchr(v8, 47);
      if (!result) {
        return result;
      }
      size_t v7 = (char *)(result + 1);
      __int128 v6 = __s1 + 13;
    }

    else
    {
      strlcat(*(char **)(v3 + 48), *(const char **)(*(void *)(v3 + 64) + 8LL), *(void *)(v3 + 56));
      uint64_t v8 = *(const char **)(v3 + 48);
      unint64_t result = (uint64_t)strrchr(v8, 47);
      if (!result) {
        return result;
      }
      size_t v7 = (char *)(result + 1);
      __int128 v6 = __s1 + 17;
    }

    size_t v5 = *(void *)(v3 + 56) + v8 - v7;
    goto LABEL_12;
  }

  return result;
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachDylibFallback( uint64_t a1, unsigned int a2, int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 64);
  if (result | v9)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    v11[2] = ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v11[3] = &unk_18961F190;
    v11[4] = a5;
    v11[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(result, v9, a4, (uint64_t)v11);
  }

  if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x83D) != 0)
    {
      if (*(_DWORD *)(a1 + 136) != 2)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/usr/local/lib",  15LL,  a4);
        if (*a4) {
          return result;
        }
      }
    }

    else if (((1 << a2) & 0x13C0) == 0)
    {
      if (a2 == 1)
      {
        int v10 = *(_DWORD *)(a1 + 136);
        if (v10 == 1) {
          return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/usr/lib",  15LL,  a4);
        }
        if (!v10)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/usr/local/lib",  15LL,  a4);
          if (!*a4) {
            return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/usr/lib",  15LL,  a4);
          }
        }
      }

      return result;
    }

    if (*(_DWORD *)(a1 + 136) != 2) {
      return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))(a5, "/usr/lib", 15LL, a4);
    }
  }

  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides20forEachDylibFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a2,  14LL,  *(void *)(a1 + 40));
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback( uint64_t result, unsigned int a2, int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(result + 24);
  uint64_t v9 = *(void *)(result + 72);
  if (v8 | v9)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    v11[2] = ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke;
    v11[3] = &unk_18961F1B8;
    v11[4] = a5;
    v11[5] = a4;
    return dyld4::ProcessConfig::PathOverrides::forEachInColonList(v8, v9, a4, (uint64_t)v11);
  }

  else if (a3 && a2 <= 0xC)
  {
    if (((1 << a2) & 0x1BFD) != 0)
    {
      if (*(_DWORD *)(result + 136) != 2) {
        return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/System/Library/Frameworks",  15LL,  a4);
      }
    }

    else if (a2 == 1)
    {
      int v10 = *(_DWORD *)(result + 136);
      if (v10 == 1) {
        return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/System/Library/Frameworks",  15LL,  a4);
      }
      if (!v10)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/Library/Frameworks",  15LL,  a4);
        if (!*a4) {
          return (*(uint64_t (**)(uint64_t, const char *, uint64_t, _BYTE *))(a5 + 16))( a5,  "/System/Library/Frameworks",  15LL,  a4);
        }
      }
    }
  }

  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides24forEachFrameworkFallbackEN5dyld38PlatformEbRbU13block_pointerFvPKcNS1_4TypeES4_E_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a2,  14LL,  *(void *)(a1 + 40));
}

size_t dyld4::ProcessConfig::PathOverrides::addSuffix( dyld4::ProcessConfig::PathOverrides *this, const char *a2, const char *a3, char *__dst)
{
  size_t v7 = strrchr(__dst, 47);
  if (v7) {
    uint64_t v8 = v7 + 1;
  }
  else {
    uint64_t v8 = __dst;
  }
  uint64_t v9 = strrchr(v8, 46);
  if (v9)
  {
    int v10 = v9;
    strlcpy(v9, a3, 0x400uLL);
    uint64_t v11 = &v10[_platform_strlen(a3)];
    uint64_t v12 = &a2[v10 - __dst];
  }

  else
  {
    uint64_t v11 = __dst;
    uint64_t v12 = a3;
  }

  return strlcat(v11, v12, 0x400uLL);
}

uint64_t dyld4::ProcessConfig::PathOverrides::forEachImageSuffix( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 104);
  if (!v10) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, a2, a3, a4);
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke;
  v12[3] = &unk_18961F1E0;
  v12[4] = a5;
  v12[5] = a1;
  v12[6] = a2;
  void v12[7] = a4;
  uint64_t result = dyld4::ProcessConfig::PathOverrides::forEachInColonList(v10, 0LL, a4, (uint64_t)v12);
  if (!*a4) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, a2, a3, a4);
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachImageSuffixEPKcNS1_4TypeERbU13block_pointerFvS3_S4_S5_E_block_invoke( uint64_t a1, const char *a2)
{
  int v4 = *(const char **)(a1 + 48);
  size_t v5 = _platform_strlen(v4);
  __int128 v6 = (dyld4::ProcessConfig::PathOverrides *)_platform_strlen(a2);
  dyld4::ProcessConfig::PathOverrides::addSuffix( v6,  v4,  a2,  (char *)&v8 - (((unint64_t)v6 + v5 + 23) & 0xFFFFFFFFFFFFFFF0LL));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

const char *dyld4::ProcessConfig::PathOverrides::forEachPathVariant( uint64_t a1, dyld4::Utils *a2, const char *a3, int a4, int a5, _BYTE *a6, uint64_t a7)
{
  int v97 = a5;
  unsigned int v10 = a3;
  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath( (dyld4::ProcessConfig::PathOverrides *)a1,  a2,  a3);
  uint64_t v14 = result;
  if (result)
  {
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(a1 + 56);
    if (!(v15 | v16)) {
      goto LABEL_10;
    }
    v101[0] = _NSConcreteStackBlock;
    v101[1] = 0x40000000LL;
    v101[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke;
    v101[3] = &unk_18961F208;
    v101[6] = _platform_strlen(result);
    v101[7] = v14;
    v101[8] = a6;
    v101[4] = a7;
    v101[5] = a1;
    uint64_t v17 = v101;
    uint64_t v18 = v15;
    uint64_t v19 = v16;
  }

  else
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v21 = *(void *)(a1 + 48);
    if (!(*(void *)a1 | v21)) {
      goto LABEL_10;
    }
    unsigned int v22 = strrchr((const char *)a2, 47);
    uint64_t v96 = a6;
    uint64_t v23 = a7;
    unsigned int v24 = v10;
    int v25 = a4;
    if (v22) {
      uint64_t v26 = v22 + 1;
    }
    else {
      uint64_t v26 = (const char *)a2;
    }
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 0x40000000LL;
    v100[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2;
    v100[3] = &unk_18961F230;
    v100[6] = _platform_strlen(v26);
    v100[7] = v26;
    a4 = v25;
    unsigned int v10 = v24;
    a7 = v23;
    uint64_t v14 = 0LL;
    a6 = v96;
    v100[8] = v96;
    v100[4] = a7;
    v100[5] = a1;
    uint64_t v17 = v100;
    uint64_t v18 = v20;
    uint64_t v19 = v21;
  }

  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachInColonList(v18, v19, a6, (uint64_t)v17);
LABEL_10:
  if (*a6) {
    return result;
  }
  uint64_t v27 = a1 + 128;
  while (1)
  {
    uint64_t v27 = *(void *)v27;
    if (!v27) {
      break;
    }
    if (!_platform_strcmp(*(const char **)(v27 + 8), (const char *)a2)) {
      return (const char *)(*(uint64_t (**)(uint64_t, void, uint64_t, _BYTE *))(a7 + 16))( a7,  *(void *)(v27 + 16),  1LL,  a6);
    }
  }

  if (*(_BYTE *)a2 == 64) {
    goto LABEL_17;
  }
  if (v10 == 6)
  {
    int v29 = _platform_strncmp((const char *)a2, "/System/iOSSupport/", 0x13uLL);
    if (*(void *)(a1 + 120))
    {
      if (v29)
      {
        size_t v30 = _platform_strlen((const char *)a2);
        size_t v31 = v30 + 26;
        __chkstk_darwin(v30, v32, v33, v34, v35, v36, v37, v38, (uint64_t)v96);
        LODWORD(v96) = a4;
        uint64_t v40 = (char *)&v96 - ((v39 + 41) & 0xFFFFFFFFFFFFFFF0LL);
        strlcpy(v40, "/System/iOSSupport", v31);
        strlcat(v40, (const char *)a2, v31);
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v40, 3LL, a6, a7);
        if (*a6) {
          return result;
        }
        size_t v41 = _platform_strlen(*(const char **)(a1 + 120));
        size_t v42 = _platform_strlen((const char *)a2);
        size_t v43 = v41 + v42 + 26;
        __chkstk_darwin(v42, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v96);
        uint64_t v52 = (char *)&v96 - v51;
        strlcpy((char *)&v96 - v51, *(const char **)(a1 + 120), v43);
        strlcat(v52, "/System/iOSSupport", v43);
        strlcat(v52, (const char *)a2, v43);
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)v52, 6LL, a6, a7);
        if (*a6) {
          return result;
        }
        size_t v53 = _platform_strlen((const char *)a2);
        size_t v54 = v53 + 26;
        __chkstk_darwin(v53, v55, v56, v57, v58, v59, v60, v61, (uint64_t)v96);
        uint64_t v63 = (char *)&v96 - ((v62 + 41) & 0xFFFFFFFFFFFFFFF0LL);
        strlcpy(v63, "/System/iOSSupport", v54);
        strlcat(v63, (const char *)a2, v54);
        uint64_t v64 = (uint64_t)v63;
        a4 = (int)v96;
        uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, v64, 4LL, a6, a7);
        if (*a6) {
          return result;
        }
      }

      goto LABEL_29;
    }

    if (v29)
    {
      size_t v84 = _platform_strlen((const char *)a2);
      LODWORD(v96) = 6;
      size_t v85 = v84 + 26;
      __chkstk_darwin(v84, v86, v87, v88, v89, v90, v91, v92, (uint64_t)v96);
      int v94 = a4;
      uint64_t v95 = (char *)&v96 - ((v93 + 41) & 0xFFFFFFFFFFFFFFF0LL);
      strlcpy(v95, "/System/iOSSupport", v85);
      strlcat(v95, (const char *)a2, v85);
      uint64_t v78 = a1;
      uint64_t v79 = (uint64_t)v95;
      a4 = v94;
      uint64_t v80 = 4LL;
      goto LABEL_37;
    }
  }

  else if (*(void *)(a1 + 120))
  {
LABEL_29:
    uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 8LL, a6, a7);
    if (*a6) {
      return result;
    }
    size_t v65 = _platform_strlen(*(const char **)(a1 + 120));
    size_t v66 = _platform_strlen((const char *)a2);
    LODWORD(v96) = v10;
    size_t v67 = v65 + v66 + 8;
    __chkstk_darwin(v66, v68, v69, v70, v71, v72, v73, v74, (uint64_t)v96);
    int v75 = a4;
    v77 = (char *)&v96 - v76;
    strlcpy((char *)&v96 - v76, *(const char **)(a1 + 120), v67);
    strlcat(v77, (const char *)a2, v67);
    uint64_t v78 = a1;
    uint64_t v79 = (uint64_t)v77;
    a4 = v75;
    uint64_t v80 = 7LL;
LABEL_37:
    uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(v78, v79, v80, a6, a7);
    unsigned int v10 = v96;
    if (*a6) {
      return result;
    }
  }

LABEL_17:
  uint64_t result = (const char *)dyld4::ProcessConfig::PathOverrides::forEachImageSuffix(a1, (uint64_t)a2, 9LL, a6, a7);
  if (!*a6 && (v97 & 1) == 0)
  {
    if (v14)
    {
      size_t v28 = _platform_strlen(v14);
      v99[0] = _NSConcreteStackBlock;
      v99[1] = 0x40000000LL;
      v99[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3;
      v99[3] = &unk_18961F258;
      v99[6] = v28;
      v99[7] = v14;
      v99[8] = a2;
      v99[9] = a6;
      v99[4] = a7;
      v99[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachFrameworkFallback(a1, v10, a4, a6, (uint64_t)v99);
    }

    else
    {
      v81 = strrchr((const char *)a2, 47);
      if (v81) {
        v82 = v81 + 1;
      }
      else {
        v82 = (const char *)a2;
      }
      size_t v83 = _platform_strlen(v82);
      v98[0] = _NSConcreteStackBlock;
      v98[1] = 0x40000000LL;
      v98[2] = ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4;
      v98[3] = &unk_18961F280;
      v98[6] = v83;
      v98[7] = v82;
      v98[8] = a2;
      v98[9] = a6;
      v98[4] = a7;
      v98[5] = a1;
      return (const char *)dyld4::ProcessConfig::PathOverrides::forEachDylibFallback(a1, v10, a4, a6, (uint64_t)v98);
    }
  }

  return result;
}

      ++v5;
      v4 += 4;
    }
  }

  *(_BYTE *)(a4 + 120) = v13;
}

  unsigned int v10 = (_BYTE *)(*this)++;
  *unsigned int v10 = (_BYTE)a2 + 48;
  return this;
}

    if (dyld3::MachOFile::builtForPlatform(v11, v12, 1)) {
      return v8;
    }
LABEL_18:
    if (!a4)
    {
LABEL_33:
      if (a2 == 6)
      {
LABEL_34:
        uint64_t v8 = 1LL;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 1)) {
          return v8;
        }
      }

      return 0LL;
    }

    if (a2 == 12)
    {
      uint64_t v8 = 1LL;
      uint64_t v13 = a1;
      uint64_t v14 = 7;
    }

    else
    {
      if (a2 != 11) {
        goto LABEL_24;
      }
      uint64_t v8 = 1LL;
      uint64_t v13 = a1;
      uint64_t v14 = 2;
    }

    if (dyld3::MachOFile::builtForPlatform(v13, v14, 1)) {
      return v8;
    }
LABEL_24:
    HIDWORD(v15) = a2;
    LODWORD(v15) = a2 - 6;
    switch((v15 >> 1))
    {
      case 0u:
        goto LABEL_34;
      case 5u:
        uint64_t v8 = 1LL;
        if (dyld3::MachOFile::builtForPlatform(a1, 1, 0)) {
          return v8;
        }
        if (a2 == 6) {
          goto LABEL_34;
        }
        if (a2 == 20) {
          goto LABEL_32;
        }
        if (a2 != 18) {
          return 0LL;
        }
LABEL_29:
        uint64_t v8 = 1LL;
        if (dyld3::MachOFile::builtForPlatform(a1, 2, 1)) {
          return v8;
        }
        if (a2 == 6) {
          goto LABEL_34;
        }
        if (a2 != 20) {
          return 0LL;
        }
LABEL_32:
        uint64_t v8 = 1LL;
        if (!dyld3::MachOFile::builtForPlatform(a1, 3, 1)) {
          goto LABEL_33;
        }
        return v8;
      case 6u:
        goto LABEL_29;
      case 7u:
        goto LABEL_32;
      default:
        return 0LL;
    }
  }

  return 1LL;
}

uint64_t dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath( dyld4::ProcessConfig::PathOverrides *this, dyld4::Utils *a2, const char *a3)
{
  unsigned int v24 = this;
  int v4 = dyld4::Utils::strrstr(a2, ".framework/", a3);
  if (v4) {
    BOOL v11 = v4 >= (char *)a2;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    return 0LL;
  }
  uint64_t v12 = (dyld4::Utils *)v4;
  for (uint64_t i = 0LL; ; ++i)
  {
    if (v12 == a2 || *(_BYTE *)v12 == 47)
    {
      BOOL v14 = v12 != a2;
      uint64_t v15 = v12 == a2 ? (uint64_t)v12 : (uint64_t)v12 + 1;
      __chkstk_darwin((uint64_t)v4, v15, v5, v6, v7, v8, v9, v10, (uint64_t)v24);
      uint64_t v17 = (char *)&v24 - v16;
      strncpy((char *)&v24 - v16, v18, i - v14);
      v17[i - v14] = 0;
      int v4 = strrchr((const char *)a2, 47);
      if (v4)
      {
        uint64_t v19 = v4;
        uint64_t v20 = v4 + 1;
        int v4 = (char *)_platform_strcmp(v17, v4 + 1);
        if (!(_DWORD)v4) {
          break;
        }
        uint64_t v21 = (const char *)*((void *)v24 + 13);
        if (v21)
        {
          int v4 = (char *)_platform_strncmp(v17, v20, i - v14);
          if (!(_DWORD)v4)
          {
            int v4 = (char *)_platform_strcmp(v21, &v19[i - v14 + 1]);
            if (!(_DWORD)v4) {
              break;
            }
          }
        }
      }
    }

    uint64_t v12 = (dyld4::Utils *)((char *)v12 - 1);
    if (v12 < a2) {
      return 0LL;
    }
  }

  if (v12 == a2) {
    char v23 = 2;
  }
  else {
    char v23 = 1;
  }
  return (uint64_t)v12 + (v23 & 1);
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke( uint64_t a1, char *__s)
{
  uint64_t v4 = *(void *)(a1 + 40);
  size_t v5 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v6 = v5 + 8;
  uint64_t v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix( v4,  (uint64_t)v7,  0LL,  *(_BYTE **)(a1 + 64),  *(void *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_2( uint64_t a1, char *__s)
{
  uint64_t v4 = *(void *)(a1 + 40);
  size_t v5 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v6 = v5 + 8;
  uint64_t v7 = (char *)&v9 - ((v5 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  strlcpy(v7, __s, v5 + 8);
  strlcat(v7, "/", v6);
  strlcat(v7, *(const char **)(a1 + 56), v6);
  return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix( v4,  (uint64_t)v7,  0LL,  *(_BYTE **)(a1 + 64),  *(void *)(a1 + 32));
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_3( uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  size_t v7 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v8 = v7 + 8;
  uint64_t v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  uint64_t result = _platform_strcmp(*(const char **)(a1 + 64), v9);
  if ((_DWORD)result) {
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix( v6,  (uint64_t)v9,  a3,  *(_BYTE **)(a1 + 72),  *(void *)(a1 + 32));
  }
  return result;
}

uint64_t ___ZNK5dyld413ProcessConfig13PathOverrides18forEachPathVariantEPKcN5dyld38PlatformEbbRbU13block_pointerFvS3_NS1_4TypeES6_E_block_invoke_4( uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  size_t v7 = _platform_strlen(__s) + *(void *)(a1 + 48);
  size_t v8 = v7 + 8;
  uint64_t v9 = (char *)&v11 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  strlcpy(v9, __s, v7 + 8);
  strlcat(v9, "/", v8);
  strlcat(v9, *(const char **)(a1 + 56), v8);
  uint64_t result = _platform_strcmp(v9, *(const char **)(a1 + 64));
  if ((_DWORD)result) {
    return dyld4::ProcessConfig::PathOverrides::forEachImageSuffix( v6,  (uint64_t)v9,  a3,  *(_BYTE **)(a1 + 72),  *(void *)(a1 + 32));
  }
  return result;
}

const char *dyld4::ProcessConfig::PathOverrides::typeName(unsigned int a1)
{
  if (a1 > 0xF) {
    return "unknown";
  }
  else {
    return (&off_18961F2A0)[a1];
  }
}

DyldSharedCache *dyld4::ProcessConfig::canonicalDylibPathInCache(DyldSharedCache **this, const char *a2)
{
  return dyld4::ProcessConfig::DyldCache::getCanonicalPath(this + 30, a2);
}

void *dyld4::PseudoDylib::create( lsl::Lock **a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    dyld4::PseudoDylib::create();
  }
  if (!a5) {
    dyld4::PseudoDylib::create();
  }
  if (a2 <= a3 || a2 - a4 >= a3) {
    dyld4::PseudoDylib::create();
  }
  uint64_t result = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x28uLL);
  *uint64_t result = a3;
  result[1] = a4;
  result[2] = a5;
  result[3] = a6;
  result[4] = a2;
  return result;
}

const char *dyld4::PseudoDylib::loadableAtPath(dyld4::PseudoDylib *this, const char *__s2)
{
  uint64_t v3 = *(uint64_t (**)(void, void, const char *))(*((void *)this + 2) + 48LL);
  if (v3) {
    return (const char *)v3(*((void *)this + 3), *(void *)this, __s2);
  }
  return __s2;
}

uint64_t dyld4::PseudoDylib::disposeString(uint64_t (***this)(char *), char *a2)
{
  return (*this[2])(a2);
}

uint64_t dyld4::PseudoDylib::initialize(dyld4::PseudoDylib *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 2) + 8LL))( *((void *)this + 3),  *(void *)this);
}

uint64_t dyld4::PseudoDylib::lookupSymbols( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    dyld4::PseudoDylib::lookupSymbols();
  }
  if (a3 != a7) {
    dyld4::PseudoDylib::lookupSymbols();
  }
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(a1[2] + 24LL))(a1[3], *a1, a2, a3, a4);
}

uint64_t dyld4::PseudoDylib::finalizeRequestedSymbols(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(a1[2] + 56LL);
  if (v3) {
    return v3(a1[3], *a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PseudoDylib::lookupAddress(dyld4::PseudoDylib *this, const void *a2, dl_info *a3)
{
  return (*(uint64_t (**)(void, void, const void *, dl_info *))(*((void *)this + 2) + 32LL))( *((void *)this + 3),  *(void *)this,  a2,  a3);
}

uint64_t dyld4::PseudoDylib::findUnwindSections(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    dyld4::PseudoDylib::findUnwindSections();
  }
  if (!a4) {
    dyld4::PseudoDylib::findUnwindSections();
  }
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(a1[2] + 40LL))(a1[3], *a1, a2, a3);
}

double dyld4::RuntimeLocks::RuntimeLocks(dyld4::RuntimeLocks *this)
{
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

uint64_t dyld4::RuntimeLocks::withLoadersReadLock(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (!v4) {
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  (*(void (**)(uint64_t, void *, void))(*(void *)v4 + 104LL))(v4, a1 + 1, 0LL);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(void, void *))(*(void *)*a1 + 112LL))(*a1, a1 + 1);
}

uint64_t dyld4::RuntimeLocks::withNotifiersReadLock(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (!v4) {
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  (*(void (**)(uint64_t, void *, void))(*(void *)v4 + 104LL))(v4, a1 + 2, 0LL);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(void, void *))(*(void *)*a1 + 112LL))(*a1, a1 + 2);
}

uint64_t dyld4::RuntimeLocks::withTLVLock(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (!v4) {
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  }
  (*(void (**)(uint64_t, void *, void))(*(void *)v4 + 104LL))(v4, a1 + 3, 0LL);
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  return (*(uint64_t (**)(void, void *))(*(void *)*a1 + 112LL))(*a1, a1 + 3);
}

unint64_t dyld4::RuntimeLocks::takeLockBeforeFork(dyld4::RuntimeLocks *this)
{
  unint64_t result = *(void *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *, void))(*(void *)result + 104LL))( result,  (char *)this + 8,  0LL);
    (*(void (**)(void, char *, void))(**(void **)this + 104LL))( *(void *)this,  (char *)this + 16,  0LL);
    (*(void (**)(void, char *, void))(**(void **)this + 104LL))( *(void *)this,  (char *)this + 24,  0LL);
    unint64_t result = (***(uint64_t (****)(void))this)(*(void *)this);
    if (result >= 6)
    {
      (*(void (**)(void, char *, void))(**(void **)this + 184LL))( *(void *)this,  (char *)this + 40,  0LL);
      return (*(uint64_t (**)(void, char *, void))(**(void **)this + 184LL))( *(void *)this,  (char *)this + 44,  0LL);
    }
  }

  return result;
}

unint64_t dyld4::RuntimeLocks::releaseLockInForkParent(dyld4::RuntimeLocks *this)
{
  unint64_t result = *(void *)this;
  if (result)
  {
    (*(void (**)(unint64_t, char *))(*(void *)result + 112LL))(result, (char *)this + 8);
    (*(void (**)(void, char *))(**(void **)this + 112LL))(*(void *)this, (char *)this + 16);
    (*(void (**)(void, char *))(**(void **)this + 112LL))(*(void *)this, (char *)this + 24);
    unint64_t result = (***(uint64_t (****)(void))this)(*(void *)this);
    if (result >= 6)
    {
      (*(void (**)(void, char *))(**(void **)this + 192LL))(*(void *)this, (char *)this + 40);
      return (*(uint64_t (**)(void, char *))(**(void **)this + 192LL))(*(void *)this, (char *)this + 44);
    }
  }

  return result;
}

uint64_t (***dyld4::RuntimeLocks::resetLockInForkChild(dyld4::RuntimeLocks *this))(void)
{
  unint64_t result = *(uint64_t (****)(void))this;
  if (result)
  {
    unint64_t result = (uint64_t (***)(void))(**result)(result);
    if ((unint64_t)result >= 2)
    {
      (*(void (**)(void, char *))(**(void **)this + 152LL))(*(void *)this, (char *)this + 8);
      (*(void (**)(void, char *))(**(void **)this + 152LL))(*(void *)this, (char *)this + 16);
      unint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void, char *))(**(void **)this + 152LL))( *(void *)this,  (char *)this + 24);
      *((void *)this + 5) = 0LL;
    }
  }

  return result;
}

uint64_t dyld4::RuntimeLocks::takeDlopenLockBeforeFork(dyld4::RuntimeLocks *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(uint64_t, char *, void))(*(void *)result + 104LL))( result,  (char *)this + 32,  0LL);
  }
  return result;
}

uint64_t dyld4::RuntimeLocks::releaseDlopenLockInForkParent(dyld4::RuntimeLocks *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)result + 112LL))(result, (char *)this + 32);
  }
  return result;
}

uint64_t (***dyld4::RuntimeLocks::resetDlopenLockInForkChild(dyld4::RuntimeLocks *this))(void)
{
  uint64_t result = *(uint64_t (****)(void))this;
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if ((unint64_t)result >= 2) {
      return (uint64_t (***)(void))(*(uint64_t (**)(void, char *))(**(void **)this + 152LL))( *(void *)this,  (char *)this + 32);
    }
  }

  return result;
}

uint64_t dyld4::RuntimeState::appLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 123);
  if (!v2) {
    dyld4::RuntimeState::appLoadAddress();
  }
  if (*(_DWORD *)(v2 + 12) <= a2) {
    dyld4::RuntimeState::appLoadAddress();
  }
  return *(void *)(*((void *)this + 125) + 8LL * a2);
}

uint64_t dyld4::RuntimeState::setAppLoadAddress(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 984);
  if (!v3) {
    dyld4::RuntimeState::setAppLoadAddress();
  }
  if (*(_DWORD *)(v3 + 12) <= a2) {
    dyld4::RuntimeState::setAppLoadAddress();
  }
  *(void *)(*(void *)(result + 1000) + 8LL * a2) = a3;
  return result;
}

uint64_t dyld4::RuntimeState::cachedDylibLoadAddress(dyld4::RuntimeState *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (*(_DWORD *)(v2 + 392) <= a2) {
    dyld4::RuntimeState::cachedDylibLoadAddress();
  }
  return DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(v2 + 240), a2, &v5, &v4);
}

void dyld4::RuntimeState::add(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = v5 + 1;
  *(void *)(v4 + 8 * v5) = a2;
  if (!*((void *)this + 13) || !*((void *)this + 12))
  {
    if ((~*((unsigned __int16 *)a2 + 2) & 3) != 0)
    {
      size_t v7 = (dyld3::MachOFile *)dyld4::Loader::mf(a2, this);
      if (!dyld3::MachOFile::isDylib(v7)) {
        return;
      }
      uint64_t v6 = dyld3::MachOFile::installName(v7);
    }

    else
    {
      uint64_t v6 = (char *)dyld4::Loader::path(a2, this);
    }

    size_t v8 = v6;
    if (v6)
    {
      uint64_t v9 = *((void *)this + 1);
      int v10 = *(_DWORD *)(v9 + 68);
      if (v10 == 10)
      {
        if (_platform_strcmp(v8, "/System/DriverKit/usr/lib/system/libdyld.dylib"))
        {
          uint64_t v11 = "/System/DriverKit/usr/lib/libSystem.dylib";
          goto LABEL_20;
        }

void dyld4::RuntimeState::setDyldLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  *((void *)this + 13) = a2;
  __int128 v5 = xmmword_18961F320;
  __int128 v6 = *(_OWORD *)algn_18961F330;
  uint64_t v7 = 2LL;
  Diagnostics::Diagnostics((Diagnostics *)&v4);
  if (dyld4::Loader::hasExportedSymbol( (uint64_t)a2,  (vm_address_t *)&v4,  this,  "__dyld_missing_symbol_abort",  1u,  1,  (uint64_t *)&v5,  0LL))
  {
    *((void *)this + 14) = dyld4::Loader::resolvedAddress(this, (uint64_t)&v5);
    if ((_DWORD)v7 != 1) {
      dyld4::RuntimeState::setDyldLoader();
    }
    *((void *)this + 15) = v6;
  }

  mach_o::Error::~Error(&v4);
}

void dyld4::RuntimeState::printLinkageChain(dyld4::RuntimeState *this, uint64_t *a2, const char *a3)
{
  v10[0] = 0;
  if (a2)
  {
    __int128 v6 = a2;
    while (v6 == a2)
    {
LABEL_10:
      size_t v8 = dyld4::Loader::leafName((dyld4::Loader *)v6[1], this);
      strlcat(v10, v8, 0x800uLL);
      __int128 v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_16;
      }
    }

    __dst[0] = 0;
    char v7 = *((_BYTE *)v6 + 16);
    if ((v7 & 2) != 0)
    {
      strlcat(__dst, "r", 8uLL);
      char v7 = *((_BYTE *)v6 + 16);
      if ((v7 & 1) == 0)
      {
LABEL_6:
        if ((v7 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }

    else if ((v6[2] & 1) == 0)
    {
      goto LABEL_6;
    }

    strlcat(__dst, "w", 8uLL);
    char v7 = *((_BYTE *)v6 + 16);
    if ((v7 & 4) == 0)
    {
LABEL_7:
      if ((v7 & 8) == 0)
      {
LABEL_9:
        strlcat(v10, " -", 0x800uLL);
        strlcat(v10, __dst, 0x800uLL);
        strlcat(v10, "-> ", 0x800uLL);
        goto LABEL_10;
      }

LABEL_8:
      strlcat(__dst, "d", 8uLL);
      goto LABEL_9;
    }

  uint64_t v13 = 0LL;
  BOOL v14 = 0;
  return v13 | v14 | v12;
}

  char v23 = *((void *)a2 + 10);
  if (v23)
  {
    unsigned int v24 = (dyld4::Loader **)*((void *)a2 + 9);
    int v25 = 8 * v23;
    while (1)
    {
      uint64_t v9 = *v24;
      uint64_t v26 = *((void *)a2 + 1);
      size_t v28 = *(const void **)(v26 + 224);
      uint64_t v27 = *(void *)(v26 + 232);
      int v29 = (const char *)dyld4::Loader::path(*v24, a2);
      size_t v30 = strrchr(v29, 47);
      if (v30) {
        int v29 = v30 + 1;
      }
      if (v27 == _platform_strlen(v29))
      {
        uint64_t v15 = _platform_memcmp(v28, v29, v27);
        if (!(_DWORD)v15) {
          break;
        }
      }

      ++v24;
      v25 -= 8LL;
      if (!v25) {
        return;
      }
    }

    if (v9)
    {
LABEL_19:
      __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v33);
      size_t v31 = *((void *)a2 + 10) + *((void *)a2 + 6);
      v36[0] = (uint64_t)&v34[-1] - v32;
      v36[1] = v31;
      v36[2] = 0LL;
      v34[0] = 0LL;
      v34[1] = (uint64_t)this;
      uint64_t v35 = mach_o::LinkedDylibAttributes::regular;
      dyld4::Loader::recursivelyLogChainToLinksWith(this, a2, a3, v9, v34, v34, v36);
    }
  }

      if (v7[v5] == 61) {
        return &v7[v5 + 1];
      }
    }

    uint64_t v9 = kdebug_typefilter_typefilter;
    if (!kdebug_typefilter_typefilter) {
      return 1LL;
    }
  }

  return ((*(unsigned __int8 *)(v9 + ((unint64_t)a1 >> 19)) >> (BYTE2(a1) & 7)) & 1) != 0;
}

LABEL_14:
    strlcat(__dst, "u", 8uLL);
    if ((v6[2] & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

      v12 += 16LL;
    }

    while (v12 != v13);
  }

  return result;
}

  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 16) = 0;
  return result;
}

  a1[5] |= 0x20uLL;
  if ((a2 & 0x2000000) != 0) {
LABEL_7:
  }
    a1[5] |= 0x40uLL;
LABEL_8:
  uint64_t v21 = 0LL;
  unsigned int v22 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  size_t v8 = a2 & 0x81FFFFFF;
  uint64_t v18 = 0LL;
  uint64_t v9 = 240LL;
  switch((int)v8)
  {
    case 0:
      a1[3] = 0LL;
      a1[4] = 0LL;
      goto LABEL_36;
    case 1:
      goto LABEL_32;
    case 2:
      size_t v8 = 6LL;
      goto LABEL_32;
    case 3:
      size_t v8 = 7LL;
      goto LABEL_32;
    case 4:
      size_t v8 = 25LL;
      goto LABEL_32;
    case 5:
      size_t v8 = 27LL;
      goto LABEL_32;
    case 6:
      size_t v8 = 28LL;
      goto LABEL_32;
    case 7:
      size_t v8 = 33LL;
      goto LABEL_32;
    case 8:
      size_t v8 = 34LL;
      goto LABEL_32;
    case 9:
      int v10 = v23;
      v23 += 2;
      uint64_t v21 = *(void *)v10;
      char v23 = v10 + 4;
      unsigned int v22 = (int)v10[2];
      a1[3] = 35LL;
      a1[4] = &v21;
      goto LABEL_36;
    case 10:
      goto LABEL_34;
    case 11:
      uint64_t v11 = v23;
      v23 += 2;
      uint64_t v12 = *(_DWORD **)v11;
      char v23 = v11 + 4;
      uint64_t v13 = (uint64_t *)*((void *)v11 + 1);
      a1[3] = 241LL;
      LODWORD(v20) = *v12;
      uint64_t v19 = *v13;
      BOOL v14 = &v19;
      goto LABEL_35;
    case 12:
      size_t v8 = 50LL;
      goto LABEL_32;
    case 13:
      size_t v8 = 19LL;
      goto LABEL_32;
    case 14:
      uint64_t v9 = 65LL;
      goto LABEL_34;
    case 15:
      size_t v8 = 45LL;
      goto LABEL_32;
    case 16:
      uint64_t v9 = 75LL;
      goto LABEL_34;
    case 17:
      size_t v8 = 5LL;
LABEL_32:
      a1[3] = v8;
      uint64_t v15 = (uint64_t **)v23;
      v23 += 2;
      BOOL v14 = *v15;
      goto LABEL_35;
    case 18:
      uint64_t v9 = 52LL;
LABEL_34:
      a1[3] = v9;
      uint64_t v16 = v23;
      v23 += 2;
      BOOL v14 = (uint64_t *)*v16;
LABEL_35:
      a1[4] = v14;
LABEL_36:
      uint64_t result = v18 != 0;
      break;
    default:
      *__error() = 22;
LABEL_37:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }

  return result;
}

LABEL_16:
  dyld4::RuntimeState::log(this, "%s: %s\n", a3, v10);
}

    std::__throw_bad_optional_access[abi:nn180100]();
  }

  if (!v7) {
    goto LABEL_16;
  }
  uint64_t v9 = result - *(void *)(a2 + 32);
  int v10 = *(void *)(a2 + 48);
  if (*(_DWORD *)(a2 + 64) == 8)
  {
    uint64_t v11 = *(char **)(v10 + v9);
    if (!v11) {
      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v11 = (char *)*(unsigned int *)(v10 + v9);
    if (!*(_DWORD *)(v10 + v9)) {
      goto LABEL_14;
    }
  }

  uint64_t v12 = *(dyld4::RuntimeState **)(a2 + 56);
  uint64_t v13 = *((void *)v12 + 6);
  if (v13)
  {
    BOOL v14 = (dyld4::Loader **)*((void *)v12 + 5);
    uint64_t v15 = 8 * v13;
    while (1)
    {
      uint64_t v16 = *v14;
      uint64_t result = dyld4::Loader::contains(*v14, v12, v11, (const void **)&v19, &v18, &v17);
      if ((result & 1) != 0) {
        break;
      }
      ++v14;
      v15 -= 8LL;
      if (!v15) {
        goto LABEL_14;
      }
    }

    uint64_t result = dyld4::Loader::loadAddress(v16, v12);
    size_t v8 = &v11[-result];
    *(void *)a3 = v16;
    goto LABEL_4;
  }

      BOOL v14 = *((void *)this + 22);
      if (v14)
      {
        char v7 = (dyld4::RuntimeState **)*((void *)this + 21);
        uint64_t v15 = 16 * v14;
        while (v7[1] != a2)
        {
          v7 += 2;
          v15 -= 16LL;
          if (!v15) {
            return v4;
          }
        }

  int v10 = v5[1];
  if ((v10 & 1) != 0) {
    lsl::Allocator::Pool::aligned_alloc_best_fit();
  }
  uint64_t v11 = (lsl::Allocator::Pool *)(v5 + 2);
  v5[1] = v10 | 1;
  if (v11 == this) {
    lsl::Allocator::Pool::aligned_alloc_best_fit();
  }
  return v11;
}

void dyld4::RuntimeState::log(dyld4::RuntimeState *this, char *a2, ...)
{
}

uint64_t dyld4::RuntimeState::recursiveMarkNonDelayed(uint64_t a1, dyld4::Loader *a2, uint64_t *a3, char **a4)
{
  uint64_t result = dyld4::Loader::isDelayInit(a2, (dyld4::RuntimeState *)a1);
  if ((_DWORD)result)
  {
    dyld4::Loader::setDelayInit(a2, (dyld4::RuntimeState *)a1, 0);
    uint64_t v9 = *(void *)(a1 + 8);
    size_t v10 = *(void *)(v9 + 232);
    if (v10)
    {
      uint64_t v11 = *(const void **)(v9 + 224);
      uint64_t v12 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
      if (v10 == _platform_strlen(v12) && !_platform_memcmp(v11, v12, v10))
      {
        if (*(_BYTE *)(a1 + 648)) {
          strcpy(__dst, "no longer delayed(");
        }
        else {
          strcpy(__dst, "not delayed at launch(");
        }
        uint64_t v13 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
        strlcat(__dst, v13, 0x40uLL);
        strlcat(__dst, ")", 0x40uLL);
        dyld4::RuntimeState::printLinkageChain((dyld4::RuntimeState *)a1, a3, __dst);
      }
    }

    uint64_t result = dyld4::Loader::dependentCount(a2);
    if ((_DWORD)result)
    {
      int v14 = result;
      uint64_t v15 = 0LL;
      do
      {
        char v22 = 0;
        uint64_t result = dyld4::Loader::dependent(a2, (dyld4::RuntimeState *)a1, v15, &v22);
        if (result && (v22 & 8) == 0)
        {
          *(void *)__dst = 0LL;
          *(void *)&char __dst[8] = result;
          __dst[16] = v22;
          *a4 = __dst;
          uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, result, a3, __dst);
        }

        uint64_t v15 = (v15 + 1);
      }

      while (v14 != (_DWORD)v15);
    }

    uint64_t v16 = *(void *)(a1 + 936);
    if (v16)
    {
      uint64_t v17 = 16 * v16;
      uint64_t v18 = (dyld4::Loader **)(*(void *)(a1 + 928) + 8LL);
      do
      {
        if (*(v18 - 1) == a2)
        {
          if (*(_BYTE *)(*(void *)(a1 + 8) + 200LL))
          {
            uint64_t v19 = dyld4::Loader::leafName(*v18, (const dyld4::RuntimeState *)a1);
            uint64_t v20 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log( (dyld4::RuntimeState *)a1,  "%s has weak-def (or flat lookup) symbol used by %s, so cannot be delayed\n",  v19,  v20);
          }

          *(void *)__dst = 0LL;
          *(void *)&char __dst[8] = *v18;
          uint64_t v21 = *(void *)&__dst[8];
          __dst[16] = mach_o::LinkedDylibAttributes::regular;
          *a4 = __dst;
          uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed(a1, v21, a3, __dst);
        }

        v18 += 2;
        v17 -= 16LL;
      }

      while (v17);
    }
  }

  return result;
}

uint64_t dyld4::RuntimeState::partitionDelayLoads( uint64_t result, dyld4::Loader **a2, uint64_t a3, dyld4::Loader **a4, uint64_t a5, uint64_t a6)
{
  size_t v10 = a2;
  uint64_t v11 = (dyld4::RuntimeState *)result;
  uint64_t v12 = 8 * a3;
  if (a3)
  {
    uint64_t v13 = 8 * a3;
    int v14 = a2;
    do
    {
      uint64_t v15 = *v14++;
      uint64_t result = dyld4::Loader::setDelayInit(v15, v11, 1);
      v13 -= 8LL;
    }

    while (v13);
  }

  if (a5)
  {
    uint64_t v16 = 8 * a5;
    do
    {
      uint64_t v17 = *a4++;
      uint64_t v47 = 0LL;
      uint64_t v48 = v17;
      char v49 = mach_o::LinkedDylibAttributes::regular;
      uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)v11, v17, (uint64_t *)&v47, &v47);
      v16 -= 8LL;
    }

    while (v16);
  }

  if (*((void *)v11 + 22))
  {
    if (*(_BYTE *)(*((void *)v11 + 1) + 190LL) && a3 != 0)
    {
      uint64_t v19 = v12;
      uint64_t v20 = v10;
      do
      {
        uint64_t v21 = *v20;
        uint64_t result = dyld4::Loader::mf(*v20, v11);
        if ((*((_WORD *)v21 + 2) & 2) == 0)
        {
          char v22 = (dyld3::MachOFile *)result;
          uint64_t result = dyld3::MachOFile::isDylib((dyld3::MachOFile *)result);
          if ((_DWORD)result)
          {
            uint64_t result = dyld3::MachOFile::hasInterposingTuples(v22);
            if ((_DWORD)result)
            {
              if (*(_BYTE *)(*((void *)v11 + 1) + 200LL))
              {
                char v23 = dyld4::Loader::leafName(v21, v11);
                dyld4::RuntimeState::log(v11, "has interposing tuples so cannot be delayed: %s\n", v23);
              }

              uint64_t v47 = 0LL;
              uint64_t v48 = v21;
              char v49 = mach_o::LinkedDylibAttributes::regular;
              uint64_t result = dyld4::RuntimeState::recursiveMarkNonDelayed((uint64_t)v11, v21, (uint64_t *)&v47, &v47);
            }
          }
        }

        ++v20;
        v19 -= 8LL;
      }

      while (v19);
    }
  }

  uint64_t v24 = a6;
  if (*((void *)v11 + 10))
  {
    unint64_t v25 = 0LL;
    do
    {
      uint64_t v26 = *(dyld4::Loader **)(*((void *)v11 + 9) + 8 * v25);
      uint64_t result = dyld4::Loader::isDelayInit(v26, v11);
      if ((result & 1) == 0)
      {
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)v11 + 32, *((void *)v11 + 6) + 1LL);
        uint64_t v27 = *((void *)v11 + 5);
        uint64_t v28 = *((void *)v11 + 6);
        *((void *)v11 + 6) = v28 + 1;
        *(void *)(v27 + 8 * v28) = v26;
        if (*(_BYTE *)(*((void *)v11 + 1) + 200LL))
        {
          int v29 = dyld4::Loader::leafName(v26, v11);
          dyld4::RuntimeState::log(v11, "move delayed to loaded: %s\n", v29);
        }

        uint64_t v31 = *((void *)v11 + 9);
        uint64_t v30 = *((void *)v11 + 10);
        uint64_t result = v31 + 8 * v25;
        uint64_t v32 = v31 + 8 * v30;
        if (v32 != result + 8)
        {
          uint64_t result = (uint64_t)memmove((void *)result, (const void *)(result + 8), v32 - (result + 8));
          uint64_t v30 = *((void *)v11 + 10);
        }

        *((void *)v11 + 10) = v30 - 1;
        if (v24)
        {
          uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve(v24, *(void *)(v24 + 16) + 1LL);
          uint64_t v33 = *(void *)(v24 + 8);
          uint64_t v34 = *(void *)(v24 + 16);
          *(void *)(v24 + 16) = v34 + 1;
          *(void *)(v33 + 8 * v34) = v26;
        }

        --v25;
      }

      ++v25;
    }

    while (v25 < *((void *)v11 + 10));
  }

  if (*((void *)v11 + 6))
  {
    unint64_t v35 = 0LL;
    do
    {
      uint64_t v36 = *(dyld4::Loader **)(*((void *)v11 + 5) + 8 * v35);
      uint64_t result = dyld4::Loader::isDelayInit(v36, v11);
      if ((result & 1) != 0)
      {
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)v11 + 64, *((void *)v11 + 10) + 1LL);
        uint64_t v37 = *((void *)v11 + 9);
        uint64_t v38 = *((void *)v11 + 10);
        *((void *)v11 + 10) = v38 + 1;
        *(void *)(v37 + 8 * v38) = v36;
        if (*(_BYTE *)(*((void *)v11 + 1) + 200LL))
        {
          uint64_t v39 = dyld4::Loader::leafName(v36, v11);
          dyld4::RuntimeState::log(v11, "move loaded to delayed: %s\n", v39);
        }

        uint64_t v41 = *((void *)v11 + 5);
        uint64_t v40 = *((void *)v11 + 6);
        uint64_t result = v41 + 8 * v35;
        uint64_t v42 = v41 + 8 * v40;
        if (v42 != result + 8)
        {
          uint64_t result = (uint64_t)memmove((void *)result, (const void *)(result + 8), v42 - (result + 8));
          uint64_t v40 = *((void *)v11 + 6);
        }

        unint64_t v43 = v40 - 1;
        *((void *)v11 + 6) = v43;
        --v35;
      }

      else
      {
        unint64_t v43 = *((void *)v11 + 6);
      }

      ++v35;
    }

    while (v35 < v43);
  }

  if (v24 && a3)
  {
    do
    {
      uint64_t v44 = *v10;
      uint64_t result = dyld4::Loader::isDelayInit(*v10, v11);
      if ((result & 1) == 0)
      {
        uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve(v24, *(void *)(v24 + 16) + 1LL);
        uint64_t v45 = *(void *)(v24 + 8);
        uint64_t v46 = *(void *)(v24 + 16);
        *(void *)(v24 + 16) = v46 + 1;
        *(void *)(v45 + 8 * v46) = v44;
      }

      ++v10;
      v12 -= 8LL;
    }

    while (v12);
  }

  return result;
}

void dyld4::RuntimeState::setMainLoader(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  *((void *)this + 3) = a2;
  uint64_t v4 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a2, this);
  uint64_t v5 = *((void *)this + 1);
  if (*(_BYTE *)(v5 + 200))
  {
    dyld4::Loader::logLoad(a2, this, *(char **)(v5 + 16));
    uint64_t v5 = *((void *)this + 1);
  }

  if (*(_BYTE *)(v5 + 201))
  {
    dyld4::RuntimeState::log(this, "Kernel mapped %s\n", *(const char **)(v5 + 16));
    v7[0] = 0LL;
    v7[1] = v7;
    v7[2] = 0x2000000000LL;
    int v8 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    v6[2] = ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke;
    v6[3] = &unk_18961F350;
    v6[4] = v7;
    v6[5] = this;
    v6[6] = dyld3::MachOLoaded::getSlide(v4);
    v6[7] = v4;
    dyld3::MachOFile::forEachSegment(v4, (uint64_t)v6);
    _Block_object_dispose(v7, 8);
  }

void ___ZN5dyld412RuntimeState13setMainLoaderEPKNS_6LoaderE_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v3 = (dyld4::RuntimeState *)a1[5];
  vm_size_t v4 = (*(void *)(a2 + 8) + vm_page_size - 1) & -(uint64_t)vm_page_size;
  if (!v4)
  {
    if (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL)) {
      vm_size_t v4 = 0LL;
    }
    else {
      vm_size_t v4 = a1[7];
    }
  }

  if (*(_BYTE *)(*((void *)v3 + 1) + 201LL))
  {
    uint64_t v5 = a1[6] + *(void *)(a2 + 16);
    int v6 = *(_DWORD *)(a2 + 52);
    char v7 = (const char *)dyld3::MachOLoaded::segmentName( (dyld3::MachOLoaded *)a1[7],  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL));
    uint64_t v8 = 120LL;
    if ((v6 & 4) == 0) {
      uint64_t v8 = 46LL;
    }
    uint64_t v9 = 119LL;
    if ((v6 & 2) == 0) {
      uint64_t v9 = 46LL;
    }
    uint64_t v11 = v8;
    uint64_t v10 = 114LL;
    if ((v6 & 1) == 0) {
      uint64_t v10 = 46LL;
    }
    dyld4::RuntimeState::log(v3, "%14s (%c%c%c) 0x%012llX->0x%012llX \n", v7, v10, v9, v11, v5, v4 + v5);
  }

  ++*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
}

uint64_t dyld4::RuntimeState::setHelpers(uint64_t result, uint64_t a2)
{
  **(void **)(result + 136) = a2;
  *(void *)(result + 152) = a2;
  return result;
}

void dyld4::RuntimeState::vlog(dyld4::RuntimeState *this, char *a2, char *a3)
{
  if (!*((_BYTE *)this + 1125)) {
    dyld4::RuntimeState::setUpLogging(this);
  }
  if (*((_BYTE *)this + 1124))
  {
    if (snprintf( __str,  0x800uLL,  "<%d>%s[%d]: ",  13,  *(const char **)(*((void *)this + 1) + 136LL),  *(_DWORD *)(*((void *)this + 1) + 152LL)) >= 1)
    {
      size_t v12 = _platform_strlen(__str);
      if (vsnprintf(&__str[v12], 2048 - v12, a2, a3) >= 1)
      {
        int v13 = *((_DWORD *)this + 280);
        size_t v14 = _platform_strlen(__str);
        sendto(v13, __str, v14, 0, 0LL, 0);
      }
    }
  }

  else
  {
    int v15 = *((_DWORD *)this + 280);
    if (v15 != -1)
    {
      _simple_dprintf(v15, "dyld[%d]: ", v6, v7, v8, v9, v10, v11, *(_DWORD *)(*((void *)this + 1) + 152LL));
      _simple_vdprintf(*((_DWORD *)this + 280), a2, (int *)a3);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(*((void *)this + 17) + 44LL));
}

os_unfair_lock_s *dyld4::RuntimeState::setUpLogging(dyld4::RuntimeState *this)
{
  uint64_t v2 = (lsl::Lock *)*((void *)this + 16);
  lsl::MemoryManager::lockGuard(v2, (lsl::Lock **)&v11);
  uint64_t v3 = *((void *)v2 + 3);
  if (!v3)
  {
    lsl::MemoryManager::writeProtect(v2, 0);
    uint64_t v3 = *((void *)v2 + 3);
  }

  *((void *)v2 + 3) = v3 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v11.st_dev);
  uint64_t v4 = *((void *)this + 1);
  if (*(_BYTE *)(v4 + 216) || *(_BYTE *)(v4 + 217))
  {
    *((_DWORD *)this + 280) = *(_DWORD *)(v4 + 212);
    *((_WORD *)this + 562) = 256;
    goto LABEL_6;
  }

  if (*(_DWORD *)(v4 + 152) == 1)
  {
    int v7 = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)v4, (dyld3 *)"/dev/console", (char *)0x20001, 0LL);
LABEL_13:
    char v8 = 0;
    *((_DWORD *)this + 280) = v7;
LABEL_14:
    *((_BYTE *)this + 1124) = v8;
    *((_BYTE *)this + 1125) = 1;
    goto LABEL_15;
  }

  if ((dyld4::SyscallDelegate::fstat((dyld4::SyscallDelegate *)v4, *(_DWORD *)(v4 + 212), &v11) & 0x80000000) == 0)
  {
    int v7 = *(_DWORD *)(*((void *)this + 1) + 212LL);
    goto LABEL_13;
  }

  uint64_t v10 = *((void *)this + 19);
  if (v10 && ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 96LL))(v10) & 1) != 0)
  {
    char v8 = 1;
    goto LABEL_14;
  }

LABEL_15:
  if (!*((_BYTE *)this + 1124)) {
    goto LABEL_6;
  }
  int v9 = dyld4::SyscallDelegate::socket(*((dyld4::SyscallDelegate **)this + 1), 1, 2, 0);
  *((_DWORD *)this + 280) = v9;
  if (v9 != -1)
  {
    dyld4::SyscallDelegate::fcntl(*((dyld4::SyscallDelegate **)this + 1), v9, 2, (void *)1);
    strcpy((char *)&v12[1], "/var/run/syslog");
    HIBYTE(v12[0]) = 1;
    uint64_t v13 = 0LL;
    memset(&v12[9], 0, 80);
    if (dyld4::SyscallDelegate::connect( *((dyld4::SyscallDelegate **)this + 1),  *((_DWORD *)this + 280),  (const sockaddr *)v12,  0x6Au) == -1)
    {
      dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)this + 1), *((_DWORD *)this + 280));
      *((_DWORD *)this + 280) = -1;
    }

    else if (*((_DWORD *)this + 280) != -1)
    {
      goto LABEL_6;
    }
  }

  *((_BYTE *)this + 1124) = 0;
LABEL_6:
  lsl::MemoryManager::lockGuard(v2, (lsl::Lock **)&v11);
  uint64_t v5 = *((void *)v2 + 3) - 1LL;
  *((void *)v2 + 3) = v5;
  if (!v5) {
    lsl::MemoryManager::writeProtect(v2, 1);
  }
  return lsl::Lock::unlock(*(lsl::Lock **)&v11.st_dev);
}

    uint64_t v19 = *(void *)(a4 + ((unint64_t)a7 << 6) + 16) + a8;
    if (v19 >= *(void *)(*(void *)(v14[7] + 8LL) + 24LL) && v19 < *(void *)(*(void *)(v14[8] + 8LL) + 24LL))
    {
      uint64_t v20 = *(void *)(*(void *)(v14[6] + 8LL) + 24LL);
      uint64_t v21 = v19 - v20;
      if (a6 == 8) {
        char v22 = *(void *)((char *)v15 + v21);
      }
      else {
        char v22 = *(unsigned int *)((char *)v15 + v21);
      }
      if (v22 >= *(void *)(*(void *)(v14[9] + 8LL) + 24LL) && v22 < *(void *)(*(void *)(v14[10] + 8LL) + 24LL)) {
        dyld3::MachOAnalyzer::contentIsRegularStub(v15, (const unsigned __int8 *)v15 + v22 - v20);
      }
    }

    return (*(uint64_t (**)(void))(v14[4] + 16LL))();
  }

  return result;
}

os_unfair_lock_s *dyld4::RuntimeState::addDynamicReference( dyld4::RuntimeState *this, const dyld4::Loader *a2, const dyld4::Loader *a3)
{
  if ((*((_WORD *)a3 + 2) & 0x20) == 0
    || (uint64_t result = (os_unfair_lock_s *)dyld4::Loader::isDelayInit(a3, this), (_DWORD)result))
  {
    int v7 = (lsl::Lock *)*((void *)this + 16);
    char v8 = (void *)*((void *)this + 17);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    size_t v12 = (void (*)(void *))___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke;
    uint64_t v13 = &__block_descriptor_tmp_45;
    size_t v14 = this;
    int v15 = a2;
    uint64_t v16 = a3;
    lsl::MemoryManager::lockGuard(v7, &v17);
    uint64_t v9 = *((void *)v7 + 3);
    if (!v9)
    {
      lsl::MemoryManager::writeProtect(v7, 0);
      uint64_t v9 = *((void *)v7 + 3);
    }

    *((void *)v7 + 3) = v9 + 1;
    lsl::Lock::unlock(v17);
    if (*v8)
    {
      (*(void (**)(void, void *, void))(*(void *)*v8 + 104LL))(*v8, v8 + 1, 0LL);
      v12(v11);
      (*(void (**)(void, void *))(*(void *)*v8 + 112LL))(*v8, v8 + 1);
    }

    else
    {
      ___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke(v11);
    }

    lsl::MemoryManager::lockGuard(v7, &v17);
    uint64_t v10 = *((void *)v7 + 3) - 1LL;
    *((void *)v7 + 3) = v10;
    if (!v10) {
      lsl::MemoryManager::writeProtect(v7, 1);
    }
    return lsl::Lock::unlock(v17);
  }

  return result;
}

void *___ZN5dyld412RuntimeState19addDynamicReferenceEPKNS_6LoaderES3__block_invoke(void *result)
{
  uint64_t v1 = result[4];
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v1 + 936);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = (void *)(*(void *)(v1 + 928) + 8LL);
    while (*(v5 - 1) != v2 || *v5 != result[6])
    {
      v5 += 2;
      v4 -= 16LL;
      if (!v4) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v6 = result[6];
    uint64_t result = (void *)lsl::Vector<dyld4::InterposeTupleAll>::reserve(v1 + 920, v3 + 1);
    uint64_t v7 = *(void *)(v1 + 928);
    uint64_t v8 = *(void *)(v1 + 936);
    *(void *)(v1 + 936) = v8 + 1;
    uint64_t v9 = (void *)(v7 + 16 * v8);
    void *v9 = v2;
    v9[1] = v6;
  }

  return result;
}

uint64_t dyld4::RuntimeState::addMissingFlatLazySymbol( dyld4::RuntimeState *this, const dyld4::Loader *a2, const char *a3, unint64_t *a4)
{
  uint64_t result = lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 888, *((void *)this + 113) + 1LL);
  uint64_t v9 = *((void *)this + 112);
  uint64_t v10 = *((void *)this + 113);
  *((void *)this + 113) = v10 + 1;
  stat v11 = (void *)(v9 + 24 * v10);
  *stat v11 = a2;
  v11[1] = a3;
  void v11[2] = a4;
  return result;
}

void dyld4::RuntimeState::rebindMissingFlatLazySymbols(uint64_t a1, dyld4::Loader ***a2)
{
  uint64_t v4 = *(void *)(a1 + 896);
  uint64_t v5 = *(void *)(a1 + 904);
  uint64_t v6 = v4 + 24 * v5;
  v11[0] = a2;
  v11[1] = (dyld4::Loader ***)&v12;
  void v11[2] = (dyld4::Loader ***)a1;
  if (v5)
  {
    uint64_t v7 = 24 * v5;
    while ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()( v11,  v4) & 1) == 0)
    {
      v4 += 24LL;
      v7 -= 24LL;
      if (!v7)
      {
        uint64_t v4 = v6;
        goto LABEL_13;
      }
    }
  }

  uint64_t v8 = v4 + 24;
  if (v4 != v6 && v8 != v6)
  {
    do
    {
      if ((dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()( v11,  v8) & 1) == 0)
      {
        __int128 v10 = *(_OWORD *)v8;
        *(void *)(v4 + 16) = *(void *)(v8 + 16);
        *(_OWORD *)uint64_t v4 = v10;
        v4 += 24LL;
      }

      v8 += 24LL;
    }

    while (v8 != v6);
  }

LABEL_13:
  *(void *)(a1 + 904) += 0x5555555555555555LL * ((*(void *)(a1 + 896) + 24LL * *(void *)(a1 + 904) - v4) >> 3);
  mach_o::Error::~Error(&v12);
}

    if (++v10 == 2)
    {
      uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8LL);
      if (!*(_BYTE *)(v16 + 186))
      {
        uint64_t v39 = *a2;
        if (v39 != 47 && v39 != 64)
        {
          uint64_t v40 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
          uint64_t v41 = *(vm_address_t **)(a1 + 72);
          if (v40) {
            Diagnostics::error(v41, "tried: '%s' (relative path not allowed in hardened program)", a2);
          }
          else {
            Diagnostics::appendError(v41, ", '%s' (relative path not allowed in hardened program)");
          }
          return;
        }
      }

      if (dyld4::ProcessConfig::DyldCache::indexOfPath((DyldSharedCache **)(v16 + 240), a2, &v76))
      {
        uint64_t v17 = 0LL;
        uint64_t v18 = *(void *)(a1 + 56);
        *(void *)&uint64_t v78 = v18 + 32;
        *((void *)&v78 + 1) = v18 + 64;
        while (1)
        {
          uint64_t v19 = *((void *)&v78 + v17);
          if (!*(_BYTE *)(*(void *)(a1 + 64) + 5LL) || v19 != *(void *)(a1 + 56) + 64LL)
          {
            uint64_t v20 = *(void *)(v19 + 16);
            if (v20) {
              break;
            }
          }

  a1[5] |= 0x10uLL;
  if ((a2 & 0x4000000) == 0)
  {
LABEL_6:
    if ((a2 & 0x2000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

uint64_t dyld4::RuntimeState::removeMissingFlatLazySymbols(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 896);
  uint64_t v3 = *(void *)(result + 904);
  uint64_t v4 = &v2[3 * v3];
  uint64_t v5 = v2;
  if (v3)
  {
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v5 = *(void **)(result + 896);
    while (1)
    {
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        uint64_t v8 = *(void **)a2;
        while (*v8 != *v5)
        {
          ++v8;
          v7 -= 8LL;
          if (!v7)
          {
            uint64_t v8 = (void *)(*(void *)a2 + 8 * v6);
            break;
          }
        }
      }

      else
      {
        uint64_t v8 = *(void **)a2;
      }

      v5 += 3;
      if (v5 == v4) {
        goto LABEL_24;
      }
    }
  }

  if (v5 == v4)
  {
LABEL_24:
    uint64_t v5 = &v2[3 * v3];
  }

  else
  {
    uint64_t v9 = v5 + 3;
    if (v5 + 3 != v4)
    {
      do
      {
        __int128 v10 = *(void **)a2;
        uint64_t v11 = *(void *)(a2 + 8);
        if (v11)
        {
          uint64_t v12 = 8 * v11;
          uint64_t v13 = *(void **)a2;
          while (*v13 != *v9)
          {
            ++v13;
            v12 -= 8LL;
            if (!v12)
            {
              uint64_t v13 = &v10[v11];
              break;
            }
          }
        }

        else
        {
          uint64_t v13 = *(void **)a2;
        }

        if (v11 == v13 - v10)
        {
          __int128 v14 = *(_OWORD *)v9;
          v5[2] = v9[2];
          *(_OWORD *)uint64_t v5 = v14;
          v5 += 3;
        }

        v9 += 3;
      }

      while (v9 != v4);
      uint64_t v2 = *(void **)(result + 896);
      uint64_t v3 = *(void *)(result + 904);
    }
  }

  *(void *)(result + 904) = v3 + 0x5555555555555555LL * (&v2[3 * v3] - v5);
  return result;
}

unint64_t *dyld4::RuntimeState::PermanentRanges::make(lsl::Lock ***a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v24 = 0LL;
  unint64_t v25 = &v24;
  uint64_t v26 = 0x5002000000LL;
  uint64_t v27 = __Block_byref_object_copy__0;
  uint64_t v28 = __Block_byref_object_dispose__0;
  uint64_t v5 = 8 * v4;
  int v29 = (char *)&v20[-1] - v2;
  uint64_t v30 = 8 * v4;
  vm_address_t v32 = 0LL;
  vm_size_t v33 = 0LL;
  uint64_t v31 = 0LL;
  if (v4)
  {
    uint64_t v6 = *(dyld4::Loader ***)a2;
    do
    {
      uint64_t v7 = *v6++;
      Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(v7, (const dyld4::RuntimeState *)a1);
      uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
      v23[0] = 0LL;
      v23[1] = v23;
      v23[2] = 0x2000000000LL;
      v23[3] = 0LL;
      v21[0] = 0LL;
      v21[1] = v21;
      void v21[2] = 0x2000000000LL;
      char v22 = 0;
      __int128 v10 = (_DWORD *)dyld4::Loader::loadAddress(v7, (const dyld4::RuntimeState *)a1);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000LL;
      v20[2] = ___ZN5dyld412RuntimeState15PermanentRanges4makeERS0_RKN5dyld35ArrayIPKNS_6LoaderEEE_block_invoke;
      v20[3] = &unk_18961F398;
      v20[4] = v23;
      v20[5] = v21;
      v20[7] = Slide;
      v20[6] = &v24;
      v20[8] = v7;
      dyld3::MachOFile::forEachSegment(v10, (uint64_t)v20);
      _Block_object_dispose(v21, 8);
      _Block_object_dispose(v23, 8);
      v5 -= 8LL;
    }

    while (v5);
    unint64_t v11 = *((unsigned int *)v25 + 14);
  }

  else
  {
    unint64_t v11 = 0LL;
  }

  uint64_t v12 = lsl::Allocator::malloc(a1[2], (32 * v11) | 0x10);
  uint64_t v13 = v12;
  atomic_store(0LL, v12);
  v12[1] = v11;
  if (v11)
  {
    unint64_t v14 = 0LL;
    int v15 = v12 + 2;
    do
    {
      uint64_t v16 = (_OWORD *)dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( v25 + 5,  v14);
      __int128 v17 = v16[1];
      *int v15 = *v16;
      v15[1] = v17;
      v15 += 2;
      ++v14;
    }

    while (v11 != v14);
  }

  _Block_object_dispose(&v24, 8);
  uint64_t v31 = 0LL;
  if (v32) {
    vm_deallocate(mach_task_self_, v32, v33);
  }
  return v13;
}

double __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__0(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZN5dyld412RuntimeState15PermanentRanges4makeERS0_RKN5dyld35ArrayIPKNS_6LoaderEEE_block_invoke( void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[7] + *(void *)(a2 + 16);
  uint64_t v5 = v4 + *(void *)(a2 + 24);
  uint64_t v6 = *(unsigned int *)(a2 + 52);
  if (v4 == *(void *)(*(void *)(result[4] + 8LL) + 24LL)
    && (_DWORD)v6 == *(unsigned __int8 *)(*(void *)(result[5] + 8LL) + 24LL)
    && (v7 = *(void *)(result[6] + 8LL), (uint64_t v8 = *(void *)(v7 + 56)) != 0))
  {
    *(void *)(*(void *)(v7 + 40) + 32 * v8 - 24) = v5;
  }

  else if ((_DWORD)v6)
  {
    uint64_t v9 = result[8];
    uint64_t v10 = *(void *)(result[6] + 8LL);
    double result = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace( (void *)(v10 + 40),  1LL);
    uint64_t v11 = *(void *)(v10 + 40);
    uint64_t v12 = *(void *)(v10 + 56);
    *(void *)(v10 + 56) = v12 + 1;
    uint64_t v13 = (void *)(v11 + 32 * v12);
    void *v13 = v4;
    v13[1] = v5;
    v13[2] = v9;
    v13[3] = v6;
    LODWORD(v6) = *(_DWORD *)(a2 + 52);
  }

  *(void *)(*(void *)(v3[4] + 8LL) + 24LL) = v5;
  *(_BYTE *)(*(void *)(v3[5] + 8LL) + 24LL) = v6;
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 32 * a2;
}

BOOL dyld4::RuntimeState::PermanentRanges::contains( dyld4::RuntimeState::PermanentRanges *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  unint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = (void *)((char *)this + 40);
    BOOL v8 = 1;
    while (*(v7 - 3) > a2 || *(v7 - 2) <= a3)
    {
      BOOL v8 = ++v6 < v5;
      v7 += 4;
      if (v5 == v6) {
        return 0;
      }
    }

    *a4 = *v7;
    *a5 = (const Loader *)*(v7 - 1);
  }

  else
  {
    return 0;
  }

  return v8;
}

unint64_t *dyld4::RuntimeState::addPermanentRanges(uint64_t a1, uint64_t a2)
{
  double result = dyld4::RuntimeState::PermanentRanges::make((lsl::Lock ***)a1, a2);
  unint64_t v4 = *(unint64_t **)(a1 + 1016);
  if (v4)
  {
    atomic_store((unint64_t)result, v4);
  }

  else
  {
    *(void *)(a1 + 1016) = result;
  }

  return result;
}

BOOL dyld4::RuntimeState::inPermanentRange( dyld4::RuntimeState *this, unint64_t a2, unint64_t a3, unsigned __int8 *a4, const Loader **a5)
{
  unint64_t v5 = (dyld4::RuntimeState::PermanentRanges *)*((void *)this + 127);
  if (!v5) {
    return 0LL;
  }
  do
  {
    BOOL result = dyld4::RuntimeState::PermanentRanges::contains(v5, a2, a3, a4, a5);
    if (result) {
      break;
    }
    unint64_t v5 = (dyld4::RuntimeState::PermanentRanges *)atomic_load((unint64_t *)v5);
  }

  while (v5);
  return result;
}

dyld3::MachOFile *dyld4::RuntimeState::checkHiddenCacheAddr( dyld3::MachOFile *result, uint64_t a2, uint64_t a3, const unsigned __int8 *a4, uint64_t *a5)
{
  if (a2)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0)
    {
      BOOL v8 = result;
      BOOL result = (dyld3::MachOFile *)dyld4::JustInTimeLoader::overridesDylibInCache(a2, &v17[1], v17);
      if ((_DWORD)result)
      {
        BOOL result = (dyld3::MachOFile *)DyldSharedCache::getIndexedImageEntry( *(DyldSharedCache **)(*((void *)v8 + 1) + 240LL),  v17[0],  &v16,  &v15);
        if (result)
        {
          BOOL result = (dyld3::MachOFile *)dyld3::MachOLoaded::hasExportedSymbol(result, a4, 0LL, &v14, &v13);
          if ((_DWORD)result)
          {
            uint64_t v9 = v14;
            BOOL result = (dyld3::MachOFile *)dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace( a5,  1LL);
            uint64_t v10 = *a5;
            uint64_t v11 = a5[2];
            a5[2] = v11 + 1;
            uint64_t v12 = (void *)(v10 + 16 * v11);
            void *v12 = v9;
            v12[1] = a3;
          }
        }
      }
    }
  }

  return result;
}

void dyld4::RuntimeState::appendInterposingTuples( uint64_t **this, const dyld4::Loader *a2, const unsigned __int8 *a3, unsigned int a4)
{
  if (*((_BYTE *)this[1] + 190))
  {
    uint64_t v63 = 0LL;
    uint64_t v64 = &v63;
    uint64_t v65 = 0x4002000000LL;
    size_t v66 = __Block_byref_object_copy__47;
    size_t v67 = __Block_byref_object_dispose__48;
    uint64_t v68 = (char *)v42 - v4;
    uint64_t v69 = a4;
    uint64_t v70 = 0LL;
    if (a4)
    {
      unsigned int v8 = a4;
      do
      {
        unint64_t v9 = v64[7];
        if (v9 >= v64[6]) {
          dyld4::RuntimeState::appendInterposingTuples((uint64_t)this, (uint64_t)a2, (uint64_t)a3);
        }
        uint64_t v10 = v64[5];
        v64[7] = v9 + 1;
        uint64_t v11 = (_OWORD *)(v10 + 32 * v9);
        *uint64_t v11 = 0uLL;
        v11[1] = 0uLL;
        --v8;
      }

      while (v8);
    }

    v42[1] = (vm_address_t **)v42;
    uint64_t v53 = 0LL;
    size_t v54 = &v53;
    uint64_t v12 = &a3[16 * a4];
    uint64_t v55 = 0x5002000000LL;
    uint64_t v56 = __Block_byref_object_copy__49;
    uint64_t v57 = __Block_byref_object_dispose__50;
    uint64_t v58 = &v71;
    uint64_t v59 = 32LL;
    vm_address_t v61 = 0LL;
    vm_size_t v62 = 0LL;
    uint64_t v60 = 0LL;
    uint64_t v47 = 0LL;
    uint64_t v48 = &v47;
    uint64_t v50 = __Block_byref_object_copy__51;
    uint64_t v51 = __Block_byref_object_dispose__52;
    uint64_t v49 = 0x3002000000LL;
    v42[0] = (vm_address_t **)&v52;
    Diagnostics::Diagnostics((Diagnostics *)&v52);
    char v13 = (char *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    if ((dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)v13) & 1) != 0)
    {
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 0x40000000LL;
      uint64_t v46[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke;
      v46[3] = &unk_18961F410;
      v46[8] = v13;
      v46[9] = a2;
      v46[4] = &v47;
      v46[5] = &v53;
      v46[10] = a3;
      v46[11] = v12;
      v46[6] = &v63;
      v46[7] = this;
      dyld3::MachOAnalyzer::withChainStarts(v13, (vm_address_t *)v48 + 5, 0LL, (uint64_t)v46);
    }

    else
    {
      uint64_t Address = dyld3::MachOFile::preferredLoadAddress((dyld3::MachOFile *)v13);
      v45[0] = _NSConcreteStackBlock;
      v45[1] = 0x40000000LL;
      v45[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_3;
      v45[3] = &unk_18961F438;
      v45[6] = a3;
      v45[7] = v12;
      v45[4] = &v63;
      v45[5] = v13;
      v45[8] = &v13[-Address];
      v45[9] = a2;
      dyld3::MachOAnalyzer::forEachRebase((dyld3::MachOFile *)v13, (vm_address_t *)v48 + 5, 0, (uint64_t)v45);
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 0x40000000LL;
      v44[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_4;
      v44[3] = &unk_18961F460;
      v44[8] = v13;
      v44[9] = a3;
      v44[10] = v12;
      v44[11] = a2;
      v44[4] = &v47;
      v44[5] = &v63;
      v44[6] = &v53;
      v44[7] = this;
      dyld3::MachOAnalyzer::forEachBind( (dyld3::MachOFile *)v13,  (vm_address_t *)v48 + 5,  (uint64_t)v44,  (uint64_t)&__block_literal_global);
    }

    uint64_t v15 = v64[7];
    if (v15)
    {
      uint64_t v16 = v64[5];
      uint64_t v17 = v16 + 32 * v15;
      unint64_t v43 = this + 24;
      do
      {
        uint64_t v18 = *(void *)(v16 + 16);
        if (v18)
        {
          uint64_t v19 = *(void *)(v16 + 8);
          if (v19)
          {
            uint64_t v20 = this[22];
            if (!v20) {
              goto LABEL_20;
            }
            uint64_t v21 = 0LL;
            char v22 = this[21];
            uint64_t v23 = 16LL * (void)v20;
            do
            {
              if (v22[1] == v18)
              {
                uint64_t v21 = *v22;
                uint64_t *v22 = v19;
              }

              v22 += 2;
              v23 -= 16LL;
            }

            while (v23);
            if (v21)
            {
              char v24 = 0;
            }

            else
            {
LABEL_20:
              lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)v20 + 1);
              uint64_t v21 = 0LL;
              unint64_t v25 = this[21];
              uint64_t v26 = this[22];
              this[22] = (uint64_t *)((char *)v26 + 1);
              uint64_t v27 = &v25[2 * (void)v26];
              uint64_t *v27 = v19;
              v27[1] = v18;
              char v24 = 1;
            }

            if (*((_BYTE *)this[1] + 206))
            {
              uint64_t v28 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
              dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "%s has interposed '%s' to replacing binds to 0x%08lX with 0x%08lX\n",  v28,  *(const char **)(v16 + 24),  *(void *)(v16 + 16),  *(void *)(v16 + 8));
            }

            uint64_t v29 = *(void *)(v16 + 16);
            lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)v43, (unint64_t)this[26] + 1);
            uint64_t v30 = this[25];
            uint64_t v31 = this[26];
            this[26] = (uint64_t *)((char *)v31 + 1);
            vm_address_t v32 = &v30[3 * (void)v31];
            uint64_t *v32 = (uint64_t)a2;
            if ((v24 & 1) != 0)
            {
              v32[1] = v29;
              v32[2] = v29;
            }

            else
            {
              v32[1] = v21;
              v32[2] = v29;
              if (*((_BYTE *)this[1] + 206)) {
                dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "   '%s' was previously interposed, so chaining 0x%08lX to call through to 0x%08lX\n",  *(const char **)(v16 + 24),  *(void *)(v16 + 8),  v21);
              }
            }

            uint64_t v33 = v54[7];
            if (v33)
            {
              uint64_t v34 = (void *)v54[5];
              uint64_t v35 = 16 * v33;
              do
              {
                if (v34[1] == *(void *)(v16 + 16))
                {
                  uint64_t v36 = *(void *)(v16 + 8);
                  uint64_t v37 = *v34;
                  lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)(this + 20), (unint64_t)this[22] + 1);
                  uint64_t v38 = this[21];
                  uint64_t v39 = this[22];
                  this[22] = (uint64_t *)((char *)v39 + 1);
                  uint64_t v40 = &v38[2 * (void)v39];
                  *uint64_t v40 = v36;
                  v40[1] = v37;
                  if (*((_BYTE *)this[1] + 206))
                  {
                    uint64_t v41 = dyld4::Loader::leafName(a2, (const dyld4::RuntimeState *)this);
                    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "%s has interposed '%s' so need to patch cache uses of 0x%08lX\n",  v41,  *(const char **)(v16 + 24),  *v34);
                  }
                }

                v34 += 2;
                v35 -= 16LL;
              }

              while (v35);
            }
          }
        }

        v16 += 32LL;
      }

      while (v16 != v17);
    }

    _Block_object_dispose(&v47, 8);
    mach_o::Error::~Error(v42[0]);
    _Block_object_dispose(&v53, 8);
    uint64_t v60 = 0LL;
    if (v61) {
      vm_deallocate(mach_task_self_, v61, v62);
    }
    _Block_object_dispose(&v63, 8);
  }

__n128 __Block_byref_object_copy__47(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double __Block_byref_object_copy__49(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__50(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke( uint64_t a1, unsigned int *a2)
{
  v24[0] = 0LL;
  v24[1] = v24;
  v24[2] = 0x5002000000LL;
  v24[3] = __Block_byref_object_copy__53;
  v24[4] = __Block_byref_object_dispose__54;
  v24[5] = &v29;
  v24[6] = 128LL;
  vm_address_t v26 = 0LL;
  vm_size_t v27 = 0LL;
  uint64_t v25 = 0LL;
  v20[0] = 0LL;
  v20[1] = v20;
  v20[2] = 0x5002000000LL;
  v20[3] = __Block_byref_object_copy__55;
  v20[4] = __Block_byref_object_dispose__56;
  v20[5] = &v28;
  v20[6] = 128LL;
  vm_address_t address = 0LL;
  vm_size_t size = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v4 = *(dyld3::MachOFile **)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  unsigned int v8 = (vm_address_t *)(*(void *)(v6 + 8) + 40LL);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000LL;
  v19[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57;
  v19[3] = &unk_18961F3C0;
  uint64_t v9 = *(void *)(a1 + 72);
  v19[8] = v5;
  void v19[9] = v9;
  v19[4] = v6;
  v19[5] = v24;
  v19[6] = v7;
  v19[7] = v20;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(v4, v8, (uint64_t)v19);
  if (!Diagnostics::hasError((Diagnostics *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)))
  {
    uint64_t v10 = dyld3::MachOFile::preferredLoadAddress(*(dyld3::MachOFile **)(a1 + 64));
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
    v15[1] = 0x40000000LL;
    __int128 v12 = *(_OWORD *)(a1 + 64);
    __int128 v16 = *(_OWORD *)(a1 + 80);
    char v13 = (vm_address_t *)(v11 + 40);
    v15[0] = _NSConcreteStackBlock;
    v15[2] = ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2;
    v15[3] = &unk_18961F3E8;
    uint64_t v17 = v10;
    uint64_t v14 = *(void *)(a1 + 48);
    __int128 v18 = v12;
    v15[4] = v14;
    void v15[5] = v24;
    v15[6] = v20;
    dyld3::MachOLoaded::forEachFixupInAllChains(v12, v13, a2, 0, (uint64_t)v15);
  }

  _Block_object_dispose(v20, 8);
  uint64_t v21 = 0LL;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  _Block_object_dispose(v24, 8);
  uint64_t v25 = 0LL;
  if (v26) {
    vm_deallocate(mach_task_self_, v26, v27);
  }
}

double __Block_byref_object_copy__53(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__54(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double __Block_byref_object_copy__55(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__56(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57( uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v10 = *(dyld4::RuntimeState **)(a1 + 64);
  dyld4::Loader::resolveSymbol( *(dyld4::Loader **)(a1 + 72),  v10,  (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  a2,  a3,  a5,  0LL,  0LL,  (uint64_t)v21);
  if (Diagnostics::hasError((Diagnostics *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)))
  {
    uint64_t v11 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 72), v10);
    dyld4::RuntimeState::log(v10, "warning could not apply interposing tuples in %s\n", v11);
    *a6 = 1;
  }

  else
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
    char v13 = (char *)dyld4::Loader::resolvedAddress(v10, (uint64_t)v21) + a4;
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v12 + 40), 1LL);
    uint64_t v14 = *(void *)(v12 + 40);
    uint64_t v15 = *(void *)(v12 + 56);
    *(void *)(v12 + 56) = v15 + 1;
    *(void *)(v14 + 8 * v15) = v13;
    uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v17 = *(void *)(v16 + 56);
    if (!v17) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    dyld4::RuntimeState::checkHiddenCacheAddr( v10,  v21[0],  *(void *)(*(void *)(v16 + 40) + 8 * v17 - 8),  (const unsigned __int8 *)a3,  (uint64_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
    uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8LL);
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v18 + 40), 1LL);
    uint64_t v19 = *(void *)(v18 + 40);
    uint64_t v20 = *(void *)(v18 + 56);
    *(void *)(v18 + 56) = v20 + 1;
    *(void *)(v19 + 8 * v20) = a3;
  }

void *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2( void *result, mach_o::ChainedFixupPointerOnDisk *this, uint64_t a3)
{
  unint64_t v3 = result[7];
  if (v3 <= (unint64_t)this)
  {
    uint64_t v4 = result;
    if (result[8] > (unint64_t)this)
    {
      uint64_t v5 = (uint64_t)this - v3;
      unint64_t v6 = (v5 >> 3) / 2;
      if ((((v5 >> 3) + (v5 >> 3 < 0)) & 0xFFFFFFFFFFFFFFFELL) == v5 >> 3)
      {
        double result = (void *)mach_o::ChainedFixupPointerOnDisk::isRebase( this,  *(unsigned __int16 *)(a3 + 6),  result[9],  &v19);
        if ((_DWORD)result)
        {
          uint64_t v9 = *(void *)(v4[4] + 8LL);
          if (*(void *)(v9 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)result,  v7,  v8);
          }
          *(void *)(*(void *)(v9 + 40) + 32 * v6 + 8) = v19 + v4[10];
          uint64_t v10 = *(void *)(v4[4] + 8LL);
          if (*(void *)(v10 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)result,  v7,  v8);
          }
          *(void *)(*(void *)(v10 + 40) + 32 * v6) = v4[11];
        }
      }

      else
      {
        double result = (void *)mach_o::ChainedFixupPointerOnDisk::isBind(this, *(unsigned __int16 *)(a3 + 6), &v18, &v19);
        if ((_DWORD)result)
        {
          uint64_t v11 = (void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(*(void *)(v4[5] + 8LL) + 40LL),  v18);
          uint64_t v14 = *(void *)(v4[4] + 8LL);
          if (*(void *)(v14 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)v11,  v12,  v13);
          }
          *(void *)(*(void *)(v14 + 40) + 32 * v6 + 16) = *v11;
          double result = (void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(*(void *)(v4[6] + 8LL) + 40LL),  v18);
          uint64_t v17 = *(void *)(v4[4] + 8LL);
          if (*(void *)(v17 + 56) <= v6) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)result,  v15,  v16);
          }
          *(void *)(*(void *)(v17 + 40) + 32 * v6 + 24) = *result;
        }
      }
    }
  }

  return result;
}

uint64_t dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 8 * a2;
}

void *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_3( void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result[6];
  unint64_t v4 = (void *)(result[5] + a2);
  if (v3 <= (unint64_t)v4 && result[7] > (unint64_t)v4)
  {
    uint64_t v5 = (uint64_t)((uint64_t)v4 - v3) >> 3;
    uint64_t v6 = *(void *)(result[4] + 8LL);
    if (*(void *)(v6 + 56) <= (unint64_t)(v5 / 2)) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)result,  a2,  a3);
    }
    *(void *)(*(void *)(v6 + 40) + 32 * (v5 / 2) + 8) = result[8] + *v4;
    uint64_t v7 = *(void *)(result[4] + 8LL);
    if (*(void *)(v7 + 56) <= (unint64_t)(v5 / 2)) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)result,  a2,  a3);
    }
    *(void *)(*(void *)(v7 + 40) + 32 * (v5 / 2)) = result[9];
  }

  return result;
}

dyld3::MachOFile *___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_4( dyld3::MachOFile *result, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *((void *)result + 8) + a2;
  if (*((void *)result + 9) <= v8)
  {
    uint64_t v9 = result;
    if (*((void *)result + 10) > v8)
    {
      uint64_t v12 = (dyld4::RuntimeState *)*((void *)result + 7);
      dyld4::Loader::resolveSymbol( *((dyld4::Loader **)result + 11),  v12,  (vm_address_t *)(*(void *)(*((void *)result + 4) + 8LL) + 40LL),  a3,  a5,  a6,  a7,  0LL,  (uint64_t)v21);
      double result = (dyld3::MachOFile *)Diagnostics::noError((Diagnostics *)(*(void *)(v9[4] + 8LL) + 40LL));
      if ((_DWORD)result)
      {
        uint64_t v13 = (uint64_t)(v8 - v9[9]) >> 3;
        if (v13 >= 0) {
          uint64_t v14 = (uint64_t)(v8 - v9[9]) >> 3;
        }
        else {
          uint64_t v14 = v13 + 1;
        }
        uint64_t v15 = dyld4::Loader::resolvedAddress(v12, (uint64_t)v21);
        uint64_t v18 = *(void *)(v9[5] + 8LL);
        if (*(void *)(v18 + 56) <= (unint64_t)(v14 >> 1)) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)v15,  v16,  v17);
        }
        uint64_t v19 = (uint64_t)v15 + a8;
        *(void *)(*(void *)(v18 + 40) + 32 * (v14 >> 1) + 16) = (char *)v15 + a8;
        uint64_t v20 = *(void *)(v9[5] + 8LL);
        if (*(void *)(v20 + 56) <= (unint64_t)(v14 >> 1)) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( (uint64_t)v15,  v16,  v19);
        }
        *(void *)(*(void *)(v20 + 40) + 32 * (v14 >> 1) + 24) = a5;
        return dyld4::RuntimeState::checkHiddenCacheAddr( v12,  v21[0],  v19,  (const unsigned __int8 *)a5,  (uint64_t *)(*(void *)(v9[6] + 8LL) + 40LL));
      }
    }
  }

  return result;
}

void dyld4::RuntimeState::buildInterposingTables(dyld4::RuntimeState *this)
{
  if (*(_BYTE *)(*((void *)this + 1) + 190LL))
  {
    uint64_t v27 = 0LL;
    char v28 = &v27;
    uint64_t v29 = 0x2000000000LL;
    int v30 = 0;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x5002000000LL;
    uint64_t v20 = __Block_byref_object_copy__74;
    uint64_t v21 = __Block_byref_object_dispose__75;
    char v22 = &v31;
    uint64_t v23 = 8LL;
    vm_address_t address = 0LL;
    vm_size_t size = 0LL;
    uint64_t v24 = 0LL;
    uint64_t v2 = *((void *)this + 6);
    if (v2)
    {
      unint64_t v3 = (dyld4::Loader **)*((void *)this + 5);
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *v3;
        uint64_t v6 = (dyld3::MachOFile *)dyld4::Loader::analyzer(*v3, this);
        if ((*((_WORD *)v5 + 2) & 2) == 0)
        {
          uint64_t v7 = v6;
          if (dyld3::MachOFile::isDylib(v6))
          {
            Diagnostics::Diagnostics((Diagnostics *)&v16);
            v15[0] = _NSConcreteStackBlock;
            v15[1] = 0x40000000LL;
            v15[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke;
            v15[3] = &unk_18961F4C8;
            v15[4] = &v27;
            void v15[5] = &v17;
            v15[6] = v5;
            dyld3::MachOFile::forEachInterposingSection(v7, (uint64_t)&v16, (uint64_t)v15);
            mach_o::Error::~Error(&v16);
          }
        }

        ++v3;
        v4 -= 8LL;
      }

      while (v4);
      unint64_t v8 = *((unsigned int *)v28 + 6);
      if ((_DWORD)v8)
      {
        lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)this + 160, v8);
        lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)this + 192, *((unsigned int *)v28 + 6));
        uint64_t v9 = v18[7];
        if (v9)
        {
          uint64_t v10 = (dyld4::Loader **)v18[5];
          uint64_t v11 = 8 * v9;
          do
          {
            uint64_t v12 = *v10++;
            Diagnostics::Diagnostics((Diagnostics *)&v16);
            uint64_t v13 = (_DWORD *)dyld4::Loader::analyzer(v12, this);
            v14[0] = _NSConcreteStackBlock;
            v14[1] = 0x40000000LL;
            v14[2] = ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2;
            v14[3] = &__block_descriptor_tmp_78;
            v14[4] = this;
            v14[5] = v12;
            void v14[6] = v13;
            dyld3::MachOFile::forEachInterposingSection(v13, (uint64_t)&v16, (uint64_t)v14);
            mach_o::Error::~Error(&v16);
            v11 -= 8LL;
          }

          while (v11);
        }
      }
    }

    _Block_object_dispose(&v17, 8);
    uint64_t v24 = 0LL;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(&v27, 8);
  }

double __Block_byref_object_copy__74(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__75(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke( void *a1, uint64_t a2, unint64_t a3)
{
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) += a3 >> 4;
  uint64_t v4 = *(void *)(a1[5] + 8LL);
  double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v4 + 40), 1LL);
  uint64_t v6 = a1[6];
  uint64_t v7 = *(void *)(v4 + 40);
  uint64_t v8 = *(void *)(v4 + 56);
  *(void *)(v4 + 56) = v8 + 1;
  *(void *)(v7 + 8 * v8) = v6;
  return result;
}

uint64_t lsl::Vector<dyld4::InterposeTupleAll>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact(result, v2);
  }

  return result;
}

uint64_t lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact(result, v2);
  }

  return result;
}

void ___ZN5dyld412RuntimeState22buildInterposingTablesEv_block_invoke_2( uint64_t a1, uint64_t a2, unint64_t a3)
{
}

void *dyld4::RuntimeState::setLaunchMissingDylib(void *this, const char *a2, const char *a3)
{
  this[77] = 1LL;
  this[78] = a3;
  this[79] = a2;
  this[80] = 0LL;
  return this;
}

void *dyld4::RuntimeState::setLaunchMissingSymbol( void *this, const char *a2, const char *a3, const char *a4)
{
  this[77] = 4LL;
  this[78] = a4;
  this[79] = a3;
  this[80] = a2;
  return this;
}

BOOL dyld4::RuntimeState::hasMissingFlatLazySymbols(dyld4::RuntimeState *this)
{
  return *((void *)this + 113) != 0LL;
}

void dyld4::RuntimeState::setVMAccountingSuspending(dyld4::RuntimeState *this, int a2)
{
  if (*((unsigned __int8 *)this + 1129) != a2)
  {
    if (*(_BYTE *)(*((void *)this + 1) + 202LL)) {
      dyld4::RuntimeState::log(this, "set vm.footprint_suspend=%d\n", a2);
    }
    int v9 = 0;
    int v10 = a2;
    size_t v8 = 4LL;
    int v4 = sysctlbyname("vm.footprint_suspend", &v9, &v8, &v10, 4uLL);
    if (*(_BYTE *)(*((void *)this + 1) + 202LL)) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      int v6 = v4;
      uint64_t v7 = __error();
      dyld4::RuntimeState::log(this, "vm.footprint_suspend => %d, errno=%d\n", v6, *v7);
    }

    *((_BYTE *)this + 1129) = a2;
  }

uint64_t dyld4::RuntimeState::incDlRefCount(uint64_t this, const dyld4::Loader *a2)
{
  if ((*((_WORD *)a2 + 2) & 0x20) == 0)
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 1048);
    if (v4)
    {
      BOOL v5 = (void *)(*(void *)(this + 1040) + 8LL);
      uint64_t v6 = 16 * v4;
      while ((const dyld4::Loader *)*(v5 - 1) != a2)
      {
        v5 += 2;
        v6 -= 16LL;
        if (!v6) {
          goto LABEL_6;
        }
      }

      ++*v5;
    }

    else
    {
LABEL_6:
      this = lsl::Vector<dyld4::InterposeTupleAll>::reserve(this + 1032, v4 + 1);
      uint64_t v7 = *(void *)(v3 + 1040);
      uint64_t v8 = *(void *)(v3 + 1048);
      *(void *)(v3 + 1048) = v8 + 1;
      int v9 = (void *)(v7 + 16 * v8);
      void *v9 = a2;
      v9[1] = 1LL;
    }
  }

  return this;
}

os_unfair_lock_s *dyld4::RuntimeState::decDlRefCount(os_unfair_lock_s *this, const dyld4::Loader *a2)
{
  if ((*((_WORD *)a2 + 2) & 0x20) == 0)
  {
    uint64_t v3 = this;
    uint64_t v4 = *(lsl::Lock **)&this[32]._os_unfair_lock_opaque;
    lsl::MemoryManager::lockGuard(v4, &v16);
    uint64_t v5 = *((void *)v4 + 3);
    if (!v5)
    {
      lsl::MemoryManager::writeProtect(v4, 0);
      uint64_t v5 = *((void *)v4 + 3);
    }

    *((void *)v4 + 3) = v5 + 1;
    lsl::Lock::unlock(v16);
    uint64_t v6 = *(void *)&v3[262]._os_unfair_lock_opaque;
    if (v6)
    {
      uint64_t v7 = (void *)(*(void *)&v3[260]._os_unfair_lock_opaque + 8LL);
      size_t v8 = 16 * v6 - 16;
      while ((const dyld4::Loader *)*(v7 - 1) != a2)
      {
        v7 += 2;
        v8 -= 16LL;
        if (v8 == -16LL) {
          goto LABEL_20;
        }
      }

      if ((*v7)-- == 1LL)
      {
        if (v8)
        {
          memmove(v7 - 1, v7 + 1, v8);
          uint64_t v6 = *(void *)&v3[262]._os_unfair_lock_opaque;
        }

        *(void *)&v3[262]._os_unfair_lock_opaque = v6 - 1;
        p_os_unfair_lock_opaque = &v3[274]._os_unfair_lock_opaque;
        do
          unsigned int v11 = __ldxr(p_os_unfair_lock_opaque);
        while (__stxr(v11 + 1, p_os_unfair_lock_opaque));
        if (!v11)
        {
          do
          {
            dyld4::RuntimeState::garbageCollectInner((dyld4::RuntimeState *)v3);
            do
            {
              unsigned int v12 = __ldxr(p_os_unfair_lock_opaque);
              BOOL v13 = __OFSUB__(v12, 1);
              signed int v14 = v12 - 1;
            }

            while (__stxr(v14, p_os_unfair_lock_opaque));
          }

          while (!((v14 < 0) ^ v13 | (v14 == 0)));
        }
      }
    }

LABEL_20:
    lsl::MemoryManager::lockGuard(v4, &v16);
    uint64_t v15 = *((void *)v4 + 3) - 1LL;
    *((void *)v4 + 3) = v15;
    if (!v15) {
      lsl::MemoryManager::writeProtect(v4, 1);
    }
    return lsl::Lock::unlock(v16);
  }

  return this;
}

  this[117] = v5 - (&v4[v5] - v7);
  if (this[42])
  {
    BOOL v13 = (dyld3::MachOFile *)dyld4::Loader::analyzer(a2, (dyld4::RuntimeState *)this);
    if ((dyld3::MachOFile::hasWeakDefs(v13) & 1) != 0
      || (this = (void *)dyld3::MachOFile::usesWeakDefs(v13), (_DWORD)this))
    {
      this = (void *)dyld3::MachOFile::mappedSize(v13);
      signed int v14 = v3[42];
      uint64_t v15 = *(void *)(v14 + 72);
      if (v15)
      {
        uint64_t v16 = (char *)this + (void)v13;
        uint64_t v17 = (const dyld4::Loader **)(*(void *)(v14 + 56) + 8LL);
        uint64_t v18 = 24 * v15;
        do
        {
          if (*v17 == a2) {
            *uint64_t v17 = 0LL;
          }
          uint64_t v19 = (const char *)*(v17 - 1);
          if (v19 >= (const char *)v13 && v19 < v16)
          {
            this = lsl::Allocator::strdup((lsl::Lock **)v3[2], v19);
            *(v17 - 1) = (const dyld4::Loader *)this;
          }

          v17 += 3;
          v18 -= 24LL;
        }

        while (v18);
      }
    }
  }

  return this;
}

  lsl::Allocator::~Allocator((lsl::Allocator *)v15);
}

    double result = Diagnostics::error( *(vm_address_t **)(v5 + 64),  "initializer 0x%0llX does not point within executable segment");
  }

  else
  {
    if (!a3) {
      return result;
    }
    while (1)
    {
      signed int v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 56), *(unsigned int *)v6);
      uint64_t v15 = *(void *)(*(void *)(v5 + 40) + 8LL);
      uint64_t v16 = *(void *)(v15 + 80);
      if (!v16) {
        break;
      }
      uint64_t v17 = *(void *)(v15 + 64);
      uint64_t v18 = 24 * v16;
      uint64_t v19 = (void *)(v17 + 8);
      while (*(v19 - 1) > (unint64_t)v14 || *v19 <= (unint64_t)v14)
      {
        v19 += 3;
        v18 -= 24LL;
        if (!v18) {
          goto LABEL_21;
        }
      }

      double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16LL))( *(void *)(v5 + 32),  v14 - *(_DWORD *)(v5 + 72));
      uint64_t v6 = (uint64_t *)((char *)v6 + 4);
      if (v6 >= v7) {
        return result;
      }
    }

void *dyld4::Reaper::markDirectlyDlopenedImagesAsUsed(void *this)
{
  uint64_t v1 = *(void *)(*this + 1048LL);
  if (v1)
  {
    unint64_t v2 = *(void **)(*this + 1040LL);
    uint64_t v3 = &v2[2 * v1];
    do
    {
      if (v2[1])
      {
        uint64_t v4 = (void *)this[1];
        uint64_t v5 = v4[2];
        if (v5)
        {
          uint64_t v6 = (_BYTE *)(*v4 + 8LL);
          uint64_t v7 = 16 * v5;
          while (*((void *)v6 - 1) != *v2)
          {
            v6 += 16;
            v7 -= 16LL;
            if (!v7) {
              goto LABEL_10;
            }
          }

          *uint64_t v6 = 1;
        }
      }

LABEL_10:
      v2 += 2;
    }

    while (v2 != v3);
  }

  return this;
}

      uint64_t v6 = (v6 + 1);
    }

    while ((_DWORD)v6 != v5);
  }

  unsigned int v11 = *((void *)*this + 117);
  if (v11)
  {
    unsigned int v12 = *((void *)*this + 116);
    BOOL v13 = v12 + 16 * v11;
    do
    {
      if (*(const dyld4::Loader **)v12 == a2)
      {
        signed int v14 = this[1];
        uint64_t v15 = *((void *)v14 + 2);
        if (v15)
        {
          uint64_t v16 = (_BYTE *)(*(void *)v14 + 8LL);
          uint64_t v17 = 16 * v15;
          while (*((void *)v16 - 1) != *(void *)(v12 + 8))
          {
            v16 += 16;
            v17 -= 16LL;
            if (!v17) {
              goto LABEL_14;
            }
          }

          lsl::Lock *v16 = 1;
        }
      }

    *a4 = v5 + 1;
    int v9 = a2[v5] | v8;
LABEL_11:
    a2[v5] = v9;
    int v10 = *(unsigned __int8 *)v6++;
    uint64_t v4 = v10;
    double result = v10 == 0;
    if (v10)
    {
      v7 ^= 1u;
      uint64_t v5 = *a4;
      if (*a4 <= a3) {
        continue;
      }
    }

    return result;
  }

    unsigned int v11 = *((void *)this + 1);
    if (*(_BYTE *)(v11 + 190))
    {
      unsigned int v12 = *((void *)this + 26);
      if (v12)
      {
        uint64_t v7 = (dyld4::RuntimeState **)(*((void *)this + 25) + 8LL);
        BOOL v13 = 24 * v12;
        while (v7[1] != a2 || *(v7 - 1) != a3)
        {
          v7 += 3;
          v13 -= 24LL;
          if (!v13) {
            goto LABEL_16;
          }
        }

        if (!*(_BYTE *)(v11 + 206)) {
          return *v7;
        }
        uint64_t v16 = *v7;
        goto LABEL_24;
      }

  *(void *)(*(void *)(a1 + 80) + 8LL * (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))++) = v10;
  mach_o::Error::~Error(&v33);
}

  size_t v8 = *(dyld4::Atlas::Mapper **)&v3[2]._os_unfair_lock_opaque;
  if (!v8) {
    goto LABEL_25;
  }
  *(void *)&uint64_t v19 = *(void *)&v3[2]._os_unfair_lock_opaque;
  *((void *)&v19 + 1) = 4096LL;
  int v9 = dyld4::Atlas::Mapper::map(v8, v5, 4096LL);
  uint64_t v20 = v9;
  uint64_t v21 = v10;
  if ((__int128 *)((char *)this + 112) != &v19)
  {
    uint64_t v19 = *((_OWORD *)this + 7);
    *((void *)this + 14) = v8;
    *((void *)this + 15) = 4096LL;
    unsigned int v11 = (char *)*((void *)this + 16);
    *((void *)this + 16) = v9;
    uint64_t v20 = v11;
    LOBYTE(v11) = *((_BYTE *)this + 136);
    *((_BYTE *)this + 136) = v10;
    uint64_t v21 = (char)v11;
  }

  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
  double result = (_DWORD *)*((void *)this + 16);
  if (!result) {
    goto LABEL_25;
  }
  unsigned int v12 = result[5];
  BOOL v13 = 28LL;
  if (*result == -17958193) {
    BOOL v13 = 32LL;
  }
  signed int v14 = v13 + v12;
  if ((unint64_t)(v13 + v12) > 0x1000)
  {
    uint64_t v15 = *(void *)v4 ? *(dyld4::Atlas::Mapper **)(*(void *)v4 + 8LL) : 0LL;
    *(void *)&uint64_t v19 = v15;
    *((void *)&v19 + 1) = v13 + v12;
    uint64_t v16 = dyld4::Atlas::Mapper::map(v15, v5, v14);
    uint64_t v20 = v16;
    uint64_t v21 = v17;
    if ((__int128 *)((char *)this + 112) != &v19)
    {
      uint64_t v19 = *((_OWORD *)this + 7);
      *((void *)this + 14) = v15;
      *((void *)this + 15) = v14;
      uint64_t v18 = (char *)*((void *)this + 16);
      *((void *)this + 16) = v16;
      uint64_t v20 = v18;
      LOBYTE(v18) = *((_BYTE *)this + 136);
      *((_BYTE *)this + 136) = v17;
      uint64_t v21 = (char)v18;
    }

    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v19);
    double result = (_DWORD *)*((void *)this + 16);
    if (!result) {
      goto LABEL_25;
    }
  }

  return result;
}

void *dyld4::Reaper::markDynamicNeverUnloadImagesAsUsed(void *this)
{
  uint64_t v1 = *(void *)(*this + 1080LL);
  if (v1)
  {
    unint64_t v2 = *(void **)(*this + 1072LL);
    uint64_t v3 = &v2[v1];
    uint64_t v4 = (uint64_t *)this[1];
    uint64_t v5 = *v4;
    uint64_t v6 = v4[2];
    uint64_t v7 = (_BYTE *)(v5 + 8);
    do
    {
      if (v6)
      {
        uint64_t v8 = 16 * v6;
        int v9 = v7;
        while (*((void *)v9 - 1) != *v2)
        {
          v9 += 16;
          v8 -= 16LL;
          if (!v8) {
            goto LABEL_9;
          }
        }

        _BYTE *v9 = 1;
      }

LABEL_9:
      ++v2;
    }

    while (v2 != v3);
  }

  return this;
}

    unsigned int v11 = 195903495LL;
    goto LABEL_10;
  }

  int v10 = *v9;
  if (*v9 != 1) {
    goto LABEL_4;
  }
}

    int v10 = 195903495LL;
    goto LABEL_10;
  }

  int v9 = *v8;
  if (*v8 != 1) {
    goto LABEL_4;
  }
  return result;
}

    std::__throw_bad_optional_access[abi:nn180100]();
  }

  return result;
}

    uint64_t v5 = (_BYTE *)(*this)++;
    *uint64_t v5 = a2 / 0x3E8 + 48;
    LODWORD(a2) = a2 % 0x3E8;
LABEL_10:
    if (a2 < 0x64)
    {
      uint64_t v6 = (_BYTE *)(*this)++;
      *uint64_t v6 = 48;
      goto LABEL_13;
    }

    unsigned int v11 = a1[1];
    ++a1;
    double result = v11;
    if (!v11) {
      return result;
    }
  }

uint64_t dyld4::Reaper::markDependentsOf(dyld4::RuntimeState **this, const dyld4::Loader *a2)
{
  uint64_t result = dyld4::Loader::dependentCount(a2);
  if ((_DWORD)result)
  {
    int v5 = result;
    uint64_t v6 = 0LL;
    do
    {
      uint64_t result = dyld4::Loader::dependent(a2, *this, v6, 0LL);
      uint64_t v7 = this[1];
      uint64_t v8 = *((void *)v7 + 2);
      if (v8)
      {
        int v9 = (_BYTE *)(*(void *)v7 + 8LL);
        uint64_t v10 = 16 * v8;
        while (*v9 || *((void *)v9 - 1) != result)
        {
          v9 += 16;
          v10 -= 16LL;
          if (!v10) {
            goto LABEL_10;
          }
        }

        _BYTE *v9 = 1;
      }

uint64_t dyld4::Reaper::markDependentOfInUseImages(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 8);
  uint64_t v2 = v1[2];
  if (v2)
  {
    uint64_t v3 = (dyld4::RuntimeState **)this;
    uint64_t v4 = 16 * v2;
    int v5 = (const dyld4::Loader **)(*v1 + 8LL);
    do
    {
      if (*(_BYTE *)v5) {
        this = dyld4::Reaper::markDependentsOf(v3, *(v5 - 1));
      }
      v5 += 2;
      v4 -= 16LL;
    }

    while (v4);
  }

  return this;
}

uint64_t dyld4::Reaper::garbageCollect(dyld4::Reaper *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  uint64_t v3 = v2[2];
  if (v3)
  {
    int v4 = 0;
    uint64_t v5 = *v2;
    uint64_t v6 = 16 * v3;
    uint64_t v7 = (unsigned __int8 *)(v5 + 8);
    do
    {
      int v8 = *v7;
      v7 += 16;
      v4 += v8;
      v6 -= 16LL;
    }

    while (v6);
  }

  else
  {
    int v4 = 0;
  }

  do
  {
    while (1)
    {
      int v9 = v4;
      uint64_t result = dyld4::Reaper::markDependentOfInUseImages((uint64_t)this);
      uint64_t v11 = (uint64_t *)*((void *)this + 1);
      uint64_t v12 = v11[2];
      if (v12) {
        break;
      }
      int v4 = 0;
      if (!v9) {
        goto LABEL_15;
      }
    }

    int v4 = 0;
    uint64_t v13 = *v11;
    uint64_t v14 = 16 * v12;
    uint64_t v15 = (unsigned __int8 *)(v13 + 8);
    uint64_t v16 = 16 * v12;
    do
    {
      int v17 = *v15;
      v15 += 16;
      v4 += v17;
      v16 -= 16LL;
    }

    while (v16);
  }

  while (v4 != v9);
  int v18 = 0;
  uint64_t v19 = (unsigned __int8 *)(v13 + 8);
  do
  {
    int v20 = *v19;
    v19 += 16;
    v18 += v20;
    v14 -= 16LL;
  }

  while (v14);
  LODWORD(v12) = v12 - v18;
LABEL_15:
  *((_DWORD *)this + 4) = v12;
  return result;
}

void dyld4::Reaper::finalizeDeadImages(dyld4::Reaper *this)
{
  uint64_t v1 = *((unsigned int *)this + 4);
  if ((_DWORD)v1 && *(void *)(*(void *)this + 152LL))
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x5002000000LL;
    uint64_t v14 = __Block_byref_object_copy__84;
    uint64_t v15 = __Block_byref_object_dispose__85;
    uint64_t v3 = *((unsigned int *)this + 4);
    uint64_t v16 = (char *)&v10[-1] - ((16 * v1 + 23) & 0x1FFFFFFFF0LL);
    uint64_t v17 = v3;
    vm_address_t v19 = 0LL;
    vm_size_t v20 = 0LL;
    uint64_t v18 = 0LL;
    int v4 = (uint64_t *)*((void *)this + 1);
    uint64_t v5 = v4[2];
    if (v5)
    {
      uint64_t v6 = *v4;
      uint64_t v7 = 16 * v5;
      do
      {
        if (!*(_BYTE *)(v6 + 8))
        {
          int v8 = (_DWORD *)dyld4::Loader::analyzer(*(dyld4::Loader **)v6, *(dyld4::RuntimeState **)this);
          if ((*(_WORD *)(*(void *)v6 + 4LL) & 2) == 0)
          {
            v10[0] = _NSConcreteStackBlock;
            v10[1] = 0x40000000LL;
            v10[2] = ___ZN5dyld46Reaper18finalizeDeadImagesEv_block_invoke;
            v10[3] = &unk_18961F510;
            v10[4] = &v11;
            v10[5] = v8;
            dyld3::MachOFile::forEachSegment(v8, (uint64_t)v10);
          }
        }

        v6 += 16LL;
        v7 -= 16LL;
      }

      while (v7);
      if (v12[7]) {
        (*(void (**)(void, uint64_t))(**(void **)(*(void *)this + 152LL) + 88LL))( *(void *)(*(void *)this + 152LL),  v12[5]);
      }
    }

    _Block_object_dispose(&v11, 8);
    uint64_t v18 = 0LL;
    if (v19) {
      vm_deallocate(mach_task_self_, v19, v20);
    }
  }

double __Block_byref_object_copy__84(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__85(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZN5dyld46Reaper18finalizeDeadImagesEv_block_invoke(void *result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 52) & 4) != 0)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a2 + 16);
    uint64_t v5 = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)result[5]) + v4;
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(v3[4] + 8LL);
    double result = dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace( (void *)(v7 + 40),  1LL);
    uint64_t v8 = *(void *)(v7 + 40);
    uint64_t v9 = *(void *)(v7 + 56);
    *(void *)(v7 + 56) = v9 + 1;
    uint64_t v10 = (void *)(v8 + 16 * v9);
    *uint64_t v10 = v5;
    v10[1] = v6;
  }

  return result;
}

void dyld4::RuntimeState::garbageCollectInner(dyld4::RuntimeState *this)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v37 = 0LL;
  uint64_t v38 = &v37;
  uint64_t v39 = 0x4002000000LL;
  uint64_t v40 = __Block_byref_object_copy__87;
  uint64_t v41 = __Block_byref_object_dispose__88;
  uint64_t v42 = (char *)&v28 - ((16 * v2 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = v2;
  uint64_t v44 = 0LL;
  uint64_t v3 = (void *)*((void *)this + 17);
  v36[0] = _NSConcreteStackBlock;
  v36[1] = 0x40000000LL;
  v36[2] = ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke;
  v36[3] = &unk_18961F538;
  v36[4] = &v37;
  v36[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v3, (uint64_t)v36);
  v34[0] = this;
  v34[1] = v38 + 5;
  int v35 = 0;
  dyld4::Reaper::garbageCollect((dyld4::Reaper *)v34);
  dyld4::Reaper::finalizeDeadImages((dyld4::Reaper *)v34);
  uint64_t v5 = lsl::AllocatorLayout::minSize(v4);
  __chkstk_darwin(v5, v6, v7, v8, v9, v10, v11, v12, v28);
  uint64_t v14 = (lsl::Allocator *)((char *)&v28 - v13);
  uint64_t v15 = v38[7];
  uint64_t v17 = lsl::AllocatorLayout::minSize(v16);
  vm_size_t v20 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v14, (char *)(v17 + 8 * v15 + 64), v18, v19);
  int v30 = v20;
  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v30, v38[7]);
  uint64_t v21 = v38[7];
  if (v21)
  {
    uint64_t v22 = 16 * v21;
    uint64_t v23 = v38[5] + 8;
    uint64_t v24 = (unsigned __int8 *)v23;
    do
    {
      int v25 = *v24;
      v24 += 16;
      if (!v25)
      {
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v30, v32 + 1);
        uint64_t v26 = *(void *)(v23 - 8);
        uint64_t v27 = v32++;
        *(void *)(v31 + 8 * v27) = v26;
      }

      uint64_t v23 = (uint64_t)v24;
      v22 -= 16LL;
    }

    while (v22);
  }

  if (v32)
  {
    uint64_t v28 = v31;
    uint64_t v29 = v32;
    dyld4::RuntimeState::notifyUnload((uint64_t)this, &v28);
    uint64_t v28 = v31;
    uint64_t v29 = v32;
    dyld4::RuntimeState::removeLoaders((lsl::Lock ***)this, (uint64_t)&v28);
  }

  if (v31) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v30, 0LL);
  }
  lsl::Allocator::~Allocator(v20);
  _Block_object_dispose(&v37, 8);
}

__n128 __Block_byref_object_copy__87(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld412RuntimeState19garbageCollectInnerEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4)
  {
    uint64_t v6 = *(void *)(v3 + 40);
    uint64_t v7 = 8 * v4;
    do
    {
      __int16 v8 = *(_WORD *)(*(void *)v6 + 4LL);
      if ((v8 & 2) == 0)
      {
        uint64_t v9 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
        v10.n128_u64[0] = *(void *)v6;
        v10.n128_u8[8] = (v8 & 0x20) != 0;
        dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(v9, &v10, a3);
      }

      v6 += 8LL;
      v7 -= 8LL;
    }

    while (v7);
  }

__n128 dyld3::Array<dyld4::Reaper::LoaderAndUse>::push_back(uint64_t *a1, __n128 *a2, uint64_t a3)
{
  unint64_t v3 = a1[2];
  if (v3 >= a1[1]) {
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)a1, (uint64_t)a2, a3);
  }
  uint64_t v4 = *a1;
  a1[2] = v3 + 1;
  __n128 result = *a2;
  *(__n128 *)(v4 + 16 * v3) = *a2;
  return result;
}

void dyld4::RuntimeState::notifyUnload(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void **)(a1 + 136);
  v71[0] = _NSConcreteStackBlock;
  v71[1] = 0x40000000LL;
  v71[2] = ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v71[3] = &__block_descriptor_tmp_96;
  v71[4] = a1;
  v71[5] = a2;
  dyld4::RuntimeLocks::withNotifiersReadLock(v4, (uint64_t)v71);
  if (*(void *)(a1 + 656))
  {
    uint64_t v12 = a2[1];
    if (v12)
    {
      uint64_t v13 = (dyld4::Loader **)*a2;
      uint64_t v14 = 8 * v12;
      do
      {
        uint64_t v15 = *v13;
        if ((*((_WORD *)*v13 + 2) & 4) != 0)
        {
          uint64_t v16 = *(void (**)(uint64_t, uint64_t))(a1 + 656);
          uint64_t v17 = dyld4::Loader::path(*v13, (const dyld4::RuntimeState *)a1);
          uint64_t Address = dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
          v16(v17, Address);
          if (*(_BYTE *)(*(void *)(a1 + 8) + 205LL))
          {
            vm_address_t v19 = (const void *)dyld4::Loader::loadAddress(v15, (const dyld4::RuntimeState *)a1);
            vm_size_t v20 = (const char *)dyld4::Loader::path(v15, (const dyld4::RuntimeState *)a1);
            dyld4::RuntimeState::log( (dyld4::RuntimeState *)a1,  "objc-unmapped-notifier called with image %p %s\n",  v19,  v20);
          }
        }

        ++v13;
        v14 -= 8LL;
      }

      while (v14);
    }
  }

  if (kdebug_is_enabled(0x1F050000u, v5, v6, v7, v8, v9, v10, v11))
  {
    uint64_t v21 = a2[1];
    if (v21)
    {
      uint64_t v22 = (dyld4::Loader **)*a2;
      uint64_t v23 = 8 * v21;
      do
      {
        int v25 = *v22++;
        uint64_t v24 = (unsigned int *)v25;
        uint64_t v26 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(v25, (const dyld4::RuntimeState *)a1);
        dyld3::MachOFile::getUuid(v26, (unsigned __int8 *)v72);
        uint64_t v27 = (dyld3 *)dyld4::Loader::path(v25, (const dyld4::RuntimeState *)a1);
        int v29 = dyld3::stat(v27, &v70, v28);
        if (v29) {
          __darwin_ino64_t st_ino = 0LL;
        }
        else {
          __darwin_ino64_t st_ino = (unsigned __int8 (*)[16])v70.st_ino;
        }
        if (v29) {
          fsobj_id st_dev = 0LL;
        }
        else {
          fsobj_id st_dev = (fsobj_id)v70.st_dev;
        }
        uint64_t v32 = (void *)dyld4::Loader::path((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        fsid v33 = (fsid)dyld4::Loader::loadAddress((dyld4::Loader *)v24, (const dyld4::RuntimeState *)a1);
        fsobj_id v34 = st_dev;
        dyld3::kdebug_trace_dyld_image((dyld3 *)5, v32, (void **)v72, st_ino, v34, v33, (const void *)v24[6], v35, v64);
        v23 -= 8LL;
      }

      while (v23);
    }
  }

  if (dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8)))
  {
    uint64_t v36 = a2[1];
    if (v36)
    {
      uint64_t v37 = (uint64_t *)*a2;
      uint64_t v38 = *a2 + 8 * v36;
      uint64_t v39 = *(void *)(a1 + 864);
      uint64_t v40 = *(void *)(a1 + 872);
      do
      {
        uint64_t v41 = *v37;
        uint64_t v42 = (_OWORD *)(v39 + 16 * v40);
        if (v40)
        {
          uint64_t v43 = 16 * v40;
          while (*(void *)v39 != v41)
          {
            v39 += 16LL;
            v43 -= 16LL;
            if (!v43)
            {
              uint64_t v44 = v42;
              goto LABEL_34;
            }
          }

          dyld4::SyscallDelegate::dtraceUnregisterUserProbe( *(dyld4::SyscallDelegate **)(a1 + 8),  *(unsigned int *)(v39 + 8));
        }

        uint64_t v44 = v42;
        if ((_OWORD *)v39 != v42)
        {
          uint64_t v45 = v39 + 16;
          uint64_t v44 = (_OWORD *)v39;
          while ((_OWORD *)v45 != v42)
          {
            if (*(void *)v45 == v41) {
              dyld4::SyscallDelegate::dtraceUnregisterUserProbe( *(dyld4::SyscallDelegate **)(a1 + 8),  *(unsigned int *)(v45 + 8));
            }
            else {
              *v44++ = *(_OWORD *)v45;
            }
            v45 += 16LL;
          }
        }

LABEL_34:
        uint64_t v39 = *(void *)(a1 + 864);
        uint64_t v40 = *(void *)(a1 + 872) - ((v39 + 16LL * *(void *)(a1 + 872) - (uint64_t)v44) >> 4);
        *(void *)(a1 + 872) = v40;
        ++v37;
      }

      while (v37 != (uint64_t *)v38);
    }
  }

  dyld4::RuntimeState::removeMissingFlatLazySymbols(a1, (uint64_t)a2);
  uint64_t v46 = *(lsl::Lock **)(a1 + 128);
  uint64_t v47 = *(void **)(a1 + 136);
  v65[0] = _NSConcreteStackBlock;
  v65[1] = 0x40000000LL;
  size_t v66 = (void (*)(void *))___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2;
  size_t v67 = &__block_descriptor_tmp_98;
  uint64_t v68 = a1;
  uint64_t v69 = a2;
  lsl::MemoryManager::lockGuard(v46, (lsl::Lock **)&v70);
  uint64_t v48 = *((void *)v46 + 3);
  if (!v48)
  {
    lsl::MemoryManager::writeProtect(v46, 0);
    uint64_t v48 = *((void *)v46 + 3);
  }

  *((void *)v46 + 3) = v48 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  if (*v47)
  {
    (*(void (**)(void, void *, void))(*(void *)*v47 + 104LL))(*v47, v47 + 1, 0LL);
    v66(v65);
    (*(void (**)(void, void *))(*(void *)*v47 + 112LL))(*v47, v47 + 1);
  }

  else
  {
    ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2(v65);
  }

  lsl::MemoryManager::lockGuard(v46, (lsl::Lock **)&v70);
  uint64_t v49 = *((void *)v46 + 3) - 1LL;
  *((void *)v46 + 3) = v49;
  if (!v49) {
    lsl::MemoryManager::writeProtect(v46, 1);
  }
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  uint64_t v50 = *(lsl::Lock **)(a1 + 128);
  uint64_t v51 = *(void **)(a1 + 136);
  lsl::MemoryManager::lockGuard(v50, (lsl::Lock **)&v70);
  uint64_t v52 = *((void *)v50 + 3);
  if (!v52)
  {
    lsl::MemoryManager::writeProtect(v50, 0);
    uint64_t v52 = *((void *)v50 + 3);
  }

  *((void *)v50 + 3) = v52 + 1;
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  if (*v51)
  {
    (*(void (**)(void, void *, void))(*(void *)*v51 + 104LL))(*v51, v51 + 1, 0LL);
    uint64_t v53 = a2[1];
    if (v53)
    {
      uint64_t v54 = *a2;
      uint64_t v55 = 8 * v53;
      do
      {
        if (*(void *)v54) {
          BOOL v56 = (*(_WORD *)(*(void *)v54 + 4LL) & 1) == 0;
        }
        else {
          BOOL v56 = 0;
        }
        if (v56)
        {
          uint64_t v57 = *(void *)(*(void *)v54 + 104LL);
          if (v57)
          {
            if ((*(uint64_t (**)(void, void))(*(void *)(v57 + 16) + 16LL))( *(void *)(v57 + 24),  *(void *)v57))
            {
              (**(void (***)(void))(v57 + 16))();
            }
          }
        }

        v54 += 8LL;
        v55 -= 8LL;
      }

      while (v55);
    }

    (*(void (**)(void, void *))(*(void *)*v51 + 112LL))(*v51, v51 + 1);
  }

  else
  {
    uint64_t v58 = a2[1];
    if (v58)
    {
      uint64_t v59 = *a2;
      uint64_t v60 = 8 * v58;
      do
      {
        if (*(void *)v59) {
          BOOL v61 = (*(_WORD *)(*(void *)v59 + 4LL) & 1) == 0;
        }
        else {
          BOOL v61 = 0;
        }
        if (v61)
        {
          uint64_t v62 = *(void *)(*(void *)v59 + 104LL);
          if (v62)
          {
            if ((*(uint64_t (**)(void, void))(*(void *)(v62 + 16) + 16LL))( *(void *)(v62 + 24),  *(void *)v62))
            {
              (**(void (***)(void))(v62 + 16))();
            }
          }
        }

        v59 += 8LL;
        v60 -= 8LL;
      }

      while (v60);
    }
  }

  lsl::MemoryManager::lockGuard(v50, (lsl::Lock **)&v70);
  uint64_t v63 = *((void *)v50 + 3) - 1LL;
  *((void *)v50 + 3) = v63;
  if (!v63) {
    lsl::MemoryManager::writeProtect(v50, 1);
  }
  lsl::Lock::unlock(*(lsl::Lock **)&v70.st_dev);
  dyld4::RuntimeState::notifyDebuggerUnload((lsl::Lock ***)a1, a2);
}

void dyld4::RuntimeState::removeLoaders(lsl::Lock ***a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = *(dyld4::Loader ***)a2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      __int16 v7 = *((_WORD *)*v4 + 2);
      if ((v7 & 0x42) == 0)
      {
        if ((v7 & 1) != 0)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
        }

        else if ((*((_BYTE *)v6 + 42) & 0x20) == 0)
        {
          dyld4::Loader::unmap(*v4, (dyld4::RuntimeState *)a1, 0);
          *(_DWORD *)uint64_t v6 = 2053923954;
          lsl::Allocator::free(a1[2], v6);
        }
      }

      ++v4;
      v5 -= 8LL;
    }

    while (v5);
  }

void dyld4::RuntimeState::notifyDtrace(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = dyld4::SyscallDelegate::dtraceUserProbesEnabled(*(dyld4::SyscallDelegate **)(a1 + 8));
  if ((_DWORD)v4)
  {
    v32[1] = (uint64_t)v32;
    __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, v32[0]);
    uint64_t v13 = (dof_ioctl_data *)((char *)v32 - ((v12 + 1295) & 0xFFFFFFFFFFFFFFF0LL));
    v13->uint64_t dofiod_count = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = &v35;
    uint64_t v37 = 0x2000000000LL;
    char v38 = 0;
    uint64_t v14 = *(void *)(a2 + 8);
    if (v14)
    {
      uint64_t v15 = *(dyld4::Loader ***)a2;
      uint64_t v16 = 8 * v14;
      do
      {
        uint64_t v17 = *v15++;
        Diagnostics::Diagnostics((Diagnostics *)&v34);
        uint64_t v18 = (_DWORD *)dyld4::Loader::analyzer(v17, (dyld4::RuntimeState *)a1);
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000LL;
        v33[2] = ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
        v33[3] = &unk_18961F560;
        v33[6] = v13;
        v33[7] = v18;
        v33[8] = v17;
        v33[4] = &v35;
        v33[5] = a1;
        dyld3::MachOFile::forEachDOFSection(v18, (uint64_t)&v34, (uint64_t)v33);
        mach_o::Error::~Error(&v34);
        v16 -= 8LL;
      }

      while (v16);
      if (v13->dofiod_count)
      {
        dyld4::SyscallDelegate::dtraceRegisterUserProbes(*(dyld4::SyscallDelegate **)(a1 + 8), v13);
        if (*((_BYTE *)v36 + 24))
        {
          uint64_t v19 = *(void *)(a2 + 8);
          if (v19)
          {
            vm_size_t v20 = *(dyld4::Loader ***)a2;
            uint64_t v21 = *(void *)a2 + 8 * v19;
            v32[0] = (uint64_t)&v13->dofiod_helpers[0].dofhp_dof;
            do
            {
              uint64_t v22 = *v20;
              if ((*((_WORD *)*v20 + 2) & 0x20) == 0)
              {
                uint64_t v23 = dyld4::Loader::analyzer(*v20, (dyld4::RuntimeState *)a1);
                uint64_t dofiod_count = v13->dofiod_count;
                if (v13->dofiod_count)
                {
                  uint64_t v25 = v23;
                  uint64_t v26 = 0LL;
                  uint64_t v27 = (uint64_t *)v32[0];
                  do
                  {
                    if (*(v27 - 1) == v25)
                    {
                      uint64_t v28 = *v27;
                      lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 856, *(void *)(a1 + 872) + 1LL);
                      uint64_t v29 = *(void *)(a1 + 864);
                      uint64_t v30 = *(void *)(a1 + 872);
                      *(void *)(a1 + 872) = v30 + 1;
                      uint64_t v31 = v29 + 16 * v30;
                      *(void *)uint64_t v31 = v22;
                      *(_DWORD *)(v31 + 8) = v28;
                      uint64_t dofiod_count = v13->dofiod_count;
                    }

                    v27 += 10;
                    ++v26;
                  }

                  while (v26 < dofiod_count);
                }
              }

              ++v20;
            }

            while (v20 != (dyld4::Loader **)v21);
          }
        }
      }
    }

    _Block_object_dispose(&v35, 8);
  }

size_t ___ZN5dyld412RuntimeState12notifyDtraceERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke( void *a1, unsigned int a2)
{
  unint64_t v3 = (const dyld4::RuntimeState *)a1[5];
  uint64_t v4 = a1[6] + 80LL * *(void *)a1[6];
  uint64_t v5 = (char *)(v4 + 8);
  uint64_t v7 = a1[7];
  uint64_t v6 = (dyld4::Loader *)a1[8];
  *(int64x2_t *)(v4 + 72) = vdupq_n_s64(v7 + (unint64_t)a2);
  uint64_t v8 = dyld4::Loader::leafName(v6, v3);
  size_t result = strlcpy(v5, v8, 0x40uLL);
  ++*(void *)a1[6];
  if ((*(_BYTE *)(a1[8] + 4LL) & 0x20) == 0) {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  }
  return result;
}

void dyld4::RuntimeState::notifyDebuggerLoad(dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize(this);
  __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, v19);
  uint64_t v13 = (lsl::Allocator *)((char *)&v20[-1] - (((unint64_t)v12 + 87) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = lsl::AllocatorLayout::minSize(v12);
  uint64_t v17 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v13, (char *)(v14 + 72), v15, v16);
  uint64_t v21 = v17;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v21, 1uLL);
  lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v21, v23 + 1);
  uint64_t v18 = v23++;
  *(void *)(v22 + 8 * v18) = a2;
  v20[0] = v22;
  v20[1] = v18 + 1;
  dyld4::RuntimeState::notifyDebuggerLoad(this, (uint64_t)v20);
  if (v22) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v21, 0LL);
  }
  lsl::Allocator::~Allocator(v17);
}

void dyld4::RuntimeState::notifyDebuggerLoad(lsl::AllocatorLayout *a1, uint64_t a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize(a1);
  __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, (uint64_t)v46);
  uint64_t v13 = (lsl::Allocator *)((char *)&v46 - (((unint64_t)v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = (char *)lsl::AllocatorLayout::minSize(v12);
  uint64_t v46 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal(v13, v14, v15, v16);
  uint64_t v17 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)v46);
  __chkstk_darwin(v17, v18, v19, v20, v21, v22, v23, v24, (uint64_t)v46);
  uint64_t v26 = (lsl::Allocator *)((char *)&v46 - v25);
  uint64_t v27 = *(void *)(a2 + 8);
  uint64_t v29 = lsl::AllocatorLayout::minSize(v28);
  uint64_t v32 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v26, (char *)(v29 + 40 * v27 + 64), v30, v31);
  uint64_t v48 = v32;
  int8x16_t v49 = 0uLL;
  uint64_t v50 = 0LL;
  lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact((uint64_t)&v48, *(void *)(a2 + 8));
  uint64_t v33 = *(void *)(a2 + 8);
  if (v33)
  {
    fsobj_id v34 = *(dyld4::Loader ***)a2;
    uint64_t v35 = 8 * v33;
    do
    {
      uint64_t v36 = *v34;
      if (*v34 != *((dyld4::Loader **)a1 + 3))
      {
        if ((*((_WORD *)v36 + 2) & 2) != 0)
        {
          uint64_t v38 = 0LL;
          uint64_t v37 = 0LL;
        }

        else
        {
          dyld4::Loader::fileID(*v34, v47);
          uint64_t v37 = v47[0].i64[1];
          uint64_t v38 = v47[0].i64[0];
        }

        uint64_t v39 = dyld4::Loader::path(v36, a1);
        uint64_t Address = dyld4::Loader::loadAddress(v36, a1);
        int v41 = (*((unsigned __int8 *)v36 + 4) >> 1) & 1;
        lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)&v48, v49.i64[1] + 1);
        uint64_t v42 = v49.i64[1]++;
        uint64_t v43 = v49.i64[0] + 40 * v42;
        *(void *)uint64_t v43 = v37;
        *(void *)(v43 + 8) = v38;
        *(void *)(v43 + 16) = v39;
        *(void *)(v43 + 24) = Address;
        *(_BYTE *)(v43 + 32) = v41;
      }

      ++v34;
      v35 -= 8LL;
    }

    while (v35);
  }

  uint64_t v44 = (lsl::Allocator *)v46;
  if (v49.i64[1])
  {
    uint64_t v45 = (lsl::Lock **)*((void *)a1 + 2);
    v47[0] = v49;
    dyld4::ExternallyViewableState::addImages((uint64_t)a1 + 536, v45, v46, v47[0].i64);
  }

  if (v49.i64[0]) {
    lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize((os_unfair_lock_s *)&v48, 0LL);
  }
  lsl::Allocator::~Allocator(v32);
  lsl::Allocator::~Allocator(v44);
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact( uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    size_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 40 * a2);
    if ((result & 1) == 0)
    {
      size_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 40 * a2);
      uint64_t v4 = result;
      if (*(void *)(v3 + 16))
      {
        uint64_t v5 = 0LL;
        unint64_t v6 = 0LL;
        do
        {
          uint64_t v7 = result + v5;
          uint64_t v8 = (__int128 *)(*(void *)(v3 + 8) + v5);
          __int128 v9 = *v8;
          __int128 v10 = v8[1];
          *(void *)(v7 + 32) = *((void *)v8 + 4);
          *(_OWORD *)uint64_t v7 = v9;
          *(_OWORD *)(v7 + 16) = v10;
          ++v6;
          unint64_t v11 = *(void *)(v3 + 16);
          v5 += 40LL;
        }

        while (v11 > v6);
      }

      else
      {
        unint64_t v11 = 0LL;
      }

      uint64_t v12 = *(void **)(v3 + 8);
      if (v12)
      {
        size_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v12);
        unint64_t v11 = *(void *)(v3 + 16);
      }

      if (v11 >= a2) {
        unint64_t v13 = a2;
      }
      else {
        unint64_t v13 = v11;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v13;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

void dyld4::RuntimeState::notifyDebuggerUnload(lsl::Lock ***a1, uint64_t *a2)
{
  uint64_t v4 = lsl::AllocatorLayout::minSize((lsl::AllocatorLayout *)a1);
  __chkstk_darwin(v4, v5, v6, v7, v8, v9, v10, v11, v37);
  unint64_t v13 = (lsl::Allocator *)((char *)&v38[-1] - (((unint64_t)v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = (char *)lsl::AllocatorLayout::minSize(v12);
  uint64_t v17 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal(v13, v14, v15, v16);
  __chkstk_darwin((uint64_t)v17, v18, v19, v20, v21, v22, v23, v24, v37);
  uint64_t v28 = (uint64_t *)((char *)&v38[-1] - ((v27 + 23) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v29 = a2[1];
  if (!v29) {
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1((uint64_t)v38, v25, v26);
  }
  uint64_t v30 = 0LL;
  uint64_t v31 = *a2;
  uint64_t v32 = 8 * v29;
  do
  {
    uint64_t Address = dyld4::Loader::loadAddress(*(dyld4::Loader **)(v31 + 8 * v30), (const dyld4::RuntimeState *)a1);
    if (v29 == v30) {
      dyld4::RuntimeState::appendInterposingTuples(Address, v34, v35);
    }
    uint64_t v36 = (uint64_t *)(v30 + 1);
    v28[v30++] = Address;
    v32 -= 8LL;
  }

  while (v32);
  v38[0] = v28;
  v38[1] = v36;
  dyld4::ExternallyViewableState::removeImages((uint64_t)(a1 + 67), a1[2], v17, v38);
  lsl::Allocator::~Allocator((lsl::Allocator *)v17);
}

void dyld4::RuntimeState::notifyLoad( const dyld4::RuntimeState *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v84 = a2;
  uint64_t v9 = *(void *)(a2 + 8);
  if (kdebug_is_enabled(0x1F050000u, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v10 = *(void *)(v84 + 8);
    if (v10)
    {
      uint64_t v11 = *(dyld4::Loader ***)v84;
      uint64_t v12 = 8 * v10;
      do
      {
        unint64_t v13 = *v11;
        uint64_t Address = (unsigned int *)dyld4::Loader::loadAddress(*v11, a1);
        if ((*((_WORD *)v13 + 2) & 2) != 0
          || (uint64_t v15 = (dyld3 *)dyld4::Loader::path(v13, a1), dyld3::stat(v15, &v95, v16)))
        {
          __darwin_ino64_t st_ino = 0LL;
          fsobj_id st_dev = 0LL;
        }

        else
        {
          __darwin_ino64_t st_ino = (unsigned __int8 (*)[16])v95.st_ino;
          fsobj_id st_dev = (fsobj_id)v95.st_dev;
        }

        dyld3::MachOFile::getUuid((dyld3::MachOFile *)Address, (unsigned __int8 *)v96);
        uint64_t v19 = (void *)dyld4::Loader::path(v13, a1);
        fsobj_id v20 = st_dev;
        fsid v21 = (fsid)Address;
        dyld3::kdebug_trace_dyld_image(0LL, v19, (void **)v96, st_ino, v20, v21, (const void *)Address[2], v22, v83);
        ++v11;
        v12 -= 8LL;
      }

      while (v12);
    }
  }

  uint64_t v23 = (void *)*((void *)a1 + 17);
  v93[0] = _NSConcreteStackBlock;
  v93[1] = 0x40000000LL;
  v93[2] = ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke;
  v93[3] = &__block_descriptor_tmp_94;
  uint64_t v24 = v84;
  v93[4] = a1;
  v93[5] = v84;
  int v94 = v9;
  uint64_t Lock = dyld4::RuntimeLocks::withNotifiersReadLock(v23, (uint64_t)v93);
  unsigned int v92 = 0;
  char v91 = 0;
  __chkstk_darwin(Lock, v26, v27, v28, v29, v30, v31, v32, (uint64_t)v83);
  __chkstk_darwin(v33, v34, v35, v36, v37, v38, v39, v40, (uint64_t)v83);
  uint64_t v42 = (char *)&v83 - v41;
  __chkstk_darwin(v43, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v83);
  uint64_t v87 = &v83 - 4 * v9;
  if (*((void *)a1 + 84) || *((void *)a1 + 86))
  {
    uint64_t v52 = *(void *)(v24 + 8);
    if (v52)
    {
      uint64_t v86 = v51;
      size_t v83 = &v83;
      int v85 = 0;
      uint64_t v53 = 0LL;
      uint64_t v54 = *(dyld4::Loader ***)v24;
      uint64_t v55 = 8 * v52;
      do
      {
        BOOL v56 = *v54;
        if ((*((_WORD *)*v54 + 2) & 4) != 0)
        {
          uint64_t v57 = dyld4::Loader::path(*v54, a1);
          *(void *)(v86 + 8LL * v53) = v57;
          uint64_t v58 = dyld4::Loader::loadAddress(v56, a1);
          *(void *)&v42[8 * v53] = v58;
          uint64_t v59 = dyld4::Loader::path(v56, a1);
          int DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v56);
          BOOL v61 = &v87[4 * v53];
          *BOOL v61 = (const void *)v58;
          v61[1] = (const void *)v59;
          v61[2] = v56;
          *((_DWORD *)v61 + 6) = DoesObjCFixups;
          uint64_t v53 = (v53 + 1);
          unsigned int v92 = v53;
          BOOL hasConstantSegmentsToProtect = dyld4::Loader::hasConstantSegmentsToProtect(v56);
          __int16 v63 = *((_WORD *)v56 + 2);
          if (hasConstantSegmentsToProtect && (v63 & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadWrite(v56, a1);
            __int16 v63 = *((_WORD *)v56 + 2);
          }

          if ((v63 & 2) != 0)
          {
            int v85 = 1;
            char v91 = 1;
          }
        }

        ++v54;
        v55 -= 8LL;
      }

      while (v55);
      uint64_t v64 = v84;
      if ((_DWORD)v53)
      {
        char v90 = 0;
        uint64_t v88 = &v89;
        uint64_t v89 = a1;
        uint64_t v65 = (lsl::Lock *)*((void *)a1 + 16);
        lsl::MemoryManager::lockGuard(v65, (lsl::Lock **)&v95);
        uint64_t v66 = *((void *)v65 + 3);
        if (!v66)
        {
          lsl::MemoryManager::writeProtect(v65, 0);
          uint64_t v66 = *((void *)v65 + 3);
        }

        *((void *)v65 + 3) = v66 + 1;
        lsl::Lock::unlock(*(lsl::Lock **)&v95.st_dev);
        v95.fsobj_id st_dev = 520552484;
        memset(&v95.st_ino, 0, 104);
        dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v95, v67, v68, v69, v70, v71, v72, v73);
        uint64_t v74 = (void (*)(uint64_t, const void **))*((void *)a1 + 84);
        if (v74)
        {
          if (v85)
          {
            dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(&v89);
            uint64_t v74 = (void (*)(uint64_t, const void **))*((void *)a1 + 84);
          }

          v74(v53, v87);
        }

        else
        {
          int v75 = (void (*)(uint64_t))*((void *)a1 + 86);
          if (v75)
          {
            *(void *)uint64_t v96 = _NSConcreteStackBlock;
            uint64_t v97 = 0x40000000LL;
            uint64_t v98 = ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke;
            uint64_t v99 = &__block_descriptor_tmp_161;
            uint64_t v102 = &v92;
            uint64_t v103 = &v91;
            uint64_t v100 = v87;
            uint64_t v101 = &v88;
            v75(v53);
          }
        }

        uint64_t v76 = v86;
        if (*(_BYTE *)(*((void *)a1 + 1) + 205LL))
        {
          dyld4::RuntimeState::log(a1, "objc-mapped-notifier called with %d images:\n", v92);
          if (v92)
          {
            for (unint64_t i = 0LL; i < v92; ++i)
              dyld4::RuntimeState::log( a1,  " objc-mapped: %p %s\n",  *(const void **)&v42[8 * i],  *(const char **)(v76 + 8 * i));
          }
        }

        dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v95);
        lsl::MemoryManager::lockGuard(v65, (lsl::Lock **)&v95);
        uint64_t v78 = *((void *)v65 + 3) - 1LL;
        *((void *)v65 + 3) = v78;
        if (!v78) {
          lsl::MemoryManager::writeProtect(v65, 1);
        }
        lsl::Lock::unlock(*(lsl::Lock **)&v95.st_dev);
        if (v90) {
          dyld4::ProcessConfig::DyldCache::makeDataConstWritable( (char **)(*((void *)v89 + 1) + 240LL),  *((void *)v89 + 1) + 200LL,  *((void *)v89 + 1),  0);
        }
      }

      uint64_t v79 = *(void *)(v64 + 8);
      if (v79)
      {
        uint64_t v80 = *(dyld4::Loader ***)v64;
        uint64_t v81 = 8 * v79;
        do
        {
          v82 = *v80;
          if ((*((_WORD *)*v80 + 2) & 4) != 0
            && dyld4::Loader::hasConstantSegmentsToProtect(*v80)
            && (*((_WORD *)v82 + 2) & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadOnly(v82, a1);
          }

          ++v80;
          v81 -= 8LL;
        }

        while (v81);
      }
    }
  }

uint64_t ___ZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  uint64_t v9 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v10 = *((void *)v9 + 89);
  if (v10)
  {
    uint64_t v11 = (const void **)*((void *)v9 + 88);
    uint64_t v12 = &v11[v10];
    do
    {
      uint64_t v13 = *(void *)(v8 + 40);
      uint64_t v14 = *(void *)(v13 + 8);
      if (v14)
      {
        uint64_t v15 = *v11;
        uint64_t v16 = *(dyld4::Loader ***)v13;
        uint64_t v17 = 8 * v14;
        do
        {
          uint64_t v18 = *v16;
          uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v16, v9);
          int v72 = 520552472;
          uint64_t v73 = Address;
          uint64_t v74 = 0LL;
          int v75 = v15;
          __int128 v76 = 0u;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          __int128 v79 = 0u;
          __int128 v80 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v72, v20, v21, v22, v23, v24, v25, v26);
          if (*(_BYTE *)(*((void *)v9 + 1) + 205LL)) {
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v15, Address);
          }
          if ((*((_WORD *)v18 + 2) & 2) != 0) {
            uint64_t Slide = *(void *)(*((void *)v9 + 1) + 264LL);
          }
          else {
            uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
          }
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v15)(Address, Slide);
          size_t result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v72);
          ++v16;
          v17 -= 8LL;
        }

        while (v17);
      }

      ++v11;
    }

    while (v11 != v12);
  }

  uint64_t v28 = *((void *)v9 + 97);
  if (v28)
  {
    uint64_t v29 = (const void **)*((void *)v9 + 96);
    uint64_t v71 = &v29[v28];
    do
    {
      uint64_t v30 = *(void *)(v8 + 40);
      uint64_t v31 = *(void *)(v30 + 8);
      if (v31)
      {
        uint64_t v32 = *v29;
        uint64_t v33 = *(dyld4::Loader ***)v30;
        uint64_t v34 = 8 * v31;
        do
        {
          uint64_t v35 = *v33;
          uint64_t v36 = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v33, v9);
          int v72 = 520552472;
          uint64_t v73 = v36;
          uint64_t v74 = 0LL;
          int v75 = v32;
          __int128 v76 = 0u;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          __int128 v79 = 0u;
          __int128 v80 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v72, v37, v38, v39, v40, v41, v42, v43);
          if (*(_BYTE *)(*((void *)v9 + 1) + 205LL)) {
            dyld4::RuntimeState::log(v9, "notifier %p called with mh=%p\n", v32, v36);
          }
          uint64_t v44 = dyld4::Loader::path(v35, v9);
          ((void (*)(dyld3::MachOLoaded *, uint64_t, BOOL))v32)(v36, v44, (*((_WORD *)v35 + 2) & 0x20) == 0);
          size_t result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v72);
          ++v33;
          v34 -= 8LL;
        }

        while (v34);
      }

      ++v29;
    }

    while (v29 != v71);
  }

  uint64_t v45 = *((void *)v9 + 101);
  if (v45)
  {
    uint64_t v46 = (const void **)*((void *)v9 + 100);
    uint64_t v47 = &v46[v45];
    do
    {
      uint64_t v48 = *v46;
      __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, (uint64_t)v71);
      uint64_t v50 = (uint64_t *)((char *)&v71 - ((v49 + 15) & 0xFFFFFFFF0LL));
      __chkstk_darwin(v51, v52, v53, v54, v55, v56, v57, v58, (uint64_t)v71);
      uint64_t v67 = (v66 + 15) & 0xFFFFFFFF0LL;
      uint64_t v68 = (char *)&v71 - v67;
      if (v69)
      {
        unint64_t v70 = 0LL;
        do
        {
          v50[v70] = dyld4::Loader::loadAddress(*(dyld4::Loader **)(**(void **)(v8 + 40) + 8 * v70), v9);
          *(void *)&v68[8 * v70] = dyld4::Loader::path(*(dyld4::Loader **)(**(void **)(v8 + 40) + 8 * v70), v9);
          ++v70;
        }

        while (v70 < *(unsigned int *)(v8 + 48));
        uint64_t v67 = *v50;
      }

      int v72 = 520552472;
      uint64_t v73 = (dyld3::MachOLoaded *)v67;
      uint64_t v74 = 0LL;
      int v75 = v48;
      __int128 v76 = 0u;
      __int128 v77 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      __int128 v80 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v72, v59, v60, v61, v62, v63, v64, v65);
      if (*(_BYTE *)(*((void *)v9 + 1) + 205LL)) {
        dyld4::RuntimeState::log(v9, "bulk notifier %p called with %d images\n", v48, *(_DWORD *)(v8 + 48));
      }
      ((void (*)(void, uint64_t *, char *))v48)(*(unsigned int *)(v8 + 48), v50, v68);
      size_t result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v72);
      ++v46;
    }

    while (v46 != v47);
  }

  return result;
}

uint64_t dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter( uint64_t this, dyld4::RuntimeState *a2)
{
  *(void *)this = a2;
  *(_BYTE *)(this + 8) = 0;
  return this;
}

void dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter( dyld4::DyldCacheDataConstLazyScopedWriter *this)
{
  if (*((_BYTE *)this + 8)) {
    dyld4::ProcessConfig::DyldCache::makeDataConstWritable( (char **)(*(void *)(*(void *)this + 8LL) + 240LL),  *(void *)(*(void *)this + 8LL) + 200LL,  *(void *)(*(void *)this + 8LL),  0);
  }
}

uint64_t ___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke( uint64_t result)
{
  uint64_t v20 = result;
  vm_address_t v1 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v2 = *((void *)v1 + 93);
  if (v2)
  {
    uint64_t v3 = (const void **)*((void *)v1 + 92);
    uint64_t v19 = &v3[v2];
    do
    {
      uint64_t v4 = *(void *)(v20 + 40);
      uint64_t v5 = *(void *)(v4 + 8);
      if (v5)
      {
        uint64_t v6 = *v3;
        uint64_t v7 = *(dyld4::Loader ***)v4;
        uint64_t v8 = 8 * v5;
        do
        {
          uint64_t v9 = *v7;
          uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*v7, v1);
          int v21 = 520552476;
          uint64_t v22 = Address;
          uint64_t v23 = 0LL;
          uint64_t v24 = v6;
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          __int128 v29 = 0u;
          dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v11, v12, v13, v14, v15, v16, v17);
          if (*(_BYTE *)(*((void *)v1 + 1) + 205LL)) {
            dyld4::RuntimeState::log(v1, "remove notifier %p called with mh=%p\n", v6, Address);
          }
          if ((*((_WORD *)v9 + 2) & 2) != 0) {
            uint64_t Slide = *(void *)(*((void *)v1 + 1) + 264LL);
          }
          else {
            uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
          }
          ((void (*)(dyld3::MachOLoaded *, uint64_t))v6)(Address, Slide);
          size_t result = dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
          ++v7;
          v8 -= 8LL;
        }

        while (v8);
      }

      ++v3;
    }

    while (v3 != v19);
  }

  return result;
}

void *___ZN5dyld412RuntimeState12notifyUnloadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEE_block_invoke_2( void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)result[4];
    uint64_t v4 = *(const dyld4::Loader ***)v1;
    uint64_t v5 = *(void *)v1 + 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      uint64_t v7 = v3[6];
      if (v7)
      {
        uint64_t v8 = (const dyld4::Loader **)v3[5];
        size_t v9 = 8 * v7 - 8;
        uint64_t v10 = v8;
        while (1)
        {
          uint64_t v11 = *v10++;
          if (v11 == v6) {
            break;
          }
          v9 -= 8LL;
          uint64_t v8 = v10;
          if (v9 == -8LL) {
            goto LABEL_11;
          }
        }

        if (v9)
        {
          memmove(v8, v8 + 1, v9);
          uint64_t v7 = v3[6];
        }

        void v3[6] = v7 - 1;
      }

LABEL_11:
      size_t result = dyld4::RuntimeState::removeDynamicDependencies(v3, v6);
      ++v4;
    }

    while (v4 != (const dyld4::Loader **)v5);
  }

  return result;
}

    if ((_OWORD *)(a1 + 16) == v27)
    {
      *(void *)&v27[1] = 0LL;
      if (*((void *)&v27[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v27[1] + 1), size);
      }
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v27[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v27 + 8);
      uint64_t v12 = size;
      *(void *)(a1 + 40) = *((void *)&v27[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }

  if (!*(_BYTE *)(a2 + 8)) {
    goto LABEL_26;
  }
  uint64_t v13 = (*(void *)(a1 + 32) - 1LL) & *(void *)a2;
  uint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_22:
    uint64_t v17 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v17;
    ++*(void *)(a1 + 8);
    uint64_t v18 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    int v21 = *(void *)(a1 + 56);
    uint64_t v22 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v22 + 1;
    uint64_t v23 = v21 + 24 * v22;
    uint64_t v24 = *(_OWORD *)a2;
    *(_DWORD *)(v23 + 16) = *(_DWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v23 = v24;
    __int128 v25 = *(void *)(a1 + 72);
    if (!v25) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v18,  v19,  v20);
    }
    return *(void *)(a1 + 56) + 24 * v25 - 24;
  }

  else
  {
    uint64_t v15 = 1LL;
    while (1)
    {
      uint64_t v16 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14);
      if (dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(v16, a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14);
      }
      uint64_t v13 = (*(void *)(a1 + 32) - 1LL) & (v13 + v15++);
      uint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1) {
        goto LABEL_22;
      }
    }
  }

      uint64_t v23 = v5[5];
      uint64_t v24 = *(void *)(v23 + 16);
      if (v24)
      {
        __int128 v25 = *(void **)(v23 + 8);
        __int128 v26 = 24 * v24 - 24;
        __int128 v27 = v25;
        while (1)
        {
          __int128 v28 = *v27;
          v27 += 3;
          if (v28 == v35) {
            break;
          }
          v26 -= 24LL;
          __int128 v25 = v27;
          if (v26 == -24LL) {
            goto LABEL_19;
          }
        }

        if (v26)
        {
          memmove(v25, v25 + 3, v26);
          uint64_t v24 = *(void *)(v23 + 16);
        }

        *(void *)(v23 + 16) = v24 - 1;
      }

void *dyld4::RuntimeState::removeDynamicDependencies(void *this, const dyld4::Loader *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = (_OWORD *)this[116];
  uint64_t v5 = this[117];
  uint64_t v6 = &v4[v5];
  uint64_t v7 = v4;
  if (v5)
  {
    uint64_t v8 = 0LL;
    while (1)
    {
      uint64_t v7 = &v4[v8];
      if (*(const dyld4::Loader **)&v4[v8] == a2 || *((void *)&v4[v8] + 1) == (void)a2) {
        break;
      }
      if (v5 == ++v8)
      {
        uint64_t v7 = &v4[v5];
        goto LABEL_20;
      }
    }
  }

  uint64_t v10 = v7 + 1;
  if (v7 != v6 && v10 != v6)
  {
    do
    {
      if (*(const dyld4::Loader **)v10 != a2 && *((void *)v10 + 1) != (void)a2) {
        *v7++ = *v10;
      }
      ++v10;
    }

    while (v10 != v6);
    uint64_t v4 = (_OWORD *)this[116];
    uint64_t v5 = this[117];
  }

void dyld4::RuntimeState::doSingletonPatching( dyld4::RuntimeState *this, dyld4::DyldCacheDataConstLazyScopedWriter *a2)
{
  if (*((void *)this + 38) != *((void *)this + 40))
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(a2);
    uint64_t v3 = (uint64_t (***)(void))*((void *)this + 19);
    for (unint64_t i = *((void *)this + 40); i < *((void *)this + 38); *((void *)this + 40) = i)
    {
      uint64_t v5 = *((void *)this + 37) + 16 * i;
      uint64_t v6 = *(_OWORD **)v5;
      uint64_t v7 = *(_OWORD **)(v5 + 8);
      *uint64_t v6 = *v7;
      if (*(_BYTE *)(*((void *)this + 1) + 202LL)) {
        dyld4::RuntimeState::log(this, "cache singleton fixup: *0x%012lX = 0x%012lX\n", v6, v7);
      }
      unint64_t i = *((void *)this + 40) + 1LL;
    }
  }

_BYTE *dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(_BYTE *this)
{
  if (!this[8])
  {
    uint64_t v1 = *(void *)(*(void *)this + 8LL);
    if (*(_BYTE *)(v1 + 158))
    {
      if (*(void *)(v1 + 240))
      {
        this[8] = 1;
        return (_BYTE *)dyld4::ProcessConfig::DyldCache::makeDataConstWritable((char **)(v1 + 240), v1 + 200, v1, 1);
      }
    }
  }

  return this;
}

void dyld4::RuntimeState::notifyObjCPatching(dyld4::RuntimeState *this)
{
  if (*((void *)this + 83) && *((void *)this + 34))
  {
    uint64_t v2 = (uint64_t (***)(void))*((void *)this + 19);
    uint64_t v3 = *((void *)this + 34);
    if (v3)
    {
      uint64_t v4 = (void *)*((void *)this + 33);
      uint64_t v5 = &v4[4 * v3];
      do
      {
        (*((void (**)(void, void, void, void))this + 83))(*v4, v4[1], v4[2], v4[3]);
        v4 += 4;
      }

      while (v4 != v5);
    }

    if (*(_BYTE *)(*((void *)this + 1) + 205LL)) {
      dyld4::RuntimeState::log(this, "objc-patch-class-notifier called with %lld patches:\n", *((void *)this + 34));
    }
    *((void *)this + 34) = 0LL;
  }

os_unfair_lock_s *dyld4::RuntimeState::setObjCNotifiers( lsl::Lock *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (lsl::Lock *)*((void *)a1 + 16);
  lsl::MemoryManager::lockGuard(v12, v17);
  uint64_t v13 = *((void *)v12 + 3);
  if (!v13)
  {
    lsl::MemoryManager::writeProtect(v12, 0);
    uint64_t v13 = *((void *)v12 + 3);
  }

  *((void *)v12 + 3) = v13 + 1;
  lsl::Lock::unlock(v17[0]);
  *((void *)a1 + 82) = a2;
  *((void *)a1 + 83) = a3;
  *((void *)a1 + 84) = a4;
  *((void *)a1 + 85) = a5;
  *((void *)a1 + 86) = a6;
  uint64_t v14 = (void *)*((void *)a1 + 17);
  v17[0] = (lsl::Lock *)_NSConcreteStackBlock;
  v17[1] = (lsl::Lock *)0x40000000;
  v17[2] = (lsl::Lock *)___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke;
  v17[3] = (lsl::Lock *)&__block_descriptor_tmp_170;
  v17[4] = a1;
  dyld4::RuntimeLocks::withLoadersReadLock(v14, (uint64_t)v17);
  lsl::MemoryManager::lockGuard(v12, v17);
  uint64_t v15 = *((void *)v12 + 3) - 1LL;
  *((void *)v12 + 3) = v15;
  if (!v15) {
    lsl::MemoryManager::writeProtect(v12, 1);
  }
  return lsl::Lock::unlock(v17[0]);
}

const dyld4::RuntimeState *dyld4::RuntimeState::notifyObjCInit( const dyld4::RuntimeState *this, const dyld4::Loader *a2)
{
  if ((*((_WORD *)a2 + 2) & 8) != 0)
  {
    uint64_t v2 = (uint64_t)this;
    if (*((void *)this + 85))
    {
      uint64_t Address = (const void *)dyld4::Loader::loadAddress(a2, this);
      uint64_t v5 = (const char *)dyld4::Loader::path(a2, (const dyld4::RuntimeState *)v2);
      int v15 = 520552480;
      uint64_t v16 = Address;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v15, v6, v7, v8, v9, v10, v11, v12);
      if (*(_BYTE *)(*(void *)(v2 + 8) + 205LL)) {
        dyld4::RuntimeState::log( (dyld4::RuntimeState *)v2,  "objc-init-notifier called with mh=%p, path=%s\n",  Address,  v5);
      }
      v13[0] = Address;
      v13[1] = v5;
      v13[2] = a2;
      int DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(a2);
      (*(void (**)(void *))(v2 + 680))(v13);
      return (const dyld4::RuntimeState *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v15);
    }
  }

  return this;
}

uint64_t dyld4::RuntimeState::addNotifyAddFunc( dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 696, *((void *)this + 89) + 1LL);
  uint64_t v7 = *((void *)this + 88);
  uint64_t v8 = *((void *)this + 89);
  *((void *)this + 89) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve( (uint64_t)this + 1064,  *((void *)this + 135) + 1LL);
      uint64_t v9 = *((void *)this + 134);
      uint64_t v10 = *((void *)this + 135);
      *((void *)this + 135) = v10 + 1;
      *(void *)(v9 + 8 * v10) = a2;
    }
  }

  return result;
}

uint64_t dyld4::RuntimeState::addNotifyRemoveFunc( dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, uint64_t))
{
  uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 728, *((void *)this + 93) + 1LL);
  uint64_t v7 = *((void *)this + 92);
  uint64_t v8 = *((void *)this + 93);
  *((void *)this + 93) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve( (uint64_t)this + 1064,  *((void *)this + 135) + 1LL);
      uint64_t v9 = *((void *)this + 134);
      uint64_t v10 = *((void *)this + 135);
      *((void *)this + 135) = v10 + 1;
      *(void *)(v9 + 8 * v10) = a2;
    }
  }

  return result;
}

uint64_t dyld4::RuntimeState::addNotifyLoadImage( dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(const mach_header *, const char *, BOOL))
{
  uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 760, *((void *)this + 97) + 1LL);
  uint64_t v7 = *((void *)this + 96);
  uint64_t v8 = *((void *)this + 97);
  *((void *)this + 97) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve( (uint64_t)this + 1064,  *((void *)this + 135) + 1LL);
      uint64_t v9 = *((void *)this + 134);
      uint64_t v10 = *((void *)this + 135);
      *((void *)this + 135) = v10 + 1;
      *(void *)(v9 + 8 * v10) = a2;
    }
  }

  return result;
}

uint64_t dyld4::RuntimeState::addNotifyBulkLoadImage( dyld4::RuntimeState *this, const dyld4::Loader *a2, void (*a3)(unsigned int, const mach_header **, const char **))
{
  uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 792, *((void *)this + 101) + 1LL);
  uint64_t v7 = *((void *)this + 100);
  uint64_t v8 = *((void *)this + 101);
  *((void *)this + 101) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a3;
  if (a2)
  {
    if ((*((_WORD *)a2 + 2) & 0x20) == 0)
    {
      uint64_t result = lsl::Vector<void (*)(mach_header const*,long)>::reserve( (uint64_t)this + 1064,  *((void *)this + 135) + 1LL);
      uint64_t v9 = *((void *)this + 134);
      uint64_t v10 = *((void *)this + 135);
      *((void *)this + 135) = v10 + 1;
      *(void *)(v9 + 8 * v10) = a2;
    }
  }

  return result;
}

double dyld4::RuntimeState::initialize(dyld4::RuntimeState *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    uint64_t v3 = (dyld4::Loader **)*((void *)this + 5);
    uint64_t v4 = 8 * v2;
    do
    {
      if ((*((_WORD *)*v3 + 2) & 0x1000) != 0)
      {
        uint64_t v5 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v3, this);
        dyld4::RuntimeState::setUpTLVs(this, v5);
      }

      ++v3;
      v4 -= 8LL;
    }

    while (v4);
  }

  uint64_t v6 = (__n128 *)*((void *)this + 16);
  uint64_t v7 = *((void *)this + 17) + 40LL;
  v9.n128_u64[0] = (unint64_t)this;
  v9.n128_u64[1] = v7;
  *(void *)&double result = lsl::MemoryManager::adoptLock(v6, &v9).n128_u64[0];
  return result;
}

void dyld4::RuntimeState::setUpTLVs(dyld4::RuntimeState *this, const dyld3::MachOAnalyzer *a2)
{
  uint64_t v17 = 0LL;
  __int128 v18 = &v17;
  uint64_t v19 = 0x4002000000LL;
  __int128 v20 = __Block_byref_object_copy__102;
  __int128 v21 = __Block_byref_object_dispose__103;
  __int128 v22 = a2;
  int v23 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 19) + 144LL))(*((void *)this + 19));
  BOOL v5 = 0;
  uint64_t v6 = *((void *)this + 1);
  unint64_t v7 = *(void *)(v6 + 240);
  if (v7) {
    BOOL v8 = v7 >= (unint64_t)a2;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    BOOL v5 = v7 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240)) > (unint64_t)a2;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  v14[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke;
  v14[3] = &unk_18961F5E8;
  BOOL v15 = v5;
  v14[4] = &v17;
  v14[5] = this;
  void v14[6] = v4;
  void v14[7] = v4;
  int v9 = dyld3::MachOAnalyzer::forEachThreadLocalVariable(a2, (uint64_t)&v16, (uint64_t)v14);
  uint64_t v10 = v18;
  *((_DWORD *)v18 + 13) = v9;
  *((_DWORD *)v10 + 14) = v11;
  uint64_t v12 = (void *)*((void *)this + 17);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000LL;
  v13[2] = ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2;
  void v13[3] = &unk_18961F610;
  v13[4] = &v17;
  v13[5] = this;
  dyld4::RuntimeLocks::withTLVLock(v12, (uint64_t)v13);
  mach_o::Error::~Error(&v16);
  _Block_object_dispose(&v17, 8);
}

__n128 __Block_byref_object_copy__102(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

unint64_t ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke( unint64_t result, void *a2, void *a3)
{
  BOOL v5 = (void *)result;
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(unsigned int *)a3;
  if (*(_BYTE *)(result + 64)) {
    BOOL v8 = (_DWORD)v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 || (__n128 result = (***(uint64_t (****)(void))(v6 + 152))(*(void *)(v6 + 152)), result < 4))
  {
    LODWORD(v10) = *(_DWORD *)(*(void *)(v5[4] + 8LL) + 48LL);
    if (!(_DWORD)v10)
    {
      __n128 result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(v6 + 152) + 48LL))( *(void *)(v6 + 152),  &v11);
      if ((_DWORD)result) {
        dyld4::halt("could not create thread local variables pthread key", 0LL);
      }
      *(_DWORD *)(*(void *)(v5[4] + 8LL) + 48LL) = v11;
      LODWORD(v10) = *(_DWORD *)(*(void *)(v5[4] + 8LL) + 48LL);
    }

    uint64_t v10 = v10;
    goto LABEL_13;
  }

  __n128 result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 152) + 168LL))(*(void *)(v6 + 152), v7);
  uint64_t v9 = *(void *)(v5[4] + 8LL);
  uint64_t v10 = *(unsigned int *)(v9 + 48);
  if (!(_DWORD)v10)
  {
    *(_DWORD *)(v9 + 48) = v7;
    goto LABEL_14;
  }

  if ((_DWORD)v10 != (_DWORD)v7) {
LABEL_13:
  }
    *a3 = v10;
LABEL_14:
  if (*a2 != v5[6]) {
    *a2 = v5[7];
  }
  return result;
}

__n128 ___ZN5dyld412RuntimeState9setUpTLVsEPKN5dyld313MachOAnalyzerE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v1 + 824, *(void *)(v1 + 840) + 1LL);
  uint64_t v3 = *(void *)(v1 + 832);
  uint64_t v4 = *(void *)(v1 + 840);
  *(void *)(v1 + 840) = v4 + 1;
  BOOL v5 = (__n128 *)(v3 + 24 * v4);
  __n128 result = *(__n128 *)(v2 + 40);
  v5[1].n128_u64[0] = *(void *)(v2 + 56);
  *BOOL v5 = result;
  return result;
}

void *dyld4::RuntimeState::_instantiateTLVs(dyld4::RuntimeState *this, uint64_t a2)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  uint64_t v15 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  uint64_t v4 = (void *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld412RuntimeState16_instantiateTLVsEm_block_invoke;
  void v7[3] = &unk_18961F638;
  v7[6] = this;
  void v7[7] = a2;
  v7[4] = &v12;
  v7[5] = &v8;
  dyld4::RuntimeLocks::withTLVLock(v4, (uint64_t)v7);
  if (v13[3])
  {
    BOOL v5 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8LL))( *((void *)this + 19),  v9[3]);
    memmove(v5, (const void *)v13[3], v9[3]);
    (*(void (**)(void, uint64_t, void *))(**((void **)this + 19) + 72LL))(*((void *)this + 19), a2, v5);
  }

  else
  {
    BOOL v5 = 0LL;
  }

  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  return v5;
}

void *___ZN5dyld412RuntimeState16_instantiateTLVsEm_block_invoke(void *result)
{
  uint64_t v1 = result[6];
  uint64_t v2 = *(void *)(v1 + 840);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 832);
    uint64_t v4 = 24 * v2;
    BOOL v5 = (unsigned int *)(v3 + 16);
    do
    {
      if (result[7] == *(v5 - 2))
      {
        *(void *)(*(void *)(result[4] + 8LL) + 24LL) = *((void *)v5 - 2) + *(v5 - 1);
        *(void *)(*(void *)(result[5] + 8LL) + 24LL) = *v5;
      }

      v5 += 6;
      v4 -= 24LL;
    }

    while (v4);
  }

  return result;
}

void dyld4::RuntimeState::addTLVTerminationFunc( dyld4::RuntimeState *this, void (*a2)(void *), void *a3)
{
  uint64_t v6 = (void *)(*(uint64_t (**)(void, void))(**((void **)this + 19) + 64LL))( *((void *)this + 19),  *((void *)this + 138));
  if (!v6)
  {
    uint64_t v6 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8LL))( *((void *)this + 19),  128LL);
    bzero(v6, 0x80uLL);
    (*(void (**)(void, void, void *))(**((void **)this + 19) + 72LL))( *((void *)this + 19),  *((void *)this + 138),  v6);
  }

  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }

  while (v6);
  uint64_t v8 = v7[1];
  if (v8 == 7)
  {
    uint64_t v9 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 19) + 8LL))( *((void *)this + 19),  128LL);
    bzero(v9, 0x80uLL);
    *uint64_t v7 = v9;
    uint64_t v8 = v9[1];
    uint64_t v7 = v9;
  }

  v7[1] = v8 + 1;
  uint64_t v10 = &v7[2 * v8];
  v10[2] = a2;
  v10[3] = a3;
}

uint64_t dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(v4, a2);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16))(a2, a1);
}

uint64_t dyld4::RuntimeState::_finalizeListTLV(dyld4::RuntimeState *this, uint64_t *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke;
  v6[3] = &__block_descriptor_tmp_110;
  v6[4] = this;
  dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v6);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_111;
  v5[4] = this;
  return dyld4::RuntimeState::TLV_TerminatorList::reverseWalkChain(a2, (uint64_t)v5);
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = (void *)(a2 + 16 * v2 + 8);
    do
    {
      BOOL v5 = (void (*)(void))*(v4 - 1);
      if (v5) {
        v5(*v4);
      }
      __n128 result = (*(uint64_t (**)(void, void))(**(void **)(v3 + 152) + 64LL))( *(void *)(v3 + 152),  *(void *)(v3 + 1104));
      if (result)
      {
        uint64_t v6 = result;
        (*(void (**)(void, void, void))(**(void **)(v3 + 152) + 72LL))( *(void *)(v3 + 152),  *(void *)(v3 + 1104),  0LL);
        __n128 result = (**(uint64_t (***)(uint64_t, uint64_t))v3)(v3, v6);
      }

      v4 -= 2;
      --v2;
    }

    while (v2);
  }

  return result;
}

uint64_t ___ZN5dyld412RuntimeState16_finalizeListTLVEPv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 152LL) + 16LL))(*(void *)(*(void *)(a1 + 32) + 152LL));
}

uint64_t dyld4::RuntimeState::exitTLV(dyld4::RuntimeState *this)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 19) + 64LL))( *((void *)this + 19),  *((void *)this + 138));
  if (result)
  {
    uint64_t v3 = result;
    (*(void (**)(void, void, void))(**((void **)this + 19) + 72LL))( *((void *)this + 19),  *((void *)this + 138),  0LL);
    return (**(uint64_t (***)(dyld4::RuntimeState *, uint64_t))this)(this, v3);
  }

  return result;
}

void dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(dyld4::RuntimeState *this, int a2)
{
  uint64_t v4 = dyld4::ProcessConfig::Process::environ((const char ***)(*((void *)this + 1) + 8LL), "DYLD_CLOSURE_DIR");
  uint64_t v5 = *((void *)this + 1);
  if (*(_BYTE *)(v5 + 169)) {
    BOOL v6 = v4 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    strlcpy(__dst, v4, 0x400uLL);
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "using DYLD_CLOSURE_DIR to find loaders\n");
    }
    goto LABEL_16;
  }

  uint64_t v7 = (char *)dyld4::ProcessConfig::Process::environ((const char ***)(v5 + 8), "HOME");
  uint64_t v8 = (dyld4::SyscallDelegate *)*((void *)this + 1);
  if (!v7)
  {
    if (*((_BYTE *)v8 + 207)) {
      dyld4::RuntimeState::log( this,  "did not look for saved PrebuiltLoaderSet because $DYLD_CLOSURE_DIR and $HOME are not set\n");
    }
    return;
  }

  BOOL isMaybeContainerized = dyld4::SyscallDelegate::isMaybeContainerized(v8, v7);
  uint64_t v10 = *((void *)this + 1);
  if (!isMaybeContainerized)
  {
    if (!*(_BYTE *)(v10 + 169))
    {
      if (*(_BYTE *)(v10 + 207)) {
        dyld4::RuntimeState::log( this,  "did not look for saved PrebuiltLoaderSet because $HOME is not containerized and this is not an internal install\n");
      }
      return;
    }

    uint64_t v13 = dyld4::ProcessConfig::Process::environ((const char ***)(v10 + 8), "DYLD_USE_CLOSURES");
    uint64_t v14 = (dyld4::SyscallDelegate *)*((void *)this + 1);
    if (!v13)
    {
      if (*((_BYTE *)v14 + 207)) {
        dyld4::RuntimeState::log( this,  "did not look for saved PrebuiltLoaderSet because DYLD_USE_CLOSURES is not set\n");
      }
      return;
    }

    if (dyld4::SyscallDelegate::realpathdir(v14, (dyld3 *)v7, __dst))
    {
      strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
      strlcat(__dst, *(const char **)(*((void *)this + 1) + 136LL), 0x400uLL);
      strlcat(__dst, "/", 0x400uLL);
      if (!a2
        || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v15)
        || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
      {
        uint64_t v16 = dyld4::ProcessConfig::Process::appleParam( (const char ***)(*((void *)this + 1) + 8LL),  "executable_cdhash");
        if (v16)
        {
          strlcat(__dst, v16, 0x400uLL);
          strlcat(__dst, "-", 0x400uLL);
        }

        uint64_t v17 = *(char **)(*((void *)this + 1) + 16LL);
        size_t v18 = _platform_strlen(v17);
        unint64_t v20 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( (uint64_t)__source,  (uint64_t *)v17,  v18);
        __int128 v22 = __source;
        int v21 = 8;
        do
        {
          dyld4::Loader::appendHexByte(v20, &v22, v19);
          v20 >>= 8;
          --v21;
        }

        while (v21);
        char *v22 = 0;
        uint64_t v12 = __source;
        goto LABEL_31;
      }

      goto LABEL_42;
    }

LABEL_32:
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME failed realpath\n");
    }
    return;
  }

  if (!dyld4::SyscallDelegate::realpathdir((dyld4::SyscallDelegate *)v10, (dyld3 *)v7, __dst)) {
    goto LABEL_32;
  }
  strlcat(__dst, "/Library/Caches/com.apple.dyld/", 0x400uLL);
  if (dyld4::SyscallDelegate::isContainerized(*((dyld4::SyscallDelegate **)this + 1), __dst))
  {
    if (!a2
      || dyld4::SyscallDelegate::dirExists(*((dyld4::SyscallDelegate **)this + 1), (dyld3 *)__dst, v11)
      || dyld4::SyscallDelegate::mkdirs(*((dyld4::SyscallDelegate **)this + 1), __dst))
    {
      uint64_t v12 = *(char **)(*((void *)this + 1) + 136LL);
LABEL_31:
      strlcat(__dst, v12, 0x400uLL);
      strlcat(__dst, ".dyld4", 0x400uLL);
LABEL_16:
      *((void *)this + 122) = lsl::Allocator::strdup(*((lsl::Lock ***)this + 2), __dst);
      return;
    }

    LOBYTE(v4) = 0;
    return v4 & 1;
  }

      uint64_t result = _platform_strncmp(v17, ".*s", 3uLL);
      if (!(_DWORD)result) {
        goto LABEL_44;
      }
    }

    if (v25 == 48)
    {
      ++v23;
      __int128 v29 = *(unsigned __int8 *)++v17;
      __int128 v26 = v29;
      goto LABEL_35;
    }

    if (v25 == 88)
    {
LABEL_62:
      a4 += 2;
      uint64_t v41 = (std::ios_base *)v6;
LABEL_90:
      uint64_t result = (uint64_t)hex(v41);
    }

    else
    {
LABEL_130:
      if (a2 && (uint64_t result = a2(*(unsigned __int8 *)v17)) != 0)
      {
        uint64_t v74 = *(_BYTE *)result;
        if (*(_BYTE *)result)
        {
          int v75 = (unsigned __int8 *)(result + 1);
          do
          {
            __int128 v76 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v76 >= *(void *)(v6 + 16))
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              __int128 v76 = *(_BYTE **)(v6 + 8);
            }

            *(void *)(v6 + 8) = v76 + 1;
            dyld4::RuntimeState *v76 = v74;
            __int128 v77 = *v75++;
            uint64_t v74 = v77;
          }

          while (v77);
        }
      }

      else
      {
        __int128 v79 = *(_BYTE **)(v6 + 8);
        if ((unint64_t)v79 >= *(void *)(v6 + 16))
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          __int128 v79 = *(_BYTE **)(v6 + 8);
        }

        *(void *)(v6 + 8) = v79 + 1;
        *__int128 v79 = v26;
      }
    }

LABEL_42:
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "failed to make directory for PrebuiltLoaderSet\n");
    }
    return;
  }

  if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
    dyld4::RuntimeState::log(this, "did not look for saved PrebuiltLoaderSet because $HOME is not containerized\n");
  }
}

const char *dyld4::RuntimeState::buildBootToken(uint64_t a1, uint64_t *a2)
{
  unsigned int v15 = 0;
  uint64_t result = dyld4::ProcessConfig::Process::appleParam((const char ***)(*(void *)(a1 + 8) + 8LL), "executable_boothash");
  if (result)
  {
    uint64_t result = (const char *)hexStringToBytes(result, v18, 0x80u, &v15);
    if ((_DWORD)result)
    {
      uint64_t v6 = v15;
      if (v15)
      {
        uint64_t v7 = v18;
        do
        {
          dyld3::Array<unsigned char>::push_back(a2, (char *)v7++, v5);
          --v6;
        }

        while (v6);
      }

      if (dyld3::MachOFile::getUuid((dyld3::MachOFile *)&dword_180058000, v17))
      {
        for (uint64_t i = 0LL; i != 16; ++i)
          dyld3::Array<unsigned char>::push_back(a2, (char *)&v17[i], v8);
      }

      uint64_t v10 = *(char **)(*(void *)(a1 + 8) + 24LL);
      size_t v11 = _platform_strlen(v10);
      unint64_t v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v16, (uint64_t *)v10, v11);
      int v14 = 8;
      do
      {
        char v16 = v13;
        dyld3::Array<unsigned char>::push_back(a2, &v16, v12);
        v13 >>= 8;
        --v14;
      }

      while (v14);
      return (const char *)1;
    }
  }

  return result;
}

BOOL hexStringToBytes(const char *a1, unsigned __int8 *a2, unsigned int a3, unsigned int *a4)
{
  *a4 = 0;
  char v4 = *a1;
  if (!*a1) {
    return 1LL;
  }
  int v5 = 0;
  uint64_t v6 = a1 + 1;
  char v7 = 1;
  while (1)
  {
    char v8 = v4 - 48;
    if ((v4 - 65) <= 5u)
    {
      char v8 = v4 - 55;
LABEL_6:
      if ((v7 & 1) != 0) {
        goto LABEL_7;
      }
      goto LABEL_10;
    }

    char v8 = v4 - 87;
    if ((v7 & 1) != 0)
    {
LABEL_7:
      unsigned __int8 v9 = 16 * v8;
      goto LABEL_11;
    }

uint64_t *dyld3::Array<unsigned char>::push_back(uint64_t *result, char *a2, uint64_t a3)
{
  unint64_t v3 = result[2];
  if (v3 >= result[1]) {
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)result, (uint64_t)a2, a3);
  }
  char v4 = *a2;
  uint64_t v5 = *result;
  result[2] = v3 + 1;
  *(_BYTE *)(v5 + v3) = v4;
  return result;
}

BOOL dyld4::RuntimeState::fileAlreadyHasBootToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __s2 = &v7;
  *(_OWORD *)__n = xmmword_1800B8250;
  BOOL result = dyld4::SyscallDelegate::getFileAttribute( *(void *)(a1 + 8),  *(char **)(a1 + 976),  "com.apple.dyld",  (uint64_t)&__s2);
  if (result) {
    return __n[1] == *(void *)(a3 + 16) && _platform_memcmp(*(const void **)a3, __s2, __n[1]) == 0;
  }
  return result;
}

void dyld4::RuntimeState::loadAppPrebuiltLoaderSet(dyld4::RuntimeState *this)
{
  if (dyld4::SyscallDelegate::fileExists(*((void *)this + 1), *((dyld3 **)this + 122), 0LL, 0LL))
  {
    unint64_t v20 = &v22;
    __int128 v21 = xmmword_1800B8250;
    if ((dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v20) & 1) != 0)
    {
      if (dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v2, (uint64_t)&v20))
      {
        Diagnostics::Diagnostics((Diagnostics *)&v19);
        Only = dyld4::SyscallDelegate::mapFileReadOnly( *((void *)this + 1),  (vm_address_t *)&v19,  *((dyld3 **)this + 122),  0LL,  0LL,  0LL,  0LL);
        *((void *)this + 123) = Only;
        if (Only)
        {
          dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)Only + 3));
          **((void **)this + 125) = *(void *)(*((void *)this + 1) + 8LL);
          if (*((void *)this + 123))
          {
            int v11 = 520552504;
            __int128 v12 = 0u;
            __int128 v13 = 0u;
            __int128 v14 = 0u;
            __int128 v15 = 0u;
            __int128 v16 = 0u;
            __int128 v17 = 0u;
            uint64_t v18 = 0LL;
            dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, v4, v5, v6, v7, v8, v9, v10);
            if ((dyld4::PrebuiltLoaderSet::isValid(*((dyld4::PrebuiltLoaderSet **)this + 123), this) & 1) == 0)
            {
              dyld4::SyscallDelegate::unmapFile( *((dyld4::SyscallDelegate **)this + 1),  *((void **)this + 123),  *(unsigned int *)(*((void *)this + 123) + 8LL));
              *((void *)this + 123) = 0LL;
            }

            dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
          }
        }

        mach_o::Error::~Error(&v19);
      }

      else if (*(_BYTE *)(*((void *)this + 1) + 207LL))
      {
        dyld4::RuntimeState::log(this, "existing PrebuiltLoaderSet file not used because boot-token differs\n");
      }
    }

    else if (*(_BYTE *)(*((void *)this + 1) + 207LL))
    {
      dyld4::RuntimeState::log( this,  "did not look for saved PrebuiltLoaderSet because main executable is not codesigned\n");
    }
  }

void dyld4::RuntimeState::allocateProcessArrays(dyld4::RuntimeState *this, unint64_t a2)
{
  *((void *)this + 124) = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), a2);
  *((void *)this + 125) = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 8 * a2);
  bzero(*((void **)this + 124), a2);
  bzero(*((void **)this + 125), 8 * a2);
}

uint64_t dyld4::RuntimeState::saveAppPrebuiltLoaderSet( dyld4::RuntimeState *this, const dyld4::PrebuiltLoaderSet *a2)
{
  __int128 v15 = &v17;
  __int128 v16 = xmmword_1800B8250;
  if ((dyld4::RuntimeState::buildBootToken((uint64_t)this, (uint64_t *)&v15) & 1) != 0)
  {
    if (*((void *)this + 122))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v14);
      Only = (unsigned int *)dyld4::SyscallDelegate::mapFileReadOnly( *((void *)this + 1),  (vm_address_t *)&v14,  *((dyld3 **)this + 122),  0LL,  0LL,  0LL,  0LL);
      if (!Only)
      {
LABEL_9:
        Diagnostics::Diagnostics((Diagnostics *)&v13);
        uint64_t v8 = dyld4::SyscallDelegate::saveFileWithAttribute( *((void *)this + 1),  (vm_address_t *)&v13,  *((char **)this + 122),  a2,  *((unsigned int *)a2 + 2),  "com.apple.dyld",  (uint64_t)&v15);
        if ((_DWORD)v8)
        {
          if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
            dyld4::RuntimeState::log(this, "wrote PrebuiltLoaderSet to file '%s'\n");
          }
        }

        else if (*(_BYTE *)(*((void *)this + 1) + 207LL))
        {
          Diagnostics::errorMessage((Diagnostics *)&v13);
          dyld4::RuntimeState::log(this, "tried but failed (%s) to write PrebuiltLoaderSet to file '%s'\n");
        }

        mach_o::Error::~Error(&v13);
        goto LABEL_20;
      }

      uint64_t v5 = Only;
      size_t v6 = Only[2];
      if ((_DWORD)v6 != *((_DWORD *)a2 + 2) || _platform_memcmp(Only, a2, Only[2]))
      {
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v6);
LABEL_7:
        dyld4::SyscallDelegate::unlink(*((dyld4::SyscallDelegate **)this + 1), *((const char **)this + 122));
        if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
          dyld4::RuntimeState::log( this,  "deleting existing out of date PrebuiltLoaderSet file '%s'\n",  *((const char **)this + 122));
        }
        goto LABEL_9;
      }

      BOOL HasBootToken = dyld4::RuntimeState::fileAlreadyHasBootToken((uint64_t)this, v7, (uint64_t)&v15);
      int v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
      if (HasBootToken)
      {
        if (*((_BYTE *)v11 + 207))
        {
          dyld4::RuntimeState::log(this, "PrebuiltLoaderSet already saved as file '%s'\n", *((const char **)this + 122));
          int v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
        }

        dyld4::SyscallDelegate::unmapFile(v11, v5, v5[2]);
      }

      else
      {
        if (*((_BYTE *)v11 + 207))
        {
          dyld4::RuntimeState::log( this,  "updating boot attribute on existing PrebuiltLoaderSet file '%s'\n",  *((const char **)this + 122));
          int v11 = (dyld4::SyscallDelegate *)*((void *)this + 1);
        }

        BOOL v12 = dyld4::SyscallDelegate::setFileAttribute( (int)v11,  *((char **)this + 122),  "com.apple.dyld",  (uint64_t)&v15);
        dyld4::SyscallDelegate::unmapFile(*((dyld4::SyscallDelegate **)this + 1), v5, v5[2]);
        if (!v12) {
          goto LABEL_7;
        }
      }

      uint64_t v8 = 1LL;
LABEL_20:
      mach_o::Error::~Error(&v14);
      return v8;
    }

    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "no path to save PrebuiltLoaderSet file\n");
    }
  }

  else if (*(_BYTE *)(*((void *)this + 1) + 207LL))
  {
    dyld4::RuntimeState::log(this, "could not save PrebuiltLoaderSet because main executable is not codesigned\n");
  }

  return 0LL;
}

dyld4::PrebuiltLoader *dyld4::RuntimeState::findPrebuiltLoader(dyld4::RuntimeState *this, const char *__s2)
{
  if (!*((void *)this + 120)) {
    goto LABEL_5;
  }
  uint64_t hasImagePath = DyldSharedCache::hasImagePath(*(DyldSharedCache **)(*((void *)this + 1) + 240LL), __s2, &v13);
  if (!(_DWORD)hasImagePath) {
    goto LABEL_5;
  }
  uint64_t v7 = *((void *)this + 120);
  uint64_t v8 = (dyld4::PrebuiltLoader *)(v7 + *(unsigned int *)(v7 + *(unsigned int *)(v7 + 16) + 4LL * (unsigned __int16)v13));
  if (!dyld4::PrebuiltLoader::isValid(v8, this, v6))
  {
LABEL_5:
    uint64_t v9 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 123);
    if (!v9) {
      return 0LL;
    }
    Loader = (dyld4::PrebuiltLoader *)dyld4::PrebuiltLoaderSet::findLoader(v9, this, __s2);
    if (!Loader) {
      return 0LL;
    }
    uint64_t v8 = Loader;
    if (!dyld4::PrebuiltLoader::isValid(Loader, this, v11)) {
      return 0LL;
    }
  }

  return v8;
}

void dyld4::RuntimeState::initializeClosureMode(dyld4::RuntimeState *this)
{
  __int128 v2 = 0uLL;
  *((_OWORD *)this + 60) = 0u;
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = *(void *)(v3 + 240);
  if (v4)
  {
    if (*(_DWORD *)(v4 + 16) >= 0x170u)
    {
      uint64_t v5 = (unsigned int *)(*(void *)(v3 + 264) + *(void *)(v4 + 328));
      int valid = dyld4::PrebuiltLoaderSet::validHeader((dyld4::PrebuiltLoaderSet *)v5, this);
      __int128 v2 = 0uLL;
      if (valid)
      {
        *((void *)this + 120) = v5;
        uint64_t v7 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), v5[3]);
        *((void *)this + 121) = v7;
        bzero(v7, *(unsigned int *)(*((void *)this + 120) + 12LL));
        __int128 v2 = 0uLL;
      }
    }
  }

  *((void *)this + 122) = 0LL;
  *((_OWORD *)this + 62) = v2;
  *((_BYTE *)this + 1008) = 0;
  uint64_t v8 = *((void *)this + 1);
  if (!*(void *)(v8 + 240))
  {
    if (*(_BYTE *)(v8 + 207)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because there is no dyld shared cache\n");
    }
    goto LABEL_33;
  }

  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(v8 + 400)))
  {
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders not being used because DYLD_ env vars are set\n");
    }
    goto LABEL_33;
  }

  if (!*((void *)this + 120) || !*((void *)this + 121))
  {
LABEL_33:
    int v19 = 0;
    int v18 = 0;
    __int128 v21 = (dyld4::PrebuiltLoaderSet **)((char *)this + 984);
    goto LABEL_34;
  }

  LaunchLoaderSet = DyldSharedCache::findLaunchLoaderSet( *(DyldSharedCache **)(*((void *)this + 1) + 240LL),  *(const char **)(*((void *)this + 1) + 16LL));
  uint64_t v10 = *((void *)this + 1);
  if (LaunchLoaderSet)
  {
    uint64_t v11 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSet;
LABEL_18:
    char v15 = 0;
    goto LABEL_19;
  }

  if (!_platform_strncmp(*(const char **)(v10 + 16), "/System/", 8uLL))
  {
    uint64_t v49 = *(DyldSharedCache **)(v10 + 240);
    uint64_t v50 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v10 + 8), "executable_cdhash");
    LaunchLoaderSetWithCDHash = DyldSharedCache::findLaunchLoaderSetWithCDHash(v49, v50);
    uint64_t v10 = *((void *)this + 1);
    if (LaunchLoaderSetWithCDHash)
    {
      uint64_t v11 = (dyld4::PrebuiltLoaderSet *)LaunchLoaderSetWithCDHash;
      uint64_t v53 = dyld4::Loader::leafName(*(dyld4::Loader **)(v10 + 16), v52);
      if (!*((_DWORD *)v11 + 3)) {
        dyld4::RuntimeState::findPrebuiltLoader((uint64_t)v53, v54, v55);
      }
      uint64_t v56 = (const char *)v53;
      uint64_t v57 = (dyld4::Loader *)dyld4::PrebuiltLoader::path( (dyld4::PrebuiltLoaderSet *)((char *)v11 + *(unsigned int *)((char *)v11 + *((unsigned int *)v11 + 4))),  this);
      uint64_t v59 = dyld4::Loader::leafName(v57, v58);
      int v60 = _platform_strcmp(v56, (const char *)v59);
      uint64_t v10 = *((void *)this + 1);
      if (!v60) {
        goto LABEL_18;
      }
    }
  }

  BOOL v12 = *(DyldSharedCache **)(v10 + 240);
  unsigned int v13 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v10 + 8), "executable_cdhash");
  BOOL hasLaunchLoaderSetWithCDHash = DyldSharedCache::hasLaunchLoaderSetWithCDHash(v12, v13);
  uint64_t v10 = *((void *)this + 1);
  if (hasLaunchLoaderSetWithCDHash)
  {
    uint64_t v11 = 0LL;
    goto LABEL_18;
  }

  unsigned int v20 = *(_DWORD *)(v10 + 68);
  if (v20 <= 0xB && (char v15 = 1, ((1 << v20) & 0x81C) != 0))
  {
    uint64_t v11 = 0LL;
  }

  else
  {
    dyld4::ProcessConfig::Process::appleParam((const char ***)(v10 + 8), "executable_cdhash");
    uint64_t v11 = 0LL;
    char v15 = 0;
    uint64_t v10 = *((void *)this + 1);
  }

LABEL_19:
  if (!*(_BYTE *)(v10 + 169)) {
    goto LABEL_24;
  }
  __int128 v16 = dyld4::ProcessConfig::Process::environ((const char ***)(v10 + 8), "DYLD_USE_CLOSURES");
  if (!v16) {
    goto LABEL_24;
  }
  char v17 = v16;
  if (!_platform_strcmp(v16, "0"))
  {
    *((void *)this + 120) = 0LL;
    goto LABEL_33;
  }

  if (_platform_strcmp(v17, "1"))
  {
    if (!_platform_strcmp(v17, "2"))
    {
      uint64_t v70 = *((void *)this + 1);
      unsigned int v71 = *(_DWORD *)(v70 + 68) - 2;
      if (v71 >= 0xA || ((0x207u >> v71) & 1) == 0)
      {
        dyld4::ProcessConfig::Process::appleParam((const char ***)(v70 + 8), "executable_cdhash");
        if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
          dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
        }
      }

      int v19 = 0;
      int v18 = 1;
LABEL_26:
      dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 0);
      if (*((void *)this + 122))
      {
        dyld4::RuntimeState::loadAppPrebuiltLoaderSet(this);
        goto LABEL_73;
      }

      goto LABEL_72;
    }

      BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, __int128 *))(v5[3] + 16LL))(1LL, 1LL, &v33);
      ++v10;
    }

    while (v10 != (uint64_t *)v11);
    uint64_t v6 = v5[3];
    a5 = v32;
  }

  __int128 v29 = v5[4];
  *(_DWORD *)(v6 + 4) = *(void *)(v29 + 16);
  atomic_store(*(void *)(v29 + 8), (unint64_t *)(v6 + 8));
  atomic_store(a5, (unint64_t *)(v5[3] + 184LL));
  uint64_t v30 = v5[5];
  uint64_t v31 = v5[3];
  *(void *)(v31 + 88) = *(void *)(v30 + 16);
  *(void *)(v31 + 96) = *(void *)(v30 + 8);
  return result;
}

LABEL_24:
    int v18 = 0;
    if ((v15 & 1) == 0)
    {
      int v19 = 0;
      goto LABEL_73;
    }

    int v19 = 1;
    goto LABEL_26;
  }

  uint64_t v61 = *((void *)this + 1);
  unsigned int v62 = *(_DWORD *)(v61 + 68) - 2;
  if (v62 >= 0xA || ((0x207u >> v62) & 1) == 0)
  {
    dyld4::ProcessConfig::Process::appleParam((const char ***)(v61 + 8), "executable_cdhash");
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoaders cannot be used with unsigned or old format programs\n");
    }
    int v18 = 0;
LABEL_72:
    int v19 = 0;
    goto LABEL_73;
  }

  int v18 = 0;
  int v19 = 1;
LABEL_73:
  __int128 v21 = (dyld4::PrebuiltLoaderSet **)((char *)this + 984);
  char v22 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 123);
  if (!v11 || v22)
  {
LABEL_35:
    if (v22)
    {
      int v23 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcSelectorMap(v22);
      if (v23)
      {
        uint64_t v24 = *v23;
        __int128 v25 = (char *)v23 + 4 * *v23;
        uint64_t v26 = *((void *)v25 + 1);
        *((void *)this + 43) = v23 + 1;
        *((void *)this + 44) = v24;
        *((void *)this + 45) = v24;
        *((void *)this + 46) = v25 + 16;
        *((void *)this + 47) = v26;
        *((void *)this + 48) = v26;
      }

      __int128 v27 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcClassMap(*v21);
      if (v27)
      {
        uint64_t v28 = *v27;
        __int128 v29 = &v27[*v27];
        uint64_t v30 = v29[1];
        *((void *)this + 49) = v27 + 1;
        *((void *)this + 50) = v28;
        *((void *)this + 51) = v28;
        *((void *)this + 52) = v29 + 2;
        *((void *)this + 53) = v30;
        *((void *)this + 54) = v30;
      }

      uint64_t v31 = (uint64_t *)dyld4::PrebuiltLoaderSet::objcProtocolMap(*v21);
      if (v31)
      {
        uint64_t v32 = *v31;
        uint64_t v33 = &v31[*v31];
        uint64_t v34 = v33[1];
        *((void *)this + 55) = v31 + 1;
        *((void *)this + 56) = v32;
        *((void *)this + 57) = v32;
        *((void *)this + 58) = v33 + 2;
        *((void *)this + 59) = v34;
        *((void *)this + 60) = v34;
      }

      uint64_t v35 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(*v21);
      if (v35)
      {
        uint64_t v36 = (void *)v35;
        uint64_t v37 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 61) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( (uint64_t)v37,  (uint64_t)this,  v36);
      }

      uint64_t v38 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(*v21);
      if (v38)
      {
        uint64_t v39 = (void *)v38;
        uint64_t v40 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 62) = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( (uint64_t)v40,  (uint64_t)this,  v39);
      }

      uint64_t v41 = dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(*v21);
      if (v41)
      {
        uint64_t v42 = (void *)v41;
        uint64_t v43 = lsl::Allocator::malloc(*((lsl::Lock ***)this + 2), 0x68uLL);
        *((void *)this + 63) = dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap( (uint64_t)v43,  (uint64_t)this,  v42);
      }
    }

    uint64_t v44 = *v21;
    if (!*v21)
    {
      *((_BYTE *)this + 1008) = v19;
      if (v19) {
        goto LABEL_50;
      }
      uint64_t v44 = 0LL;
    }

      if (*(_BYTE *)(*(void *)(a1 + 64) + 5LL)) {
        return;
      }
      uint64_t v24 = *(dyld4::RuntimeState **)(a1 + 56);
      __int128 v25 = *((void *)v24 + 75);
      if (v25)
      {
        if (!*(_BYTE *)(*((void *)v24 + 1) + 208LL)
          || (dyld4::RuntimeState::log(v24, "searching %llu pseudo-dylibs:\n", *((void *)v24 + 75)),
              uint64_t v24 = *(dyld4::RuntimeState **)(a1 + 56),
              (__int128 v25 = *((void *)v24 + 75)) != 0))
        {
          uint64_t v26 = (dyld4::PseudoDylib **)*((void *)v24 + 74);
          __int128 v27 = &v26[v25];
          while (1)
          {
            uint64_t v28 = dyld4::PseudoDylib::loadableAtPath(*v26, a2);
            if (v28)
            {
              __int128 v29 = (char *)v28;
              uint64_t v30 = *(dyld4::RuntimeState **)(a1 + 56);
              if (*(_BYTE *)(*((void *)v30 + 1) + 208LL)) {
                dyld4::RuntimeState::log(v30, "  found: pseduo-dylib: %s\n", a2);
              }
              Diagnostics::Diagnostics((Diagnostics *)&v78);
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dyld4::JustInTimeLoader::makePseudoDylibLoader( (vm_address_t *)&v78,  *(void *)(a1 + 56),  v29,  *(void *)(a1 + 64),  (mach_o::Header **)*v26);
              if (v29 != a2) {
                dyld4::PseudoDylib::disposeString((uint64_t (***)(char *))*v26, v29);
              }
              if (Diagnostics::hasError((Diagnostics *)&v78))
              {
                uint64_t v31 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
                uint64_t v32 = *(vm_address_t **)(a1 + 72);
                uint64_t v33 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v78);
                if (v31) {
                  Diagnostics::error(v32, "tried: '%s' (%s)", a2, v33);
                }
                else {
                  Diagnostics::appendError(v32, ", '%s' (%s)", a2, v33);
                }
                uint64_t v34 = *(dyld4::RuntimeState **)(a1 + 56);
                if (*(_BYTE *)(*((void *)v34 + 1) + 208LL))
                {
                  uint64_t v35 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v78);
                  dyld4::RuntimeState::log(v34, "  found: pseudo-dylib-error: %s => %s\n", a2, v35);
                }
              }

              if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
              {
                Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
                *a4 = 1;
                uint64_t v54 = (vm_address_t **)&v78;
                goto LABEL_141;
              }

              mach_o::Error::~Error((vm_address_t **)&v78);
            }

            if (++v26 == v27)
            {
              uint64_t v24 = *(dyld4::RuntimeState **)(a1 + 56);
              break;
            }
          }
        }

        if (*(_BYTE *)(*((void *)v24 + 1) + 208LL) && !*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
          dyld4::RuntimeState::log(v24, "   no pseudo-dylibs matched\n");
        }
      }

      int v75 = 0;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      if (*(_BYTE *)(a1 + 80))
      {
        if (a3 != 3
          && a3 != 8
          && dyld4::ProcessConfig::DyldCache::indexOfPath( (DyldSharedCache **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 240LL),  a2,  (unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)))
        {
          if (dyld4::ProcessConfig::DyldCache::isOverridablePath( (dyld4::ProcessConfig::DyldCache *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 240LL),  a2)
            && (dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8LL), a2, &v78, &v75) & 1) != 0)
          {
            if (BYTE8(v79))
            {
              uint64_t v36 = 1;
              goto LABEL_77;
            }

            Diagnostics::Diagnostics((Diagnostics *)&v72);
            goto LABEL_92;
          }

        char v17 = (const char *)dyld4::Loader::path(a3, this);
LABEL_26:
        dyld4::RuntimeState::log(this, "  interpose replaced 0x%08lX with 0x%08lX in %s\n", v4, v16, v17);
        return *v7;
      }
    }
  }

  return v4;
}

LABEL_54:
    *((_BYTE *)this + 1009) = 0;
    if (!v18) {
      return;
    }
    uint64_t v45 = (char *)this + 1009;
    if (v44) {
      return;
    }
    goto LABEL_56;
  }

  dyld4::RuntimeState::allocateProcessArrays(this, *((unsigned int *)v11 + 3));
  **((void **)this + 125) = *(void *)(*((void *)this + 1) + 8LL);
  if (!*((_DWORD *)v11 + 3)) {
    dyld4::RuntimeState::findPrebuiltLoader(v63, v64, v65);
  }
  uint64_t v66 = (dyld4::PrebuiltLoaderSet *)((char *)v11 + *(unsigned int *)((char *)v11 + *((unsigned int *)v11 + 4)));
  uint64_t v67 = *((void *)this + 1);
  if (*(_BYTE *)(v67 + 207))
  {
    dyld4::RuntimeState::log( this,  "PrebuiltLoader %p found for %s in the dyld cache\n",  (char *)v11 + *(unsigned int *)((char *)v11 + *((unsigned int *)v11 + 4)),  *(const char **)(v67 + 16));
    uint64_t v67 = *((void *)this + 1);
  }

  uint64_t v68 = dyld4::ProcessConfig::Process::appleParam((const char ***)(v67 + 8), "executable_cdhash");
  if (!v68 || !hexStringToBytes(v68, v73, 0x14u, &v72) || !dyld4::PrebuiltLoader::recordedCdHashIs(v66, v73))
  {
    if (*(_BYTE *)(*((void *)this + 1) + 207LL)) {
      dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because cdHash does not match\n", v66);
    }
    goto LABEL_34;
  }

  *((void *)this + 123) = v11;
  if ((dyld4::PrebuiltLoaderSet::isValid(v11, this) & 1) != 0)
  {
LABEL_34:
    char v22 = *v21;
    goto LABEL_35;
  }

  if (*(_BYTE *)(*((void *)this + 1) + 207LL))
  {
    int v69 = (const char *)dyld4::PrebuiltLoader::path(v66, this);
    dyld4::RuntimeState::log(this, "PrebuiltLoader %p not used because Loader for %s is invalid\n", v11, v69);
  }

  *((void *)this + 123) = 0LL;
  *((_BYTE *)this + 1008) = v19;
  if ((v19 & 1) == 0)
  {
    uint64_t v44 = 0LL;
    LOBYTE(v19) = 0;
    goto LABEL_54;
  }

LABEL_50:
  dyld4::RuntimeState::buildAppPrebuiltLoaderSetPath(this, 1);
  *((_BYTE *)this + 1009) = 0;
  if (!v18) {
    return;
  }
  uint64_t v45 = (char *)this + 1009;
  LOBYTE(v19) = 1;
  if (*v21) {
    return;
  }
LABEL_56:
  uint64_t v46 = *((void *)this + 1);
  char v47 = v19 ^ 1;
  if (!*(void *)(v46 + 240)) {
    char v47 = 1;
  }
  if ((v47 & 1) == 0)
  {
    uint64_t v48 = (const char *)*((void *)this + 122);
    if (v48)
    {
      _BYTE *v45 = 1;
      if (*(_BYTE *)(v46 + 207)) {
        dyld4::RuntimeState::log( this,  "PrebuiltLoaderSet required for '%s' but not found at '%s'\n",  *(const char **)(v46 + 136),  v48);
      }
    }
  }

BOOL dyld4::RuntimeState::inPrebuiltLoader( dyld4::RuntimeState *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  uint64_t v6 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 120);
  BOOL result = 1;
  if (!v6 || !dyld4::PrebuiltLoaderSet::contains(v6, a2, a3))
  {
    uint64_t v7 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 123);
    if (!v7 || !dyld4::PrebuiltLoaderSet::contains(v7, a2, a3)) {
      return 0;
    }
  }

  return result;
}

dyld4::DyldCacheDataConstScopedWriter *dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter( dyld4::DyldCacheDataConstScopedWriter *this, dyld4::RuntimeState *a2)
{
  *(void *)this = a2;
  *((_BYTE *)this + 8) = 0;
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(this);
  return this;
}

uint64_t dyld4::RuntimeState::rebindMissingFlatLazySymbols(std::span<dyld4::Loader const*,18446744073709551615ul> const&)::$_0::operator()( dyld4::Loader ****a1, uint64_t a2)
{
  __int128 v2 = (const dyld4::RuntimeState *)a1[2];
  uint64_t v3 = *(dyld4::Loader **)(a2 + 8);
  v14[0] = 0LL;
  v14[1] = v3;
  v14[2] = 0LL;
  v14[3] = 0LL;
  v14[4] = (dyld4::Loader *)2;
  uint64_t v4 = (*a1)[1];
  if (!v4) {
    return 0LL;
  }
  uint64_t v7 = **a1;
  uint64_t v8 = 8LL * (void)v4;
  while (1)
  {
    uint64_t v9 = *v7;
    if ((dyld4::Loader::hiddenFromFlat(*v7, 0) & 1) == 0)
    {
      if (dyld4::Loader::hasExportedSymbol( (uint64_t)v9,  (vm_address_t *)a1[1],  v2,  *(const unsigned __int8 **)(a2 + 8),  1u,  1,  (uint64_t *)v14,  0LL)) {
        break;
      }
    }

    ++v7;
    v8 -= 8LL;
    if (!v8) {
      return 0LL;
    }
  }

  uint64_t v11 = dyld4::Loader::resolvedAddress(v2, (uint64_t)v14);
  if (*(_BYTE *)(*((void *)v2 + 1) + 202LL))
  {
    uint64_t v12 = *(void *)(a2 + 16);
    unsigned int v13 = dyld4::Loader::leafName(v9, v2);
    dyld4::RuntimeState::log(v2, "fixup: *0x%012lX = 0x%012lX <%s>\n", v12, v11, v13);
  }

  **(void **)(a2 + 16) = v11;
  dyld4::RuntimeState::addDynamicReference(v2, *(const dyld4::Loader **)a2, v14[0]);
  return 1LL;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v11 = v7 + v9;
      unint64_t v12 = 0x9DDFEA08EB382D69LL
          * (v6 ^ ((0x9DDFEA08EB382D69LL * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69LL * (v6 ^ (v4 + a3))));
      unint64_t v13 = 0x9DDFEA08EB382D69LL * (v12 ^ (v12 >> 47));
      unint64_t v14 = v8 + a3 + v7 + v4;
      uint64_t v15 = v14 + v5;
      unint64_t v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297LL * (v12 ^ (v12 >> 47)), 21);
      uint64_t v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v18 = v17 + v6 + v9;
      uint64_t v19 = __ROR8__(v18, 44);
      uint64_t v20 = v18 + v10;
      uint64_t v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      uint64_t v23 = *a2;
      char v22 = a2 + 4;
      unint64_t v24 = v23 - 0x4B6D499041670D8DLL * v5;
      uint64_t v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0LL);
      do
      {
        uint64_t v26 = *(v22 - 3);
        uint64_t v27 = v24 + v15 + v11 + v26;
        uint64_t v28 = v22[2];
        uint64_t v29 = v22[3];
        uint64_t v30 = v22[1];
        unint64_t v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        uint64_t v31 = v13 + v20;
        uint64_t v32 = *(v22 - 2);
        uint64_t v33 = *(v22 - 1);
        uint64_t v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        uint64_t v35 = v34 + v20 + v33;
        uint64_t v36 = v34 + v26 + v32;
        uint64_t v15 = v36 + v33;
        uint64_t v37 = __ROR8__(v36, 44) + v34;
        unint64_t v38 = (0xB492B66FBE98F273LL * __ROR8__(v27, 37)) ^ v21;
        unint64_t v24 = 0xB492B66FBE98F273LL * __ROR8__(v31, 33);
        unint64_t v16 = v37 + __ROR8__(v35 + v38, 21);
        unint64_t v39 = v24 + v21 + *v22;
        uint64_t v20 = v39 + v30 + v28 + v29;
        uint64_t v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        unint64_t v13 = v38;
        v25 += 64LL;
      }

      while (v25);
      unint64_t v40 = v24
          - 0x622015F714C7D297LL
          * ((0x9DDFEA08EB382D69LL
            * (v21 ^ ((0x9DDFEA08EB382D69LL * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69LL * (v21 ^ ((0x9DDFEA08EB382D69LL * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v21 ^ v16)))) >> 47));
      unint64_t v41 = 0x9DDFEA08EB382D69LL
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297LL
                  * ((0x9DDFEA08EB382D69LL
                    * (v20 ^ ((0x9DDFEA08EB382D69LL * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69LL * (v20 ^ ((0x9DDFEA08EB382D69LL * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69LL * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }

    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](a2, a3);
    }
  }

  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](a2, a3);
  }

  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](a2, a3);
  }

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100]( _DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557LL * (a2 + 4LL * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }

    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69LL * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69LL * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }

  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL
            * (v4 ^ ((0x9DDFEA08EB382D69LL * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69LL * (v4 ^ ((0x9DDFEA08EB382D69LL * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }

  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100]( void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273LL * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557LL, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69LL * (v5 ^ (v4 - 0x3C5A37A36834CED9LL * *(void *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69LL
       * ((0x9DDFEA08EB382D69LL * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69LL * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100]( void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9LL * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9LL * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127LL * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1LL
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9LL * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9LL * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact( uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    unint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 16 * a2);
    if ((result & 1) == 0)
    {
      unint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 16 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0LL;
        for (unint64_t i = 0LL; i < v5; ++i)
        {
          *(_OWORD *)(result + v6) = *(_OWORD *)(*(void *)(v3 + 8) + v6);
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 16LL;
        }
      }

      uint64_t v8 = *(void **)(v3 + 8);
      if (v8)
      {
        unint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v8);
        unint64_t v5 = *(void *)(v3 + 16);
      }

      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

uint64_t lsl::Vector<dyld4::RuntimeState::MissingFlatSymbol>::reserveExact( uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    unint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 24 * a2);
    if ((result & 1) == 0)
    {
      unint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 24 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0LL;
        for (unint64_t i = 0LL; i < v5; ++i)
        {
          uint64_t v8 = result + v6;
          uint64_t v9 = (__int128 *)(*(void *)(v3 + 8) + v6);
          __int128 v10 = *v9;
          *(void *)(v8 + 16) = *((void *)v9 + 2);
          *(_OWORD *)uint64_t v8 = v10;
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 24LL;
        }
      }

      uint64_t v11 = *(void **)(v3 + 8);
      if (v11)
      {
        unint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v11);
        unint64_t v5 = *(void *)(v3 + 16);
      }

      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    unint64_t result = memmove((void *)v4[3], *v4, 32LL * (void)v4[2]);
    uint64_t v12 = (const void *)((unint64_t)v4[4] >> 5);
    const char *v4 = v4[3];
    v4[1] = v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve( void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    unint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 32 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    unint64_t result = memmove((void *)v3[3], *v3, 32LL * (void)v3[2]);
    uint64_t v11 = (const void *)((unint64_t)v3[4] >> 5);
    *unint64_t v3 = v3[3];
    v3[1] = v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    vm_address_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 16 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    unint64_t result = memmove((void *)v4[3], *v4, 16LL * (void)v4[2]);
    uint64_t v12 = (const void *)((unint64_t)v4[4] >> 4);
    const char *v4 = v4[3];
    v4[1] = v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    unint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 8 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    unint64_t result = memmove((void *)v3[3], *v3, 8LL * (void)v3[2]);
    uint64_t v11 = (const void *)((unint64_t)v3[4] >> 3);
    *unint64_t v3 = v3[3];
    v3[1] = v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

os_unfair_lock_s *lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::resize( os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  40 * a2);
  }

  else
  {
    unint64_t v3 = result + 2;
    unint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      unint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

uint64_t lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<dyld4::ExternallyViewableState::ImageInfo>::reserveExact(result, v2);
  }

  return result;
}

_BYTE *___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke( _BYTE *result, unsigned int a2)
{
  if (**((_DWORD **)result + 6) <= a2) {
    ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke_cold_1();
  }
  if ((*(_WORD *)(*(void *)(*((void *)result + 4) + 32LL * a2 + 16) + 4LL) & 2) != 0)
  {
    if (**((_BYTE **)result + 7)) {
      return dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(**((_BYTE ***)result + 5));
    }
  }

  return result;
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(dyld4::RuntimeState **)(a1 + 32);
  if (*((void *)v8 + 83) && *((void *)v8 + 34))
  {
    a1 = *((void *)v8 + 19);
    if (a1)
    {
      a1 = (**(uint64_t (***)(unint64_t))a1)(a1);
      if (a1 >= 3) {
        a1 = (*(uint64_t (**)(void))(**((void **)v8 + 19) + 160LL))(*((void *)v8 + 19));
      }
    }

    uint64_t v9 = *((void *)v8 + 34);
    if (v9)
    {
      uint64_t v10 = (void *)*((void *)v8 + 33);
      uint64_t v11 = &v10[4 * v9];
      do
      {
        a1 = (*((uint64_t (**)(void, void, void, void))v8 + 83))(*v10, v10[1], v10[2], v10[3]);
        v10 += 4;
      }

      while (v10 != v11);
    }

    if (*(_BYTE *)(*((void *)v8 + 1) + 205LL)) {
      dyld4::RuntimeState::log(v8, "objc-patch-class-notifier called with %lld patches:\n", *((void *)v8 + 34));
    }
    *((void *)v8 + 34) = 0LL;
  }

  unint64_t v12 = *((void *)v8 + 6);
  uint64_t v13 = 8 * v12;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v62);
  unint64_t v14 = (const void **)((char *)&v63[-1] - ((8 * v12 + 23) & 0xFFFFFFFFFFFFFFF0LL));
  __chkstk_darwin(v15, v16, v17, v18, v19, v20, v21, v22, v62);
  unint64_t v24 = (const char **)((char *)&v63[-1] - v23);
  __chkstk_darwin(v25, v26, v27, v28, v29, v30, v31, v32, v62);
  uint64_t v69 = 0LL;
  uint64_t v70 = &v69;
  uint64_t v71 = 0x4002000000LL;
  unsigned int v72 = __Block_byref_object_copy__164;
  uint64_t v73 = __Block_byref_object_dispose__165;
  uint64_t v74 = (char *)&v63[-1] - (v33 & 0xFFFFFFFFFFFFFFE0LL | 0x10);
  unint64_t v75 = v12;
  uint64_t v76 = 0LL;
  if (v12)
  {
    HIDWORD(v62) = 0;
    unint64_t v34 = 0LL;
    unint64_t v35 = 0LL;
    uint64_t v36 = (dyld4::Loader **)*((void *)v8 + 5);
    do
    {
      uint64_t v37 = *v36;
      uint64_t Address = dyld4::Loader::loadAddress(*v36, v8);
      if ((*((_WORD *)v37 + 2) & 4) != 0)
      {
        uint64_t v41 = Address;
        uint64_t v42 = dyld4::Loader::path(v37, v8);
        if (v35 >= v12) {
          dyld4::RuntimeState::appendInterposingTuples(v42, v43, v44);
        }
        v24[v35] = (const char *)v42;
        if (v34 >= v12) {
          dyld4::RuntimeState::appendInterposingTuples(v42, v43, v44);
        }
        uint64_t v45 = v8;
        unint64_t v46 = v12;
        v14[v34] = (const void *)v41;
        char v47 = v70 + 5;
        uint64_t v65 = v41;
        uint64_t v48 = v45;
        uint64_t v66 = dyld4::Loader::path(v37, v45);
        uint64_t v67 = v37;
        int DoesObjCFixups = dyld4::Loader::dyldDoesObjCFixups(v37);
        dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(v47, (uint64_t)&v65, v49);
        uint64_t Address = dyld4::Loader::hasConstantSegmentsToProtect(v37);
        __int16 v50 = *((_WORD *)v37 + 2);
        if ((_DWORD)Address && (v50 & 0x80) != 0)
        {
          dyld4::Loader::makeSegmentsReadWrite(v37, v48);
          __int16 v50 = *((_WORD *)v37 + 2);
        }

        ++v35;
        ++v34;
        HIDWORD(v62) |= (v50 & 2) >> 1;
        unint64_t v12 = v46;
        uint64_t v8 = v48;
      }

      ++v36;
      v13 -= 8LL;
    }

    while (v13);
    if (v34)
    {
      uint64_t v65 = (uint64_t)v8;
      LOBYTE(v66) = 0;
      if (*((void *)v8 + 84))
      {
        if ((v62 & 0x100000000LL) != 0) {
          uint64_t Address = (uint64_t)dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(&v65);
        }
        if (!v70[7]) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(Address, v39, v40);
        }
        (*((void (**)(unint64_t, uint64_t))v8 + 84))(v34, v70[5]);
      }

      else
      {
        uint64_t v51 = (void (*)(unint64_t, uint64_t, void *))*((void *)v8 + 86);
        if (v51)
        {
          v63[0] = _NSConcreteStackBlock;
          v63[1] = 0x40000000LL;
          v63[2] = ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166;
          v63[3] = &unk_18961F6E0;
          char v64 = BYTE4(v62) & 1;
          v63[4] = &v69;
          v63[5] = &v65;
          if (!v70[7]) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( Address,  v39,  v40);
          }
          v51(v34, v70[5], v63);
        }
      }

      if (*(_BYTE *)(*((void *)v8 + 1) + 205LL))
      {
        dyld4::RuntimeState::log(v8, "objc-mapped-notifier called with %lld images:\n", v34);
        do
        {
          if (!v35) {
            ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v52, v53, v54);
          }
          uint64_t v56 = *v14++;
          uint64_t v55 = v56;
          uint64_t v57 = *v24++;
          dyld4::RuntimeState::log(v8, " objc-mapped: %p %s\n", v55, v57);
          --v35;
          --v34;
        }

        while (v34);
      }

      uint64_t v58 = *((void *)v8 + 6);
      if (v58)
      {
        uint64_t v59 = (dyld4::Loader **)*((void *)v8 + 5);
        uint64_t v60 = 8 * v58;
        do
        {
          uint64_t v61 = *v59;
          if ((*((_WORD *)*v59 + 2) & 4) != 0
            && dyld4::Loader::hasConstantSegmentsToProtect(*v59)
            && (*((_WORD *)v61 + 2) & 0x80) != 0)
          {
            dyld4::Loader::makeSegmentsReadOnly(v61, v8);
          }

          ++v59;
          v60 -= 8LL;
        }

        while (v60);
      }

      if ((_BYTE)v66) {
        dyld4::ProcessConfig::DyldCache::makeDataConstWritable( (char **)(*(void *)(v65 + 8) + 240LL),  *(void *)(v65 + 8) + 200LL,  *(void *)(v65 + 8),  0);
      }
    }
  }

  _Block_object_dispose(&v69, 8);
}

__n128 __Block_byref_object_copy__164(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 dyld3::Array<_dyld_objc_notify_mapped_info>::push_back(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[2];
  if (v3 >= a1[1]) {
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)a1, a2, a3);
  }
  uint64_t v4 = *a1;
  a1[2] = v3 + 1;
  vm_size_t v5 = (_OWORD *)(v4 + 32 * v3);
  __n128 result = *(__n128 *)a2;
  __int128 v7 = *(_OWORD *)(a2 + 16);
  *vm_size_t v5 = *(_OWORD *)a2;
  v5[1] = v7;
  return result;
}

_BYTE *___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166( _BYTE *result, unsigned int a2)
{
  uint64_t v2 = *(void *)(*((void *)result + 4) + 8LL);
  if ((*(_WORD *)(*(void *)(*(void *)(v2 + 40) + 32LL * a2 + 16) + 4LL) & 2) != 0)
  {
    if (result[48]) {
      return dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*((_BYTE **)result + 5));
    }
  }

  return result;
}

uint64_t lsl::Vector<void (*)(mach_header const*,long)>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<void (*)(mach_header const*,long)>::reserveExact(result, v2);
  }

  return result;
}

uint64_t lsl::Vector<void (*)(mach_header const*,long)>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    __n128 result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 8 * a2);
    if ((result & 1) == 0)
    {
      __n128 result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 8 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0LL;
        __int128 v7 = (void *)result;
        do
          *v7++ = *(void *)(*(void *)(v3 + 8) + 8 * v6++);
        while (v5 != v6);
      }

      uint64_t v8 = *(void **)(v3 + 8);
      if (v8)
      {
        __n128 result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v8);
        unint64_t v5 = *(void *)(v3 + 16);
      }

      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( uint64_t a1, uint64_t a2, void *a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v5 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = *a3;
  *(void *)(a1 + 8) = a3[1];
  uint64_t v6 = a3 + 3;
  unint64_t v7 = a3[2];
  *unint64_t v5 = a3 + 3;
  *(void *)(a1 + 24) = v7;
  if (v7)
  {
    uint64_t v8 = dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    uint64_t v11 = *(void *)(a1 + 72);
    *(void *)(a1 + 32) = v7;
    if (v11) {
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( (uint64_t)v8,  v9,  v10);
    }
  }

  unint64_t v12 = &v6[v7];
  unint64_t v13 = *v12;
  *(void *)(a1 + 56) = v12 + 1;
  *(void *)(a1 + 64) = v13;
  if (v13)
  {
    dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve( (void *)(a1 + 56),  v13);
    *(void *)(a1 + 72) = v13;
  }

  *(void *)(a1 + 96) = a2;
  return a1;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap( uint64_t a1, uint64_t a2, void *a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v5 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = *a3;
  *(void *)(a1 + 8) = a3[1];
  uint64_t v6 = a3 + 3;
  unint64_t v7 = a3[2];
  *unint64_t v5 = a3 + 3;
  *(void *)(a1 + 24) = v7;
  if (v7)
  {
    uint64_t v8 = dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v5, v7);
    uint64_t v11 = *(void *)(a1 + 72);
    *(void *)(a1 + 32) = v7;
    if (v11) {
      dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( (uint64_t)v8,  v9,  v10);
    }
  }

  unint64_t v12 = &v6[v7];
  unint64_t v13 = *v12;
  *(void *)(a1 + 56) = v12 + 1;
  *(void *)(a1 + 64) = v13;
  if (v13)
  {
    dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve( (void *)(a1 + 56),  v13);
    *(void *)(a1 + 72) = v13;
  }

  *(void *)(a1 + 96) = a2;
  return a1;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve( void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 48 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    __n128 result = memmove((void *)v3[3], *v3, 48LL * (void)v3[2]);
    unint64_t v11 = (unint64_t)v3[4] / 0x30;
    *uint64_t v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

void OUTLINED_FUNCTION_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_3(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_4(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

char *lsl::emitPVLEUInt64(unint64_t a1, uint64_t a2)
{
  unint64_t v11 = a1;
  int v3 = __clz(a1);
  if (v3 == 64) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = 64 - v3;
  }
  if (v4 < 0x39)
  {
    uint64_t v9 = (v4 + 6) / 7;
    unint64_t v11 = (a1 << v9) | (1 << (v9 - 1));
    vm_size_t v7 = (char *)&v11 + v9;
    uint64_t v8 = (char *)&v12 + 7;
  }

  else
  {
    lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1LL);
    uint64_t v5 = *(void *)(a2 + 8);
    uint64_t v6 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v6 + 1;
    *(_BYTE *)(v5 + v6) = 0;
    vm_size_t v7 = (char *)&v12;
    uint64_t v8 = (char *)&v12 + 6;
  }

  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( (uint64_t)v8,  (char *)&v11,  v7,  a2);
}

uint64_t lsl::readPVLEUInt64(unsigned __int8 **a1)
{
  uint64_t __dst = 0LL;
  unint64_t v2 = *a1;
  unsigned int v3 = **a1;
  unsigned int v4 = __clz(__rbit32(v3));
  if (**a1) {
    BOOL v5 = v4 == 8;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t result = *(void *)(v2 + 1);
    uint64_t v7 = (uint64_t)(a1[1] - 9);
    *a1 = v2 + 9;
    a1[1] = (unsigned __int8 *)v7;
  }

  else
  {
    uint64_t v8 = v4 + 1;
    char v9 = 7 - v4;
    uint64_t v10 = (v3 >> (v4 + 1)) & ~(-1 << (7 - v4));
    if (v4)
    {
      memmove(&__dst, v2 + 1, v8 - 1);
      uint64_t v11 = __dst;
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    uint64_t result = (v11 << v9) | v10;
    uint64_t v12 = &a1[1][-v8];
    *a1 = &v2[v8];
    a1[1] = v12;
  }

  return result;
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  BOOL v5 = a2;
  if (a2 != a3)
  {
    do
    {
      lsl::Vector<std::byte>::reserve(a4, *(void *)(a4 + 16) + 1LL);
      char v7 = *v5++;
      uint64_t v8 = *(void *)(a4 + 8);
      uint64_t v9 = *(void *)(a4 + 16);
      *(void *)(a4 + 16) = v9 + 1;
      *(_BYTE *)(v8 + v9) = v7;
    }

    while (v5 != a3);
    return a3;
  }

  return v5;
}

uint64_t lsl::Vector<std::byte>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<std::byte>::reserveExact(result, v2);
  }

  return result;
}

uint64_t lsl::Vector<std::byte>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), a2);
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        for (unint64_t i = 0LL; i < v5; ++i)
        {
          *(_BYTE *)(result + i) = *(_BYTE *)(*(void *)(v3 + 8) + i);
          unint64_t v5 = *(void *)(v3 + 16);
        }
      }

      char v7 = *(void **)(v3 + 8);
      if (v7)
      {
        uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v7);
        unint64_t v5 = *(void *)(v3 + 16);
      }

      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

os_unfair_lock_s **lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(os_unfair_lock_s **a1, void *a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(os_unfair_lock_s **)&v3[36]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    }
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v3[28]);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v3[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }

  return a1;
}

os_unfair_lock_s *lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount( os_unfair_lock_s *this, void *a2)
{
  unint64_t v2 = this;
  do
    unsigned int v3 = __ldaxr(&this->_os_unfair_lock_opaque);
  while (__stlxr(v3 - 1, &this->_os_unfair_lock_opaque));
  if (!v3)
  {
    uint64_t v4 = *(dyld4::Atlas::Mapper **)&this[2]._os_unfair_lock_opaque;
    if (v4)
    {
      dyld4::Atlas::Mapper::~Mapper(v4);
      lsl::Allocator::freeObject(*(os_unfair_lock_s **)&v2[2]._os_unfair_lock_opaque, v5);
    }

    return lsl::Allocator::freeObject(v2, a2);
  }

  return this;
}

uint64_t dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 && *(_BYTE *)(a1 + 24)) {
    dyld4::Atlas::Mapper::unmap(*(dyld4::Atlas::Mapper **)a1, v2, *(void *)(a1 + 8));
  }
  return a1;
}

uint64_t SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, objc *this)
{
  unint64_t v4 = objc::lookup8(this, (const unsigned __int8 *)8, *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8((objc *)((char *)this + 8), (const unsigned __int8 *)8, *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4LL * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

uint64_t SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>(uint64_t a1, unsigned __int8 *a2)
{
  return (32 * *a2) & 0xE0 | 0x10u;
}

uint64_t SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = objc::lookup8(*(objc **)a2, *(const unsigned __int8 **)(a2 + 8), *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8((objc *)(a2 + 16), (const unsigned __int8 *)8, *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4LL * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  size_t v4 = HIWORD(*a2);
  return a2[1] == *(void *)(a3 + 16)
      && v4 == *(void *)(a3 + 8)
      && _platform_memcmp((const void *)(a4 + (*a2 & 0xFFFFFFFFFFFFLL)), *(const void **)a3, v4) == 0;
}

uint64_t SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 8) & 0x1F | (32 * (**(_BYTE **)a2 & 7u));
}

uint64_t SwiftHashTable::hash<PointerHashTableBuilderKey>(uint64_t a1, objc **a2)
{
  unint64_t v4 = objc::lookup8((objc *)(a2 + 1), (const unsigned __int8 *)4, *(void *)(a1 + 24));
  unint64_t v5 = objc::lookup8(*a2, (const unsigned __int8 *)(8 * *((_DWORD *)a2 + 2)), *(void *)(a1 + 24));
  int v6 = *(_DWORD *)(a1 + 8);
  if (v6 == 64) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (v5 ^ v4) >> v6;
  }
  return v7 ^ *(_DWORD *)(a1 + 4LL * *(unsigned __int8 *)(a1 + ((v5 ^ v4) & *(unsigned int *)(a1 + 12)) + 1056) + 32);
}

BOOL SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>( uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3 = a2[1];
  return v3 == *(_DWORD *)(a3 + 8) && _platform_memcmp((const void *)(a1 + *a2), *(const void **)a3, 8 * v3) == 0;
}

uint64_t SwiftHashTable::checkbyte<PointerHashTableBuilderKey>(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 8) & 0x1F | (32 * (**(_DWORD **)a2 & 7u));
}

const char *getForeignFullIdentity(const char *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = &a1[_platform_strlen(a1)];
  size_t v3 = _platform_strlen(v2 + 1);
  if (v3)
  {
    uint64_t v4 = (uint64_t)&v2[v3 + 1];
    unint64_t v5 = v2;
    do
    {
      int v6 = (const char *)v4;
      int v7 = v5[1];
      unsigned int v8 = v7 - 82;
      BOOL v9 = v7 == 78;
      uint64_t v10 = v5 + 2;
      if (v9)
      {
        uint64_t v11 = v6;
      }

      else
      {
        uint64_t v10 = v1;
        uint64_t v11 = v2;
      }

      if (v8 < 2)
      {
        unint64_t v2 = v6;
      }

      else
      {
        uint64_t v1 = v10;
        unint64_t v2 = v11;
      }

      size_t v12 = _platform_strlen(v6 + 1);
      uint64_t v4 = (uint64_t)&v6[v12 + 1];
      unint64_t v5 = v6;
    }

    while (v12);
  }

  return v1;
}

BOOL dyld4::PrebuiltSwift::findProtocolConformances( dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  if (!*((void *)a3 + 2))
  {
    Diagnostics::error( a2,  "Skipped optimizing Swift protocols due to missing objc class optimisations from the on-disk binary");
    return 0LL;
  }

  int v6 = (void *)*((void *)a4 + 1);
  uint64_t v19 = v6[39];
  if (!v19)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc class optimisations");
    return 0LL;
  }

  if (v6[36]) {
    BOOL v7 = v6[37] == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    Diagnostics::error(a2, "Skipped optimizing Swift protocols due to missing objc header infos");
    return 0LL;
  }

  uint64_t v9 = *((void *)a4 + 6);
  if (v9)
  {
    uint64_t v18 = v6[34];
    uint64_t v10 = (dyld4::Loader **)*((void *)a4 + 5);
    uint64_t v11 = 8 * v9;
    do
    {
      size_t v12 = *v10;
      if ((*((_WORD *)*v10 + 2) & 1) == 0)
      {
        unint64_t v13 = (dyld3::MachOFile *)dyld4::Loader::mf(*v10, a4);
        uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v13);
        uint64_t v15 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v12, a4);
        int v16 = dyld3::MachOFile::pointerSize(v15);
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000LL;
        v33[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke;
        v33[3] = &__block_descriptor_tmp_2;
        int v34 = v16;
        v33[4] = Address;
        v33[5] = v15;
        v31[0] = _NSConcreteStackBlock;
        v31[1] = 0x40000000LL;
        v31[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2;
        v31[3] = &__block_descriptor_tmp_5;
        v31[4] = Address;
        v31[5] = v12;
        int v32 = v16;
        v31[6] = v15;
        v31[7] = a4;
        uint64_t v25 = 0LL;
        uint64_t v26 = &v25;
        uint64_t v27 = 0x4802000000LL;
        uint64_t v28 = __Block_byref_object_copy__1;
        uint64_t v29 = __Block_byref_object_dispose__1;
        uint64_t v17 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(v12, a4);
        metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v30, v17);
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000LL;
        v22[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6;
        v22[3] = &unk_18961F7B8;
        v22[8] = v13;
        v22[9] = a2;
        v22[6] = &v25;
        v22[7] = this;
        v22[4] = v33;
        v22[5] = v31;
        v22[10] = Address;
        v22[11] = v12;
        v22[12] = a4;
        v22[13] = a3;
        v22[14] = v19;
        v22[15] = v18;
        char v23 = 1;
        *(_DWORD *)&v24[3] = *(_DWORD *)((char *)v35 + 3);
        *(_DWORD *)unint64_t v24 = v35[0];
        metadata_visitor::SwiftVisitor::forEachProtocolConformance( (metadata_visitor::SwiftVisitor *)(v26 + 5),  (uint64_t)v22);
        _Block_object_dispose(&v25, 8);
      }

      ++v10;
      v11 -= 8LL;
    }

    while (v11);
  }

  return !Diagnostics::hasError((Diagnostics *)a2);
}

BOOL ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke( uint64_t a1, _BYTE *a2)
{
  if (*a2) {
    return 0LL;
  }
  uint64_t v4 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)(a2 + 8));
  if (!v5) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = v4 - *(void *)(a1 + 32);
  if (*(_DWORD *)(a1 + 48) == 8) {
    uint64_t v8 = *(void *)(v6 + v7);
  }
  else {
    uint64_t v8 = *(unsigned int *)(v6 + v7);
  }
  return v8 == 0;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2@<X0>( metadata_visitor::ResolvedValue *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  int v5 = *(unsigned __int8 *)this;
  uint64_t result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)((char *)this + 8));
  if (v5)
  {
    if (v7)
    {
      uint64_t v8 = (char *)(result - *(void *)(a2 + 32));
      *(void *)a3 = *(void *)(a2 + 40);
LABEL_4:
      *(void *)(a3 + 8) = v8;
      *(_BYTE *)(a3 + 16) = 1;
      return result;
    }

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_6( uint64_t a1, metadata_visitor::SwiftConformance *this, _BYTE *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  if (metadata_visitor::SwiftConformance::isNull(this)
    && (dyld3::MachOFile::enforceFormat(*(_DWORD **)(a1 + 64), 14) & 1) == 0)
  {
    uint64_t v11 = *(vm_address_t **)(a1 + 72);
    metadata_visitor::SwiftConformance::getLocation(this);
    Diagnostics::error(v11, "Skipped optimizing Swift protocols due to null conformance at 0x%llx");
    goto LABEL_17;
  }

  metadata_visitor::SwiftConformance::getProtocolPointer( this,  (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  (uint64_t)v64);
  metadata_visitor::SwiftConformance::getTypeRef( this,  (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  (uint64_t)v63);
  metadata_visitor::SwiftConformance::getProtocolConformanceFlags( this,  (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  v62);
  metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer( (metadata_visitor::ResolvedValue *)v63,  (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  (uint64_t)v61);
  LOBYTE(v59.var0) = 0;
  char v60 = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(void *)(a1 + 40) + 16LL))(&v44);
  char v60 = v45;
  BindTarget v59 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error( *(vm_address_t **)(a1 + 72),  "Skipped optimizing Swift protocols, could not find image for type conformance pointer");
    goto LABEL_17;
  }

  LOBYTE(v57.var0) = 0;
  LOBYTE(v58) = 0;
  (*(void (**)(BindTarget *__return_ptr))(*(void *)(a1 + 40) + 16LL))(&v44);
  LOBYTE(v58) = v45;
  BindTarget v57 = v44;
  if (!(_BYTE)v45)
  {
    Diagnostics::error( *(vm_address_t **)(a1 + 72),  "Skipped optimizing Swift protocols, could not find image for type protocol pointer");
    goto LABEL_17;
  }

  VMuint64_t Address = objc_visitor::Protocol::getVMAddress(this);
  if (!v8) {
    goto LABEL_41;
  }
  unint64_t v9 = VMAddress - *(void *)(a1 + 80);
  unsigned int v10 = metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind((metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *)v62);
  if (v10 < 2)
  {
    LOBYTE(v55.var0) = 0;
    char v56 = 0;
    if (v59.var0 == *(Loader **)(a1 + 88))
    {
      v44.var0 = *(Loader **)(a1 + 80);
      int v14 = 1;
      LOBYTE(v44.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      uint64_t v23 = operator+((uint64_t)&v44, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL, v23, v24, &v44);
      BindTarget v50 = v44;
      *(void *)&__int128 v51 = v45;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50))
      {
        int hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v50);
        unint64_t v18 = (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        uint64_t v19 = &v50;
        goto LABEL_27;
      }
    }

    else
    {
      size_t v12 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer( (dyld4::Loader *)v59.var0,  *(dyld4::RuntimeState **)(a1 + 96));
      metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v44, v12);
      uint64_t v13 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v59.var0, *(const dyld4::RuntimeState **)(a1 + 96));
      v54.var0 = (Loader *)dyld3::MachOFile::preferredLoadAddress(v13);
      int v14 = 1;
      LOBYTE(v54.var1) = 1;
      v50.var0 = (Loader *)v59.var1;
      LOBYTE(v50.var1) = 1;
      uint64_t v15 = operator+((uint64_t)&v54, (uint64_t)&v50);
      metadata_visitor::Visitor::getValueFor((uint64_t)&v44, v15, v16, &v50);
      BindTarget v52 = v50;
      uint64_t v53 = v51;
      if (metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52))
      {
        int hasImportInfo = metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo((metadata_visitor::SwiftConformance::TypeContextDescriptor *)&v52);
        unint64_t v18 = (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        uint64_t v19 = &v52;
LABEL_27:
        metadata_visitor::SwiftConformance::TypeContextDescriptor::getName( (metadata_visitor::SwiftConformance::TypeContextDescriptor *)v19,  v18,  &v55);
        char v56 = 1;
LABEL_29:
        if (!v14)
        {
LABEL_37:
          if (!v60) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50, &v59);
          if (!(_BYTE)v58) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v57);
          v52.var0 = *(Loader **)(a1 + 88);
          v52.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v54, &v52);
          BindTarget v44 = v50;
          *(void *)&__int128 v45 = v54.var0;
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert( v6,  (uint64_t)&v44,  &v49);
          return;
        }

        uint64_t v25 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v55);
        v52.var0 = (Loader *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)&v55);
        v52.var1 = v26;
        size_t v27 = _platform_strlen(v25);
        if (hasImportInfo)
        {
          ForeignFullIdentity = getForeignFullIdentity(v25);
          size_t v30 = v29;
          v44.var0 = (Loader *)(ForeignFullIdentity - v25);
          LOBYTE(v44.var1) = 1;
          operator+=((uint64_t)&v52, (uint64_t)&v44);
          uint64_t v25 = (char *)ForeignFullIdentity;
        }

        else
        {
          size_t v30 = v27;
        }

        if (!(v30 >> 16))
        {
          uint64_t v31 = *(Loader **)(a1 + 88);
          v54.var0 = v31;
          if (!LOBYTE(v52.var1)) {
            goto LABEL_41;
          }
          var0 = v52.var0;
          uint64_t v33 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)v31, *(const dyld4::RuntimeState **)(a1 + 96));
          v54.var1 = (unint64_t)var0 - dyld3::MachOFile::preferredLoadAddress(v33);
          v50.var0 = (Loader *)v25;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v50.var1, &v54);
          *(void *)&__int128 v51 = v30;
          if (!(_BYTE)v58) {
            goto LABEL_41;
          }
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef( (dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v51 + 8),  &v57);
          v49.var0 = *(Loader **)(a1 + 88);
          v49.var1 = v9;
          dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v48, &v49);
          BindTarget v44 = v50;
          __int128 v45 = v51;
          uint64_t v46 = v48;
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( v6 + 208,  (uint64_t)&v44,  &v47);
          goto LABEL_37;
        }

        Diagnostics::error(*(vm_address_t **)(a1 + 72), "Protocol conformance exceeded name length of 16-bits");
LABEL_17:
        *a3 = 1;
        return;
      }
    }

    int v14 = 0;
    int hasImportInfo = 0;
    goto LABEL_29;
  }

  if (v10 == 2)
  {
    ClassName = (Loader *)metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName( (metadata_visitor::SwiftConformance::SwiftTypeRefPointer *)v63,  (const metadata_visitor::SwiftVisitor *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
    v55.var0 = *(Loader **)(a1 + 88);
    v55.var1 = v9;
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v55);
    v44.var0 = 0LL;
    v44.var1 = (unint64_t)&v44;
    *(void *)&__int128 v45 = 0x2000000000LL;
    BYTE8(v45) = 0;
    v50.var0 = ClassName;
    v50.var1 = _platform_strlen((const char *)ClassName);
    uint64_t v21 = *(uint64_t **)(a1 + 104);
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 0x40000000LL;
    v40[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11;
    v40[3] = &unk_18961F768;
    v40[4] = &v44;
    v40[5] = v6;
    BindTarget v41 = v57;
    uint64_t v42 = v58;
    uint64_t v43 = v52.var0;
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( (uint64_t)(v21 + 17),  v21 + 19,  v21 + 24,  v21[29],  (const void **)&v50.var0,  (uint64_t)v40);
    uint64_t v22 = *(unsigned int **)(a1 + 112);
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 0x40000000LL;
    void v34[2] = ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3;
    v34[3] = &unk_18961F790;
    __int128 v35 = *(_OWORD *)(a1 + 120);
    uint64_t v36 = *(void *)(a1 + 96);
    v34[4] = &v44;
    v34[5] = v6;
    BindTarget v37 = v57;
    uint64_t v38 = v58;
    uint64_t v39 = v52.var0;
    objc::ObjectHashTable::forEachObject(v22, (char *)ClassName, (uint64_t)v34);
    if (!*(_BYTE *)(v44.var1 + 24))
    {
      Diagnostics::error( *(vm_address_t **)(a1 + 72),  "Skipped optimizing Swift protocols, could not find image for ObjCClassName pointer at all");
      *a3 = 1;
    }

    _Block_object_dispose(&v44, 8);
  }

  else if (v10 == 3)
  {
    if (v60)
    {
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55, &v59);
      if ((_BYTE)v58)
      {
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v55.var1, &v57);
        v50.var0 = *(Loader **)(a1 + 88);
        v50.var1 = v9;
        dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v52, &v50);
        BindTarget v44 = v55;
        *(void *)&__int128 v45 = v52.var0;
        dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert( v6 + 104,  (uint64_t)&v44,  &v54);
        return;
      }
    }

LABEL_41:
    std::__throw_bad_optional_access[abi:nn180100]();
  }

uint64_t operator+(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 8) || !*(_BYTE *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return *(void *)a2 + *(void *)a1;
}

uint64_t operator+=(uint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 8) || !*(_BYTE *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  *(void *)result += *(void *)a2;
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    vm_size_t size = 0LL;
    memset(v50, 0, sizeof(v50));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v50, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v50, 1LL);
      uint64_t v8 = (*(void *)&v50[1])++;
      *(void *)(*(void *)&v50[0] + 8 * v8) = -1LL;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0LL;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v9)
                       + 40) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v9);
          unint64_t v12 = dyld4::HashForeignConformanceKey::hash(v10, *(dyld4::RuntimeState **)(a1 + 96), v11);
          unint64_t v13 = (*(void *)&v50[1] - 1LL) & v12;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) != -1LL)
          {
            uint64_t v14 = 1LL;
            do
              unint64_t v13 = (*(void *)&v50[1] - 1LL) & (v13 + v14++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) != -1LL);
          }

          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v50, v13) = v9;
        }

        ++v9;
      }

      while (v9 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v50)
    {
      *(void *)&v50[1] = 0LL;
      if (*((void *)&v50[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v50[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v15 = *(void *)(a1 + 40);
      if (v15) {
        vm_deallocate(mach_task_self_, v15, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v50[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v50 + 8);
      vm_size_t v16 = size;
      *(void *)(a1 + 40) = *((void *)&v50[1] + 1);
      *(void *)(a1 + 48) = v16;
    }
  }

  unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & dyld4::HashForeignConformanceKey::hash( a2,  *(dyld4::RuntimeState **)(a1 + 96),  (uint64_t)a3);
  unint64_t v18 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if (v18 == -1LL)
  {
LABEL_22:
    uint64_t v19 = (void *)(a1 + 56);
    uint64_t v22 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v22;
    ++*(void *)(a1 + 8);
    __int128 v23 = *(_OWORD *)(a2 + 16);
    v50[0] = *(_OWORD *)a2;
    v50[1] = v23;
    uint64_t v24 = *(void *)(a2 + 32);
    uint64_t v25 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v28 = *(void *)(a1 + 56);
    uint64_t v29 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v29 + 1;
    uint64_t v30 = v28 + 48 * v29;
    *(_OWORD *)uint64_t v30 = v50[0];
    *(_OWORD *)(v30 + 16) = v50[1];
    *(void *)(v30 + 32) = v24;
    *(void *)(v30 + 40) = 0LL;
    *a3 = 0;
    uint64_t v31 = *(void *)(a1 + 72);
    if (!v31) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v25,  v26,  v27);
    }
  }

  else
  {
    uint64_t v19 = (void *)(a1 + 56);
    uint64_t v20 = 1LL;
    while (1)
    {
      uint64_t v21 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      if (dyld4::EqualForeignConformanceKey::equal(v21, a2, *(dyld4::RuntimeState **)(a1 + 96))) {
        break;
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & (v17 + v20++);
      unint64_t v18 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if (v18 == -1LL) {
        goto LABEL_22;
      }
    }

    while (1)
    {
      char v32 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v18)
                     + 40);
      uint64_t v33 = (void *)(a1 + 56);
      if ((v32 & 3) == 0) {
        break;
      }
      unint64_t v18 = *(void *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( v33,  v18)
                      + 40) >> 3;
    }

    uint64_t v34 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( v33,  v18);
    uint64_t v37 = *(void *)(v34 + 40);
    if ((v37 & 7) != 0)
    {
      if ((v37 & 4) == 0) {
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( v34,  v35,  v36);
      }
      unint64_t v38 = v37 & 0xFFFFFFFFFFFFFFF9LL | 2;
      *(void *)(v34 + 40) = v38;
      uint64_t v39 = v38 & 3 | (8LL * *(void *)(a1 + 72));
    }

    else
    {
      uint64_t v40 = v37 | 1;
      *(void *)(v34 + 40) = v40;
      uint64_t v39 = v40 & 7 | (8LL * *(void *)(a1 + 72));
    }

    *(void *)(v34 + 40) = v39;
    __int128 v41 = *(_OWORD *)(a2 + 16);
    v50[0] = *(_OWORD *)a2;
    v50[1] = v41;
    uint64_t v42 = *(void *)(a2 + 32);
    uint64_t v43 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v46 = *(void *)(a1 + 56);
    uint64_t v47 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v47 + 1;
    uint64_t v48 = v46 + 48 * v47;
    *(_OWORD *)uint64_t v48 = v50[0];
    *(_OWORD *)(v48 + 16) = v50[1];
    *(void *)(v48 + 32) = v42;
    *(void *)(v48 + 40) = 4LL;
    *a3 = 1;
    uint64_t v31 = *(void *)(a1 + 72);
    if (!v31) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v43,  v44,  v45);
    }
  }

  return *v19 + 48 * v31 - 48;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    vm_size_t size = 0LL;
    memset(v47, 0, sizeof(v47));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v47, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v47, 1LL);
      uint64_t v8 = (*(void *)&v47[1])++;
      *(void *)(*(void *)&v47[0] + 8 * v8) = -1LL;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0LL;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v9)
                       + 24) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v9);
          unint64_t v11 = dyld4::HashTypeConformanceKey::hash(v10);
          unint64_t v12 = (*(void *)&v47[1] - 1LL) & v11;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) != -1LL)
          {
            uint64_t v13 = 1LL;
            do
              unint64_t v12 = (*(void *)&v47[1] - 1LL) & (v12 + v13++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) != -1LL);
          }

          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v47, v12) = v9;
        }

        ++v9;
      }

      while (v9 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v47)
    {
      *(void *)&v47[1] = 0LL;
      if (*((void *)&v47[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v47[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v14 = *(void *)(a1 + 40);
      if (v14) {
        vm_deallocate(mach_task_self_, v14, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v47[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v47 + 8);
      vm_size_t v15 = size;
      *(void *)(a1 + 40) = *((void *)&v47[1] + 1);
      *(void *)(a1 + 48) = v15;
    }
  }

  unint64_t v16 = (*(void *)(a1 + 32) - 1LL) & dyld4::HashTypeConformanceKey::hash(a2);
  unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
  if (v17 == -1LL)
  {
LABEL_22:
    unint64_t v18 = (void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16) = v21;
    ++*(void *)(a1 + 8);
    v47[0] = *(_OWORD *)a2;
    uint64_t v22 = *(void *)(a2 + 16);
    __int128 v23 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v26 = *(void *)(a1 + 56);
    uint64_t v27 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v27 + 1;
    uint64_t v28 = v26 + 32 * v27;
    *(_OWORD *)uint64_t v28 = v47[0];
    *(void *)(v28 + 16) = v22;
    *(void *)(v28 + 24) = 0LL;
    *a3 = 0;
    uint64_t v29 = *(void *)(a1 + 72);
    if (!v29) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v23,  v24,  v25);
    }
  }

  else
  {
    unint64_t v18 = (void *)(a1 + 56);
    uint64_t v19 = 1LL;
    while (1)
    {
      uint64_t v20 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v17);
      if (dyld4::EqualTypeConformanceKey::equal(v20, a2)) {
        break;
      }
      unint64_t v16 = (*(void *)(a1 + 32) - 1LL) & (v16 + v19++);
      unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
      if (v17 == -1LL) {
        goto LABEL_22;
      }
    }

    while (1)
    {
      char v30 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v17)
                     + 24);
      uint64_t v31 = (void *)(a1 + 56);
      if ((v30 & 3) == 0) {
        break;
      }
      unint64_t v17 = *(void *)(dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( v31,  v17)
                      + 24) >> 3;
    }

    uint64_t v32 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](v31, v17);
    uint64_t v35 = *(void *)(v32 + 24);
    if ((v35 & 7) != 0)
    {
      if ((v35 & 4) == 0) {
        dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( v32,  v33,  v34);
      }
      unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFF9LL | 2;
      *(void *)(v32 + 24) = v36;
      uint64_t v37 = v36 & 3 | (8LL * *(void *)(a1 + 72));
    }

    else
    {
      uint64_t v38 = v35 | 1;
      *(void *)(v32 + 24) = v38;
      uint64_t v37 = v38 & 7 | (8LL * *(void *)(a1 + 72));
    }

    *(void *)(v32 + 24) = v37;
    v47[0] = *(_OWORD *)a2;
    uint64_t v39 = *(void *)(a2 + 16);
    uint64_t v40 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v43 = *(void *)(a1 + 56);
    uint64_t v44 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v44 + 1;
    uint64_t v45 = v43 + 32 * v44;
    *(_OWORD *)uint64_t v45 = v47[0];
    *(void *)(v45 + 16) = v39;
    *(void *)(v45 + 24) = 4LL;
    *a3 = 1;
    uint64_t v29 = *(void *)(a1 + 72);
    if (!v29) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v40,  v41,  v42);
    }
  }

  return *v18 + 32 * v29 - 32;
}

uint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_2_11( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(const BindTarget ***)a2;
    int v5 = (const BindTarget *)(result + 48);
    uint64_t v6 = *(void *)(result + 40) + 104LL;
    uint64_t v7 = 8 * v2;
    do
    {
      uint64_t v8 = *v4;
      *(_BYTE *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = 1;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v12, v8 + 1);
      if (!*(_BYTE *)(v3 + 64)) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef( (dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v12 + 8),  v5);
      __int128 v9 = v12;
      uint64_t v10 = *(void *)(v3 + 72);
      __n128 result = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert( v6,  (uint64_t)&v9,  &v11);
      ++v4;
      v7 -= 8LL;
    }

    while (v7);
  }

  return result;
}

unint64_t ___ZN5dyld413PrebuiltSwift24findProtocolConformancesER11DiagnosticsRNS_12PrebuiltObjCERNS_12RuntimeStateE_block_invoke_3( unint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 56)) {
    goto LABEL_13;
  }
  unint64_t v2 = result;
  uint64_t v3 = *(const dyld4::RuntimeState **)(result + 64);
  uint64_t v4 = *((void *)v3 + 6);
  if (!v4) {
    return result;
  }
  uint64_t v5 = *(void *)(result + 40);
  unint64_t v6 = *(void *)(result + 48) + a2;
  uint64_t v7 = (dyld4::Loader **)*((void *)v3 + 5);
  uint64_t v8 = 8 * v4;
  while (1)
  {
    __int128 v9 = *v7;
    uint64_t v10 = (dyld3::MachOFile *)dyld4::Loader::mf(*v7, v3);
    unint64_t Address = dyld3::MachOFile::preferredLoadAddress(v10);
    __n128 result = dyld3::MachOFile::mappedSize(v10);
    if (v6 >= Address && result + Address > v6) {
      break;
    }
    ++v7;
    v8 -= 8LL;
    if (!v8) {
      return result;
    }
  }

  v17.var0 = (Loader *)v9;
  v17.var1 = v6 - Address;
  *(_BYTE *)(*(void *)(*(void *)(v2 + 32) + 8LL) + 24LL) = 1;
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v16, &v17);
  if (!*(_BYTE *)(v2 + 88)) {
LABEL_13:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef( (dyld4::PrebuiltLoader::BindTargetRef *)((char *)&v16 + 8),  (const BindTarget *)(v2 + 72));
  __int128 v13 = v16;
  uint64_t v14 = *(void *)(v2 + 96);
  return dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::insert( v5 + 104,  (uint64_t)&v13,  &v15);
}

BOOL dyld4::PrebuiltSwift::make( dyld4::PrebuiltSwift *this, vm_address_t *a2, dyld4::PrebuiltObjC *a3, dyld4::RuntimeState *a4)
{
  BOOL result = dyld4::PrebuiltSwift::findProtocolConformances(this, a2, a3, a4);
  if (result) {
    *((_BYTE *)this + 312) = 1;
  }
  return result;
}

void std::__throw_bad_optional_access[abi:nn180100]()
{
}

uint64_t objc::StringHashTable::tryGetIndex(objc::StringHashTable *this, char *__s)
{
  uint64_t v4 = (const unsigned __int8 *)_platform_strlen(__s);
  char v5 = (char)v4;
  unint64_t v6 = objc::lookup8((objc *)__s, v4, *((void *)this + 3));
  int v7 = *((_DWORD *)this + 3);
  uint64_t v8 = *((unsigned int *)this + 4);
  if (v7 == 64) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v6 >> v7;
  }
  uint64_t v10 = v9 ^ *((_DWORD *)this + *((unsigned __int8 *)this + (v6 & v8) + 1056) + 8);
  char v11 = (char *)this + (v8 + 1) + 1056;
  if (v11[v10] != (v5 & 0x1F | (32 * *__s)))
  {
LABEL_7:
    LODWORD(v12) = 0;
    goto LABEL_8;
  }

  uint64_t v12 = *(int *)&v11[4 * v10 + *((unsigned int *)this + 1)];
  if ((_DWORD)v12)
  {
    if (!_platform_strcmp(__s, (const char *)this + v12))
    {
      int v14 = v10 & 0xFFFFFF00;
      LODWORD(v12) = v10;
      uint64_t v13 = 0x100000000LL;
      return v13 | v14 | v12;
    }

    goto LABEL_7;
  }

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve( a1,  a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 48 * a2;
}

unint64_t dyld4::HashForeignConformanceKey::hash(uint64_t a1, dyld4::RuntimeState *a2, uint64_t a3)
{
  if (a2) {
    unint64_t v4 = (uint64_t *)dyld4::PrebuiltLoader::BindTargetRef::value( (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8),  a2,  a3);
  }
  else {
    unint64_t v4 = *(uint64_t **)a1;
  }
  unint64_t v7 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24)) & 0xFFF;
  unint64_t v5 = murmurHash(v4, *(_DWORD *)(a1 + 16), 0LL);
  return murmurHash((uint64_t *)&v7, 8, 0LL) ^ v5;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 48 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    BOOL result = memmove((void *)v4[3], *v4, 48LL * (void)v4[2]);
    unint64_t v12 = (unint64_t)v4[4] / 0x30;
    uint64_t *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

unint64_t dyld4::HashTypeConformanceKey::hash(uint64_t a1)
{
  unint64_t v5 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1) & 0xFFF;
  unint64_t v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8)) & 0xFFF;
  unint64_t v2 = murmurHash((uint64_t *)&v5, 8, 0LL);
  return murmurHash((uint64_t *)&v4, 8, 0LL) ^ v2;
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, const void **a5, uint64_t a6)
{
  uint64_t v44 = a6;
  uint64_t v45 = a3;
  if (a3[2])
  {
    uint64_t v8 = prebuilt_objc::hashStringKey((uint64_t)a5);
    unint64_t v11 = a2[2];
    unint64_t v12 = (v11 - 1) & v8;
    if (v11 <= v12) {
LABEL_9:
    }
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v8,  v9,  v10);
    uint64_t v13 = *a2;
    unint64_t v14 = v45[2];
    uint64_t v15 = *v45;
    uint64_t v16 = 1LL;
    uint64_t v19 = a5;
    unint64_t v18 = *a5;
    size_t v17 = (size_t)v19[1];
    while (1)
    {
      unint64_t v20 = *(void *)(v13 + 8 * v12);
      if (v20 == -1LL) {
        break;
      }
      if (v14 <= v20) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v8,  v9,  v10);
      }
      uint64_t v21 = v15 + 56 * v20;
      if (*(void *)(v21 + 8) == v17)
      {
        uint64_t v8 = _platform_memcmp(*(const void **)v21, v18, v17);
        if (!(_DWORD)v8)
        {
          unint64_t v27 = *(void *)(v15 + 56 * v20 + 48);
          if ((v27 & 7) != 0)
          {
            if (v14 <= v27 >> 3) {
LABEL_15:
            }
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v8,  v9,  v10);
            unint64_t v28 = v27 >> 3;
            int v29 = 2;
            while (1)
            {
              unint64_t v30 = *(void *)(v15 + 56 * v28 + 48);
              if ((v30 & 3) == 0) {
                break;
              }
              unint64_t v28 = v30 >> 3;
              ++v29;
              if (v14 <= v30 >> 3) {
                goto LABEL_15;
              }
            }

            __chkstk_darwin(v8, v9, v10, v22, v23, v24, v25, v26, v43);
            *(uint64_t *)((char *)&v43 - v34) = v15 + 56 * v20 + 16;
            unint64_t v35 = v45[2];
            unint64_t v37 = *v36;
            if (v35 <= v37 >> 3) {
LABEL_20:
            }
              dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v31,  v32,  v33);
            unint64_t v38 = v37 >> 3;
            uint64_t v39 = *v45;
            unsigned int v40 = 2;
            while (1)
            {
              uint64_t v41 = v39 + 56 * v38;
              unint64_t v42 = *(void *)(v41 + 48);
              *(uint64_t *)((char *)&v43 + 8 * v40 - v34 - 8) = v41 + 16;
              if ((v42 & 3) == 0) {
                break;
              }
              unint64_t v38 = v42 >> 3;
              ++v40;
              if (v35 <= v42 >> 3) {
                goto LABEL_20;
              }
            }

            uint64_t v46 = (uint64_t *)((char *)&v43 - v34);
            v47.i64[0] = v40;
            v47.i64[1] = v40;
            (*(void (**)(uint64_t, uint64_t **))(v44 + 16))(v44, &v46);
          }

          else
          {
            uint64_t v48 = v15 + 56 * v20 + 16;
            uint64_t v46 = &v48;
            int64x2_t v47 = vdupq_n_s64(1uLL);
            (*(void (**)(uint64_t, uint64_t **))(v44 + 16))(v44, &v46);
          }

          return;
        }
      }

      unint64_t v12 = (v11 - 1) & (v12 + v16++);
      if (v11 <= v12) {
        goto LABEL_9;
      }
    }
  }

void OUTLINED_FUNCTION_1_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_2_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_3_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t dyld4::Loader::InitialOptions::InitialOptions(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)this = 0LL;
  return this;
}

BOOL *dyld4::Loader::InitialOptions::InitialOptions(BOOL *this, const Loader *a2)
{
  *this = (*((_BYTE *)a2 + 4) & 2) != 0;
  this[1] = (*((_BYTE *)a2 + 4) & 4) != 0;
  this[2] = (*((_BYTE *)a2 + 4) & 8) != 0;
  this[3] = (*((_BYTE *)a2 + 4) & 0x10) != 0;
  this[4] = (*((_BYTE *)a2 + 4) & 0x20) != 0;
  this[5] = (*((_BYTE *)a2 + 4) & 0x40) != 0;
  this[6] = (*((_WORD *)a2 + 2) & 0x80) != 0;
  this[7] = *((_BYTE *)a2 + 5) & 1;
  this[8] = (*((_WORD *)a2 + 2) & 0x400) != 0;
  this[9] = (*((_WORD *)a2 + 2) & 0x800) != 0;
  this[10] = (*((_WORD *)a2 + 2) & 0x1000) != 0;
  this[11] = (*((_WORD *)a2 + 2) & 0x2000) != 0;
  return this;
}

uint64_t dyld4::Loader::path(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::path();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::path(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::path(this, a2);
  }
}

uint64_t dyld4::Loader::mf(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::mf();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::mf(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::mf(this, a2);
  }
}

uint64_t dyld4::Loader::loadAddress(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::loadAddress();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::loadAddress(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::mf(this, a2);
  }
}

uint64_t dyld4::Loader::contains( dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::contains();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::contains(this, a2, a3, a4, a5, a6);
  }
  else {
    return dyld4::JustInTimeLoader::contains(this, a2, (unint64_t)a3, a4, a5, a6);
  }
}

BOOL dyld4::Loader::matchesPath(dyld4::Loader *this, const dyld4::RuntimeState *a2, char *a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::matchesPath();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::matchesPath(this, a2, a3);
  }
  else {
    return dyld4::JustInTimeLoader::matchesPath(this, a2, a3);
  }
}

double dyld4::Loader::fileID@<D0>(dyld4::Loader *this@<X0>, int8x16_t *a2@<X8>)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::fileID();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::fileID(this, a2);
  }
  *(void *)&double result = dyld4::JustInTimeLoader::fileID(this, (uint64_t)a2).n128_u64[0];
  return result;
}

uint64_t dyld4::Loader::dependentCount(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::dependentCount();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::dependentCount(this);
  }
  else {
    return dyld4::JustInTimeLoader::dependentCount(this);
  }
}

uint64_t dyld4::Loader::dependent(dyld4::JustInTimeLoader *a1, dyld4::RuntimeState *a2, uint64_t a3, char *a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::dependent();
  }
  if ((*((_WORD *)a1 + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::dependent(a1, a2, a3, a4);
  }
  else {
    return dyld4::JustInTimeLoader::dependent(a1, (int)a2, a3, a4);
  }
}

void dyld4::Loader::loadDependents(uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::loadDependents();
  }
  if ((*(_WORD *)(a1 + 4) & 1) != 0) {
    dyld4::PrebuiltLoader::loadDependents(a1, a2, a3, a4);
  }
  else {
    dyld4::JustInTimeLoader::loadDependents(a1, (Diagnostics *)a2, a3, a4);
  }
}

BOOL dyld4::Loader::getExportsTrie(dyld4::Loader *this, unint64_t *a2, unsigned int *a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::getExportsTrie();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::getExportsTrie(this, a2, a3);
  }
  else {
    return dyld4::JustInTimeLoader::getExportsTrie(this, a2, a3);
  }
}

unint64_t dyld4::Loader::hiddenFromFlat(dyld4::Loader *this, char a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::hiddenFromFlat();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  }
  else {
    return dyld4::JustInTimeLoader::hiddenFromFlat(this, a2);
  }
}

uint64_t dyld4::Loader::representsCachedDylibIndex(dyld4::Loader *this, int a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::representsCachedDylibIndex();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::hiddenFromFlat(this);
  }
  else {
    return dyld4::JustInTimeLoader::representsCachedDylibIndex(this, a2);
  }
}

uint64_t dyld4::Loader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::overridesDylibInCache();
  }
  if ((*(_WORD *)(a1 + 4) & 1) != 0) {
    return dyld4::PrebuiltLoader::overridesDylibInCache(a1, a2, a3);
  }
  else {
    return dyld4::JustInTimeLoader::overridesDylibInCache(a1, a2, a3);
  }
}

void dyld4::Loader::applyFixups( uint64_t a1, Diagnostics *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4, char a5, uint64_t a6)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::applyFixups();
  }
  if ((*(_WORD *)(a1 + 4) & 1) != 0) {
    dyld4::PrebuiltLoader::applyFixups(a1, a2, a3, a4);
  }
  else {
    dyld4::JustInTimeLoader::applyFixups(a1, (vm_address_t *)a2, a3, a4, a5, a6);
  }
}

void dyld4::Loader::withLayout(dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  if (*(_DWORD *)a1 != 1815378276) {
    dyld4::Loader::withLayout();
  }
  if ((*((_WORD *)a1 + 2) & 1) != 0) {
    dyld4::PrebuiltLoader::withLayout(a1, a2, a3, a4);
  }
  else {
    dyld4::JustInTimeLoader::withLayout((uint64_t)a1, a2, (uint64_t)a3, a4);
  }
}

uint64_t dyld4::Loader::dyldDoesObjCFixups(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::dyldDoesObjCFixups();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::dyldDoesObjCFixups(this);
  }
  else {
    return dyld4::JustInTimeLoader::dyldDoesObjCFixups(this);
  }
}

uint64_t dyld4::Loader::getSectionLocations(dyld4::Loader *this)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::getSectionLocations();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::getSectionLocations(this);
  }
  else {
    return dyld4::JustInTimeLoader::getSectionLocations(this);
  }
}

void dyld4::Loader::unmap(dyld4::Loader *this, dyld4::RuntimeState *a2, char a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::unmap();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    dyld4::PrebuiltLoader::unmap((uint64_t)this, a2);
  }
  else {
    dyld4::JustInTimeLoader::unmap(this, (dyld4::SyscallDelegate **)a2, a3);
  }
}

uint64_t dyld4::Loader::hasBeenFixedUp(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::hasBeenFixedUp();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::hasBeenFixedUp(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::hasBeenFixedUp(this, a2);
  }
}

unint64_t dyld4::Loader::beginInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::beginInitializers();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::beginInitializers(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::beginInitializers(this, a2);
  }
}

void dyld4::Loader::runInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::runInitializers();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    dyld4::PrebuiltLoader::runInitializers(this, a2);
  }
  else {
    dyld4::JustInTimeLoader::runInitializers((uint64_t (****)(char *))this, a2);
  }
}

uint64_t dyld4::Loader::isDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::isDelayInit();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::isDelayInit(this, a2);
  }
  else {
    return dyld4::JustInTimeLoader::isDelayInit(this, a2);
  }
}

uint64_t dyld4::Loader::setDelayInit(dyld4::Loader *this, dyld4::RuntimeState *a2, int a3)
{
  if (*(_DWORD *)this != 1815378276) {
    dyld4::Loader::setDelayInit();
  }
  if ((*((_WORD *)this + 2) & 1) != 0) {
    return dyld4::PrebuiltLoader::setDelayInit((uint64_t)this, a2, a3);
  }
  else {
    return dyld4::JustInTimeLoader::setDelayInit((uint64_t)this, a2, a3);
  }
}

uint64_t dyld4::Loader::LoaderRef::loader( dyld4::Loader::LoaderRef *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  int v3 = *(__int16 *)this;
  unsigned int v4 = *(unsigned __int16 *)this;
  if (v3 < 0)
  {
    uint64_t v5 = *((void *)a2 + 123);
    LOWORD(v3) = v4 & 0x7FFF;
    if (*(_DWORD *)(v5 + 12) <= (v4 & 0x7FFF)) {
      dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
    }
  }

  else
  {
    uint64_t v5 = *((void *)a2 + 120);
    if (*(_DWORD *)(v5 + 12) <= v4) {
      dyld4::RuntimeState::findPrebuiltLoader((uint64_t)this, (uint64_t)a2, a3);
    }
  }

  return v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4LL * (unsigned __int16)v3);
}

dyld4::Loader *dyld4::Loader::leafName(dyld4::Loader *this, const char *a2)
{
  int v3 = strrchr((const char *)this, 47);
  if (v3) {
    return (dyld4::Loader *)(v3 + 1);
  }
  else {
    return this;
  }
}

const char *dyld4::Loader::leafName(dyld4::Loader *this, const dyld4::RuntimeState *a2)
{
  unint64_t v2 = (const char *)dyld4::Loader::path(this, a2);
  int v3 = strrchr(v2, 47);
  if (v3) {
    return v3 + 1;
  }
  else {
    return v2;
  }
}

BOOL dyld4::Loader::hasMagic(dyld4::Loader *this)
{
  return *(_DWORD *)this == 1815378276;
}

uint64_t dyld4::Loader::appendHexByte(uint64_t this, void *a2, char **a3)
{
  int v3 = (_BYTE *)(*a2)++;
  else {
    char v4 = 48;
  }
  *int v3 = v4 + (this >> 4);
  uint64_t v5 = (_BYTE *)(*a2)++;
  else {
    char v6 = 48;
  }
  *uint64_t v5 = v6 + (this & 0xF);
  return this;
}

unsigned __int8 *dyld4::Loader::uuidToStr(unsigned __int8 *this, unsigned __int8 *a2, char *a3)
{
  unsigned int v3 = *this;
  if (v3 >= 0xA0) {
    char v4 = 55;
  }
  else {
    char v4 = 48;
  }
  *a2 = v4 + (*this >> 4);
  unsigned int v5 = v3 & 0xF;
  if (v5 >= 0xA) {
    char v6 = 55;
  }
  else {
    char v6 = 48;
  }
  a2[1] = v6 + v5;
  unsigned int v7 = this[1];
  if (v7 >= 0xA0) {
    char v8 = 55;
  }
  else {
    char v8 = 48;
  }
  a2[2] = v8 + (this[1] >> 4);
  unsigned int v9 = v7 & 0xF;
  if (v9 >= 0xA) {
    char v10 = 55;
  }
  else {
    char v10 = 48;
  }
  a2[3] = v10 + v9;
  unsigned int v11 = this[2];
  if (v11 >= 0xA0) {
    char v12 = 55;
  }
  else {
    char v12 = 48;
  }
  a2[4] = v12 + (this[2] >> 4);
  unsigned int v13 = v11 & 0xF;
  if (v13 >= 0xA) {
    char v14 = 55;
  }
  else {
    char v14 = 48;
  }
  a2[5] = v14 + v13;
  unsigned int v15 = this[3];
  if (v15 >= 0xA0) {
    char v16 = 55;
  }
  else {
    char v16 = 48;
  }
  a2[6] = v16 + (this[3] >> 4);
  unsigned int v17 = v15 & 0xF;
  if (v17 >= 0xA) {
    char v18 = 55;
  }
  else {
    char v18 = 48;
  }
  a2[7] = v18 + v17;
  a2[8] = 45;
  unsigned int v19 = this[4];
  if (v19 >= 0xA0) {
    char v20 = 55;
  }
  else {
    char v20 = 48;
  }
  a2[9] = v20 + (this[4] >> 4);
  unsigned int v21 = v19 & 0xF;
  if (v21 >= 0xA) {
    char v22 = 55;
  }
  else {
    char v22 = 48;
  }
  a2[10] = v22 + v21;
  unsigned int v23 = this[5];
  if (v23 >= 0xA0) {
    char v24 = 55;
  }
  else {
    char v24 = 48;
  }
  a2[11] = v24 + (this[5] >> 4);
  unsigned int v25 = v23 & 0xF;
  if (v25 >= 0xA) {
    char v26 = 55;
  }
  else {
    char v26 = 48;
  }
  a2[12] = v26 + v25;
  a2[13] = 45;
  unsigned int v27 = this[6];
  if (v27 >= 0xA0) {
    char v28 = 55;
  }
  else {
    char v28 = 48;
  }
  a2[14] = v28 + (this[6] >> 4);
  unsigned int v29 = v27 & 0xF;
  if (v29 >= 0xA) {
    char v30 = 55;
  }
  else {
    char v30 = 48;
  }
  a2[15] = v30 + v29;
  unsigned int v31 = this[7];
  if (v31 >= 0xA0) {
    char v32 = 55;
  }
  else {
    char v32 = 48;
  }
  a2[16] = v32 + (this[7] >> 4);
  unsigned int v33 = v31 & 0xF;
  if (v33 >= 0xA) {
    char v34 = 55;
  }
  else {
    char v34 = 48;
  }
  a2[17] = v34 + v33;
  a2[18] = 45;
  unsigned int v35 = this[8];
  if (v35 >= 0xA0) {
    char v36 = 55;
  }
  else {
    char v36 = 48;
  }
  a2[19] = v36 + (this[8] >> 4);
  unsigned int v37 = v35 & 0xF;
  if (v37 >= 0xA) {
    char v38 = 55;
  }
  else {
    char v38 = 48;
  }
  a2[20] = v38 + v37;
  unsigned int v39 = this[9];
  if (v39 >= 0xA0) {
    char v40 = 55;
  }
  else {
    char v40 = 48;
  }
  a2[21] = v40 + (this[9] >> 4);
  unsigned int v41 = v39 & 0xF;
  if (v41 >= 0xA) {
    char v42 = 55;
  }
  else {
    char v42 = 48;
  }
  a2[22] = v42 + v41;
  a2[23] = 45;
  unsigned int v43 = this[10];
  if (v43 >= 0xA0) {
    char v44 = 55;
  }
  else {
    char v44 = 48;
  }
  a2[24] = v44 + (this[10] >> 4);
  unsigned int v45 = v43 & 0xF;
  if (v45 >= 0xA) {
    char v46 = 55;
  }
  else {
    char v46 = 48;
  }
  a2[25] = v46 + v45;
  unsigned int v47 = this[11];
  if (v47 >= 0xA0) {
    char v48 = 55;
  }
  else {
    char v48 = 48;
  }
  a2[26] = v48 + (this[11] >> 4);
  unsigned int v49 = v47 & 0xF;
  if (v49 >= 0xA) {
    char v50 = 55;
  }
  else {
    char v50 = 48;
  }
  a2[27] = v50 + v49;
  unsigned int v51 = this[12];
  if (v51 >= 0xA0) {
    char v52 = 55;
  }
  else {
    char v52 = 48;
  }
  a2[28] = v52 + (this[12] >> 4);
  unsigned int v53 = v51 & 0xF;
  if (v53 >= 0xA) {
    char v54 = 55;
  }
  else {
    char v54 = 48;
  }
  a2[29] = v54 + v53;
  unsigned int v55 = this[13];
  if (v55 >= 0xA0) {
    char v56 = 55;
  }
  else {
    char v56 = 48;
  }
  a2[30] = v56 + (this[13] >> 4);
  unsigned int v57 = v55 & 0xF;
  if (v57 >= 0xA) {
    char v58 = 55;
  }
  else {
    char v58 = 48;
  }
  a2[31] = v58 + v57;
  unsigned int v59 = this[14];
  if (v59 >= 0xA0) {
    char v60 = 55;
  }
  else {
    char v60 = 48;
  }
  a2[32] = v60 + (this[14] >> 4);
  unsigned int v61 = v59 & 0xF;
  if (v61 >= 0xA) {
    char v62 = 55;
  }
  else {
    char v62 = 48;
  }
  a2[33] = v62 + v61;
  unsigned int v63 = this[15];
  if (v63 >= 0xA0) {
    char v64 = 55;
  }
  else {
    char v64 = 48;
  }
  a2[34] = v64 + (this[15] >> 4);
  unsigned int v65 = v63 & 0xF;
  if (v65 >= 0xA) {
    char v66 = 55;
  }
  else {
    char v66 = 48;
  }
  *(_WORD *)(a2 + 35) = (v66 + v65);
  return this;
}

unsigned __int8 *dyld4::Loader::getUuidStr(unsigned __int8 *this, char *a2, char *a3)
{
  if ((*((_WORD *)this + 2) & 0x400) != 0) {
    return dyld4::Loader::uuidToStr(this + 8, (unsigned __int8 *)a2, a3);
  }
  *(void *)a2 = 0x64697575206F6ELL;
  return this;
}

void dyld4::Loader::logLoad(dyld4::Loader *this, dyld4::RuntimeState *a2, char *a3)
{
  if ((*((_WORD *)this + 2) & 0x400) != 0) {
    dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)v5, a3);
  }
  else {
    strcpy(v5, "no uuid");
  }
  dyld4::RuntimeState::log(a2, "<%s> %s\n", v5, a3);
}

dyld4::PrebuiltLoader *dyld4::Loader::makeDiskLoader( vm_address_t *a1, dyld4::RuntimeState *this, char *__s2, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  if (*(_BYTE *)(a4 + 5)) {
    return 0LL;
  }
  double result = dyld4::RuntimeState::findPrebuiltLoader(this, __s2);
  if (!result)
  {
    if (a5)
    {
      uint64_t v15 = *((void *)this + 1);
      if (*(_BYTE *)(v15 + 157))
      {
      }
    }

    return (dyld4::PrebuiltLoader *)dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk( a1,  (uint64_t)this,  (dyld3 *)__s2,  a4,  a5,  a6,  a7);
  }

  return result;
}

dyld4::Loader *dyld4::Loader::makeDyldCacheLoader( vm_address_t *a1, dyld4::RuntimeState *this, char *__s2, uint64_t a4, int a5)
{
  if (*(_BYTE *)(a4 + 5)) {
    return 0LL;
  }
  int v8 = a4;
  PrebuiltLoader = dyld4::RuntimeState::findPrebuiltLoader(this, __s2);
  if (PrebuiltLoader)
  {
    unsigned int v5 = PrebuiltLoader;
    unsigned int v13 = (_DWORD *)dyld4::PrebuiltLoader::mf(PrebuiltLoader, this);
    if ((dyld3::MachOFile::loadableIntoProcess( v13,  *(_DWORD *)(*((void *)this + 1) + 68LL),  __s2,  *(unsigned __int8 *)(*((void *)this + 1) + 168LL)) & 1) != 0) {
      return v5;
    }
  }

  return dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache(a1, this, __s2, v8, a5);
}

void dyld4::Loader::forEachPath(int a1, uint64_t a2, dyld4::Utils *__s, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = 0LL;
  char v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  char v20 = 0;
  uint64_t v9 = *(void *)(a2 + 8);
  if (*(_BYTE *)(a4 + 1))
  {
    BOOL v10 = 0;
    uint64_t v11 = *(void *)(a2 + 8);
    char v12 = &v17;
  }

  else if (_platform_strchr((const char *)__s, 47))
  {
    BOOL v10 = dyld4::ProcessConfig::PathOverrides::getFrameworkPartialPath( (dyld4::ProcessConfig::PathOverrides *)(v9 + 400),  __s,  v13) == 0;
    uint64_t v11 = *(void *)(a2 + 8);
    char v12 = v18;
  }

  else
  {
    BOOL v10 = 0;
    char v12 = &v17;
    uint64_t v11 = v9;
  }

  char v14 = (const char *)*(unsigned int *)(v11 + 68);
  int v15 = *(unsigned __int8 *)(a4 + 11);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000LL;
  v16[2] = ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke;
  v16[3] = &unk_18961F7E0;
  v16[6] = a4;
  v16[7] = __s;
  v16[8] = a2;
  v16[4] = a5;
  v16[5] = &v17;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v9 + 400, __s, v14, v15, v10, (_BYTE *)v12 + 24, (uint64_t)v16);
  _Block_object_dispose(&v17, 8);
}

void ___ZN5dyld46Loader11forEachPathER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsEU13block_pointerFvS6_NS_13ProcessConfig13PathOverrides4TypeERbE_block_invoke( uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 48);
  if ((_DWORD)a3 != 9 || *(_BYTE *)(v5 + 1) || (int v6 = **(unsigned __int8 **)(a1 + 56), v6 == 47) || v6 == 64)
  {
    dyld4::Loader::forEachResolvedAtPathVar( *(const dyld4::RuntimeState **)(a1 + 64),  a2,  v5,  a3,  (_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(void *)(a1 + 32));
  }

  else
  {
    strcpy(__dst, "@rpath/");
    strlcat(__dst, a2, 0x400uLL);
    dyld4::Loader::forEachResolvedAtPathVar( *(const dyld4::RuntimeState **)(a1 + 64),  __dst,  *(void *)(a1 + 48),  13LL,  (_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(void *)(a1 + 32));
    if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
    {
      strcpy(v7, "/usr/lib/");
      strlcat(v7, *(const char **)(a1 + 56), 0x400uLL);
      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
      if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
      {
        if (*(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 184LL)) {
          (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
        }
      }
    }
  }

void dyld4::Loader::forEachResolvedAtPathVar( const dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, _BYTE *a5, uint64_t a6)
{
  int v12 = _platform_strncmp(__s1, "@rpath/", 7uLL);
  if (v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = *(_BYTE *)(a3 + 6) == 0;
  }
  if (v13)
  {
    int v14 = v12;
    if (dyld4::Loader::expandAtLoaderPath( a1,  __s1,  a3,  *(dyld4::Loader **)(*(void *)(a3 + 16) + 8LL),  0,  v22))
    {
      (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, v22, 11LL, a5);
    }

    else if (dyld4::Loader::expandAtExecutablePath(a1, __s1, v15, 0LL, v22))
    {
      (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, v22, 12LL, a5);
    }

    else
    {
      if (v14) {
        goto LABEL_19;
      }
      if ((_DWORD)a4 == 13) {
        int v16 = 13;
      }
      else {
        int v16 = 10;
      }
      uint64_t v17 = *(uint64_t ***)(a3 + 16);
      for (BOOL i = *a5 == 0; v17 && !*a5; BOOL i = *a5 == 0)
      {
        uint64_t v19 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v17[1], a1);
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000LL;
        void v20[2] = ___ZN5dyld46Loader24forEachResolvedAtPathVarERNS_12RuntimeStateEPKcRKNS0_11LoadOptionsENS_13ProcessConfig13PathOverrides4TypeERbU13block_pointerFvS4_SA_SB_E_block_invoke;
        v20[3] = &unk_18961F858;
        v20[6] = v17;
        void v20[7] = a3;
        v20[8] = v22;
        void v20[9] = __s1 + 6;
        v20[4] = a6;
        v20[5] = a1;
        int v21 = v16;
        v20[10] = a5;
        dyld3::MachOFile::forEachRPath(v19, (uint64_t)v20);
        uint64_t v17 = (uint64_t **)*v17;
      }

      if (i)
      {
LABEL_19:
        if (*__s1 != 64) {
          (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, __s1, a4, a5);
        }
      }
    }
  }

  else
  {
    (*(void (**)(uint64_t, char *, uint64_t, _BYTE *))(a6 + 16))(a6, __s1, a4, a5);
  }

dyld4::Loader *dyld4::Loader::getLoader( vm_address_t **a1, DyldSharedCache ***a2, const char *a3, uint64_t a4)
{
  uint64_t v5 = (char *)a3;
  uint64_t v69 = 0LL;
  uint64_t v70 = &v69;
  uint64_t v71 = 0x2000000000LL;
  uint64_t v72 = 0LL;
  int v8 = a2[1];
  if (v8[30]) {
    LODWORD(v9) = *((_BYTE *)v8 + 396) == 0;
  }
  else {
    LODWORD(v9) = 0;
  }
  if (*((_BYTE *)v8 + 208)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "find path %s\n", a3);
  }
  int v10 = _platform_strncmp(v5, "@rpath/", 7uLL);
  int v11 = *v5;
  if (v11 == 47)
  {
    BOOL v13 = 0;
    if (!v10) {
      goto LABEL_38;
    }
  }

  else if (v11 == 46 && ((int v12 = v5[1], v12 == 47) || v12 == 46 && v5[2] == 47))
  {
    BOOL v13 = 1;
    if (!v10)
    {
LABEL_38:
      BOOL v61 = v13;
      LODWORD(v60) = (_DWORD)v9;
      uint64_t v9 = a1;
      uint64_t v28 = 0LL;
      uint64_t v73 = a2 + 4;
      uint64_t v74 = (DyldSharedCache ****)(a2 + 8);
      while (1)
      {
        unsigned int v29 = (&v73)[v28];
        char v30 = v29[2];
        if (v30) {
          break;
        }
LABEL_43:
        if (++v28 == 2)
        {
          a1 = v9;
          LOBYTE(v9) = (_BYTE)v60;
          goto LABEL_45;
        }
      }

      unsigned int v31 = v29[1];
      uint64_t v32 = 8LL * (void)v30;
      while (1)
      {
        unsigned int v33 = *v31;
        if (dyld4::Loader::matchesPath(*v31, (const dyld4::RuntimeState *)a2, v5)) {
          break;
        }
        ++v31;
        v32 -= 8LL;
        if (!v32) {
          goto LABEL_43;
        }
      }

      if (*((_BYTE *)a2[1] + 208))
      {
        char v34 = (const char *)dyld4::Loader::path(v33, (const dyld4::RuntimeState *)a2);
        dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v34);
      }

      goto LABEL_89;
    }
  }

  else
  {
    BOOL v13 = v11 != 64;
    if (!v10) {
      goto LABEL_38;
    }
  }

  if (*(_BYTE *)(a4 + 1) || v11 == 47 || v11 == 64 || _platform_strchr(v5, 47))
  {
LABEL_15:
    int v14 = dyld4::ProcessConfig::canonicalDylibPathInCache(a2[1], v5);
    if (v14)
    {
      uint64_t v15 = (const char *)v14;
      if (_platform_strcmp((const char *)v14, v5))
      {
        if (*((_BYTE *)a2[1] + 208)) {
          dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to canonical cache path: %s\n", v15);
        }
        uint64_t v5 = (char *)v15;
      }
    }

    v67[0] = 0LL;
    v67[1] = v67;
    v67[2] = 0x2000000000LL;
    int isOverridablePath = dyld4::ProcessConfig::DyldCache::indexOfPath(a2[1] + 30, v5, &v68);
    char v17 = isOverridablePath;
    if (isOverridablePath) {
      int isOverridablePath = dyld4::ProcessConfig::DyldCache::isOverridablePath( (dyld4::ProcessConfig::DyldCache *)(a2[1] + 30),  v5);
    }
    v63[0] = _NSConcreteStackBlock;
    v63[1] = 0x40000000LL;
    v63[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke;
    v63[3] = &unk_18961F808;
    char v64 = (char)v9;
    char v65 = v17;
    char v66 = isOverridablePath;
    void v63[6] = v5;
    v63[7] = a2;
    v63[8] = a4;
    v63[9] = a1;
    v63[4] = &v69;
    v63[5] = v67;
    dyld4::Loader::forEachPath(isOverridablePath, (uint64_t)a2, (dyld4::Utils *)v5, a4, (uint64_t)v63);
    if (!v70[3])
    {
      char v18 = (dyld4::SyscallDelegate *)a2[1];
      char v19 = !v13;
      if (*((_BYTE *)v18 + 186)) {
        char v19 = 1;
      }
      if ((v19 & 1) != 0)
      {
        if ((*(_BYTE *)(a4 + 1) || _platform_strchr(v5, 47))
          && *v5 != 64
          && dyld4::SyscallDelegate::realpath(v18, (dyld3 *)v5, (char *)&v73))
        {
          size_t v51 = _platform_strlen((const char *)&v73);
          if (_platform_strncmp(v5, (const char *)&v73, v51))
          {
            if (*((_BYTE *)a2[1] + 208)) {
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  switch to realpath: %s\n", (const char *)&v73);
            }
            uint64_t Loader = dyld4::Loader::getLoader(a1, a2, &v73, a4);
            v70[3] = Loader;
          }
        }
      }

      else
      {
        char v20 = a1;
        uint64_t v21 = 0LL;
        uint64_t v73 = a2 + 4;
        uint64_t v74 = (DyldSharedCache ****)(a2 + 8);
        do
        {
          char v22 = (&v73)[v21];
          unsigned int v23 = v22[2];
          if (v23)
          {
            char v24 = v22[1];
            uint64_t v25 = 8LL * (void)v23;
            while (1)
            {
              char v26 = *v24;
              if (dyld4::Loader::matchesPath(*v24, (const dyld4::RuntimeState *)a2, v5)) {
                break;
              }
              ++v24;
              v25 -= 8LL;
              if (!v25) {
                goto LABEL_35;
              }
            }

            if (*((_BYTE *)a2[1] + 208))
            {
              unsigned int v27 = (const char *)dyld4::Loader::path(v26, (const dyld4::RuntimeState *)a2);
              dyld4::RuntimeState::log( (dyld4::RuntimeState *)a2,  "  found existing image by install name: %s\n",  v27);
            }

            v70[3] = (uint64_t)v26;
            Diagnostics::clearError(v20);
          }

LABEL_35:
          ++v21;
        }

        while (v21 != 2);
        a1 = v20;
      }
    }

    unsigned int v53 = v70;
    if (*((_BYTE *)a2[1] + 208) && !v70[3])
    {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  not found: %s\n", v5);
      unsigned int v53 = v70;
    }

    if (!v53[3])
    {
      if (*v5 != 64
        || *((_BYTE *)a2[1] + 184)
        || (Diagnostics::appendError((vm_address_t *)a1, ", (security policy does not allow @ path expansion)"), !v70[3]))
      {
        if (*(unsigned __int8 *)(a4 + 2) | *(unsigned __int8 *)(a4 + 5))
        {
          Diagnostics::clearError(a1);
        }

        else if (Diagnostics::noError((Diagnostics *)a1) && !_platform_strncmp(v5, "@rpath/", 7uLL))
        {
          uint64_t v73 = 0LL;
          uint64_t v74 = &v73;
          uint64_t v75 = 0x2000000000LL;
          char v76 = 0;
          char v54 = *(uint64_t ***)(a4 + 16);
          if (v54)
          {
            while (!*((_BYTE *)v74 + 24))
            {
              unsigned int v55 = (_DWORD *)dyld4::Loader::mf((dyld4::Loader *)v54[1], (const dyld4::RuntimeState *)a2);
              v62[0] = _NSConcreteStackBlock;
              v62[1] = 0x40000000LL;
              v62[2] = ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2;
              void v62[3] = &unk_18961F830;
              v62[4] = &v73;
              dyld3::MachOFile::forEachRPath(v55, (uint64_t)v62);
              char v54 = (uint64_t **)*v54;
              if (!v54)
              {
                if (!*((_BYTE *)v74 + 24)) {
                  goto LABEL_86;
                }
                break;
              }
            }

            Diagnostics::error( (vm_address_t *)a1,  "no LC_RPATH's used.  They may be invalid, eg, not start with '@loader_path' or '@executable_path'");
          }

          else
          {
LABEL_86:
            Diagnostics::error((vm_address_t *)a1, "no LC_RPATH's found");
          }

          _Block_object_dispose(&v73, 8);
        }
      }
    }

    unsigned int v33 = (dyld4::Loader *)v70[3];
    _Block_object_dispose(v67, 8);
  }

  else
  {
    BOOL v61 = v13;
    unsigned int v59 = a1;
    size_t v35 = _platform_strlen(v5);
    char v60 = &v58;
    size_t v36 = v35 + 8;
    __chkstk_darwin(v35, v37, v38, v39, v40, v41, v42, v43, v58);
    unsigned int v45 = (char *)&v58 - ((v44 + 23) & 0xFFFFFFFFFFFFFFF0LL);
    strlcpy(v45, "@rpath/", v36);
    strlcat(v45, v5, v36);
    uint64_t v46 = 0LL;
    uint64_t v73 = a2 + 4;
    uint64_t v74 = (DyldSharedCache ****)(a2 + 8);
    while (1)
    {
      unsigned int v47 = (&v73)[v46];
      char v48 = v47[2];
      if (v48) {
        break;
      }
LABEL_56:
      if (++v46 == 2)
      {
        a1 = v59;
LABEL_45:
        LOBYTE(v13) = v61;
        goto LABEL_15;
      }
    }

    unsigned int v49 = v47[1];
    uint64_t v50 = 8LL * (void)v48;
    while (1)
    {
      unsigned int v33 = *v49;
      if (dyld4::Loader::matchesPath(*v49, (const dyld4::RuntimeState *)a2, v45)) {
        break;
      }
      ++v49;
      v50 -= 8LL;
      if (!v50) {
        goto LABEL_56;
      }
    }

    if (*((_BYTE *)a2[1] + 208))
    {
      char v56 = (const char *)dyld4::Loader::path(v33, (const dyld4::RuntimeState *)a2);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "  found: already-loaded-by-rpath: %s\n", v56);
    }
  }

      if ((v26 - 48) <= 9)
      {
        do
        {
          unsigned int v27 = 10 * v24 + v26;
          uint64_t v28 = *(unsigned __int8 *)++v17;
          LOBYTE(v26) = v28;
          char v24 = v27 - 48;
        }

        while ((v28 - 48) < 0xA);
      }

LABEL_89:
  _Block_object_dispose(&v69, 8);
  return v33;
}

void ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke( uint64_t a1, char *a2, unsigned int a3, _BYTE *a4)
{
  int v8 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((void *)v8 + 1) + 208LL))
  {
    uint64_t v9 = dyld4::ProcessConfig::PathOverrides::typeName(a3);
    dyld4::RuntimeState::log(v8, "  possible path(%s): %s\n", v9, a2);
    int v8 = *(dyld4::RuntimeState **)(a1 + 56);
  }

  uint64_t v10 = 0LL;
  *(void *)&__int128 v78 = (char *)v8 + 32;
  *((void *)&v78 + 1) = (char *)v8 + 64;
  while (1)
  {
    uint64_t v11 = *((void *)&v78 + v10);
    if (!*(_BYTE *)(*(void *)(a1 + 64) + 5LL) || v11 != *(void *)(a1 + 56) + 64LL)
    {
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12) {
        break;
      }
    }

LABEL_101:
          Diagnostics::Diagnostics((Diagnostics *)&v72);
          char v56 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(_BYTE *)(*((void *)v56 + 1) + 208LL))
          {
            dyld4::RuntimeState::log( v56,  "  found: dylib-from-cache: (0x%04X) %s\n",  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  a2);
            char v56 = *(dyld4::RuntimeState **)(a1 + 56);
          }

          *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dyld4::Loader::makeDyldCacheLoader( (vm_address_t *)&v72,  v56,  a2,  *(void *)(a1 + 64),  *(_DWORD *)(*(void *)(*(void *)(a1 + 40)
                                                                                                + 8LL)
                                                                                    + 24LL));
          if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 208LL) && Diagnostics::hasError((Diagnostics *)&v72))
          {
            unsigned int v53 = "  found: dylib-from-cache-error: %s => %s\n";
            goto LABEL_131;
          }

          goto LABEL_132;
        }

        if (dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8LL), a2, &v78, &v75))
        {
          BOOL v36 = *(_BYTE *)(a1 + 82) != 0;
          goto LABEL_76;
        }
      }

      else
      {
        int v42 = dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(a1 + 56) + 8LL), a2, &v78, &v75);
        unsigned __int8 v43 = 0;
        if (a3 != 3 && a3 != 8) {
          unsigned __int8 v43 = dyld4::ProcessConfig::DyldCache::indexOfPath( (DyldSharedCache **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 240LL),  a2,  (unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
        }
        if (v42)
        {
          if (*(_BYTE *)(a1 + 81)) {
            BOOL v36 = 1;
          }
          else {
            BOOL v36 = v43;
          }
LABEL_76:
          if (BYTE8(v79))
          {
LABEL_77:
            uint64_t v44 = 0LL;
            uint64_t v45 = *(void *)(a1 + 56);
            v77[0] = v45 + 32;
            v77[1] = v45 + 64;
            while (1)
            {
              uint64_t v46 = v77[v44];
              if (!*(_BYTE *)(*(void *)(a1 + 64) + 5LL) || v46 != *(void *)(a1 + 56) + 64LL)
              {
                uint64_t v47 = *(void *)(v46 + 16);
                if (v47) {
                  break;
                }
              }

LABEL_90:
              if (++v44 == 2) {
                goto LABEL_91;
              }
            }

            char v48 = *(dyld4::Loader ***)(v46 + 8);
            uint64_t v49 = 8 * v47;
            while (1)
            {
              uint64_t v50 = *v48;
              dyld4::Loader::fileID(*v48, &v72);
              if (v74)
              {
                BOOL v51 = *((void *)&v78 + 1) != v72.i64[1] || BYTE8(v79) == 0;
                if (!v51 && (void)v78 == v72.i64[0] && (void)v79 == v73) {
                  break;
                }
              }

              ++v48;
              v49 -= 8LL;
              if (!v49) {
                goto LABEL_90;
              }
            }

            *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v50;
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
            unsigned int v55 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((void *)v55 + 1) + 208LL))
            {
              dyld4::Loader::path(v50, *(const dyld4::RuntimeState **)(a1 + 56));
              dyld4::RuntimeState::log(v55, "  found: already-loaded-by-inode-mtime: %s\n");
            }

            return;
          }

LABEL_91:
          Diagnostics::Diagnostics((Diagnostics *)&v72);
          if (v36)
          {
LABEL_92:
            char v52 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((void *)v52 + 1) + 208LL))
            {
              dyld4::RuntimeState::log(v52, "  found: dylib-from-disk-to-override-cache: %s\n", a2);
              char v52 = *(dyld4::RuntimeState **)(a1 + 56);
            }

            *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dyld4::Loader::makeDiskLoader( (vm_address_t *)&v72,  v52,  a2,  *(void *)(a1 + 64),  1,  *(_DWORD *)(*(void *)(*(void *)(a1 + 40)
                                                                                                  + 8LL)
                                                                                      + 24LL),
                                                                            0LL);
            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 208LL)
              && Diagnostics::hasError((Diagnostics *)&v72))
            {
              unsigned int v53 = "  found: dylib-from-disk-to-override-cache-error: %s => %s\n";
              goto LABEL_131;
            }
          }

          else
          {
            char v62 = *(dyld4::RuntimeState **)(a1 + 56);
            if (*(_BYTE *)(*((void *)v62 + 1) + 208LL))
            {
              dyld4::RuntimeState::log(v62, "  found: dylib-from-disk: %s\n", a2);
              char v62 = *(dyld4::RuntimeState **)(a1 + 56);
            }

            *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dyld4::Loader::makeDiskLoader( (vm_address_t *)&v72,  v62,  a2,  *(void *)(a1 + 64),  0,  0,  0LL);
            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 208LL)
              && Diagnostics::hasError((Diagnostics *)&v72))
            {
              unsigned int v53 = "  found: dylib-from-disk-error: %s => %s\n";
LABEL_131:
              unsigned int v63 = *(dyld4::RuntimeState **)(a1 + 56);
              char v64 = Diagnostics::errorMessage((Diagnostics *)&v72);
              dyld4::RuntimeState::log(v63, v53, a2, v64);
            }
          }

LABEL_132:
          if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
          {
            *a4 = 1;
            Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
          }

          else
          {
            BOOL v65 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
            char v66 = *(vm_address_t **)(a1 + 72);
            uint64_t v67 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v72);
            if (v65) {
              Diagnostics::error(v66, "tried: '%s' (%s)", a2, v67);
            }
            else {
              Diagnostics::appendError(v66, ", '%s' (%s)", a2, v67);
            }
          }

          char v54 = (vm_address_t **)&v72;
LABEL_141:
          mach_o::Error::~Error(v54);
          return;
        }

        if ((v43 & 1) != 0) {
          goto LABEL_101;
        }
      }

      uint64_t v57 = *(void *)(*(void *)(a1 + 64) + 32LL);
      if (v57 && a3 != 3 && a3 != 8) {
        (*(void (**)(uint64_t, char *))(v57 + 16))(v57, a2);
      }
      BOOL v58 = Diagnostics::noError(*(Diagnostics **)(a1 + 72));
      unsigned int v59 = *(vm_address_t **)(a1 + 72);
      if (v58) {
        Diagnostics::error(v59, "tried: ");
      }
      else {
        Diagnostics::appendError(v59, ", ");
      }
      char v60 = (const char *)&unk_1800BA999;
      if (a3 != 3
        && a3 != 8
        && (!_platform_strncmp(a2, "/usr/lib/", 9uLL)
         || !_platform_strncmp(a2, "/System/Library/", 0x10uLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/usr/lib/", 0x1BuLL)
         || !_platform_strncmp(a2, "/System/iOSSupport/System/Library/", 0x22uLL)
         || !_platform_strncmp(a2, "/System/DriverKit/", 0x12uLL)))
      {
        if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 240LL)) {
          char v60 = ", not in dyld cache";
        }
        else {
          char v60 = ", no dyld cache";
        }
      }

      int v61 = v75;
      if (v75 == 1)
      {
        if (dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(*(void *)(a1 + 56) + 8LL), a2))
        {
          Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (blocked by sandbox)%s", a2, v60);
          unsigned int v68 = *(dyld4::RuntimeState **)(a1 + 56);
          if (*(_BYTE *)(*((void *)v68 + 1) + 208LL)) {
            dyld4::RuntimeState::log(v68, "    stat(%s) blocked by file system sandbox\n");
          }
          return;
        }

        int v61 = v75;
      }

      else if (v75 == 2)
      {
        Diagnostics::appendError(*(vm_address_t **)(a1 + 72), "'%s' (no such file%s)");
        return;
      }

      uint64_t v69 = *(vm_address_t **)(a1 + 72);
      if (v61 == 666)
      {
        Diagnostics::appendError(v69, "'%s' (not a file%s)", a2, v60);
        uint64_t v70 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((void *)v70 + 1) + 208LL)) {
          dyld4::RuntimeState::log(v70, "    stat(%s) returned path is not a regular file\n");
        }
      }

      else
      {
        Diagnostics::appendError(v69, "'%s' (errno=%d%s)", a2, v61, v60);
        uint64_t v71 = *(dyld4::RuntimeState **)(a1 + 56);
        if (*(_BYTE *)(*((void *)v71 + 1) + 208LL)) {
          dyld4::RuntimeState::log(v71, "    stat(%s) returned: errno=%d\n");
        }
      }

      return;
    }
  }

  BOOL v13 = *(dyld4::Loader ***)(v11 + 8);
  uint64_t v14 = 8 * v12;
  while (1)
  {
    uint64_t v15 = *v13;
    if (dyld4::Loader::matchesPath(*v13, *(const dyld4::RuntimeState **)(a1 + 56), a2)) {
      break;
    }
    ++v13;
    v14 -= 8LL;
    if (!v14) {
      goto LABEL_13;
    }
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v15;
  *a4 = 1;
  Diagnostics::clearError(*(vm_address_t ***)(a1 + 72));
  uint64_t v37 = *(dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((void *)v37 + 1) + 208LL)) {
    dyld4::RuntimeState::log(v37, "  found: already-loaded-by-path: %s\n");
  }
}

uint64_t ___ZN5dyld46Loader9getLoaderER11DiagnosticsRNS_12RuntimeStateEPKcRKNS0_11LoadOptionsE_block_invoke_2( uint64_t result, uint64_t a2, _BYTE *a3)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  *a3 = 1;
  return result;
}

uint64_t dyld4::Loader::expandAtLoaderPath( dyld4::RuntimeState *a1, char *__s1, uint64_t a3, dyld4::Loader *a4, int a5, char *a6)
{
  if (_platform_strncmp(__s1, "@loader_path", 0xCuLL)) {
    return 0LL;
  }
  int v15 = __s1[12];
  uint64_t v14 = __s1 + 12;
  int v13 = v15;
  if (v15 != 47 && v13 != 0) {
    return 0LL;
  }
  uint64_t v17 = *((void *)a1 + 1);
  if (*(_BYTE *)(a3 + 6))
  {
    if (*(_BYTE *)(v17 + 208)) {
      dyld4::RuntimeState::log(a1, "    @loader_path not allowed in DYLD_INSERT_LIBRARIES\n");
    }
    return 0LL;
  }

  if (*(_BYTE *)(v17 + 184)) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = a5 == 0;
  }
  if (!v18 && *((void *)a1 + 3) == (void)a4)
  {
    if (*(_BYTE *)(v17 + 208)) {
      dyld4::RuntimeState::log( a1,  "    @loader_path in LC_RPATH from main executable not expanded due to security policy\n");
    }
    return 0LL;
  }

  uint64_t v20 = (const char *)dyld4::Loader::path(a4, a1);
  strlcpy(a6, v20, 0x400uLL);
  uint64_t result = (uint64_t)strrchr(a6, 47);
  if (result)
  {
    strlcpy((char *)result, v14, (size_t)&a6[-result + 1024]);
    return 1LL;
  }

  return result;
}

char *dyld4::Loader::expandAndNormalizeAtExecutablePath( dyld4::Loader *this, const char *__s1, char *a3, char *a4)
{
  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL)) {
    return 0LL;
  }
  int v10 = *((unsigned __int8 *)__s1 + 16);
  uint64_t v9 = __s1 + 16;
  int v8 = v10;
  if (v10 != 47 && v8 != 0) {
    return 0LL;
  }
  strlcpy(a3, (const char *)this, 0x400uLL);
  uint64_t result = strrchr(a3, 47);
  if (result)
  {
    if (*v9 == 47)
    {
      do
      {
        uint64_t v12 = v9;
        int v13 = result;
        if (_platform_strncmp(v9, "/..", 3uLL)) {
          break;
        }
        uint64_t v14 = v13 - 1;
        do
        {
          uint64_t result = v14;
          if (v14 <= a3) {
            break;
          }
          --v14;
        }

        while (*result != 47);
        v9 += 3;
      }

      while (result != a3);
    }

    else
    {
      int v13 = result + 1;
      uint64_t v12 = v9;
    }

    strlcpy(v13, v12, a3 - v13 + 1024);
    return (char *)1;
  }

  return result;
}

char *dyld4::Loader::expandAtExecutablePath( dyld4::RuntimeState *a1, char *__s1, uint64_t a3, uint64_t a4, char *a5)
{
  if (_platform_strncmp(__s1, "@executable_path", 0x10uLL)) {
    return 0LL;
  }
  int v10 = __s1[16];
  if (v10 != 47 && v10 != 0) {
    return 0LL;
  }
  uint64_t v12 = *((void *)a1 + 1);
  if (!*(_BYTE *)(v12 + 184))
  {
    if (*(_BYTE *)(v12 + 208)) {
      dyld4::RuntimeState::log(a1, "    @executable_path not expanded due to security policy\n");
    }
    return 0LL;
  }

  return dyld4::Loader::expandAndNormalizeAtExecutablePath(*(dyld4::Loader **)(v12 + 16), __s1, a5, v8);
}

char *___ZN5dyld46Loader24forEachResolvedAtPathVarERNS_12RuntimeStateEPKcRKNS0_11LoadOptionsENS_13ProcessConfig13PathOverrides4TypeERbU13block_pointerFvS4_SA_SB_E_block_invoke( uint64_t a1, char *__s1, _BYTE *a3)
{
  int v6 = *(const dyld4::RuntimeState **)(a1 + 40);
  if (*(_BYTE *)(*((void *)v6 + 1) + 208LL))
  {
    unsigned int v7 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(*(void *)(a1 + 48) + 8LL), v6);
    dyld4::RuntimeState::log(v6, "  LC_RPATH '%s' from '%s'\n", __s1, v7);
    int v6 = *(const dyld4::RuntimeState **)(a1 + 40);
  }

  if ((dyld4::Loader::expandAtLoaderPath( v6,  __s1,  *(void *)(a1 + 56),  *(dyld4::Loader **)(*(void *)(a1 + 48) + 8LL),  1,  *(char **)(a1 + 64)) & 1) != 0) {
    goto LABEL_5;
  }
  uint64_t result = dyld4::Loader::expandAtExecutablePath(*(dyld4::RuntimeState **)(a1 + 40), __s1, v8, 0LL, *(char **)(a1 + 64));
  if ((_DWORD)result) {
    goto LABEL_5;
  }
  if (*__s1 != 47)
  {
LABEL_6:
    if (!*a3) {
      return result;
    }
    goto LABEL_7;
  }

  strlcpy(*(char **)(a1 + 64), __s1, 0x400uLL);
  dyld4::Utils::concatenatePaths(*(dyld4::Utils **)(a1 + 64), *(char **)(a1 + 72), (const char *)0x400);
  uint64_t result = (char *)(*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (*a3)
  {
LABEL_7:
    **(_BYTE **)(a1 + 80) = 1;
    return result;
  }

  int v10 = *(const char **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 520LL);
  if (v10)
  {
    strlcpy(*(char **)(a1 + 64), v10, 0x400uLL);
    strlcat(*(char **)(a1 + 64), __s1, 0x400uLL);
LABEL_5:
    dyld4::Utils::concatenatePaths(*(dyld4::Utils **)(a1 + 64), *(char **)(a1 + 72), (const char *)0x400);
    uint64_t result = (char *)(*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
    goto LABEL_6;
  }

  return result;
}

size_t dyld4::Loader::validateFile( vm_address_t *a1, uint64_t a2, int a3, const char *a4, unsigned int *a5, uint64_t a6)
{
  if (dyld4::SyscallDelegate::fstat(*(dyld4::SyscallDelegate **)(a2 + 8), a3, &v27))
  {
    int v12 = *__error();
    if (v12 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }

    else if (v12 == 1 && dyld4::SyscallDelegate::sandboxBlockedStat(*(dyld4::SyscallDelegate **)(a2 + 8), a4))
    {
      Diagnostics::error(a1, "file system sandbox blocked stat(%s)");
    }

    else
    {
      Diagnostics::error(a1, "stat(%s) failed with errno=%d");
    }

    return -1LL;
  }

  if (*(_BYTE *)(a6 + 52))
  {
    if (v27.st_ino != *(void *)(a6 + 16))
    {
      Diagnostics::error(a1, "file inode changed from 0x%llX to 0x%llX since Loader was built for '%s'");
      return -1LL;
    }

    if (v27.st_mtimespec.tv_sec != *(void *)(a6 + 24))
    {
      Diagnostics::error(a1, "file mtime changed from 0x%llX to 0x%lX since Loader was built for '%s'");
      return -1LL;
    }

    size_t v13 = *(void *)a6;
    if (v27.st_size < *(void *)a6)
    {
      Diagnostics::error(a1, "file too small for slice offset '%s'");
      return -1LL;
    }
  }

  else
  {
    if (!a5[1]) {
      return -1LL;
    }
    uint64_t v14 = (dyld3::FatFile *)dyld4::SyscallDelegate::mmap( *(dyld4::SyscallDelegate **)(a2 + 8),  0LL,  v27.st_size,  1,  2,  a3,  0LL);
    if (v14 == (dyld3::FatFile *)-1LL)
    {
      Diagnostics::error(a1, "could not mmap() '%s'");
      return -1LL;
    }

    int v15 = v14;
    unint64_t v26 = 0LL;
    uint64_t v16 = dyld3::MachOFile::compatibleSlice( a1,  &v26,  v14,  v27.st_size,  a4,  *(_DWORD *)(*(void *)(a2 + 8) + 68LL),  0,  *(dyld3::GradedArchs **)(*(void *)(a2 + 8) + 144LL),  *(_BYTE *)(*(void *)(a2 + 8) + 169LL));
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v22 = 0LL;
      unsigned int v23 = &v22;
      uint64_t v24 = 0x2000000000LL;
      char v25 = 0;
      unint64_t v18 = a5[1];
      uint64_t v19 = (int *)((char *)v16 + *a5);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000LL;
      void v21[2] = ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke;
      void v21[3] = &unk_18961F880;
      v21[4] = &v22;
      uint64_t v21[5] = a6;
      dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)v16, v19, v18, (uint64_t)v21);
      if (*((_BYTE *)v23 + 24))
      {
        size_t v13 = (char *)v17 - (char *)v15;
      }

      else
      {
        Diagnostics::error(a1, "file cdHash not as expected '%s'", a4);
        size_t v13 = -1LL;
      }

      _Block_object_dispose(&v22, 8);
    }

    else
    {
      size_t v13 = -1LL;
    }

    dyld4::SyscallDelegate::unmapFile(*(dyld4::SyscallDelegate **)(a2 + 8), v15, *(void *)a6);
  }

  return v13;
}

uint64_t ___ZN5dyld46Loader12validateFileER11DiagnosticsRKNS_12RuntimeStateEiPKcRKNS0_19CodeSignatureInFileERKNS0_18FileValidationInfoE_block_invoke( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 40);
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t v4 = *(void *)(v2 + 40);
  uint64_t v5 = *(unsigned int *)(v2 + 48);
  if (*(void *)a2 == v3 && *(void *)(a2 + 8) == v4 && *(_DWORD *)(a2 + 16) == v5) {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

vm_address_t dyld4::Loader::mapSegments( vm_address_t *a1, dyld4::SyscallDelegate **a2, dyld3 *a3, uint64_t a4, unsigned int *a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10)
{
  int v11 = a6;
  vm_size_t v13 = a4;
  int v60 = 520552456;
  uint64_t v61 = 0LL;
  char v62 = a3;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  uint64_t v68 = 0LL;
  dyld3::ScopedTimer::startTimer( (dyld3::ScopedTimer *)&v60,  (uint64_t)a2,  (uint64_t)a3,  a4,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8);
  uint64_t v17 = dyld4::SyscallDelegate::open(a2[1], a3, 0LL, 0LL);
  if ((_DWORD)v17 == -1)
  {
    int v30 = *__error();
    if (v30 == 2)
    {
      Diagnostics::error(a1, "no such file");
    }

    else if (v30 == 1 && dyld4::SyscallDelegate::sandboxBlockedOpen(a2[1], (const char *)a3))
    {
      Diagnostics::error(a1, "file system sandbox blocked open(%s, O_RDONLY)");
    }

    else
    {
      Diagnostics::error(a1, "open(%s, O_RDONLY) failed with errno=%d");
    }

    goto LABEL_23;
  }

  unint64_t v18 = (dyld4::RuntimeState *)v17;
  off_t v19 = dyld4::Loader::validateFile(a1, (uint64_t)a2, v17, (const char *)a3, a5, a10);
  if (Diagnostics::hasError((Diagnostics *)a1)) {
    goto LABEL_22;
  }
  if (v11 && a5[1])
  {
    LODWORD(address) = 520552464;
    __int128 v70 = 0u;
    __int128 v71 = 0u;
    __int128 v72 = 0u;
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v75 = 0u;
    uint64_t v76 = 0LL;
    dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&address, v20, v21, v22, v23, v24, v25, v26);
    uint64_t v27 = *a5;
    uint64_t v28 = (vm_address_t *)a5[1];
    *(void *)__int128 v78 = v19;
    uint64_t v79 = v27;
    p_vm_address_t address = v28;
    if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 97, v78) == -1)
    {
      int v31 = *__error();
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v32);
      if (v31 == 85 || v31 == 1) {
        Diagnostics::error( a1,  "code signature invalid in <%s> '%s' (errno=%d) sliceOffset=0x%08llX, codeBlobOffset=0x%08X, codeBlobSize=0x%08X");
      }
      else {
        Diagnostics::error( a1,  "fcntl(fd, F_ADDFILESIGS_RETURN) failed with errno=%d in <%s> '%s', sliceOffset=0x%08llX, codeBlobOffset=0x%08X , codeBlobSize=0x%08X");
      }
      goto LABEL_63;
    }

    if (*(void *)v78 < (unint64_t)*a5)
    {
      dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v29);
      Diagnostics::error( a1,  "code signature does not cover entire file up to signature in <%s> '%s' (signed 0x%08llX, expected 0x%08X) for '%s'");
LABEL_63:
      dyld4::SyscallDelegate::close(a2[1], (int)v18);
      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&address);
      goto LABEL_23;
    }

    dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&address);
  }

  LOBYTE(address) = 0;
  *(void *)__int128 v78 = v19;
  uint64_t v79 = 512LL;
  p_vm_address_t address = &address;
  if (dyld4::SyscallDelegate::fcntl(a2[1], (int)v18, 98, v78) == -1)
  {
    dyld4::getUuidFromFd(a2, v18, v19, (unsigned __int8 *)v77, v33);
    Diagnostics::error(a1, "code signature in <%s> '%s' not valid for use in process: %s");
    goto LABEL_22;
  }

  vm_address_t address = 0LL;
  if (vm_allocate(mach_task_self_, &address, v13, 1))
  {
    Diagnostics::error(a1, "vm_allocate(size=0x%0llX) failed with result=%d");
    goto LABEL_22;
  }

  if (*((_BYTE *)a2[1] + 201))
  {
    if (v19) {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s (slice offset=0x%llX)\n");
    }
    else {
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "Mapping %s\n");
    }
  }

  uint64_t v36 = a7[2];
  if (!v36)
  {
LABEL_57:
    vm_address_t v54 = address;
    if (dyld3::MachOFile::isFairPlayEncrypted((dyld3::MachOFile *)address, v77, v78)
      && dyld4::SyscallDelegate::mremap_encrypted( a2[1],  (void *)(address + v77[0]),  (void *)v78[0],  (void *)1,  (void *)*(unsigned int *)(v54 + 4),  (void *)*(unsigned int *)(v54 + 8),  v55,  v56))
    {
      Diagnostics::error(a1, "could not register fairplay decryption, mremap_encrypted() => %d");
      goto LABEL_60;
    }

    dyld4::SyscallDelegate::close(a2[1], (int)v18);
    vm_address_t v34 = address;
    goto LABEL_24;
  }

  int v37 = 0;
  int v59 = *((unsigned __int8 *)a2[1] + 159);
  uint64_t v38 = (unsigned int *)(*a7 + 12LL);
  uint64_t v39 = 16 * v36;
  off_t v58 = v19;
  while (1)
  {
    uint64_t v40 = *(void *)(v38 - 3);
    if ((v40 & 0x4000000000000000LL) != 0) {
      goto LABEL_56;
    }
    size_t v41 = *v38;
    if (!(_DWORD)v41) {
      goto LABEL_56;
    }
    if ((v40 & 0x7FFFFFFFFFFFFFFLL) == 0 && v37 != 0) {
      goto LABEL_56;
    }
    BOOL v43 = v40 > -1 || v59 == 0;
    int v44 = v43 ? 18 : 524306;
    uint64_t v45 = (dyld3::MachOFile *)dyld4::SyscallDelegate::mmap( a2[1],  (void *)(address + (v40 & 0x7FFFFFFFFFFFFFFLL)),  v41,  ((unint64_t)v40 >> 59) & 7,  v44,  (int)v18,  v19 + *(v38 - 1));
    uint64_t v46 = __error();
    if (v45 == (dyld3::MachOFile *)-1LL) {
      break;
    }
    if (!v37 && !dyld3::MachOFile::isMachO(v45, a1, *v38)) {
      goto LABEL_60;
    }
    if (*((_BYTE *)a2[1] + 201))
    {
      vm_size_t v47 = v13;
      vm_size_t v48 = (vm_size_t)v45 + ((vm_page_size + *v38 - 1) & -(uint64_t)vm_page_size);
      uint64_t v49 = (const char *)dyld3::MachOLoaded::segmentName((dyld3::MachOLoaded *)address, v37);
      uint64_t v50 = *(void *)(v38 - 3) >> 59;
      vm_size_t v57 = v48;
      vm_size_t v13 = v47;
      off_t v19 = v58;
      uint64_t v51 = 120LL;
      if ((v50 & 4) == 0) {
        uint64_t v51 = 46LL;
      }
      uint64_t v52 = 119LL;
      if ((v50 & 2) == 0) {
        uint64_t v52 = 46LL;
      }
      uint64_t v53 = 114LL;
      if ((*(void *)(v38 - 3) & 0x800000000000000LL) == 0) {
        uint64_t v53 = 46LL;
      }
      dyld4::RuntimeState::log( (dyld4::RuntimeState *)a2,  "%14s (%c%c%c) 0x%012lX->0x%012lX\n",  v49,  v53,  v52,  v51,  v45,  v57);
    }

    ++v37;
LABEL_56:
    v38 += 4;
    v39 -= 16LL;
    if (!v39) {
      goto LABEL_57;
    }
  }

  if (*v46 == 1)
  {
    else {
      Diagnostics::error(a1, "code signing blocked mmap() of '%s'");
    }
  }

  else
  {
    Diagnostics::error(a1, "mmap(addr=0x%0llX, size=0x%08X) failed with errno=%d for %s");
  }

LABEL_60:
  vm_deallocate(mach_task_self_, address, v13);
LABEL_22:
  dyld4::SyscallDelegate::close(a2[1], (int)v18);
LABEL_23:
  vm_address_t v34 = 0LL;
LABEL_24:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v60);
  return v34;
}

uint64_t dyld4::getUuidFromFd( dyld4::SyscallDelegate **this, dyld4::RuntimeState *a2, off_t a3, unsigned __int8 *a4, char *a5)
{
  int v7 = (int)a2;
  *(void *)a4 = 0x64697575206F6ELL;
  uint64_t result = dyld4::SyscallDelegate::pread(this[1], (int)a2, __buf, 0x1CuLL, a3);
  if (result == 28)
  {
    uint64_t result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)__buf);
    if ((_DWORD)result)
    {
      size_t v17 = v23 + 32LL;
      __chkstk_darwin(result, v10, v11, v12, v13, v14, v15, v16, v21);
      off_t v19 = &__buf[-((v18 + 47) & 0x1FFFFFFF0LL) - 4];
      uint64_t result = dyld4::SyscallDelegate::pread(this[1], v7, v19, v17, a3);
      if (result == v17)
      {
        uint64_t result = dyld3::MachOFile::getUuid((dyld3::MachOFile *)v19, v24);
        if ((_DWORD)result) {
          return (uint64_t)dyld4::Loader::uuidToStr(v24, a4, v20);
        }
      }
    }
  }

  return result;
}

void dyld4::Loader::setUpPageInLinking( dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (dyld4::SyscallDelegate *)*((void *)a3 + 1);
  uint64_t v13 = (dyld3 *)dyld4::Loader::path(a1, a3);
  int v14 = dyld4::SyscallDelegate::open(v12, v13, 0LL, 0LL);
  if (v14 == -1)
  {
    off_t v19 = (const char *)dyld4::Loader::path(a1, a3);
    uint64_t v20 = __error();
    Diagnostics::error(a2, "open(%s, O_RDONLY) failed with errno=%d", v19, *v20);
  }

  else
  {
    int v15 = v14;
    uint64_t v16 = (int *)*((void *)a3 + 1);
    BOOL v18 = v16[41] >= 2
       && *((void *)a3 + 19) == 0LL
       && !dyld4::SyscallDelegate::sandboxBlockedPageInLinking((dyld4::SyscallDelegate *)v16);
    uint64_t v21 = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(a1, a3);
    char v22 = *(_BYTE *)(*((void *)a3 + 1) + 159LL);
    v38[0] = 0LL;
    v38[1] = v38;
    v38[2] = 0x2000000000LL;
    __int16 v39 = 0;
    v36[0] = 0LL;
    v36[1] = v36;
    v36[2] = 0x2000000000LL;
    __int16 v37 = 0;
    v32[0] = 0LL;
    v32[1] = v32;
    uint64_t v32[2] = 0x5002000000LL;
    v32[3] = __Block_byref_object_copy__2;
    v32[4] = __Block_byref_object_dispose__2;
    v32[5] = &v41;
    v32[6] = 8LL;
    vm_address_t v34 = 0LL;
    vm_size_t v35 = 0LL;
    uint64_t v33 = 0LL;
    v28[0] = 0LL;
    v28[1] = v28;
    v28[2] = 0x5002000000LL;
    v28[3] = __Block_byref_object_copy__2;
    v28[4] = __Block_byref_object_dispose__2;
    v28[5] = &v40;
    v28[6] = 8LL;
    vm_address_t address = 0LL;
    vm_size_t size = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v23 = dyld3::MachOAnalyzer::chainStartsOffset(v21);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000LL;
    v24[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke;
    v24[3] = &unk_18961F8D0;
    v24[8] = a1;
    v24[9] = v21;
    v24[4] = v38;
    v24[5] = v36;
    int v25 = v15;
    v24[10] = a2;
    v24[11] = a5;
    BOOL v26 = v18;
    char v27 = v22;
    v24[6] = v32;
    _BYTE v24[7] = v28;
    v24[12] = a4;
    v24[13] = a3;
    v24[14] = a6;
    dyld3::MachOAnalyzer::withChainStarts((char *)v21, a2, v23, (uint64_t)v24);
    dyld4::SyscallDelegate::close(*((dyld4::SyscallDelegate **)a3 + 1), v15);
    _Block_object_dispose(v28, 8);
    uint64_t v29 = 0LL;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(v32, 8);
    uint64_t v33 = 0LL;
    if (v34) {
      vm_deallocate(mach_task_self_, v34, v35);
    }
    _Block_object_dispose(v36, 8);
    _Block_object_dispose(v38, 8);
  }

double __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__2(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  uint64_t v22 = 0LL;
  uint64_t v4 = *(dyld4::Loader **)(a1 + 64);
  uint64_t v3 = *(_DWORD **)(a1 + 72);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke_2;
  v9[3] = &unk_18961F8A8;
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v13 = a2;
  uint64_t v14 = v5;
  int v16 = *(_DWORD *)(a1 + 120);
  __int128 v15 = *(_OWORD *)(a1 + 88);
  char v17 = *(_BYTE *)(a1 + 124);
  char v18 = *(_BYTE *)(a1 + 125);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  __int128 v10 = *(_OWORD *)(a1 + 32);
  __int128 v11 = v6;
  uint64_t v12 = &v19;
  dyld3::MachOFile::forEachSegment(v3, (uint64_t)v9);
  if (v20[3])
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8LL);
    if (*(void *)(v7 + 56)
      && dyld4::setUpPageInLinkingRegions( *(const dyld4::RuntimeState **)(a1 + 104),  v4,  *(void *)(a1 + 96),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  *(_DWORD *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 164LL) == 1,  (const mwl_region *)(v7 + 40),  *(void *)(a1 + 112)))
    {
      dyld4::setUpPageInLinkingRegions( *(const dyld4::RuntimeState **)(a1 + 104),  v4,  *(void *)(a1 + 96),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  1LL,  (const mwl_region *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL),  *(void *)(a1 + 112));
    }

    uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8LL);
    if (*(void *)(v8 + 56)) {
      dyld4::setUpPageInLinkingRegions( *(const dyld4::RuntimeState **)(a1 + 104),  v4,  *(void *)(a1 + 96),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  1LL,  (const mwl_region *)(v8 + 40),  *(void *)(a1 + 112));
    }
  }

  _Block_object_dispose(&v19, 8);
}

void *___ZNK5dyld46Loader18setUpPageInLinkingER11DiagnosticsRNS_12RuntimeStateEmyRKN5dyld35ArrayIPKvEE_block_invoke_2( void *result, uint64_t a2, _BYTE *a3)
{
  uint64_t v3 = (unsigned __int16)*(_DWORD *)(a2 + 56) >> 4;
  uint64_t v4 = (_DWORD *)result[9];
  if (v3 < *v4)
  {
    uint64_t v5 = v4[v3 + 1];
    if ((_DWORD)v5)
    {
      uint64_t v8 = result;
      uint64_t v9 = (unsigned __int16 *)((char *)v4 + v5);
      uint64_t v10 = *(void *)(result[4] + 8LL);
      int v11 = v9[3];
      if (*(_WORD *)(v10 + 24))
      {
        if (*(unsigned __int16 *)(v10 + 24) != v11)
        {
          Diagnostics::error((vm_address_t *)result[10], "pointer_format is different in different segments");
          *a3 = 1;
        }
      }

      else
      {
        *(_WORD *)(v10 + 24) = v11;
      }

      uint64_t v12 = *(void *)(v8[5] + 8LL);
      int v13 = v9[2];
      if (*(_WORD *)(v12 + 24))
      {
        if (*(unsigned __int16 *)(v12 + 24) != v13)
        {
          Diagnostics::error((vm_address_t *)v8[10], "page_size is different in different segments");
          *a3 = 1;
        }
      }

      else
      {
        *(_WORD *)(v12 + 24) = v13;
      }

      int v14 = *((_DWORD *)v8 + 26);
      int v15 = *(_DWORD *)(a2 + 52);
      uint64_t v16 = v8[11] + *(void *)a2;
      uint64_t v17 = v8[12] + *(void *)(a2 + 16);
      unint64_t v18 = v9[10] * (unint64_t)*(unsigned __int16 *)(*(void *)(v8[5] + 8LL) + 24LL);
      uint64_t v19 = *(void *)(a2 + 40);
      if (*((_BYTE *)v8 + 108)
        && ((int v20 = *(_DWORD *)(a2 + 56), (v20 & 2) != 0) || v9[10] >= 2u)
        && (uint64_t v21 = *(void *)(v8[6] + 8LL), *(void *)(v21 + 56) <= 4uLL))
      {
        uint64_t v22 = (void *)(v21 + 40);
        int v23 = (v20 & 2) << 8;
        if (!*((_BYTE *)v8 + 109)) {
          int v23 = 0;
        }
        v15 |= v23;
      }

      else
      {
        uint64_t v21 = *(void *)(v8[7] + 8LL);
        uint64_t v22 = (void *)(v21 + 40);
      }

      double result = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::verifySpace( v22,  1LL);
      uint64_t v24 = *(void *)(v21 + 40);
      uint64_t v25 = *(void *)(v21 + 56);
      *(void *)(v21 + 56) = v25 + 1;
      uint64_t v26 = v24 + 48 * v25;
      *(_DWORD *)uint64_t v26 = v14;
      *(_DWORD *)(v26 + 4) = v15;
      *(void *)(v26 + 8) = v16;
      *(void *)(v26 + 16) = v17;
      *(void *)(v26 + 24) = v18;
      *(void *)(v26 + 32) = v19;
      *(void *)(v26 + 40) = v9;
      *(void *)(*(void *)(v8[8] + 8LL) + 24LL) = v9;
    }
  }

  return result;
}

uint64_t dyld4::setUpPageInLinkingRegions( const dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const mwl_region *a7, uint64_t a8)
{
  int v81 = a6;
  __int16 v9 = a5;
  __int16 v10 = a4;
  uint64_t v84 = a2;
  mwlr_vm_address_t address = a7->mwlr_address;
  unsigned int v14 = 4 * mwlr_address + 4;
  const mwl_region *__attribute__((__org_arrdim(0,0))) v83 = a7;
  if (mwlr_address)
  {
    uint64_t v15 = 48 * mwlr_address;
    uint64_t v16 = (_DWORD **)(*(void *)&a7->mwlr_fd + 40LL);
    do
    {
      uint64_t v17 = *v16;
      v16 += 6;
      unsigned int v14 = (v14 + *v17 + 3) & 0xFFFFFFFC;
      v15 -= 48LL;
    }

    while (v15);
  }

  uint64_t v18 = (v14 + 47) & 0xFFFFFFF8;
  uint64_t v19 = *(void *)(a8 + 16);
  if ((_DWORD)a4 == 3) {
    char v20 = 2;
  }
  else {
    char v20 = 3;
  }
  if ((_DWORD)a4 == 3) {
    char v21 = 2;
  }
  else {
    char v21 = 3;
  }
  __chkstk_darwin((uint64_t)a1, (v19 << v20) + v18, a3, a4, a5, a6, (uint64_t)a7, a8, v80);
  int v23 = (char *)&v80 - v22;
  v82 = (const mwl_region *)v24;
  bzero((char *)&v80 - v22, v24);
  *(_DWORD *)int v23 = 7;
  *((_WORD *)v23 + 2) = v9;
  *((_WORD *)v23 + 3) = v10;
  *((_DWORD *)v23 + 2) = v18;
  *((_DWORD *)v23 + 3) = v19;
  *((_DWORD *)v23 + 4) = 40;
  *((_DWORD *)v23 + 5) = v14;
  *((void *)v23 + 3) = a3;
  *((void *)v23 + 4) = dyld4::Loader::loadAddress(v84, a1);
  uint64_t v25 = memmove(&v23[v18], *(const void **)a8, ((_DWORD)v19 << v21));
  const mwl_region *__attribute__((__org_arrdim(0,0))) v33 = v83;
  mach_vm_address_t v34 = v83->mwlr_address;
  vm_size_t v35 = &v23[*((unsigned int *)v23 + 4)];
  *(_DWORD *)vm_size_t v35 = v34;
  if (v34)
  {
    int v36 = 0;
    __int16 v37 = *(_OWORD **)&v33->mwlr_fd;
    int v38 = 4 * v34 + 4;
    uint64_t v39 = 48 * v34;
    char v40 = (unsigned int **)v37 + 5;
    do
    {
      *(_DWORD *)&v35[4 * v36 + 4] = v38;
      char v41 = *v40;
      v40 += 6;
      int v42 = *v41;
      BOOL v43 = memmove(&v23[*((_DWORD *)v23 + 4) + v38], v41, *v41);
      ++v36;
      v38 += v42;
      v39 -= 48LL;
    }

    while (v39);
    __chkstk_darwin((uint64_t)v43, v44, v45, v46, v47, v48, v49, v50, v80);
    vm_size_t v57 = (const mwl_region *)((char *)&v80 - (v56 & 0xFFFFFFFFFFFFFFE0LL | 0x10));
    uint64_t v58 = 0LL;
    uint64_t v59 = 48 * v34;
    int v60 = (mwl_region *)v57;
    const mwl_region *__attribute__((__org_arrdim(0,0))) v33 = v83;
    do
    {
      if (v34 == v58) {
        dyld4::RuntimeState::appendInterposingTuples(v51, v52, v53);
      }
      ++v58;
      __int128 v61 = *v37;
      __int128 v62 = v37[1];
      v37 += 3;
      *(_OWORD *)&v60->mwlr_fd = v61;
      *(_OWORD *)&v60->mwlr_vm_address_t address = v62;
      ++v60;
      v59 -= 48LL;
    }

    while (v59);
  }

  else
  {
    __chkstk_darwin((uint64_t)v25, v26, v27, v28, v29, v30, v31, v32, v80);
    vm_size_t v57 = (const mwl_region *)((char *)&v80 - (v63 & 0xFFFFFFFFFFFFFFE0LL | 0x10));
    LODWORD(v58) = 0;
  }

  if ((v81 & 1) != 0)
  {
    __int128 v64 = v82;
    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v64, v53, v54, v55);
  }

  const mwl_region *__attribute__((__org_arrdim(0,0))) v83 = v57;
  uint64_t v65 = *((void *)a1 + 1);
  if (*(_BYTE *)(v65 + 202) || *(_BYTE *)(v65 + 201))
  {
    __int128 v66 = (const char *)dyld4::Loader::path(v84, a1);
    dyld4::RuntimeState::log(a1, "Setting up kernel page-in linking for %s\n", v66);
    mach_vm_address_t v67 = v33->mwlr_address;
    if (v67)
    {
      uint64_t v68 = 48 * v67;
      uint64_t v69 = *(void *)&v33->mwlr_fd + 16LL;
      do
      {
        unint64_t v70 = *(void *)(v69 + 8);
        int v71 = *(_DWORD *)(v69 - 12);
        unint64_t v79 = v70 >> 10;
        uint64_t v78 = v70 + *(void *)v69;
        if ((v71 & 4) != 0) {
          uint64_t v72 = 120LL;
        }
        else {
          uint64_t v72 = 46LL;
        }
        if ((v71 & 2) != 0) {
          uint64_t v73 = 119LL;
        }
        else {
          uint64_t v73 = 46LL;
        }
        if ((v71 & 1) != 0) {
          uint64_t v74 = 114LL;
        }
        else {
          uint64_t v74 = 46LL;
        }
        dyld4::RuntimeState::log( a1,  "%14s (%c%c%c) 0x%012llX->0x%012llX (fileOffset=0x%0llX, size=%lluKB)\n",  *(const char **)(v69 + 16),  v74,  v73,  v72,  *(void *)v69,  v78,  *(void *)(v69 - 8),  v79);
        v69 += 48LL;
        v68 -= 48LL;
      }

      while (v68);
    }
  }

  __int128 v64 = v82;
  uint64_t result = __map_with_linking_np(v83, v58, (const mwl_info_hdr *)v23, (uint32_t)v82);
  if ((_DWORD)result)
  {
    uint64_t v76 = *((void *)a1 + 1);
    if (*(_BYTE *)(v76 + 202) || *(_BYTE *)(v76 + 201))
    {
      __int128 v77 = (const char *)dyld4::Loader::path(v84, a1);
      dyld4::RuntimeState::log(a1, "__map_with_linking_np(%s) failed, falling back to linking in-process\n", v77);
    }

    return dyld4::dyld_map_with_linking_np((dyld4 *)v23, v64, v53, v54, v55);
  }

  return result;
}

void dyld4::Loader::applyFixupsGeneric( dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(a1, a3);
  uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
  if (dyld3::MachOFile::hasChainedFixups(Address))
  {
    if (!*(_DWORD *)(*((void *)a3 + 1) + 164LL)
      || !dyld3::MachOFile::hasChainedFixupsLoadCommand(Address)
      || *(void *)(a5 + 16) >> 4 > 0x270uLL
      || (dyld4::Loader::setUpPageInLinking(a1, a2, a3, Slide, a4, a5),
          BOOL hasError = Diagnostics::hasError((Diagnostics *)a2),
          Diagnostics::clearError((vm_address_t **)a2),
          hasError))
    {
      uint64_t v18 = dyld3::MachOAnalyzer::chainStartsOffset(Address);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 0x40000000LL;
      v22[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke;
      v22[3] = &__block_descriptor_tmp_90;
      v22[4] = Address;
      v22[5] = a2;
      v22[6] = Slide;
      v22[7] = a5;
      v22[8] = a3;
      dyld3::MachOAnalyzer::withChainStarts((char *)Address, a2, v18, (uint64_t)v22);
    }
  }

  else if (dyld3::MachOFile::hasOpcodeFixups(Address))
  {
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000LL;
    void v21[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3;
    void v21[3] = &__block_descriptor_tmp_93;
    v21[4] = Address;
    uint64_t v21[5] = Slide;
    void v21[6] = a3;
    dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes(Address, a2, (uint64_t)v21);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000LL;
      void v20[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4;
      v20[3] = &__block_descriptor_tmp_96_0;
      v20[4] = a1;
      v20[5] = Address;
      v20[6] = a5;
      void v20[7] = a3;
      v20[8] = a8;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000LL;
      v19[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5;
      v19[3] = &__block_descriptor_tmp_99_0;
      v19[4] = a1;
      v19[5] = Address;
      v19[6] = a6;
      v19[7] = a3;
      dyld3::MachOAnalyzer::forEachBindLocation_Opcodes(Address, a2, (uint64_t)v20, (uint64_t)v19);
    }
  }

uint64_t ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke( void *a1, unsigned int *a2)
{
  uint64_t v4 = a1[4];
  uint64_t v3 = (vm_address_t *)a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = a1[7];
  uint64_t v7 = *(void *)(v6 + 16);
  __int128 v10 = *(_OWORD *)v6;
  uint64_t v11 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_89_0;
  void v9[4] = a1[8];
  return dyld3::MachOLoaded::fixupAllChainedFixups(v4, v3, a2, v5, &v10, (uint64_t)v9);
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_2( uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(dyld4::RuntimeState **)(a1 + 32);
  if (*(_BYTE *)(*((void *)v5 + 1) + 202LL)) {
    dyld4::RuntimeState::log(v5, "fixup: *0x%012lX = 0x%012lX\n", a2, a3);
  }
  *a2 = a3;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_3( void *a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(a1[4] + a2);
  uint64_t v3 = a1[5] + *v2;
  uint64_t v4 = (dyld4::RuntimeState *)a1[6];
  if (*(_BYTE *)(*((void *)v4 + 1) + 202LL)) {
    dyld4::RuntimeState::log(v4, "fixup: *0x%012lX = 0x%012lX <rebase>\n", v2, v3);
  }
  uint64_t *v2 = v3;
}

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_4( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3[2] <= (unint64_t)a3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( a1,  a2,  a3);
  }
  int v4 = a3;
  uint64_t v6 = *(const dyld4::Loader **)(a1 + 32);
  uint64_t v7 = (unint64_t *)(*(void *)(a1 + 40) + a2);
  unint64_t v8 = *(void *)(*v3 + 8LL * a3);
  __int16 v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((void *)v9 + 1) + 202LL))
  {
    __int128 v10 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v9);
    uint64_t v11 = strrchr(v10, 47);
    if (v11) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v10;
    }
    dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/bind#%u>\n", v7, v8, v12, v4);
    __int16 v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  }

  *uint64_t v7 = v8;
  if (v8 == *((void *)v9 + 14))
  {
    int v13 = *(void **)(a1 + 64);
    uint64_t v14 = v13[2];
    if (v14)
    {
      uint64_t v15 = (const char **)(*v13 + 8LL);
      uint64_t v16 = 16 * v14;
      while (*(_DWORD *)v15 != v4)
      {
        v15 += 2;
        v16 -= 16LL;
        if (!v16) {
          return;
        }
      }

      dyld4::RuntimeState::addMissingFlatLazySymbol(v9, v6, *(v15 - 1), v7);
    }
  }

void ___ZNK5dyld46Loader18applyFixupsGenericER11DiagnosticsRNS_12RuntimeStateEyRKN5dyld35ArrayIPKvEESB_bRKNS6_INS0_21MissingFlatLazySymbolEEE_block_invoke_5( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)a1[6];
  if (v3[2] <= (unint64_t)a3) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( (uint64_t)a1,  a2,  a3);
  }
  int v4 = a3;
  uint64_t v6 = (dyld4::Loader *)a1[4];
  uint64_t v7 = (uint64_t *)(a1[5] + a2);
  uint64_t v8 = *(void *)(*v3 + 8LL * a3);
  __int16 v9 = (const dyld4::RuntimeState *)a1[7];
  if (v8 == -1)
  {
    if (*(_BYTE *)(*((void *)v9 + 1) + 202LL))
    {
      int v13 = (const char *)dyld4::Loader::path(v6, v9);
      uint64_t v14 = strrchr(v13, 47);
      if (v14) {
        uint64_t v15 = v14 + 1;
      }
      else {
        uint64_t v15 = v13;
      }
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX (skipping missing weak bind) <%s/weak-bind#%u>\n", v7, v15, v4);
    }
  }

  else
  {
    if (*(_BYTE *)(*((void *)v9 + 1) + 202LL))
    {
      __int128 v10 = (const char *)dyld4::Loader::path(v6, v9);
      uint64_t v11 = strrchr(v10, 47);
      if (v11) {
        uint64_t v12 = v11 + 1;
      }
      else {
        uint64_t v12 = v10;
      }
      dyld4::RuntimeState::log(v9, "fixup: *0x%012lX = 0x%012lX <%s/weak-bind#%u>\n", v7, v8, v12, v4);
    }

    *uint64_t v7 = v8;
  }

void dyld4::Loader::findAndRunAllInitializers(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  unint64_t Address = (dyld3::MachOAnalyzer *)dyld4::Loader::loadAddress(this, a2);
  dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke;
  v6[3] = &__block_descriptor_tmp_102;
  v6[4] = this;
  void v6[5] = Address;
  v6[6] = a2;
  dyld3::MachOAnalyzer::forEachInitializer(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v6);
  if (!dyld3::MachOFile::isArch(Address, "arm64e"))
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    v5[2] = ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_105;
    v5[4] = this;
    void v5[5] = Address;
    v5[6] = a2;
    dyld3::MachOAnalyzer::forEachTerminator(Address, (vm_address_t *)&v8, (uint64_t)v7, (uint64_t)v5);
  }

  mach_o::Error::~Error(&v8);
}

uint64_t ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v9 = *(void *)(a1 + 40);
  __int128 v10 = *(const dyld4::RuntimeState **)(a1 + 48);
  uint64_t v11 = (const void *)(v9 + a2);
  if (*(_BYTE *)(*((void *)v10 + 1) + 203LL))
  {
    uint64_t v12 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 32), v10);
    dyld4::RuntimeState::log(v10, "running initializer %p in %s\n", v11, v12);
    uint64_t v9 = *(void *)(a1 + 40);
  }

  int v18 = 520552448;
  uint64_t v19 = v9;
  uint64_t v20 = 0LL;
  char v21 = v11;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v18, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = *(void *)(a1 + 48);
  if (*(_BYTE *)(v13 + 648))
  {
    uint64_t v14 = *(lsl::Lock **)(v13 + 128);
    lsl::MemoryManager::lockGuard(v14, &v27);
    uint64_t v15 = *((void *)v14 + 3) - 1LL;
    *((void *)v14 + 3) = v15;
    if (!v15) {
      lsl::MemoryManager::writeProtect(v14, 1);
    }
    lsl::Lock::unlock(v27);
    ((void (*)(void, void, void, void, void))v11)( *(unsigned int *)(*(void *)(v13 + 8) + 104LL),  *(void *)(*(void *)(v13 + 8) + 112LL),  *(void *)(*(void *)(v13 + 8) + 120LL),  *(void *)(*(void *)(v13 + 8) + 128LL),  *(void *)(v13 + 144));
    lsl::MemoryManager::lockGuard(v14, &v27);
    uint64_t v16 = *((void *)v14 + 3);
    if (!v16)
    {
      lsl::MemoryManager::writeProtect(v14, 0);
      uint64_t v16 = *((void *)v14 + 3);
    }

    *((void *)v14 + 3) = v16 + 1;
    lsl::Lock::unlock(v27);
  }

  else
  {
    ((void (*)(void, void, void, void, void))v11)( *(unsigned int *)(*(void *)(v13 + 8) + 104LL),  *(void *)(*(void *)(v13 + 8) + 112LL),  *(void *)(*(void *)(v13 + 8) + 120LL),  *(void *)(*(void *)(v13 + 8) + 128LL),  *(void *)(v13 + 144));
  }

  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v18);
}

void ___ZNK5dyld46Loader25findAndRunAllInitializersERNS_12RuntimeStateE_block_invoke_2( void *a1, unsigned int a2)
{
  uint64_t v3 = (dyld4::Loader *)a1[4];
  int v4 = (const void *)(a1[5] + a2);
  (*(void (**)(void, const void *, void))(**(void **)(a1[6] + 152LL) + 80LL))( *(void *)(a1[6] + 152LL),  v4,  0LL);
  uint64_t v5 = (const dyld4::RuntimeState *)a1[6];
  if (*(_BYTE *)(*((void *)v5 + 1) + 203LL))
  {
    uint64_t v6 = (const char *)dyld4::Loader::path(v3, v5);
    dyld4::RuntimeState::log(v5, "registering old style destructor %p for %s\n", v4, v6);
  }

void dyld4::Loader::runInitializersBottomUp( dyld4::Loader *a1, dyld4::RuntimeState *a2, uint64_t *a3, uint64_t *a4)
{
  int isDelayInit = dyld4::Loader::isDelayInit(a1, a2);
  char v10 = isDelayInit;
  if (!isDelayInit)
  {
    if ((dyld4::Loader::beginInitializers(a1, a2) & 1) != 0) {
      return;
    }
    goto LABEL_8;
  }

  uint64_t v11 = a4[2];
  if (!v11)
  {
LABEL_6:
    uint64_t v23 = (uint64_t)a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a4, &v23, v9);
LABEL_8:
    int v14 = dyld4::Loader::dependentCount(a1);
    if (v14)
    {
      int v15 = v14;
      uint64_t v16 = 0LL;
      do
      {
        char v22 = 0;
        uint64_t v17 = dyld4::Loader::dependent(a1, a2, v16, &v22);
        uint64_t v23 = v17;
        if (v17)
        {
          if ((v22 & 4) != 0)
          {
            uint64_t v19 = a3[2];
            if (v19)
            {
              uint64_t v20 = (void *)*a3;
              uint64_t v21 = 8 * v19;
              while (*v20 != v17)
              {
                ++v20;
                v21 -= 8LL;
                if (!v21) {
                  goto LABEL_17;
                }
              }
            }

            else
            {
LABEL_17:
              dyld3::Array<dyld4::Loader const*>::push_back(a3, &v23, v18);
            }
          }

          else
          {
            dyld4::Loader::runInitializersBottomUp();
          }
        }

        uint64_t v16 = (v16 + 1);
      }

      while ((_DWORD)v16 != v15);
    }

    if ((v10 & 1) == 0)
    {
      dyld4::RuntimeState::notifyObjCInit(a2, a1);
      dyld4::Loader::runInitializers(a1, a2);
    }

    return;
  }

  uint64_t v12 = (dyld4::Loader **)*a4;
  uint64_t v13 = 8 * v11;
  while (*v12 != a1)
  {
    ++v12;
    v13 -= 8LL;
    if (!v13) {
      goto LABEL_6;
    }
  }

uint64_t *dyld3::Array<dyld4::Loader const*>::push_back(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  unint64_t v3 = result[2];
  if (v3 >= result[1]) {
    dyld4::RuntimeState::appendInterposingTuples((uint64_t)result, (uint64_t)a2, a3);
  }
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  result[2] = v3 + 1;
  *(void *)(v5 + 8 * v3) = v4;
  return result;
}

os_unfair_lock_s *dyld4::Loader::runInitializersBottomUpPlusUpwardLinks( dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  uint64_t v2 = (lsl::Lock *)*((void *)a2 + 16);
  v13[0] = (uint64_t)a2;
  v13[1] = (uint64_t)this;
  lsl::MemoryManager::lockGuard(v2, &v14);
  uint64_t v3 = *((void *)v2 + 3);
  if (!v3)
  {
    lsl::MemoryManager::writeProtect(v2, 0);
    uint64_t v3 = *((void *)v2 + 3);
  }

  *((void *)v2 + 3) = v3 + 1;
  lsl::Lock::unlock(v14);
  dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()( v13,  v4,  v5,  v6,  v7,  v8,  v9,  v10);
  lsl::MemoryManager::lockGuard(v2, &v14);
  uint64_t v11 = *((void *)v2 + 3) - 1LL;
  *((void *)v2 + 3) = v11;
  if (!v11) {
    lsl::MemoryManager::writeProtect(v2, 1);
  }
  return lsl::Lock::unlock(v14);
}

void dyld4::Loader::forEachBindTarget( dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke;
  void v7[3] = &unk_18961FA28;
  char v8 = a5;
  void v7[8] = a2;
  v7[9] = a3;
  v7[4] = a4;
  v7[5] = a6;
  v7[6] = a7;
  void v7[7] = a1;
  dyld4::Loader::withLayout(a1, a2, a3, (uint64_t)v7);
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke( uint64_t a1, const mach_o::Layout *a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v18, a2);
  v16[0] = 0LL;
  v16[1] = v16;
  v16[2] = 0x2000000000LL;
  int v17 = 0;
  v14[0] = 0LL;
  v14[1] = v14;
  v14[2] = 0x2000000000LL;
  int v15 = 0;
  char v5 = *(_BYTE *)(a1 + 80);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2;
  v8[3] = &unk_18961F9D8;
  uint64_t v10 = v16;
  uint64_t v11 = v3;
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v12 = *(vm_address_t **)(a1 + 64);
  uint64_t v13 = v6;
  __int128 v9 = *(_OWORD *)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3;
  void v7[3] = &unk_18961FA00;
  void v7[7] = v3;
  void v7[8] = v6;
  v7[4] = v9;
  v7[5] = *(void *)(a1 + 48);
  v7[6] = v14;
  mach_o::Fixups::forEachBindTarget(v4, v12, v5, 0LL, (uint64_t)v8, (uint64_t)v7);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
}

BOOL ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) != *(_DWORD *)a2) {
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1();
  }
  dyld4::Loader::resolveSymbol( *(dyld4::Loader **)(a1 + 56),  *(dyld4::RuntimeState **)(a1 + 72),  *(vm_address_t **)(a1 + 64),  *(unsigned int *)(a2 + 4),  *(const char **)(a2 + 8),  *(unsigned __int8 *)(a2 + 24),  *(unsigned __int8 *)(a2 + 25),  *(void *)(a1 + 32),  (uint64_t)v7);
  v8 += *(void *)(a2 + 16);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40));
  BOOL result = Diagnostics::hasError(*(Diagnostics **)(a1 + 64));
  if (result) {
    *a3 = 1;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  return result;
}

void dyld4::Loader::resolveSymbol( dyld4::Loader *this@<X0>, dyld4::RuntimeState *a2@<X2>, vm_address_t *a3@<X1>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  HIDWORD(v55) = a7;
  int v10 = a6;
  int v11 = a4;
  uint64_t v62 = 0LL;
  uint64_t v63 = &v62;
  uint64_t v64 = 0x5002000000LL;
  uint64_t v65 = __Block_byref_object_copy__122;
  __int128 v66 = __Block_byref_object_dispose__123;
  uint64_t v67 = 0LL;
  uint64_t v68 = a5;
  uint64_t v69 = 0LL;
  uint64_t v70 = 0LL;
  uint64_t v71 = 2LL;
  uint64_t v17 = (a4 - 1);
  if ((int)a4 >= 1 && dyld4::Loader::dependentCount(this) >= a4)
  {
    uint64_t v18 = (dyld4::Loader *)dyld4::Loader::dependent(this, a2, v17, 0LL);
LABEL_16:
    v63[5] = (uint64_t)v18;
    if (v18
      && (__chkstk_darwin((uint64_t)v18, (uint64_t)a3, (uint64_t)a2, a4, (uint64_t)a5, a6, a7, a8, v55),
          uint64_t v31 = *((void *)a2 + 6),
          *(void *)&__int128 v76 = (char *)&v55 - ((v30 + 23) & 0xFFFFFFFFFFFFFFF0LL),
          *((void *)&v76 + 1) = v31,
          uint64_t v77 = 0LL,
          dyld4::Loader::hasExportedSymbol( v63[5],  a3,  a2,  (const unsigned __int8 *)a5,  0,  1,  v63 + 5,  (uint64_t *)&v76)))
    {
      uint64_t v32 = v63;
      __int128 v33 = *(_OWORD *)(v63 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
      *(_OWORD *)(a9 + 16) = v33;
      *(void *)(a9 + 32) = v32[9];
    }

    else
    {
      if (v10)
      {
        mach_vm_address_t v34 = v63;
        *((_DWORD *)v63 + 18) = 2;
        v34[7] = 0LL;
      }

      else if (HIDWORD(v55) && (uint64_t v35 = *((void *)a2 + 15)) != 0)
      {
        mach_vm_address_t v34 = v63;
        v63[5] = *((void *)a2 + 13);
        void v34[6] = (uint64_t)a5;
        v34[7] = v35;
        v34[9] = 1LL;
      }

      else
      {
        int v36 = dyld4::Loader::overridesDylibInCache((uint64_t)this, &v58, &v57);
        mach_vm_address_t v34 = v63;
        if (v36)
        {
          *((_DWORD *)v63 + 18) = 2;
          v34[7] = 195903495LL;
        }

        else
        {
          int v38 = (dyld4::Loader *)v63[5];
          if (v38) {
            uint64_t v39 = (const char *)dyld4::Loader::path(v38, a2);
          }
          else {
            uint64_t v39 = "unknown";
          }
          if (!*((void *)a2 + 19))
          {
            int v42 = (const char *)dyld4::Loader::path(this, a2);
            dyld4::RuntimeState::setLaunchMissingSymbol(a2, a5, v39, v42);
          }

          if ((*((_WORD *)this + 2) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v37);
          }
          else {
            strcpy((char *)&v76, "no uuid");
          }
          uint64_t v43 = v63[5];
          if (v43 && (*(_WORD *)(v43 + 4) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)(v43 + 8), v72, v37);
          }
          else {
            strcpy((char *)v72, "no uuid");
          }
          Diagnostics::Diagnostics((Diagnostics *)&v56);
          dyld4::Loader::tooNewErrorAddendum(this, (Diagnostics *)&v56, a2);
          uint64_t v46 = (const char *)dyld4::Loader::path(this, a2);
          uint64_t v47 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v56);
          Diagnostics::error( a3,  "Symbol not found: %s\n  Referenced from: <%s> %s%s\n  Expected in:     <%s> %s",  a5,  (const char *)&v76,  v46,  v47,  (const char *)v72,  v39);
          mach_o::Error::~Error(&v56);
LABEL_48:
          mach_vm_address_t v34 = v63;
        }
      }

      __int128 v48 = *(_OWORD *)(v34 + 7);
      *(_OWORD *)a9 = *(_OWORD *)(v34 + 5);
      *(_OWORD *)(a9 + 16) = v48;
      *(void *)(a9 + 32) = v34[9];
    }
  }

  else
  {
    uint64_t v18 = this;
    switch(v11)
    {
      case -3:
        char v19 = *(_BYTE *)(*((void *)a2 + 1) + 202LL);
        *(void *)uint64_t v72 = 0LL;
        uint64_t v73 = v72;
        uint64_t v74 = 0x2000000000LL;
        char v75 = 0;
        uint64_t v20 = (void *)*((void *)a2 + 17);
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 0x40000000LL;
        v59[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2;
        v59[3] = &unk_18961FAF8;
        char v60 = v19;
        v59[8] = a2;
        v59[9] = a5;
        v59[6] = v72;
        v59[7] = this;
        v59[10] = a3;
        v59[4] = a8;
        v59[5] = &v62;
        dyld4::RuntimeLocks::withLoadersReadLock(v20, (uint64_t)v59);
        if (v73[24])
        {
          char v22 = (const dyld4::Loader *)v63[5];
          if (v22 != this) {
            dyld4::RuntimeState::addDynamicReference(a2, this, v22);
          }
          if (*((void *)a2 + 42) && (dyld4::Loader::hiddenFromFlat((dyld4::Loader *)v63[5], 0) & 1) == 0)
          {
            uint64_t v23 = v63[5];
            unint64_t v24 = v63[7] & 0x3FFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)v63 + 76) << 62) | ((unint64_t)*((unsigned __int8 *)v63 + 77) << 63);
            uint64_t v25 = *((void *)a2 + 42);
            uint64_t v77 = 0LL;
            __int128 v76 = (unint64_t)a5;
            uint64_t v26 = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert( v25,  &v76);
            *(void *)(v26 + 8) = v23;
            *(void *)(v26 + 16) = v24;
          }
        }

        else if (v10)
        {
          char v40 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v40[7] = 0LL;
        }

        else
        {
          if ((*((_WORD *)this + 2) & 0x400) != 0) {
            dyld4::Loader::uuidToStr((unsigned __int8 *)this + 8, (unsigned __int8 *)&v76, v21);
          }
          else {
            strcpy((char *)&v76, "no uuid");
          }
          uint64_t v52 = (const char *)dyld4::Loader::path(this, a2);
          Diagnostics::error( a3,  "Symbol not found: %s\n  Referenced from: <%s> %s\n  Expected as weak-def export from some loaded dylib",  a5,  (const char *)&v76,  v52);
        }

        uint64_t v53 = v63;
        __int128 v54 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v54;
        *(void *)(a9 + 32) = v53[9];
        uint64_t v51 = v72;
        break;
      case -2:
        *(void *)&__int128 v76 = 0LL;
        *((void *)&v76 + 1) = &v76;
        uint64_t v77 = 0x2000000000LL;
        char v78 = 0;
        uint64_t v28 = (void *)*((void *)a2 + 17);
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 0x40000000LL;
        v61[2] = ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke;
        v61[3] = &unk_18961FAD0;
        v61[6] = this;
        v61[7] = a2;
        v61[8] = a3;
        v61[9] = a5;
        v61[4] = &v62;
        v61[5] = &v76;
        dyld4::RuntimeLocks::withLoadersReadLock(v28, (uint64_t)v61);
        if (*(_BYTE *)(*((void *)&v76 + 1) + 24LL))
        {
          uint64_t v29 = (const dyld4::Loader *)v63[5];
          if (v29 != this) {
            dyld4::RuntimeState::addDynamicReference(a2, this, v29);
          }
        }

        else if (v10)
        {
          char v41 = v63;
          *((_DWORD *)v63 + 18) = 2;
          v41[7] = 0LL;
        }

        else if (HIDWORD(v55) && (uint64_t v44 = *((void *)a2 + 15)) != 0)
        {
          uint64_t v45 = v63;
          v63[5] = *((void *)a2 + 13);
          v45[6] = (uint64_t)a5;
          v45[7] = v44;
          v45[8] = 0LL;
          *((_DWORD *)v45 + 18) = 1;
          *((_DWORD *)v45 + 19) = 0x10000;
        }

        else
        {
          Diagnostics::error(a3, "symbol not found in flat namespace '%s'", a5);
        }

        uint64_t v49 = v63;
        __int128 v50 = *(_OWORD *)(v63 + 7);
        *(_OWORD *)a9 = *(_OWORD *)(v63 + 5);
        *(_OWORD *)(a9 + 16) = v50;
        *(void *)(a9 + 32) = v49[9];
        uint64_t v51 = &v76;
        break;
      case -1:
        uint64_t v18 = (dyld4::Loader *)*((void *)a2 + 3);
        goto LABEL_16;
      case 0:
        goto LABEL_16;
      default:
        uint64_t v27 = (const char *)dyld4::Loader::path(this, a2);
        Diagnostics::error(a3, "unknown library ordinal %d in %s when binding '%s'", v11, v27, a5);
        goto LABEL_48;
    }

    _Block_object_dispose(v51, 8);
  }

  _Block_object_dispose(&v62, 8);
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) != *(_DWORD *)a2) {
    ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1();
  }
  uint64_t v4 = *(dyld4::Loader **)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  dyld4::Loader::resolveSymbol( v4,  *(dyld4::RuntimeState **)(a1 + 64),  (vm_address_t *)&v8,  *(unsigned int *)(a2 + 4),  *(const char **)(a2 + 8),  *(unsigned __int8 *)(a2 + 24),  *(unsigned __int8 *)(a2 + 25),  *(void *)(a1 + 32),  (uint64_t)&v5);
  if (Diagnostics::hasError((Diagnostics *)&v8))
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v7 = 1LL;
  }

  else
  {
    v6 += *(void *)(a2 + 16);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40));
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  mach_o::Error::~Error(&v8);
}

BOOL dyld4::Loader::hasConstantSegmentsToProtect(dyld4::Loader *this)
{
  return (*((_WORD *)this + 2) & 0x12) == 16;
}

void dyld4::Loader::makeSegmentsReadOnly(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke;
  v5[3] = &__block_descriptor_tmp_114_0;
  v5[4] = this;
  void v5[5] = dyld3::MachOLoaded::getSlide(Address);
  v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

void ___ZNK5dyld46Loader20makeSegmentsReadOnlyERNS_12RuntimeStateE_block_invoke(void *a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
  {
    uint64_t v3 = (dyld4::Loader *)a1[4];
    size_t v4 = *(void *)(a2 + 24);
    uint64_t v5 = (char *)(a1[5] + *(void *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8LL), v5, v4, 1);
    uint64_t v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((void *)v6 + 1) + 201LL))
    {
      uint64_t v7 = &v5[v4];
      uint64_t v8 = (const char *)dyld4::Loader::path(v3, v6);
      __int128 v9 = strrchr(v8, 47);
      if (v9) {
        int v10 = v9 + 1;
      }
      else {
        int v10 = v8;
      }
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-only (%s)\n", v5, v7, v10);
    }
  }

void dyld4::Loader::makeSegmentsReadWrite(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(this, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke;
  v5[3] = &__block_descriptor_tmp_116;
  v5[4] = this;
  void v5[5] = dyld3::MachOLoaded::getSlide(Address);
  v5[6] = a2;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v5);
}

void ___ZNK5dyld46Loader21makeSegmentsReadWriteERNS_12RuntimeStateE_block_invoke(void *a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0)
  {
    uint64_t v3 = (dyld4::Loader *)a1[4];
    size_t v4 = *(void *)(a2 + 24);
    uint64_t v5 = (char *)(a1[5] + *(void *)(a2 + 16));
    dyld4::SyscallDelegate::mprotect(*(dyld4::SyscallDelegate **)(a1[6] + 8LL), v5, v4, 3);
    uint64_t v6 = (const dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((void *)v6 + 1) + 201LL))
    {
      uint64_t v7 = &v5[v4];
      uint64_t v8 = (const char *)dyld4::Loader::path(v3, v6);
      __int128 v9 = strrchr(v8, 47);
      if (v9) {
        int v10 = v9 + 1;
      }
      else {
        int v10 = v8;
      }
      dyld4::RuntimeState::log(v6, "mprotect 0x%012lX->0x%012lX to read-write (%s)\n", v5, v7, v10);
    }
  }

void dyld4::Loader::logSegmentsFromSharedCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  size_t v4 = (const char *)dyld4::Loader::path(this, a2);
  dyld4::RuntimeState::log(a2, "Using mapping in dyld cache for %s\n", v4);
  uint64_t v5 = *(void *)(*((void *)a2 + 1) + 264LL);
  unint64_t Address = (_DWORD *)dyld4::Loader::loadAddress(this, a2);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke;
  void v7[3] = &__block_descriptor_tmp_119;
  v7[4] = a2;
  v7[5] = v5;
  dyld3::MachOFile::forEachSegment(Address, (uint64_t)v7);
}

void ___ZNK5dyld46Loader26logSegmentsFromSharedCacheERNS_12RuntimeStateE_block_invoke( uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 52);
  uint64_t v3 = 120LL;
  if ((v2 & 4) == 0) {
    uint64_t v3 = 46LL;
  }
  uint64_t v4 = 119LL;
  if ((v2 & 2) == 0) {
    uint64_t v4 = 46LL;
  }
  uint64_t v5 = 114LL;
  if ((*(_DWORD *)(a2 + 52) & 1) == 0) {
    uint64_t v5 = 46LL;
  }
  dyld4::RuntimeState::log( *(dyld4::RuntimeState **)(a1 + 32),  "%14s (%c%c%c) 0x%012llX->0x%012llX \n",  *(const char **)(a2 + 40),  v5,  v4,  v3,  *(void *)(a1 + 40) + *(void *)(a2 + 16),  *(void *)(a1 + 40) + *(void *)(a2 + 16) + *(void *)(a2 + 24));
}

void dyld4::Loader::addWeakDefsToMap(dyld4::RuntimeState *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = *(dyld4::Loader ***)a2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      uint64_t Address = dyld4::Loader::loadAddress(*v4, a1);
      if ((*(_BYTE *)(Address + 25) & 0x80) != 0)
      {
        uint64_t v8 = (dyld3::MachOFile *)Address;
        if ((dyld4::Loader::hiddenFromFlat(v6, 0) & 1) == 0)
        {
          Diagnostics::Diagnostics((Diagnostics *)&v11);
          uint64_t v9 = dyld3::MachOFile::preferredLoadAddress(v8);
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 0x40000000LL;
          v10[2] = ___ZN5dyld46Loader16addWeakDefsToMapERNS_12RuntimeStateERKNSt3__14spanIPKS0_Lm18446744073709551615EEE_block_invoke;
          v10[3] = &__block_descriptor_tmp_121;
          v10[4] = a1;
          v10[5] = v6;
          void v10[6] = v9;
          dyld3::MachOLoaded::forEachGlobalSymbol(v8, (vm_address_t *)&v11, (uint64_t)v10);
          mach_o::Error::~Error(&v11);
        }
      }

      ++v4;
      v5 -= 8LL;
    }

    while (v5);
  }

void *___ZN5dyld46Loader16addWeakDefsToMapERNS_12RuntimeStateERKNSt3__14spanIPKS0_Lm18446744073709551615EEE_block_invoke( void *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  int v11 = a2;
  if (a6 < 0)
  {
    uint64_t v7 = result;
    uint64_t v8 = dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( *(void *)(result[4] + 336LL),  (uint64_t *)(*(void *)(result[4] + 336LL) + 16LL),  (void *)(*(void *)(result[4] + 336LL) + 56LL),  0LL,  &v11);
    BOOL result = *(void **)(v7[4] + 336LL);
    if (v8 == (const char **)(result[7] + 24LL * result[9]))
    {
      uint64_t v9 = v7[5];
      unint64_t v10 = (a3 - v7[6]) & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000LL;
      uint64_t v13 = 0LL;
      __int128 v12 = (unint64_t)v11;
      BOOL result = (void *)dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert( (uint64_t)result,  &v12);
      result[1] = v9;
      result[2] = v10;
    }
  }

  return result;
}

__n128 __Block_byref_object_copy__122(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

unint64_t ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke( unint64_t result)
{
  unint64_t v1 = result;
  uint64_t v2 = 0LL;
  uint64_t v4 = *(dyld4::Loader **)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  v11[0] = v3 + 32;
  v11[1] = v3 + 64;
  while (1)
  {
    uint64_t v5 = v11[v2];
    uint64_t v6 = *(void *)(v5 + 16);
    if (v6) {
      break;
    }
LABEL_11:
    if (++v2 == 2) {
      return result;
    }
  }

  uint64_t v7 = *(dyld4::Loader ***)(v5 + 8);
  uint64_t v8 = 8 * v6;
  while (1)
  {
    uint64_t v9 = *v7;
    __n128 result = dyld4::Loader::hiddenFromFlat(*v7, 0);
    if (!(_DWORD)result || v9 == v4)
    {
      __n128 result = dyld4::Loader::hasExportedSymbol( (uint64_t)v9,  *(vm_address_t **)(v1 + 64),  *(const dyld4::RuntimeState **)(v1 + 56),  *(const unsigned __int8 **)(v1 + 72),  1u,  1,  (uint64_t *)(*(void *)(*(void *)(v1 + 32) + 8LL) + 40LL),  0LL);
      if ((result & 1) != 0) {
        break;
      }
    }

    ++v7;
    v8 -= 8LL;
    if (!v8) {
      goto LABEL_11;
    }
  }

  *(_BYTE *)(*(void *)(*(void *)(v1 + 40) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t dyld4::Loader::hasExportedSymbol( uint64_t a1, vm_address_t *a2, const dyld4::RuntimeState *a3, const unsigned __int8 *a4, unsigned int a5, int a6, uint64_t *a7, uint64_t *a8)
{
  int v68 = a6;
  if (a8)
  {
    uint64_t v15 = a8[2];
    if (v15)
    {
      uint64_t v16 = (void *)*a8;
      uint64_t v17 = 8 * v15;
      while (*v16 != a1)
      {
        ++v16;
        v17 -= 8LL;
        if (!v17) {
          goto LABEL_6;
        }
      }

      return 0LL;
    }

LABEL_6:
    uint64_t v73 = a1;
    dyld3::Array<dyld4::Loader const*>::push_back(a8, &v73, (uint64_t)a3);
  }

  uint64_t v67 = a7;
  switch(a5)
  {
    case 3u:
      char v18 = 0;
      LODWORD(v66) = 1;
      break;
    case 2u:
      char v18 = 1;
      LODWORD(v66) = 1;
      break;
    case 1u:
      char v18 = 0;
      uint64_t v66 = 0LL;
      goto LABEL_15;
    default:
      char v18 = 0;
      LODWORD(v66) = 0;
      break;
  }

  HIDWORD(v66) = 1;
LABEL_15:
  uint64_t Address = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
  if (!dyld4::Loader::getExportsTrie((dyld4::Loader *)a1, &v71, &v70))
  {
    uint64_t v38 = dyld4::Loader::mf((dyld4::Loader *)a1, a3);
    uint64_t v73 = 0LL;
    uint64_t v74 = &v73;
    uint64_t v75 = 0x2000000000LL;
    char v76 = 0;
    v69[0] = _NSConcreteStackBlock;
    v69[1] = 0x40000000LL;
    v69[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke;
    v69[3] = &unk_18961FB98;
    void v69[6] = a2;
    v69[7] = a4;
    v69[8] = v67;
    v69[9] = v38;
    v69[10] = a3;
    v69[4] = &v73;
    v69[5] = a1;
    dyld4::Loader::withLayout((dyld4::Loader *)a1, a2, a3, (uint64_t)v69);
    int v39 = *((unsigned __int8 *)v74 + 24);
    _Block_object_dispose(&v73, 8);
    if (v39) {
      return 1LL;
    }
    goto LABEL_31;
  }

  uint64_t v21 = (Diagnostics *)(Address + v71 + v70);
  char v22 = dyld3::MachOFile::trieWalk(a2, (const unsigned __int8 **)(Address + v71), v21, a4, v20);
  if (v22) {
    char v24 = v18;
  }
  else {
    char v24 = 1;
  }
  uint64_t v25 = (uint64_t)v67;
  if ((v24 & 1) != 0)
  {
LABEL_31:
    if (a1)
    {
      if ((*(_WORD *)(a1 + 4) & 1) == 0)
      {
        char v40 = *(uint64_t (****)(char *))(a1 + 104);
        if (v40)
        {
          uint64_t v72 = 0LL;
          uint64_t v73 = (uint64_t)a4;
          uint64_t v77 = 0LL;
          char v41 = (char *)dyld4::PseudoDylib::lookupSymbols( v40,  (uint64_t)&v73,  1LL,  (uint64_t)&v77,  1LL,  (uint64_t)&v72,  1LL);
          uint64_t v33 = v41 == 0LL;
          if (v41)
          {
            int v42 = v41;
            Diagnostics::error(a2, "pseudo-dylib lookup error: %s", v41);
            dyld4::PseudoDylib::disposeString(v40, v42);
            return v33;
          }

          if ((v72 & 1) != 0)
          {
            uint64_t v61 = (uint64_t)v67;
            *uint64_t v67 = a1;
            *(void *)(v61 + 8) = a4;
            uint64_t v62 = v77;
            *(void *)(v61 + 16) = (char *)v62 - dyld4::Loader::mf((dyld4::Loader *)a1, a3);
            *(_DWORD *)(v61 + 32) = 1;
            *(_BYTE *)(v61 + 36) = (v72 & 4) != 0;
            uint64_t v63 = dyld4::Loader::resolvedAddress(a3, v61);
            *(void *)(v61 + 24) = v63;
            *(void *)(v61 + 24) = dyld4::Loader::interpose(a3, v63, 0LL, v64);
            char v65 = v72;
            *(_BYTE *)(v61 + 37) = (v72 & 2) != 0;
            *(_BYTE *)(v61 + 38) = 0;
            *(_BYTE *)(v61 + 39) = (v65 & 8) != 0;
            return v33;
          }
        }
      }
    }

    if (!HIDWORD(v66)) {
      return 0LL;
    }
    uint64_t v33 = dyld4::Loader::dependentCount((dyld4::Loader *)a1);
    if (!(_DWORD)v33) {
      return v33;
    }
    uint64_t v46 = 0LL;
    while (1)
    {
      LOBYTE(v73) = 0;
      if (dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, v46, (char *)&v73))
      {
        if ((v73 & 2) != 0 || ((v73 & 0xC) != 0 ? (char v47 = 1) : (char v47 = v66 ^ 1), (v47 & 1) == 0))
        {
        }
      }

      uint64_t v46 = (v46 + 1);
      if ((_DWORD)v33 == (_DWORD)v46) {
        return 0LL;
      }
    }

    return 1LL;
  }

  uint64_t v77 = v22;
  char v27 = dyld3::MachOFile::read_uleb128(a2, &v77, (const unsigned __int8 **)v21, v23);
  if ((v27 & 8) == 0)
  {
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      uint64_t v29 = dyld3::MachOFile::read_uleb128(a2, &v77, (const unsigned __int8 **)v21, v28);
      if (!v68 && (v27 & 0x10) != 0)
      {
        uint64_t v31 = dyld3::MachOFile::read_uleb128(a2, &v77, (const unsigned __int8 **)v21, v30);
        uint64_t v32 = dyld4::Loader::loadAddress((dyld4::Loader *)a1, a3);
        uint64_t v29 = ((uint64_t (*)(void))(v32 + v31))() - v32;
        uint64_t v25 = (uint64_t)v67;
      }

      *(void *)uint64_t v25 = a1;
      *(void *)(v25 + 8) = a4;
      *(void *)(v25 + 16) = v29;
      uint64_t v33 = 1LL;
      if ((v27 & 3) == 2LL) {
        int v34 = 2;
      }
      else {
        int v34 = 1;
      }
      *(_DWORD *)(v25 + 32) = v34;
      uint64_t v35 = (dyld3::MachOFile *)dyld4::Loader::mf((dyld4::Loader *)a1, a3);
      *(_BYTE *)(v25 + 36) = dyld3::MachOFile::inCodeSection(v35, *(_DWORD *)(v25 + 16));
      int v36 = dyld4::Loader::resolvedAddress(a3, v25);
      *(void *)(v25 + 24) = v36;
      *(void *)(v25 + 24) = dyld4::Loader::interpose(a3, v36, 0LL, v37);
      *(_BYTE *)(v25 + 37) = (v27 & 4) != 0;
      *(_WORD *)(v25 + 38) = 0;
      return v33;
    }

    return 0LL;
  }

  uint64_t v43 = dyld3::MachOFile::read_uleb128(a2, &v77, (const unsigned __int8 **)v21, v26);
  unint64_t v44 = v43;
  if (*(_BYTE *)v77)
  {
    BOOL v45 = _platform_strcmp((const char *)v77, (const char *)a4) != 0;
    if (!v44) {
      goto LABEL_54;
    }
  }

  else
  {
    BOOL v45 = 0;
    if (!v43)
    {
LABEL_54:
      __int128 v48 = (const char *)dyld4::Loader::path((dyld4::Loader *)a1, a3);
      Diagnostics::error(a2, "re-export ordinal %lld in %s out of range for %s", v44, v48, (const char *)a4);
      return 0LL;
    }
  }

  LOBYTE(v72) = 0;
  uint64_t v50 = dyld4::Loader::dependent((dyld4::JustInTimeLoader *)a1, a3, (v44 - 1), (char *)&v72);
  if (!v50) {
    return 0LL;
  }
  if (a5 == 1 && v45) {
    uint64_t v57 = 0LL;
  }
  else {
    uint64_t v57 = a5;
  }
  char v58 = !v45;
  if (!a8) {
    char v58 = 1;
  }
  if ((v58 & 1) != 0) {
    return dyld4::Loader::hasExportedSymbol();
  }
  __chkstk_darwin(v50, v51, v52, v53, v57, v54, v55, v56, v66);
  char v60 = (uint64_t *)*((void *)a3 + 6);
  uint64_t v73 = (uint64_t)&v66 - ((v59 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v74 = v60;
  uint64_t v75 = 0LL;
  return dyld4::Loader::hasExportedSymbol();
}

    uint64_t v9 = *((void *)this + 38);
    if (v9)
    {
      uint64_t v7 = (dyld4::RuntimeState **)*((void *)this + 37);
      unint64_t v10 = 16 * v9;
      while (v7[1] != a2)
      {
        v7 += 2;
        v10 -= 16LL;
        if (!v10) {
          goto LABEL_10;
        }
      }

  int v11 = 0LL;
LABEL_10:
  lsl::Lock::unlock(v6);
  return v11;
}

void ___ZNK5dyld46Loader13resolveSymbolER11DiagnosticsRNS_12RuntimeStateEiPKcbbU13block_pointerFvjjRKNS0_14ResolvedSymbolEEb_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(dyld4::Loader **)(a1 + 56);
  if (*(_BYTE *)(a1 + 88)) {
    dyld4::RuntimeState::log(*(dyld4::RuntimeState **)(a1 + 64), "looking for weak-def symbol '%s':\n", v63);
  }
  uint64_t v10 = *(void *)(a1 + 64);
  unint64_t v11 = *(void *)(v10 + 328) + 1LL;
  *(void *)(v10 + 328) = v11;
  if (v11 >= 0x1389 && !*(void *)(v10 + 336))
  {
    __int128 v12 = lsl::Allocator::malloc(*(lsl::Lock ***)(v10 + 16), 0x60uLL);
    *(void *)(*(void *)(a1 + 64) + 336LL) = dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)v12);
    uint64_t v10 = *(void *)(a1 + 64);
  }

  uint64_t v13 = *(const char ***)(v10 + 336);
  if (v13
    && (uint64_t v13 = dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( (uint64_t)v13,  (uint64_t *)v13 + 2,  v13 + 7,  0LL,  (const char **)(a1 + 72)),  v13 != (const char **)(*(void *)(*(void *)(*(void *)(a1 + 64) + 336LL) + 56LL)
                             + 24LL * *(void *)(*(void *)(*(void *)(a1 + 64) + 336LL) + 72LL)))
    && (int v14 = v13[1]) != 0LL)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) = v14;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL) = *(void *)(a1 + 72);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL) = (unint64_t)v13[2] & 0x3FFFFFFFFFFFFFFFLL;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 64LL) = 0LL;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 72LL) = 1;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 76LL) = ((unint64_t)v13[2] & 0x4000000000000000LL) != 0;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 77LL) = (uint64_t)v13[2] < 0;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 78LL) = 0;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 79LL) = 0;
    if (*(_BYTE *)(a1 + 88))
    {
      uint64_t v15 = *(const dyld4::RuntimeState **)(a1 + 64);
      uint64_t v16 = *(const char **)(a1 + 72);
      uint64_t v17 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), v15);
      dyld4::RuntimeState::log(v15, "  found %s in map, using impl from %s\n", v16, v17);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

  else
  {
    __chkstk_darwin((uint64_t)v13, a2, a3, a4, a5, a6, a7, a8, (uint64_t)&v64);
    uint64_t v67 = (char *)&v64 - ((v18 + 23) & 0xFFFFFFFFFFFFFFF0LL);
    char v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    unint64_t v66 = *((void *)v19 + 6);
    if ((*((_WORD *)v9 + 2) & 2) != 0)
    {
      int hasOpcodeFixups = 0;
    }

    else
    {
      uint64_t v20 = (dyld3::MachOFile *)dyld4::Loader::mf(v9, v19);
      int hasOpcodeFixups = dyld3::MachOFile::hasOpcodeFixups(v20);
      char v19 = *(const dyld4::RuntimeState **)(a1 + 64);
    }

    uint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    v71[0] = (char *)v19 + 32;
    v71[1] = (char *)v19 + 64;
    char v65 = v67 + 8;
    do
    {
      uint64_t v24 = v71[v22];
      uint64_t v25 = *(void *)(v24 + 16);
      if (v25)
      {
        uint64_t v26 = *(dyld4::Loader ***)(v24 + 8);
        uint64_t v27 = 8 * v25;
        do
        {
          uint64_t v28 = *v26;
          if ((*((_WORD *)*v26 + 2) & 0x800) != 0
            && (dyld4::Loader::hiddenFromFlat(*v26, 0) & 1) == 0
            && dyld4::Loader::hasExportedSymbol( (uint64_t)v28,  *(vm_address_t **)(a1 + 80),  *(const dyld4::RuntimeState **)(a1 + 64),  *(const unsigned __int8 **)(a1 + 72),  1u,  1,  (uint64_t *)v68,  0LL))
          {
            int v29 = BYTE5(v70) ? 0 : hasOpcodeFixups;
            if (v29 != 1 || (*((_WORD *)v28 + 2) & 2) == 0)
            {
              if ((*(_WORD *)(*(void *)v68 + 4LL) & 2) != 0)
              {
                uint64_t hasBeenFixedUp = dyld4::Loader::hasBeenFixedUp(v28, *(dyld4::RuntimeState **)(a1 + 64));
                if ((hasBeenFixedUp & 1) == 0)
                {
                  if (v23 >= v66) {
                    dyld4::RuntimeState::appendInterposingTuples(hasBeenFixedUp, v31, v32);
                  }
                  uint64_t v33 = v69;
                  int v34 = &v67[16 * v23++];
                  *(void *)int v34 = *(void *)v68;
                  *((void *)v34 + 1) = v33;
                }
              }

              uint64_t v35 = *(void *)(*(void *)(a1 + 48) + 8LL);
              if (!*(_BYTE *)(v35 + 24))
              {
                *(_BYTE *)(v35 + 24) = 1;
                uint64_t v36 = *(void *)(*(void *)(a1 + 40) + 8LL);
                __int128 v37 = v69;
                *(_OWORD *)(v36 + 40) = *(_OWORD *)v68;
                *(_OWORD *)(v36 + 56) = v37;
                *(void *)(v36 + 72) = v70;
                if (*(_BYTE *)(a1 + 88))
                {
                  int v39 = *(const dyld4::RuntimeState **)(a1 + 64);
                  uint64_t v38 = *(const char **)(a1 + 72);
                  char v40 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v68, v39);
                  dyld4::RuntimeState::log(v39, "  using '%s' in %s\n", v38, v40);
                }
              }

              if (!BYTE5(v70))
              {
                uint64_t v41 = *(void *)(*(void *)(a1 + 40) + 8LL);
                if (*(_BYTE *)(v41 + 77))
                {
                  __int128 v42 = v69;
                  *(_OWORD *)(v41 + 40) = *(_OWORD *)v68;
                  *(_OWORD *)(v41 + 56) = v42;
                  *(void *)(v41 + 72) = v70;
                  if (*(_BYTE *)(a1 + 88))
                  {
                    unint64_t v44 = *(const dyld4::RuntimeState **)(a1 + 64);
                    uint64_t v43 = *(const char **)(a1 + 72);
                    BOOL v45 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)v68, v44);
                    dyld4::RuntimeState::log(v44, "  using non-weak '%s' in %s\n", v43, v45);
                  }
                }
              }
            }
          }

          ++v26;
          v27 -= 8LL;
        }

        while (v27);
      }

      if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)
        && dyld4::Loader::hiddenFromFlat(v9, 0))
      {
        if (*(_BYTE *)(a1 + 88))
        {
          char v47 = *(const dyld4::RuntimeState **)(a1 + 64);
          uint64_t v46 = *(const char **)(a1 + 72);
          __int128 v48 = (const char *)dyld4::Loader::path(v9, v47);
          uint64_t v49 = strrchr(v48, 47);
          if (v49) {
            uint64_t v50 = v49 + 1;
          }
          else {
            uint64_t v50 = v48;
          }
          dyld4::RuntimeState::log(v47, "  did not find unhidden '%s', trying self (%s)\n", v46, v50);
        }

        if (dyld4::Loader::hasExportedSymbol( (uint64_t)v9,  *(vm_address_t **)(a1 + 80),  *(const dyld4::RuntimeState **)(a1 + 64),  *(const unsigned __int8 **)(a1 + 72),  1u,  1,  (uint64_t *)v68,  0LL))
        {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
          uint64_t v51 = *(void *)(*(void *)(a1 + 40) + 8LL);
          __int128 v52 = v69;
          *(_OWORD *)(v51 + 40) = *(_OWORD *)v68;
          *(_OWORD *)(v51 + 56) = v52;
          *(void *)(v51 + 72) = v70;
        }
      }

      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
        BOOL v53 = v23 == 0;
      }
      else {
        BOOL v53 = 1;
      }
      if (!v53
        && (*(_WORD *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) + 4LL) & 2) == 0
        && *(void *)(a1 + 32))
      {
        uint64_t v54 = 0LL;
        uint64_t v55 = 16 * v23;
        uint64_t v56 = v65;
        do
        {
          uint64_t v57 = (dyld3::MachOFile *)dyld4::Loader::mf( *((dyld4::Loader **)v56 - 1),  *(const dyld4::RuntimeState **)(a1 + 64));
          if (dyld4::ProcessConfig::DyldCache::findMachHeaderImageIndex( (DyldSharedCache **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 240LL),  (const mach_header *)v57,  v68))
          {
            uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v57);
            uint64_t v59 = *(dyld4::RuntimeState **)(a1 + 64);
            uint64_t v60 = *(void *)v56 + Address - *(void *)(*((void *)v59 + 1) + 272LL);
            if (v60 != v54)
            {
              if (*(_BYTE *)(a1 + 88))
              {
                uint64_t v61 = *(const char **)(a1 + 72);
                uint64_t v62 = (const char *)dyld4::Loader::path( *((dyld4::Loader **)v56 - 1),  *(const dyld4::RuntimeState **)(a1 + 64));
                dyld4::RuntimeState::log(v59, "  found use of '%s' in cache, need to override: %s\n", v61, v62);
              }

              (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
              uint64_t v54 = v60;
            }
          }

          v56 += 16;
          v55 -= 16LL;
        }

        while (v55);
      }

      ++v22;
    }

    while (v22 != 2);
  }

void dyld4::Loader::tooNewErrorAddendum(dyld4::Loader *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  v11[0] = 0LL;
  v11[1] = v11;
  void v11[2] = 0x2000000000LL;
  int v12 = 0;
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  int v10 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
  v8[3] = &unk_18961FB20;
  void v8[4] = v11;
  v8[5] = v9;
  dyld3::MachOFile::forEachSupportedPlatform(&dword_180058000, (uint64_t)v8);
  uint64_t v6 = (_DWORD *)dyld4::Loader::mf(this, a3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2;
  void v7[3] = &unk_18961FB48;
  v7[4] = v11;
  v7[5] = v9;
  void v7[6] = a2;
  dyld3::MachOFile::forEachSupportedPlatform(v6, (uint64_t)v7);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v11, 8);
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke( uint64_t result, int a2, int a3)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = a3;
  return result;
}

uint64_t ___ZNK5dyld46Loader19tooNewErrorAddendumER11DiagnosticsRNS_12RuntimeStateE_block_invoke_2( uint64_t result, int a2, dyld3::MachOFile *this)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) == a2)
  {
    uint64_t v3 = result;
    if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) < this)
    {
      dyld3::MachOFile::packedVersionToString(this, v6, (char *)this);
      uint64_t v4 = *(vm_address_t **)(v3 + 48);
      uint64_t v5 = dyld3::MachOFile::platformName(*(_DWORD *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL));
      return Diagnostics::error(v4, " (built for %s %s which is newer than running OS)", v5, v6);
    }
  }

  return result;
}

const dyld4::RuntimeState *dyld4::Loader::resolvedAddress(const dyld4::RuntimeState *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 32);
  if (v2 < 2) {
    return (const dyld4::RuntimeState *)(*(void *)(a2 + 16) + dyld4::Loader::loadAddress( *(dyld4::Loader **)a2,  result));
  }
  if (v2 == 2) {
    return *(const dyld4::RuntimeState **)(a2 + 16);
  }
  return result;
}

dyld4::RuntimeState *dyld4::Loader::interpose( dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::Loader *a3, const dyld4::Loader *a4)
{
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v6 = *((void *)this + 30);
    if (v6)
    {
      uint64_t v7 = (dyld4::RuntimeState **)*((void *)this + 29);
      uint64_t v8 = 16 * v6;
      while (v7[1] != a2)
      {
        v7 += 2;
        v8 -= 16LL;
        if (!v8) {
          goto LABEL_6;
        }
      }

      goto LABEL_21;
    }

LABEL_21:
      uint64_t v11 = *((void *)this + 1);
      goto LABEL_22;
    }

    Diagnostics::error(a2, "fat header malformed, architecture slices extend beyond end of file");
    return;
  }

  if (*(_DWORD *)this != -1095041334)
  {
    Diagnostics::error(a2, "not a fat file");
    return;
  }

  uint64_t v8 = *((_DWORD *)this + 1);
  uint64_t v9 = bswap32(v8);
  if (v9 >= 0xCD)
  {
    Diagnostics::error(a2, "fat header too large: %u entries", v9);
    return;
  }

  char v40 = 0;
  if (!v8) {
    goto LABEL_34;
  }
  uint64_t v33 = v8;
  uint64_t v12 = 0LL;
  uint64_t v13 = (unsigned int *)((char *)this + 20);
  while (1)
  {
    uint64_t v14 = bswap32(*(v13 - 3));
    uint64_t v15 = bswap32(*(v13 - 2));
    uint64_t v16 = bswap32(*(v13 - 1));
    uint64_t v17 = bswap32(*v13);
    Diagnostics::Diagnostics((Diagnostics *)&v39);
    if (!a4 || dyld3::FatFile::isValidSlice(this, (vm_address_t *)&v39, a3, v12, v14, v15, v16, v17)) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))( a5,  v14,  v15,  (char *)this + v16,  v17,  &v40);
    }
    if (v40) {
      break;
    }
    if (Diagnostics::hasError((Diagnostics *)&v39))
    {
      uint64_t v18 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v39);
      Diagnostics::appendError(a2, "%s, ", v18);
    }

    v13 += 5;
    mach_o::Error::~Error(&v39);
    if (v9 == ++v12) {
      goto LABEL_33;
    }
  }

  mach_o::Error::~Error(&v39);
LABEL_33:
  if (v33 != -872415232)
  {
LABEL_34:
    uint64_t v27 = (char *)this + 8;
    uint64_t v28 = (_DWORD *)((char *)this + 20 * v9 + 8);
    int v29 = bswap32(v28[1]);
    if (*v28 == 201326593 && v29 <= 1)
    {
      uint64_t v31 = bswap32(*(_DWORD *)&v27[20 * v9 + 12]);
      uint64_t v32 = bswap32(*(_DWORD *)&v27[20 * v9 + 8]);
      if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v9, 16777228, v29, v32, v31)) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))( a5,  16777228LL,  v29,  (char *)this + v32,  v31,  &v40);
      }
    }
  }

    __n128 result = Diagnostics::error( *(vm_address_t **)(v5 + 64),  "initializer 0x%0X does not point within executable segment");
  }

  *a4 = 1;
  return result;
}

  if (!v6)
  {
    uint64_t v9 = "unknown";
    if (v7) {
      goto LABEL_23;
    }
LABEL_25:
    uint64_t v10 = "unknown";
    goto LABEL_26;
  }

        mach_msg_destroy(&v13);
        return v8;
      }

      mig_dealloc_reply_port(v13.msgh_local_port);
    }
  }

  return v8;
}

LABEL_22:
        if (!*(_BYTE *)(v11 + 206)) {
          return *v7;
        }
        uint64_t v16 = *v7;
        if (!a3)
        {
          uint64_t v17 = "dlsym";
          goto LABEL_26;
        }

  if (a4)
  {
    if (v13) {
      return kdebug_trace_string(a2, v13, 0LL, v28, v29, v30, v31, v32);
    }
  }

  return result;
}

      __n128 result = Diagnostics::error( *(vm_address_t **)(v5 + 56),  "initializer 0x%08X is not an offset to an executable segment");
      goto LABEL_6;
    }
  }

  return result;
}

  uint64_t v9 = *(const char **)(v6 + 16);
  if (!v7) {
    goto LABEL_25;
  }
LABEL_23:
  uint64_t v10 = *(const char **)(v7 + 16);
LABEL_26:
  mach_o::Error::Error(a3, "incompatible platforms: %s - %s", v9, v10);
}

    mach_msg_destroy(&v16);
    goto LABEL_23;
  }

  uint64_t v12 = v8;
LABEL_24:
  *vm_address_t address = v9;
  return v12;
}

uint64_t ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke( uint64_t a1, const mach_o::Layout *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (dyld3::MachOFile ***)mach_o::SymbolTable::SymbolTable(&v12, a2);
  uint64_t v5 = *(void *)(a1 + 48);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke_2;
  v8[3] = &unk_18961FB70;
  __int128 v9 = *(_OWORD *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 72);
  uint64_t v11 = v6;
  void v8[4] = *(void *)(a1 + 32);
  v8[5] = v3;
  return mach_o::SymbolTable::forEachGlobalSymbol(v4, v5, (uint64_t)v8);
}

dyld4::RuntimeState *___ZNK5dyld46Loader17hasExportedSymbolER11DiagnosticsRNS_12RuntimeStateEPKcNS0_18ExportedSymbolModeENS0_12ResolverModeEPNS0_14ResolvedSymbolEPN5dyld35ArrayIPKS0_EE_block_invoke_2( dyld4::RuntimeState *result, char *__s1, uint64_t a3, int a4, uint64_t a5, char a6, _BYTE *a7)
{
  if ((~a4 & 0xF) == 0)
  {
    uint64_t v10 = (uint64_t)result;
    uint64_t v11 = *((void *)result + 5);
    __n128 result = (dyld4::RuntimeState *)_platform_strcmp(__s1, *((const char **)result + 6));
    if (!(_DWORD)result)
    {
      uint64_t v12 = *(dyld3::MachOFile **)(v10 + 64);
      **(void **)(v10 + 56) = v11;
      *(void *)(*(void *)(v10 + 56) + 8LL) = *(void *)(v10 + 48);
      uint64_t Address = dyld3::MachOFile::preferredLoadAddress(v12);
      uint64_t v14 = *(void *)(v10 + 56);
      *(void *)(v14 + 16) = a3 - Address;
      *(_DWORD *)(v14 + 32) = 1;
      *(_BYTE *)(v14 + 36) = 0;
      *(_BYTE *)(v14 + 37) = a6 < 0;
      *(_WORD *)(v14 + 38) = 0;
      uint64_t v15 = dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(v10 + 72), v14);
      *(void *)(*(void *)(v10 + 56) + 24LL) = v15;
      __n128 result = dyld4::Loader::interpose(*(dyld4::Loader **)(v10 + 72), v15, 0LL, v16);
      *(void *)(*(void *)(v10 + 56) + 24LL) = result;
      *a7 = 1;
      *(_BYTE *)(*(void *)(*(void *)(v10 + 32) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

void dyld4::Loader::applyInterposingToDyldCache(dyld4::Loader *this, dyld4::RuntimeState *a2)
{
  unsigned int v2 = *(DyldSharedCache **)(*((void *)this + 1) + 240LL);
  if (v2 && *((void *)this + 22))
  {
    dyld4::DyldCacheDataConstScopedWriter::DyldCacheDataConstScopedWriter( (dyld4::DyldCacheDataConstScopedWriter *)v18,  this);
    dyld4::RuntimeState::setVMAccountingSuspending(this, 1);
    uint64_t v4 = *((void *)this + 22);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 21);
      uint64_t v6 = 16 * v4;
      do
      {
        uint64_t v7 = *(void *)(v5 + 8) - (void)v2;
        if (DyldSharedCache::addressInText(v2, v7, &v17))
        {
          uint64_t IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(v2, v17, &v16, &v15);
          if (IndexedImageEntry)
          {
            __int128 v9 = (dyld3::MachOFile *)IndexedImageEntry;
            int v10 = DyldSharedCache::unslidLoadAddress(v2) + v7;
            int Address = dyld3::MachOFile::preferredLoadAddress(v9);
            v12[0] = _NSConcreteStackBlock;
            v12[1] = 0x40000000LL;
            v12[2] = ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke;
            v12[3] = &__block_descriptor_tmp_152;
            v12[4] = v5;
            v12[5] = v2;
            int v13 = v10 - Address;
            unsigned int v14 = v17;
            v12[6] = this;
            DyldSharedCache::forEachPatchableExport(v2, v17, (uint64_t)v12);
          }
        }

        v5 += 16LL;
        v6 -= 16LL;
      }

      while (v6);
    }

    dyld4::RuntimeState::setVMAccountingSuspending(this, 0);
    dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v18);
  }

dyld3::MachOFile *___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke( dyld3::MachOFile *result, unsigned int a2, uint64_t a3)
{
  if (*((_DWORD *)result + 14) == a2)
  {
    uint64_t v4 = (dyld3::MachOFile *)*((void *)result + 5);
    uint64_t v5 = **((void **)result + 4);
    unsigned int v6 = *((_DWORD *)result + 15);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000LL;
    v7[2] = ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke_2;
    void v7[3] = &__block_descriptor_tmp_150;
    v7[4] = v4;
    v7[5] = v5;
    void v7[6] = *((void *)result + 6);
    void v7[7] = a3;
    return DyldSharedCache::forEachPatchableUseOfExport(v4, v6, a2, (uint64_t)v7);
  }

  return result;
}

void ___ZN5dyld46Loader27applyInterposingToDyldCacheERNS_12RuntimeStateE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (uint64_t *)(*(void *)(a1 + 32) + a2);
  uint64_t v6 = *(void *)(a1 + 40) + a4;
  uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 48);
  if (*(_BYTE *)(*((void *)v7 + 1) + 206LL)) {
    dyld4::RuntimeState::log( v7,  "interpose: *%p = 0x%0llX (dyld cache patch) to %s\n",  v5,  v6,  *(const char **)(a1 + 56));
  }
  *uint64_t v5 = v6;
}

void dyld4::Loader::applyCachePatchesToOverride( uint64_t a1, const dyld4::RuntimeState *a2, dyld4::Loader *this, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(DyldSharedCache **)(*((void *)a2 + 1) + 240LL);
  uint64_t Address = dyld4::Loader::loadAddress(this, a2);
  int v14 = *((_WORD *)this + 3) & 0x7FFF;
  if (DyldSharedCache::shouldPatchClientOfImage(v12, a4, v14))
  {
    uint64_t v22 = 0LL;
    unint64_t v23 = &v22;
    uint64_t v24 = 0x2000000000LL;
    char v25 = 0;
    uint64_t v18 = 0LL;
    char v19 = &v18;
    uint64_t v20 = 0x2000000000LL;
    uint64_t v21 = a5;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000LL;
    v15[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    v15[3] = &unk_18961FC28;
    v15[6] = a1;
    void v15[7] = a2;
    __int16 v17 = a4;
    int v16 = v14;
    v15[8] = v12;
    v15[9] = a6;
    v15[4] = &v18;
    void v15[5] = &v22;
    v15[10] = Address;
    v15[11] = this;
    DyldSharedCache::forEachPatchableExport(v12, a4, (uint64_t)v15);
    if (*(void *)v19[3] != -1LL) {
      dyld4::Loader::applyCachePatchesToOverride();
    }
    if (*((_BYTE *)v23 + 24)) {
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    }
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke( uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  __int128 v9 = *(uint64_t **)(v8 + 24);
  *(void *)(v8 + 24) = v9 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v9) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }

    uint64_t v10 = *v9;
    if (*v9 == 2) {
      return;
    }
LABEL_4:
    if (v10)
    {
LABEL_5:
      uint64_t v11 = *v9 + dyld4::Loader::loadAddress(v7, *(const dyld4::RuntimeState **)(a1 + 56));
LABEL_10:
      unsigned int v12 = *(unsigned __int16 *)(a1 + 100);
      int v13 = *(_DWORD *)(a1 + 96);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000LL;
      v17[2] = ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v17[3] = &unk_18961FC00;
      v17[4] = *(void *)(a1 + 40);
      _WORD v17[5] = v7;
      uint64_t v15 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 64);
      uint64_t v16 = *(void *)(a1 + 80);
      v17[6] = *(void *)(a1 + 72);
      v17[7] = v15;
      v17[8] = v16;
      void v17[9] = v11;
      __int16 v18 = v12;
      v17[10] = v14;
      v17[11] = a3;
      v17[12] = *(void *)(a1 + 88);
      v17[13] = v9;
      DyldSharedCache::forEachPatchableUseOfExportInImage(v14, v12, a2, v13, (uint64_t)v17);
      return;
    }

void ___ZNK5dyld46Loader27applyCachePatchesToOverrideERNS_12RuntimeStateEPKS0_tPKNS0_10DylibPatchERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  __int128 v9 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = (uint64_t *)(*(void *)(a1 + 64) + a2);
  uint64_t v12 = *(void *)(a1 + 72);
  if ((a5 & (v12 == 195903495)) != 0) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = v12 + a4;
  }
  uint64_t v14 = *(void *)(v10 + 176);
  if (v14)
  {
    uint64_t v15 = *(void *)(v10 + 168);
    uint64_t v16 = 16 * v14;
    __int16 v17 = (void *)(v15 + 8);
    do
    {
      if (*v17 == v13) {
        uint64_t v13 = *(v17 - 1);
      }
      v17 += 2;
      v16 -= 16LL;
    }

    while (v16);
  }

  if ((a5 & 1) == 0 && v12 == 195903495)
  {
    IndexedImagePath = (const char *)DyldSharedCache::getIndexedImagePath( *(DyldSharedCache **)(a1 + 80),  *(unsigned __int16 *)(a1 + 112));
    char v19 = *(const dyld4::RuntimeState **)(a1 + 56);
    uint64_t v20 = *(const char **)(a1 + 88);
    uint64_t v21 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), v19);
    dyld4::RuntimeState::log( v19,  "symbol '%s' missing from root that overrides %s. Use of that symbol in %s is being set to 0xBAD4007.\n",  v20,  IndexedImagePath,  v21);
  }

  if (*v11 != v13)
  {
    *uint64_t v11 = v13;
    uint64_t v22 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((void *)v22 + 1) + 202LL))
    {
      uint64_t v23 = a2;
      uint64_t v24 = (const char *)dyld4::Loader::path(*(dyld4::Loader **)(a1 + 96), *(const dyld4::RuntimeState **)(a1 + 56));
      char v25 = strrchr(v24, 47);
      if (v25) {
        uint64_t v24 = v25 + 1;
      }
      uint64_t v26 = (const char *)dyld4::Loader::path(v9, *(const dyld4::RuntimeState **)(a1 + 56));
      uint64_t v27 = strrchr(v26, 47);
      if (v27) {
        uint64_t v28 = v27 + 1;
      }
      else {
        uint64_t v28 = v26;
      }
      dyld4::RuntimeState::log( v22,  "cache fixup: *0x%012lX = 0x%012lX (*%s+0x%012lX = %s+0x%012lX)\n",  v11,  v13,  v24,  v23,  v28,  **(void **)(a1 + 104));
    }
  }

void dyld4::Loader::applyCachePatchesTo( dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld4::Loader *a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4)
{
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v12, &v13))
  {
    if (v12) {
      dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, (unsigned __int16)v13, v12, (uint64_t)a4);
    }
    if ((*((_WORD *)this + 2) & 1) == 0)
    {
      if (*(_BYTE *)(*((void *)a2 + 1) + 157LL))
      {
        uint64_t CatalystMacTwinPatches = dyld4::JustInTimeLoader::getCatalystMacTwinPatches(this);
        if (CatalystMacTwinPatches)
        {
          uint64_t v10 = CatalystMacTwinPatches;
          unsigned int v11 = dyld4::Loader::indexOfUnzipperedTwin(a2, (const dyld4::RuntimeState *)(unsigned __int16)v13, v9);
          if (v11 != 0xFFFF) {
            dyld4::Loader::applyCachePatchesToOverride((uint64_t)this, a2, a3, v11, v10, (uint64_t)a4);
          }
        }
      }
    }
  }

uint64_t dyld4::Loader::indexOfUnzipperedTwin(dyld4::Loader *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (!*(_BYTE *)(v3 + 157)) {
    return (unsigned __int16)-1;
  }
  uint64_t v5 = *((void *)this + 120);
  if (!v5)
  {
    IndexedImagePath = (const char *)dyld4::ProcessConfig::DyldCache::getIndexedImagePath( (DyldSharedCache **)(v3 + 240),  (int)a2);
    if (!_platform_strncmp(IndexedImagePath, "/System/iOSSupport/", 0x13uLL)
      && (dyld4::ProcessConfig::DyldCache::indexOfPath( (DyldSharedCache **)(*((void *)this + 1) + 240LL),  IndexedImagePath + 18,  &v10) & 1) != 0)
    {
      return (unsigned __int16)v10;
    }

    return (unsigned __int16)-1;
  }

  uint64_t v6 = (_WORD *)(v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4LL * a2));
  if ((v6[2] & 1) == 0 || (v6[22] & 4) == 0) {
    return (unsigned __int16)-1;
  }
  return (unsigned __int16)v6[30];
}

void dyld4::Loader::applyCachePatches( dyld4::Loader *this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  if (dyld4::Loader::overridesDylibInCache((uint64_t)this, &v17, &v18) && v17)
  {
    uint64_t v6 = *(dyld3::MachOFile **)(*((void *)a2 + 1) + 240LL);
    uint64_t v13 = 0LL;
    uint64_t v14 = &v13;
    uint64_t v15 = 0x2000000000LL;
    char v16 = 0;
    uint64_t v9 = 0LL;
    unsigned int v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    uint64_t v12 = v17;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000LL;
    v7[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
    void v7[3] = &unk_18961FC78;
    void v7[6] = this;
    void v7[7] = a2;
    unsigned __int16 v8 = v18;
    void v7[8] = v6;
    void v7[9] = a3;
    v7[4] = &v9;
    v7[5] = &v13;
    DyldSharedCache::forEachPatchableExport(v6, v18, (uint64_t)v7);
    if (*(void *)v10[3] != -1LL) {
      dyld4::Loader::applyCachePatches();
    }
    if (*((_BYTE *)v14 + 24)) {
      dyld4::RuntimeState::setVMAccountingSuspending(a2, 0);
    }
    _Block_object_dispose(&v9, 8);
    _Block_object_dispose(&v13, 8);
  }

uint64_t ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke( uint64_t result, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v5 = result;
  uint64_t v6 = *(dyld4::Loader **)(result + 48);
  uint64_t v7 = *(void *)(*(void *)(result + 32) + 8LL);
  unsigned __int16 v8 = *(uint64_t **)(v7 + 24);
  *(void *)(v7 + 24) = v8 + 1;
  if (a4 != 8)
  {
    if (a4 != 1)
    {
      if (*v8) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }

    uint64_t v9 = *v8;
    if (*v8 == 2) {
      return result;
    }
LABEL_4:
    if (v9)
    {
LABEL_5:
      uint64_t v10 = *v8 + dyld4::Loader::loadAddress(v6, *(const dyld4::RuntimeState **)(result + 56));
LABEL_10:
      unsigned int v11 = *(unsigned __int16 *)(v5 + 80);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 0x40000000LL;
      v15[2] = ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      v15[3] = &unk_18961FC50;
      uint64_t v12 = *(void *)(v5 + 64);
      uint64_t v13 = *(void *)(v5 + 72);
      v15[4] = *(void *)(v5 + 40);
      void v15[5] = v6;
      uint64_t v14 = *(void *)(v5 + 56);
      v15[6] = v13;
      void v15[7] = v14;
      v15[8] = v12;
      v15[9] = v10;
      v15[10] = v8;
      return DyldSharedCache::forEachPatchableGOTUseOfExport(v12, v11, a2, (uint64_t)v15);
    }

void ___ZNK5dyld46Loader17applyCachePatchesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t v9 = *(dyld4::Loader **)(a1 + 40);
  dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 48));
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    dyld4::RuntimeState::setVMAccountingSuspending(*(dyld4::RuntimeState **)(a1 + 56), 1);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  uint64_t v10 = *(void *)(a1 + 72);
  unsigned int v11 = (uint64_t *)(*(void *)(a1 + 64) + a2);
  if ((a5 & (v10 == 195903495)) != 0) {
    uint64_t v12 = 0LL;
  }
  else {
    uint64_t v12 = v10 + a4;
  }
  if (*v11 != v12)
  {
    *unsigned int v11 = v12;
    uint64_t v13 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((void *)v13 + 1) + 202LL))
    {
      uint64_t v14 = (const char *)dyld4::Loader::path(v9, *(const dyld4::RuntimeState **)(a1 + 56));
      uint64_t v15 = strrchr(v14, 47);
      if (v15) {
        char v16 = v15 + 1;
      }
      else {
        char v16 = v14;
      }
      dyld4::RuntimeState::log( v13,  "cache GOT fixup: *0x%012lX = 0x%012lX (*cache+0x%012lX = %s+0x%012lX)\n",  v11,  v12,  a2,  v16,  **(void **)(a1 + 80));
    }
  }

uint64_t dyld4::Loader::getOnDiskBinarySliceOffset( dyld4::Loader *this, dyld4::RuntimeState *a2, const dyld3::MachOAnalyzer *a3, const char *a4)
{
  uint64_t v15 = 0LL;
  char v16 = &v15;
  uint64_t v17 = 0x3002000000LL;
  unsigned __int16 v18 = __Block_byref_object_copy__164_0;
  char v19 = __Block_byref_object_dispose__165_0;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  uint64_t v7 = *((void *)this + 1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  v10[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke;
  v10[3] = &unk_18961FCC8;
  v10[5] = &v11;
  void v10[6] = a2;
  v10[4] = &v15;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v7, (vm_address_t *)v16 + 5, a3, 0, (uint64_t)v10);
  uint64_t v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
  return v8;
}

uint64_t __Block_byref_object_copy__164_0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__165_0(uint64_t a1)
{
}

void ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke( uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  uint64_t v6 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(this, this);
  if (v6)
  {
    uint64_t v7 = (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000LL;
    v8[2] = ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2;
    v8[3] = &unk_18961FCA0;
    __int128 v9 = *(_OWORD *)(a1 + 40);
    uint64_t v10 = this;
    dyld3::FatFile::forEachSlice(v6, v7, a3, (uint64_t)v8);
  }

uint64_t ___ZN5dyld46Loader26getOnDiskBinarySliceOffsetERNS_12RuntimeStateEPKN5dyld313MachOAnalyzerEPKc_block_invoke_2( uint64_t a1, int a2, int a3, char *__s2, uint64_t a5, _BYTE *a6)
{
  uint64_t result = _platform_memcmp(*(const void **)(a1 + 40), __s2, 0x40uLL);
  if (!(_DWORD)result)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = &__s2[-*(void *)(a1 + 48)];
    *a6 = 1;
  }

  return result;
}

void dyld4::Loader::recursivelyLogChainToLinksWith( dyld4::Loader *a1, dyld4::RuntimeState *a2, const char *a3, dyld4::Loader *a4, uint64_t *a5, void *a6, uint64_t *a7)
{
  if (a1 == a4)
  {
    dyld4::RuntimeState::printLinkageChain(a2, a5, a3);
  }

  else
  {
    uint64_t v14 = a7[2];
    if (v14)
    {
      uint64_t v15 = (dyld4::Loader **)*a7;
      uint64_t v16 = 8 * v14;
      while (*v15 != a1)
      {
        ++v15;
        v16 -= 8LL;
        if (!v16) {
          goto LABEL_6;
        }
      }
    }

    else
    {
LABEL_6:
      v21[0] = (uint64_t)a1;
      dyld3::Array<dyld4::Loader const*>::push_back(a7, v21, (uint64_t)a3);
      int v17 = dyld4::Loader::dependentCount(a1);
      if (v17)
      {
        int v18 = v17;
        uint64_t v19 = 0LL;
        do
        {
          char v23 = 0;
          uint64_t v20 = dyld4::Loader::dependent(a1, a2, v19, &v23);
          if (v20)
          {
            v21[0] = 0LL;
            v21[1] = v20;
            char v22 = v23;
            *a6 = v21;
            dyld4::Loader::recursivelyLogChainToLinksWith(v20, a2, a3, a4, a5, v21, a7);
          }

          uint64_t v19 = (v19 + 1);
        }

        while (v18 != (_DWORD)v19);
      }
    }
  }

void dyld4::Loader::logChainToLinksWith(dyld4::Loader *this, dyld4::RuntimeState *a2, const char *a3)
{
  uint64_t v6 = *((void *)a2 + 6);
  if (v6)
  {
    uint64_t v7 = (dyld4::Loader **)*((void *)a2 + 5);
    uint64_t v8 = 8 * v6;
    while (1)
    {
      __int128 v9 = *v7;
      uint64_t v10 = *((void *)a2 + 1);
      uint64_t v12 = *(const void **)(v10 + 224);
      size_t v11 = *(void *)(v10 + 232);
      uint64_t v13 = (const char *)dyld4::Loader::path(*v7, a2);
      uint64_t v14 = strrchr(v13, 47);
      if (v14) {
        uint64_t v13 = v14 + 1;
      }
      if (v11 == _platform_strlen(v13))
      {
        uint64_t v15 = _platform_memcmp(v12, v13, v11);
        if (!(_DWORD)v15) {
          break;
        }
      }

      ++v7;
      v8 -= 8LL;
      if (!v8) {
        goto LABEL_8;
      }
    }

    if (v9) {
      goto LABEL_19;
    }
  }

uint64_t dyld4::dyld_map_with_linking_np( dyld4 *this, const mwl_region *a2, unsigned int a3, const mwl_info_hdr *a4, const unsigned int *a5)
{
  if (*(_DWORD *)this != 7) {
    return 0xFFFFFFFFLL;
  }
  int v6 = *((_DWORD *)this + 2);
  int v7 = *((_DWORD *)this + 3);
  if (*((_WORD *)this + 3) == 3) {
    char v8 = 2;
  }
  else {
    char v8 = 3;
  }
  if ((v7 << v8) + v6 > a2)
  {
    fprintf(__stderrp, "bind table extends past blob, blobSize=%d, offset=%d, count=%d\n", (_DWORD)a2, v6, v7);
    return 0xFFFFFFFFLL;
  }

  uint64_t v9 = *((unsigned int *)this + 4);
  size_t v11 = (char *)this + v9;
  unint64_t v12 = *(unsigned int *)((char *)this + v9);
  if ((_DWORD)v12)
  {
    uint64_t v13 = 0LL;
    uint64_t v36 = v11;
    while (1)
    {
      uint64_t v14 = *(unsigned int *)&v11[4 * v13 + 4];
      if ((_DWORD)v14)
      {
        uint64_t v15 = &v11[v14];
        if (*(_WORD *)&v11[v14 + 20]) {
          break;
        }
      }

LABEL_33:
      if (++v13 >= v12) {
        return 0LL;
      }
    }

    int v16 = 0;
    uint64_t v17 = *((void *)v15 + 1) + *((void *)this + 4);
    while (1)
    {
      uint64_t v18 = *((unsigned int *)this + 4);
      uint64_t v19 = (char *)this + v18;
      uint64_t v20 = *(unsigned int *)((char *)this + v18);
      if (!(_DWORD)v20) {
LABEL_35:
      }
        dyld4::dyld_map_with_linking_np();
      unint64_t v21 = v17 + v16 * *((unsigned __int16 *)this + 2);
      uint64_t v22 = v18 + 4;
      while (1)
      {
        uint64_t v23 = &v19[*(unsigned int *)((char *)this + v22)];
        unint64_t v24 = *((void *)v23 + 1) + *((void *)this + 4);
        if (v24 <= v21
          && v24 + *((unsigned __int16 *)v23 + 10) * (unint64_t)*((unsigned __int16 *)v23 + 2) > v21)
        {
          break;
        }

        v22 += 4LL;
        if (!--v20) {
          goto LABEL_35;
        }
      }

      int v25 = *((unsigned __int16 *)this + 3);
      unint64_t v26 = (v21 - v24) / *((unsigned __int16 *)v23 + 2);
      if (v25 == 6) {
        break;
      }
      if (v25 == 3)
      {
        uint64_t v31 = *(unsigned __int16 *)&v23[2 * v26 + 22];
        if ((_DWORD)v31 != 0xFFFF)
        {
          uint64_t v32 = *((unsigned int *)this + 2);
          uint64_t v33 = (const dyld_chained_starts_in_segment *)((char *)this + v32);
          if ((v31 & 0x8000) != 0)
          {
            int v34 = v31 & 0x7FFF;
            do
            {
              __int16 v35 = *(_WORD *)&v23[2 * v34 + 22];
              dyld4::fixupChain32( (_DWORD *)(v21 + (v35 & 0x7FFF)),  (unsigned int *)this,  (const mwl_info_hdr *)v23,  v33,  a5);
              ++v34;
            }

            while ((v35 & 0x8000) == 0);
          }

          else
          {
            dyld4::fixupChain32( (_DWORD *)(v21 + v31),  (unsigned int *)this,  (const mwl_info_hdr *)v23,  (const dyld_chained_starts_in_segment *)((char *)this + v32),  a5);
          }
        }

        goto LABEL_31;
      }

      if (v25 == 2)
      {
        uint64_t v27 = v17 + v16 * *((unsigned __int16 *)this + 2);
        uint64_t v28 = this;
        int v29 = (const mwl_info_hdr *)v23;
        int v30 = 0;
LABEL_25:
        dyld4::fixupPage64(v27, v28, v29, (const dyld_chained_starts_in_segment *)v26, v30);
      }

    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1LL);
    uint64_t v10 = 0LL;
    uint64_t v31 = v35++;
    *(_DWORD *)(v34[0] + 4 * v31) = v28;
    uint64_t v33 = (const unsigned __int8 **)((char *)a2 + v28);
    break;
  }

uint64_t dyld4::fixupPage64( uint64_t this, _DWORD *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, int a5)
{
  uint64_t v5 = *((unsigned __int16 *)&a3->mwli_chains_size + a4 + 1);
  if (v5 != 0xFFFF)
  {
    int v6 = (char *)a2 + a2[2];
    int v7 = (uint64_t *)(this + v5);
    uint64_t v8 = 6LL;
    if (a5) {
      uint64_t v8 = 8LL;
    }
    uint64_t v9 = *(void *)&a2[v8];
    do
    {
      unint64_t v10 = *v7;
      if (*v7 < 0)
      {
        unsigned int v12 = a2[3];
        if ((v10 & 0xFFFFFF) >= v12) {
          return fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v10 & 0xFFFFFF, v12);
        }
        uint64_t v11 = *(void *)&v6[8 * (v10 & 0xFFFFFF)] + BYTE3(v10);
      }

      else
      {
        uint64_t v11 = (v10 & 0xFFFFFFFFFLL) + v9 + (v10 >> 36 << 56);
      }

      uint64_t v13 = (v10 >> 51) & 0xFFF;
      *int v7 = v11;
      int v7 = (uint64_t *)((char *)v7 + 4 * v13);
    }

    while (v13);
  }

  return this;
}

_DWORD *dyld4::fixupChain32( _DWORD *this, unsigned int *a2, const mwl_info_hdr *a3, const dyld_chained_starts_in_segment *a4, const unsigned int *a5)
{
  while (1)
  {
    unint64_t v5 = *this;
    if ((v5 & 0x80000000) != 0) {
      break;
    }
    int v6 = v5 & 0x3FFFFFF;
    uint32_t mwli_chains_offset = a3->mwli_chains_offset;
    if ((v5 & 0x3FFFFFF) <= mwli_chains_offset)
    {
      unsigned int v10 = a2[6];
      goto LABEL_7;
    }

    int v8 = v6 - ((mwli_chains_offset + 0x4000000) >> 1);
LABEL_8:
    uint64_t v11 = (v5 >> 26) & 0x1F;
    *this = v8;
    this += v11;
    if (!(_DWORD)v11) {
      return this;
    }
  }

  unsigned int v9 = a2[3];
  if ((v5 & 0xFFFFF) < v9)
  {
    unsigned int v10 = (v5 >> 20) & 0x3F;
    int v6 = *(&a4->size + (v5 & 0xFFFFF));
LABEL_7:
    int v8 = v6 + v10;
    goto LABEL_8;
  }

  return (_DWORD *)fprintf(__stderrp, "out of range bind ordinal %u (max %u)", v5 & 0xFFFFF, v9);
}

void dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(dyld4::RuntimeState &)const::$_0::operator()( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v42[0] = (uint64_t)v39 - v10;
  v42[1] = v9;
  uint64_t v43 = 0LL;
  __chkstk_darwin(v11, v12, v13, v14, v15, v16, v17, v18, v39[0]);
  v41[0] = (uint64_t)v39 - ((v19 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  v41[1] = v20;
  v41[2] = 0LL;
  dyld4::Loader::runInitializersBottomUp(v21, v22, v42, v41);
  __chkstk_darwin(v23, v24, v25, v26, v27, v28, v29, v30, v39[0]);
  v39[0] = (uint64_t)v39 - v32;
  v39[1] = v31;
  uint64_t v40 = 0LL;
  if (v43)
  {
    uint64_t v33 = (dyld4::Loader **)v42[0];
    uint64_t v34 = 8 * v43;
    do
    {
      __int16 v35 = *v33++;
      dyld4::Loader::runInitializersBottomUp(v35, (dyld4::RuntimeState *)*a1, v39, v41);
      v34 -= 8LL;
    }

    while (v34);
    if (v40)
    {
      uint64_t v43 = 0LL;
      uint64_t v36 = (dyld4::Loader **)v39[0];
      uint64_t v37 = 8 * v40;
      do
      {
        uint64_t v38 = *v36++;
        dyld4::Loader::runInitializersBottomUp(v38, (dyld4::RuntimeState *)*a1, v42, v41);
        v37 -= 8LL;
      }

      while (v37);
    }
  }

const char **dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return (const char **)*a3;
  }
  int v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  uint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  unint64_t v13 = a2[2];
  unint64_t v14 = v13 - 1;
  unint64_t v15 = v10 & (v13 - 1);
  if (v13 <= v15) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v10,  v11,  v12);
  uint64_t v16 = *a2;
  unint64_t v17 = a3[2];
  uint64_t v18 = *a3;
  uint64_t v19 = 1LL;
  uint64_t v20 = *a5;
  while (1)
  {
    unint64_t v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1) {
      return (const char **)(v18 + 24 * v17);
    }
    if (v17 <= v21) {
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    }
    uint64_t v22 = (const char **)(v18 + 24LL * v21);
    uint64_t v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10) {
      return v22;
    }
    unint64_t v23 = v15 + v19++;
    unint64_t v15 = v23 & v14;
    if (v13 <= (v23 & v14)) {
      goto LABEL_8;
    }
  }

uint64_t dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::insert( uint64_t a1, __int128 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v28, 0, sizeof(v28));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v28, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v28, 1LL);
      uint64_t v6 = (*(void *)&v28[1])++;
      *(_DWORD *)(*(void *)&v28[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        int v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        size_t v9 = _platform_strlen(v8);
        unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v30, (uint64_t *)v8, v9);
        unint64_t v11 = (*(void *)&v28[1] - 1LL) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1)
        {
          uint64_t v12 = 1LL;
          do
            unint64_t v11 = (*(void *)&v28[1] - 1LL) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v28, v11) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v28)
    {
      *(void *)&v28[1] = 0LL;
      if (*((void *)&v28[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v28[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v13 = *(void *)(a1 + 40);
      if (v13) {
        vm_deallocate(mach_task_self_, v13, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v28[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v28 + 8);
      vm_size_t v14 = size;
      *(void *)(a1 + 40) = *((void *)&v28[1] + 1);
      *(void *)(a1 + 48) = v14;
    }
  }

  unint64_t v15 = *(char **)a2;
  size_t v16 = _platform_strlen(*(const char **)a2);
  unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( (uint64_t)v28,  (uint64_t *)v15,  v16);
  unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    uint64_t v21 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v21;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v23 + 1;
    uint64_t v24 = v22 + 24 * v23;
    __int128 v25 = *a2;
    *(void *)(v24 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v24 = v25;
    uint64_t v26 = *(void *)(a1 + 72);
    if (!v26) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 24 * v26 - 24;
  }

  else
  {
    uint64_t v19 = 1LL;
    while (1)
    {
      uint64_t v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      if (!_platform_strcmp(*v20, *(const char **)a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & (v17 + v19++);
      unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1) {
        goto LABEL_20;
      }
    }
  }

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::reserve( a1,  a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 24 * a2;
}

uint64_t dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 4 * a2;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 24 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    uint64_t result = memmove((void *)v4[3], *v4, 24LL * (void)v4[2]);
    unint64_t v12 = (unint64_t)v4[4] / 0x18;
    dyld3::MachOFile *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

mach_o::Error *mach_o::Error::Error(mach_o::Error *this, char *__s, ...)
{
  *(void *)this = 0LL;
  vm_address_t v4 = _simple_salloc();
  *(void *)this = v4;
  _simple_vsprintf(v4, __s, (int *)va);
  return this;
}

void mach_o::Error::~Error(vm_address_t **this)
{
  unint64_t v2 = *this;
  if (v2) {
    _simple_sfree(v2);
  }
  *this = 0LL;
}

uint64_t dyld4::JustInTimeLoader::mf(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2)
{
  return *((void *)this + 4);
}

uint64_t dyld4::JustInTimeLoader::path(dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2)
{
  if (*((_WORD *)this + 20)) {
    return (uint64_t)this + *((unsigned __int16 *)this + 20);
  }
  else {
    return 0LL;
  }
}

BOOL dyld4::JustInTimeLoader::contains( dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unint64_t a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  vm_size_t v6 = (dyld3::MachOFile *)*((void *)this + 4);
  vm_size_t v8 = (unint64_t *)*((void *)this + 13);
  if (v8 && *v8 <= a3 && *v8 + v8[1] > a3) {
    return 1LL;
  }
  uint64_t v11 = 0LL;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  v10[2] = ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke;
  v10[3] = &unk_18961FCF0;
  void v10[6] = a3;
  void v10[7] = a4;
  v10[8] = a5;
  v10[9] = a6;
  v10[4] = &v11;
  v10[5] = (char *)v6 - dyld3::MachOFile::preferredLoadAddress(v6);
  dyld3::MachOFile::forEachSegment(v6, (uint64_t)v10);
  BOOL v7 = *((_BYTE *)v12 + 24) != 0;
  _Block_object_dispose(&v11, 8);
  return v7;
}

uint64_t ___ZNK5dyld416JustInTimeLoader8containsERNS_12RuntimeStateEPKvPS4_PyPh_block_invoke( uint64_t result, uint64_t a2, _BYTE *a3)
{
  unint64_t v3 = *(void *)(result + 48);
  unint64_t v4 = *(void *)(result + 40) + *(void *)(a2 + 16);
  if (v4 <= v3)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (v3 < v5 + v4)
    {
      **(void **)(result + 56) = v4;
      vm_size_t v6 = *(_BYTE **)(result + 72);
      **(void **)(result + 64) = v5;
      *vm_size_t v6 = *(_DWORD *)(a2 + 52);
      *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      *a3 = 1;
    }
  }

  return result;
}

BOOL dyld4::JustInTimeLoader::matchesPath( dyld4::JustInTimeLoader *this, const dyld4::RuntimeState *a2, char *__s1)
{
  uint64_t v5 = *((void *)this + 5);
  if ((_WORD)v5) {
    vm_size_t v6 = (char *)this + (unsigned __int16)*((void *)this + 5);
  }
  else {
    vm_size_t v6 = 0LL;
  }
  if (!_platform_strcmp(__s1, v6)) {
    return 1LL;
  }
  if ((v5 & 0x100000) != 0)
  {
    BOOL v7 = dyld3::MachOFile::installName(*((dyld3::MachOFile **)this + 4));
    if (!_platform_strcmp(__s1, v7)) {
      return 1LL;
    }
  }

  vm_size_t v8 = (dyld4::PseudoDylib *)*((void *)this + 13);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = (char *)dyld4::PseudoDylib::loadableAtPath(v8, __s1);
  if (v9 == __s1 || v9 == 0LL) {
    return v9 != 0;
  }
  dyld4::PseudoDylib::disposeString(*((uint64_t (****)(char *))this + 13), v9);
  return 1LL;
}

__n128 dyld4::JustInTimeLoader::fileID@<Q0>(dyld4::JustInTimeLoader *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 56);
  __int128 v4 = *(_OWORD *)((char *)this + 72);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

void *dyld4::JustInTimeLoader::makePatchTable( dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2, unsigned int a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  if (!*(void *)(v3 + 368)) {
    dyld4::JustInTimeLoader::makePatchTable();
  }
  BOOL v7 = (void *)(v3 + 368);
  int v8 = PatchTable::patchableExportCount((int **)(v3 + 368), a3);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = lsl::Allocator::malloc(*((lsl::Lock ***)a2 + 2), 8LL * (v8 + 1));
  uint64_t v47 = 0LL;
  __int128 v48 = &v47;
  uint64_t v49 = 0x2000000000LL;
  int v50 = 0;
  uint64_t v34 = *((void *)this + 4);
  uint64_t IndexedImageEntry = DyldSharedCache::getIndexedImageEntry(*(DyldSharedCache **)(*((void *)a2 + 1) + 240LL), a3);
  uint64_t v36 = 0LL;
  uint64_t v37 = &v36;
  uint64_t v38 = 0x8802000000LL;
  int v39 = __Block_byref_object_copy__3;
  uint64_t v40 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v41);
  IndexedImagePath = (const char *)DyldSharedCache::getIndexedImagePath( *(DyldSharedCache **)(*((void *)a2 + 1) + 240LL),  a3);
  if (IndexedImagePath)
  {
    unint64_t v12 = IndexedImagePath;
    if (!strstr(IndexedImagePath, "libdispatch.dylib") && !strstr(v12, "libxpc.dylib"))
    {
      if (_platform_strcmp(v12, "/usr/lib/libodmodule.dylib"))
      {
        if (_platform_strcmp(v12, "/usr/lib/log/liblog_odtypes.dylib"))
        {
          size_t v16 = (vm_address_t *)*((void *)this + 4);
          unint64_t v17 = v37;
          if (dyld3::MachOFile::hasChainedFixups((dyld3::MachOFile *)v16))
          {
            *(void *)uint64_t v32 = v17;
            Diagnostics::Diagnostics((Diagnostics *)&v69);
            uint64_t v59 = 0LL;
            uint64_t v60 = (uint64_t)&v59;
            uint64_t v61 = 0x5002000000LL;
            uint64_t v62 = __Block_byref_object_copy__22;
            uint64_t v63 = (dyld3::MachOFile *)__Block_byref_object_dispose__23;
            uint64_t v64 = &v70;
            uint64_t v65 = 32LL;
            vm_address_t v67 = 0LL;
            vm_size_t v68 = 0LL;
            uint64_t v66 = 0LL;
            v57[0] = (vm_address_t *)_NSConcreteStackBlock;
            v57[1] = (vm_address_t *)1174405120;
            v57[2] = (vm_address_t *)___ZN5dyld4L19getObjCPatchClassesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
            v57[3] = (vm_address_t *)&unk_18961FF48;
            v58[0] = v69;
            v58[1] = v16;
            v57[4] = (vm_address_t *)&v59;
            dyld3::MachOAnalyzer::forEachBindTarget( (dyld3::MachOFile *)v16,  (vm_address_t *)&v69,  0,  (uint64_t)v57,  (uint64_t)&__block_literal_global_0);
            if (!Diagnostics::hasError((Diagnostics *)&v69)
              && dyld3::MachOFile::findObjCDataSection( (dyld3::MachOFile *)v16,  "__objc_classlist",  &v56,  &v55))
            {
              unsigned int v18 = dyld3::MachOFile::pointerSize((dyld3::MachOFile *)v16);
              unint64_t v19 = v55 / v18;
              if (v55 % v18)
              {
                Diagnostics::error((vm_address_t *)&v69, "Invalid objc class section size");
              }

              else
              {
                unint64_t v27 = v55;
                unint64_t v28 = v18;
                uint64_t v31 = *(void *)v32 + 40LL;
                int v33 = dyld3::MachOAnalyzer::chainedPointerFormat((dyld3::MachOAnalyzer *)v16);
                uint64_t v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v16 + v56);
                if ((_DWORD)v28 == 8)
                {
                  if (v27 >= v28)
                  {
                    do
                    {
                      unsigned int v54 = 0;
                      uint64_t v53 = 0LL;
                      if (mach_o::ChainedFixupPointerOnDisk::isBind( v20,  v33,  &v54,  (unint64_t *)&v53))
                      {
                        if (*(void *)(v60 + 56) > (unint64_t)v54)
                        {
                          uint64_t v21 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(v60 + 40),  v54);
                          uint64_t v22 = *v21;
                          if (*v21)
                          {
                            uint64_t v51 = *v21;
                            char v52 = 1;
                            uint64_t v29 = v22;
                            dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                            unsigned int v54 = 0;
                            uint64_t v53 = 0LL;
                            if (mach_o::ChainedFixupPointerOnDisk::isBind( v29,  v33,  &v54,  (unint64_t *)&v53))
                            {
                              if (*(void *)(v60 + 56) > (unint64_t)v54)
                              {
                                uint64_t v23 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(v60 + 40),  v54);
                                if (*v23)
                                {
                                  uint64_t v51 = *v23;
                                  char v52 = 1;
                                  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                                }
                              }
                            }
                          }
                        }
                      }

                      uint64_t v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v20 + 8);
                      --v19;
                    }

                    while (v19);
                  }
                }

                else if (v27 >= v28)
                {
                  do
                  {
                    unsigned int v54 = 0;
                    uint64_t v53 = 0LL;
                    if (mach_o::ChainedFixupPointerOnDisk::isBind( v20,  v33,  &v54,  (unint64_t *)&v53))
                    {
                      if (*(void *)(v60 + 56) > (unint64_t)v54)
                      {
                        uint64_t v24 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(v60 + 40),  v54);
                        __int128 v25 = *v24;
                        if (*v24)
                        {
                          uint64_t v51 = *v24;
                          char v52 = 1;
                          char v30 = v25;
                          dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                          unsigned int v54 = 0;
                          uint64_t v53 = 0LL;
                          if (mach_o::ChainedFixupPointerOnDisk::isBind( v30,  v33,  &v54,  (unint64_t *)&v53))
                          {
                            if (*(void *)(v60 + 56) > (unint64_t)v54)
                            {
                              uint64_t v26 = (mach_o::ChainedFixupPointerOnDisk **)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]( (void *)(v60 + 40),  v54);
                              if (*v26)
                              {
                                uint64_t v51 = *v26;
                                char v52 = 1;
                                dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v31, &v51);
                              }
                            }
                          }
                        }
                      }
                    }

                    uint64_t v20 = (mach_o::ChainedFixupPointerOnDisk *)((char *)v20 + 4);
                    --v19;
                  }

                  while (v19);
                }
              }
            }

            mach_o::Error::~Error(v58);
            _Block_object_dispose(&v59, 8);
            uint64_t v66 = 0LL;
            if (v67) {
              vm_deallocate(mach_task_self_, v67, v68);
            }
            mach_o::Error::~Error(&v69);
          }
        }
      }
    }
  }

  uint64_t v70 = 0LL;
  unint64_t v71 = &v70;
  uint64_t v72 = 0x8802000000LL;
  uint64_t v73 = __Block_byref_object_copy__3;
  uint64_t v74 = __Block_byref_object_dispose__3;
  dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v75);
  uint64_t v13 = (dyld3::MachOFile *)*((void *)this + 4);
  char v14 = v71 + 5;
  Diagnostics::Diagnostics((Diagnostics *)v57);
  uint64_t v59 = _NSConcreteStackBlock;
  uint64_t v60 = 0x40000000LL;
  uint64_t v61 = (uint64_t)___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke;
  uint64_t v62 = (double (*)(uint64_t, uint64_t))&__block_descriptor_tmp_102_0;
  uint64_t v63 = v13;
  uint64_t v64 = v14;
  dyld3::MachOFile::forEachSingletonPatch(v13, (uint64_t)v57, (uint64_t)&v59);
  mach_o::Error::~Error(v57);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 0x40000000LL;
  v35[2] = ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke;
  _DWORD v35[3] = &unk_18961FD18;
  v35[8] = a2;
  void v35[9] = IndexedImageEntry;
  v35[4] = &v70;
  v35[5] = &v36;
  v35[6] = &v47;
  v35[7] = this;
  v35[10] = v9;
  v35[11] = v34;
  PatchTable::forEachPatchableExport(v7, a3, (uint64_t)v35);
  v9[*((unsigned int *)v48 + 6)] = -1LL;
  _Block_object_dispose(&v70, 8);
  uint64_t v78 = 0LL;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  v75[4] = 0LL;
  if (v76) {
    vm_deallocate(mach_task_self_, v76, v77);
  }
  _Block_object_dispose(&v36, 8);
  uint64_t v44 = 0LL;
  if (v45) {
    vm_deallocate(mach_task_self_, v45, v46);
  }
  v41[4] = 0LL;
  if (v42) {
    vm_deallocate(mach_task_self_, v42, v43);
  }
  _Block_object_dispose(&v47, 8);
  return v9;
}

double __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 88) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v3 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v3;
  *(void *)(a2 + 88) = 0LL;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a1 + 128) = 0LL;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  uint64_t v4 = *(void *)(a2 + 128);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(void *)(a1 + 128) = v4;
  *(void *)(a2 + 128) = 0LL;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__3(uint64_t result)
{
  unint64_t v1 = (void *)result;
  *(void *)(result + 112) = 0LL;
  vm_address_t v2 = *(void *)(result + 120);
  if (v2) {
    double result = vm_deallocate(mach_task_self_, v2, *(void *)(result + 128));
  }
  v1[9] = 0LL;
  vm_address_t v3 = v1[10];
  if (v3) {
    return vm_deallocate(mach_task_self_, v3, v1[11]);
  }
  return result;
}

void ___ZNK5dyld416JustInTimeLoader14makePatchTableERNS_12RuntimeStateEj_block_invoke( uint64_t a1, unsigned int a2, const unsigned __int8 *a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 56);
  Diagnostics::Diagnostics((Diagnostics *)&v33);
  int hasExportedSymbol = dyld4::Loader::hasExportedSymbol( v8,  (vm_address_t *)&v33,  *(const dyld4::RuntimeState **)(a1 + 64),  a3,  0,  1,  (uint64_t *)&v31,  0LL);
  uint64_t v10 = 0LL;
  if (hasExportedSymbol)
  {
    uint64_t Address = dyld4::Loader::loadAddress(v31, *(const dyld4::RuntimeState **)(a1 + 64));
    unint64_t v12 = (dyld3::MachOAnalyzer *)(Address + v32);
    if (a4 == 8)
    {
      unint64_t v19 = (dyld3::MachOAnalyzer *)Address;
      uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>( v20 + 40,  (void *)(v20 + 56),  (void *)(v20 + 96),  0LL,  &v34) != *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 96LL)
                    + 16LL * *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 112LL))
      {
        uint64_t v21 = *(dyld3::MachOAnalyzer **)(a1 + 72);
        if (!dyld3::MachOAnalyzer::isSwiftClass(v19, v12))
        {
          uint64_t v22 = (dyld3::MachOAnalyzer *)((char *)v21 + a2);
          if (!dyld3::MachOAnalyzer::isSwiftClass(v21, v22))
          {
            uint64_t v23 = *(void *)(a1 + 64);
            lsl::Vector<dyld4::InterposeTupleAll>::reserve(v23 + 224, *(void *)(v23 + 240) + 1LL);
            uint64_t v24 = *(void *)(v23 + 232);
            uint64_t v25 = *(void *)(v23 + 240);
            *(void *)(v23 + 240) = v25 + 1;
            uint64_t v26 = (dyld3::MachOAnalyzer **)(v24 + 16 * v25);
            const char *v26 = v22;
            v26[1] = v12;
            uint64_t v27 = *(void *)(a1 + 64);
            lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v27 + 256, *(void *)(v27 + 272) + 1LL);
            uint64_t v28 = *(void *)(v27 + 264);
            uint64_t v29 = *(void *)(v27 + 272);
            *(void *)(v27 + 272) = v29 + 1;
            char v30 = (dyld3::MachOAnalyzer **)(v28 + 32 * v29);
            mach_o::ChainedFixupPointerOnDisk *v30 = v21;
            v30[1] = v22;
            v30[2] = v19;
            v30[3] = v12;
            uint64_t v10 = 1LL;
            goto LABEL_10;
          }
        }
      }
    }

    else if (a4 == 1)
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8LL);
      uint64_t v34 = Address + v32;
      if (dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>( v13 + 40,  (void *)(v13 + 56),  (void *)(v13 + 96),  0LL,  &v34) != *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 96LL)
                    + 16LL * *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 112LL))
      {
        uint64_t v14 = *(void *)(a1 + 64);
        uint64_t v15 = *(void *)(a1 + 72) + a2;
        lsl::Vector<dyld4::InterposeTupleAll>::reserve(v14 + 288, *(void *)(v14 + 304) + 1LL);
        uint64_t v16 = *(void *)(v14 + 296);
        uint64_t v17 = *(void *)(v14 + 304);
        *(void *)(v14 + 304) = v17 + 1;
        unsigned int v18 = (void *)(v16 + 16 * v17);
        *unsigned int v18 = v15;
        v18[1] = v12;
        uint64_t v10 = 2LL;
        goto LABEL_10;
      }
    }

    uint64_t v10 = (uint64_t)v12 - *(void *)(a1 + 88);
  }

void dyld4::JustInTimeLoader::loadDependents( uint64_t a1, Diagnostics *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  if ((*(_BYTE *)(a1 + 42) & 1) == 0)
  {
    uint64_t v23 = 0LL;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x2000000000LL;
    int v26 = 0;
    uint64_t v8 = *(mach_o::Error **)(a1 + 32);
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000LL;
    v22[2] = ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke;
    v22[3] = &unk_18961FD40;
    v22[4] = &v23;
    v22[5] = a1;
    v22[6] = a3;
    v22[7] = a4;
    v22[8] = a2;
    mach_o::Header::forEachLinkedDylib(v8, (uint64_t)v22);
    *(void *)(a1 + 40) |= 0x10000uLL;
    if (!Diagnostics::hasError(a2))
    {
      v21[0] = *((void *)a4 + 2);
      v21[1] = a1;
      __int128 v9 = a4[1];
      uint64_t v10 = *((void *)a4 + 4);
      __int128 v17 = *a4;
      uint64_t v19 = *((void *)&v9 + 1);
      uint64_t v20 = v10;
      unsigned int v18 = v21;
      uint64_t v11 = v24;
      *((_DWORD *)v24 + 6) = 0;
      unint64_t v12 = *(void *)(a1 + 40);
      if ((v12 & 0x7FFF8000000000LL) != 0)
      {
        int v13 = 0;
        do
        {
          uint64_t v14 = *(void *)(a1 + 8LL * v13 + 464);
          if (v14)
          {
            dyld4::Loader::loadDependents(v14, a2, a3, &v17);
            uint64_t v11 = v24;
          }

          int v13 = *((_DWORD *)v11 + 6) + 1;
          *((_DWORD *)v11 + 6) = v13;
          unint64_t v12 = *(void *)(a1 + 40);
        }

        while (v13 < (unsigned __int16)(v12 >> 39));
      }

      if ((v12 & 0x400000) != 0)
      {
        *(void *)(a1 + 88) = dyld4::JustInTimeLoader::makePatchTable( (dyld4::JustInTimeLoader *)a1,  a3,  (v12 >> 24) & 0x7FFF);
        *(void *)(a1 + 96) = 0LL;
        if (*(_BYTE *)(*((void *)a3 + 1) + 157LL))
        {
          unsigned int v16 = dyld4::Loader::indexOfUnzipperedTwin( a3,  (const dyld4::RuntimeState *)(*(_DWORD *)(a1 + 43) & 0x7FFF),  v15);
          if (v16 != 0xFFFF) {
            *(void *)(a1 + 96) = dyld4::JustInTimeLoader::makePatchTable((dyld4::JustInTimeLoader *)a1, a3, v16);
          }
        }
      }
    }

    _Block_object_dispose(&v23, 8);
  }

void ___ZN5dyld416JustInTimeLoader14loadDependentsER11DiagnosticsRNS_12RuntimeStateERKNS_6Loader11LoadOptionsE_block_invoke( uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  int v9 = a3;
  uint64_t v10 = *(void *)(a1 + 40);
  if ((~a3 & 0xA) == 0) {
    int v9 = a3 & 0xF7;
  }
  if ((~v9 & 3) != 0) {
    char v11 = v9;
  }
  else {
    char v11 = v9 & 0xFE;
  }
  if ((*(_BYTE *)(v10 + 42) & 0x80) == 0) {
    *(_BYTE *)dyld4::JustInTimeLoader::dependentAttrs( *(dyld4::JustInTimeLoader **)(a1 + 40),  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) = v11;
  }
  char v12 = v11 & 1;
  if ((*(_WORD *)(v10 + 4) & 2) != 0
    && (v11 & 1) != 0
    && (uint64_t v13 = *(void *)(*(void *)(a1 + 48) + 8LL),
        uint64_t v15 = *(void *)(v13 + 240),
        uint64_t v14 = (DyldSharedCache **)(v13 + 240),
        v15)
    && (dyld4::ProcessConfig::DyldCache::indexOfPath(v14, a2, v40) & 1) == 0)
  {
    uint64_t v21 = *(dyld4::RuntimeState **)(a1 + 48);
    if (*(_BYTE *)(*((void *)v21 + 1) + 207LL))
    {
      if (*(_WORD *)(v10 + 40)) {
        uint64_t v22 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
      }
      else {
        uint64_t v22 = 0LL;
      }
      dyld4::RuntimeState::log(v21, "Skipping shared cache weak-linked dylib '%s' from '%s'\n", a2, v22);
    }

    *(void *)(v10 + 8LL * *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 464) = 0LL;
  }

  else
  {
    if (*a2 != 47) {
      goto LABEL_25;
    }
    uint64_t v16 = *(void *)(a1 + 48);
    uint64_t v17 = *(void *)(v16 + 48);
    if (!v17) {
      goto LABEL_25;
    }
    unsigned int v18 = *(dyld4::Loader ***)(v16 + 40);
    uint64_t v19 = 8 * v17;
    while (1)
    {
      uint64_t v20 = *v18;
      if (dyld4::Loader::matchesPath(*v18, *(const dyld4::RuntimeState **)(a1 + 48), a2)) {
        break;
      }
      ++v18;
      v19 -= 8LL;
      if (!v19) {
        goto LABEL_25;
      }
    }

    if (!v20)
    {
LABEL_25:
      v39[0] = *(void *)(*(void *)(a1 + 56) + 16LL);
      v39[1] = v10;
      Diagnostics::Diagnostics((Diagnostics *)&v38);
      uint64_t v23 = *(__int128 **)(a1 + 56);
      __int128 v24 = *v23;
      __int128 v25 = v23[1];
      uint64_t v37 = *((void *)v23 + 4);
      __int128 v35 = v24;
      __int128 v36 = v25;
      BYTE11(v35) = *(_BYTE *)(v10 + 5) & 1;
      *(void *)&__int128 v36 = v39;
      BYTE2(v35) = v12;
      uint64_t v26 = *((void *)v23 + 3);
      if (v26) {
        uint64_t Loader = (dyld4::Loader *)(*(uint64_t (**)(uint64_t, vm_address_t **, void, char *, __int128 *))(v26 + 16))( v26,  &v38,  *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 68LL),  a2,  &v35);
      }
      else {
        uint64_t Loader = dyld4::Loader::getLoader(&v38, *(DyldSharedCache ****)(a1 + 48), a2, (uint64_t)&v35);
      }
      uint64_t v20 = Loader;
      if (Diagnostics::hasError((Diagnostics *)&v38))
      {
        dyld4::Loader::getUuidStr((unsigned __int8 *)v10, (char *)v40, v28);
        Diagnostics::Diagnostics((Diagnostics *)&v34);
        dyld4::Loader::tooNewErrorAddendum( (dyld4::Loader *)v10,  (Diagnostics *)&v34,  *(dyld4::RuntimeState **)(a1 + 48));
        uint64_t v29 = *(vm_address_t **)(a1 + 64);
        if (*(_WORD *)(v10 + 40)) {
          char v30 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
        }
        else {
          char v30 = 0LL;
        }
        uint64_t v31 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v34);
        uint64_t v32 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v38);
        Diagnostics::error( v29,  "Library not loaded: %s\n  Referenced from: <%s> %s%s\n  Reason: %s",  a2,  (const char *)v40,  v30,  v31,  v32);
        if (**(_BYTE **)(a1 + 56))
        {
          if (*(_WORD *)(v10 + 40)) {
            int v33 = (const char *)(v10 + *(unsigned __int16 *)(v10 + 40));
          }
          else {
            int v33 = 0LL;
          }
          dyld4::RuntimeState::setLaunchMissingDylib(*(void **)(a1 + 48), a2, v33);
        }

        *a6 = 1;
        mach_o::Error::~Error(&v34);
      }

      mach_o::Error::~Error(&v38);
    }

    *(void *)(v10 + 8LL * *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + 464) = v20;
  }

  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t dyld4::JustInTimeLoader::dependentAttrs(dyld4::JustInTimeLoader *this, unsigned int a2)
{
  unint64_t v2 = *((void *)this + 5);
  uint64_t v3 = (unsigned __int16)(v2 >> 39);
  if ((v2 & 0x800000) != 0) {
    dyld4::JustInTimeLoader::dependentAttrs();
  }
  return (uint64_t)this + 8 * v3 + a2 + 464;
}

uint64_t dyld4::JustInTimeLoader::dependentCount(dyld4::JustInTimeLoader *this)
{
  return (unsigned __int16)(*((void *)this + 5) >> 39);
}

uint64_t dyld4::JustInTimeLoader::dependent(dyld4::JustInTimeLoader *this, int a2, unsigned int a3, char *a4)
{
  unint64_t v4 = *((void *)this + 5);
  if (a4)
  {
    if ((v4 & 0x800000) != 0) {
      uint64_t v8 = &mach_o::LinkedDylibAttributes::regular;
    }
    else {
      uint64_t v8 = (char *)dyld4::JustInTimeLoader::dependentAttrs(this, a3);
    }
    *a4 = *v8;
  }

  return *((void *)this + a3 + 58);
}

BOOL dyld4::JustInTimeLoader::getExportsTrie( dyld4::JustInTimeLoader *this, unint64_t *a2, unsigned int *a3)
{
  unint64_t v3 = *((unsigned int *)this + 28);
  if ((_DWORD)v3)
  {
    *a2 = v3;
    *a3 = *((_DWORD *)this + 29);
  }

  return (_DWORD)v3 != 0;
}

unint64_t dyld4::JustInTimeLoader::hiddenFromFlat(dyld4::JustInTimeLoader *this, char a2)
{
  unint64_t v2 = *((void *)this + 5);
  if ((a2 & 1) == 0) {
    return (v2 >> 19) & 1;
  }
  unint64_t result = 0LL;
  *((void *)this + 5) = v2 & 0xFFFFFFFFFFF7FFFFLL;
  return result;
}

BOOL dyld4::JustInTimeLoader::representsCachedDylibIndex(dyld4::JustInTimeLoader *this, int a2)
{
  unint64_t v2 = *((void *)this + 5);
  return (v2 & 0x400000) != 0 && ((v2 >> 24) & 0x7FFF) == a2
      || (*((_WORD *)this + 2) & 2) != 0 && (*((_WORD *)this + 3) & 0x7FFF) == a2;
}

uint64_t dyld4::JustInTimeLoader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  unint64_t v3 = *(void *)(a1 + 40);
  if ((v3 & 0x400000) != 0)
  {
    *a2 = *(void *)(a1 + 88);
    *a3 = *(_WORD *)(a1 + 43) & 0x7FFF;
  }

  return (v3 >> 22) & 1;
}

void dyld4::JustInTimeLoader::withLayout(uint64_t a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
}

uint64_t dyld4::JustInTimeLoader::dyldDoesObjCFixups(dyld4::JustInTimeLoader *this)
{
  return (*((unsigned __int16 *)this + 2) >> 1) & 1;
}

uint64_t dyld4::JustInTimeLoader::getSectionLocations(dyld4::JustInTimeLoader *this)
{
  return (uint64_t)this + 120;
}

uint64_t dyld4::JustInTimeLoader::handleStrongWeakDefOverrides( uint64_t this, dyld4::RuntimeState *a2, dyld4::DyldCacheDataConstLazyScopedWriter *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke;
  v5[3] = &__block_descriptor_tmp_15_0;
  v5[4] = this;
  void v5[5] = a2;
  uint64_t v3 = *(void *)(this + 24);
  if (v3)
  {
    if ((*(_WORD *)(v3 + 4) & 0x800) != 0)
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000LL;
      v4[2] = ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2;
      void v4[3] = &unk_18961FD88;
      void v4[5] = v3;
      v4[6] = this;
      v4[4] = v5;
      return dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v4);
    }
  }

  return this;
}

dyld3::MachOFile *___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  vm_size_t v6 = *(dyld3::MachOFile **)(*(void *)(v4 + 8) + 240LL);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke;
  v8[3] = &__block_descriptor_tmp_20;
  void v8[4] = v6;
  v8[5] = v4;
  void v8[6] = a4;
  v8[7] = v5;
  return DyldSharedCache::forEachPatchableUseOfExport(v6, a2, a3, (uint64_t)v8);
}

void ___ZN5dyld416JustInTimeLoader28handleStrongWeakDefOverridesERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterE_block_invoke_2( uint64_t a1, const char *a2)
{
}

void ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (char **)(*(void *)(a1 + 32) + a2);
  vm_size_t v6 = (char *)dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(a1 + 40), *(void *)(a1 + 48)) + a4;
  if (*v5 != v6)
  {
    dyld4::DyldCacheDataConstLazyScopedWriter::makeWriteable(*(_BYTE **)(a1 + 56));
    BOOL v7 = *(dyld4::RuntimeState **)(a1 + 40);
    if (*(_BYTE *)(*((void *)v7 + 1) + 202LL)) {
      dyld4::RuntimeState::log(v7, "cache patch: %p = 0x%0lX\n", v5, v6);
    }
    *uint64_t v5 = v6;
  }

void dyld4::JustInTimeLoader::applyFixups( uint64_t a1, vm_address_t *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4, char a5, uint64_t a6)
{
  if ((*(_WORD *)(a1 + 4) & 2) != 0)
  {
    if (*(_BYTE *)(a3 + 1126))
    {
      uint64_t v11 = *(void *)(a3 + 48);
      if (v11)
      {
        char v12 = *(dyld4::Loader ***)(a3 + 40);
        uint64_t v13 = 8 * v11;
        do
        {
          uint64_t v14 = *v12++;
          dyld4::Loader::applyCachePatchesTo(v14, (dyld4::RuntimeState *)a3, (const dyld4::Loader *)a1, a4);
          v13 -= 8LL;
        }

        while (v13);
      }
    }

    *(void *)(a1 + 40) |= 0x20000uLL;
  }

  else if (!*(void *)(a1 + 104))
  {
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 0x40000000LL;
    v48[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke;
    v48[3] = &__block_descriptor_tmp_21;
    v48[4] = a3;
    v48[5] = a4;
    uint64_t v38 = 0LL;
    int v39 = &v38;
    uint64_t v40 = 0x5002000000LL;
    uint64_t v41 = __Block_byref_object_copy__22;
    vm_address_t v42 = __Block_byref_object_dispose__23;
    vm_size_t v43 = &v51;
    uint64_t v44 = 512LL;
    vm_address_t v46 = 0LL;
    vm_size_t v47 = 0LL;
    uint64_t v45 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v29 = &v28;
    uint64_t v30 = 0x5002000000LL;
    uint64_t v31 = __Block_byref_object_copy__22;
    uint64_t v32 = __Block_byref_object_dispose__23;
    int v33 = &v50;
    uint64_t v34 = 32LL;
    vm_address_t v36 = 0LL;
    vm_size_t v37 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x5002000000LL;
    uint64_t v21 = __Block_byref_object_copy__24;
    uint64_t v22 = __Block_byref_object_dispose__25;
    uint64_t v23 = &v49;
    uint64_t v24 = 4LL;
    vm_address_t address = 0LL;
    vm_size_t size = 0LL;
    uint64_t v25 = 0LL;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_26;
    v17[3] = &unk_18961FDF0;
    v17[6] = a1;
    v17[7] = a3;
    v17[4] = &v38;
    _WORD v17[5] = &v18;
    v17[8] = a6;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000LL;
    v16[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_2;
    void v16[3] = &unk_18961FE18;
    v16[6] = a1;
    v16[7] = a3;
    v16[4] = &v28;
    v16[5] = &v18;
    dyld4::Loader::forEachBindTarget( (dyld4::Loader *)a1,  a2,  (dyld4::RuntimeState *)a3,  (uint64_t)v48,  a5,  (uint64_t)v17,  (uint64_t)v16);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      dyld4::Loader::applyFixupsGeneric( (dyld4::Loader *)a1,  a2,  (dyld4::RuntimeState *)a3,  *(void *)(a1 + 48),  (uint64_t)(v39 + 5),  (uint64_t)(v29 + 5),  1LL,  (uint64_t)(v19 + 5));
      if (*(_DWORD *)(*(void *)(a3 + 8) + 68LL) == 1)
      {
        if (*(void *)(a3 + 104))
        {
          uint64_t v10 = *(dyld3::MachOFile **)(a1 + 32);
          if ((dyld3::MachOFile::inDyldCache(v10) & 1) == 0)
          {
            v15[0] = _NSConcreteStackBlock;
            v15[1] = 0x40000000LL;
            v15[2] = ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3;
            v15[3] = &__block_descriptor_tmp_38;
            v15[4] = v10;
            void v15[5] = a3;
            dyld3::MachOFile::forEachSupportedPlatform(v10, (uint64_t)v15);
          }
        }
      }

      if (dyld4::Loader::hasConstantSegmentsToProtect((dyld4::Loader *)a1)) {
        dyld4::Loader::makeSegmentsReadOnly((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
      }
      if (Diagnostics::noError((Diagnostics *)a2)) {
        *(void *)(a1 + 40) |= 0x20000uLL;
      }
    }

    _Block_object_dispose(&v18, 8);
    uint64_t v25 = 0LL;
    if (address) {
      vm_deallocate(mach_task_self_, address, size);
    }
    _Block_object_dispose(&v28, 8);
    uint64_t v35 = 0LL;
    if (v36) {
      vm_deallocate(mach_task_self_, v36, v37);
    }
    _Block_object_dispose(&v38, 8);
    uint64_t v45 = 0LL;
    if (v46) {
      vm_deallocate(mach_task_self_, v46, v47);
    }
  }

dyld3::MachOFile *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  vm_size_t v6 = *(dyld3::MachOFile **)(*(void *)(v4 + 8) + 240LL);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZN5dyld416JustInTimeLoader17cacheWeakDefFixupERNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEjjRKNS_6Loader14ResolvedSymbolE_block_invoke;
  v8[3] = &__block_descriptor_tmp_20;
  void v8[4] = v6;
  v8[5] = v4;
  void v8[6] = a4;
  v8[7] = v5;
  return DyldSharedCache::forEachPatchableUseOfExport(v6, a2, a3, (uint64_t)v8);
}

double __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__23(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

void *__Block_byref_object_dispose__25(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_26( uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v4 = *(const dyld4::RuntimeState **)(a1 + 56);
  vm_size_t v6 = dyld4::Loader::resolvedAddress(v4, a2);
  uint64_t v8 = dyld4::Loader::interpose(v4, v6, v5, v7);
  int v9 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(_BYTE *)(*((void *)v9 + 1) + 202LL))
  {
    if (*(void *)a2)
    {
      uint64_t v10 = dyld4::Loader::leafName(*(dyld4::Loader **)a2, *(const dyld4::RuntimeState **)(a1 + 56));
      int v9 = *(const dyld4::RuntimeState **)(a1 + 56);
    }

    else
    {
      uint64_t v10 = "<none>";
    }

    uint64_t v11 = dyld4::Loader::leafName(v5, v9);
    dyld4::RuntimeState::log( v9,  "<%s/bind#%llu> -> %p (%s/%s)\n",  v11,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL),  v8,  v10,  *(const char **)(a2 + 8));
  }

  if (*(_BYTE *)(a2 + 38))
  {
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v12 + 40), 1LL);
    uint64_t v15 = *(void *)(v12 + 40);
    uint64_t v16 = *(void *)(v12 + 56);
    *(void *)(v12 + 56) = v16 + 1;
    uint64_t v17 = v15 + 16 * v16;
    *(void *)uint64_t v17 = v13;
    *(_DWORD *)(v17 + 8) = v14;
  }

  if (*(_BYTE *)(a2 + 39))
  {
    uint64_t v18 = *(void *)(a1 + 64);
    if (v18)
    {
      __int128 v25 = *(_OWORD *)a2;
      lsl::Vector<dyld4::InterposeTupleAll>::reserve(v18, *(void *)(v18 + 16) + 1LL);
      uint64_t v19 = *(void *)(v18 + 8);
      uint64_t v20 = *(void *)(v18 + 16);
      *(void *)(v18 + 16) = v20 + 1;
      *(_OWORD *)(v19 + 16 * v20) = v25;
    }
  }

  uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8LL);
  double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v21 + 40), 1LL);
  uint64_t v23 = *(void *)(v21 + 40);
  uint64_t v24 = *(void *)(v21 + 56);
  *(void *)(v21 + 56) = v24 + 1;
  *(void *)(v23 + 8 * v24) = v8;
  return result;
}

void *___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(dyld4::Loader **)(a1 + 48);
  uint64_t v4 = *(const dyld4::RuntimeState **)(a1 + 56);
  if (*(_DWORD *)(a2 + 32) == 1 && *(void *)a2 == 0LL)
  {
    if (*(_BYTE *)(*((void *)v4 + 1) + 202LL))
    {
      uint64_t v12 = dyld4::Loader::leafName(*(dyld4::Loader **)(a1 + 48), v4);
      dyld4::RuntimeState::log( v4,  "<%s/bind#%llu> -> missing-weak-bind (%s)\n",  v12,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL),  *(const char **)(a2 + 8));
    }

    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8LL);
    double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v13 + 40), 1LL);
    uint64_t v15 = *(void *)(v13 + 40);
    uint64_t v16 = *(void *)(v13 + 56);
    *(void *)(v13 + 56) = v16 + 1;
    *(void *)(v15 + 8 * v16) = -1LL;
  }

  else
  {
    BOOL v7 = dyld4::Loader::resolvedAddress(*(const dyld4::RuntimeState **)(a1 + 56), a2);
    int v9 = dyld4::Loader::interpose(v4, v7, v5, v8);
    uint64_t v10 = *(const dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((void *)v10 + 1) + 202LL))
    {
      if (*(void *)a2)
      {
        uint64_t v11 = dyld4::Loader::leafName(*(dyld4::Loader **)a2, *(const dyld4::RuntimeState **)(a1 + 56));
        uint64_t v10 = *(const dyld4::RuntimeState **)(a1 + 56);
      }

      else
      {
        uint64_t v11 = "<none>";
      }

      uint64_t v17 = dyld4::Loader::leafName(v5, v10);
      dyld4::RuntimeState::log( v10,  "<%s/bind#%llu> -> %p (%s/%s)\n",  v17,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL),  v9,  v11,  *(const char **)(a2 + 8));
    }

    if (*(_BYTE *)(a2 + 38))
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v19 = *(void *)(a2 + 8);
      uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL);
      dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace( (void *)(v18 + 40),  1LL);
      uint64_t v21 = *(void *)(v18 + 40);
      uint64_t v22 = *(void *)(v18 + 56);
      *(void *)(v18 + 56) = v22 + 1;
      uint64_t v23 = v21 + 16 * v22;
      *(void *)uint64_t v23 = v19;
      *(_DWORD *)(v23 + 8) = v20;
    }

    uint64_t v24 = *(void *)(*(void *)(a1 + 32) + 8LL);
    double result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v24 + 40), 1LL);
    uint64_t v25 = *(void *)(v24 + 40);
    uint64_t v26 = *(void *)(v24 + 56);
    *(void *)(v24 + 56) = v26 + 1;
    *(void *)(v25 + 8 * v26) = v9;
  }

  return result;
}

uint64_t ___ZNK5dyld416JustInTimeLoader11applyFixupsER11DiagnosticsRNS_12RuntimeStateERNS_34DyldCacheDataConstLazyScopedWriterEbPN3lsl6VectorINSt3__14pairIPKNS_6LoaderEPKcEEEE_block_invoke_3( uint64_t result, int a2, unsigned int a3)
{
  if (a2 == 1 && a3 <= 0xA0900)
  {
    void v9[3] = v3;
    void v9[4] = v4;
    uint64_t v5 = result;
    double result = dyld3::MachOLoaded::findSectionContent(*(dyld3::MachOLoaded **)(result + 32), "__DATA", "__dyld", v9);
    if (result)
    {
      vm_size_t v6 = (void *)result;
      uint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress( *(dyld4::Loader **)(*(void *)(v5 + 40) + 104LL),  *(const dyld4::RuntimeState **)(v5 + 40));
      double result = dyld3::MachOLoaded::findSectionContent(Address, "__TPRO_CONST", "__dyld4", &v8);
      if (result)
      {
        *vm_size_t v6 = 0LL;
        v6[1] = *(void *)(result + 56);
      }
    }
  }

  return result;
}

void dyld4::JustInTimeLoader::unmap(dyld4::JustInTimeLoader *this, dyld4::SyscallDelegate **a2, char a3)
{
  __int16 v3 = *((_WORD *)this + 2);
  if ((v3 & 2) == 0 && !*((void *)this + 13))
  {
    if ((v3 & 0x20) != 0 && (a3 & 1) == 0)
    {
      if (*((_WORD *)this + 20)) {
        BOOL v7 = (char *)this + *((unsigned __int16 *)this + 20);
      }
      else {
        BOOL v7 = 0LL;
      }
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "trying to unmap %s\n", v7);
    }

    if ((a3 & 1) == 0 && (*((_WORD *)this + 2) & 0x20) != 0) {
      dyld4::JustInTimeLoader::unmap();
    }
    size_t v8 = dyld3::MachOFile::mappedSize(*((dyld3::MachOFile **)this + 4));
    int v9 = (char *)*((void *)this + 4);
    dyld4::SyscallDelegate::unmapFile(a2[1], v9, v8);
    if (*((_BYTE *)a2[1] + 201))
    {
      if (*((_WORD *)this + 20)) {
        uint64_t v10 = (char *)this + *((unsigned __int16 *)this + 20);
      }
      else {
        uint64_t v10 = 0LL;
      }
      dyld4::RuntimeState::log((dyld4::RuntimeState *)a2, "unmapped 0x%012lX->0x%012lX for %s\n", v9, &v9[v8], v10);
    }
  }

uint64_t dyld4::JustInTimeLoader::hasBeenFixedUp(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2)
{
  return (*((unsigned __int8 *)this + 42) >> 1) & 1;
}

unint64_t dyld4::JustInTimeLoader::beginInitializers( dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2)
{
  unint64_t v2 = *((void *)this + 5);
  if ((v2 & 0x40000) == 0) {
    *((void *)this + 5) = v2 | 0x40000;
  }
  return (v2 >> 18) & 1;
}

dyld4::PseudoDylib *dyld4::JustInTimeLoader::runInitializers( uint64_t (****this)(char *), dyld4::RuntimeState *a2)
{
  double result = (dyld4::PseudoDylib *)this[13];
  if (result)
  {
    double result = (dyld4::PseudoDylib *)dyld4::PseudoDylib::initialize(result);
    if (result)
    {
      uint64_t v5 = (char *)result;
      dyld4::RuntimeState::log(a2, "error running pseudo-dylib initializers: %s", (const char *)result);
      return (dyld4::PseudoDylib *)dyld4::PseudoDylib::disposeString(this[13], v5);
    }
  }

  return result;
}

uint64_t dyld4::JustInTimeLoader::isDelayInit(dyld4::JustInTimeLoader *this, dyld4::RuntimeState *a2)
{
  return *((unsigned __int8 *)this + 46) >> 7;
}

uint64_t dyld4::JustInTimeLoader::setDelayInit(uint64_t this, dyld4::RuntimeState *a2, int a3)
{
  uint64_t v3 = *(void *)(this + 40);
  if (a3)
  {
    if ((v3 & 0x40000) != 0) {
      return this;
    }
    unint64_t v4 = v3 | 0x80000000000000LL;
  }

  else
  {
    unint64_t v4 = v3 & 0xFF7FFFFFFFFFFFFFLL;
  }

  *(void *)(this + 40) = v4;
  return this;
}

uint64_t dyld4::Loader::Loader( uint64_t this, const dyld4::Loader::InitialOptions *a2, __int16 a3, int a4, __int16 a5, int a6)
{
  *(_DWORD *)this = 1815378276;
  __int16 v6 = *(_WORD *)(this + 4) & 0xFFFE | a3;
  *(_WORD *)(this + 4) = v6;
  __int16 v7 = v6 & 0xFFFD | (2 * (*(_BYTE *)a2 & 0x7F));
  *(_WORD *)(this + 4) = v7;
  __int16 v8 = v7 & 0xFFFB | (4 * (*((_BYTE *)a2 + 1) & 0x3F));
  *(_WORD *)(this + 4) = v8;
  __int16 v9 = v8 & 0xFFF7 | (8 * (*((_BYTE *)a2 + 2) & 0x1F));
  *(_WORD *)(this + 4) = v9;
  __int16 v10 = v9 & 0xFFEF | (16 * (*((_BYTE *)a2 + 3) & 0xF));
  *(_WORD *)(this + 4) = v10;
  __int16 v11 = v10 & 0xFFDF | (32 * (*((_BYTE *)a2 + 4) & 7));
  *(_WORD *)(this + 4) = v11;
  __int16 v12 = v11 & 0xFFBF | ((*((_BYTE *)a2 + 5) & 3) << 6);
  *(_WORD *)(this + 4) = v12;
  __int16 v13 = v12 & 0xFF7F | ((*((_BYTE *)a2 + 6) & 1) << 7);
  *(_WORD *)(this + 4) = v13;
  __int16 v14 = v13 & 0xFCFF | (*((unsigned __int8 *)a2 + 7) << 8);
  if (a6) {
    __int16 v15 = 512;
  }
  else {
    __int16 v15 = 0;
  }
  __int16 v16 = v14 | v15;
  *(_WORD *)(this + 4) = v16;
  __int16 v17 = v16 & 0xFBFF | (*((unsigned __int8 *)a2 + 8) << 10);
  *(_WORD *)(this + 4) = v17;
  __int16 v18 = v17 & 0xF7FF | (*((unsigned __int8 *)a2 + 9) << 11);
  *(_WORD *)(this + 4) = v18;
  __int16 v19 = v18 & 0xEFFF | (*((unsigned __int8 *)a2 + 10) << 12);
  *(_WORD *)(this + 4) = v19;
  *(_WORD *)(this + 4) = v19 & 0x1FFF | (*((unsigned __int8 *)a2 + 11) << 13);
  if (a4) {
    __int16 v20 = 0x8000;
  }
  else {
    __int16 v20 = 0;
  }
  *(_WORD *)(this + 6) = v20 | a5;
  *(void *)(this + 24) = 0LL;
  return this;
}

void *dyld4::JustInTimeLoader::make( uint64_t a1, mach_o::Header *this, const char *a3, __int128 *a4, uint64_t a5, char a6, char a7, int a8, __int16 a9)
{
  BOOL v54 = 1;
  unsigned int v16 = mach_o::Header::linkedDylibCount(this, &v54);
  unsigned int v17 = v16 - 1;
  if (!v16) {
    unsigned int v17 = 1;
  }
  uint64_t v18 = 8LL * v17 + 472;
  uint64_t v19 = v16;
  if (v54) {
    uint64_t v20 = 0LL;
  }
  else {
    uint64_t v20 = v16;
  }
  uint64_t v41 = a3;
  size_t v21 = _platform_strlen(a3);
  uint64_t v22 = lsl::Allocator::malloc(*(lsl::Lock ***)(a1 + 16), v21 + v20 + v18 + 1);
  dyld4::Loader::InitialOptions::InitialOptions((uint64_t)&v42);
  BOOL v42 = DyldSharedCache::inDyldCache(*(DyldSharedCache **)(*(void *)(a1 + 8) + 240LL), this, v23);
  char hasObjC = dyld3::MachOFile::hasObjC(this);
  Diagnostics::Diagnostics((Diagnostics *)v59);
  char hasPlusLoadMethod = dyld3::MachOFile::hasPlusLoadMethod(this, (Diagnostics *)v59);
  mach_o::Error::~Error((vm_address_t **)v59);
  char v44 = hasPlusLoadMethod;
  uint64_t v55 = 0LL;
  unint64_t v56 = &v55;
  uint64_t v57 = 0x2000000000LL;
  char v58 = 0;
  *(void *)uint64_t v59 = _NSConcreteStackBlock;
  *(void *)&v59[8] = 0x40000000LL;
  uint64_t v60 = ___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke;
  uint64_t v61 = &unk_18961FFE0;
  uint64_t v62 = &v55;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v59);
  char v25 = *((_BYTE *)v56 + 24);
  _Block_object_dispose(&v55, 8);
  char v45 = v25;
  char v46 = a6 | a8;
  char v47 = a7;
  if (hasObjC) {
    char hasConstObjCSection = dyld3::MachOFile::hasConstObjCSection(this);
  }
  else {
    char hasConstObjCSection = 0;
  }
  char v48 = hasConstObjCSection;
  char v49 = dyld3::MachOFile::enforceFormat(this, 16) ^ 1;
  BOOL Uuid = dyld3::MachOFile::getUuid(this, v59);
  char hasWeakDefs = dyld3::MachOFile::hasWeakDefs(this);
  char hasThreadLocalVariables = dyld3::MachOFile::hasThreadLocalVariables(this);
  if (dyld3::MachOFile::isDylib(this))
  {
    uint64_t v27 = dyld3::MachOFile::installName(this);
    BOOL v28 = _platform_strncmp(v27, "/usr/lib/system/lib", 0x13uLL) == 0;
  }

  else
  {
    BOOL v28 = 0;
  }

  BOOL v53 = v28;
  dyld4::Loader::Loader((uint64_t)v22, (const dyld4::Loader::InitialOptions *)&v42, 0, 0, 0, 0);
  v22[4] = this;
  v22[6] = 0LL;
  __int128 v29 = *a4;
  __int128 v30 = a4[1];
  v22[15] = 1LL;
  *(_OWORD *)(v22 + 7) = v29;
  *(_OWORD *)(v22 + 9) = v30;
  *(_OWORD *)(v22 + 11) = 0u;
  *(_OWORD *)(v22 + 13) = 0u;
  if (v54) {
    __int16 v31 = 0;
  }
  else {
    __int16 v31 = v19;
  }
  v22[5] = v22[5] & 0xFFFFFFFFFFF00000LL | (unsigned __int16)(v31 + v18);
  BOOL isDylib = dyld3::MachOFile::isDylib(this);
  unint64_t v33 = 0LL;
  if (isDylib)
  {
    uint64_t v34 = dyld3::MachOFile::installName(this);
    unint64_t v33 = (unint64_t)(_platform_strcmp(v34, v41) != 0) << 20;
  }

  v22[5] = v22[5] & 0xFFFFFFFF4FFFFFLL | v33 | ((unint64_t)v54 << 23);
  v22[6] = a5;
  uint64_t v35 = v22 + 1;
  if (Uuid) {
    *uint64_t v35 = *(_OWORD *)v59;
  }
  else {
    bzero(v35, 0x10uLL);
  }
  *((_DWORD *)v22 + 6) = *((_DWORD *)this + 2);
  dyld4::JustInTimeLoader::parseSectionLocations(this, (uint64_t)(v22 + 15));
  v22[11] = 0LL;
  v22[13] = 0LL;
  uint64_t v36 = 0x400000LL;
  if (!a8) {
    uint64_t v36 = 0LL;
  }
  unint64_t v37 = v36 & 0xFFFFFF8000FFFFFFLL | ((unint64_t)(a9 & 0x7FFF) << 24) | ((unint64_t)(unsigned __int16)v19 << 39) | v22[5] & 0xFF80000000BFFFFFLL;
  v22[5] = v37;
  if ((_DWORD)v19)
  {
    for (uint64_t i = 0LL; i != v19; ++i)
    {
      v22[i + 58] = 0LL;
      if (!v54) {
        *(_BYTE *)dyld4::JustInTimeLoader::dependentAttrs((dyld4::JustInTimeLoader *)v22, i) = mach_o::LinkedDylibAttributes::regular;
      }
    }

    LOWORD(v37) = *((_WORD *)v22 + 20);
  }

  strlcpy((char *)v22 + (unsigned __int16)v37, v41, 0x400uLL);
  v22[5] &= ~0x80000000000000uLL;
  dyld4::RuntimeState::add((dyld4::RuntimeState *)a1, (const dyld4::Loader *)v22);
  if ((a8 & 1) != 0)
  {
    if (v42) {
      *(_BYTE *)(a1 + 1127) = 1;
    }
    else {
      *(_BYTE *)(a1 + 1126) = 1;
    }
  }

  if (*(_BYTE *)(*(void *)(a1 + 8) + 207LL)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)a1, "using JustInTimeLoader %p for %s\n", v22, v41);
  }
  return v22;
}

void dyld4::JustInTimeLoader::parseSectionLocations(dyld3::MachOFile *a1, uint64_t a2)
{
  *(_OWORD *)(a2 + 248) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 264) = 0u;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke;
  v5[3] = &__block_descriptor_tmp_46_1;
  v5[4] = dyld3::MachOFile::preferredLoadAddress(a1);
  void v5[5] = a2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2;
  void v4[3] = &unk_18961FE80;
  v4[4] = v5;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v4);
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke( uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 40) + 8LL * a2;
  *(void *)(v3 + 8) = *(void *)(a3 + 64) - *(void *)(result + 32);
  *(void *)(v3 + 176) = *(void *)(a3 + 72);
  return result;
}

uint64_t ___ZN5dyld416JustInTimeLoader21parseSectionLocationsEPKN5dyld39MachOFileERNS_16SectionLocationsE_block_invoke_2( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(const char **)(a2 + 40);
  if (_platform_strcmp(v4, "__TEXT"))
  {
    uint64_t result = _platform_strncmp(v4, "__DATA", 6uLL);
    if ((_DWORD)result) {
      return result;
    }
    __int16 v8 = *(const char **)(a2 + 80);
    if (!_platform_strcmp(v8, "__objc_imageinfo"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_selrefs"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_msgrefs"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_classrefs"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_superrefs"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_protorefs"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_classlist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_stublist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_nlclslist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_catlist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_catlist2"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_nlcatlist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_protolist"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v8, "__objc_fork_ok"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    uint64_t result = _platform_strcmp(v8, "__objc_rawisa");
    if (!(_DWORD)result)
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }
  }

  else
  {
    __int16 v6 = *(const char **)(a2 + 80);
    if (!_platform_strcmp(v6, "__swift5_protos"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v6, "__swift5_proto"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v6, "__swift5_types"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v6, "__swift5_replace"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    if (!_platform_strcmp(v6, "__swift5_replac2"))
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }

    uint64_t result = _platform_strcmp(v6, "__swift5_acfuncs");
    if (!(_DWORD)result)
    {
      __int16 v7 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL);
      return v7();
    }
  }

  return result;
}

void dyld4::JustInTimeLoader::getFileValidationInfo(dyld4::JustInTimeLoader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10 = 0LL;
  __int16 v11 = &v10;
  uint64_t v12 = 0x6002000000LL;
  __int16 v13 = __Block_byref_object_copy__71;
  __int16 v14 = __Block_byref_object_dispose__72;
  bzero(&v15, 0x38uLL);
  if (*((_BYTE *)this + 80))
  {
    uint64_t v5 = v11;
    *((_BYTE *)v11 + 92) = 1;
    void v5[5] = *((void *)this + 6);
    void v5[7] = *((void *)this + 7);
    _BYTE v5[8] = *((void *)this + 9);
  }

  if ((*((_WORD *)this + 2) & 2) != 0)
  {
    __int16 v7 = v11;
  }

  else
  {
    __int16 v6 = (_DWORD *)*((void *)this + 4);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke;
    void v9[3] = &unk_18961FEA8;
    void v9[4] = &v10;
    dyld3::MachOAnalyzer::forEachCDHash(v6, (uint64_t)v9);
    __int16 v7 = v11;
    void v11[6] = *((void *)this + 8);
  }

  __int128 v8 = *(_OWORD *)(v7 + 7);
  *(_OWORD *)a2 = *(_OWORD *)(v7 + 5);
  *(_OWORD *)(a2 + 16) = v8;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v7 + 9);
  *(void *)(a2 + 48) = v7[11];
  _Block_object_dispose(&v10, 8);
}

__n128 __Block_byref_object_copy__71(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  __int128 v4 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 ___ZNK5dyld416JustInTimeLoader21getFileValidationInfoERNS_12RuntimeStateE_block_invoke( uint64_t a1, __n128 *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 93LL) = 1;
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL);
  __n128 result = *a2;
  *(_DWORD *)(v2 + 88) = a2[1].n128_u32[0];
  *(__n128 *)(v2 + 72) = result;
  return result;
}

uint64_t dyld4::JustInTimeLoader::getCatalystMacTwinPatches(dyld4::JustInTimeLoader *this)
{
  return *((void *)this + 12);
}

void dyld4::JustInTimeLoader::withRegions(dyld3::MachOFile *a1, uint64_t a2)
{
  int v4 = dyld3::MachOFile::segmentCount(a1);
  uint64_t Address = dyld3::MachOFile::preferredLoadAddress(a1);
  __chkstk_darwin(Address, v6, v7, v8, v9, v10, v11, v12, v16[0]);
  uint64_t v18 = 0LL;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x4002000000LL;
  size_t v21 = __Block_byref_object_copy__75;
  uint64_t v22 = __Block_byref_object_dispose__76;
  uint64_t v23 = (char *)v16 - v14;
  uint64_t v24 = v13;
  uint64_t v25 = 0LL;
  v16[0] = (uint64_t)_NSConcreteStackBlock;
  v16[1] = 0x40000000LL;
  v16[2] = (uint64_t)___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke;
  void v16[3] = (uint64_t)&unk_18961FED0;
  int v17 = v4;
  v16[4] = (uint64_t)&v18;
  v16[5] = v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v16);
  (*(void (**)(uint64_t, uint64_t *))(a2 + 16))(a2, v19 + 5);
  _Block_object_dispose(&v18, 8);
}

__n128 __Block_byref_object_copy__75(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double ___ZN5dyld416JustInTimeLoader11withRegionsEPKN5dyld39MachOFileEU13block_pointerFvRKNS1_5ArrayINS_6Loader6RegionEEEE_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 56);
  uint64_t v5 = *(void *)(a2 + 8);
  if ((v4 & 8) != 0 && !v5) {
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(a2 + 52);
  v13.n128_u32[2] = *(void *)a2;
  v13.n128_u32[3] = v5;
  *(void *)&double result = dyld3::Array<dyld4::Loader::Region>::push_back( (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  &v13).n128_u64[0];
  if ((*(_BYTE *)(a2 + 56) & 8) != 0)
  {
LABEL_10:
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(a1 + 32);
    v12.n128_u64[0] = (*(void *)(a2 + 16) - *(void *)(a1 + 40) + v9) & 0x7FFFFFFFFFFFFFFLL | ((unint64_t)(*(_DWORD *)(a2 + 52) & 7) << 59) | 0x4000000000000000LL;
    unsigned __int32 v11 = *(_DWORD *)(a2 + 24) - v9;
    v12.n128_u32[2] = 0;
    v12.n128_u32[3] = v11;
    *(void *)&double result = dyld3::Array<dyld4::Loader::Region>::push_back((uint64_t *)(*(void *)(v10 + 8) + 40LL), &v12).n128_u64[0];
  }

  return result;
}

__n128 dyld3::Array<dyld4::Loader::Region>::push_back(uint64_t *a1, __n128 *a2)
{
  unint64_t v2 = a1[2];
  if (v2 >= a1[1]) {
    ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
  }
  uint64_t v3 = *a1;
  a1[2] = v2 + 1;
  __n128 result = *a2;
  *(__n128 *)(v3 + 16 * v2) = *a2;
  return result;
}

dyld4::Loader *dyld4::JustInTimeLoader::makeJustInTimeLoaderDyldCache( vm_address_t *a1, dyld4::RuntimeState *a2, char *a3, int a4, int a5)
{
  __int16 v5 = a5;
  unint64_t v23 = 0LL;
  unint64_t v22 = 0LL;
  uint64_t IndexedImageEntry = (mach_o::Header *)dyld4::ProcessConfig::DyldCache::getIndexedImageEntry( (DyldSharedCache **)(*((void *)a2 + 1) + 240LL),  a5,  &v23,  &v22);
  uint64_t v10 = *((void *)a2 + 1);
  char v11 = *(_BYTE *)(v10 + 397);
  __int128 v19 = v22;
  unint64_t v20 = v23;
  char v21 = v11;
  if ((dyld3::MachOFile::loadableIntoProcess( IndexedImageEntry,  *(_DWORD *)(v10 + 68),  a3,  *(unsigned __int8 *)(v10 + 168)) & 1) != 0)
  {
    if (_platform_strncmp(a3, "/System/iOSSupport/", 0x13uLL))
    {
      int v12 = 0;
      __int16 v13 = 0;
    }

    else
    {
      int v12 = dyld4::ProcessConfig::DyldCache::indexOfPath( (DyldSharedCache **)(*((void *)a2 + 1) + 240LL),  a3 + 18,  &v18);
      __int16 v13 = v18;
      if (!v12) {
        __int16 v13 = 0;
      }
    }

    uint64_t v15 = (dyld4::Loader *)dyld4::JustInTimeLoader::make((uint64_t)a2, IndexedImageEntry, a3, &v19, 0LL, 1, 0, v12, v13);
    uint64_t v14 = v15;
    *((_WORD *)v15 + 3) = *((_WORD *)v15 + 3) & 0x8000 | v5 & 0x7FFF;
    uint64_t v16 = *((void *)a2 + 1);
    if (*(_BYTE *)(v16 + 201))
    {
      dyld4::Loader::logSegmentsFromSharedCache(v15, a2);
      uint64_t v16 = *((void *)a2 + 1);
    }

    if (*(_BYTE *)(v16 + 200)) {
      dyld4::Loader::logLoad(v14, a2, a3);
    }
  }

  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0LL;
  }

  return v14;
}

uint64_t dyld4::JustInTimeLoader::makeJustInTimeLoaderDisk( vm_address_t *a1, uint64_t a2, dyld3 *a3, uint64_t a4, char a5, int a6, uint64_t a7)
{
  uint64_t v21 = 0LL;
  unint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000LL;
  uint64_t v24 = 0LL;
  int v14 = dyld3::GradedArchs::checksOSBinary(*(dyld3::GradedArchs **)(*(void *)(a2 + 8) + 144LL));
  uint64_t v15 = *(void *)(a2 + 8);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000LL;
  v18[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke;
  v18[3] = &unk_18961FF20;
  v18[6] = a3;
  v18[7] = a2;
  v18[4] = &v21;
  v18[5] = a1;
  char v20 = a5;
  int v19 = a6;
  v18[8] = a4;
  v18[9] = a7;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v15, a1, a3, v14, (uint64_t)v18);
  uint64_t v16 = v22[3];
  _Block_object_dispose(&v21, 8);
  return v16;
}

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke( uint64_t a1, dyld3::FatFile *this, unint64_t a3, int a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v22 = 0LL;
  uint64_t v10 = dyld3::MachOFile::compatibleSlice( *(vm_address_t **)(a1 + 40),  &v22,  this,  a3,  *(const char **)(a1 + 48),  *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 68LL),  a4,  *(dyld3::GradedArchs **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 144LL),  *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 169LL));
  if (v10)
  {
    char v11 = (dyld3::MachOFile *)v10;
    if (dyld3::MachOFile::isDylib((dyld3::MachOFile *)v10))
    {
      int v12 = *(_BYTE **)(a1 + 64);
      if (!v12[7])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot load dylib '%s'");
        return;
      }
    }

    else if (dyld3::MachOFile::isBundle(v11))
    {
      int v12 = *(_BYTE **)(a1 + 64);
      if (!v12[8])
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "cannot link against bundle '%s'");
        return;
      }
    }

    else
    {
      if (!dyld3::MachOFile::isMainExecutable(v11))
      {
        Diagnostics::error(*(vm_address_t **)(a1 + 40), "unloadable mach-o file type %d '%s'");
        return;
      }

      int v12 = *(_BYTE **)(a1 + 64);
      if (!v12[9])
      {
        uint64_t v21 = *(vm_address_t **)(a1 + 40);
        if (v12[1]) {
          Diagnostics::error(v21, "cannot link against a main executable '%s'");
        }
        else {
          Diagnostics::error(v21, "cannot dlopen a main executable '%s'");
        }
        return;
      }
    }

    char v13 = v12[4];
    if (v12[10])
    {
      BOOL v14 = 0;
    }

    else if (*v12)
    {
      BOOL v14 = 1;
    }

    else
    {
      BOOL v14 = dyld3::MachOAnalyzer::neverUnload(v11);
    }

    unint64_t v15 = dyld3::MachOFile::mappedSize(v11);
    char v16 = *((_BYTE *)a5 + 24);
    uint64_t v17 = *a5;
    v23[0] = _NSConcreteStackBlock;
    v23[2] = ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2;
    v23[3] = &unk_18961FEF8;
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v19 = *(void *)(a1 + 32);
    v23[6] = *(void *)(a1 + 40);
    v23[7] = v18;
    uint64_t v20 = a5[2];
    v23[1] = 0x40000000LL;
    v23[8] = a6;
    v23[9] = v15;
    BOOL v28 = v14;
    v23[10] = v11 - this;
    v23[12] = v17;
    v23[13] = v20;
    char v24 = v16;
    void v23[4] = v19;
    v23[5] = v11;
    uint64_t v25 = a5;
    char v29 = v13;
    char v30 = *(_BYTE *)(a1 + 84);
    int v27 = *(_DWORD *)(a1 + 80);
    int8x16_t v26 = vextq_s8(*(int8x16_t *)(a1 + 64), *(int8x16_t *)(a1 + 64), 8uLL);
    dyld4::JustInTimeLoader::withRegions(v11, (uint64_t)v23);
  }

void ___ZN5dyld416JustInTimeLoader24makeJustInTimeLoaderDiskER11DiagnosticsRNS_12RuntimeStateEPKcRKNS_6Loader11LoadOptionsEbjPKN6mach_o6LayoutE_block_invoke_2( uint64_t a1, void *a2)
{
  BOOL hasCodeSignature = dyld3::MachOFile::hasCodeSignature(*(dyld3::MachOFile **)(a1 + 40), &v9, &v10);
  LOBYTE(v8) = 0;
  __int16 v5 = (mach_o::Header *)dyld4::Loader::mapSegments( *(vm_address_t **)(a1 + 48),  *(dyld4::SyscallDelegate ***)(a1 + 56),  *(dyld3 **)(a1 + 64),  *(void *)(a1 + 72),  &v9,  hasCodeSignature,  a2,  (void *)*(unsigned __int8 *)(a1 + 164),  v8,  a1 + 80);
  if (v5)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dyld4::JustInTimeLoader::make( *(void *)(a1 + 56),  v5,  *(const char **)(a1 + 64),  *(__int128 **)(a1 + 136),  *(void *)(a1 + 80),  *(_BYTE *)(a1 + 164),  *(_BYTE *)(a1 + 165),  *(unsigned __int8 *)(a1 + 166),  *(_DWORD *)(a1 + 160));
    int v6 = *(dyld4::RuntimeState **)(a1 + 56);
    if (*(_BYTE *)(*((void *)v6 + 1) + 200LL)) {
      dyld4::Loader::logLoad( *(dyld4::Loader **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  v6,  *(char **)(a1 + 64));
    }
    if (*(_BYTE *)(*(void *)(a1 + 152) + 3LL))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      *(void *)(v7 + 40) |= 0x80000uLL;
    }
  }

void *dyld4::JustInTimeLoader::makeLaunchLoader( dyld4::JustInTimeLoader *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld3::MachOAnalyzer *a4, const char *a5, const mach_o::Layout *a6)
{
  uint64_t v9 = dyld4::Loader::getOnDiskBinarySliceOffset(a2, a3, a4, (const char *)a4);
  dyld4::SyscallDelegate::fileExists(*((void *)a2 + 1), a4, (uint64_t)v11, 0LL);
  return dyld4::JustInTimeLoader::make((uint64_t)a2, a3, (const char *)a4, v11, v9, 1, 0, 0, 0);
}

void *dyld4::JustInTimeLoader::makePseudoDylibLoader( vm_address_t *a1, uint64_t a2, const char *a3, uint64_t a4, mach_o::Header **a5)
{
  uint64_t v9 = *a5;
  memset(v11, 0, sizeof(v11));
  if ((dyld3::MachOFile::loadableIntoProcess(v9, *(_DWORD *)(*(void *)(a2 + 8) + 68LL), a3, 0) & 1) != 0)
  {
    __n128 result = dyld4::JustInTimeLoader::make(a2, v9, a3, v11, 0LL, 0, 0, 0, 0);
    result[13] = a5;
  }

  else
  {
    Diagnostics::error(a1, "wrong platform to load into process");
    return 0LL;
  }

  return result;
}

void *___ZN5dyld4L19getObjCPatchClassesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  __n128 result = (void *)Diagnostics::hasError((Diagnostics *)(a1 + 40));
  if ((_DWORD)result)
  {
    *a3 = 1;
    return result;
  }

  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v7 + 40), 1LL);
  }

  else
  {
    uint64_t v15 = 0LL;
    char v14 = 0;
    int hasExportedSymbol = dyld3::MachOLoaded::hasExportedSymbol( *(dyld3::MachOFile **)(a1 + 48),  *(const unsigned __int8 **)(a2 + 8),  0LL,  &v15,  &v14);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v7 + 40), 1LL);
    if (hasExportedSymbol)
    {
      uint64_t v9 = v15;
      uint64_t v10 = *(void *)(v7 + 40);
      uint64_t v11 = *(void *)(v7 + 56);
      *(void *)(v7 + 56) = v11 + 1;
      *(void *)(v10 + 8 * v11) = v9;
      return result;
    }
  }

  uint64_t v12 = *(void *)(v7 + 40);
  uint64_t v13 = *(void *)(v7 + 56);
  *(void *)(v7 + 56) = v13 + 1;
  *(void *)(v12 + 8 * v13) = 0LL;
  return result;
}

void __destroy_helper_block_8_40c17_ZTS11Diagnostics(uint64_t a1)
{
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v21, 0, sizeof(v21));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v21, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v21, 1LL);
      uint64_t v6 = (*(void *)&v21[1])++;
      *(_DWORD *)(*(void *)&v21[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = (void *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        unint64_t v9 = (*(void *)&v21[1] - 1LL) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1)
        {
          uint64_t v10 = 1LL;
          do
            unint64_t v9 = (*(void *)&v21[1] - 1LL) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v21, v9) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v21)
    {
      *(void *)&v21[1] = 0LL;
      if (*((void *)&v21[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v21[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v21[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v21 + 8);
      vm_size_t v12 = size;
      *(void *)(a1 + 40) = *((void *)&v21[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }

  unint64_t v13 = (*(void *)(a1 + 32) - 1LL) & *a2;
  unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_20:
    uint64_t v16 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v16;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(a1 + 56), 1LL);
    uint64_t v17 = *(void *)(a1 + 56);
    uint64_t v18 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v18 + 1;
    *(_OWORD *)(v17 + 16 * v18) = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a1 + 72);
    if (!v19) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 16 * v19 - 16;
  }

  else
  {
    uint64_t v15 = 1LL;
    while (*(void *)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14) != *a2)
    {
      unint64_t v13 = (*(void *)(a1 + 32) - 1LL) & (v13 + v15++);
      unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1) {
        goto LABEL_20;
      }
    }

    return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14);
  }

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve( a1,  a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 16 * a2;
}

void *dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve( void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 16 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    __n128 result = memmove((void *)v3[3], *v3, 16LL * (void)v3[2]);
    vm_address_t v11 = (const void *)((unint64_t)v3[4] >> 4);
    *uint64_t v3 = v3[3];
    v3[1] = v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L19getSingletonPatchesEPKN5dyld313MachOAnalyzerERNS0_3MapIPKvbNS_11HashPointerENS_12EqualPointerEEE_block_invoke( uint64_t result, int a2, uint64_t a3)
{
  if (a2 == 1)
  {
    uint64_t v9 = v3;
    uint64_t v10 = v4;
    uint64_t v6 = *(void *)(result + 32);
    uint64_t v5 = *(void *)(result + 40);
    uint64_t v7 = v6 + a3;
    char v8 = 1;
    return dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::insert(v5, &v7);
  }

  return result;
}

uint64_t ___ZN5dyld4L12hasDataConstEPKN5dyld39MachOFileE_block_invoke(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 56) & 2) != 0) {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

uint64_t dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  uint64_t v3 = 32LL;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1LL);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }

  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  return a1;
}

uint64_t dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>( uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  unint64_t v5 = a3[2];
  if (!v5) {
    return *a3;
  }
  unint64_t v6 = a2[2];
  unint64_t v7 = (v6 - 1) & *a5;
  if (v6 <= v7) {
LABEL_8:
  }
    dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>();
  uint64_t v8 = *a3;
  uint64_t v9 = 1LL;
  while (1)
  {
    unint64_t v10 = *(unsigned int *)(*a2 + 4 * v7);
    if ((_DWORD)v10 == -1) {
      return v8 + 16 * v5;
    }
    if (v5 <= v10) {
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    }
    if (*(void *)(v8 + 16 * v10) == *a5) {
      return v8 + 16 * v10;
    }
    unint64_t v7 = (v7 + v9++) & (v6 - 1);
    if (v6 <= v7) {
      goto LABEL_8;
    }
  }

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(result, v2);
  }

  return result;
}

uint64_t lsl::Vector<dyld4::ObjCClassReplacement>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    __n128 result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 32 * a2);
    if ((result & 1) == 0)
    {
      __n128 result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 32 * a2);
      uint64_t v4 = result;
      unint64_t v5 = *(void *)(v3 + 16);
      if (v5)
      {
        uint64_t v6 = 0LL;
        for (unint64_t i = 0LL; i < v5; ++i)
        {
          uint64_t v8 = (_OWORD *)(result + v6);
          uint64_t v9 = (_OWORD *)(*(void *)(v3 + 8) + v6);
          __int128 v10 = v9[1];
          *uint64_t v8 = *v9;
          v8[1] = v10;
          unint64_t v5 = *(void *)(v3 + 16);
          v6 += 32LL;
        }
      }

      vm_address_t v11 = *(void **)(v3 + 8);
      if (v11)
      {
        __n128 result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v11);
        unint64_t v5 = *(void *)(v3 + 16);
      }

      if (v5 >= a2) {
        unint64_t v5 = a2;
      }
      *(void *)(v3 + 8) = v4;
      *(void *)(v3 + 16) = v5;
    }

    *(void *)(v3 + 24) = a2;
  }

  return result;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef( unint64_t *a1, vm_address_t *this, uint64_t a3)
{
  int v4 = *(_DWORD *)(a3 + 32);
  if (v4 == 1)
  {
    if (*(void *)a3) {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)a3 + 6LL);
    }
    else {
      uint64_t v8 = 0x7FFFLL;
    }
    unint64_t v9 = *(void *)(a3 + 16);
    *a1 = (v8 | (HIBYTE(v9) << 16)) & 0x8000000000FFFFFFLL | ((v9 & 0x7FFFFFFFFFLL) << 24);
    uint64_t v10 = v9 & 0x7FFFFFFFFFLL;
    if ((v9 & 0x4000000000LL) != 0) {
      uint64_t v10 = v9 & 0x7FFFFFFFFFLL | 0xFFFF8000000000LL;
    }
    if ((v10 | v9 & 0xFF00000000000000LL) != *(void *)(a3 + 16)) {
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
    }
  }

  else if (v4 == 2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = __ROR8__(v5, 56);
    *a1 = v6 | 0x8000000000000000LL;
    if ((v6 & 0x4000000000000000LL) != 0) {
      unint64_t v7 = (v6 | 0x8000000000000000LL) >> 8;
    }
    else {
      unint64_t v7 = ((v6 | 0x8000000000000000LL) >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    if ((v7 | (v6 << 56)) != *(void *)(a3 + 16)) {
      Diagnostics::error( this,  "unencodeable absolute value (0x%llx) for symbol '%s'",  *(void *)(a3 + 16),  *(const char **)(a3 + 8));
    }
  }

  return a1;
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::offset(dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1 = *(void *)this >> 16;
  if ((*(void *)this & 0x4000000000000000LL) != 0) {
    uint64_t v2 = (*(void *)this >> 24) | 0xFFFF8000000000LL;
  }
  else {
    uint64_t v2 = (*(void *)this >> 24) & 0x7FFFFFFFFFLL;
  }
  return v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v1 << 56);
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::value( dyld4::PrebuiltLoader::BindTargetRef *this, dyld4::RuntimeState *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000LL) != 0)
  {
    uint64_t v10 = (v3 >> 8) | 0x80000000000000LL;
    if ((v3 & 0x4000000000000000LL) == 0) {
      uint64_t v10 = (v3 >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    return v10 | (v3 << 56);
  }

  else
  {
    __int16 v11 = *(void *)this;
    uint64_t v6 = (dyld4::PrebuiltLoader *)dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v11, a2, a3);
    uint64_t Address = dyld4::PrebuiltLoader::loadAddress(v6, a2);
    uint64_t v8 = (*(void *)this >> 24) | 0xFFFF8000000000LL;
    if ((*(void *)this & 0x4000000000000000LL) == 0) {
      uint64_t v8 = (*(void *)this >> 24) & 0x7FFFFFFFFFLL;
    }
    return Address + (*(void *)this >> 16 << 56) + v8;
  }

uint64_t dyld4::PrebuiltLoader::BindTargetRef::loaderRef( dyld4::PrebuiltLoader::BindTargetRef *this, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)this;
  if (result < 0) {
    dyld4::PrebuiltLoader::BindTargetRef::loaderRef(result, a2, a3);
  }
  return result;
}

uint64_t dyld4::PrebuiltLoader::loadAddress(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  int v2 = *((__int16 *)this + 3);
  if (v2 < 0) {
    return dyld4::RuntimeState::appLoadAddress(a2, v2 & 0x7FFF);
  }
  else {
    return dyld4::RuntimeState::cachedDylibLoadAddress(a2, *((unsigned __int16 *)this + 3));
  }
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset( dyld4::PrebuiltLoader::BindTargetRef *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(void *)this >> 24;
  if ((*(void *)this & 0x4000000000000000LL) != 0) {
    v2 |= 0xFFFF8000000000uLL;
  }
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)BYTE2(*(void *)this) << 56);
  uint64_t v4 = ((unint64_t)v1 >> 8) | 0x80000000000000LL;
  if ((v1 & 0x4000000000000000LL) == 0) {
    uint64_t v4 = ((unint64_t)v1 >> 8) & 0x7FFFFFFFFFFFFFLL;
  }
  uint64_t v5 = v4 | (v1 << 56);
  if (v1 < 0) {
    return v5;
  }
  else {
    return v3;
  }
}

unint64_t dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute( dyld4::PrebuiltLoader::BindTargetRef *this)
{
  return v2;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef(unint64_t *this, uint64_t a2)
{
  uint64_t v2 = __ROR8__(a2, 56);
  *this = v2 | 0x8000000000000000LL;
  unint64_t v3 = ((v2 | 0x8000000000000000LL) >> 8) & 0x7FFFFFFFFFFFFFLL;
  if ((v2 & 0x4000000000000000LL) != 0) {
    unint64_t v3 = (v2 | 0x8000000000000000LL) >> 8;
  }
  if ((v3 | (v2 << 56)) != a2) {
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  }
  return this;
}

unint64_t *dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef( unint64_t *this, const BindTarget *a2)
{
  if (a2->var0) {
    uint64_t v2 = *((unsigned __int16 *)a2->var0 + 3);
  }
  else {
    uint64_t v2 = 0x7FFFLL;
  }
  unint64_t var1 = a2->var1;
  *this = (v2 | (HIBYTE(var1) << 16)) & 0x8000000000FFFFFFLL | ((var1 & 0x7FFFFFFFFFLL) << 24);
  uint64_t v4 = var1 & 0x7FFFFFFFFFLL;
  if ((var1 & 0x4000000000LL) != 0) {
    uint64_t v4 = var1 & 0x7FFFFFFFFFLL | 0xFFFF8000000000LL;
  }
  if ((v4 | var1 & 0xFF00000000000000LL) != a2->var1) {
    dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef();
  }
  return this;
}

uint64_t dyld4::PrebuiltLoader::path(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  if (*((_WORD *)this + 16)) {
    return (uint64_t)this + *((unsigned __int16 *)this + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoader::contains( dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2, char *a3, const void **a4, unint64_t *a5, unsigned __int8 *a6)
{
  unint64_t Address = dyld4::PrebuiltLoader::loadAddress(this, a2);
  unint64_t v12 = *((unsigned __int16 *)this + 22);
  unint64_t v13 = &a3[-Address];
  unint64_t v14 = (char *)this + *((unsigned __int16 *)this + 23);
  uint64_t v15 = 16 * (v12 >> 4);
  while (1)
  {
    unint64_t v16 = *(void *)v14 & 0x7FFFFFFFFFFFFFFLL;
    if ((unint64_t)v13 >= v16)
    {
      unint64_t v17 = *((unsigned int *)v14 + 3);
    }

    v14 += 16;
    v15 -= 16LL;
    if (!v15) {
      return 0LL;
    }
  }

  *a4 = (const void *)(Address + v16);
  *a5 = v17;
  *a6 = (*(void *)v14 >> 59) & 7;
  return 1LL;
}

BOOL dyld4::PrebuiltLoader::matchesPath( dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2, const char *__s1)
{
  if (*((_WORD *)this + 16)) {
    uint64_t v5 = (char *)this + *((unsigned __int16 *)this + 16);
  }
  else {
    uint64_t v5 = 0LL;
  }
  return !_platform_strcmp(__s1, v5)
      || *((_WORD *)this + 20) && !_platform_strcmp(__s1, (const char *)this + *((unsigned __int16 *)this + 20));
}

double dyld4::PrebuiltLoader::fileID@<D0>(dyld4::PrebuiltLoader *this@<X0>, int8x16_t *a2@<X8>)
{
  if (this && *((_WORD *)this + 21))
  {
    unint64_t v3 = (char *)this + *((unsigned __int16 *)this + 21);
    uint64_t v4 = *((void *)v3 + 3);
    char v5 = v3[52];
    int8x16_t v6 = vextq_s8(*(int8x16_t *)(v3 + 8), *(int8x16_t *)(v3 + 8), 8uLL);
    *a2 = v6;
    a2[1].i64[0] = v4;
    a2[1].i8[8] = v5;
  }

  else
  {
    v6.i64[0] = 0LL;
    *a2 = 0u;
    a2[1] = 0u;
  }

  return *(double *)v6.i64;
}

uint64_t dyld4::PrebuiltLoader::dependentCount(dyld4::PrebuiltLoader *this)
{
  return *((unsigned __int16 *)this + 24);
}

BOOL dyld4::PrebuiltLoader::recordedCdHashIs(dyld4::PrebuiltLoader *this, const unsigned __int8 *a2)
{
  BOOL result = 0LL;
  if (this && *((_WORD *)this + 21))
  {
    uint64_t v4 = (char *)this + *((unsigned __int16 *)this + 21);
    if (v4[53])
    {
      uint64_t v5 = *((void *)v4 + 4);
      uint64_t v6 = *((void *)v4 + 5);
      uint64_t v7 = *((unsigned int *)v4 + 12);
      return v5 == *(void *)a2 && v6 == *((void *)a2 + 1) && v7 == *((_DWORD *)a2 + 4);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void dyld4::PrebuiltLoader::map(dyld4::Loader *this, vm_address_t *a2, dyld4::RuntimeState *a3)
{
  __int16 v3 = *((_WORD *)this + 3);
  if (v3 >= 0) {
    uint64_t v4 = (char *)a3 + 968;
  }
  else {
    uint64_t v4 = (char *)a3 + 992;
  }
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = v3 & 0x7FFF;
  if (*(_BYTE *)(*((void *)a3 + 1) + 207LL))
  {
    if (*((_WORD *)this + 16)) {
      uint64_t v10 = (char *)this + *((unsigned __int16 *)this + 16);
    }
    else {
      uint64_t v10 = 0LL;
    }
    dyld4::RuntimeState::log(a3, "using PrebuiltLoader %p for %s\n", this, v10);
  }

  unsigned int v11 = *((unsigned __int16 *)this + 2);
  if ((v11 & 2) != 0)
  {
    *(_BYTE *)(v5 + v6) = 3;
    uint64_t v19 = (_BYTE *)*((void *)a3 + 1);
    if (v19[201])
    {
      dyld4::Loader::logSegmentsFromSharedCache(this, a3);
      uint64_t v19 = (_BYTE *)*((void *)a3 + 1);
    }

    if (v19[200])
    {
      if (*((_WORD *)this + 16)) {
        uint64_t v20 = (char *)this + *((unsigned __int16 *)this + 16);
      }
      else {
        uint64_t v20 = 0LL;
      }
      dyld4::Loader::logLoad(this, a3, v20);
      uint64_t v19 = (_BYTE *)*((void *)a3 + 1);
    }

    if (v19[157] && (*((_WORD *)this + 22) & 8) != 0) {
      *((_BYTE *)a3 + 1127) = 1;
    }
  }

  else if (*((dyld4::Loader **)a3 + 3) == this)
  {
    dyld4::PrebuiltLoader::setLoadAddress((uint64_t)this, (uint64_t)a3, *(void *)(*((void *)a3 + 1) + 8LL));
  }

  else
  {
    if (*((_WORD *)this + 16)) {
      unint64_t v12 = (dyld4::Loader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = *((unsigned int *)this + 19);
    unint64_t v14 = (unint64_t)*((unsigned __int16 *)this + 22) >> 4;
    v25[0] = (char *)this + *((unsigned __int16 *)this + 23);
    v25[1] = v14;
    v25[2] = v14;
    uint64_t v15 = (void *)((v11 >> 5) & 1);
    if (*((_WORD *)this + 21)) {
      unint64_t v16 = (char *)this + *((unsigned __int16 *)this + 21);
    }
    else {
      unint64_t v16 = 0LL;
    }
    LOBYTE(v24) = 1;
    vm_address_t v17 = dyld4::Loader::mapSegments( a2,  (dyld4::SyscallDelegate **)a3,  v12,  v13,  (unsigned int *)this + 20,  1LL,  v25,  v15,  v24,  (uint64_t)v16);
    if (Diagnostics::hasError((Diagnostics *)a2)) {
      return;
    }
    dyld4::PrebuiltLoader::setLoadAddress((uint64_t)this, (uint64_t)a3, v17);
    *(_BYTE *)(v5 + v6) = 3;
    if (*(_BYTE *)(*((void *)a3 + 1) + 200LL))
    {
      if (*((_WORD *)this + 16)) {
        uint64_t v18 = (char *)this + *((unsigned __int16 *)this + 16);
      }
      else {
        uint64_t v18 = 0LL;
      }
      dyld4::Loader::logLoad(this, a3, v18);
    }
  }

  if (*(_DWORD *)(*((void *)a3 + 1) + 540LL) && (uint64_t v21 = *((void *)a3 + 6)) != 0)
  {
    unint64_t v22 = (dyld4::Loader **)*((void *)a3 + 5);
    uint64_t v23 = 8 * v21;
    while (*v22 != this)
    {
      ++v22;
      v23 -= 8LL;
      if (!v23) {
        goto LABEL_42;
      }
    }
  }

  else
  {
LABEL_42:
    dyld4::RuntimeState::add(a3, this);
  }

uint64_t dyld4::PrebuiltLoader::setLoadAddress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(__int16 *)(a1 + 6);
  if ((v3 & 0x80000000) == 0) {
    dyld4::PrebuiltLoader::setLoadAddress();
  }
  return dyld4::RuntimeState::setAppLoadAddress(a2, v3 & 0x7FFF, a3);
}

void dyld4::PrebuiltLoader::loadDependents( uint64_t a1, vm_address_t *a2, dyld4::RuntimeState *a3, __int128 *a4)
{
  __int16 v8 = *(_WORD *)(a1 + 6);
  if (v8 >= 0) {
    unint64_t v9 = (uint64_t *)((char *)a3 + 968);
  }
  else {
    unint64_t v9 = (uint64_t *)((char *)a3 + 992);
  }
  uint64_t v10 = *v9;
  uint64_t v11 = v8 & 0x7FFF;
  dyld4::PrebuiltLoader::map((dyld4::Loader *)a1, a2, a3);
  if (*(unsigned __int8 *)(v10 + v11) <= 3u)
  {
    *(_BYTE *)(v10 + v11) = 4;
    __chkstk_darwin(v12, v13, v14, v15, v16, v17, v18, v19, v28);
    uint64_t v20 = (char *)&v28 - v21;
    LODWORD(v21) = *(unsigned __int16 *)(a1 + 48);
    if (*(_WORD *)(a1 + 48))
    {
      unint64_t v22 = 0LL;
      do
      {
        uint64_t v23 = (dyld4::Loader *)dyld4::PrebuiltLoader::dependent((_WORD *)a1, a3, v22, 0LL);
        *(void *)&v20[8 * v22] = v23;
        if (v23) {
          dyld4::PrebuiltLoader::map(v23, a2, a3);
        }
        ++v22;
        unint64_t v21 = *(unsigned __int16 *)(a1 + 48);
      }

      while (v22 < v21);
    }

    v31[0] = *((void *)a4 + 2);
    v31[1] = a1;
    __int128 v24 = a4[1];
    __int128 v28 = *a4;
    __int128 v29 = v24;
    uint64_t v25 = *((void *)a4 + 4);
    BYTE11(v28) = *(_BYTE *)(a1 + 5) & 1;
    uint64_t v30 = v25;
    *(void *)&__int128 v29 = v31;
    if ((_DWORD)v21)
    {
      unint64_t v26 = 0LL;
      do
      {
        uint64_t v27 = *(void *)&v20[8 * v26];
        if (v27)
        {
          dyld4::PrebuiltLoader::loadDependents(v27, a2, a3, &v28);
          LODWORD(v21) = *(unsigned __int16 *)(a1 + 48);
        }

        ++v26;
      }

      while (v26 < v21);
    }

    *(_BYTE *)(v10 + v11) = 5;
  }

uint64_t dyld4::PrebuiltLoader::dependent(_WORD *a1, dyld4::RuntimeState *a2, uint64_t a3, char *a4)
{
  if (a4)
  {
    if (a1[18]) {
      uint64_t v6 = (char *)a1 + (unsigned __int16)a1[18] + a3;
    }
    else {
      uint64_t v6 = &mach_o::LinkedDylibAttributes::regular;
    }
    *a4 = *v6;
  }

  __int16 v11 = *(_WORD *)((char *)&a1[a3] + (unsigned __int16)a1[17]);
  if (v11 == 0x7FFF) {
    return 0LL;
  }
  uint64_t result = dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v11, a2, a3);
  if ((a1[2] & 2) != 0 && (*(_WORD *)(result + 44) & 4) == 0 && *(_BYTE *)(*((void *)a2 + 1) + 157LL))
  {
    int v9 = *(unsigned __int16 *)(result + 60);
    if (v9 != 0xFFFF)
    {
      __int16 v10 = v9 & 0x7FFF;
      return dyld4::Loader::LoaderRef::loader((dyld4::Loader::LoaderRef *)&v10, a2, v8);
    }
  }

  return result;
}

uint64_t dyld4::PrebuiltLoader::unmap(uint64_t this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *(_WORD *)(this + 6);
  if (v2 >= 0) {
    int v3 = (char *)a2 + 968;
  }
  else {
    int v3 = (char *)a2 + 992;
  }
  *(_BYTE *)(*(void *)v3 + (v2 & 0x7FFF)) = 2;
  return this;
}

void dyld4::PrebuiltLoader::applyFixups( uint64_t a1, Diagnostics *a2, uint64_t a3, dyld4::DyldCacheDataConstLazyScopedWriter *a4)
{
  if ((*(_WORD *)(a1 + 4) & 2) != 0)
  {
    if (*(unsigned __int8 *)(a3 + 1126) | *(unsigned __int8 *)(a3 + 1127) && (uint64_t v8 = *(void *)(a3 + 48)) != 0)
    {
      __int16 v10 = *(dyld4::Loader ***)(a3 + 40);
      uint64_t v11 = 8 * v8;
      do
      {
        uint64_t v12 = *v10++;
        dyld4::Loader::applyCachePatchesTo(v12, (dyld4::RuntimeState *)a3, (const dyld4::Loader *)a1, a4);
        v11 -= 8LL;
      }

      while (v11);
      int v7 = (*(unsigned __int16 *)(a1 + 4) >> 1) & 1;
    }

    else
    {
      int v7 = 1;
    }
  }

  else
  {
    int v7 = 0;
  }

  int v13 = *(__int16 *)(a1 + 6);
  uint64_t v14 = (uint64_t *)(a3 + 992);
  if (v13 >= 0) {
    uint64_t v14 = (uint64_t *)(a3 + 968);
  }
  uint64_t v15 = *v14;
  if (!v7 || v13 < 0)
  {
    uint64_t v44 = *(_WORD *)(a1 + 6) & 0x7FFF;
    uint64_t v45 = v15;
    char v46 = (vm_address_t *)a2;
    v52[0] = &v57;
    v52[1] = 512LL;
    vm_address_t v54 = 0LL;
    vm_size_t v55 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v16 = *(unsigned int *)(a1 + 52);
    if ((_DWORD)v16)
    {
      uint64_t v17 = (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + *(unsigned __int16 *)(a1 + 50));
      uint64_t v18 = 8 * v16;
      do
      {
        unint64_t v19 = dyld4::PrebuiltLoader::BindTargetRef::value(v17, (dyld4::RuntimeState *)a3, a3);
        if (*(_BYTE *)(*(void *)(a3 + 8) + 202LL))
        {
          uint64_t v20 = *(void *)v17;
          unint64_t v21 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
          if (v20 < 0)
          {
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p\n");
          }

          else
          {
            if ((*(void *)v17 & 0x8000000000000000LL) != 0) {
              dyld4::PrebuiltLoader::BindTargetRef::loaderRef((uint64_t)v21, v22, v23);
            }
            v56[0] = *(void *)v17;
            __int128 v24 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader( (dyld4::Loader::LoaderRef *)v56,  (const dyld4::RuntimeState *)a3,  v23);
            dyld4::Loader::leafName(v24, (const dyld4::RuntimeState *)a3);
            dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
          }
        }

        dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v52, 1LL);
        uint64_t v25 = v53++;
        *(void *)(v52[0] + 8 * v25) = v19;
        uint64_t v17 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v17 + 8);
        v18 -= 8LL;
      }

      while (v18);
    }

    if (!Diagnostics::hasError(a2))
    {
      v48[0] = v56;
      v48[1] = 32LL;
      vm_address_t address = 0LL;
      vm_size_t size = 0LL;
      uint64_t v49 = 0LL;
      uint64_t v27 = *(unsigned int *)(a1 + 96);
      if ((_DWORD)v27)
      {
        __int128 v28 = (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + *(unsigned int *)(a1 + 92));
        uint64_t v29 = 8 * v27;
        do
        {
          if ((*(void *)v28 & 0x800000000000FFFFLL) == 0x7FFF)
          {
            if (*(_BYTE *)(*(void *)(a3 + 8) + 202LL))
            {
              uint64_t v30 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
              dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> missing-weak-bind\n", v30, v49);
            }

            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v48, 1LL);
            uint64_t v31 = v49++;
            *(void *)(v48[0] + 8 * v31) = -1LL;
          }

          else
          {
            unint64_t v32 = dyld4::PrebuiltLoader::BindTargetRef::value(v28, (dyld4::RuntimeState *)a3, v26);
            if (*(_BYTE *)(*(void *)(a3 + 8) + 202LL))
            {
              uint64_t v33 = *(void *)v28;
              uint64_t v34 = dyld4::Loader::leafName((dyld4::Loader *)a1, (const dyld4::RuntimeState *)a3);
              if (v33 < 0)
              {
                dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p\n");
              }

              else
              {
                if ((*(void *)v28 & 0x8000000000000000LL) != 0) {
                  dyld4::PrebuiltLoader::BindTargetRef::loaderRef((uint64_t)v34, v35, v36);
                }
                LOWORD(v47[0]) = *(void *)v28;
                unint64_t v37 = (dyld4::Loader *)dyld4::Loader::LoaderRef::loader( (dyld4::Loader::LoaderRef *)v47,  (const dyld4::RuntimeState *)a3,  v36);
                dyld4::Loader::leafName(v37, (const dyld4::RuntimeState *)a3);
                dyld4::RuntimeState::log((dyld4::RuntimeState *)a3, "<%s/bind#%llu> -> %p (%s+0x%08llX)\n");
              }
            }

            dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v48, 1LL);
            uint64_t v38 = v49++;
            *(void *)(v48[0] + 8 * v38) = v32;
          }

          __int128 v28 = (dyld4::PrebuiltLoader::BindTargetRef *)((char *)v28 + 8);
          v29 -= 8LL;
        }

        while (v29);
      }

      if (!Diagnostics::hasError((Diagnostics *)v46))
      {
        if (!a1
          || !*(_WORD *)(a1 + 42)
          || (uint64_t v39 = a1 + *(unsigned __int16 *)(a1 + 42), !*(_BYTE *)(v39 + 52))
          || (uint64_t v40 = *(void *)v39, *(void *)v39 == -1LL))
        {
          uint64_t v41 = (dyld4::RuntimeState *)dyld4::Loader::analyzer((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
          if (*(_WORD *)(a1 + 32)) {
            vm_size_t v43 = (const dyld3::MachOAnalyzer *)(a1 + *(unsigned __int16 *)(a1 + 32));
          }
          else {
            vm_size_t v43 = 0LL;
          }
          uint64_t v40 = dyld4::Loader::getOnDiskBinarySliceOffset((dyld4::Loader *)a3, v41, v43, v42);
        }

        memset(v47, 0, sizeof(v47));
        dyld4::Loader::applyFixupsGeneric( (dyld4::Loader *)a1,  v46,  (dyld4::RuntimeState *)a3,  v40,  (uint64_t)v52,  (uint64_t)v48,  1LL,  (uint64_t)v47);
        dyld4::PrebuiltLoader::applyObjCFixups((dyld4::PrebuiltLoader *)a1, (dyld4::RuntimeState *)a3);
        if (dyld4::Loader::hasConstantSegmentsToProtect((dyld4::Loader *)a1)) {
          dyld4::Loader::makeSegmentsReadOnly((dyld4::Loader *)a1, (dyld4::RuntimeState *)a3);
        }
        *(_BYTE *)(v45 + v44) = 6;
      }

      uint64_t v49 = 0LL;
      if (address) {
        vm_deallocate(mach_task_self_, address, size);
      }
    }

    uint64_t v53 = 0LL;
    if (v54) {
      vm_deallocate(mach_task_self_, v54, v55);
    }
  }

  else
  {
    *(_BYTE *)(v15 + (*(_WORD *)(a1 + 6) & 0x7FFF)) = 6;
  }

void dyld4::PrebuiltLoader::applyObjCFixups(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  if (this)
  {
    uint64_t v3 = *((unsigned int *)this + 14);
    if ((_DWORD)v3)
    {
      uint64_t v5 = (char *)this + v3;
      unint64_t Address = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      unint64_t v32 = Address;
      uint64_t v33 = Address;
      int v7 = (dyld3::MachOFile *)dyld4::PrebuiltLoader::loadAddress(this, a2);
      int v8 = dyld3::MachOFile::pointerSize(v7);
      int v9 = (char *)Address + *(void *)v5;
      *((_DWORD *)v9 + 1) |= 0x80u;
      if (*(_BYTE *)(*((void *)a2 + 1) + 202LL)) {
        dyld4::RuntimeState::log(a2, "fixup: *0x%012lX = 0x%012lX <objc-info preoptimized>\n", v9, *(void *)v9);
      }
      dyld3::MachOAnalyzer::makeVMAddrConverter(Address, 1, (uint64_t)v31);
      uint64_t v10 = dyld3::MachOFile::preferredLoadAddress(Address);
      uint64_t v11 = v10;
      uint64_t v30 = v10;
      uint64_t v12 = *((unsigned int *)v5 + 16);
      if ((_DWORD)v12)
      {
        uint64_t v13 = *(void *)(*((void *)a2 + 123) + 56LL) + *(void *)(*((void *)a2 + 1) + 240LL);
        uint64_t v14 = *((unsigned int *)v5 + 13);
        uint64_t v26 = 0LL;
        uint64_t v27 = &v26;
        uint64_t v28 = 0x2000000000LL;
        int v29 = 0;
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 0x40000000LL;
        v24[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke;
        v24[3] = &unk_189620030;
        v24[6] = v14;
        _BYTE v24[7] = v14;
        v24[4] = &v26;
        v24[5] = &v5[v12];
        v24[8] = v10;
        v24[9] = Address;
        v24[10] = v13;
        v24[11] = a2;
        uint64_t v25 = v24;
        dyld3::MachOAnalyzer::forEachObjCProtocol(Address, *((void *)v5 + 4), v14, (uint64_t)v31, (uint64_t)&v25);
        _Block_object_dispose(&v26, 8);
      }

      uint64_t v15 = *((unsigned int *)v5 + 18);
      if ((_DWORD)v15)
      {
        uint64_t v16 = *(void *)(*((void *)a2 + 1) + 304LL);
        uint64_t v17 = &v5[*((unsigned int *)v5 + 17)];
        uint64_t v26 = 0LL;
        uint64_t v27 = &v26;
        uint64_t v28 = 0x2000000000LL;
        int v29 = 0;
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000LL;
        v23[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2;
        v23[3] = &unk_189620058;
        v23[6] = v15;
        v23[7] = v15;
        void v23[4] = &v26;
        v23[5] = v17;
        v23[8] = v16;
        v23[9] = a2;
        v23[10] = Address;
        dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique(a2, this, v11, (uint64_t)v5, (uint64_t)v23);
        _Block_object_dispose(&v26, 8);
      }

      if (v5[56])
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000LL;
        v22[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3;
        v22[3] = &__block_descriptor_tmp_35_0;
        v22[4] = v11;
        v22[5] = Address;
        v22[6] = a2;
        uint64_t v26 = v22;
        dyld3::MachOAnalyzer::forEachObjCClass( Address,  *((void *)v5 + 2),  *((unsigned int *)v5 + 11),  (uint64_t)v31,  (uint64_t)&v26);
      }

      if (v5[57])
      {
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000LL;
        void v20[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4;
        v20[3] = &__block_descriptor_tmp_36;
        v20[4] = &v30;
        v20[5] = &v33;
        v20[6] = &v32;
        void v20[7] = a2;
        int v21 = v8;
        uint64_t v26 = v20;
        dyld3::MachOAnalyzer::forEachObjCClass( Address,  *((void *)v5 + 2),  *((unsigned int *)v5 + 11),  (uint64_t)v31,  (uint64_t)&v26);
      }

      if (v5[58])
      {
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000LL;
        v19[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5;
        v19[3] = &__block_descriptor_tmp_38_0;
        v19[4] = &v30;
        v19[5] = &v33;
        v19[6] = &v32;
        v19[7] = a2;
        uint64_t v26 = v19;
        dyld3::MachOAnalyzer::forEachObjCCategory( v33,  *((void *)v5 + 3),  *((unsigned int *)v5 + 12),  (uint64_t)v31,  (uint64_t)&v26);
      }

      if (v5[59])
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000LL;
        v18[2] = ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6;
        v18[3] = &__block_descriptor_tmp_39;
        v18[4] = &v30;
        v18[5] = &v33;
        v18[6] = &v32;
        v18[7] = a2;
        uint64_t v26 = v18;
        dyld3::MachOAnalyzer::forEachObjCProtocol( v33,  *((void *)v5 + 4),  *((unsigned int *)v5 + 13),  (uint64_t)v31,  (uint64_t)&v26);
      }
    }
  }

BOOL dyld4::PrebuiltLoader::getExportsTrie( dyld4::PrebuiltLoader *this, unint64_t *a2, unsigned int *a3)
{
  *a2 = *((void *)this + 8);
  unsigned int v3 = *((_DWORD *)this + 18);
  *a3 = v3;
  return v3 != 0;
}

uint64_t dyld4::PrebuiltLoader::hiddenFromFlat(dyld4::PrebuiltLoader *this)
{
  return 0LL;
}

_WORD *dyld4::PrebuiltLoader::recursiveMarkBeingValidated( _WORD *this, const dyld4::RuntimeState *a2, BOOL a3)
{
  __int16 v3 = this[3];
  if (v3 >= 0) {
    uint64_t v4 = (char *)a2 + 968;
  }
  else {
    uint64_t v4 = (char *)a2 + 992;
  }
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = v3 & 0x7FFF;
  if (!*(_BYTE *)(v5 + v6))
  {
    BOOL v7 = a3;
    int v9 = this;
    if (!a3 || (this[2] & 2) == 0)
    {
      *(_BYTE *)(v5 + v6) = 1;
      if (this[24])
      {
        char v10 = 0;
        uint64_t v11 = 0LL;
        do
        {
          this = (_WORD *)dyld4::PrebuiltLoader::dependent(v9, a2, v11, 0LL);
          if (this)
          {
            uint64_t v12 = this;
            if ((this[2] & 1) == 0) {
              dyld4::PrebuiltLoader::recursiveMarkBeingValidated();
            }
            this = (_WORD *)dyld4::PrebuiltLoader::recursiveMarkBeingValidated((dyld4::PrebuiltLoader *)this, a2, v7);
            __int16 v13 = v12[3];
            if (v13 >= 0) {
              uint64_t v14 = (char *)a2 + 968;
            }
            else {
              uint64_t v14 = (char *)a2 + 992;
            }
            v10 |= *(unsigned __int8 *)(*(void *)v14 + (v13 & 0x7FFF)) == 255;
          }

          uint64_t v11 = (v11 + 1);
        }

        while (v11 < (unsigned __int16)v9[24]);
        if ((v10 & 1) != 0)
        {
          __int16 v15 = v9[3];
          if (v15 >= 0) {
            uint64_t v16 = (char *)a2 + 968;
          }
          else {
            uint64_t v16 = (char *)a2 + 992;
          }
          *(_BYTE *)(*(void *)v16 + (v15 & 0x7FFF)) = -1;
        }
      }
    }
  }

  return this;
}

BOOL dyld4::PrebuiltLoader::isValid(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2, uint64_t a3)
{
  __int16 v3 = *((_WORD *)this + 3);
  __int16 v4 = v3;
  uint64_t v5 = (char *)a2 + 992;
  if (v3 >= 0) {
    uint64_t v5 = (char *)a2 + 968;
  }
  int v6 = *(unsigned __int8 *)(*(void *)v5 + (v3 & 0x7FFF));
  if (v6 == 255) {
    return 0LL;
  }
  char v10 = this;
  int v11 = *(unsigned __int8 *)(*((void *)a2 + 1) + 399LL);
  if (!v6)
  {
    this = (dyld4::PrebuiltLoader *)dyld4::PrebuiltLoader::recursiveMarkBeingValidated(this, a2, v11 == 0);
    __int16 v4 = *((_WORD *)v10 + 3);
  }

  uint64_t v12 = 0LL;
  v45[0] = &v49;
  v45[1] = 1024LL;
  vm_address_t address = 0LL;
  vm_size_t size = 0LL;
  uint64_t v46 = 0LL;
  if ((v4 & 0x8000) == 0)
  {
LABEL_19:
    if (!v11) {
      goto LABEL_29;
    }
    goto LABEL_20;
  }

  uint64_t v13 = *((void *)a2 + 123);
  unsigned int v14 = *(_DWORD *)(v13 + 12);
  if (v14)
  {
    uint64_t v12 = 0LL;
    for (unsigned int i = 0; i < v14; ++i)
    {
      uint64_t v16 = v13 + *(unsigned int *)(v13 + *(unsigned int *)(v13 + 16) + 4LL * (unsigned __int16)i);
      __int16 v17 = *(_WORD *)(v16 + 6);
      if (v17 >= 0) {
        uint64_t v18 = (char *)a2 + 968;
      }
      else {
        uint64_t v18 = (char *)a2 + 992;
      }
      if (*(_BYTE *)(*(void *)v18 + (v17 & 0x7FFF)) == 1)
      {
        this = (dyld4::PrebuiltLoader *)dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v45, 1LL);
        uint64_t v19 = v46;
        uint64_t v12 = ++v46;
        *(void *)(v45[0] + 8 * v19) = v16;
        unsigned int v14 = *(_DWORD *)(v13 + 12);
      }
    }

    goto LABEL_19;
  }

  uint64_t v12 = 0LL;
  if (!v11) {
    goto LABEL_29;
  }
LABEL_20:
  uint64_t v20 = *((void *)a2 + 120);
  unsigned int v21 = *(_DWORD *)(v20 + 12);
  if (v21)
  {
    for (unsigned int j = 0; j < v21; ++j)
    {
      uint64_t v23 = v20 + *(unsigned int *)(v20 + *(unsigned int *)(v20 + 16) + 4LL * (unsigned __int16)j);
      __int16 v24 = *(_WORD *)(v23 + 6);
      if (v24 >= 0) {
        uint64_t v25 = (char *)a2 + 968;
      }
      else {
        uint64_t v25 = (char *)a2 + 992;
      }
      if (*(_BYTE *)(*(void *)v25 + (v24 & 0x7FFF)) == 1)
      {
        this = (dyld4::PrebuiltLoader *)dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v45, 1LL);
        uint64_t v26 = v46;
        uint64_t v12 = ++v46;
        *(void *)(v45[0] + 8 * v26) = v23;
        unsigned int v21 = *(_DWORD *)(v20 + 12);
      }
    }
  }

LABEL_29:
  if (v12)
  {
    uint64_t v27 = (dyld4::PrebuiltLoader **)v45[0];
    uint64_t v28 = 8 * v12;
    do
    {
      int v29 = *v27++;
      dyld4::PrebuiltLoader::invalidateInIsolation(v29, a2);
      v28 -= 8LL;
    }

    while (v28);
  }

  while (v46)
  {
    char v30 = 0;
    uint64_t v31 = (_WORD **)v45[0];
    uint64_t v32 = 8 * v46;
    do
    {
      __int16 v33 = (*v31)[3];
      if (v33 >= 0) {
        uint64_t v34 = (char *)a2 + 968;
      }
      else {
        uint64_t v34 = (char *)a2 + 992;
      }
      uint64_t v35 = *(void *)v34;
      uint64_t v36 = v33 & 0x7FFF;
      if (*(_BYTE *)(*(void *)v34 + v36) == 1)
      {
        dyld4::PrebuiltLoader::invalidateShallow(*v31, a2);
        if (*(_BYTE *)(v35 + v36) != 1) {
          char v30 = 1;
        }
      }

      ++v31;
      v32 -= 8LL;
    }

    while (v32);
    if ((v30 & 1) == 0)
    {
      if (v46)
      {
        uint64_t v37 = v45[0];
        uint64_t v38 = 8 * v46;
        do
        {
          __int16 v39 = *(_WORD *)(*(void *)v37 + 6LL);
          if (v39 >= 0) {
            uint64_t v40 = (char *)a2 + 968;
          }
          else {
            uint64_t v40 = (char *)a2 + 992;
          }
          uint64_t v41 = *(void *)v40;
          uint64_t v42 = v39 & 0x7FFF;
          if (*(_BYTE *)(v41 + v42) == 1) {
            *(_BYTE *)(v41 + v42) = 2;
          }
          v37 += 8LL;
          v38 -= 8LL;
        }

        while (v38);
      }

      break;
    }
  }

  __int16 v43 = *((_WORD *)v10 + 3);
  if (v43 >= 0) {
    uint64_t v44 = (char *)a2 + 968;
  }
  else {
    uint64_t v44 = (char *)a2 + 992;
  }
  BOOL v7 = *(unsigned __int8 *)(*(void *)v44 + (v43 & 0x7FFF)) != 255;
  uint64_t v46 = 0LL;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  return v7;
}

void dyld4::PrebuiltLoader::invalidateInIsolation( dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 968;
  }
  else {
    __int16 v3 = (char *)a2 + 992;
  }
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v2 & 0x7FFF;
  if ((*((_WORD *)this + 2) & 2) != 0)
  {
    uint64_t v19 = *((void *)a2 + 1);
    if (!*(void *)(v19 + 240))
    {
      *(_BYTE *)(v4 + v5) = -1;
      return;
    }

    if ((*((_WORD *)this + 22) & 2) != 0)
    {
      if (!*(_BYTE *)(v19 + 396))
      {
        if (*((_WORD *)this + 16)) {
          uint64_t v20 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
        }
        else {
          uint64_t v20 = 0LL;
        }
        uint64_t v19 = *((void *)a2 + 1);
      }

      *(void *)&__int128 v36 = 0LL;
      *((void *)&v36 + 1) = &v36;
      *(void *)&__int128 v37 = 0x2000000000LL;
      BYTE8(v37) = 0;
      char v35 = 0;
      if (*((_WORD *)this + 16)) {
        unsigned int v21 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
      }
      else {
        unsigned int v21 = 0LL;
      }
      uint64_t v22 = (const char *)*(unsigned int *)(v19 + 68);
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000LL;
      uint64_t v34[2] = ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke;
      v34[3] = &unk_189620008;
      v34[5] = this;
      void v34[6] = a2;
      v34[4] = &v36;
      dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v19 + 400, v21, v22, 0, 1, &v35, (uint64_t)v34);
      if (*(_BYTE *)(*((void *)&v36 + 1) + 24LL))
      {
        if (*(_BYTE *)(*((void *)a2 + 1) + 207LL))
        {
          uint64_t v23 = dyld4::Loader::leafName(this, a2);
          dyld4::console( (dyld4 *)"PrebuiltLoader %p '%s' not used because a file was found that overrides it\n",  v24,  this,  v23);
        }

        *(_BYTE *)(v4 + v5) = -1;
      }

      _Block_object_dispose(&v36, 8);
    }
  }

  else if (*((_WORD *)this + 21) && (int v8 = (char *)this + *((unsigned __int16 *)this + 21), v8[52]))
  {
    uint64_t v10 = *((void *)v8 + 1);
    uint64_t v9 = *((void *)v8 + 2);
    uint64_t v11 = *((void *)v8 + 3);
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    uint64_t v12 = *((void *)a2 + 1);
    if (*((_WORD *)this + 16)) {
      uint64_t v13 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      uint64_t v13 = 0LL;
    }
    if (!dyld4::SyscallDelegate::fileExists(v12, v13, (uint64_t)&v36, 0LL))
    {
      *(_BYTE *)(v4 + v5) = -1;
      if (!*(_BYTE *)(*((void *)a2 + 1) + 207LL)) {
        return;
      }
      uint64_t v18 = "PrebuiltLoader %p not used because file missing\n";
LABEL_56:
      dyld4::console((dyld4 *)v18, v14, this);
      return;
    }

    if (*((void *)&v36 + 1) != v10 || BYTE8(v37) == 0 || (void)v36 != v9 || (void)v37 != v11)
    {
      *(_BYTE *)(v4 + v5) = -1;
      if (*(_BYTE *)(*((void *)a2 + 1) + 207LL))
      {
        uint64_t v18 = "PrebuiltLoader %p not used because file inode/mtime does not match\n";
        goto LABEL_56;
      }
    }
  }

  else
  {
    if (*((_WORD *)this + 16)) {
      uint64_t v25 = (dyld4::PrebuiltLoader *)((char *)this + *((unsigned __int16 *)this + 16));
    }
    else {
      uint64_t v25 = 0LL;
    }
    uint64_t v26 = (const char **)*((void *)a2 + 1);
    if (_platform_strcmp((const char *)v25, v26[2]))
    {
      int v27 = dyld4::SyscallDelegate::open((dyld4::SyscallDelegate *)v26, v25, 0LL, 0LL);
      if (v27 == -1)
      {
        *(_BYTE *)(v4 + v5) = -1;
        if (*(_BYTE *)(*((void *)a2 + 1) + 207LL)) {
          dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cannot be opened\n", v28, this, v25);
        }
      }

      else
      {
        int v29 = v27;
        Diagnostics::Diagnostics((Diagnostics *)&v36);
        if (*((_WORD *)this + 21)) {
          char v30 = (char *)this + *((unsigned __int16 *)this + 21);
        }
        else {
          char v30 = 0LL;
        }
        size_t v32 = dyld4::Loader::validateFile( (vm_address_t *)&v36,  (uint64_t)a2,  v29,  (const char *)v25,  (unsigned int *)this + 20,  (uint64_t)v30);
        __int16 v33 = (dyld4::SyscallDelegate *)*((void *)a2 + 1);
        if (v32 == -1LL)
        {
          *(_BYTE *)(v4 + v5) = -1;
          if (*((_BYTE *)v33 + 207))
          {
            dyld4::console((dyld4 *)"PrebuiltLoader %p not used because file '%s' cdHash changed\n", v31, this, v25);
            __int16 v33 = (dyld4::SyscallDelegate *)*((void *)a2 + 1);
          }
        }

        dyld4::SyscallDelegate::close(v33, v29);
        mach_o::Error::~Error((vm_address_t **)&v36);
      }
    }
  }

_WORD *dyld4::PrebuiltLoader::invalidateShallow(_WORD *this, const dyld4::RuntimeState *a2)
{
  if (this[24])
  {
    __int16 v3 = this;
    uint64_t v4 = 0LL;
    do
    {
      this = (_WORD *)dyld4::PrebuiltLoader::dependent(v3, a2, v4, 0LL);
      if (this && (this[2] & 1) != 0)
      {
        __int16 v5 = this[3];
        uint64_t v6 = *((void *)a2 + 124);
        uint64_t v7 = v5 >= 0 ? *((void *)a2 + 121) : *((void *)a2 + 124);
        if (*(unsigned __int8 *)(v7 + (v5 & 0x7FFF)) == 255)
        {
          __int16 v8 = v3[3];
          if (v8 >= 0) {
            uint64_t v6 = *((void *)a2 + 121);
          }
          *(_BYTE *)(v6 + (v8 & 0x7FFF)) = -1;
        }
      }

      uint64_t v4 = (v4 + 1);
    }

    while (v4 < (unsigned __int16)v3[24]);
  }

  return this;
}

ssize_t ___ZNK5dyld414PrebuiltLoader21invalidateInIsolationERKNS_12RuntimeStateE_block_invoke( ssize_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (a3 >= 10)
  {
    *a4 = 1;
    return result;
  }

  ssize_t v6 = result;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  uint64_t v7 = *(void *)(result + 40);
  uint64_t result = dyld4::ProcessConfig::fileExists(*(void *)(*(void *)(result + 48) + 8LL), a2, &v19, 0LL);
  if ((_DWORD)result)
  {
    if (!v7 || !*(_WORD *)(v7 + 42) || (uint64_t v9 = v7 + *(unsigned __int16 *)(v7 + 42), !*(_BYTE *)(v9 + 52)))
    {
      if (*(_BYTE *)(*(void *)(*(void *)(v6 + 48) + 8LL) + 207LL))
      {
        __int16 v17 = "found '%s' which invalidates PrebuiltLoader for '%s'\n";
        goto LABEL_21;
      }

LABEL_25:
      *(_BYTE *)(*(void *)(*(void *)(v6 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
      return result;
    }

    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v13 = v9 + 16;
    uint64_t v11 = *(void *)(v9 + 16);
    uint64_t v12 = *(void *)(v13 + 8);
    if (*((void *)&v19 + 1) != v10 || BYTE8(v20) == 0 || (void)v19 != v11 || (void)v20 != v12)
    {
      if (*(_BYTE *)(*(void *)(*(void *)(v6 + 48) + 8LL) + 207LL))
      {
        __int16 v17 = "found '%s' with different inode/mtime than PrebuiltLoader for '%s'\n";
LABEL_21:
        if (*(_WORD *)(v7 + 32)) {
          uint64_t v18 = v7 + *(unsigned __int16 *)(v7 + 32);
        }
        else {
          uint64_t v18 = 0LL;
        }
        uint64_t result = dyld4::console((dyld4 *)v17, v8, a2, v18);
        goto LABEL_25;
      }

      goto LABEL_25;
    }
  }

  return result;
}

      CacheInDirAndMap = (void *)v15;
    }
  }

  if (a5 && v13) {
    uint64_t result = kdebug_trace_string(a1, v13, 0LL, v31, v32, v33, v34, v35);
  }
  if (a3)
  {
    if (v15) {
      return kdebug_trace_string(a1, v15, 0LL, v31, v32, v33, v34, v35);
    }
  }

  return result;
}

BOOL dyld4::PrebuiltLoader::dyldDoesObjCFixups(dyld4::PrebuiltLoader *this)
{
  else {
    return (*((unsigned __int16 *)this + 2) >> 1) & 1;
  }
}

uint64_t dyld4::PrebuiltLoader::getSectionLocations(dyld4::PrebuiltLoader *this)
{
  return (uint64_t)this + 104;
}

BOOL dyld4::PrebuiltLoader::hasBeenFixedUp(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 968;
  }
  else {
    __int16 v3 = (char *)a2 + 992;
  }
  return *(unsigned __int8 *)(*(void *)v3 + (v2 & 0x7FFF)) > 5u;
}

uint64_t dyld4::PrebuiltLoader::beginInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 968;
  }
  else {
    __int16 v3 = (char *)a2 + 992;
  }
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v2 & 0x7FFF;
  int v6 = *(unsigned __int8 *)(v4 + v5);
  if (v6 != 6) {
    dyld4::PrebuiltLoader::beginInitializers();
  }
  uint64_t result = 0LL;
  *(_BYTE *)(v4 + v5) = 8;
  return result;
}

void dyld4::PrebuiltLoader::runInitializers(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  if ((*((_WORD *)this + 22) & 1) != 0) {
    dyld4::Loader::findAndRunAllInitializers(this, a2);
  }
  __int16 v4 = *((_WORD *)this + 3);
  if (v4 >= 0) {
    uint64_t v5 = (char *)a2 + 968;
  }
  else {
    uint64_t v5 = (char *)a2 + 992;
  }
  *(_BYTE *)(*(void *)v5 + (v4 & 0x7FFF)) = 9;
}

BOOL dyld4::PrebuiltLoader::isDelayInit(dyld4::PrebuiltLoader *this, dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 968;
  }
  else {
    __int16 v3 = (char *)a2 + 992;
  }
  return *(_BYTE *)(*(void *)v3 + (v2 & 0x7FFF)) == 7;
}

uint64_t dyld4::PrebuiltLoader::setDelayInit(uint64_t this, dyld4::RuntimeState *a2, int a3)
{
  __int16 v3 = *(_WORD *)(this + 6);
  if (v3 >= 0) {
    __int16 v4 = (char *)a2 + 968;
  }
  else {
    __int16 v4 = (char *)a2 + 992;
  }
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = v3 & 0x7FFF;
  int v7 = *(unsigned __int8 *)(v5 + v6);
  if (a3)
  {
    if (v7 != 6) {
      return this;
    }
    char v8 = 7;
  }

  else
  {
    if (v7 != 7) {
      return this;
    }
    char v8 = 6;
  }

  *(_BYTE *)(v5 + v6) = v8;
  return this;
}

BOOL dyld4::PrebuiltLoader::isInitialized(dyld4::PrebuiltLoader *this, const dyld4::RuntimeState *a2)
{
  __int16 v2 = *((_WORD *)this + 3);
  if (v2 >= 0) {
    __int16 v3 = (char *)a2 + 968;
  }
  else {
    __int16 v3 = (char *)a2 + 992;
  }
  return *(_BYTE *)(*(void *)v3 + (v2 & 0x7FFF)) == 9;
}

double dyld4::PrebuiltLoader::PrebuiltLoader(dyld4::PrebuiltLoader *this, const Loader *a2)
{
  *(void *)&double result = 1LL;
  *((void *)this + 13) = 1LL;
  return result;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1[4] + 8LL);
  unint64_t v4 = *(unsigned int *)(v3 + 24);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  if (a1[7] <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( (uint64_t)a1,  a2,  a3);
  }
  if (*(_BYTE *)(a1[5] + v4) == 1)
  {
    uint64_t v5 = (uint64_t *)(a1[9] + a2 - a1[8]);
    uint64_t v7 = a1[10];
    uint64_t v6 = (dyld4::RuntimeState *)a1[11];
    if (*(_BYTE *)(*((void *)v6 + 1) + 202LL)) {
      dyld4::RuntimeState::log(v6, "fixup: *0x%012lX = 0x%012lX <objc-protocol>\n", v5, v7);
    }
    *uint64_t v5 = v7;
  }

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  unint64_t v4 = *(unsigned int *)(v3 + 24);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  if (*(void *)(a1 + 56) <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( a1,  a2,  a3);
  }
  uint64_t v7 = (dyld4::PrebuiltLoader::BindTargetRef *)(*(void *)(a1 + 40) + 8 * v4);
  unint64_t v8 = *(void *)v7;
  if ((*(void *)v7 & 0x8000000000000000LL) != 0)
  {
    uint64_t v10 = (v8 >> 8) | 0x80000000000000LL;
    if ((v8 & 0x4000000000000000LL) == 0) {
      uint64_t v10 = (v8 >> 8) & 0x7FFFFFFFFFFFFFLL;
    }
    uint64_t v9 = (const char *)(*(void *)(a1 + 64) + (v10 | (v8 << 56)));
  }

  else
  {
    uint64_t v9 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(v7, *(dyld4::RuntimeState **)(a1 + 72), a3);
  }

  uint64_t v11 = *(dyld4::RuntimeState **)(a1 + 72);
  uint64_t v12 = (const char **)(*(void *)(a1 + 80) + a2);
  if (*(_BYTE *)(*((void *)v11 + 1) + 202LL)) {
    dyld4::RuntimeState::log(v11, "fixup: *0x%012lX = 0x%012lX <objc-selector '%s'>\n", v12, v9, v9);
  }
  _WORD *v12 = v9;
}

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_3( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if ((a6 & 1) == 0 && *(_BYTE *)(a5 + 36) && (*(_BYTE *)(a5 + 32) & 1) == 0)
  {
    uint64_t v6 = (unint64_t *)(a1[5] + a4 - a1[4]);
    unint64_t v7 = *v6 & 0xFFFFFFFFFFFFFFFCLL | 2;
    unint64_t v8 = (dyld4::RuntimeState *)a1[6];
    if (*(_BYTE *)(*((void *)v8 + 1) + 202LL)) {
      dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark swift stable>\n", v6, v7);
    }
    *uint64_t v6 = v7;
  }

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t OnlyDataField = dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(a5, 2, *(_DWORD *)(a1 + 64));
  if (OnlyDataField)
  {
    uint64_t v7 = OnlyDataField - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v7) & 1) == 0)
    {
      unint64_t v8 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v9 = (_DWORD *)(**(void **)(a1 + 48) + v7);
      uint64_t v10 = *v9 | 1LL;
      if (*(_BYTE *)(*((void *)v8 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v8, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v9, v10);
      }
      _DWORD *v9 = v10;
    }
  }

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_5( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  if (v5)
  {
    uint64_t v6 = v5 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 56);
      unint64_t v8 = (_DWORD *)(**(void **)(a1 + 48) + v6);
      uint64_t v9 = *v8 | 1LL;
      if (*(_BYTE *)(*((void *)v7 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      }
      *unint64_t v8 = v9;
    }
  }

  uint64_t v10 = *(void *)(a3 + 24);
  if (v10)
  {
    uint64_t v11 = v10 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      uint64_t v12 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v13 = (_DWORD *)(**(void **)(a1 + 48) + v11);
      uint64_t v14 = *v13 | 1LL;
      if (*(_BYTE *)(*((void *)v12 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      }
      _DWORD *v13 = v14;
    }
  }

void ___ZNK5dyld414PrebuiltLoader15applyObjCFixupsERNS_12RuntimeStateE_block_invoke_6( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3[3];
  if (v5)
  {
    uint64_t v6 = v5 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v6) & 1) == 0)
    {
      uint64_t v7 = *(dyld4::RuntimeState **)(a1 + 56);
      unint64_t v8 = (_DWORD *)(**(void **)(a1 + 48) + v6);
      uint64_t v9 = *v8 | 1LL;
      if (*(_BYTE *)(*((void *)v7 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v7, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v8, v9);
      }
      *unint64_t v8 = v9;
    }
  }

  uint64_t v10 = a3[4];
  if (v10)
  {
    uint64_t v11 = v10 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v11) & 1) == 0)
    {
      uint64_t v12 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v13 = (_DWORD *)(**(void **)(a1 + 48) + v11);
      uint64_t v14 = *v13 | 1LL;
      if (*(_BYTE *)(*((void *)v12 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v12, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v13, v14);
      }
      _DWORD *v13 = v14;
    }
  }

  uint64_t v15 = a3[5];
  if (v15)
  {
    uint64_t v16 = v15 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v16) & 1) == 0)
    {
      __int16 v17 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v18 = (_DWORD *)(**(void **)(a1 + 48) + v16);
      uint64_t v19 = *v18 | 1LL;
      if (*(_BYTE *)(*((void *)v17 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v17, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v18, v19);
      }
      *uint64_t v18 = v19;
    }
  }

  uint64_t v20 = a3[6];
  if (v20)
  {
    uint64_t v21 = v20 - **(void **)(a1 + 32);
    if ((dyld3::MachOAnalyzer::objcMethodListIsRelative(**(dyld3::MachOAnalyzer ***)(a1 + 40), v21) & 1) == 0)
    {
      uint64_t v22 = *(dyld4::RuntimeState **)(a1 + 56);
      uint64_t v23 = (_DWORD *)(**(void **)(a1 + 48) + v21);
      uint64_t v24 = *v23 | 1LL;
      if (*(_BYTE *)(*((void *)v22 + 1) + 202LL)) {
        dyld4::RuntimeState::log(v22, "fixup: *0x%012lX = 0x%012lX <mark method list uniqued>\n", v23, v24);
      }
      _DWORD *v23 = v24;
    }
  }

void dyld4::PrebuiltLoader::serialize( vm_address_t *a1, const dyld4::RuntimeState *a2, uint64_t a3, __int16 a4, uint64_t a5, dyld4::PrebuiltObjC *a6, int a7, dyld4::BumpAllocator *this)
{
  uint64_t v103 = a1;
  uint64_t v14 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 0x1C0uLL);
  dyld4::PrebuiltLoader::PrebuiltLoader((dyld4::PrebuiltLoader *)(*(void *)this + v14), (const Loader *)a3);
  *(_WORD *)(*(void *)this + v14 + 6) = a4;
  uint64_t v15 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf((dyld4::JustInTimeLoader *)a3, a2);
  __int16 FixupsLoadCommandFileOffset = dyld3::MachOFile::getFixupsLoadCommandFileOffset(v15);
  uint64_t v17 = *(void *)this;
  uint64_t v18 = *(void *)this + v14;
  *(_WORD *)(v18 + 38) = FixupsLoadCommandFileOffset;
  *(_WORD *)(v18 + 32) = *((_DWORD *)this + 4) - v17 - v14;
  uint64_t v105 = a2;
  uint64_t v19 = (const char *)dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)a3, a2);
  unint64_t v20 = _platform_strlen(v19) + 1;
  uint64_t v21 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v20);
  memmove((void *)(*(void *)this + v21), v19, v20);
  *(_WORD *)(*(void *)this + v14 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  uint64_t v22 = dyld3::MachOFile::installName(v15);
  uint64_t v104 = v15;
  if (dyld3::MachOFile::isDylib(v15) && _platform_strcmp(v22, v19))
  {
    uint64_t v23 = *((void *)this + 2) - *(void *)this;
    *(_WORD *)(*(void *)this + v14 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v23 - v14;
    unint64_t v24 = _platform_strlen(v22) + 1;
    dyld4::BumpAllocator::zeroFill(this, v24);
    memmove((void *)(*(void *)this + v23), v22, v24);
  }

  if ((*(_WORD *)(a3 + 4) & 2) != 0)
  {
    if (dyld4::ProcessConfig::DyldCache::isOverridablePath( (dyld4::ProcessConfig::DyldCache *)(*((void *)v105 + 1) + 240LL),  v19))
    {
      __int16 v25 = 2;
    }

    else
    {
      __int16 v25 = 0;
    }
  }

  else
  {
    __int16 v25 = 0;
  }

  *(_WORD *)(*(void *)this + v14 + 44) = *(_WORD *)(*(void *)this + v14 + 44) & 0xFFFD | v25;
  unsigned int v26 = dyld4::JustInTimeLoader::dependentCount((dyld4::JustInTimeLoader *)a3);
  uint64_t v27 = *(void *)this;
  *(_WORD *)(*(void *)this + v14 + 48) = v26;
  uint64_t v28 = *((void *)this + 2);
  uint64_t v100 = v19;
  uint64_t v101 = a6;
  uint64_t v99 = a5;
  if ((((_BYTE)v28 - (_BYTE)v27) & 1) != 0)
  {
    dyld4::BumpAllocator::zeroFill(this, 2LL - (((_BYTE)v28 - (_BYTE)v27) & 1));
    uint64_t v28 = *((void *)this + 2);
    uint64_t v27 = *(void *)this;
  }

  __int16 v29 = v28 - v27;
  unsigned __int16 v30 = v29 - v14;
  *(_WORD *)(v27 + v14 + 34) = v29 - v14;
  uint64_t v31 = dyld4::BumpAllocator::zeroFill(this, 2LL * v26);
  __chkstk_darwin(v31, v26 + 1, v32, v33, v34, v35, v36, v37, v98);
  __int16 v39 = (char *)&v98 - ((v38 + 15) & 0x1FFFFFFF0LL);
  if ((v40 & 1) != 0 || (bzero((char *)&v98 - ((v38 + 15) & 0x1FFFFFFF0LL), v38), v26))
  {
    uint64_t v41 = 0LL;
    char v42 = 0;
    uint64_t v102 = v14;
    uint64_t v43 = v14 + v30;
    do
    {
      uint64_t v44 = dyld4::JustInTimeLoader::dependent((dyld4::JustInTimeLoader *)a3, (int)v105, v41, &v39[v41]);
      int v45 = v39[v41];
      BOOL v46 = v45 != mach_o::LinkedDylibAttributes::regular;
      if (v44)
      {
        uint64_t v47 = *(void *)this + v43;
        __int16 v48 = *(_WORD *)(v44 + 6);
      }

      else
      {
        if ((v45 & 1) == 0) {
          dyld4::PrebuiltLoader::serialize();
        }
        uint64_t v47 = *(void *)this + v43;
        __int16 v48 = 0x7FFF;
      }

      *(_WORD *)(v47 + 2 * v41) = v48;
      v42 |= v46;
      ++v41;
    }

    while (v26 != v41);
    uint64_t v49 = *(void *)this;
    uint64_t v14 = v102;
    uint64_t v50 = *(void *)this + v102;
    *(_WORD *)(v50 + 36) = 0;
    if ((v42 & 1) != 0)
    {
      unsigned __int16 v51 = *((void *)this + 2) - (v14 + v49);
      *(_WORD *)(v50 + 36) = v51;
      dyld4::BumpAllocator::zeroFill(this, v26);
      memmove((void *)(*(void *)this + v14 + v51), v39, v26);
      uint64_t v49 = *(void *)this;
    }
  }

  else
  {
    uint64_t v49 = *(void *)this;
    *(_WORD *)(*(void *)this + v14 + 36) = 0;
  }

  dyld4::JustInTimeLoader::getExportsTrie( (dyld4::JustInTimeLoader *)a3,  (unint64_t *)(v49 + v14 + 64),  (unsigned int *)(v49 + v14 + 72));
  char v52 = (Diagnostics *)v103;
  uint64_t v53 = v104;
  *(_WORD *)(*(void *)this + v14 + 44) = *(_WORD *)(*(void *)this + v14 + 44) & 0xFFFE | dyld3::MachOFile::hasInitializer( v104,  v103);
  if (!Diagnostics::hasError(v52))
  {
    *(void *)(*(void *)this + v14 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
    if ((*(_BYTE *)(a3 + 4) & 2) == 0)
    {
      if (dyld3::MachOFile::hasCodeSignature(v53, (unsigned int *)v121, (unsigned int *)&v110))
      {
        uint64_t v54 = *(void *)this + v14;
        *(_DWORD *)(v54 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v121[0];
        *(_DWORD *)(v54 + 84) = v110;
      }

      if ((*(_WORD *)(a3 + 4) & 2) == 0) {
        goto LABEL_28;
      }
    }

    if (*(_BYTE *)(*((void *)v105 + 1) + 397LL))
    {
LABEL_28:
      if (((*((_DWORD *)this + 4) - *(_DWORD *)this) & 7) != 0) {
        dyld4::BumpAllocator::zeroFill( this,  8LL - ((*((_DWORD *)this + 4) - *(_DWORD *)this) & 7));
      }
      dyld4::JustInTimeLoader::getFileValidationInfo((dyld4::JustInTimeLoader *)a3, (uint64_t)v121);
      uint64_t v55 = *((void *)this + 2) - *(void *)this;
      *(_WORD *)(*(void *)this + v14 + 42) = v55 - v14;
      dyld4::BumpAllocator::zeroFill(this, 0x38uLL);
      uint64_t v56 = *(void *)this + v55;
      __int128 v57 = v121[0];
      __int128 v58 = v121[1];
      __int128 v59 = v121[2];
      *(void *)(v56 + 48) = v122;
      *(_OWORD *)(v56 + 16) = v58;
      *(_OWORD *)(v56 + 32) = v59;
      *(_OWORD *)uint64_t v56 = v57;
    }

    *(_DWORD *)(*(void *)this + v14 + 76) = dyld3::MachOFile::mappedSize(v53);
    v120[0] = _NSConcreteStackBlock;
    v120[1] = 0x40000000LL;
    v120[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke;
    v120[3] = &__block_descriptor_tmp_46_2;
    v120[4] = this;
    v120[5] = v14;
    v120[6] = this;
    v120[7] = v14;
    dyld4::JustInTimeLoader::withRegions(v53, (uint64_t)v120);
    SectionLocations = (const void *)dyld4::JustInTimeLoader::getSectionLocations((dyld4::JustInTimeLoader *)a3);
    memmove((void *)(*(void *)this + v14 + 104), SectionLocations, 0x158uLL);
    int v61 = *(_DWORD *)(*((void *)v105 + 1) + 64LL);
    if (v61 == 1 || v61 == 6) {
      int v63 = (*(unsigned __int16 *)(a3 + 4) >> 1) & 1;
    }
    else {
      int v63 = 0;
    }
    if (v63 == 1)
    {
      if (dyld3::MachOFile::builtForPlatform(v53, 6, 0)) {
        __int16 v64 = 4;
      }
      else {
        __int16 v64 = 0;
      }
    }

    else
    {
      __int16 v64 = 0;
    }

    *(_WORD *)(*(void *)this + v14 + 44) = *(_WORD *)(*(void *)this + v14 + 44) & 0xFFFB | v64;
    *(_WORD *)(*(void *)this + v14 + 44) &= ~8u;
    uint64_t v65 = *(void *)this + v14;
    *(_DWORD *)(v65 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0xFFFF;
    if (v63)
    {
      if ((*(_WORD *)(v65 + 44) & 4) != 0)
      {
        if (!_platform_strncmp(v100, "/System/iOSSupport/", 0x13uLL))
        {
          uint64_t v70 = *((void *)v105 + 6);
          if (v70)
          {
            unint64_t v71 = (char *)(v100 + 18);
            uint64_t v72 = (dyld4::Loader **)*((void *)v105 + 5);
            uint64_t v73 = 8 * v70;
            while (1)
            {
              uint64_t v74 = *v72;
              if (dyld4::Loader::matchesPath(*v72, v105, v71)) {
                break;
              }
              ++v72;
              v73 -= 8LL;
              if (!v73) {
                goto LABEL_58;
              }
            }

            uint64_t v75 = *(void *)this + v14;
            *(_WORD *)(v75 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((_WORD *)v74 + 3) & 0x7FFF;
            *(_WORD *)(v75 + 44) |= 8u;
          }
        }
      }

      else
      {
        strcpy((char *)v121, "/System/iOSSupport");
        strlcat((char *)v121, v100, 0x400uLL);
        uint64_t v66 = *((void *)v105 + 6);
        if (v66)
        {
          vm_address_t v67 = (dyld4::Loader **)*((void *)v105 + 5);
          uint64_t v68 = 8 * v66;
          while (1)
          {
            __int128 v69 = *v67;
            ++v67;
            v68 -= 8LL;
            if (!v68) {
              goto LABEL_58;
            }
          }

          *(_WORD *)(*(void *)this + v14 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((_WORD *)v69 + 3) & 0x7FFF;
        }
      }
    }

LABEL_58:
    uint64_t v110 = 0LL;
    uint64_t v111 = &v110;
    uint64_t v112 = 0x5002000000LL;
    uint64_t v113 = __Block_byref_object_copy__4;
    v114 = __Block_byref_object_dispose__4;
    v115 = v121;
    uint64_t v116 = 16LL;
    vm_address_t v118 = 0LL;
    vm_size_t v119 = 0LL;
    uint64_t v117 = 0LL;
    vm_address_t v76 = v104;
    if ((*(_BYTE *)(a3 + 4) & 2) == 0)
    {
      uint64_t v77 = *((void *)this + 2);
      uint64_t v78 = *(void *)this;
      if ((((_BYTE)v77 - *(void *)this) & 7) != 0)
      {
        dyld4::BumpAllocator::zeroFill(this, 8LL - (((_BYTE)v77 - *(void *)this) & 7));
        uint64_t v77 = *((void *)this + 2);
        uint64_t v78 = *(void *)this;
      }

      unint64_t v79 = v77 - (v14 + v78);
      *(_WORD *)(v78 + v14 + 5dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v79;
      if (v79 >= 0x10000) {
        dyld4::PrebuiltLoader::serialize();
      }
      *(_DWORD *)(v78 + v14 + 52) = 0;
      v109[0] = _NSConcreteStackBlock;
      v109[1] = 0x40000000LL;
      v109[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51;
      v109[3] = &__block_descriptor_tmp_55;
      uint64_t v80 = (Diagnostics *)v103;
      v109[4] = v103;
      v109[5] = this;
      v109[6] = this;
      v109[7] = v14;
      v108[0] = _NSConcreteStackBlock;
      v108[1] = 0x40000000LL;
      v108[2] = ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_2;
      v108[3] = &unk_189620140;
      v108[4] = &v110;
      v108[5] = v103;
      dyld4::Loader::forEachBindTarget((dyld4::Loader *)a3, v103, v105, v99, 1, (uint64_t)v109, (uint64_t)v108);
      if (Diagnostics::hasError(v80)) {
        goto LABEL_79;
      }
      if (v111[7])
      {
        uint64_t v81 = *((void *)this + 2);
        uint64_t v82 = *(void *)this;
        if ((((_BYTE)v81 - *(void *)this) & 7) != 0)
        {
          dyld4::BumpAllocator::zeroFill(this, 8LL - (((_BYTE)v81 - *(void *)this) & 7));
          uint64_t v81 = *((void *)this + 2);
          uint64_t v82 = *(void *)this;
        }

        uint64_t v83 = v82 + v14;
        *(_DWORD *)(v83 + 92) = v81 - (v14 + v82);
        *(_DWORD *)(v83 + 96) = v111[7];
        uint64_t v84 = v111;
        uint64_t v85 = v111[7];
        if (!v85)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v111 + 5, 1uLL);
          v84[7] = 1LL;
          vm_address_t v76 = v104;
          uint64_t v85 = v111[7];
          uint64_t v81 = *((void *)this + 2);
          uint64_t v82 = *(void *)this;
        }

        uint64_t v86 = (const void *)v84[5];
        size_t v87 = 8 * v85;
        uint64_t v88 = v81 - v82;
        dyld4::BumpAllocator::zeroFill(this, 8 * v85);
        memmove((void *)(*(void *)this + v88), v86, v87);
      }
    }

    int v89 = dyld4::PrebuiltObjC::serializeFixups(v101, (const dyld4::Loader *)a3, this);
    int v90 = v89 - v14;
    if (!v89) {
      int v90 = 0;
    }
    uint64_t v91 = *(void *)this + v14;
    *(_DWORD *)(v91 + 56) = v90;
    *(_OWORD *)(v91 + 8) = *(_OWORD *)(a3 + 8);
    uint64_t v92 = *(void *)this + v14;
    *(_DWORD *)(v92 + 24) = *((_DWORD *)v76 + 2);
    *(_DWORD *)(v92 + 88) = 0;
    if (dyld4::JustInTimeLoader::overridesDylibInCache(a3, &v107, &v106))
    {
      uint64_t v93 = v107;
      if (v107)
      {
        uint64_t v94 = *((void *)this + 2) - *(void *)this;
        *(_DWORD *)(*(void *)this + v14 + 88) = v94 - v14;
        if (*v93 == -1LL)
        {
          unint64_t v97 = 8LL;
        }

        else
        {
          uint64_t v95 = 1LL;
          do
            uint64_t v96 = v93[v95++];
          while (v96 != -1);
          unint64_t v97 = (v95 * 8);
        }

        dyld4::BumpAllocator::zeroFill(this, v97);
        memmove((void *)(*(void *)this + v94), v93, v97);
      }
    }

  mach_o::Error::~Error(&v46);
  return v8;
}

LABEL_79:
    _Block_object_dispose(&v110, 8);
    uint64_t v117 = 0LL;
    if (v118) {
      vm_deallocate(mach_task_self_, v118, v119);
    }
  }

uint64_t dyld4::BumpAllocator::zeroFill(dyld4::BumpAllocator *this, unint64_t a2)
{
  vm_size_t v5 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  uint64_t result = *(void *)this;
  if (v5 - v4 + result < a2)
  {
    unint64_t v7 = 0x100000LL;
    if (v5 > 0x100000) {
      unint64_t v7 = v5;
    }
    if (v7 < a2) {
      unint64_t v7 = (a2 & 0xFFFFFFFFFFF00000LL) + 0x100000;
    }
    v5 += v7;
    vm_allocate(mach_task_self_, &address, v5, 1006632961);
    uint64_t result = address;
    if (!address) {
      dyld4::BumpAllocator::zeroFill();
    }
    uint64_t v8 = *((void *)this + 2);
    uint64_t v9 = v8 - *(void *)this;
    if (*(void *)this)
    {
      memmove((void *)address, *(const void **)this, v8 - *(void *)this);
      vm_deallocate(mach_task_self_, *(void *)this, *((void *)this + 1));
      uint64_t result = address;
    }

    uint64_t v4 = result + v9;
    *((void *)this + 1) = v5;
    *((void *)this + 2) = result + v9;
    *(void *)this = result;
  }

  unint64_t v10 = v4 + a2;
  if (v10 > result + v5) {
    dyld4::BumpAllocator::zeroFill();
  }
  *((void *)this + 2) = v10;
  return result;
}

void *dyld4::BumpAllocator::append(dyld4::BumpAllocator *this, const void *a2, unint64_t a3)
{
  uint64_t v6 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, a3);
  return memmove((void *)(*(void *)this + v6), a2, a3);
}

dyld4::BumpAllocator *dyld4::BumpAllocator::align(dyld4::BumpAllocator *this, unsigned int a2)
{
  unint64_t v2 = (*((void *)this + 2) - *(void *)this) % (unint64_t)a2;
  if (v2) {
    return (dyld4::BumpAllocator *)dyld4::BumpAllocator::zeroFill(this, a2 - v2);
  }
  return this;
}

void *___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  vm_size_t v5 = *(dyld4::BumpAllocator **)(a1 + 32);
  uint64_t v6 = *((void *)v5 + 2);
  uint64_t v7 = *(void *)v5;
  if ((((_BYTE)v6 - *(void *)v5) & 7) != 0)
  {
    vm_size_t v5 = (dyld4::BumpAllocator *)dyld4::BumpAllocator::zeroFill( v5,  8LL - (((_BYTE)v6 - *(void *)v5) & 7));
    uint64_t v8 = *(uint64_t **)(a1 + 32);
    uint64_t v6 = v8[2];
    uint64_t v7 = *v8;
  }

  unint64_t v9 = v6 - *(void *)(a1 + 40) - v7;
  uint64_t v10 = **(void **)(a1 + 48) + *(void *)(a1 + 56);
  *(_WORD *)(v10 + 46) = v9;
  if (v9 >= 0x10000) {
    ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_cold_2();
  }
  *(_WORD *)(v10 + 44) = *(_WORD *)(v10 + 44) & 0xF | (16 * *(_WORD *)(a2 + 16));
  uint64_t v11 = *(void *)(a2 + 16);
  if (!v11) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( (uint64_t)v5,  a2,  a3);
  }
  uint64_t v12 = *(dyld4::BumpAllocator **)(a1 + 32);
  uint64_t v13 = *(const void **)a2;
  size_t v14 = 16 * v11;
  uint64_t v15 = *((void *)v12 + 2) - *(void *)v12;
  dyld4::BumpAllocator::zeroFill(v12, 16 * v11);
  return memmove((void *)(*(void *)v12 + v15), v13, v14);
}

double __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__4(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

uint64_t ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result = Diagnostics::hasError(*(Diagnostics **)(a1 + 32));
  if ((_DWORD)result)
  {
    *a3 = 1;
  }

  else
  {
    uint64_t v6 = *(dyld4::BumpAllocator **)(a1 + 40);
    uint64_t v7 = *((void *)v6 + 2) - *(void *)v6;
    uint64_t result = dyld4::BumpAllocator::zeroFill(v6, 8uLL);
    *(void *)(*(void *)v6 + v7) = v10;
    uint64_t v8 = **(void **)(a1 + 48) + *(void *)(a1 + 56);
    int v9 = *(_DWORD *)(v8 + 52);
    *(_DWORD *)(v8 + 52) = v9 + 1;
    if (v9 == -1) {
      ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1();
    }
  }

  return result;
}

void *___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_2( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result = (void *)Diagnostics::hasError(*(Diagnostics **)(a1 + 40));
  if ((_DWORD)result)
  {
    *a3 = 1;
  }

  else
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(v6 + 40), 1LL);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = *(void *)(v6 + 56);
    *(void *)(v6 + 56) = v8 + 1;
    *(void *)(v7 + 8 * v8) = v9;
  }

  return result;
}

uint64_t dyld4::PrebuiltLoader::overridesDylibInCache(uint64_t a1, void *a2, _WORD *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a1 + 44);
  if ((v3 & 8) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 88);
    if ((_DWORD)v4) {
      uint64_t v5 = a1 + v4;
    }
    else {
      uint64_t v5 = 0LL;
    }
    *a2 = v5;
    *a3 = *(_WORD *)(a1 + 60);
  }

  return (v3 >> 3) & 1;
}

void dyld4::PrebuiltLoader::withLayout( dyld4::Loader *a1, vm_address_t *a2, dyld4::RuntimeState *a3, uint64_t a4)
{
  uint64_t v6 = (dyld3::MachOLoaded *)dyld4::Loader::analyzer(a1, a3);
  dyld3::MachOAnalyzer::withVMLayout(v6, a2, a4);
}

BOOL dyld4::PrebuiltLoaderSet::contains( dyld4::PrebuiltLoaderSet *this, dyld4::PrebuiltLoaderSet *a2, uint64_t a3)
{
  return a2 >= this && (char *)a2 + a3 <= (char *)this + *((unsigned int *)this + 2);
}

uint64_t dyld4::PrebuiltLoaderSet::validHeader(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  if (*(_DWORD *)this == 1936733284)
  {
    if (*((_DWORD *)this + 1) == 389703534) {
      return 1LL;
    }
    if (*(_BYTE *)(*((void *)a2 + 1) + 207LL)) {
      dyld4::console( (dyld4 *)"not using PrebuiltLoaderSet %p because versionHash (0x%08X) does not match dyld (0x%08X)\n",  (const char *)a2,  this,  *((unsigned int *)this + 1),  389703534LL);
    }
  }

  else if (*(_BYTE *)(*((void *)a2 + 1) + 207LL))
  {
    dyld4::console( (dyld4 *)"not using PrebuiltLoaderSet %p because magic at start does not match\n",  (const char *)a2,  this);
  }

  return 0LL;
}

uint64_t dyld4::PrebuiltLoaderSet::isValid(dyld4::PrebuiltLoaderSet *this, dyld4::RuntimeState *a2)
{
  uint64_t v5 = *((unsigned int *)this + 7);
  if ((_DWORD)v5)
  {
    __int128 v6 = *(_OWORD *)((char *)this + v5);
    __int128 v27 = v6;
    uint64_t v7 = *((void *)a2 + 1);
    uint64_t v8 = *(DyldSharedCache **)(v7 + 240);
    if (!v8)
    {
      if (*(_BYTE *)(v7 + 207)) {
        dyld4::console( (dyld4 *)"not using PrebuiltLoaderSet %p because process does not have a dyld cache\n",  v4,  *(double *)&v6,  this);
      }
      return 0LL;
    }

    *(void *)&double v10 = DyldSharedCache::getUUID(v8, &v24).n128_u64[0];
    if ((void)v27 != v24.n128_u64[0] || *((void *)&v27 + 1) != v24.n128_u64[1])
    {
      if (*(_BYTE *)(*((void *)a2 + 1) + 207LL)) {
        dyld4::console((dyld4 *)"not using PrebuiltLoaderSet %p because cache UUID does not match\n", v9, v10, this);
      }
      return 0LL;
    }
  }

  v24.n128_u64[0] = 0LL;
  v24.n128_u64[1] = (unint64_t)&v24;
  uint64_t v25 = 0x2000000000LL;
  char v26 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000LL;
  v23[2] = ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke;
  v23[3] = &unk_189620168;
  v23[5] = this;
  v23[6] = a2;
  void v23[4] = &v24;
  uint64_t MustBeMissingPath = dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath((size_t)this, (uint64_t)v23);
  uint64_t v15 = 0LL;
  if (!*(_BYTE *)(v24.n128_u64[1] + 24))
  {
    unsigned int v16 = *((_DWORD *)this + 3);
    if (!v16) {
      goto LABEL_20;
    }
    unsigned int v17 = 0;
    char v18 = 0;
    do
    {
      uint64_t MustBeMissingPath = dyld4::PrebuiltLoader::isValid( (dyld4::PrebuiltLoaderSet *)((char *)this + *(unsigned int *)((char *)this + 4 * (unsigned __int16)v17 + *((unsigned int *)this + 4))),  a2,  v14);
      v18 |= MustBeMissingPath ^ 1;
      ++v17;
      unsigned int v16 = *((_DWORD *)this + 3);
    }

    while (v17 < v16);
    if ((v18 & 1) != 0)
    {
      uint64_t v15 = 0LL;
    }

    else
    {
LABEL_20:
      uint64_t v19 = *(unsigned int *)(*((void *)a2 + 1) + 392LL);
      if ((_DWORD)v19)
      {
        unint64_t v20 = (unsigned __int8 *)*((void *)a2 + 121);
        do
        {
          if (*v20++) {
            ++v16;
          }
          --v19;
        }

        while (v19);
      }

      *((_DWORD *)a2 + 253) = v16;
      uint64_t v15 = 1LL;
    }
  }

  _Block_object_dispose(&v24, 8);
  return v15;
}

size_t dyld4::PrebuiltLoaderSet::forEachMustBeMissingPath(size_t result, uint64_t a2)
{
  size_t v3 = result;
  char v6 = 0;
  uint64_t v4 = (const char *)(result + *(unsigned int *)(result + 36));
  int v5 = -1;
  do
  {
    (*(void (**)(uint64_t, const char *, char *))(a2 + 16))(a2, v4, &v6);
    uint64_t result = _platform_strlen(v4);
    v4 += result + 1;
  }

  while (!v6);
  return result;
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet7isValidERNS_12RuntimeStateE_block_invoke( void *a1, dyld3 *a2, _BYTE *a3)
{
  uint64_t v6 = a1[5];
  uint64_t result = dyld4::SyscallDelegate::fileExists(*(void *)(a1[6] + 8LL), a2, 0LL, 0LL);
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(*(void *)(a1[6] + 8LL) + 207LL)) {
      uint64_t result = dyld4::console( (dyld4 *)"not using PrebuiltLoaderSet %p because existence of file '%s' invalids the PrebuiltLoaderSet\n",  v8,  v6,  a2);
    }
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

uint64_t dyld4::PrebuiltLoaderSet::findLoader( dyld4::PrebuiltLoaderSet *this, const dyld4::RuntimeState *a2, const char *a3)
{
  BOOL Index = dyld4::PrebuiltLoaderSet::findIndex((uint64_t)this, a2, a3, &v8);
  if (!Index) {
    return 0LL;
  }
  return (uint64_t)this + *(unsigned int *)((char *)this + 4 * v8 + *((unsigned int *)this + 4));
}

BOOL dyld4::PrebuiltLoaderSet::findIndex( uint64_t this, const dyld4::RuntimeState *a2, const char *__s2, unsigned __int16 *a4)
{
  unsigned int v4 = *(_DWORD *)(this + 12);
  if (v4)
  {
    uint64_t v7 = this;
    int v8 = 0;
    BOOL v9 = 1;
    while (1)
    {
      uint64_t v10 = v7 + *(unsigned int *)(v7 + *(unsigned int *)(v7 + 16) + 4LL * (unsigned __int16)v8);
      uint64_t v11 = *(unsigned __int16 *)(v10 + 32);
      uint64_t v12 = v10 + v11;
      uint64_t v13 = (_DWORD)v11 ? (const char *)v12 : 0LL;
      this = _platform_strcmp(v13, __s2);
      if (!(_DWORD)this) {
        break;
      }
      BOOL v9 = ++v8 < v4;
      if (v4 == v8) {
        return 0;
      }
    }

    *a4 = v8;
  }

  else
  {
    return 0;
  }

  return v9;
}

uint64_t dyld4::PrebuiltLoaderSet::objcSelectorMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 10);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::objcClassMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 11);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::objcProtocolMap(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 12);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 16);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 17);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(dyld4::PrebuiltLoaderSet *this)
{
  uint64_t v1 = *((unsigned int *)this + 18);
  if ((_DWORD)v1) {
    return (uint64_t)this + v1;
  }
  else {
    return 0LL;
  }
}

BOOL dyld4::PrebuiltLoaderSet::hasOptimizedSwift(dyld4::PrebuiltLoaderSet *this)
{
  return *((_DWORD *)this + 16) || *((_DWORD *)this + 17) || *((_DWORD *)this + 18) != 0;
}

void dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(dyld4::PrebuiltLoaderSet *this, dyld4::Loader **a2)
{
  if (this)
  {
    uint64_t v2 = *((unsigned int *)this + 11);
    if ((_DWORD)v2)
    {
      if ((*((_BYTE *)this + 52) & 1) != 0 && *((_BYTE *)a2[1] + 203))
      {
        unsigned int v4 = (uint64_t *)((char *)this + v2);
        uint64_t v5 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(a2[3], (const dyld4::RuntimeState *)a2);
        v14[0] = 0LL;
        v14[1] = v14;
        v14[2] = 0x8802000000LL;
        void v14[3] = __Block_byref_object_copy__64;
        v14[4] = __Block_byref_object_dispose__65;
        dyld3::Map<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::Map((uint64_t)v15);
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000LL;
        uint64_t v13[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke;
        void v13[3] = &unk_189620190;
        v13[4] = v14;
        dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(v5, (uint64_t)v13);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 0x40000000LL;
        v12[2] = ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2;
        v12[3] = &unk_1896201B8;
        v12[4] = v14;
        v12[5] = a2;
        prebuilt_objc::forEachClass(v4, (uint64_t)v12, v6, v7, v8, v9, v10, v11);
        _Block_object_dispose(v14, 8);
        uint64_t v18 = 0LL;
        if (address) {
          vm_deallocate(mach_task_self_, address, size);
        }
        v15[4] = 0LL;
        if (v16) {
          vm_deallocate(mach_task_self_, v16, v17);
        }
      }
    }
  }

double __Block_byref_object_copy__64(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 88) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v3 = *(void *)(a2 + 88);
  *(void *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v3;
  *(void *)(a2 + 88) = 0LL;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a1 + 128) = 0LL;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  uint64_t v4 = *(void *)(a2 + 128);
  *(void *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 120);
  *(void *)(a1 + 128) = v4;
  *(void *)(a2 + 128) = 0LL;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return result;
}

uint64_t __Block_byref_object_dispose__65(uint64_t result)
{
  uint64_t v1 = (void *)result;
  *(void *)(result + 112) = 0LL;
  vm_address_t v2 = *(void *)(result + 120);
  if (v2) {
    double result = vm_deallocate(mach_task_self_, v2, *(void *)(result + 128));
  }
  v1[9] = 0LL;
  vm_address_t v3 = v1[10];
  if (v3) {
    return vm_deallocate(mach_task_self_, v3, v1[11]);
  }
  return result;
}

uint64_t ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke( uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL) + 40LL;
  uint64_t v4 = a2;
  char v5 = 0;
  uint64_t result = dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert(v2, &v4);
  *(_BYTE *)(result + 8) = 1;
  return result;
}

void ___ZNK5dyld417PrebuiltLoaderSet23logDuplicateObjCClassesERNS_12RuntimeStateE_block_invoke_2( uint64_t a1, dyld4::PrebuiltLoader::BindTargetRef *this, uint64_t a3)
{
  if (*(void *)(a3 + 16) != 1LL)
  {
    char v26 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(this, *(dyld4::RuntimeState **)(a1 + 40), a3);
    uint64_t v5 = dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( *(void *)(*(void *)(a1 + 32) + 8LL) + 40LL,  (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL),  (void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 96LL),  0LL,  &v26);
    if (v5 == *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 96LL)
             + 16LL * *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 112LL))
    {
      if (!*(void *)(a3 + 16)) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v5,  v6,  v7);
      }
      if ((***(void ***)a3 & 0x8000000000000000LL) != 0) {
        dyld4::PrebuiltLoader::BindTargetRef::loaderRef(v5, v6, v7);
      }
      __int16 v25 = ***(void ***)a3;
      uint64_t v8 = dyld4::Loader::LoaderRef::loader( (dyld4::Loader::LoaderRef *)&v25,  *(const dyld4::RuntimeState **)(a1 + 40),  v7);
      if (*(_WORD *)(v8 + 32)) {
        uint64_t v11 = (const char *)(v8 + *(unsigned __int16 *)(v8 + 32));
      }
      else {
        uint64_t v11 = 0LL;
      }
      if (!*(void *)(a3 + 16)) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v8,  v9,  v10);
      }
      unint64_t v12 = dyld4::PrebuiltLoader::BindTargetRef::value( **(dyld4::PrebuiltLoader::BindTargetRef ***)a3,  *(dyld4::RuntimeState **)(a1 + 40),  v10);
      uint64_t v15 = *(void *)(a3 + 16);
      if (v15 != 1)
      {
        vm_address_t v16 = (const void *)v12;
        vm_size_t v17 = (dyld4::PrebuiltLoader::BindTargetRef **)(*(void *)a3 + 8LL);
        uint64_t v18 = 8 * v15 - 8;
        do
        {
          uint64_t v19 = *v17;
          if ((*(void *)*v17 & 0x8000000000000000LL) != 0) {
            dyld4::PrebuiltLoader::BindTargetRef::loaderRef(v12, v13, v14);
          }
          __int16 v24 = *(void *)*v17;
          uint64_t v20 = dyld4::Loader::LoaderRef::loader( (dyld4::Loader::LoaderRef *)&v24,  *(const dyld4::RuntimeState **)(a1 + 40),  v14);
          if (*(_WORD *)(v20 + 32)) {
            uint64_t v22 = (const char *)(v20 + *(unsigned __int16 *)(v20 + 32));
          }
          else {
            uint64_t v22 = 0LL;
          }
          uint64_t v23 = (const void *)dyld4::PrebuiltLoader::BindTargetRef::value(v19, *(dyld4::RuntimeState **)(a1 + 40), v21);
          dyld4::RuntimeState::log( *(dyld4::RuntimeState **)(a1 + 40),  "Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.\n",  v26,  v11,  v16,  v22,  v23);
          ++v17;
          v18 -= 8LL;
        }

        while (v18);
      }
    }
  }

vm_address_t dyld4::PrebuiltLoaderSet::makeLaunchSet( vm_address_t *this, Diagnostics *a2, dyld4::RuntimeState *a3, const dyld4::MissingPaths *a4)
{
  if (*((void *)a2 + 22)) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = *((void *)a2 + 30) == 0LL;
  }
  if (!v5 || *((void *)a2 + 38) != 0LL)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses interposing", a3, a4);
    return 0LL;
  }

  if (dyld4::ProcessConfig::PathOverrides::dontUsePrebuiltForApp((dyld4::ProcessConfig::PathOverrides *)(*((void *)a2 + 1) + 400LL)))
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that uses DYLD_* env vars", v9, v10);
    return 0LL;
  }

  BOOL hasMissingFlatLazySymbols = dyld4::RuntimeState::hasMissingFlatLazySymbols(a2);
  if (hasMissingFlatLazySymbols)
  {
    Diagnostics::error(this, "cannot make PrebuiltLoaderSet for program that has missing flat lazy symbols", v13, v14);
    return 0LL;
  }

  __chkstk_darwin(hasMissingFlatLazySymbols, v12, v13, v14, v15, v16, v17, v18, v72);
  uint64_t v22 = (char *)&v73[-1] - ((v21 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v23 = *((void *)a2 + 6);
  if (!v23)
  {
    unint64_t v25 = 0LL;
LABEL_29:
    uint64_t v72 = (uint64_t)&v72;
    dyld4::PrebuiltObjC::PrebuiltObjC((dyld4::PrebuiltObjC *)v98);
    dyld4::PrebuiltSwift::PrebuiltSwift((dyld4::PrebuiltSwift *)v93);
    Diagnostics::Diagnostics((Diagnostics *)v103);
    dyld4::PrebuiltObjC::make((dyld4::PrebuiltObjC *)v98, (Diagnostics *)v103, a2);
    if (!Diagnostics::hasError((Diagnostics *)v103))
    {
      Diagnostics::Diagnostics((Diagnostics *)&v75);
      dyld4::PrebuiltSwift::make((dyld4::PrebuiltSwift *)v93, (vm_address_t *)&v75, (dyld4::PrebuiltObjC *)v98, a2);
      mach_o::Error::~Error(&v75);
    }

    mach_o::Error::~Error((vm_address_t **)v103);
    uint64_t v85 = 0LL;
    uint64_t v86 = &v85;
    uint64_t v87 = 0x4002000000LL;
    uint64_t v88 = __Block_byref_object_copy__76;
    int v89 = __Block_byref_object_dispose__77;
    vm_size_t v91 = 0LL;
    uint64_t v92 = 0LL;
    vm_address_t v90 = 0LL;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)&v90, 0x50uLL);
    uint64_t v33 = v86[5];
    uint64_t v32 = v86 + 5;
    *(void *)uint64_t v33 = 0x173A676E73703464LL;
    *(_DWORD *)(v33 + 12) = v25;
    *(_OWORD *)(v33 + 16) = xmmword_1800B8310;
    *(_OWORD *)(v33 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *(_OWORD *)(v33 + 56) = 0u;
    *(_DWORD *)(v33 + 72) = 0;
    dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 4 * v25);
    uint64_t v35 = *(DyldSharedCache **)(*((void *)a2 + 1) + 240LL);
    if (v35)
    {
      *(_DWORD *)(*v32 + 28LL) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
      DyldSharedCache::getUUID(v35, v103);
      uint64_t v36 = v86 + 5;
      uint64_t v37 = v86[7] - v86[5];
      dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 0x10uLL);
      *(__n128 *)(*v36 + v37) = v103[0];
    }

    uint64_t v75 = 0LL;
    vm_address_t v76 = &v75;
    uint64_t v77 = 0x5002000000LL;
    uint64_t v78 = __Block_byref_object_copy__78;
    unint64_t v79 = __Block_byref_object_dispose__79;
    uint64_t v80 = v103;
    uint64_t v81 = 16LL;
    vm_address_t v83 = 0LL;
    vm_size_t v84 = 0LL;
    uint64_t v82 = 0LL;
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 0x40000000LL;
    v74[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke;
    v74[3] = &unk_1896201E0;
    v74[4] = &v75;
    v74[5] = this;
    if (v25)
    {
      uint64_t v38 = 0LL;
      while (1)
      {
        *(_DWORD *)(*v32 + *(unsigned int *)(*v32 + 16LL) + 4 * v38) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
        dyld4::PrebuiltLoader::serialize( this,  a2,  *(void *)&v22[8 * v38],  v38 & 0x7FFF | 0x8000,  (uint64_t)v74,  (dyld4::PrebuiltObjC *)v98,  v34,  (dyld4::BumpAllocator *)(v86 + 5));
        if (Diagnostics::hasError((Diagnostics *)this)) {
          break;
        }
        if (v25 == ++v38) {
          goto LABEL_37;
        }
      }

      vm_address_t v19 = 0LL;
    }

    else
    {
LABEL_37:
      if (v100)
      {
        if (v98[14])
        {
          *(_DWORD *)(*v32 + 40LL) = dyld4::PrebuiltObjC::serializeSelectorMap( (dyld4::PrebuiltObjC *)v98,  (dyld4::BumpAllocator *)(v86 + 5));
          int v39 = *((_DWORD *)v86 + 10);
          int v40 = *((_DWORD *)v86 + 14);
          uint64_t v41 = ((_BYTE)v40 - (_BYTE)v39) & 7;
          if ((((_BYTE)v40 - (_BYTE)v39) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v41);
          }
        }

        if (v98[26])
        {
          *(_DWORD *)(*v32 + 44LL) = dyld4::PrebuiltObjC::serializeClassMap( (dyld4::PrebuiltObjC *)v98,  (dyld4::BumpAllocator *)(v86 + 5));
          int v42 = *((_DWORD *)v86 + 10);
          int v43 = *((_DWORD *)v86 + 14);
          uint64_t v44 = ((_BYTE)v43 - (_BYTE)v42) & 7;
          if ((((_BYTE)v43 - (_BYTE)v42) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v44);
          }
        }

        if (v98[39])
        {
          *(_DWORD *)(*v32 + 48LL) = dyld4::PrebuiltObjC::serializeProtocolMap( (dyld4::PrebuiltObjC *)v98,  (dyld4::BumpAllocator *)(v86 + 5));
          int v45 = *((_DWORD *)v86 + 10);
          int v46 = *((_DWORD *)v86 + 14);
          uint64_t v47 = ((_BYTE)v46 - (_BYTE)v45) & 7;
          if ((((_BYTE)v46 - (_BYTE)v45) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v47);
          }
        }

        if (!v102) {
          std::__throw_bad_optional_access[abi:nn180100]();
        }
        uint64_t v48 = *v32;
        *(void *)(*v32 + 56LL) = v101;
        if (v99) {
          *(_DWORD *)(v48 + 52) |= 1u;
        }
      }

      if (v97)
      {
        if (v93[9])
        {
          uint64_t v49 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 64LL) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize( v93,  v49);
          int v50 = *((_DWORD *)v86 + 10);
          int v51 = *((_DWORD *)v86 + 14);
          uint64_t v52 = ((_BYTE)v51 - (_BYTE)v50) & 7;
          if ((((_BYTE)v51 - (_BYTE)v50) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v52);
          }
        }

        if (v94[9])
        {
          uint64_t v53 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 68LL) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize( v94,  v53);
          int v54 = *((_DWORD *)v86 + 10);
          int v55 = *((_DWORD *)v86 + 14);
          uint64_t v56 = ((_BYTE)v55 - (_BYTE)v54) & 7;
          if ((((_BYTE)v55 - (_BYTE)v54) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v56);
          }
        }

        if (v96)
        {
          __int128 v57 = (void *)v95[7];
          uint64_t v58 = 48 * v96;
          do
          {
            void *v57 = 0LL;
            v57 += 6;
            v58 -= 48LL;
          }

          while (v58);
          __int128 v59 = (dyld4::BumpAllocator *)(v86 + 5);
          *(_DWORD *)(*v32 + 72LL) = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
          dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize( v95,  v59);
          int v60 = *((_DWORD *)v86 + 10);
          int v61 = *((_DWORD *)v86 + 14);
          uint64_t v62 = ((_BYTE)v61 - (_BYTE)v60) & 7;
          if ((((_BYTE)v61 - (_BYTE)v60) & 7) != 0) {
            dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 8 - v62);
          }
        }
      }

      int v63 = v76;
      __int16 v64 = v76[7];
      uint64_t v65 = v86;
      uint64_t v66 = (_DWORD *)*v32;
      if (v64)
      {
        v66[6] = *((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 10);
        vm_address_t v67 = v63[5];
        uint64_t v68 = 16LL * (void)v64;
        do
        {
          __int128 v69 = v86 + 5;
          uint64_t v70 = v86[7] - v86[5];
          dyld4::BumpAllocator::zeroFill((dyld4::BumpAllocator *)(v86 + 5), 0x10uLL);
          __int128 v71 = *(_OWORD *)v67;
          v67 += 2;
          *(_OWORD *)(*v69 + v7dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v71;
          uint64_t v66 = (_DWORD *)*v32;
          ++*(_DWORD *)(*v32 + 20LL);
          v68 -= 16LL;
        }

        while (v68);
        uint64_t v65 = v86;
      }

      if (*((void *)a3 + 2) != *(void *)a3)
      {
        v66[9] = *((_DWORD *)v65 + 14) - *((_DWORD *)v65 + 10);
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 0x40000000LL;
        v73[2] = ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke_3;
        v73[3] = &unk_189620208;
        v73[4] = &v85;
        v73[5] = v32;
        v73[6] = 0LL;
        dyld4::MissingPaths::forEachPath((size_t)a3, (uint64_t)v73);
        uint64_t v65 = v86;
        uint64_t v66 = (_DWORD *)*v32;
      }

      v66[2] = *((_DWORD *)v65 + 14) - *((_DWORD *)v65 + 10);
      vm_address_t v19 = dyld4::BumpAllocator::finalize((dyld4::BumpAllocator *)(v86 + 5));
    }

    _Block_object_dispose(&v75, 8);
    uint64_t v82 = 0LL;
    if (v83) {
      vm_deallocate(mach_task_self_, v83, v84);
    }
    _Block_object_dispose(&v85, 8);
    if (v90) {
      vm_deallocate(mach_task_self_, v90, v91);
    }
    dyld4::PrebuiltSwift::~PrebuiltSwift((dyld4::PrebuiltSwift *)v93);
    dyld4::PrebuiltObjC::~PrebuiltObjC((dyld4::PrebuiltObjC *)v98);
    return v19;
  }

  int v24 = 0;
  unint64_t v25 = 0LL;
  char v26 = (uint64_t *)*((void *)a2 + 5);
  uint64_t v27 = 8 * v23;
  while (1)
  {
    uint64_t v28 = *v26;
    __int16 v29 = *(_WORD *)(*v26 + 4);
    if (*v26 && (v29 & 1) == 0) {
      break;
    }
LABEL_26:
    ++v26;
    v27 -= 8LL;
    if (!v27) {
      goto LABEL_29;
    }
  }

  if ((v29 & 2) != 0)
  {
    dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)v28, a2);
    Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that is in dyld cache (%s)");
    return 0LL;
  }

  if ((*(_BYTE *)(v28 + 42) & 0x40) == 0)
  {
    if (v25 >= v23) {
      ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
    }
    *(void *)&v22[8 * v25++] = v28;
    __int16 v31 = v24++ | 0x8000;
    *(_WORD *)(v28 + 6) = v31;
    goto LABEL_26;
  }

  dyld4::JustInTimeLoader::path((dyld4::JustInTimeLoader *)v28, a2);
  Diagnostics::error(this, "cannot make PrebuiltLoader for dylib that overrides dylib in dyld cache (%s)");
  return 0LL;
}

__n128 __Block_byref_object_copy__76(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

uint64_t __Block_byref_object_dispose__77(uint64_t result)
{
  uint64_t v2 = (void *)(result + 40);
  vm_address_t v1 = *(void *)(result + 40);
  if (v1)
  {
    __n128 result = vm_deallocate(mach_task_self_, v1, *(void *)(result + 48));
    v2[1] = 0LL;
    v2[2] = 0LL;
    void *v2 = 0LL;
  }

  return result;
}

double __Block_byref_object_copy__78(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__79(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

double ___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  *(void *)&__int128 v9 = __PAIR64__(a3, a2);
  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((unint64_t *)&v9 + 1, *(vm_address_t **)(a1 + 40), a4);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(v5 + 40), 1LL);
  uint64_t v6 = *(void *)(v5 + 40);
  uint64_t v7 = *(void *)(v5 + 56);
  *(void *)(v5 + 56) = v7 + 1;
  double result = *(double *)&v9;
  *(_OWORD *)(v6 + 16 * v7) = v9;
  return result;
}

void *dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::serialize( void *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v4) = *a1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v5) = a1[1];
  unint64_t v6 = a1[4];
  uint64_t v7 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v7) = v6;
  uint64_t v8 = (const void *)a1[2];
  v6 *= 8LL;
  uint64_t v9 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(void *)this + v9), v8, v6);
  unint64_t v10 = a1[9];
  uint64_t v11 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v11) = v10;
  uint64_t v12 = (const void *)a1[7];
  v10 *= 32LL;
  uint64_t v13 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v10);
  return memmove((void *)(*(void *)this + v13), v12, v10);
}

void *dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::serialize( void *a1, dyld4::BumpAllocator *this)
{
  uint64_t v4 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v4) = *a1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v5) = a1[1];
  unint64_t v6 = a1[4];
  uint64_t v7 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v7) = v6;
  uint64_t v8 = (const void *)a1[2];
  v6 *= 8LL;
  uint64_t v9 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v6);
  memmove((void *)(*(void *)this + v9), v8, v6);
  unint64_t v10 = a1[9];
  uint64_t v11 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, 8uLL);
  *(void *)(*(void *)this + v11) = v10;
  uint64_t v12 = (const void *)a1[7];
  v10 *= 48LL;
  uint64_t v13 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v10);
  return memmove((void *)(*(void *)this + v13), v12, v10);
}

size_t dyld4::MissingPaths::forEachPath(size_t result, uint64_t a2)
{
  uint64_t v2 = *(const char **)result;
  if (*(void *)result < *(void *)(result + 16))
  {
    size_t v4 = result;
    do
    {
      (*(void (**)(uint64_t, const char *))(a2 + 16))(a2, v2);
      double result = _platform_strlen(v2);
      v2 += result + 1;
    }

    while ((unint64_t)v2 < *(void *)(v4 + 16));
  }

  return result;
}

void *___ZN5dyld417PrebuiltLoaderSet13makeLaunchSetER11DiagnosticsRNS_12RuntimeStateERKNS_12MissingPathsE_block_invoke_3( uint64_t a1, char *__s)
{
  size_t v4 = *(dyld4::BumpAllocator **)(*(void *)(a1 + 32) + 8LL);
  unint64_t v5 = _platform_strlen(__s) + 1;
  uint64_t v6 = *((void *)v4 + 5);
  size_t v4 = (dyld4::BumpAllocator *)((char *)v4 + 40);
  uint64_t v7 = *((void *)v4 + 2) - v6;
  dyld4::BumpAllocator::zeroFill(v4, v5);
  double result = memmove((void *)(*(void *)v4 + v7), __s, v5);
  uint64_t v9 = **(void **)(a1 + 40) + *(void *)(a1 + 48);
  ++*(_DWORD *)(v9 + 32);
  return result;
}

vm_address_t dyld4::BumpAllocator::finalize(dyld4::BumpAllocator *this)
{
  unint64_t v2 = *((void *)this + 1);
  vm_address_t v3 = *(void *)this;
  vm_size_t v4 = (~*(void *)this + *((void *)this + 2) + vm_page_size) & -(uint64_t)vm_page_size;
  if (v2 > v4)
  {
    vm_deallocate(mach_task_self_, v4 + v3, v2 - v4);
    *((void *)this + 1) = v4;
    *((void *)this + 2) = 0LL;
  }

  vm_protect(mach_task_self_, v3, v4, 0, 1);
  *(void *)this = 0LL;
  return v3;
}

uint64_t dyld4::PrebuiltLoaderSet::forEachCachePatch(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 20))
  {
    uint64_t v3 = result;
    unint64_t v4 = 0LL;
    uint64_t v5 = result + *(unsigned int *)(result + 24);
    do
    {
      double result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
      ++v4;
      v5 += 16LL;
    }

    while (v4 < *(unsigned int *)(v3 + 20));
  }

  return result;
}

uint64_t dyld4::PrebuiltLoaderSet::deallocate(vm_address_t address)
{
  return vm_deallocate( mach_task_self_,  address,  (vm_page_size + *(unsigned int *)(address + 8) - 1) & -(uint64_t)vm_page_size);
}

void dyld4::BumpAllocator::~BumpAllocator(vm_address_t *this)
{
  if (*this)
  {
    vm_deallocate(mach_task_self_, *this, this[1]);
    this[1] = 0LL;
    this[2] = 0LL;
    *this = 0LL;
  }

void *dyld4::MissingPaths::addPath(dyld4::MissingPaths *this, const char *__s)
{
  unint64_t v4 = _platform_strlen(__s) + 1;
  uint64_t v5 = *((void *)this + 2) - *(void *)this;
  dyld4::BumpAllocator::zeroFill(this, v4);
  return memmove((void *)(*(void *)this + v5), __s, v4);
}

dyld4::PrebuiltObjC *dyld4::PrebuiltObjC::PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  *((void *)this + 4) = 0LL;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 40);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap( (uint64_t)this + 136,  0LL);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap( (uint64_t)this + 240,  0LL);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 344);
  *((_WORD *)this + 22dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  *((_BYTE *)this + 448) = 0;
  *((_BYTE *)this + 456) = 0;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *((void *)this + 62) = 0LL;
  return this;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map( uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  uint64_t v3 = 32LL;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1LL);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }

  while (v3);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  return a1;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::MultiMap( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1LL);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1LL;
    --v5;
  }

  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve( void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    uint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (vm_page_size + 56 * v6 - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    double result = memmove((void *)v3[3], *v3, 56LL * (void)v3[2]);
    unint64_t v11 = (unint64_t)v3[4] / 0x38;
    *uint64_t v3 = v3[3];
    v3[1] = (const void *)v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

dyld4::PrebuiltSwift *dyld4::PrebuiltSwift::PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  uint64_t v2 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( (uint64_t)this,  0LL);
  dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( v2 + 104,  0LL);
  dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap( (uint64_t)this + 208,  0LL);
  *((_BYTE *)this + 312) = 0;
  return this;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  vm_address_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1LL);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1LL;
    --v5;
  }

  while (v5);
  dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::MultiMap( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  vm_address_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  int v5 = 32;
  dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v4, 1LL);
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v7 + 1;
    *(void *)(v6 + 8 * v7) = -1LL;
    --v5;
  }

  while (v5);
  dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::reserve( (void *)(a1 + 56),  0x20uLL);
  *(void *)(a1 + 96) = a2;
  return a1;
}

void dyld4::PrebuiltSwift::~PrebuiltSwift(dyld4::PrebuiltSwift *this)
{
  *((void *)this + 35) = 0LL;
  vm_address_t v2 = *((void *)this + 36);
  if (v2) {
    vm_deallocate(mach_task_self_, v2, *((void *)this + 37));
  }
  *((void *)this + 3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  vm_address_t v3 = *((void *)this + 31);
  if (v3) {
    vm_deallocate(mach_task_self_, v3, *((void *)this + 32));
  }
  *((void *)this + 22) = 0LL;
  vm_address_t v4 = *((void *)this + 23);
  if (v4) {
    vm_deallocate(mach_task_self_, v4, *((void *)this + 24));
  }
  *((void *)this + 17) = 0LL;
  vm_address_t v5 = *((void *)this + 18);
  if (v5) {
    vm_deallocate(mach_task_self_, v5, *((void *)this + 19));
  }
  *((void *)this + 9) = 0LL;
  vm_address_t v6 = *((void *)this + 10);
  if (v6) {
    vm_deallocate(mach_task_self_, v6, *((void *)this + 11));
  }
  *((void *)this + 4) = 0LL;
  vm_address_t v7 = *((void *)this + 5);
  if (v7) {
    vm_deallocate(mach_task_self_, v7, *((void *)this + 6));
  }
}

void dyld4::PrebuiltObjC::~PrebuiltObjC(dyld4::PrebuiltObjC *this)
{
  if (*((void *)this + 60))
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *((void *)this + 58);
      vm_address_t v5 = (void *)(v4 + v2);
      *(void *)(v4 + v2 + 136) = 0LL;
      vm_address_t v6 = *(void *)(v4 + v2 + 144);
      if (v6) {
        vm_deallocate(mach_task_self_, v6, v5[19]);
      }
      v5[12] = 0LL;
      vm_address_t v7 = v5[13];
      if (v7) {
        vm_deallocate(mach_task_self_, v7, *(void *)(v4 + v2 + 112));
      }
      ++v3;
      v2 += 160LL;
    }

    while (v3 != *((void *)this + 60));
  }

  *((void *)this + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  vm_address_t v8 = *((void *)this + 61);
  if (v8) {
    vm_deallocate(mach_task_self_, v8, *((void *)this + 62));
  }
  *((void *)this + 52) = 0LL;
  vm_address_t v9 = *((void *)this + 53);
  if (v9) {
    vm_deallocate(mach_task_self_, v9, *((void *)this + 54));
  }
  *((void *)this + 47) = 0LL;
  vm_address_t v10 = *((void *)this + 48);
  if (v10) {
    vm_deallocate(mach_task_self_, v10, *((void *)this + 49));
  }
  *((void *)this + 39) = 0LL;
  vm_address_t v11 = *((void *)this + 40);
  if (v11) {
    vm_deallocate(mach_task_self_, v11, *((void *)this + 41));
  }
  *((void *)this + 34) = 0LL;
  vm_address_t v12 = *((void *)this + 35);
  if (v12) {
    vm_deallocate(mach_task_self_, v12, *((void *)this + 36));
  }
  *((void *)this + 26) = 0LL;
  vm_address_t v13 = *((void *)this + 27);
  if (v13) {
    vm_deallocate(mach_task_self_, v13, *((void *)this + 28));
  }
  *((void *)this + 21) = 0LL;
  vm_address_t v14 = *((void *)this + 22);
  if (v14) {
    vm_deallocate(mach_task_self_, v14, *((void *)this + 23));
  }
  *((void *)this + 14) = 0LL;
  vm_address_t v15 = *((void *)this + 15);
  if (v15) {
    vm_deallocate(mach_task_self_, v15, *((void *)this + 16));
  }
  *((void *)this + 9) = 0LL;
  vm_address_t v16 = *((void *)this + 10);
  if (v16) {
    vm_deallocate(mach_task_self_, v16, *((void *)this + 11));
  }
  if (*((void *)this + 2))
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    do
    {
      dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage((dyld4::PrebuiltObjC::ObjCOptimizerImage *)(*(void *)this + v17));
      ++v18;
      v17 += 568LL;
    }

    while (v18 != *((void *)this + 2));
  }

  *((void *)this + 2) = 0LL;
  vm_address_t v19 = *((void *)this + 3);
  if (v19) {
    vm_deallocate(mach_task_self_, v19, *((void *)this + 4));
  }
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::~ObjCOptimizerImage( dyld4::PrebuiltObjC::ObjCOptimizerImage *this)
{
  *((void *)this + 58) = 0LL;
  vm_address_t v2 = *((void *)this + 59);
  if (v2) {
    vm_deallocate(mach_task_self_, v2, *((void *)this + 60));
  }
  *((void *)this + 53) = 0LL;
  vm_address_t v3 = *((void *)this + 54);
  if (v3) {
    vm_deallocate(mach_task_self_, v3, *((void *)this + 55));
  }
  *((void *)this + 46) = 0LL;
  vm_address_t v4 = *((void *)this + 47);
  if (v4) {
    vm_deallocate(mach_task_self_, v4, *((void *)this + 48));
  }
  *((void *)this + 41) = 0LL;
  vm_address_t v5 = *((void *)this + 42);
  if (v5) {
    vm_deallocate(mach_task_self_, v5, *((void *)this + 43));
  }
  *((void *)this + 36) = 0LL;
  vm_address_t v6 = *((void *)this + 37);
  if (v6) {
    vm_deallocate(mach_task_self_, v6, *((void *)this + 38));
  }
  *((void *)this + 29) = 0LL;
  vm_address_t v7 = *((void *)this + 30);
  if (v7) {
    vm_deallocate(mach_task_self_, v7, *((void *)this + 31));
  }
  *((void *)this + 24) = 0LL;
  vm_address_t v8 = *((void *)this + 25);
  if (v8) {
    vm_deallocate(mach_task_self_, v8, *((void *)this + 26));
  }
  *((void *)this + 17) = 0LL;
  vm_address_t v9 = *((void *)this + 18);
  if (v9) {
    vm_deallocate(mach_task_self_, v9, *((void *)this + 19));
  }
  *((void *)this + 12) = 0LL;
  vm_address_t v10 = *((void *)this + 13);
  if (v10) {
    vm_deallocate(mach_task_self_, v10, *((void *)this + 14));
  }
  *((void *)this + 7) = 0LL;
  vm_address_t v11 = *((void *)this + 8);
  if (v11) {
    vm_deallocate(mach_task_self_, v11, *((void *)this + 9));
  }
  mach_o::Error::~Error((vm_address_t **)this + 4);
}

uint64_t dyld3::Map<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::insert( uint64_t a1, const char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v26, 0, sizeof(v26));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v26, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v26, 1LL);
      uint64_t v6 = (*(void *)&v26[1])++;
      *(_DWORD *)(*(void *)&v26[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        vm_address_t v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        size_t v9 = _platform_strlen(v8);
        unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v28, (uint64_t *)v8, v9);
        unint64_t v11 = (*(void *)&v26[1] - 1LL) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1)
        {
          uint64_t v12 = 1LL;
          do
            unint64_t v11 = (*(void *)&v26[1] - 1LL) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v26, v11) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v26)
    {
      *(void *)&v26[1] = 0LL;
      if (*((void *)&v26[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v26[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v13 = *(void *)(a1 + 40);
      if (v13) {
        vm_deallocate(mach_task_self_, v13, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v26[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v26 + 8);
      vm_size_t v14 = size;
      *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)&v26[1] + 1);
      *(void *)(a1 + 48) = v14;
    }
  }

  vm_address_t v15 = (char *)*a2;
  size_t v16 = _platform_strlen(*a2);
  unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( (uint64_t)v26,  (uint64_t *)v15,  v16);
  unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    uint64_t v21 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v21;
    ++*(void *)(a1 + 8);
    dyld3::OverflowSafeArray<dyld4::RuntimeState::HiddenCacheAddr,4294967295ull>::verifySpace((void *)(a1 + 56), 1LL);
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v23 + 1;
    *(_OWORD *)(v22 + 16 * v23) = *(_OWORD *)a2;
    uint64_t v24 = *(void *)(a1 + 72);
    if (!v24) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1();
    }
    return *(void *)(a1 + 56) + 16 * v24 - 16;
  }

  else
  {
    uint64_t v19 = 1LL;
    while (1)
    {
      uint64_t v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      if (!_platform_strcmp(*v20, *a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & (v17 + v19++);
      unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1) {
        goto LABEL_20;
      }
    }
  }

uint64_t dyld3::MapBase<char const*,BOOL,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return *a3;
  }
  vm_address_t v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  uint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v24, (uint64_t *)v8, v9);
  unint64_t v13 = a2[2];
  unint64_t v14 = v13 - 1;
  unint64_t v15 = v10 & (v13 - 1);
  if (v13 <= v15) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v10,  v11,  v12);
  uint64_t v16 = *a2;
  unint64_t v17 = a3[2];
  uint64_t v18 = *a3;
  uint64_t v19 = 1LL;
  uint64_t v20 = *a5;
  while (1)
  {
    unint64_t v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1) {
      return v18 + 16 * v17;
    }
    if (v17 <= v21) {
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    }
    uint64_t v10 = _platform_strcmp(*(const char **)(v18 + 16 * v21), v20);
    if (!(_DWORD)v10) {
      return v18 + 16 * v21;
    }
    unint64_t v22 = v15 + v19++;
    unint64_t v15 = v22 & v14;
    if (v13 <= (v22 & v14)) {
      goto LABEL_8;
    }
  }

void OUTLINED_FUNCTION_2_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

unint64_t objc::lookup8(objc *this, const unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3 = 0x9E3779B97F4A7C13LL;
  if ((unint64_t)a2 < 0x18)
  {
    unint64_t v5 = a3;
    uint64_t v4 = a2;
  }

  else
  {
    uint64_t v4 = a2;
    unint64_t v5 = a3;
    do
    {
      unint64_t v6 = a3
         + ((unint64_t)*((unsigned __int8 *)this + 14) << 48)
      unint64_t v7 = v3
         + ((unint64_t)*((unsigned __int8 *)this + 22) << 48)
      unint64_t v8 = (v5
          + ((unint64_t)*((unsigned __int8 *)this + 6) << 48)
          + (*(unsigned int *)this | ((unint64_t)*((unsigned __int8 *)this + 4) << 32) | ((unint64_t)*((unsigned __int8 *)this + 5) << 40))
          + ((unint64_t)*((unsigned __int8 *)this + 7) << 56)
          - (v6
           + v7)) ^ (v7 >> 43);
      unint64_t v9 = (v6 - v7 - v8) ^ (v8 << 9);
      unint64_t v10 = (v7 - v8 - v9) ^ (v9 >> 8);
      unint64_t v11 = (v8 - v9 - v10) ^ (v10 >> 38);
      unint64_t v12 = (v9 - v10 - v11) ^ (v11 << 23);
      unint64_t v13 = (v10 - v11 - v12) ^ (v12 >> 5);
      unint64_t v14 = (v11 - v12 - v13) ^ (v13 >> 35);
      unint64_t v15 = (v12 - v13 - v14) ^ (v14 << 49);
      unint64_t v16 = (v13 - v14 - v15) ^ (v15 >> 11);
      unint64_t v5 = (v14 - v15 - v16) ^ (v16 >> 12);
      a3 = (v15 - v16 - v5) ^ (v5 << 18);
      unint64_t v3 = (v16 - v5 - a3) ^ (a3 >> 22);
      this = (objc *)((char *)this + 24);
      v4 -= 24;
    }

    while ((unint64_t)v4 > 0x17);
  }

  unint64_t v17 = (unint64_t)&a2[v3];
  switch((unint64_t)v4)
  {
    case 1uLL:
      goto LABEL_29;
    case 2uLL:
      goto LABEL_28;
    case 3uLL:
      goto LABEL_27;
    case 4uLL:
      goto LABEL_26;
    case 5uLL:
      goto LABEL_25;
    case 6uLL:
      goto LABEL_24;
    case 7uLL:
      goto LABEL_23;
    case 8uLL:
      goto LABEL_22;
    case 9uLL:
      goto LABEL_21;
    case 0xAuLL:
      goto LABEL_20;
    case 0xBuLL:
      goto LABEL_19;
    case 0xCuLL:
      goto LABEL_18;
    case 0xDuLL:
      goto LABEL_17;
    case 0xEuLL:
      goto LABEL_16;
    case 0xFuLL:
      goto LABEL_15;
    case 0x10uLL:
      goto LABEL_14;
    case 0x11uLL:
      goto LABEL_13;
    case 0x12uLL:
      goto LABEL_12;
    case 0x13uLL:
      goto LABEL_11;
    case 0x14uLL:
      goto LABEL_10;
    case 0x15uLL:
      goto LABEL_9;
    case 0x16uLL:
      goto LABEL_8;
    case 0x17uLL:
      v17 += (unint64_t)*((unsigned __int8 *)this + 22) << 56;
LABEL_8:
      v17 += (unint64_t)*((unsigned __int8 *)this + 21) << 48;
LABEL_9:
      v17 += (unint64_t)*((unsigned __int8 *)this + 20) << 40;
LABEL_10:
      v17 += (unint64_t)*((unsigned __int8 *)this + 19) << 32;
LABEL_11:
      v17 += (unint64_t)*((unsigned __int8 *)this + 18) << 24;
LABEL_12:
      v17 += (unint64_t)*((unsigned __int8 *)this + 17) << 16;
LABEL_13:
      v17 += (unint64_t)*((unsigned __int8 *)this + 16) << 8;
LABEL_14:
      a3 += (unint64_t)*((unsigned __int8 *)this + 15) << 56;
LABEL_15:
      a3 += (unint64_t)*((unsigned __int8 *)this + 14) << 48;
LABEL_16:
      a3 += (unint64_t)*((unsigned __int8 *)this + 13) << 40;
LABEL_17:
      a3 += (unint64_t)*((unsigned __int8 *)this + 12) << 32;
LABEL_18:
      a3 += (unint64_t)*((unsigned __int8 *)this + 11) << 24;
LABEL_19:
      a3 += (unint64_t)*((unsigned __int8 *)this + 10) << 16;
LABEL_20:
      a3 += (unint64_t)*((unsigned __int8 *)this + 9) << 8;
LABEL_21:
      a3 += *((unsigned __int8 *)this + 8);
LABEL_22:
      v5 += (unint64_t)*((unsigned __int8 *)this + 7) << 56;
LABEL_23:
      v5 += (unint64_t)*((unsigned __int8 *)this + 6) << 48;
LABEL_24:
      v5 += (unint64_t)*((unsigned __int8 *)this + 5) << 40;
LABEL_25:
      v5 += (unint64_t)*((unsigned __int8 *)this + 4) << 32;
LABEL_26:
      v5 += (unint64_t)*((unsigned __int8 *)this + 3) << 24;
LABEL_27:
      v5 += (unint64_t)*((unsigned __int8 *)this + 2) << 16;
LABEL_28:
      v5 += (unint64_t)*((unsigned __int8 *)this + 1) << 8;
LABEL_29:
      v5 += *(unsigned __int8 *)this;
      break;
    default:
      break;
  }

  unint64_t v18 = (v5 - a3 - v17) ^ (v17 >> 43);
  unint64_t v19 = (a3 - v17 - v18) ^ (v18 << 9);
  unint64_t v20 = (v17 - v18 - v19) ^ (v19 >> 8);
  unint64_t v21 = (v18 - v19 - v20) ^ (v20 >> 38);
  unint64_t v22 = (v19 - v20 - v21) ^ (v21 << 23);
  unint64_t v23 = (v20 - v21 - v22) ^ (v22 >> 5);
  unint64_t v24 = (v21 - v22 - v23) ^ (v23 >> 35);
  unint64_t v25 = (v22 - v23 - v24) ^ (v24 << 49);
  unint64_t v26 = (v23 - v24 - v25) ^ (v25 >> 11);
  unint64_t v27 = (v24 - v25 - v26) ^ (v26 >> 12);
  return (v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 18))) ^ (((v25 - v26 - v27) ^ (v27 << 18)) >> 22);
}

unint64_t dyld4::SyscallDelegate::amfiFlags( dyld4::SyscallDelegate *this, int a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v11 = 0LL;
  uint64_t v8 = 2LL;
  if (!a2) {
    uint64_t v8 = 0LL;
  }
  if ((_DWORD)a3) {
    uint64_t v9 = v8 | 4;
  }
  else {
    uint64_t v9 = v8;
  }
  else {
    return v11;
  }
}

uint64_t dyld4::SyscallDelegate::internalInstall(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFF4084] & 1;
}

BOOL dyld4::SyscallDelegate::getCWD(dyld4::SyscallDelegate *this, char *a2)
{
  int v3 = open(".", 0x100000, 0LL);
  if (v3 == -1) {
    return 0LL;
  }
  int v4 = v3;
  int v5 = fcntl(v3, 50, a2);
  close(v4);
  return v5 != -1;
}

void *dyld4::SyscallDelegate::getGradedArchs( dyld4::SyscallDelegate *this, const char *a2, dyld3::GradedArchs *a3)
{
  return dyld3::GradedArchs::forCurrentOS(a3);
}

uint64_t dyld4::SyscallDelegate::openLogFile(dyld4::SyscallDelegate *this, const char *a2)
{
  return open(a2, 521, 420LL);
}

uint64_t dyld4::SyscallDelegate::dtraceUserProbesEnabled(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC092] & 1;
}

uint64_t dyld4::SyscallDelegate::dtraceRegisterUserProbes(dyld4::SyscallDelegate *this, dof_ioctl_data *a2)
{
  uint64_t result = open("/dev/dtracehelper", 2);
  if ((_DWORD)result != -1)
  {
    int v4 = result;
    int v5 = a2;
    ioctl(result, 0x80086804uLL, &v5);
    return close(v4);
  }

  return result;
}

uint64_t dyld4::SyscallDelegate::dtraceUnregisterUserProbe(dyld4::SyscallDelegate *this, uint64_t a2)
{
  uint64_t result = open("/dev/dtracehelper", 2, 0LL);
  if ((_DWORD)result != -1)
  {
    int v4 = result;
    ioctl(result, 0x20006802uLL, a2);
    return close(v4);
  }

  return result;
}

BOOL dyld4::SyscallDelegate::hasExistingDyldCache( dyld4::SyscallDelegate *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  int v7 = __shared_region_check_np(a2);
  if (!v7)
  {
    unint64_t v8 = *(void *)(*a2 + 496) + *a2;
    if (_platform_strncmp((const char *)v8, "dyld_data    v0", 0x10uLL))
    {
      unint64_t v9 = 0LL;
      *a3 = 0LL;
    }

    else
    {
      *a3 = *(void *)(v8 + 16);
      unint64_t v9 = *(void *)(v8 + 24);
    }

    *a4 = v9;
  }

  return v7 == 0;
}

uint64_t dyld4::SyscallDelegate::disablePageInLinking(dyld4::SyscallDelegate *this)
{
  return __shared_region_check_np((uint64_t *)0xFFFFFFFFFFFFFFFFLL);
}

DyldSharedCache *dyld4::SyscallDelegate::getDyldCache(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 v10 = *a2;
  int v11 = *((_DWORD *)a2 + 4);
  BYTE5(v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  dyld3::loadDyldCache((uint64_t)&v10, (void *)a3);
  uint64_t result = *(DyldSharedCache **)a3;
  if (*(void *)a3)
  {
    DyldSharedCache::getUUID(result, &v12);
    fsobj_id v5 = *(fsobj_id *)(a3 + 32);
    return (DyldSharedCache *)dyld3::kdebug_trace_dyld_cache( *(unsigned __int8 (**)[16])(a3 + 40),  v5,  *(void **)a3,  &v12,  v6,  v7,  v8,  v9);
  }

  return result;
}

uint64_t dyld4::SyscallDelegate::forEachInDirectory(int a1, char *a2, int a3, uint64_t a4)
{
  uint64_t result = open(a2, 0x100000, 0LL);
  if ((_DWORD)result != -1)
  {
    int v8 = result;
    bzero(v14, 0x18uLL);
    v14[0] = 5;
    int v15 = -2147483639;
    int v9 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0LL);
    if (v9 < 1) {
      return close(v8);
    }
    int v10 = v9;
    while (1)
    {
      int v11 = v17;
      do
      {
        uint64_t v12 = *((int *)v11 + 6);
        if ((v11[4] & 8) == 0) {
          goto LABEL_15;
        }
        unsigned int v13 = *((_DWORD *)v11 + 8);
        if (v13 == 2)
        {
          if (!a3) {
            goto LABEL_15;
          }
        }

        else if (v13 != 1 || (a3 & 1) != 0)
        {
          goto LABEL_15;
        }

        v16[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, a2, (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, "/", (const char *)0x400) > 0x3FF
          || dyld4::Utils::concatenatePaths((dyld4::Utils *)v16, &v11[v12 + 24], (const char *)0x400) > 0x3FF)
        {
          return close(v8);
        }

        (*(void (**)(uint64_t, _BYTE *, char *))(a4 + 16))(a4, v16, &v11[v12 + 24]);
LABEL_15:
        v11 += *(unsigned int *)v11;
        --v10;
      }

      while (v10);
      int v10 = getattrlistbulk(v8, v14, v17, 0x200uLL, 0LL);
      if (v10 <= 0) {
        return close(v8);
      }
    }
  }

  return result;
}

uint64_t dyld4::SyscallDelegate::getDylibInfo(int a1, dyld3 *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = 0LL;
  unint64_t v21 = &v20;
  uint64_t v22 = 0x3002000000LL;
  unint64_t v23 = __Block_byref_object_copy__5;
  unint64_t v24 = __Block_byref_object_dispose__5;
  Diagnostics::Diagnostics((Diagnostics *)&v25);
  uint64_t v16 = 0LL;
  unint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  char v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  _WORD v14[2] = ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke;
  void v14[3] = &unk_189620230;
  int v15 = a3;
  void v14[6] = a4;
  void v14[7] = a2;
  void v14[8] = a5;
  v14[9] = a6;
  v14[4] = &v20;
  void v14[5] = &v16;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(a1, (vm_address_t *)v21 + 5, a2, 0, (uint64_t)v14);
  uint64_t v12 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  mach_o::Error::~Error(&v25);
  return v12;
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::withReadOnlyMappedFile( int a1, vm_address_t *a2, dyld3 *a3, int a4, uint64_t a5)
{
  unsigned __int8 v9 = 0;
  if (a4) {
    unint64_t v6 = &v9;
  }
  else {
    unint64_t v6 = 0LL;
  }
  uint64_t result = dyld4::SyscallDelegate::mapFileReadOnly(a1, a2, a3, (off_t *)&v11, (uint64_t)v10, v6, (uint64_t)v12);
  if (result)
  {
    int v8 = result;
    (*(void (**)(uint64_t, dyld3::MachOAnalyzer *, size_t, void, _OWORD *, _BYTE *))(a5 + 16))( a5,  result,  v11,  v9,  v10,  v12);
    return (dyld3::MachOAnalyzer *)munmap(v8, v11);
  }

  return result;
}

uint64_t ___ZNK5dyld415SyscallDelegate12getDylibInfoEPKcN5dyld38PlatformERKNS3_11GradedArchsERjPc_block_invoke( uint64_t a1, dyld3::FatFile *this, unint64_t a3)
{
  int v3 = this;
  unint64_t v9 = a3;
  unint64_t v10 = 0LL;
  if (dyld3::FatFile::isFatFileWithSlice( this,  (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  a3,  *(const dyld3::GradedArchs **)(a1 + 48),  1,  &v10,  &v9,  &v11))
  {
    int v3 = (dyld3::MachOFile *)((char *)v3 + v10);
  }

  else
  {
    uint64_t result = dyld3::MachOFile::isMachO(v3, (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), v9);
    if (!(_DWORD)result) {
      return result;
    }
  }

  uint64_t result = dyld3::MachOFile::isDylib(v3);
  if ((_DWORD)result)
  {
    uint64_t result = dyld3::MachOFile::loadableIntoProcess(v3, *(_DWORD *)(a1 + 80), *(const char **)(a1 + 56), 0);
    if ((_DWORD)result)
    {
      uint64_t result = dyld3::MachOFile::getDylibInstallName(v3, (const char **)&__source, &v7, &v6);
      if ((_DWORD)result)
      {
        **(_DWORD **)(a1 + 64) = v6;
        uint64_t result = strlcpy(*(char **)(a1 + 72), __source, 0x400uLL);
        *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
      }
    }
  }

  return result;
}

BOOL dyld4::SyscallDelegate::isContainerized(dyld4::SyscallDelegate *this, const char *__s1)
{
  return __s1 && _platform_strncmp(__s1, "/private/var/mobile/Containers/Data/", 0x24uLL) == 0;
}

BOOL dyld4::SyscallDelegate::isMaybeContainerized(dyld4::SyscallDelegate *this, const char *__big)
{
  return __big && strstr(__big, "/var/mobile/Containers/Data/") != 0LL;
}

uint64_t dyld4::SyscallDelegate::fileExists(int a1, dyld3 *this, uint64_t a3, int *a4)
{
  if (dyld3::stat(this, &v11, (stat *)a3))
  {
    if (a4)
    {
      unsigned int v6 = __error();
      uint64_t result = 0LL;
      int v8 = *v6;
LABEL_9:
      *a4 = v8;
      return result;
    }

    return 0LL;
  }

  if ((v11.st_mode & 0xF000) != 0x8000)
  {
    if (a4)
    {
      uint64_t result = 0LL;
      int v8 = 666;
      goto LABEL_9;
    }

    return 0LL;
  }

  uint64_t result = 1LL;
  if (a3)
  {
    __darwin_time_t tv_sec = v11.st_mtimespec.tv_sec;
    uint64_t st_dev = v11.st_dev;
    *(void *)a3 = v11.st_ino;
    *(void *)(a3 + 8) = st_dev;
    *(void *)(a3 + 16) = tv_sec;
    *(_BYTE *)(a3 + 24) = 1;
  }

  return result;
}

BOOL dyld4::SyscallDelegate::dirExists(dyld4::SyscallDelegate *this, dyld3 *a2, stat *a3)
{
  return !dyld3::stat(a2, &v5, a3) && (v5.st_mode & 0xF000) == 0x4000;
}

BOOL dyld4::SyscallDelegate::mkdirs(dyld4::SyscallDelegate *this, const char *__s)
{
  size_t v3 = _platform_strlen(__s);
  __chkstk_darwin(v3, v4, v5, v6, v7, v8, v9, v10, v19);
  uint64_t v12 = (char *)&v19 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  strcpy(v12, __s);
  unsigned int v13 = strrchr(v12, 47);
  int v15 = v13;
  if (v13)
  {
    v13[1] = 0;
    if (dyld3::stat((dyld3 *)v12, &v20, v14))
    {
      uint64_t v16 = _platform_strchr(v12 + 1, 47);
      if (v16)
      {
        unint64_t v17 = v16;
        do
        {
          *unint64_t v17 = 0;
          mkdir(v12, 0x1EDu);
          *unint64_t v17 = 47;
          unint64_t v17 = _platform_strchr(v17 + 1, 47);
        }

        while (v17);
      }
    }
  }

  return v15 != 0LL;
}

BOOL dyld4::SyscallDelegate::realpath(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  uint64_t v4 = (const char *)a2;
  int v5 = dyld3::open(a2, 0LL, 0LL);
  if (v5 == -1)
  {
    strlcpy(__dst, v4, 0x400uLL);
    uint64_t v8 = strrchr(__dst, 47);
    if (v8)
    {
      *uint64_t v8 = 0;
      v4 += v8 - __dst + 1;
    }

    else
    {
      strcpy(__dst, ".");
    }

    int v9 = dyld3::open((dyld3 *)__dst, (const char *)0x100000, 0LL);
    if (v9 == -1) {
      return 0LL;
    }
    int v10 = v9;
    int v11 = fcntl(v9, 50, a3);
    close(v10);
    if (v11)
    {
      return 0LL;
    }

    else
    {
      strlcat(a3, "/", 0x400uLL);
      strlcat(a3, v4, 0x400uLL);
      return 1LL;
    }
  }

  else
  {
    int v6 = v5;
    BOOL v7 = fcntl(v5, 50, a3) == 0;
    close(v6);
  }

  return v7;
}

uint64_t dyld4::SyscallDelegate::fcntl(dyld4::SyscallDelegate *this, int a2, int a3, void *a4)
{
  return fcntl(a2, a3, a4);
}

BOOL dyld4::SyscallDelegate::realpathdir(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3)
{
  int v4 = dyld3::open(a2, (const char *)0x100000, 0LL);
  if (v4 == -1) {
    return 0LL;
  }
  int v5 = v4;
  BOOL v6 = fcntl(v4, 50, a3) == 0;
  close(v5);
  return v6;
}

dyld3::MachOAnalyzer *dyld4::SyscallDelegate::mapFileReadOnly( int a1, vm_address_t *a2, dyld3 *this, off_t *a4, uint64_t a5, _BYTE *a6, uint64_t a7)
{
  if (dyld3::stat(this, &v41, (stat *)this) == -1)
  {
    int v20 = *__error();
    if (v20 == 2)
    {
      Diagnostics::error(a2, "no such file");
    }

    else if (v20 == 1 {
           && (pid_t v21 = getpid(),
    }
               (int)sandbox_check( v21,  (vm_address_t *)"file-read-metadata",  1073741825,  v22,  v23,  v24,  v25,  v26,  this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked stat()", v37);
    }

    else
    {
      __error();
      Diagnostics::error(a2, "stat() failed with errno=%d");
    }

    return 0LL;
  }

  if (!v41.st_size) {
    return 0LL;
  }
  int v13 = dyld3::open(this, 0LL, 0LL);
  if (v13 < 0)
  {
    if (*__error() == 1
      && (pid_t v27 = getpid(),
          (int)sandbox_check( v27,  (vm_address_t *)"file-read-data",  1073741825,  v28,  v29,  v30,  v31,  v32,  this) >= 1))
    {
      Diagnostics::error(a2, "file system sandbox blocked open()", v38);
    }

    else
    {
      Diagnostics::error(a2, "open() failed with errno=%d");
    }

    return 0LL;
  }

  int v14 = v13;
  int v15 = (dyld3::MachOAnalyzer *)mmap(0LL, v41.st_size, 1, 2, v13, 0LL);
  if (v15 == (dyld3::MachOAnalyzer *)-1LL)
  {
    st_vm_size_t size = v41.st_size;
    uint64_t v35 = __error();
    Diagnostics::error(a2, "mmap(size=0x%0lX) failed with errno=%d", st_size, *v35);
    close(v14);
    return 0LL;
  }

  uint64_t v16 = v15;
  if (a4) {
    *a4 = v41.st_size;
  }
  if (a5)
  {
    __darwin_time_t tv_sec = v41.st_mtimespec.tv_sec;
    uint64_t st_dev = v41.st_dev;
    *(void *)a5 = v41.st_ino;
    *(void *)(a5 + 8) = st_dev;
    *(void *)(a5 + 16) = tv_sec;
    *(_BYTE *)(a5 + 24) = 1;
  }

  if (a7) {
    fcntl(v14, 50, a7);
  }
  if (a6)
  {
    *a6 = 0;
    if (dyld3::MachOFile::hasMachOMagic(v16))
    {
      if (*((_DWORD *)v16 + 1) == 16777228
        && (*((_DWORD *)v16 + 2) & 0xFFFFFF) == 2
        && dyld3::MachOAnalyzer::isOSBinary(v16, v14, 0LL))
      {
        *a6 = 1;
      }
    }

    else
    {
      uint64_t v36 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v16, v19);
      if (v36)
      {
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 0x40000000LL;
        void v39[2] = ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke;
        v39[3] = &__block_descriptor_tmp_14;
        int v40 = v14;
        v39[4] = v16;
        v39[5] = a6;
        dyld3::FatFile::forEachSlice(v36, a2, v41.st_size, (uint64_t)v39);
      }
    }
  }

  close(v14);
  return v16;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedStat(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-metadata", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

uint64_t dyld4::SyscallDelegate::open(dyld4::SyscallDelegate *this, dyld3 *a2, char *a3, uint64_t a4)
{
  return dyld3::open(a2, a3, a4);
}

BOOL dyld4::SyscallDelegate::sandboxBlockedOpen(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-read-data", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

BOOL dyld4::SyscallDelegate::getpath(dyld4::SyscallDelegate *this, int a2, char *a3)
{
  return fcntl(a2, 50, a3) == 0;
}

uint64_t ___ZNK5dyld415SyscallDelegate15mapFileReadOnlyER11DiagnosticsPKcPmPNS_6FileIDEPbPc_block_invoke( uint64_t result, int a2, int a3, dyld3::MachOAnalyzer *this)
{
  if (a2 == 16777228 && (a3 & 0xFFFFFF) == 2)
  {
    uint64_t v5 = result;
    uint64_t result = dyld3::MachOAnalyzer::isOSBinary(this, *(_DWORD *)(result + 48), (uint64_t)this - *(void *)(result + 32));
    if ((_DWORD)result) {
      **(_BYTE **)(v5 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
    }
  }

  return result;
}

uint64_t dyld4::SyscallDelegate::unmapFile(dyld4::SyscallDelegate *this, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

BOOL dyld4::SyscallDelegate::getFileAttribute(int a1, char *path, char *name, uint64_t a4)
{
  unint64_t v5 = getxattr(path, name, *(void **)a4, *(void *)(a4 + 8), 0, 0);
  if (v5 != -1LL)
  {
    if (*(void *)(a4 + 8) < v5) {
      dyld4::SyscallDelegate::getFileAttribute();
    }
    *(void *)(a4 + 16) = v5;
  }

  return v5 != -1LL;
}

BOOL dyld4::SyscallDelegate::setFileAttribute(int a1, char *a2, const char *a3, uint64_t a4)
{
  if (chmod(a2, 0x180u)) {
    return 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  return !chmod(a2, 0x100u) && v8;
}

uint64_t dyld4::SyscallDelegate::saveFileWithAttribute( int a1, vm_address_t *a2, char *__source, const void *a4, size_t a5, const char *a6, uint64_t a7)
{
  unsigned int v13 = getpid();
  __sourcea[0] = 46;
  if (HIBYTE(v13) >= 0xA0u) {
    char v14 = 55;
  }
  else {
    char v14 = 48;
  }
  __sourcea[1] = v14 + (v13 >> 28);
  unsigned int v15 = HIBYTE(v13) & 0xF;
  if (v15 >= 0xA) {
    char v16 = 55;
  }
  else {
    char v16 = 48;
  }
  __sourcea[2] = v16 + v15;
  if (BYTE2(v13) >= 0xA0u) {
    char v17 = 55;
  }
  else {
    char v17 = 48;
  }
  __sourcea[3] = v17 + ((v13 >> 20) & 0xF);
  if ((HIWORD(v13) & 0xF) >= 0xAu) {
    char v18 = 55;
  }
  else {
    char v18 = 48;
  }
  __sourcea[4] = v18 + (BYTE2(v13) & 0xF);
  if (BYTE1(v13) >= 0xA0u) {
    char v19 = 55;
  }
  else {
    char v19 = 48;
  }
  __sourcea[5] = v19 + ((unsigned __int16)v13 >> 12);
  unsigned int v20 = (v13 >> 8) & 0xF;
  if (v20 >= 0xA) {
    char v21 = 55;
  }
  else {
    char v21 = 48;
  }
  __sourcea[6] = v21 + v20;
  else {
    char v22 = 48;
  }
  __sourcea[7] = v22 + ((v13 & 0xF0) >> 4);
  if ((v13 & 0xF) >= 0xA) {
    char v23 = 55;
  }
  else {
    char v23 = 48;
  }
  __sourcea[8] = v23 + (v13 & 0xF);
  __sourcea[9] = 0;
  strlcat(__dst, __sourcea, 0x400uLL);
  int v24 = open_dprotected_np(__dst, 513, 4, 0, 384LL);
  if (v24 == -1)
  {
    __error();
    Diagnostics::error(a2, "open/open_dprotected_np(%s) failed, errno=%d");
  }

  else
  {
    int v25 = v24;
    if (ftruncate(v24, a5) == -1)
    {
      __error();
      Diagnostics::error(a2, "ftruncate(%lu) failed, errno=%d");
    }

    else if (write(v25, a4, a5) == a5)
    {
      if (fsetxattr(v25, a6, *(const void **)a7, *(void *)(a7 + 16), 0, 0) == -1)
      {
        __error();
        Diagnostics::error(a2, "fsetxattr(%s) failed, errno=%d");
      }

      else if (fchmod(v25, 0x100u) == -1)
      {
        __error();
        Diagnostics::error(a2, "fchmod(S_IRUSR) failed, errno=%d");
      }

      else if (close(v25) == -1)
      {
        __error();
        Diagnostics::error(a2, "close() failed, errno=%d");
      }

      else
      {
        if (rename(__dst, __source) != -1) {
          return 1LL;
        }
        __error();
        Diagnostics::error(a2, "rename(%s, %s) failed, errno=%d");
      }
    }

    else
    {
      __error();
      Diagnostics::error(a2, "write() failed, errno=%d");
    }
  }

  return 0LL;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedMmap(dyld4::SyscallDelegate *this, const char *a2)
{
  unsigned int v2 = a2;
  pid_t v3 = getpid();
  return (int)sandbox_check(v3, (vm_address_t *)"file-map-executable", 1073741825, v4, v5, v6, v7, v8, v2) > 0;
}

BOOL dyld4::SyscallDelegate::sandboxBlockedPageInLinking(dyld4::SyscallDelegate *this)
{
  pid_t v1 = getpid();
  return (int)sandbox_check(v1, (vm_address_t *)"syscall-unix", 1073741838, v2, v3, v4, v5, v6, 0x226u) > 0;
}

dyld4::SyscallDelegate::DyldCommPage *dyld4::SyscallDelegate::DyldCommPage::DyldCommPage( dyld4::SyscallDelegate::DyldCommPage *this)
{
  return this;
}

uint64_t dyld4::SyscallDelegate::dyldCommPageFlags(dyld4::SyscallDelegate *this)
{
  return MEMORY[0xFFFFFC160];
}

uint64_t dyld4::SyscallDelegate::setDyldCommPageFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return sysctlbyname("kern.dyld_flags", 0LL, 0LL, &v3, 8uLL);
}

BOOL dyld4::SyscallDelegate::bootVolumeWritable(dyld4::SyscallDelegate *this)
{
  return statfs64("/", &v2)
      || *(_DWORD *)v2.f_fstypename ^ 0x73667061 | v2.f_fstypename[4]
      || (~v2.f_flags & 0x40000001) != 0;
}

uint64_t dyld4::SyscallDelegate::close(dyld4::SyscallDelegate *this, int a2)
{
  return close(a2);
}

ssize_t dyld4::SyscallDelegate::pread( dyld4::SyscallDelegate *this, int __fd, void *__buf, size_t __nbyte, off_t a5)
{
  return pread(__fd, __buf, __nbyte, a5);
}

uint64_t dyld4::SyscallDelegate::mprotect(dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4)
{
  return mprotect(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::unlink(dyld4::SyscallDelegate *this, const char *a2)
{
  return unlink(a2);
}

uint64_t dyld4::SyscallDelegate::fstat(dyld4::SyscallDelegate *this, int a2, stat *a3)
{
  return fstat64(a2, a3);
}

void *dyld4::SyscallDelegate::mmap( dyld4::SyscallDelegate *this, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t dyld4::SyscallDelegate::socket(dyld4::SyscallDelegate *this, int a2, int a3, int a4)
{
  return socket(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::connect( dyld4::SyscallDelegate *this, int a2, const sockaddr *a3, socklen_t a4)
{
  return connect(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::vm_protect( dyld4::SyscallDelegate *this, vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return vm_protect(target_task, address, size, set_maximum, new_protection);
}

uint64_t dyld4::SyscallDelegate::mremap_encrypted( dyld4::SyscallDelegate *this, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mremap_encrypted(a2, a3, a4, a5, a6, a6, a7, a8);
}

ssize_t dyld4::SyscallDelegate::fsgetpath( dyld4::SyscallDelegate *this, char *a2, size_t a3, fsid_t a4, uint64_t a5)
{
  fsid_t v6 = a4;
  return fsgetpath(a2, a3, &v6, a5);
}

uint64_t dyld4::SyscallDelegate::getfsstat(dyld4::SyscallDelegate *this, statfs *a2, int a3, int a4)
{
  return getfsstat64(a2, a3, a4);
}

uint64_t dyld4::SyscallDelegate::getattrlist( dyld4::SyscallDelegate *this, const char *a2, attrlist *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

uint64_t PatchTable::patchableExportCount(int **this, unsigned int a2)
{
  statfs v2 = *this;
  int v3 = **this;
  else {
    return 0LL;
  }
}

BOOL PatchTable::imageHasClient(PatchTable *this, unsigned int a2, int a3)
{
  return (**(_DWORD **)this - 2) <= 2 && PatchTableV2::imageHasClient(this, a2, a3);
}

BOOL PatchTableV2::imageHasClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = (unsigned int *)(v3 + *(void *)(v3 + 8) - v4 + 16LL * a2);
  unsigned int v6 = v5[1];
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = (int *)(v3 + *(void *)(v3 + 40) - v4 + 12LL * *v5);
  uint64_t v8 = 12LL * v6 - 12;
  do
  {
    int v9 = *v7;
    v7 += 3;
    BOOL result = v9 == a3;
    BOOL v11 = v9 == a3 || v8 == 0;
    v8 -= 12LL;
  }

  while (!v11);
  return result;
}

void *PatchTable::forEachPatchableExport(void *result, unsigned int a2, uint64_t a3)
{
  return result;
}

void *PatchTableV2::forEachPatchableExport(void *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = (void *)*result;
  if (*(void *)(*result + 16LL) > (unint64_t)a2)
  {
    uint64_t v4 = result[1];
    uint64_t v5 = (uint64_t)&v3[2 * a2] + v3[1] - v4;
    uint64_t v6 = *(unsigned int *)(v5 + 12);
    if ((_DWORD)v6)
    {
      unint64_t v8 = v3[12];
      int v9 = (char *)v3 + v3[11] - v4;
      int v10 = (_DWORD *)((char *)v3 + v3[3] + 8LL * *(unsigned int *)(v5 + 8) - v4 + 4);
      uint64_t v11 = 8 * v6;
      do
      {
        if (v8 < (*v10 & 0xFFFFFFFu)) {
          abort();
        }
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void, char *, void))(a3 + 16))( a3,  *(v10 - 1),  &v9[*v10 & 0xFFFFFFF],  *v10 >> 28);
        v10 += 2;
        v11 -= 8LL;
      }

      while (v11);
    }
  }

  return result;
}

PatchTableV2 *PatchTable::forEachPatchableUseOfExportInImage( PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  int v5 = **(_DWORD **)a1;
  if (v5 == 4) {
    return (PatchTableV2 *)PatchTableV4::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  }
  if (v5 == 3 || v5 == 2) {
    return (PatchTableV2 *)PatchTableV2::forEachPatchableUseOfExportInImage(a1, a2, a3, a4, a5);
  }
  return a1;
}

char *PatchTableV2::forEachPatchableUseOfExportInImage( PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 1);
  uint64_t v9 = *(void *)(*(void *)a1 + 24LL);
  uint64_t v10 = *(void *)(*(void *)a1 + 72LL);
  BOOL result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    unsigned int v13 = (unsigned int *)(result + 8);
    uint64_t v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8LL * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12LL;
      if (!v14) {
        return result;
      }
    }

    uint64_t v15 = *v13;
    if ((_DWORD)v15)
    {
      char v16 = (unsigned int *)(v10 + 8LL * *(v13 - 1) - v8 + v7 + 4);
      uint64_t v17 = 8 * v15;
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
        int8x16_t v18 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1800B8340),  (int8x16_t)xmmword_1800B8350);
        *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
        unsigned __int32 v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
        BOOL result = (char *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *(v16 - 1));
        v16 += 2;
        v17 -= 8LL;
      }

      while (v17);
    }
  }

  return result;
}

char *PatchTableV4::forEachPatchableUseOfExportInImage( PatchTableV2 *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 1);
  uint64_t v9 = *(void *)(*(void *)a1 + 24LL);
  uint64_t v10 = *(void *)(*(void *)a1 + 72LL);
  BOOL result = PatchTableV2::clientsExportsForImageAndClient(a1, a2, a4);
  if (v12)
  {
    unsigned int v13 = (unsigned int *)(result + 8);
    uint64_t v14 = 12 * v12;
    while (*(_DWORD *)(v7 + v9 - v8 + 8LL * *(v13 - 2)) != a3)
    {
      v13 += 3;
      v14 -= 12LL;
      if (!v14) {
        return result;
      }
    }

    uint64_t v15 = *v13;
    if ((_DWORD)v15)
    {
      char v16 = (unsigned int *)(v7 + v10 - v8 + 8LL * *(v13 - 1));
      uint64_t v17 = &v16[2 * v15];
      do
      {
        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v21);
        dyld_cache_patchable_location_v4::getPMD((uint64_t)v16, &v21);
        uint64_t v18 = *v16;
        unsigned int v19 = v16[1];
        v16 += 2;
        if ((v19 & 1) != 0) {
          uint64_t v20 = (v19 >> 9) & 0x1F;
        }
        else {
          uint64_t v20 = v19 >> 9;
        }
        BOOL result = (char *)(*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void))(a5 + 16))( a5,  v18,  v21,  v20,  (v19 >> 8) & 1);
      }

      while (v16 != v17);
    }
  }

  return result;
}

void *PatchTable::forEachPatchableCacheUseOfExport( void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6 = *(_DWORD *)*result;
  if (v6 == 4) {
    return PatchTableV4::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  }
  if (v6 == 3 || v6 == 2) {
    return PatchTableV2::forEachPatchableCacheUseOfExport(result, a2, a3, a4, a5, a6);
  }
  return result;
}

void *PatchTableV2::forEachPatchableCacheUseOfExport( void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)*result;
  if (*(void *)(*result + 16LL) > (unint64_t)a2)
  {
    uint64_t v9 = result[1];
    uint64_t v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    unsigned int v12 = *v10;
    uint64_t v11 = v10[1];
    unsigned int v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      uint64_t v14 = (char *)v8 + v8[3] - v9;
      int v25 = (char *)v8 + v8[7] - v9;
      uint64_t v29 = (char *)v8 + v8[9] - v9;
      pid_t v27 = &v13[3 * v11];
      do
      {
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *v13);
        unsigned int v15 = v13[2];
        if (v15)
        {
          char v16 = (unsigned int *)&v25[12 * v13[1]];
          uint64_t v17 = &v16[3 * v15];
          uint64_t v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              uint64_t v19 = v16[2];
              if ((_DWORD)v19)
              {
                uint64_t v20 = (unsigned int *)&v29[8 * v16[1]];
                unsigned int v21 = &v20[2 * v19];
                do
                {
                  char v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v30);
                  unsigned int v23 = v20[1];
                  int8x16_t v24 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v23), (uint32x4_t)xmmword_1800B8340),  (int8x16_t)xmmword_1800B8350);
                  *(int8x8_t *)v24.i8 = vorr_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
                  unsigned __int32 v30 = v24.i32[0] | v30 & 0xF0000000 | v24.i32[1] | HIWORD(v23);
                  BOOL result = (void *)(*(uint64_t (**)(uint64_t, char *))(a6 + 16))(a6, v22);
                  v20 += 2;
                }

                while (v20 != v21);
              }
            }

            v16 += 3;
          }

          while (v16 != v17);
        }

        v13 += 3;
      }

      while (v13 != v27);
    }
  }

  return result;
}

void *PatchTableV4::forEachPatchableCacheUseOfExport( void *result, unsigned int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = (void *)*result;
  if (*(void *)(*result + 16LL) > (unint64_t)a2)
  {
    uint64_t v9 = result[1];
    uint64_t v10 = (unsigned int *)((char *)&v8[2 * a2] + v8[1] - v9);
    unsigned int v12 = *v10;
    uint64_t v11 = v10[1];
    unsigned int v13 = (unsigned int *)((char *)v8 + 12 * v12 + v8[5] - v9);
    if (v11)
    {
      uint64_t v14 = (char *)v8 + v8[3] - v9;
      int v25 = (char *)v8 + v8[7] - v9;
      uint64_t v29 = (char *)v8 + v8[9] - v9;
      pid_t v27 = &v13[3 * v11];
      do
      {
        BOOL result = (void *)(*(uint64_t (**)(uint64_t, void))(a5 + 16))(a5, *v13);
        unsigned int v15 = v13[2];
        if (v15)
        {
          char v16 = (unsigned int *)&v25[12 * v13[1]];
          uint64_t v17 = &v16[3 * v15];
          uint64_t v18 = (char *)result - a4;
          do
          {
            if (*(_DWORD *)&v14[8 * *v16] == a3)
            {
              uint64_t v19 = v16[2];
              if ((_DWORD)v19)
              {
                uint64_t v20 = (unsigned int *)&v29[8 * v16[1]];
                unsigned int v21 = &v20[2 * v19];
                do
                {
                  char v22 = &v18[*v20];
                  dyld3::MachOFile::PointerMetaData::PointerMetaData(&v30);
                  dyld_cache_patchable_location_v4::getPMD((uint64_t)v20, &v30);
                  unsigned int v23 = v20[1];
                  if ((v23 & 1) != 0) {
                    uint64_t v24 = (v23 >> 9) & 0x1F;
                  }
                  else {
                    uint64_t v24 = v23 >> 9;
                  }
                  BOOL result = (void *)(*(uint64_t (**)(uint64_t, char *, void, uint64_t, void))(a6 + 16))( a6,  v22,  v30,  v24,  (v23 >> 8) & 1);
                  v20 += 2;
                }

                while (v20 != v21);
              }
            }

            v16 += 3;
          }

          while (v16 != v17);
        }

        v13 += 3;
      }

      while (v13 != v27);
    }
  }

  return result;
}

uint64_t PatchTable::forEachPatchableGOTUseOfExport( uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = **(_DWORD **)result;
  if (v4 == 4) {
    return (uint64_t)PatchTableV4::forEachPatchableGOTUseOfExport((void *)result, a2, a3, a4);
  }
  if (v4 == 3) {
    return PatchTableV3::forEachPatchableGOTUseOfExport(result, a2, a3, a4);
  }
  return result;
}

uint64_t PatchTableV3::forEachPatchableGOTUseOfExport( uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = *(void **)result;
  if (*(void *)(*(void *)result + 112LL) > (unint64_t)a2)
  {
    uint64_t v5 = *(void *)(result + 8);
    int v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    uint64_t v7 = v6[1];
    if ((_DWORD)v7)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      uint64_t v11 = v7 - 1;
      while (1)
      {
        uint64_t v12 = v9 + v11;
        if (v9 + v11 < 0 != __OFADD__(v9, v11)) {
          ++v12;
        }
        uint64_t v13 = v12 >> 1;
        BOOL result = *(unsigned int *)((char *)&v4[*(unsigned int *)(v10 + 12LL * v13)] + v4[3] - v5);
        if ((_DWORD)result == a3) {
          break;
        }
        else {
          uint64_t v11 = v13 - 1;
        }
        if (v9 > v11) {
          return result;
        }
      }

      uint64_t v14 = v10 + 12LL * v13;
      uint64_t v15 = *(unsigned int *)(v14 + 8);
      if ((_DWORD)v15)
      {
        char v16 = (unsigned int *)((char *)v4 + v4[17] + 16LL * *(unsigned int *)(v14 + 4) - v5 + 8);
        uint64_t v17 = 16 * v15;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v19);
          int8x16_t v18 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(*v16), (uint32x4_t)xmmword_1800B8340),  (int8x16_t)xmmword_1800B8350);
          *(int8x8_t *)v18.i8 = vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
          unsigned __int32 v19 = v18.i32[0] | v19 & 0xF0000000 | v18.i32[1] | HIWORD(*v16);
          BOOL result = (*(uint64_t (**)(uint64_t, void))(a4 + 16))(a4, *((void *)v16 - 1));
          v16 += 4;
          v17 -= 16LL;
        }

        while (v17);
      }
    }
  }

  return result;
}

void *PatchTableV4::forEachPatchableGOTUseOfExport( void *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v4 = (void *)*result;
  if (*(void *)(*result + 112LL) > (unint64_t)a2)
  {
    uint64_t v5 = result[1];
    int v6 = (unsigned int *)((char *)&v4[a2] + v4[13] - v5);
    uint64_t v7 = v6[1];
    if ((_DWORD)v7)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = (uint64_t)v4 + 12 * *v6 + v4[15] - v5;
      uint64_t v11 = v4[17] - v5;
      uint64_t v12 = (char *)v4 + v4[3] - v5;
      uint64_t v13 = (char *)v4 + v11;
      uint64_t v14 = v7 - 1;
      while (1)
      {
        uint64_t v15 = v9 + v14;
        if (v9 + v14 < 0 != __OFADD__(v9, v14)) {
          ++v15;
        }
        uint64_t v16 = v15 >> 1;
        unsigned int v17 = *(_DWORD *)&v12[8 * *(unsigned int *)(v10 + 12LL * v16)];
        if (v17 == a3) {
          break;
        }
        if (v17 <= a3) {
          uint64_t v9 = v16 + 1;
        }
        else {
          uint64_t v14 = v16 - 1;
        }
        if (v9 > v14) {
          return result;
        }
      }

      uint64_t v18 = v10 + 12LL * v16;
      uint64_t v19 = *(unsigned int *)(v18 + 8);
      if ((_DWORD)v19)
      {
        uint64_t v20 = (uint64_t)&v13[16 * *(unsigned int *)(v18 + 4)];
        uint64_t v21 = v20 + 16 * v19;
        do
        {
          dyld3::MachOFile::PointerMetaData::PointerMetaData(&v24);
          dyld_cache_patchable_location_v4_got::getPMD(v20, &v24);
          unsigned int v22 = *(_DWORD *)(v20 + 8);
          if ((v22 & 1) != 0) {
            uint64_t v23 = (v22 >> 9) & 0x1F;
          }
          else {
            uint64_t v23 = v22 >> 9;
          }
          BOOL result = (void *)(*(uint64_t (**)(uint64_t, void, void, uint64_t, void))(a4 + 16))( a4,  *(void *)v20,  v24,  v23,  (v22 >> 8) & 1);
          v20 += 16LL;
        }

        while (v20 != v21);
      }
    }
  }

  return result;
}

char *PatchTableV2::clientsExportsForImageAndClient(PatchTableV2 *this, unsigned int a2, int a3)
{
  uint64_t v3 = *(void **)this;
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = (unsigned int *)((char *)&v3[2 * a2] + v3[1] - v4);
  uint64_t v6 = v5[1];
  if (!(_DWORD)v6) {
    return 0LL;
  }
  unsigned int v7 = *v5;
  uint64_t v8 = (char *)v3 + v3[7] - v4;
  uint64_t v9 = 12 * v6;
  for (uint64_t i = (uint64_t)v3 + v3[5] + 12LL * v7 - v4 + 8; *(_DWORD *)(i - 8) != a3; i += 12LL)
  {
    v9 -= 12LL;
    if (!v9) {
      return 0LL;
    }
  }

  return &v8[12 * *(unsigned int *)(i - 4)];
}

uint64_t dyld_cache_patchable_location_v4::getPMD(uint64_t result, unsigned int *a2)
{
  if ((*(_DWORD *)(result + 4) & 1) != 0)
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 4);
    unsigned int v4 = v5 >> 16;
    *a2 = v4;
    unsigned int v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
    *a2 = v6;
    unsigned int v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 4) & 1) << 24);
    *a2 = v7;
    unsigned int v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 4) << 11) & 0x4000000;
    *a2 = v8;
    unsigned int v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 4) << 13) & 0x8000000;
  }

  else
  {
    unsigned int v2 = *a2;
    *a2 &= 0xFFFF0000;
    unsigned int v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 4) >> 1) & 0x7F) << 17);
  }

  *a2 = v3;
  return result;
}

uint64_t dyld_cache_patchable_location_v4_got::getPMD(uint64_t result, unsigned int *a2)
{
  if ((*(_DWORD *)(result + 8) & 1) != 0)
  {
    HIDWORD(v5) = *((unsigned __int16 *)a2 + 1);
    LODWORD(v5) = *(_DWORD *)(result + 8);
    unsigned int v4 = v5 >> 16;
    *a2 = v4;
    unsigned int v6 = v4 & 0xFF00FFFF | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
    *a2 = v6;
    unsigned int v7 = v6 & 0xFEFFFFFF | ((*(_DWORD *)(result + 8) & 1) << 24);
    *a2 = v7;
    unsigned int v8 = v7 & 0xF9FFFFFF | (*(_DWORD *)(result + 8) << 11) & 0x4000000;
    *a2 = v8;
    unsigned int v3 = v8 & 0xF7FFFFFF | (*(_DWORD *)(result + 8) << 13) & 0x8000000;
  }

  else
  {
    unsigned int v2 = *a2;
    *a2 &= 0xFFFF0000;
    unsigned int v3 = v2 & 0xF0000000 | (((*(_DWORD *)(result + 8) >> 1) & 0x7F) << 17);
  }

  *a2 = v3;
  return result;
}

dyld4::FileManager *dyld4::FileManager::FileManager( dyld4::FileManager *this, lsl::Lock **a2, const dyld4::SyscallDelegate *a3)
{
  *(void *)this = a3;
  *((void *)this + 1) = a2;
  unint64_t v5 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x28uLL);
  *unint64_t v5 = 0LL;
  v5[1] = a2;
  v5[3] = 0LL;
  *((_BYTE *)v5 + 32) = 0;
  *((void *)this + 2) = v5;
  return this;
}

double dyld4::FileManager::fileRecordForPath@<D0>( dyld4::FileManager *this@<X0>, lsl::Lock **a2@<X1>, const char *__s@<X2>, uint64_t a4@<X8>)
{
  if (__s) {
    unsigned int v6 = lsl::Allocator::strdup(a2, __s);
  }
  else {
    unsigned int v6 = 0LL;
  }
  *(void *)a4 = this;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(void *)(a4 + 48) = 0LL;
  *(void *)(a4 + 56) = 0LL;
  *(void *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v6;
  *(void *)&double result = 0x1FFFFFFFFLL;
  *(void *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(_BYTE *)(a4 + 74) = 1;
  return result;
}

double dyld4::FileManager::fileRecordForVolumeUUIDAndObjID@<D0>( dyld4::FileManager *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)a4 = this;
  *(void *)(a4 + 8) = a3;
  *(void *)(a4 + 16) = 0LL;
  *(_OWORD *)(a4 + 24) = *(_OWORD *)a2;
  *(void *)(a4 + 48) = 0LL;
  *(void *)(a4 + 56) = 0LL;
  *(void *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *(void *)&double result = 0x1FFFFFFFFLL;
  *(void *)(a4 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a4 + 72) = 0;
  *(_BYTE *)(a4 + 74) = 1;
  return result;
}

dyld4::FileRecord *dyld4::FileManager::fileRecordForVolumeDevIDAndObjID@<X0>( dyld4::FileManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, dyld4::FileRecord *a4@<X8>)
{
  return dyld4::FileRecord::FileRecord(a4, this, a3, a2, 0LL);
}

void dyld4::FileManager::reloadFSInfos(dyld4::FileManager *this)
{
  uint64_t v2 = lsl::AllocatorLayout::minSize(this);
  __chkstk_darwin(v2, v3, v4, v5, v6, v7, v8, v9, v35);
  uint64_t v11 = (lsl::Allocator *)((char *)&v35 - (((unint64_t)v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v12 = (char *)lsl::AllocatorLayout::minSize(v10);
  uint64_t v15 = (lsl::Lock **)lsl::Allocator::stackAllocatorInternal(v11, v12, v13, v14);
  int v16 = dyld4::SyscallDelegate::getfsstat(*(dyld4::SyscallDelegate **)this, 0LL, 0, 2);
  if (v16 != -1)
  {
    LODWORD(v17) = v16;
    while (1)
    {
      uint64_t v18 = (statfs *)lsl::Allocator::malloc(v15, 2168 * (int)v17);
      lsl::Allocator::free(v15, v18);
      LODWORD(v17) = dyld4::SyscallDelegate::getfsstat(*(dyld4::SyscallDelegate **)this, 0LL, 0, 2);
      if ((_DWORD)v17 == -1) {
        goto LABEL_20;
      }
    }

    if ((int)v17 >= 1)
    {
      int v40 = &v60[8];
      uint64_t v38 = (uint64_t *)&v66[8];
      int v39 = v59;
      uint64_t v36 = (_OWORD *)((char *)v57 + 8);
      uint64_t v37 = &v42;
      _X22 = v18;
      uint64_t v17 = v17;
      do
      {
        __asm { PRFM            #0, [X22,#0x1998] }

        uint64_t v25 = _X22->f_fsid.val[0];
        uint64_t v26 = *((void *)this + 2);
        pid_t v27 = v40;
        *int v40 = 0LL;
        v27[1] = 0LL;
        *(void *)int v60 = v25;
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find( v26,  (unint64_t *)v60,  (uint64_t)&v43);
        uint64_t v54 = v43;
        v57[2] = v48;
        v57[3] = v49;
        v57[4] = v50;
        uint64_t v58 = v51;
        __int128 v55 = v44;
        __int128 v56 = v45;
        v57[0] = v46;
        v57[1] = v47;
        uint64_t v28 = *(void *)v52;
        uint64_t v29 = v39;
        *(void *)(v39 + 7) = *(void *)&v52[7];
        void *v29 = v28;
        v59[15] = v53;
        uint64_t v30 = *((void *)this + 2);
        __int128 v65 = 0u;
        memset(v66, 0, 23);
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        memset(v60, 0, sizeof(v60));
        uint64_t v43 = v30;
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        __int128 v50 = 0u;
        uint64_t v51 = 0LL;
        uint64_t v31 = *v38;
        *(void *)&v52[7] = *(uint64_t *)((char *)v38 + 7);
        *(void *)uint64_t v52 = v31;
        char v53 = 0;
        if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v54,  (uint64_t)&v43))
        {
          if ((_X22->f_flags & 0x4000) != 0)
          {
            *(_DWORD *)int v60 = 5;
            *(_DWORD *)&v60[12] = 0;
            *(void *)&v60[16] = 0LL;
            *(void *)&v60[4] = 0x8006000000000006LL;
            if (!dyld4::SyscallDelegate::getattrlist( *(dyld4::SyscallDelegate **)this,  _X22->f_mntonname,  (attrlist *)v60,  &v54,  0x40uLL,  0)
              && (BYTE8(v55) & 1) != 0)
            {
              uint64_t v32 = *((void *)this + 2);
              uint64_t v41 = v25;
              *(_OWORD *)uint64_t v37 = *v36;
            }

            else
            {
              uint64_t v32 = *((void *)this + 2);
              int v34 = v37;
              *uint64_t v37 = 0LL;
              v34[1] = 0LL;
              uint64_t v41 = v25;
            }

            uint64_t v33 = &v41;
          }

          else
          {
            uint64_t v32 = *((void *)this + 2);
            __int128 v55 = 0uLL;
            uint64_t v54 = v25;
            uint64_t v33 = &v54;
          }

          lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert( v32,  (uint64_t)v33,  (uint64_t)&v43);
        }

        ++_X22;
        --v17;
      }

      while (v17);
    }

    lsl::Allocator::free(v15, v18);
  }

double lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v9 = *(void *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 8);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator( (uint64_t)v22,  a1,  &v9);
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal( a1,  (uint64_t)v22,  &v9,  (uint64_t)&v11);
  uint64_t v5 = v11;
  *(_OWORD *)(a3 + 72) = v16;
  *(_OWORD *)(a3 + 88) = v17;
  *(_OWORD *)(a3 + 104) = v18;
  *(_OWORD *)(a3 + 8) = v12;
  *(_OWORD *)(a3 + 24) = v13;
  *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v14;
  double result = *(double *)&v15;
  *(_OWORD *)(a3 + 56) = v15;
  *(void *)(a3 + 135) = *(void *)&v20[7];
  uint64_t v7 = *(void *)v20;
  *(void *)(a3 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v19;
  *(void *)(a3 + 128) = v7;
  __int16 v8 = v21;
  *(void *)a3 = v5;
  *(_WORD *)(a3 + 143) = v8;
  return result;
}

uint64_t dyld4::FileManager::uuidForFileSystem(dyld4::FileManager *this, unsigned int a2)
{
  uint64_t v3 = *((void *)this + 2);
  *(void *)&v23[8] = 0LL;
  *(void *)&void v23[16] = 0LL;
  unint64_t v4 = a2;
  *(void *)uint64_t v23 = a2;
  lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find( v3,  (unint64_t *)v23,  (uint64_t)&v12);
  v26[4] = v17;
  v26[5] = v18;
  v26[6] = v19;
  uint64_t v25 = v12;
  v26[0] = v13;
  v26[1] = v14;
  _OWORD v26[2] = v15;
  v26[3] = v16;
  *(void *)&void v28[7] = *(void *)&v21[7];
  uint64_t v27 = v20;
  *(void *)uint64_t v28 = *(void *)v21;
  unsigned __int8 v29 = v22;
  uint64_t v5 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v5;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v20 = 0LL;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v25,  (uint64_t)&v12))
  {
    dyld4::FileManager::reloadFSInfos(this);
    uint64_t v6 = *((void *)this + 2);
    uint64_t v31 = 0LL;
    uint64_t v32 = 0LL;
    unint64_t v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find( v6,  &v30,  (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(void *)uint64_t v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(void *)&v23[135] = *(void *)&v21[7];
    *(void *)&v23[120] = v20;
    *(void *)&v23[128] = *(void *)v21;
    unsigned __int8 v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap( &v25,  (uint64_t *)v23);
  }

  uint64_t v7 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v7;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v20 = 0LL;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v25,  (uint64_t)&v12))
  {
    uint64_t v8 = *((void *)this + 2);
    *(void *)&v23[8] = 0LL;
    *(void *)&void v23[16] = 0LL;
    *(void *)uint64_t v23 = v4;
    lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::insert(v8, (uint64_t)v23, (uint64_t)&v12);
    uint64_t v9 = *((void *)this + 2);
    uint64_t v31 = 0LL;
    uint64_t v32 = 0LL;
    unint64_t v30 = v4;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find( v9,  &v30,  (uint64_t)&v12);
    *(_OWORD *)&v23[72] = v17;
    *(_OWORD *)&v23[88] = v18;
    *(_OWORD *)&v23[104] = v19;
    *(void *)uint64_t v23 = v12;
    *(_OWORD *)&v23[8] = v13;
    *(_OWORD *)&v23[24] = v14;
    *(_OWORD *)&v23[40] = v15;
    *(_OWORD *)&v23[56] = v16;
    *(void *)&v23[135] = *(void *)&v21[7];
    *(void *)&v23[120] = v20;
    *(void *)&v23[128] = *(void *)v21;
    unsigned __int8 v24 = v22;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap( &v25,  (uint64_t *)v23);
  }

  uint64_t v10 = *((void *)this + 2);
  memset(v23, 0, 135);
  uint64_t v12 = v10;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v20 = 0LL;
  memset(v21, 0, sizeof(v21));
  unsigned __int8 v22 = 0;
  if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v25,  (uint64_t)&v12)) {
    dyld4::FileManager::uuidForFileSystem();
  }
  return *(void *)(*((void *)v26 + v29 - 1) + 24LL * v28[v29 - 1] + 8);
}

uint64_t dyld4::FileManager::fsidForUUID(dyld4::FileManager *this, const UUID *a2, uint64_t a3)
{
  uint64_t v5 = *((void *)this + 2);
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  memset(v60, 0, sizeof(v60));
  uint64_t v52 = v5;
  uint64_t v6 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)&v52,  (uint64_t)a2,  a3);
  uint64_t v7 = *(void *)v6;
  __int128 v8 = *(_OWORD *)(v6 + 104);
  __int128 v9 = *(_OWORD *)(v6 + 88);
  uint64_t v10 = *(void *)(v6 + 120);
  uint64_t v11 = *(void *)(v6 + 128);
  __int128 v46 = *(_OWORD *)(v6 + 72);
  __int128 v47 = v9;
  __int128 v48 = v8;
  uint64_t v49 = v10;
  __int128 v12 = *(_OWORD *)(v6 + 56);
  __int128 v13 = *(_OWORD *)(v6 + 40);
  __int128 v14 = *(_OWORD *)(v6 + 24);
  __int128 v42 = *(_OWORD *)(v6 + 8);
  __int128 v43 = v14;
  __int128 v44 = v13;
  __int128 v45 = v12;
  *(void *)&v50[7] = *(void *)(v6 + 135);
  *(void *)__int128 v50 = v11;
  LOBYTE(v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v6 + 143);
  uint64_t v41 = v7;
  unsigned __int8 v51 = v10;
  __int128 v67 = 0u;
  memset(v68, 0, sizeof(v68));
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  uint64_t v52 = v5;
  memset(v60, 0, sizeof(v60));
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v41,  (uint64_t)&v52))
  {
    while (1)
    {
      uint64_t v17 = 0LL;
      uint64_t v18 = *((void *)&v42 + v51 - 1) + 24LL * v50[v51 - 1];
      do
      {
        int v19 = *(unsigned __int8 *)(v18 + 8 + v17);
        int v20 = (*a2)[v17];
      }

      while (v19 == v20 && v17++ != 15);
      if (v19 == v20) {
        break;
      }
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)&v41,  v15,  v16);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v41,  (uint64_t)&v52)) {
        goto LABEL_10;
      }
    }
  }

  else
  {
LABEL_10:
    dyld4::FileManager::reloadFSInfos(this);
    uint64_t v22 = *((void *)this + 2);
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    memset(v60, 0, sizeof(v60));
    uint64_t v52 = v22;
    uint64_t v25 = lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)&v52,  v23,  v24);
    uint64_t v26 = *(void *)v25;
    __int128 v27 = *(_OWORD *)(v25 + 104);
    __int128 v28 = *(_OWORD *)(v25 + 88);
    uint64_t v29 = *(void *)(v25 + 120);
    uint64_t v30 = *(void *)(v25 + 128);
    __int128 v46 = *(_OWORD *)(v25 + 72);
    __int128 v47 = v28;
    __int128 v48 = v27;
    uint64_t v49 = v29;
    __int128 v31 = *(_OWORD *)(v25 + 56);
    __int128 v32 = *(_OWORD *)(v25 + 40);
    __int128 v33 = *(_OWORD *)(v25 + 24);
    __int128 v42 = *(_OWORD *)(v25 + 8);
    __int128 v43 = v33;
    __int128 v44 = v32;
    __int128 v45 = v31;
    *(void *)&v50[7] = *(void *)(v25 + 135);
    *(void *)__int128 v50 = v30;
    LOBYTE(v29) = *(_BYTE *)(v25 + 143);
    uint64_t v41 = v26;
    unsigned __int8 v51 = v29;
    __int128 v67 = 0u;
    memset(v68, 0, sizeof(v68));
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    uint64_t v52 = v22;
    memset(v60, 0, sizeof(v60));
    if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v41,  (uint64_t)&v52)) {
      return 0LL;
    }
    while (1)
    {
      uint64_t v36 = 0LL;
      uint64_t v18 = *((void *)&v42 + v51 - 1) + 24LL * v50[v51 - 1];
      do
      {
        int v37 = *(unsigned __int8 *)(v18 + 8 + v36);
        int v38 = (*a2)[v36];
      }

      while (v37 == v38 && v36++ != 15);
      if (v37 == v38) {
        break;
      }
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)&v41,  v34,  v35);
      if (!lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v41,  (uint64_t)&v52)) {
        return 0LL;
      }
    }
  }

  return *(void *)v18;
}

char *dyld4::FileManager::getPath@<X0>( char *this@<X0>, const UUID *a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t v5 = this;
  uint64_t v7 = 0LL;
  do
  {
    int v8 = (*a2)[v7];
    if ((*a2)[v7]) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = v7 == 15;
    }
    ++v7;
  }

  while (!v9);
  if (v8)
  {
    uint64_t v10 = dyld4::FileManager::fsidForUUID((dyld4::FileManager *)this, a2, a3);
    return dyld4::FileManager::getPath(v5, (fsid_t)v10, a3, a4);
  }

  else
  {
    *a4 = 0LL;
  }

  return this;
}

char *dyld4::FileManager::getPath@<X0>(char *this@<X0>, fsid_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  if (*(void *)&a2 && a3)
  {
    uint64_t v6 = this;
    if (dyld4::SyscallDelegate::fsgetpath(*(dyld4::SyscallDelegate **)this, __s, 0x400uLL, a2, a3) == -1) {
      this = 0LL;
    }
    else {
      this = lsl::Allocator::strdup(*((lsl::Lock ***)v6 + 1), __s);
    }
    *a4 = this;
  }

  else
  {
    *a4 = 0LL;
  }

  return this;
}

dyld4::FileRecord *dyld4::FileRecord::FileRecord( dyld4::FileRecord *this, dyld4::FileManager *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = dyld4::FileManager::uuidForFileSystem(a2, a4);
  *((void *)this + 4) = v7;
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  *((void *)this + 7) = a5;
  *((void *)this + 8) = 0x1FFFFFFFFLL;
  *((_WORD *)this + 36) = 0;
  *((_BYTE *)this + 74) = 1;
  if (*((void *)this + 1) && a5 && *((void *)this + 2)) {
    *((_DWORD *)this + 17) = 0;
  }
  return this;
}

__n128 dyld4::FileRecord::swap(dyld4::FileRecord *this, dyld4::FileRecord *a2)
{
  __int128 v4 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)a2 + 24) = v4;
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v5;
  uint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v6;
  uint64_t v7 = *((void *)this + 5);
  *((void *)this + 5) = 0LL;
  int v8 = (os_unfair_lock_s *)*((void *)a2 + 5);
  if (a2 == this)
  {
    *((void *)a2 + 5) = v7;
    if (v8) {
      lsl::Allocator::freeObject(v8, a2);
    }
  }

  else
  {
    *((void *)this + 5) = v8;
    *((void *)a2 + 5) = v7;
  }

  uint64_t v9 = *(void *)this;
  *(void *)this = *(void *)a2;
  *(void *)a2 = v9;
  __n128 result = *((__n128 *)a2 + 3);
  __int128 v11 = *((_OWORD *)this + 3);
  *((__n128 *)this + 3) = result;
  *((_OWORD *)a2 + 3) = v11;
  LODWORD(v9) = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)a2 + 16) = v9;
  LODWORD(v9) = *((_DWORD *)this + 17);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)a2 + 17) = v9;
  LOWORD(v9) = *((_WORD *)this + 36);
  *((_WORD *)this + 36) = *((_WORD *)a2 + 36);
  *((_WORD *)a2 + 36) = v9;
  LOBYTE(v9) = *((_BYTE *)this + 74);
  *((_BYTE *)this + 74) = *((_BYTE *)a2 + 74);
  *((_BYTE *)a2 + 74) = v9;
  return result;
}

uint64_t dyld4::FileRecord::FileRecord(uint64_t a1, dyld4::FileRecord *a2)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 64) = 0x1FFFFFFFFLL;
  *(_WORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 74) = 1;
  dyld4::FileRecord::swap((dyld4::FileRecord *)a1, a2);
  return a1;
}

dyld4::FileRecord *dyld4::FileRecord::operator=(dyld4::FileRecord *a1, dyld4::FileRecord *a2)
{
  return a1;
}

void dyld4::FileRecord::~FileRecord(dyld4::FileRecord *this, void *a2)
{
  int v3 = *((_DWORD *)this + 16);
  if (v3 != -1)
  {
    close(v3);
    *((_DWORD *)this + 16) = -1;
  }

  __int128 v4 = (os_unfair_lock_s *)*((void *)this + 5);
  if (v4) {
    lsl::Allocator::freeObject(v4, a2);
  }
}

uint64_t dyld4::FileRecord::getPath(dyld4::FileRecord *this)
{
  if (!*((void *)this + 5))
  {
    fsid_t v2 = (fsid_t)*((void *)this + 2);
    if (v2) {
      dyld4::FileManager::getPath(*(char **)this, v2, *((void *)this + 1), &v6);
    }
    else {
      dyld4::FileManager::getPath(*(char **)this, (const UUID *)((char *)this + 24), *((void *)this + 1), &v6);
    }
    __int128 v4 = (os_unfair_lock_s *)*((void *)this + 5);
    *((void *)this + 5) = v6;
    if (v4) {
      lsl::Allocator::freeObject(v4, v3);
    }
  }

  return *((void *)this + 5);
}

BOOL dyld4::FileRecord::exists(dyld4::FileRecord *this)
{
  return *((_DWORD *)this + 17) == 0;
}

uint64_t dyld4::FileRecord::stat(uint64_t this)
{
  if (*(_DWORD *)(this + 68) == 1)
  {
    uint64_t v1 = this;
    int v2 = *(_DWORD *)(this + 64);
    if (v2 == -1)
    {
      Path = (const char *)dyld4::FileRecord::getPath((dyld4::FileRecord *)v1);
      this = stat64(Path, &v9);
    }

    else
    {
      this = fstat64(v2, &v9);
    }

    *(_DWORD *)(v1 + 68) = this;
    if (!(_DWORD)this)
    {
      __darwin_time_t tv_sec = v9.st_mtimespec.tv_sec;
      *(void *)(v1 + 48) = v9.st_size;
      *(void *)(v1 + 56) = tv_sec;
      *(_WORD *)(v1 + 72) = v9.st_mode;
      if (!*(void *)(v1 + 8))
      {
        uint64_t v5 = 24LL;
        do
        {
          int v6 = *(unsigned __int8 *)(v1 + v5);
          if (*(_BYTE *)(v1 + v5)) {
            break;
          }
        }

        while (v5++ != 39);
        if (!v6)
        {
          *(void *)(v1 + 8) = v9.st_ino;
          this = dyld4::FileManager::uuidForFileSystem(*(dyld4::FileManager **)v1, v9.st_dev);
          *(void *)(v1 + 24) = this;
          *(void *)(v1 + 32) = v8;
        }
      }
    }
  }

  return this;
}

uint64_t dyld4::FileRecord::objectID(dyld4::FileRecord *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((void *)this + 1);
  }

  return result;
}

uint64_t dyld4::FileRecord::mtime(dyld4::FileRecord *this)
{
  uint64_t result = *((void *)this + 7);
  if (!result)
  {
    dyld4::FileRecord::stat((uint64_t)this);
    return *((void *)this + 7);
  }

  return result;
}

BOOL dyld4::FileRecord::persistent(dyld4::FileRecord *this)
{
  uint64_t v1 = 0LL;
  int v2 = (char *)this + 24;
  do
  {
    int v3 = v2[v1];
    if (v2[v1]) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = v1 == 15;
    }
    ++v1;
  }

  while (!v4);
  return v3 && *((void *)this + 1) != 0LL;
}

uint64_t dyld4::FileRecord::volume(dyld4::FileRecord *this)
{
  return (uint64_t)this + 24;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 143);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 143);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 143);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 143);
  }
  if ((_DWORD)v4)
  {
    uint64_t v5 = (unsigned __int8 *)(a1 + 128);
    int v6 = (unsigned __int8 *)(a2 + 128);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }

    if (v10) {
      return 1LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0LL;
    }
    else {
      return v12;
    }
  }

uint64_t *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::swap( uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = *a2;
  *a2 = v2;
  for (uint64_t i = 1LL; i != 16; ++i)
  {
    uint64_t v4 = result[i];
    result[i] = a2[i];
    a2[i] = v4;
  }

  uint64_t v5 = 0LL;
  int v6 = result + 16;
  unsigned int v7 = a2 + 16;
  do
  {
    char v8 = *((_BYTE *)v6 + v5);
    *((_BYTE *)v6 + v5) = *((_BYTE *)v7 + v5);
    *((_BYTE *)v7 + v5++) = v8;
  }

  while (v5 != 15);
  char v9 = *((_BYTE *)result + 143);
  *((_BYTE *)result + 143) = *((_BYTE *)a2 + 143);
  *((_BYTE *)a2 + 143) = v9;
  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(result + 143);
  uint64_t v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 143))
  {
    int v5 = *((unsigned __int8 *)v4 + 32);
    uint64_t v6 = result + 128;
    ++*(_BYTE *)(result + 128 + (v3 - 1));
    if (v3 == v5)
    {
      uint64_t v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(void *)(result
                                                                                           + 8
                                                                                           + 8LL
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 240LL) & 0x7F))
            break;
          *(_BYTE *)(result + 143) = v7 + ~(_BYTE)i;
        }
      }
    }

    else
    {
      int v15 = *(unsigned __int8 *)(result + 143);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        uint64_t v16 = result + 8;
        do
        {
          uint64_t v17 = *(void *)(v16 + 8 * (v15 - 1LL));
          if (*(char *)(v17 + 240) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          *(void *)(v16 + 8LL * v15) = *(void *)(v17
                                                                    + 8LL
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1LL)
                                                                    + 168);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 143) + 1;
          *(_BYTE *)(result + 143) = v15;
        }

        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 143) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 128 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
        uint64_t v12 = *(unsigned __int8 *)(result + 143);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 240) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 168);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 143) = v10;
      }

      while (v13 > v10);
    }
  }

  return result;
}

double lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::find@<D0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = a1;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  uint64_t v22 = 0LL;
  if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( (uint64_t)&v23,  (uint64_t)&v13)
    && (unsigned __int8 v6 = v32, *a2 >= *(void *)(*((void *)v24 + v32 - 1) + 24LL * v31[v32 - 1])))
  {
    __int128 v8 = v28;
    *(_OWORD *)(a3 + 72) = v27;
    *(_OWORD *)(a3 + 88) = v8;
    *(_OWORD *)(a3 + 104) = v29;
    __int128 v9 = v24[1];
    *(_OWORD *)(a3 + 8) = v24[0];
    *(_OWORD *)(a3 + 24) = v9;
    double result = *(double *)&v25;
    __int128 v10 = v26;
    *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v25;
    *(void *)a3 = v23;
    uint64_t v11 = v30;
    *(_OWORD *)(a3 + 56) = v10;
    *(void *)(a3 + 135) = *(void *)&v31[7];
    uint64_t v12 = *(void *)v31;
    *(void *)(a3 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v11;
    *(void *)(a3 + 128) = v12;
    *(_BYTE *)(a3 + 143) = v6;
  }

  else
  {
    *(void *)a3 = a1;
    double result = 0.0;
    *(_OWORD *)(a3 + 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 88) = 0u;
    *(_OWORD *)(a3 + 104) = 0u;
    *(_OWORD *)(a3 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *(void *)(a3 + 136) = 0LL;
  }

  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::const_iterator( uint64_t result, uint64_t a2, unint64_t *a3)
{
  *(void *)double result = a2;
  *(_OWORD *)(result + 8) = 0u;
  uint64_t v3 = result + 8;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(_OWORD *)(result + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(result + 136) = 0LL;
  if (*(_BYTE *)(a2 + 32))
  {
    unint64_t v4 = 0LL;
    uint64_t v5 = *(void *)a2;
    uint64_t v6 = result + 128;
    do
    {
      *(void *)(v3 + 8 * v4) = v5;
      unint64_t v7 = *(_BYTE *)(v5 + 240) & 0x7F;
      if ((*(_BYTE *)(v5 + 240) & 0x7F) != 0)
      {
        __int128 v8 = (void *)v5;
        do
        {
          unint64_t v9 = v7 >> 1;
          __int128 v10 = &v8[3 * (v7 >> 1)];
          unint64_t v12 = *v10;
          uint64_t v11 = v10 + 3;
          v7 += ~(v7 >> 1);
          if (v12 < *a3) {
            __int128 v8 = v11;
          }
          else {
            unint64_t v7 = v9;
          }
        }

        while (v7);
      }

      else
      {
        __int128 v8 = (void *)(v5 + 24LL * (*(_BYTE *)(v5 + 240) & 0x7F));
      }

      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v8 - v5) >> 3);
      *(_BYTE *)(v6 + v4) = v13;
      uint64_t v14 = *(void *)(v3 + 8 * v4);
      if ((*(_BYTE *)(v14 + 240) & 0x7F) != v13
        && *(void *)(v14 + 24LL * v13) < *a3)
      {
        *(_BYTE *)(result + 143) = v4 + 1;
        return result;
      }

      unint64_t v15 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v4 + 1 != (_DWORD)v15)
      {
        if ((*(_BYTE *)(v14 + 240) & 0x80) != 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  (uint64_t)a3);
        }
        uint64_t v5 = *(void *)(v14 + 8LL * v13 + 168);
      }

      ++v4;
    }

    while (v4 < v15);
    for (*(_BYTE *)(result + 143) = v15; (_BYTE)v15; *(_BYTE *)(result + 143) = v15)
    {
      if (*(_BYTE *)(v6 + v15 - 1) != (*(_BYTE *)(*(void *)(result
                                                                                            + 8LL * v15)
                                                                                + 240LL) & 0x7F))
        break;
      LOBYTE(v15) = v15 - 1;
    }
  }

  return result;
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::insert_internal( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v26 = a1;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    uint64_t v35 = 0LL;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( a2,  (uint64_t)&v26))
    {
      uint64_t v8 = *(unsigned __int8 *)(a2 + 143);
      if (*a3 >= *(void *)(*(void *)(a2 + 8 + 8 * (v8 - 1)) + 24LL * *(unsigned __int8 *)(a2 + 128 + v8 - 1)))
      {
        char v15 = 0;
        __int128 v21 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a4 + 88) = v21;
        *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
        __int128 v22 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a4 + 24) = v22;
        __int128 v23 = *(_OWORD *)(a2 + 56);
        *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
        *(void *)a4 = *(void *)a2;
        *(void *)(a4 + 135) = *(void *)(a2 + 135);
        uint64_t v24 = *(void *)(a2 + 120);
        *(_OWORD *)(a4 + 56) = v23;
        uint64_t v25 = *(void *)(a2 + 128);
        *(void *)(a4 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v24;
        *(void *)(a4 + 128) = v25;
        *(_BYTE *)(a4 + 143) = v8;
        goto LABEL_11;
      }
    }

    uint64_t v26 = a1;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    uint64_t v35 = 0LL;
    if (lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator<=>( a2,  (uint64_t)&v26)
      && *(unsigned __int8 *)(a2 + 143) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      uint64_t v11 = (uint64_t *)(a2 + 128);
      uint64_t v12 = *(unsigned __int8 *)(a2 + 143) - 1LL;
      unsigned __int8 v13 = *(_BYTE *)(a2 + 128 + v12);
    }

    else
    {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--( a2,  v9,  v10);
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion((unsigned __int8 *)a2);
      uint64_t v11 = (uint64_t *)(a2 + 128);
      uint64_t v18 = *(unsigned __int8 *)(a2 + 143) + a2 + 128;
      unsigned __int8 v13 = *(_BYTE *)(v18 - 1) + 1;
      *(_BYTE *)(v18 - 1) = v13;
      uint64_t v12 = *(unsigned __int8 *)(a2 + 143) - 1LL;
    }

    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert( *(void *)(a2 + 8 + 8 * v12),  v13,  (uint64_t)a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    uint64_t v19 = *(void *)(a2 + 120);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    uint64_t v20 = *v11;
    *(void *)(a4 + 135) = *(uint64_t *)((char *)v11 + 7);
    *(void *)(a4 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v19;
    *(void *)(a4 + 128) = v20;
    char v17 = *(_BYTE *)(a2 + 143);
    char v15 = 1;
  }

  else
  {
    uint64_t v14 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v14 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0x80;
    *(_OWORD *)uint64_t v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((_OWORD *)v14 + 2) = 0u;
    *((_OWORD *)v14 + 3) = 0u;
    *((_OWORD *)v14 + 4) = 0u;
    *((_OWORD *)v14 + 5) = 0u;
    *((_OWORD *)v14 + 6) = 0u;
    *((_OWORD *)v14 + 7) = 0u;
    *((_OWORD *)v14 + 8) = 0u;
    *((_OWORD *)v14 + 9) = 0u;
    *((_OWORD *)v14 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)v14 + 11) = 0u;
    *((_OWORD *)v14 + 12) = 0u;
    *((_OWORD *)v14 + 13) = 0u;
    *((_OWORD *)v14 + 14) = 0u;
    *(void *)a1 = v14;
    char v15 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v14;
    *(_BYTE *)(a2 + 143) = 1;
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert( (uint64_t)v14,  0,  (uint64_t)a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(void *)(a4 + 135) = *(void *)(a2 + 135);
    uint64_t v16 = *(void *)(a2 + 128);
    *(void *)(a4 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 120);
    *(void *)(a4 + 128) = v16;
    char v17 = *(_BYTE *)(a2 + 143);
  }

  *(_BYTE *)(a4 + 143) = v17;
LABEL_11:
  *(_BYTE *)(a4 + 144) = v15;
}

__n128 lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert( uint64_t a1, unsigned int a2, uint64_t a3)
{
  char v3 = *(_BYTE *)(a1 + 240);
  char v4 = v3;
  uint64_t v5 = v3 & 0x7F;
  if (v3 >= 0) {
    int v6 = 7;
  }
  else {
    int v6 = 10;
  }
  if ((_DWORD)v5 == v6) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if (v6 == a2) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert();
  }
  if ((_DWORD)v5 != a2)
  {
    uint64_t v7 = 3 * v5;
    uint64_t v8 = a1 + 8 * v7;
    uint64_t v9 = 24LL * a2 - 8 * v7;
    uint64_t v10 = v8;
    do
    {
      uint64_t v11 = *(void *)(v10 - 24);
      v10 -= 24LL;
      *(void *)uint64_t v8 = v11;
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(v8 - 16);
      uint64_t v8 = v10;
      v9 += 24LL;
    }

    while (v9);
    char v4 = *(_BYTE *)(a1 + 240);
  }

  *(_BYTE *)(a1 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v4 + 1;
  *(void *)(a1 + 24LL * a2) = *(void *)a3;
  __n128 result = *(__n128 *)(a3 + 8);
  *(__n128 *)(a1 + 24LL * a2 + 8) = result;
  return result;
}

uint64_t lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator--( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 143);
  char v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 143))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      uint64_t v5 = result + 128;
      uint64_t v6 = v3 - 1;
      uint64_t v7 = (char *)(result + 128 + v3 - 1);
      char v8 = *v7;
      if (!*(_BYTE *)(result + 128 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(v3) = v3 - 1;
            *(_BYTE *)(result + 143) = v3;
            uint64_t v6 = v3 - 1LL;
            char v8 = *(_BYTE *)(v5 + v6);
          }

          while (!v8);
        }

        uint64_t v7 = (char *)(v5 + v6);
      }
    }

    else
    {
      uint64_t v16 = result + 8;
      uint64_t v17 = result + 128;
      do
      {
        uint64_t v18 = *(void *)(v16 + 8 * (v3 - 1LL));
        if (*(char *)(v18 + 240) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
        }
        uint64_t v19 = *(void *)(v18 + 8LL * *(unsigned __int8 *)(v17 + v3 - 1LL) + 168);
        *(void *)(v16 + 8LL * v3) = v19;
        *(_BYTE *)(v17 + v3) = *(_BYTE *)(v19 + 240) & 0x7F;
        LOBYTE(v3) = *(_BYTE *)(result + 143) + 1;
        *(_BYTE *)(result + 143) = v3;
      }

      while (*((unsigned __int8 *)v4 + 32) != v3);
      uint64_t v20 = v17 + v3;
      char v21 = *(_BYTE *)(v20 - 1);
      uint64_t v7 = (char *)(v20 - 1);
      char v8 = v21;
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 143) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 128 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v9 + 240) & 0x7F;
        uint64_t v12 = *(unsigned __int8 *)(result + 143);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 240) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 8LL * *(unsigned __int8 *)(v14 + 240) + 168);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 143) = v10;
      }

      while (v13 > v10);
      uint64_t v15 = v10 - 1LL;
    }

    else
    {
      uint64_t v15 = -1LL;
    }

    uint64_t v7 = (char *)(result + v15 + 128);
    char v8 = *v7;
  }

  *uint64_t v7 = v8 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion( unsigned __int8 *result)
{
  uint64_t v1 = result[143];
  uint64_t v2 = result;
  uint64_t v3 = result + 8;
  else {
    int v4 = 10;
  }
  if ((*(_BYTE *)(*(void *)&result[8 * v1] + 240LL) & 0x7F) == v4)
  {
    if (!result[143]) {
      goto LABEL_15;
    }
    uint64_t v5 = 0LL;
    unsigned int v6 = 0;
    do
    {
      else {
        int v7 = 10;
      }
      if ((*(_BYTE *)(v3[v5] + 240LL) & 0x7F) != v7) {
        unsigned int v6 = v5;
      }
      ++v5;
    }

    while (v1 != v5);
    if (!v6)
    {
LABEL_15:
      else {
        int v8 = 10;
      }
      if ((*(_BYTE *)(*v3 + 240LL) & 0x7F) == v8)
      {
        __n128 result = (unsigned __int8 *)lsl::Allocator::aligned_alloc( *(lsl::Lock ***)(*(void *)result + 8LL),  0x100uLL,  0x100uLL);
        uint64_t v9 = **(void **)v2;
        result[240] = 0;
        *(_OWORD *)__n128 result = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((void *)result + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
        *((void *)result + 21) = v9;
        **(void **)uint64_t v2 = result;
        if (v2[143] && (__n128 result = (unsigned __int8 *)memmove(v2 + 129, v2 + 128, v2[143]), v2[143]))
        {
          __n128 result = (unsigned __int8 *)memmove(v3 + 1, v3, 8LL * v2[143]);
          LOBYTE(v1) = v2[143] + 1;
        }

        else
        {
          LOBYTE(v1) = 1;
        }

        unsigned int v6 = 0;
        v2[128] = 0;
        unsigned __int8 v10 = *(uint64_t **)v2;
        *((void *)v2 + 1) = **(void **)v2;
        ++*((_BYTE *)v10 + 32);
        v2[143] = v1;
      }

      else
      {
        unsigned int v6 = 0;
      }
    }

    if (v6 + 1 < v1)
    {
      uint64_t v11 = v2 + 128;
      uint64_t v12 = v6;
      do
      {
        int v13 = v12;
        __n128 result = (unsigned __int8 *)lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild( v3[v12],  v11[v12],  *(lsl::Lock ***)(*(void *)v2 + 8LL));
        uint64_t v16 = v3[v12];
        if (*(char *)(v16 + 240) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v14,  v15);
        }
        uint64_t v17 = v11[v12];
        uint64_t v18 = *(void *)(v16 + 8 * v17 + 168);
        unsigned int v19 = v2[v12 + 129];
        if (v19 > (*(_BYTE *)(v18 + 240) & 0x7Fu))
        {
          unsigned __int8 v20 = v17 + 1;
          v11[v12] = v20;
          v2[v12 + 129] = v19 + (~*(_BYTE *)(v18 + 240) | 0x80);
          uint64_t v21 = v3[v12];
          if (*(char *)(v21 + 240) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v14,  v15);
          }
          *(void *)&v2[8 * v12 + 16] = *(void *)(v21 + 8LL * v20 + 168);
        }

        ++v12;
      }

      while (v13 + 2 < v2[143]);
    }
  }

  return result;
}

char *lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild( uint64_t a1, uint64_t a2, lsl::Lock **this)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 240);
  uint64_t v5 = a1 + 168;
  uint64_t v6 = a1 + 168 + 8LL * a2;
  char v7 = *(_BYTE *)(*(void *)v6 + 240LL);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 7;
  }
  else {
    int v10 = 10;
  }
  if (v9 != v10) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 3LL;
  }
  else {
    uint64_t v13 = 5LL;
  }
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    uint64_t v14 = 3 * v3;
    uint64_t v15 = a1 + 24 * v3;
    uint64_t v16 = 24LL * a2 - 8 * v14;
    uint64_t v17 = v15;
    do
    {
      uint64_t v18 = *(void *)(v17 - 24);
      v17 -= 24LL;
      *(void *)uint64_t v15 = v18;
      *(_OWORD *)(v15 + 8) = *(_OWORD *)(v15 - 16);
      uint64_t v15 = v17;
      v16 += 24LL;
    }

    while (v16);
    a2 = *(unsigned __int8 *)(a1 + 240);
  }

  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( a1,  a2,  (uint64_t)this);
  }
  uint64_t v19 = v5 + 8LL * a2;
  if (v19 != v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v19 - v6);
    LOBYTE(a2) = *(_BYTE *)(a1 + 240);
  }

  *(_BYTE *)(a1 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2 + 1;
  uint64_t v20 = *(void *)v6 + 24LL * v13;
  *(void *)(a1 + 24LL * v12) = *(void *)v20;
  *(_OWORD *)(a1 + 24LL * v12 + 8) = *(_OWORD *)(v20 + 8);
  __n128 result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  uint64_t v24 = result;
  char v25 = *(_BYTE *)(*(void *)v6 + 240LL);
  result[240] = v25 & 0x80;
  if (v25 < 0)
  {
    __int128 v26 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  }

  else
  {
    *((void *)result + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
    __int128 v26 = 0uLL;
  }

  *((_OWORD *)result + 8) = v26;
  *((_OWORD *)result + 9) = v26;
  *((_OWORD *)result + 6) = v26;
  *((_OWORD *)result + 7) = v26;
  *((_OWORD *)result + 4) = v26;
  *((_OWORD *)result + 5) = v26;
  *((_OWORD *)result + 2) = v26;
  *((_OWORD *)result + 3) = v26;
  *(_OWORD *)__n128 result = v26;
  *((_OWORD *)result + 1) = v26;
  if (*(char *)(a1 + 240) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v22,  v23);
  }
  unsigned __int8 v27 = v9 + ~(_BYTE)v13;
  __int128 v28 = (uint64_t *)(v5 + 8 * v12);
  v28[1] = (uint64_t)result;
  uint64_t v29 = *v28;
  if (v27)
  {
    uint64_t v30 = v29 + 24LL * v13;
    uint64_t v31 = v30 + 24LL * v27 + 24;
    uint64_t v32 = v30 + 24;
    __int128 v33 = result;
    do
    {
      *(void *)__int128 v33 = *(void *)v32;
      *(_OWORD *)(v33 + 8) = *(_OWORD *)(v32 + 8);
      v32 += 24LL;
      v33 += 24;
    }

    while (v32 != v31);
    uint64_t v29 = *(void *)v6;
  }

  int v34 = *(char *)(v29 + 240);
  if ((v34 & 0x80000000) == 0)
  {
    if (result[240] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v22,  v23);
    }
    __n128 result = (char *)memmove(result + 168, (const void *)(v29 + 8 * v13 + 176), 8LL * v27 + 8);
    uint64_t v29 = *(void *)v6;
    LOBYTE(v34) = *(_BYTE *)(*(void *)v6 + 240LL);
  }

  *(_BYTE *)(v29 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v34 + ~v27;
  char v35 = v24[240] + v27;
  v24[240] = v35;
  if (v35 >= 0) {
    int v36 = 7;
  }
  else {
    int v36 = 10;
  }
  if ((v35 & 0x7F) == v36
    || ((char v37 = *(_BYTE *)(v29 + 240), v38 = v37, v39 = v37 & 0x7F, v38 >= 0) ? (v40 = 7) : (v40 = 10), v39 == v40))
  {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild();
  }

  return result;
}

void OUTLINED_FUNCTION_0_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

os_unfair_lock_s *lsl::Lock::lock(lsl::Lock *this)
{
  __n128 result = (os_unfair_lock_s *)*((void *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_not_owner(result);
    if (!*(void *)this) {
      lsl::Lock::lock();
    }
    return (os_unfair_lock_s *)(*(uint64_t (**)(void, void, void))(**(void **)(*(void *)this + 152LL)
                                                                                 + 184LL))( *(void *)(*(void *)this + 152LL),  *((void *)this + 1),  0LL);
  }

  return result;
}

os_unfair_lock_s *lsl::Lock::unlock(lsl::Lock *this)
{
  __n128 result = (os_unfair_lock_s *)*((void *)this + 1);
  if (result)
  {
    os_unfair_lock_assert_owner(result);
    if (!*(void *)this) {
      lsl::Lock::unlock();
    }
    return (os_unfair_lock_s *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)this + 152LL) + 192LL))( *(void *)(*(void *)this + 152LL),  *((void *)this + 1));
  }

  return result;
}

double lsl::MemoryManager::MemoryManager( lsl::MemoryManager *this, const char **a2, const char **a3, void *a4)
{
  *((void *)this + 8) = 0LL;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = a4;
  return result;
}

uint64_t lsl::MemoryManager::setDyldCacheAddr(uint64_t this, void *a2)
{
  *(void *)(this + 32) = a2;
  return this;
}

__n128 lsl::MemoryManager::adoptLock(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

os_unfair_lock_s *lsl::MemoryManager::lockGuard@<X0>(lsl::Lock *this@<X0>, lsl::Lock **a2@<X8>)
{
  *a2 = this;
  return lsl::Lock::lock(this);
}

mach_vm_address_t lsl::MemoryManager::vm_allocate_bytes(lsl::MemoryManager *this, uint64_t a2)
{
  kern_return_t v4;
  mach_vm_address_t address;
  char v7[1024];
  unint64_t v3 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000LL;
  vm_address_t address = 0x100000000LL;
  if (mach_vm_map(mach_task_self_, &address, v3, vm_page_mask, 1006632961, 0, 0LL, 0, 3, 7, 1u))
  {
    int v4 = vm_allocate(mach_task_self_, &address, v3, 1006632961);
    if (v4) {
      lsl::MemoryManager::vm_allocate_bytes(v7, v3, (uint64_t *)this, v4);
    }
  }

  return address;
}

size_t lsl::appendHexToString<unsigned long long>(char *a1, uint64_t a2)
{
  v6.val[0] = (int8x8_t)vsra_n_u8( (uint8x8_t)vbsl_s8( (int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0A0LL, (uint8x8_t)a2),  (int8x8_t)0x3030303030303030LL,  (int8x8_t)0x5757575757575757LL),  (uint8x8_t)a2,  4uLL);
  int8x8_t v2 = vand_s8((int8x8_t)a2, (int8x8_t)0xF0F0F0F0F0F0F0FLL);
  v6.val[1] = vadd_s8( vbsl_s8( (int8x8_t)vcgt_u8((uint8x8_t)0xA0A0A0A0A0A0A0ALL, (uint8x8_t)v2),  (int8x8_t)0x3030303030303030LL,  (int8x8_t)0x5757575757575757LL),  v2);
  unint64_t v3 = v5;
  vst2_s8(v3, v6);
  v3 += 16;
  *unint64_t v3 = 0;
  return strlcat(a1, v5, 0x400uLL);
}

size_t lsl::appendHexToString<int>(char *a1, __int32 a2, int8x8_t a3)
{
  a3.i32[0] = a2;
  int8x8_t v3 = vzip1_s8(a3, a3);
  int16x4_t v4 = (int16x4_t)vand_s8(v3, (int8x8_t)0xF000F000F000FLL);
  int8x8_t v6 = vtrn1_s8( (int8x8_t)vsra_n_u16( (uint16x4_t)vbsl_s8( (int8x8_t)vcgt_u16( (uint16x4_t)0xA000A000A000A0LL,  (uint16x4_t)(*(void *)&v3 & 0xFF00FF00FF00FFLL)),  (int8x8_t)0x30003000300030LL,  (int8x8_t)0x57005700570057LL),  (uint16x4_t)(*(void *)&v3 & 0xFF00FF00FF00FFLL),  4uLL),  (int8x8_t)vadd_s16( (int16x4_t)vbsl_s8( (int8x8_t)vcgt_u16((uint16x4_t)0xA000A000A000ALL, (uint16x4_t)v4),  (int8x8_t)0x30003000300030LL,  (int8x8_t)0x57005700570057LL),  v4));
  char v7 = 0;
  return strlcat(a1, (const char *)&v6, 0x400uLL);
}

uint64_t lsl::MemoryManager::writeProtect(lsl::MemoryManager *this, int a2)
{
  char v2 = a2;
  uint64_t v4 = *((void *)this + 4);
  if (v4 && *(_DWORD *)(v4 + 16) >= 0x205u && *(_DWORD *)(v4 + 516))
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = v4 - *(void *)(v4 + 224);
    if (a2) {
      vm_prot_t v7 = 1;
    }
    else {
      vm_prot_t v7 = 19;
    }
    int v8 = (vm_size_t *)(*(unsigned int *)(v4 + 512) + v4 + 8);
    do
    {
      vm_protect(mach_task_self_, v6 + *(v8 - 1), *v8, 0, v7);
      ++v5;
      v8 += 2;
    }

    while (v5 < *(unsigned int *)(v4 + 516));
  }

  uint64_t result = *((void *)this + 2);
  if (result)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000LL;
    _OWORD v10[2] = ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke;
    v10[3] = &__block_descriptor_tmp_7;
    char v11 = v2;
    return lsl::Allocator::forEachVMAllocatedBuffer(result, (uint64_t)v10);
  }

  return result;
}

uint64_t lsl::Allocator::forEachVMAllocatedBuffer(uint64_t result, uint64_t a2)
{
  char v2 = *(void **)(result + 16);
  if (v2)
  {
    while (1)
    {
      unint64_t v4 = v2[4];
      uint64_t v5 = v2[5];
LABEL_6:
      char v2 = (void *)v2[2];
      if (!v2) {
        return result;
      }
    }

    uint64_t v5 = v2[5];
LABEL_5:
    v6[0] = v2[4];
    v6[1] = v5;
    uint64_t result = (*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v6);
    goto LABEL_6;
  }

  return result;
}

uint64_t ___ZN3lsl13MemoryManager12writeProtectEb_block_invoke(uint64_t a1, vm_address_t *a2)
{
  if (*(_BYTE *)(a1 + 32)) {
    vm_prot_t v2 = 1;
  }
  else {
    vm_prot_t v2 = 3;
  }
  return vm_protect(mach_task_self_, *a2, a2[1], 0, v2);
}

lsl::Allocator::Pool *lsl::AllocatorLayout::init( lsl::AllocatorLayout *this, unint64_t a2, const char **a3, const char **a4, void *a5)
{
  if (a2 <= 0xAF) {
    lsl::AllocatorLayout::init();
  }
  *((void *)this + 8) = 0LL;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = a5;
  uint64_t result = lsl::Allocator::Pool::Pool( (unint64_t)this + 128,  (uint64_t)this + 80,  0LL,  (unint64_t)this,  a2,  (unint64_t *)this + 22,  a2 - 176);
  *((void *)this + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = this;
  *((void *)this + 11) = result;
  *((void *)this + 13) = 0LL;
  *((void *)this + 14) = 0LL;
  *((void *)this + 12) = result;
  *((_BYTE *)this + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  return result;
}

uint64_t lsl::AllocatorLayout::allocator(lsl::AllocatorLayout *this)
{
  return (uint64_t)this + 80;
}

_OWORD *lsl::Allocator::stackAllocatorInternal( lsl::Allocator *this, char *a2, const char **a3, const char **a4)
{
  if (!this) {
    lsl::Allocator::stackAllocatorInternal();
  }
  if (!a2) {
    lsl::Allocator::stackAllocatorInternal();
  }
  if ((unint64_t)a2 < 0xB0
    || (uint64_t v5 = (char *)(((unint64_t)this + 15) & 0xFFFFFFFFFFFFFFF0LL),
        uint64_t v6 = (char *)(v5 - (char *)this),
        v6 > a2 - 176))
  {
    lsl::Allocator::stackAllocatorInternal();
  }

  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  vm_prot_t v7 = v5 + 80;
  lsl::AllocatorLayout::init((lsl::AllocatorLayout *)v5, a2 - v6, a3, a4, 0LL);
  return v7;
}

void *lsl::Allocator::malloc(lsl::Lock **this, unint64_t a2)
{
  return lsl::Allocator::aligned_alloc(this, 0x10uLL, a2);
}

void *lsl::Allocator::aligned_alloc(lsl::Lock **this, unint64_t a2, unint64_t a3)
{
  uint64_t v6 = *this;
  lsl::Lock::lock(*this);
  uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] != 1LL) {
    lsl::Allocator::aligned_alloc();
  }
  uint64_t v8 = 16LL;
  if (a2 <= 0x10) {
    uint64_t v9 = 16LL;
  }
  else {
    uint64_t v9 = a2;
  }
  if (a3 > 0x10) {
    uint64_t v8 = a3;
  }
  uint64_t v10 = (v9 + v8 - 1) & -v9;
  char v11 = *this;
  *((void *)v11 + 5) = a2;
  *((void *)v11 + 6) = a3;
  *((void *)v11 + 7) = v9;
  *((void *)v11 + 8) = v10;
  uint64_t v12 = this[2];
  if (*((_BYTE *)this + 40)) {
    uint64_t v13 = lsl::Allocator::Pool::aligned_alloc_best_fit(v12, v9, v10);
  }
  else {
    uint64_t v13 = lsl::Allocator::Pool::aligned_alloc(v12, v9, v10);
  }
  uint64_t v14 = v13;
  if (!v13)
  {
    uint64_t v15 = (uint64_t)this[2];
    if (((v9 + v10 + 16463) & 0xFFFFFFFFFFFFC000LL) <= 0x40000) {
      unint64_t v16 = 0x40000LL;
    }
    else {
      unint64_t v16 = (v9 + v10 + 16463) & 0xFFFFFFFFFFFFC000LL;
    }
    unint64_t v17 = *(void *)(v15 + 8);
    bytes = (unint64_t *)lsl::MemoryManager::vm_allocate_bytes(*this, v16);
    lsl::Allocator::Pool::Pool(v17, (uint64_t)this, v15, (unint64_t)bytes, v19, bytes, v19);
    *(void *)(v15 + 8) = v17;
    uint64_t v20 = (lsl::Allocator::Pool *)*((void *)this[2] + 1);
    this[2] = v20;
    uint64_t v14 = lsl::Allocator::Pool::aligned_alloc(v20, v9, v10);
    if (!v14) {
      lsl::Allocator::aligned_alloc();
    }
  }

  this[3] = (lsl::Lock *)((char *)this[3] + v10);
  lsl::Lock::unlock(v6);
  return v14;
}

lsl::Allocator::Pool *lsl::Allocator::Pool::aligned_alloc_best_fit( lsl::Allocator::Pool *this, uint64_t a2, unint64_t a3)
{
  if (a2 != 16) {
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  }
  unint64_t v4 = (void *)**((void **)this + 3);
  uint64_t v5 = 0LL;
  unint64_t v6 = -1LL;
  do
  {
    uint64_t v7 = v4[1];
    if ((v7 & 1) == 0)
    {
      unint64_t v8 = (v7 & 0xFFFFFFFFFFFFFFFCLL) - (void)v4 - 16;
      if (v8 >= a3)
      {
        if (v8 - a3 < v6)
        {
          unint64_t v6 = v8 - a3;
          uint64_t v5 = v4;
        }

        if (v8 == a3)
        {
          uint64_t v5 = v4;
          goto LABEL_16;
        }
      }
    }

    unint64_t v4 = (void *)*v4;
  }

  while ((v4 & 1) == 0 && v4);
  if (!v5)
  {
    a2 = 16LL;
    return (lsl::Allocator::Pool *)lsl::Allocator::Pool::aligned_alloc(this, a2, a3);
  }

void *lsl::Allocator::Pool::aligned_alloc(lsl::Allocator::Pool *this, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (lsl::Allocator::AllocationMetadata *)*((void *)this + 3);
  if ((lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v6, 1) != this) {
    lsl::Allocator::Pool::aligned_alloc();
  }
  unint64_t v7 = (*((void *)v6 + 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)v6 - 16;
  unint64_t v8 = 0LL;
  if (v7 >= a3 + 16)
  {
    uint64_t v9 = ((unint64_t)v6 + a2 + 15) & -a2;
    if (v9 - ((uint64_t)v6 + 16) <= v7 - (a3 + 16))
    {
      if ((lsl::Allocator::AllocationMetadata *)((char *)v6 + 16) != (lsl::Allocator::AllocationMetadata *)v9)
      {
        lsl::Allocator::AllocationMetadata::reserve(v6, (unsigned __int16)(v9 - (_WORD)v6 - 32), 0);
        unint64_t v6 = (lsl::Allocator::AllocationMetadata *)*((void *)this + 3);
      }

      unint64_t v8 = (void *)((char *)v6 + 16);
      lsl::Allocator::AllocationMetadata::reserve(v6, a3, 1u);
    }
  }

  return v8;
}

os_unfair_lock_s *lsl::Allocator::freeObject(os_unfair_lock_s *this, void *a2)
{
  if (this)
  {
    vm_prot_t v2 = this;
    int8x8_t v3 = (lsl::Lock ***)lsl::Allocator::AllocationMetadata::pool((lsl::Allocator::AllocationMetadata *)&this[-4], 1);
    return lsl::Allocator::free(*v3, v2);
  }

  return this;
}

uint64_t lsl::Allocator::AllocationMetadata::forPtr(lsl::Allocator::AllocationMetadata *this, void *a2)
{
  return (uint64_t)this - 16;
}

unint64_t lsl::Allocator::AllocationMetadata::pool(lsl::Allocator::AllocationMetadata *this, int a2)
{
  for (uint64_t i = *(lsl::Allocator::AllocationMetadata **)this;
        i && (i & 1) == 0LL;
        uint64_t i = *(lsl::Allocator::AllocationMetadata **)i)
  {
    if (a2)
    {
      uint64_t v4 = *((void *)this + 1);
      if ((v4 & 1) == 0 && (((v4 & 0xFFFFFFFFFFFFFFFCLL) - (void)this) & 0xFFFFFFFFFFFFFFF8LL) != 0x10)
      {
        unint64_t result = *((void *)this + 2);
        if (result) {
          return result;
        }
      }
    }

    this = i;
  }

  return (unint64_t)i & 0xFFFFFFFFFFFFFFFELL;
}

uint64_t lsl::Allocator::Pool::allocator(lsl::Allocator::Pool *this)
{
  return *(void *)this;
}

os_unfair_lock_s *lsl::Allocator::free(lsl::Lock **this, void *a2)
{
  uint64_t v4 = *this;
  lsl::Lock::lock(*this);
  if (a2)
  {
    this[3] = (lsl::Lock *)((char *)this[3] + (void)a2 - (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL));
    lsl::Allocator::AllocationMetadata::deallocate((lsl::Allocator::AllocationMetadata *)(a2 - 2));
  }

  return lsl::Lock::unlock(v4);
}

void *lsl::Allocator::AllocationMetadata::deallocate(lsl::Allocator::AllocationMetadata *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((v1 & 1) == 0) {
    lsl::Allocator::AllocationMetadata::deallocate();
  }
  int8x8_t v3 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  *((void *)this + 1) = v1 & 0xFFFFFFFFFFFFFFFCLL;
  return lsl::Allocator::AllocationMetadata::coalesce(this, v3);
}

uint64_t lsl::Allocator::realloc(lsl::Lock **this, void *a2, unint64_t a3)
{
  unint64_t v6 = *this;
  lsl::Lock::lock(*this);
  if (!a2) {
    goto LABEL_6;
  }
  unint64_t v7 = (lsl::Allocator::AllocationMetadata *)(a2 - 2);
  uint64_t v8 = 16LL;
  if (a3 > 0x10) {
    uint64_t v8 = a3;
  }
  unint64_t v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  unint64_t v10 = (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)v7;
  if (v10 - 16 >= v9)
  {
    if (v10 - 16 > v9) {
      lsl::Allocator::AllocationMetadata::returnToNext(v7, v9);
    }
    goto LABEL_9;
  }

  if (lsl::Allocator::AllocationMetadata::consumeFromNext(v7, v9))
  {
LABEL_9:
    this[3] = (lsl::Lock *)((char *)this[3] + v9 - v10 + 16);
    uint64_t v11 = 1LL;
    goto LABEL_10;
  }

uint64_t lsl::Allocator::AllocationMetadata::consumeFromNext( lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 1);
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v2 & 2) != 0) {
    unint64_t v4 = 0LL;
  }
  else {
    unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFFCLL;
  }
  uint64_t v5 = *(void *)(v4 + 8);
  if ((v5 & 1) != 0) {
    return 0LL;
  }
  unint64_t v7 = (char *)this + a2 + 16;
  uint64_t v8 = &v7[-v3];
  unint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFFCLL) - v4;
  if (v9 - 16 >= (unint64_t)&v7[-v3])
  {
    lsl::Allocator::AllocationMetadata::AllocationMetadata( (unint64_t)v7,  this,  v9 - 16 - (void)&v7[-v3],  v5 & 3,  v2 & 3);
    return 1LL;
  }

  uint64_t result = 0LL;
  if ((v5 & 2) == 0 && v8 == (char *)v9)
  {
    *((void *)this + 1) = v5 | 1;
    *(void *)(v5 & 0xFFFFFFFFFFFFFFFCLL) = this;
    return 1LL;
  }

  return result;
}

void *lsl::Allocator::AllocationMetadata::returnToNext( lsl::Allocator::AllocationMetadata *this, uint64_t a2)
{
  unint64_t v4 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(this, 1);
  lsl::Allocator::AllocationMetadata::AllocationMetadata( (unint64_t)this + a2 + 16,  this,  (*((void *)this + 1) & 0xFFFFFFFFFFFFFFFCLL) - ((void)this + a2) - 32,  0LL,  *((void *)this + 1) & 3LL);
  uint64_t v5 = *((void *)this + 1);
  if ((v5 & 2) != 0) {
    unint64_t v6 = 0LL;
  }
  else {
    unint64_t v6 = (lsl::Allocator::AllocationMetadata *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
  }
  return lsl::Allocator::AllocationMetadata::coalesce(v6, v4);
}

char *lsl::Allocator::strdup(lsl::Lock **this, const char *__s)
{
  unint64_t v4 = _platform_strlen(__s) + 1;
  uint64_t v5 = (char *)lsl::Allocator::aligned_alloc(this, 0x10uLL, v4);
  strlcpy(v5, __s, v4);
  return v5;
}

uint64_t lsl::Allocator::owned(lsl::Allocator *this, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = (void *)*((void *)this + 2);
  if (!v3) {
    return 0LL;
  }
  while (1)
  {
    unint64_t v4 = v3[4];
    if (v4 <= a2 && a2 + a3 <= v3[5] + v4) {
      break;
    }
    unint64_t v3 = (void *)v3[2];
    if (!v3) {
      return 0LL;
    }
  }

  return 1LL;
}

unint64_t lsl::Allocator::size(lsl::Allocator *this, void *a2)
{
  if (a2) {
    return (*(a2 - 1) & 0xFFFFFFFFFFFFFFFCLL) - (void)a2;
  }
  else {
    return 0LL;
  }
}

uint64_t ___ZN3lsl9AllocatorD2Ev_block_invoke(uint64_t a1, vm_address_t *a2)
{
  return vm_deallocate(mach_task_self_, *a2, a2[1]);
}

void lsl::Allocator::~Allocator(lsl::Allocator *this)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 0x40000000LL;
  v1[2] = ___ZN3lsl9AllocatorD2Ev_block_invoke;
  v1[3] = &__block_descriptor_tmp_18_0;
  v1[4] = this;
  lsl::Allocator::forEachVMAllocatedBuffer((uint64_t)this, (uint64_t)v1);
}

lsl::Allocator::Pool *lsl::Allocator::Pool::Pool( unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = a4;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a5;
  *a6 = a1 | 1;
  a6[1] = ((unint64_t)a6 + (a7 & 0xFFFFFFFFFFFFFFF0LL)) | 2;
  *(void *)(a1 + 24) = a6;
  uint64_t v8 = lsl::Allocator::Pool::aligned_alloc((lsl::Allocator::Pool *)a1, 16LL, 48LL);
  *uint64_t v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  *(void *)(a1 + 8) = v8;
  return (lsl::Allocator::Pool *)a1;
}

unint64_t lsl::Allocator::AllocationMetadata::reserve( lsl::Allocator::AllocationMetadata *this, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *((void *)this + 1);
  if ((v3 & 1) != 0) {
    lsl::Allocator::AllocationMetadata::reserve();
  }
  return lsl::Allocator::AllocationMetadata::AllocationMetadata( (unint64_t)this + a2 + 16,  this,  (v3 & 0xFFFFFFFFFFFFFFFCLL) - ((void)this + a2) - 32,  2LL,  a3);
}

uint64_t lsl::Allocator::setBestFit(uint64_t this, char a2)
{
  *(_BYTE *)(this + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2;
  return this;
}

unint64_t lsl::Allocator::AllocationMetadata::AllocationMetadata( unint64_t this, lsl::Allocator::AllocationMetadata *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = 0LL;
  *(void *)(this + 8) = 0LL;
  unint64_t v10 = lsl::Allocator::AllocationMetadata::pool(a2, 1);
  if (!v10) {
    lsl::Allocator::AllocationMetadata::AllocationMetadata();
  }
  *(void *)this = a2;
  if ((a4 & 2) != 0)
  {
    *(void *)(v10 + 24) = this;
  }

  else
  {
    uint64_t v11 = *((void *)a2 + 1);
    if ((v11 & 2) != 0) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = (void *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
    }
    void *v12 = this;
  }

  *((void *)a2 + 1) = this | a5;
  unint64_t v13 = (this + 16 + a3) | a4;
  *(void *)(this + 8) = v13;
  if ((v13 & 1) == 0 && (((v13 & 0xFFFFFFFFFFFFFFFCLL) - this) & 0xFFFFFFFFFFFFFFF8LL) != 0x10) {
    *(void *)(this + 16) = v10;
  }
  if ((v13 & 2) == 0) {
    *(void *)(v13 & 0xFFFFFFFFFFFFFFFCLL) = this;
  }
  return this;
}

void *lsl::Allocator::AllocationMetadata::setPoolHint(void *this, lsl::Allocator::Pool *a2)
{
  uint64_t v2 = this[1];
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = this;
    if ((((v2 & 0xFFFFFFFFFFFFFFFCLL) - (void)this) & 0xFFFFFFFFFFFFFFF8LL) != 0x10)
    {
      if (!a2)
      {
        if ((*this & 1LL) != 0) {
          unint64_t v4 = 0LL;
        }
        else {
          unint64_t v4 = (lsl::Allocator::AllocationMetadata *)*this;
        }
        this = (void *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
        a2 = (lsl::Allocator::Pool *)this;
        if (!this) {
          lsl::Allocator::AllocationMetadata::setPoolHint();
        }
      }

      v3[2] = a2;
    }
  }

  return this;
}

void *lsl::Allocator::AllocationMetadata::coalesce( lsl::Allocator::AllocationMetadata *this, lsl::Allocator::Pool *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if ((v3 & 2) == 0 && (v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v4 = *(void *)((v3 & 0xFFFFFFFFFFFFFFFCLL) + 8);
    if ((v4 & 1) == 0)
    {
      *((void *)this + 1) = v4;
      if ((v4 & 2) == 0) {
        *(void *)(v4 & 0xFFFFFFFFFFFFFFFCLL) = this;
      }
      uint64_t v3 = v4;
    }
  }

  uint64_t v5 = *(lsl::Allocator::AllocationMetadata **)this;
  if (*(void *)this) {
    BOOL v6 = (*(void *)this & 1LL) == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6 || (*((_BYTE *)v5 + 8) & 1) != 0)
  {
    uint64_t v5 = this;
  }

  else
  {
    *((void *)v5 + 1) = v3;
    if ((v3 & 2) == 0)
    {
      uint64_t v7 = *((void *)this + 1);
      if ((v7 & 2) != 0) {
        uint64_t v8 = 0LL;
      }
      else {
        uint64_t v8 = (void *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
      }
      *uint64_t v8 = v5;
    }
  }

  uint64_t result = lsl::Allocator::AllocationMetadata::setPoolHint(v5, a2);
  if ((*((_BYTE *)v5 + 8) & 2) != 0) {
    *((void *)a2 + 3) = v5;
  }
  return result;
}

uint64_t lsl::AllocatorLayout::minSize(lsl::AllocatorLayout *this)
{
  return 256LL;
}

size_t OUTLINED_FUNCTION_0_1(uint64_t a1, const char *a2)
{
  return strlcat(v2, a2, 0x400uLL);
}

size_t OUTLINED_FUNCTION_1_1(uint64_t a1, uint64_t a2)
{
  return lsl::appendHexToString<unsigned long long>(v2, a2);
}

unint64_t murmurHash(uint64_t *a1, int a2, uint64_t a3)
{
  unint64_t v3 = (0xC6A4A7935BD1E995LL * a2) ^ a3;
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 7;
  }
  if ((a2 + 7) >= 0xF)
  {
    uint64_t v5 = 8 * ((uint64_t)v4 >> 3);
    BOOL v6 = (char *)&a1[v4 >> 3];
    do
    {
      uint64_t v7 = *a1++;
      unint64_t v3 = 0xC6A4A7935BD1E995LL
         * ((0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * v7) ^ ((0xC6A4A7935BD1E995LL * v7) >> 47))) ^ v3);
      v5 -= 8LL;
    }

    while (v5);
    a1 = (uint64_t *)v6;
  }

  switch(a2 & 7)
  {
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_14;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_11;
    case 6:
      goto LABEL_10;
    case 7:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 6) << 48;
LABEL_10:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 5) << 40;
LABEL_11:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 4) << 32;
LABEL_12:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 3) << 24;
LABEL_13:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 2) << 16;
LABEL_14:
      v3 ^= (unint64_t)*((unsigned __int8 *)a1 + 1) << 8;
LABEL_15:
      v3 ^= *(unsigned __int8 *)a1;
      break;
    default:
      break;
  }

  unint64_t v8 = 0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * v3) ^ ((0xC6A4A7935BD1E995LL * v3) >> 47));
  return v8 ^ (v8 >> 47);
}

uint64_t dyld3::loadDyldCache(uint64_t a1, void *a2)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  if (*(_BYTE *)(a1 + 4)) {
    return dyld3::mapSplitCachePrivate((unsigned int *)a1, (uint64_t)a2);
  }
  return dyld3::mapSplitCacheSystemWide(a1, (uint64_t)a2);
}

uint64_t dyld3::mapSplitCachePrivate(unsigned int *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  char v168 = 0;
  int v169 = 0;
  memset(v184, 0, sizeof(v184));
  LOBYTE(v4) = 0;
  uint64_t v152 = v170;
  if (v170 && !v168)
  {
    LOBYTE(v4) = 0;
    BOOL v6 = "shared cache is too old, missing subcache suffixes";
LABEL_8:
    *(void *)(a2 + 16) = v6;
    return v4 & 1;
  }

  for (uint64_t i = 0LL; i != 7168; i += 56LL)
  {
    unint64_t v8 = &v181[i];
    *((_BYTE *)v8 + 389) = 0;
    *((_DWORD *)v8 + 98) = 0;
  }

  if (v152 >= 2)
  {
    unint64_t v9 = &v183;
    uint64_t v10 = v152 - 1;
    uint64_t v11 = (const char *)v166;
    while (1)
    {
      memset(v172, 0, sizeof(v172));
      char v173 = 0;
      fsid_t v174 = 0LL;
      uint64_t v175 = 0LL;
      char v176 = 0;
      if (*((_BYTE *)v3 + 6))
      {
        bzero(v177, 0x400uLL);
      }

      v9 += 56;
      v11 += 32;
      if (!--v10) {
        goto LABEL_18;
      }
    }

LABEL_18:
  unint64_t v13 = (dyld3 *)memmove(v181, v167, 0x1C0uLL);
  uint64_t v145 = v167[0];
  dyld3::deallocateExistingSharedCache(v13);
  *(void *)a2 = v181[0];
  *(void *)(a2 + 8) = 0LL;
  v148 = v3;
  if ((_DWORD)v152)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = v181;
    while (1)
    {
      unint64_t v16 = &v181[56 * v14];
      uint64_t v17 = *((unsigned int *)v16 + 96);
      if ((_DWORD)v17) {
        break;
      }
LABEL_24:
      ++v14;
      v15 += 56;
      if (v14 == v152)
      {
        uint64_t v22 = *(void *)(a2 + 8);
        unint64_t v3 = v148;
        goto LABEL_35;
      }
    }

    int v18 = *((_DWORD *)v16 + 98);
    uint64_t v19 = *v16;
    uint64_t v20 = *v16 - v145 + 0x180000000LL;
    uint64_t v21 = v15;
    while (mmap((void *)(v20 + *(void *)(a2 + 8) + *v21 - v19), v21[1], *((_DWORD *)v21 + 11) & 7, 18, v18, v21[2]) != (void *)-1LL)
    {
      v21 += 6;
      if (!--v17) {
        goto LABEL_24;
      }
    }

    if (!*(void *)(a2 + 16)) {
      *(void *)(a2 + 16) = "mmap() the shared cache region failed";
    }
    uint64_t v23 = (int *)v182;
    uint64_t v24 = v152;
    do
    {
      if (*v23 != -1) {
        close(*v23);
      }
      v23 += 112;
      --v24;
    }

    while (v24);
    goto LABEL_32;
  }

  uint64_t v22 = 0LL;
LABEL_35:
  __int128 v26 = (char *)(v22 + v171);
  size_t v27 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
  if (mmap((void *)(v22 + v171), v27, 3, 4114, -1, 0LL) != v26)
  {
    mmap((void *)0x180000000LL, 0x180000000uLL, 0, 4114, 0, 0LL);
    LOBYTE(v4) = 0;
    *(void *)a2 = 0LL;
    BOOL v6 = "could not mmap() dynamic config memory";
    goto LABEL_8;
  }

  strcpy(v26, "dyld_data    v0");
  *((_OWORD *)v26 + 1) = *(_OWORD *)(a2 + 32);
  mprotect(v26, v27, 1);
  if (*((_BYTE *)v3 + 6)) {
    dyld3::verboseSharedCacheMappings(*(dyld3 **)a2, v28);
  }
  if (!(_DWORD)v152)
  {
    LOBYTE(v4) = 1;
    return v4 & 1;
  }

  uint64_t v146 = (vm_address_t *)&v163;
  v143 = &v162;
  fsobj_id v144 = v179;
  v142 = &v178;
  uint64_t v4 = 1LL;
  uint64_t v29 = 0LL;
  do
  {
    uint64_t v147 = v29;
    uint64_t v30 = (uint64_t)memmove(v177, &v181[56 * v29], 0x1C0uLL);
    if (*((_BYTE *)v148 + 8))
    {
      v165[0] = _NSConcreteStackBlock;
      v165[1] = 0x40000000LL;
      v165[2] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke;
      v165[3] = &__block_descriptor_tmp_8;
      v165[4] = a2;
      uint64_t v30 = DyldSharedCache::forEachRegion(v177[0], (uint64_t)v165);
    }

    int v38 = *((unsigned __int8 *)v148 + 12);
    uint64_t v39 = v180;
    uint64_t v153 = v180;
    if (v38)
    {
      unsigned int v40 = 0;
      char v41 = 1;
      if (v180)
      {
        __int128 v42 = (_DWORD **)v144;
        do
        {
          if (*(v42 - 1))
          {
            ++v40;
            if (**v42 != 5) {
              char v41 = 0;
            }
          }

          v42 += 6;
          --v39;
        }

        while (v39);
      }

      uint64_t v39 = v153;
      if (v40 <= 5 && (v41 & 1) != 0)
      {
        v160 = (char *)v172;
        vm_size_t v161 = 8LL;
        __int128 v43 = v143;
        v143[1] = 0LL;
        v43[2] = 0LL;
        uint64_t *v43 = 0LL;
        uint64_t v44 = v39;
        if ((_DWORD)v39)
        {
          v150 = (unsigned int *)&v179[48 * v147 + 8];
          uint64_t v151 = (int *)&v181[56 * v147 + 49];
          uint64_t v45 = (uint64_t)v142;
          unsigned int v149 = v4;
          do
          {
            if (*(void *)v45)
            {
              __int128 v46 = *(_DWORD **)(v45 + 8);
              if (*v46 != 5) {
                __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1115, "slideInfoHeader->version == 5");
              }
              int v47 = *v151;
              int v156 = *(_DWORD *)(v45 + 20);
              int v157 = v47;
              uint64_t v158 = *(void *)(v45 - 8);
              uint64_t v155 = *(void *)(v45 - 24);
              uint64_t v48 = *(void *)(a2 + 8);
              int v49 = v46[2];
              int v154 = v46[1];
              uint64_t v30 = (uint64_t)DyldSharedCache::mappingName((DyldSharedCache *)*v150, 0);
              unint64_t v50 = v162 + 1;
              if (v162 + 1 > v161)
              {
                uint64_t v51 = v30;
                vm_address_t v52 = (vm_address_t)v163;
                vm_size_t v53 = v164;
                if (2 * v161 > v50) {
                  unint64_t v50 = 2 * v161;
                }
                vm_size_t v164 = (vm_page_size + 48 * v50 - 1) & -(uint64_t)vm_page_size;
                if (vm_allocate(mach_task_self_, v146, v164, 1006632961)) {
                  __assert_rtn("growTo", "Array.h", 184, "0");
                }
                memmove(v163, v160, 48 * v162);
                v160 = v163;
                vm_size_t v161 = v164 / 0x30;
                uint64_t v30 = v51;
                if (v52)
                {
                  vm_deallocate(mach_task_self_, v52, v53);
                  uint64_t v30 = v51;
                }
              }

              int v54 = v156 & 7;
              uint64_t v55 = v48 + v155;
              uint64_t v56 = (v49 * v154);
              uint64_t v57 = v162++;
              __int128 v58 = &v160[48 * v57];
              *(_DWORD *)__int128 v58 = v157;
              *((_DWORD *)v58 + 1) = v54;
              *((void *)v58 + 1) = v158;
              *((void *)v58 + 2) = v55;
              *((void *)v58 + 3) = v56;
              *((void *)v58 + 4) = v30;
              *((void *)v58 + 5) = v46;
              uint64_t v4 = v149;
            }

            v45 += 48LL;
            --v44;
          }

          while (v44);
          unsigned int v59 = 4 * v162 + 4;
          if (v162)
          {
            uint64_t v60 = 48 * v162;
            __int128 v61 = v160 + 40;
            do
            {
              if (**(_DWORD **)v61 != 5) {
                __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1142, "slideInfoHeader->version == 5");
              }
              unsigned int v59 = (v59 + 2 * *(_DWORD *)(*(void *)v61 + 8LL) + 25) & 0xFFFFFFFC;
              v61 += 48;
              v60 -= 48LL;
            }

            while (v60);
          }
        }

        else
        {
          unsigned int v59 = 4;
        }

        size_t v62 = (v59 + 47) & 0xFFFFFFF8;
        __chkstk_darwin(v30, v31, v32, v33, v34, v35, v36, v37, (uint64_t)v142);
        __int128 v63 = (uint64_t **)((char *)&v142 - ((v62 + 15) & 0x1FFFFFFF0LL));
        bzero(v63, v62);
        void *v63 = 0xD400000000007LL;
        *((_DWORD *)v63 + 2) = v62;
        *(void *)((char *)v63 + 12) = 0x2800000000LL;
        *((_DWORD *)v63 + 5) = v59;
        uint64_t v72 = *(void *)(a2 + 8);
        uint64_t v73 = v145;
        v63[3] = v72;
        v63[4] = v73;
        uint64_t v74 = v162;
        *((_DWORD *)v63 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v162;
        if (v74)
        {
          unsigned int v75 = 0;
          vm_address_t v76 = &v160[48 * v74];
          unsigned int v77 = 4 * v74 + 4;
          uint64_t v78 = v72 + v73;
          unint64_t v79 = v160;
          do
          {
            uint64_t v80 = (_DWORD *)*((void *)v79 + 5);
            if (*v80 != 5) {
              __assert_rtn("mapSplitCachePrivate", "SharedCacheRuntime.cpp", 1168, "slideInfoHeader->version == 5");
            }
            *((_DWORD *)v63 + v75 + 11) = v77;
            uint64_t v81 = v77 + 40;
            uint64_t v82 = (uint64_t)v63 + v81;
            int v83 = 2 * v80[2] + 22;
            *(_DWORD *)uint64_t v82 = v83;
            *(_DWORD *)(v82 + 4) = 868352;
            *(void *)(v82 + 8) = *((void *)v79 + 2) - v78;
            *(_DWORD *)(v82 + 16) = 0;
            uint64_t v84 = v80[2];
            *(_WORD *)(v82 + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v84;
            if ((_DWORD)v84)
            {
              v80 += 6;
              v81 += (uint64_t)v63 + 22;
              do
              {
                unsigned int v85 = *(unsigned __int16 *)v80;
                uint64_t v80 = (_DWORD *)((char *)v80 + 2);
                uint64_t v82 = v85;
                *(_WORD *)uint64_t v81 = v85;
                v81 += 2LL;
                --v84;
              }

              while (v84);
            }

            ++v75;
            unsigned int v77 = (v77 + v83 + 3) & 0xFFFFFFFC;
            v79 += 48;
          }

          while (v79 != v76);
          __chkstk_darwin(v84, (uint64_t)v80, v81, v82, 868352LL, v69, v70, v71, (uint64_t)v142);
          vm_address_t v90 = (const mwl_region *)((char *)&v142 - (v89 & 0xFFFFFFFFFFFFFFE0LL | 0x10));
          uint64_t v91 = 0LL;
          uint64_t v92 = 48 * v87;
          uint64_t v93 = (mwl_region *)v90;
          do
          {
            if (v87 == v91) {
              __assert_rtn("push_back", "Array.h", 64, "_usedCount < _allocCount");
            }
            ++v91;
            __int128 v94 = *v88;
            __int128 v95 = v88[1];
            v88 += 3;
            *(_OWORD *)&v93->mwlr_fd = v94;
            *(_OWORD *)&v93->mwlr_vm_address_t address = v95;
            ++v93;
            v92 -= 48LL;
          }

          while (v92);
        }

        else
        {
          __chkstk_darwin(v64, v65, v66, v67, v68, v69, v70, v71, (uint64_t)v142);
          vm_address_t v90 = (const mwl_region *)((char *)&v142 - (v96 & 0xFFFFFFFFFFFFFFE0LL | 0x10));
          LODWORD(v91) = 0;
        }

        if (*((_BYTE *)v148 + 6)) {
          dyld4::console((dyld4 *)"Setting up kernel page-in linking for subcache %d\n", v86, v147);
        }
        int v98 = __map_with_linking_np(v90, v91, (const mwl_info_hdr *)((char *)&v142 - ((v62 + 15) & 0x1FFFFFFF0LL)), v62);
        if (v98 && *((_BYTE *)v148 + 6)) {
          dyld4::console( (dyld4 *)"__map_with_linking_np(subcache %d) failed, falling back to linking in-process\n",  v97,  v147);
        }
        uint64_t v162 = 0LL;
        if (v163) {
          vm_deallocate(mach_task_self_, (vm_address_t)v163, v164);
        }
        if (!v98) {
          goto LABEL_131;
        }
        uint64_t v39 = v153;
      }
    }

    if ((_DWORD)v39)
    {
      uint64_t v99 = 0LL;
      while (!v177[6 * v99 + 3])
      {
LABEL_130:
        if (++v99 == v39) {
          goto LABEL_131;
        }
      }

      char v100 = &v177[6 * v99];
      uint64_t v101 = v100[4];
      if (v101)
      {
        int v102 = *(_DWORD *)v101;
        if (*(_DWORD *)v101 == 5)
        {
          uint64_t v132 = "invalid pointer kind in cache file";
          goto LABEL_128;
        }

        uint64_t v103 = *v100;
        if (v102 != 3)
        {
          if (v102 == 2)
          {
            uint64_t v104 = *(unsigned int *)(v101 + 12);
            if ((_DWORD)v104)
            {
              uint64_t v105 = 0LL;
              int v106 = *(_DWORD *)(v101 + 4);
              uint64_t v107 = v101 + *(unsigned int *)(v101 + 8);
              uint64_t v108 = v101 + *(unsigned int *)(v101 + 16);
              do
              {
                int v109 = *(__int16 *)(v107 + 2 * v105);
                if (v109 != 0x4000)
                {
                  uint64_t v110 = v103 + (v106 * v105);
                  if (v109 < 0)
                  {
                    unsigned __int16 v120 = v109 & 0x3FFF;
                    unint64_t v121 = *(void *)(v101 + 24);
                    uint64_t v122 = *(void *)(v101 + 32);
                    char v123 = __clz(__rbit64(v121)) - 2;
                    do
                    {
                      int v124 = *(__int16 *)(v108 + 2LL * v120);
                      unsigned int v125 = 4 * (v124 & 0x3FFF);
                      uint64_t v126 = *(void *)(a2 + 8) + v122;
                      do
                      {
                        uint64_t v127 = *(void *)(v110 + v125);
                        unint64_t v128 = (v127 & v121) >> v123;
                        unint64_t v129 = v127 & ~v121;
                        BOOL v117 = v129 == 0;
                        uint64_t v130 = v126 + v129;
                        if (v117) {
                          uint64_t v130 = 0LL;
                        }
                        *(void *)(v110 + v125) = v130;
                        v125 += v128;
                      }

                      while ((_DWORD)v128);
                      ++v120;
                    }

                    while ((v124 & 0x80000000) == 0);
                  }

                  else
                  {
                    unint64_t v111 = *(void *)(v101 + 24);
                    char v112 = __clz(__rbit64(v111)) - 2;
                    unsigned int v113 = 4 * (v109 & 0x3FFF);
                    uint64_t v114 = *(void *)(v101 + 32) + *(void *)(a2 + 8);
                    do
                    {
                      uint64_t v115 = *(void *)(v110 + v113);
                      unint64_t v116 = (v115 & v111) >> v112;
                      unint64_t v118 = v115 & ~v111;
                      BOOL v117 = v118 == 0;
                      uint64_t v119 = v114 + v118;
                      if (v117) {
                        uint64_t v119 = 0LL;
                      }
                      *(void *)(v110 + v113) = v119;
                      v113 += v116;
                    }

                    while ((_DWORD)v116);
                  }
                }

                ++v105;
              }

              while (v105 != v104);
              int v131 = 1;
              uint64_t v39 = v153;
              goto LABEL_129;
            }

            goto LABEL_125;
          }

          uint64_t v132 = "invalid slide info in cache file";
LABEL_128:
          int v131 = 0;
          *(void *)(a2 + 16) = v132;
          goto LABEL_129;
        }

        unint64_t v133 = *(unsigned int *)(v101 + 8);
        if ((_DWORD)v133)
        {
          unint64_t v134 = 0LL;
          int v135 = *(_DWORD *)(v101 + 4);
          while (1)
          {
            unint64_t v136 = *(unsigned __int16 *)(v101 + 2 * v134 + 24);
            if ((_DWORD)v136 != 0xFFFF) {
              break;
            }
LABEL_123:
            ++v134;
            int v131 = 1;
            uint64_t v39 = v153;
            if (v134 >= v133) {
              goto LABEL_129;
            }
          }

          uint64_t v137 = v4;
          fsid v138 = (void *)(v103 + (v135 * v134));
          unint64_t v139 = v136 >> 3;
          while (1)
          {
            v138 += v139;
            if ((*v138 & 0x8000000000000000LL) != 0) {
              break;
            }
            unint64_t v139 = (*v138 >> 51) & 0x7FFLL;
            v172[0] = *v138;
            *fsid v138 = *(void *)(a2 + 8)
                  + mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget((mach_o::ChainedFixupPointerOnDisk::Arm64e *)v172);
            if (!v139)
            {
              unint64_t v133 = *(unsigned int *)(v101 + 8);
              uint64_t v4 = v137;
              goto LABEL_123;
            }
          }

          uint64_t v132 = "invalid pointer kind in cache file";
          LODWORD(v4) = v137;
          uint64_t v39 = v153;
          goto LABEL_128;
        }
      }

    __int128 v26 = __clz(bswap64(v22)) & 0xFFFFFFFFFFFFFFF8LL;
    return (v18 >> v26) - (v20 >> v26);
  }

  if (v4)
  {
    uint64_t v5 = (char *)__s1 + v4;
    BOOL v6 = (char *)__s2 + v4;
    while (1)
    {
      uint64_t v7 = *(int8x16_t *)__s1;
      __s1 = (char *)__s1 + 16;
      unint64_t v8 = v7;
      unint64_t v9 = *(int8x16_t *)__s2;
      __s2 = (char *)__s2 + 16;
      uint64_t v10 = vceqq_s8(v8, v9);
      v8.i8[0] = vminvq_u8((uint8x16_t)v10);
      if (!v8.i32[0]) {
        break;
      }
      uint64_t v11 = v4 > 0x10;
      v4 -= 16LL;
      if (!v11)
      {
        __s1 = v5;
        __s2 = v6;
        goto LABEL_8;
      }
    }
  }

  else
  {
LABEL_8:
    uint64_t v12 = *(int8x16_t *)__s1;
    __s1 = (char *)__s1 + 16;
    unint64_t v13 = v12;
    uint64_t v14 = *(int8x16_t *)__s2;
    __s2 = (char *)__s2 + 16;
    uint64_t v10 = vceqq_s8(v13, v14);
    v13.i8[0] = vminvq_u8((uint8x16_t)v10);
    if (v13.i32[0]) {
      return 0;
    }
  }

  unint64_t v16 = (uint8x16_t)vorrq_s8(v10, (int8x16_t)xmmword_1800AECC0);
  v16.i8[0] = vminvq_u8(v16);
  return *((unsigned __int8 *)__s1 + v16.u32[0] - 16) - *((unsigned __int8 *)__s2 + v16.u32[0] - 16);
}

LABEL_125:
      int v131 = 1;
LABEL_129:
      uint64_t v4 = v4 & v131;
      goto LABEL_130;
    }

LABEL_131:
    if (*((_BYTE *)v148 + 8))
    {
      v159[0] = _NSConcreteStackBlock;
      v159[1] = 0x40000000LL;
      v159[2] = ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2;
      v159[3] = &__block_descriptor_tmp_9;
      v159[4] = a2;
      DyldSharedCache::forEachRegion(v177[0], (uint64_t)v159);
    }

    uint64_t v29 = v147 + 1;
  }

  while (v147 + 1 != v152);
  v140 = (int *)v182;
  uint64_t v141 = v152;
  do
  {
    if (*v140 != -1) {
      close(*v140);
    }
    v140 += 112;
    --v141;
  }

  while (v141);
  return v4 & 1;
}

uint64_t dyld3::reuseExistingCache(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = __s1;
  if (_platform_strcmp(__s1, "dyld_v1   arm64"))
  {
    uint64_t result = 0LL;
    *(void *)(a2 + 16) = "existing shared cache in memory is not compatible";
  }

  else
  {
    *(void *)a2 = v5;
    *(void *)(a2 + 8) = DyldSharedCache::slide((DyldSharedCache *)v5);
    uint64_t v6 = *((void *)v5 + 13);
    BOOL v7 = v6 == 2 && *((_DWORD *)v5 + 114) == 0;
    if (v6) {
      char v8 = v7;
    }
    else {
      char v8 = 1;
    }
    *(_BYTE *)(a2 + 48) = v8;
    uint64_t v9 = *((void *)v5 + 62) + *(void *)a2;
    else {
      *(_OWORD *)(a2 + 32) = *(_OWORD *)(v9 + 16);
    }
    if (*(_BYTE *)(a1 + 6))
    {
      if (fsgetpath(v13, 0x400uLL, (fsid_t *)(a2 + 32), *(void *)(a2 + 40)) >= 1) {
        dyld4::console((dyld4 *)"re-using existing shared cache (%s):\n", v11, v13);
      }
      dyld3::verboseSharedCacheMappings((dyld3 *)v5, (const DyldSharedCache *)v11);
    }

    return 1LL;
  }

  return result;
}

uint64_t dyld3::mapSplitCacheSystemWide(uint64_t a1, uint64_t a2)
{
  char v74 = 0;
  int v75 = 0;
  memset(v81, 0, 256);
  int v4 = dyld3::preflightMainCacheFile((unsigned int *)a1, a2, (uint64_t)v73, v81, v72);
  uint64_t result = 0LL;
  if (v4)
  {
    uint64_t v6 = v76;
    if (v76 && !v74)
    {
      uint64_t result = 0LL;
      BOOL v7 = "shared cache is too old, missing subcache suffixes";
LABEL_13:
      *(void *)(a2 + 16) = v7;
      return result;
    }

    for (uint64_t i = 0LL; i != 57344; i += 448LL)
    {
      uint64_t v9 = &v78[i];
      v9[389] = 0;
      *((_DWORD *)v9 + 98) = 0;
    }

    if (v6 < 2)
    {
LABEL_11:
      v67[0] = 0LL;
      vm_size_t v13 = (vm_page_size + 31) & -(uint64_t)vm_page_size;
      if (vm_allocate(mach_task_self_, v67, v13, 1))
      {
        uint64_t result = 0LL;
        BOOL v7 = "Could not vm_allocate fixed range for dynamic config data";
        goto LABEL_13;
      }

      vm_address_t v14 = v67[0];
      strcpy((char *)v67[0], "dyld_data    v0");
      *(_OWORD *)(v14 + 16) = *(_OWORD *)(a2 + 32);
      memmove(v78, v73, 0x1C0uLL);
      __chkstk_darwin((v6 + 1), v15, v16, v17, v18, v19, v20, v21, v64);
      uint64_t v30 = (char *)&v64 - v29;
      uint64_t v66 = v31;
      if ((_DWORD)v6)
      {
        uint64_t v32 = 0LL;
        int v33 = 0;
        int v34 = v79[6];
        uint64_t v35 = v30 + 4;
        do
        {
          int v36 = *(_DWORD *)&v78[v32 + 384];
          v33 += v36;
          if (v32) {
            int v37 = 0;
          }
          else {
            int v37 = v34;
          }
          *(v35 - 1) = *(_DWORD *)&v78[v32 + 392];
          *uint64_t v35 = v36;
          v35[1] = v37;
          v32 += 448LL;
          v35 += 3;
        }

        while (448 * v6 != v32);
        uint64_t v38 = v6;
      }

      else
      {
        uint64_t v38 = 0LL;
        int v33 = 0;
      }

      uint64_t v39 = &v30[12 * v38];
      *(void *)uint64_t v39 = 0x1FFFFFFFFLL;
      *((_DWORD *)v39 + 2) = 0;
      __chkstk_darwin(v22, (uint64_t)v30, v23, v24, v25, v26, v27, v28, v64);
      int v47 = (char *)&v64 - (v33 + 1) * (unint64_t)v46;
      if (*(_BYTE *)(a1 + 6))
      {
        unsigned int v65 = v40;
        vm_size_t v48 = v13;
        int v49 = v41;
        dyld4::console((dyld4 *)"Mapping the shared cache system wide\n", v41);
        char v41 = v49;
        vm_size_t v13 = v48;
        unint64_t v40 = v65;
      }

      if ((_DWORD)v6)
      {
        uint64_t v50 = 0LL;
        int v51 = 0;
        vm_address_t v52 = v78;
        do
        {
          uint64_t v53 = *(unsigned int *)&v78[448 * v50 + 384];
          int v54 = v52;
          if ((_DWORD)v53)
          {
            do
            {
              uint64_t v55 = &v47[48 * v51++];
              __int128 v56 = v54[1];
              *(_OWORD *)uint64_t v55 = *v54;
              *((_OWORD *)v55 + 1) = v56;
              *((_OWORD *)v55 + 2) = v54[2];
              v54 += 3;
              --v53;
            }

            while (v53);
          }

          ++v50;
          v52 += 448;
        }

        while (v50 != v38);
      }

      vm_address_t v57 = v67[0];
      __int128 v58 = &v47[48 * v33];
      *(void *)__int128 v58 = v77;
      *((void *)v58 + 1) = v13;
      *((void *)v58 + 3) = 0LL;
      *((void *)v58 + 4) = 0LL;
      *((void *)v58 + 2) = v57;
      *((void *)v58 + 5) = 0x100000001LL;
      int v59 = __shared_region_map_and_slide_2_np( (void *)v40,  v41,  (void *)(v33 + 1),  v47,  v42,  v43,  v44,  v45);
      vm_deallocate(mach_task_self_, v67[0], v13);
      if ((_DWORD)v6)
      {
        uint64_t v60 = v79;
        do
        {
          if (*v60 != -1) {
            close(*v60);
          }
          v60 += 112;
          --v38;
        }

        while (v38);
      }

      char v61 = dyld3::reuseExistingCache(a1, a2);
      if (v59)
      {
        if ((v61 & 1) != 0)
        {
          return 1LL;
        }

        else
        {
          uint64_t result = 0LL;
          if (!*(void *)(a2 + 16)) {
            *(void *)(a2 + 16) = "syscall to map cache into shared region failed";
          }
        }
      }

      else
      {
        if (*(_BYTE *)(a1 + 6)) {
          char v63 = v61;
        }
        else {
          char v63 = 1;
        }
        if ((v63 & 1) == 0) {
          dyld4::console((dyld4 *)"mapped dyld cache file system wide\n", v62);
        }
        return 1LL;
      }
    }

    else
    {
      uint64_t v10 = &v80;
      uint64_t v11 = v6 - 1;
      uint64_t v12 = (const char *)v72;
      while (1)
      {
        memset(v67, 0, sizeof(v67));
        char v68 = 0;
        uint64_t v69 = 0LL;
        uint64_t v70 = 0LL;
        char v71 = 0;
        v10 += 56;
        v12 += 32;
        if (!--v11) {
          goto LABEL_11;
        }
      }
    }
  }

  return result;
}

uint64_t dyld3::deallocateExistingSharedCache(dyld3 *this)
{
  uint64_t v2 = 0LL;
  uint64_t result = __shared_region_check_np(&v2);
  if (!(_DWORD)result) {
    return __shared_region_check_np(0LL);
  }
  return result;
}

uint64_t dyld3::preflightMainCacheFile(unsigned int *a1, uint64_t a2, uint64_t a3, char *__dst, _OWORD *a5)
{
  uint64_t v9 = (dyld3 *)*a1;
  int v10 = *((unsigned __int8 *)a1 + 9);
  int v11 = *((unsigned __int8 *)a1 + 10);
  strcpy(__source, "dyld_shared_cache_arm64");
  strlcpy(__dst, __source, 0x100uLL);
  if (!v10)
  {
    strlcpy(__dsta, __source, 0x100uLL);
    strlcat(__dsta, ".development", 0x400uLL);
    if (!dyld3::fstatat(v9, __dsta, &v20, 0LL))
    {
      int v13 = dyld3::fstatat(v9, __source, &v19, 0LL);
      if (v11 || v13)
      {
        strlcpy(__source, __dsta, 0x100uLL);
      }

      else if (!dyld3::stat( (dyld3 *)"/System/Library/Caches/com.apple.dyld/enable-dylibs-to-override-cache",  &v18,  v14) {
             && v18.st_size <= 1023)
      }
      {
        strlcat(__source, ".development", 0x100uLL);
      }
    }
  }

  int v15 = dyld3::openat((dyld3 *)*a1, __source, v12);
  if (v15 == -1)
  {
    if (*__error() == 2)
    {
      uint64_t result = 0LL;
      *(_BYTE *)(a2 + 24) = 0;
      uint64_t v17 = "no shared cache file";
    }

    else
    {
      uint64_t result = 0LL;
      uint64_t v17 = "shared cache file open() failed";
    }

    *(void *)(a2 + 16) = v17;
  }

  else
  {
    *(_BYTE *)(a2 + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v15, a5);
  }

  return result;
}

uint64_t dyld3::preflightSubCacheFile( unsigned int *a1, uint64_t a2, uint64_t a3, char *__source, const char *a5)
{
  uint64_t v9 = (dyld3 *)*a1;
  strlcpy(__dst, __source, 0x100uLL);
  strlcat(__dst, a5, 0x100uLL);
  int v11 = dyld3::openat(v9, __dst, v10);
  if (v11 == -1)
  {
    if (*__error() == 2)
    {
      uint64_t result = 0LL;
      *(_BYTE *)(a2 + 24) = 0;
      int v13 = "no shared cache file";
    }

    else
    {
      uint64_t result = 0LL;
      int v13 = "shared cache file open() failed";
    }

    *(void *)(a2 + 16) = v13;
  }

  else
  {
    *(_BYTE *)(a2 + 24) = 1;
    return dyld3::preflightCacheFile((uint64_t)a1, a2, a3, v11, 0LL);
  }

  return result;
}

void dyld3::verboseSharedCacheMappings(dyld3 *this, const DyldSharedCache *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke;
  v3[3] = &__block_descriptor_tmp_37;
  void v3[4] = DyldSharedCache::slide(this);
  DyldSharedCache::forEachRange((char *)this, (uint64_t)v3, 0LL);
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke( uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0) {
    return vm_protect(mach_task_self_, *(void *)(*(void *)(result + 32) + 8LL) + a3, size, 0, 19);
  }
  return result;
}

uint64_t ___ZN5dyld3L20mapSplitCachePrivateERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE_block_invoke_2( uint64_t result, int a2, uint64_t a3, vm_size_t size, uint64_t a5, uint64_t a6, char a7)
{
  if ((a7 & 4) != 0) {
    return vm_protect(mach_task_self_, *(void *)(*(void *)(result + 32) + 8LL) + a3, size, 0, 1);
  }
  return result;
}

uint64_t dyld3::preflightCacheFile(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _OWORD *a5)
{
  if (fstat64(a4, &v55))
  {
    int v10 = "shared cache file stat() failed";
LABEL_10:
    *(void *)(a2 + 16) = v10;
LABEL_11:
    close(a4);
    return 0LL;
  }

  st_vm_size_t size = v55.st_size;
  __darwin_ino64_t st_ino = v55.st_ino;
  *(void *)(a2 + 32) = v55.st_dev;
  *(void *)(a2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = st_ino;
  if (pread(a4, v59, 0x4000uLL, 0LL) != 0x4000)
  {
    int v10 = "shared cache file pread() failed";
    goto LABEL_10;
  }

  if (v59[0] != 0x2031765F646C7964LL || v59[1] != 0x34366D72612020LL)
  {
    int v10 = "shared cache file has wrong magic";
    goto LABEL_10;
  }

  uint64_t v15 = v60;
  if (v60 >= 0xE0)
  {
    int v16 = *(_DWORD *)(a1 + 16);
    if (v68 == v16)
    {
      if ((v69 & 2) != 0)
      {
LABEL_22:
        int v10 = "shared cache file is for a different platform";
        goto LABEL_10;
      }
    }

    else if (!v73 || v73 != v16)
    {
      goto LABEL_22;
    }
  }

  unsigned int v17 = v61;
  if (v61 - 9 <= 0xFFFFFFF7)
  {
    int v10 = "shared cache file mappings are invalid";
    goto LABEL_10;
  }

  stat v18 = (char *)v59 + v60;
  uint64_t v19 = v61 - 1;
  uint64_t v20 = *((void *)v18 + 2);
  if (v20)
  {
    uint64_t v21 = "shared cache text file offset is invalid";
    goto LABEL_28;
  }

  if (v64 + v63 != st_size)
  {
    uint64_t v21 = "shared cache code signature size is invalid";
LABEL_28:
    *(void *)(a2 + 16) = v21;
    if (v17 >= 2)
    {
LABEL_29:
      int v22 = *((_DWORD *)v18 + 6) | 4;
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  if (v61 >= 2)
  {
    if (*(_DWORD *)&v18[32 * v19 + 24] != 1) {
      *(void *)(a2 + 16) = "shared cache linkedit permissions are invalid";
    }
    goto LABEL_29;
  }

LABEL_30:
  int v22 = *((_DWORD *)v18 + 6);
LABEL_31:
  if (v22 != 5) {
    *(void *)(a2 + 16) = "shared cache text permissions are invalid";
  }
  if (*(void *)(a2 + 16)) {
    goto LABEL_11;
  }
  unsigned int v23 = 1;
  while (v17 != v23)
  {
    uint64_t v24 = &v18[32 * v23 - 32];
    uint64_t v26 = *(void *)v24;
    uint64_t v25 = *((void *)v24 + 1);
    if ((unint64_t)(v25 + v26) <= *(void *)&v18[32 * v23])
    {
      v20 += v25;
      uint64_t v27 = *(void *)&v18[32 * v23++ + 16];
      if (v20 == v27) {
        continue;
      }
    }

    int v10 = "shared cache mappings overlap";
    goto LABEL_10;
  }

  v58[0] = 0LL;
  v58[1] = v63;
  v58[2] = v64;
  if (fcntl(a4, 97, v58) == -1)
  {
    int v10 = "code signature registration for shared cache failed";
    goto LABEL_10;
  }

  if (v58[0] < v63)
  {
    int v10 = "code signature does not cover entire shared cache file";
    goto LABEL_10;
  }

  uint64_t v28 = mmap(0LL, 0x4000uLL, 5, 2, a4, 0LL);
  if (v28 == (void *)-1LL)
  {
    int v10 = "first page of shared cache not mmap()able";
    goto LABEL_10;
  }

  int v54 = v28;
  if (_platform_memcmp(v28, v59, 0x4000uLL))
  {
    int v10 = "first page of mmap()ed shared cache not valid";
    goto LABEL_10;
  }

  munmap(v54, 0x4000uLL);
  uint64_t v29 = v61;
  *(_DWORD *)(a3 + 384) = v61;
  if ((_DWORD)v29)
  {
    uint64_t v30 = 0LL;
    uint64_t v31 = 0LL;
    unsigned int v32 = v60;
    int v33 = *(unsigned __int8 *)(a1 + 8);
    uint64_t v34 = 48 * v29;
    do
    {
      int v36 = *(_DWORD *)&v62[v15];
      int v35 = *(_DWORD *)&v62[v15 + 4];
      if (v32 > 0x138)
      {
        unint64_t v40 = (void *)((char *)&v59[v30] + v72);
        uint64_t v38 = v40[3];
        uint64_t v39 = v40[4];
        uint64_t v41 = v40[5];
        int v37 = ~((_DWORD)v41 << 6) & 0x40;
        if ((v41 & 4) != 0)
        {
          if (v33) {
            v36 |= 0x200u;
          }
          else {
            v35 |= 2u;
          }
        }
      }

      else if (v31 == 48)
      {
        int v37 = 0;
        uint64_t v38 = v65;
        uint64_t v39 = v66;
      }

      else
      {
        uint64_t v39 = 0LL;
        int v37 = 0;
        uint64_t v38 = 0LL;
      }

      uint64_t v42 = a3 + v31;
      *(_OWORD *)uint64_t v42 = *(_OWORD *)((char *)v59 + v15);
      uint64_t v43 = *(void *)((char *)&v59[2] + v15);
      *(void *)(v42 + 24) = 0LL;
      *(void *)(v42 + 32) = 0LL;
      *(void *)(v42 + 16) = v43;
      *(_DWORD *)(v42 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36;
      *(_DWORD *)(v42 + 44) = v35;
      if (v39)
      {
        if (v17 <= 1)
        {
          *(_DWORD *)(a3 + 392) = a4;
          std::__throw_bad_optional_access[abi:nn180100]();
        }

        uint64_t v44 = v38 - *(void *)&v18[32 * v19 + 16] + *(void *)&v18[32 * v19];
        *(void *)(v42 + 24) = v39;
        *(void *)(v42 + 32) = v44;
        int v45 = v37 | 0x20;
        *(_DWORD *)(v42 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36 | v45;
        *(_DWORD *)(v42 + 44) = v35 | v45;
      }

      v31 += 48LL;
      v15 += 32LL;
      v30 += 7LL;
    }

    while (v34 != v31);
    *(_DWORD *)(a3 + 392) = a4;
  }

  if (__offset_4 > 0x7F)
  {
    int v10 = "shared cache file subcache count exceeds limit";
    goto LABEL_10;
  }

  if (!a5 && __offset_4)
  {
    int v10 = "no shared cache subcache indices";
    goto LABEL_10;
  }

  unsigned int v46 = v60;
  *(_BYTE *)(a3 + 389) = v60 > 0x1C8;
  if (v46 >= 0x1C9)
  {
    if (pread(a4, __buf, 0x1C00uLL, __offseta) != 7168)
    {
      int v10 = "shared cache file pread() failed, could not read subcache entries";
      goto LABEL_10;
    }

    uint64_t v47 = __offset_4;
    if (__offset_4)
    {
      vm_size_t v48 = &v57;
      do
      {
        __int128 v49 = *((_OWORD *)v48 + 1);
        *a5 = *(_OWORD *)v48;
        a5[1] = v49;
        a5 += 2;
        v48 += 7;
        --v47;
      }

      while (v47);
    }
  }

  *(_OWORD *)(a3 + 40dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v70;
  *(void *)(a3 + 416) = v71;
  *(_BYTE *)(a3 + 388) = *(_BYTE *)(a1 + 11);
  *(_DWORD *)(a3 + 424) = DyldSharedCache::numSubCaches((DyldSharedCache *)v59) + 1;
  uint64_t v50 = v78;
  uint64_t v51 = v67;
  *(void *)(a3 + 432) = v77 + v70;
  *(void *)(a3 + 44dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v50;
  BOOL v52 = v51 == 2 && v76 == 0;
  if (v51) {
    char v53 = v52;
  }
  else {
    char v53 = 1;
  }
  *(_BYTE *)(a2 + 48) = v53;
  return 1LL;
}

uint64_t dyld3::openat(dyld3 *this, const char *a2, const char *a3)
{
  int v4 = (int)this;
  for (uint64_t result = openat((int)this, a2, 0, 0LL); (_DWORD)result == -1; uint64_t result = openat(v4, a2, 0, 0LL))
  {
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

ssize_t ___ZN5dyld3L26verboseSharedCacheMappingsEPK15DyldSharedCache_block_invoke( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return dyld4::console( (dyld4 *)"        0x%08llX->0x%08llX init=%x, max=%x %s\n",  a2,  *(void *)(a1 + 32) + a3,  a4 + *(void *)(a1 + 32) + a3 - 1,  a7,  a8,  a2);
}

uint64_t lsl::CRC32c::CRC32c(uint64_t this)
{
  *(void *)this = &lsl::sCRC32cSW;
  *(_DWORD *)(this + 8) = -1;
  return this;
}

uint64_t lsl::CRC32c::operator unsigned int(uint64_t a1)
{
  return ~*(_DWORD *)(a1 + 8);
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(**(void **)a1 + 16LL))(*(void *)a1, a1[2], a2);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32c::operator()(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)a1 + 32LL))( *(void *)a1,  a1[2],  a2,  a3);
  a1[2] = result;
  return result;
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, unsigned int a2, char a3)
{
  return lsl::CRC32cSW::sCRC32cTable[(a2 ^ a3)] ^ (a2 >> 8);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, __int16 a3)
{
  __int16 v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, __int16 *, uint64_t))(*(void *)this + 32LL))( this,  a2,  &v4,  2LL);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, int *, uint64_t))(*(void *)this + 32LL))( this,  a2,  &v4,  4LL);
}

uint64_t lsl::CRC32cSW::checksum(lsl::CRC32cSW *this, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return (*(uint64_t (**)(lsl::CRC32cSW *, uint64_t, uint64_t *, uint64_t))(*(void *)this + 32LL))( this,  a2,  &v4,  8LL);
}

uint64_t lsl::CRC32cSW::checksum(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  for (uint64_t result = a2; a4; --a4)
  {
    char v5 = *a3++;
    uint64_t result = lsl::CRC32cSW::sCRC32cTable[(v5 ^ result)] ^ (result >> 8);
  }

  return result;
}

mach_port_name_array_t dyld4::RemoteNotificationResponder::RemoteNotificationResponder( mach_port_name_array_t names_addr, int a2)
{
  kern_return_t v5;
  mach_port_name_t v6;
  vm_size_t v7;
  *(_OWORD *)names_addr = 0u;
  *((_OWORD *)names_addr + 1) = 0u;
  *((void *)names_addr + 4) = names_addr;
  names_addr[10] = 8;
  unint64_t v3 = names_addr + 10;
  *((void *)names_addr + 6) = 0LL;
  if (a2 != 1229016646) {
    goto LABEL_10;
  }
  uint64_t v4 = (mach_port_name_array_t *)(names_addr + 8);
  char v5 = task_dyld_process_info_notify_get(names_addr, names_addr + 10);
  while (v5 == 3)
  {
    uint64_t v6 = 2 * names_addr[10];
    if (v6 <= 0x10) {
      uint64_t v6 = 16;
    }
    names_addr[10] = v6;
    BOOL v7 = 4LL * v6;
    *((void *)names_addr + 6) = v7;
    if (vm_allocate(mach_task_self_, (vm_address_t *)names_addr + 4, v7, 1)) {
      goto LABEL_10;
    }
    char v5 = task_dyld_process_info_notify_get(*v4, v3);
    if (v5)
    {
      vm_deallocate(mach_task_self_, *((void *)names_addr + 4), *((void *)names_addr + 6));
      *((void *)names_addr + 6) = 0LL;
    }
  }

  if (v5) {
LABEL_10:
  }
    *unint64_t v3 = 0;
  return names_addr;
}

void dyld4::RemoteNotificationResponder::~RemoteNotificationResponder( dyld4::RemoteNotificationResponder *this)
{
  if (*((_DWORD *)this + 10))
  {
    unint64_t v2 = 0LL;
    do
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(*((void *)this + 4) + 4 * v2++));
    while (v2 < *((unsigned int *)this + 10));
    vm_size_t v3 = *((void *)this + 6);
    if (v3) {
      vm_deallocate(mach_task_self_, *((void *)this + 4), v3);
    }
  }

uint64_t dyld4::RemoteNotificationResponder::sendMessage( uint64_t this, mach_msg_id_t a2, mach_msg_size_t a3, mach_msg_header_t *a4)
{
  if (*(_DWORD *)(this + 40))
  {
    uint64_t v7 = this;
    mach_port_name_t name = 0;
    *(_OWORD *)&options.flags = xmmword_1800B8780;
    options.reserved[1] = 0LL;
    this = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)&name, &name);
    if (!(_DWORD)this)
    {
      unint64_t v8 = *(unsigned int *)(v7 + 40);
      if ((_DWORD)v8)
      {
        for (unint64_t i = 0LL; i < v8; ++i)
        {
          uint64_t v10 = *(void *)(v7 + 32);
          if (*(_DWORD *)(v10 + 4 * i))
          {
            a4->msgh_bits = 5395;
            a4->msgh_id = a2;
            mach_port_name_t v11 = name;
            a4->msgh_local_port = name;
            mach_port_t v12 = *(_DWORD *)(v10 + 4 * i);
            a4->msgh_voucher_port = 0;
            a4->msgh_vm_size_t size = a3;
            a4->msgh_remote_port = v12;
            if (mach_msg_overwrite(a4, 3, a3, 0x5Cu, v11, 0, 0, &rcv_msg, 0))
            {
              mach_msg_destroy(a4);
              *(_DWORD *)(*(void *)(v7 + 32) + 4 * i) = 0;
            }

            unint64_t v8 = *(unsigned int *)(v7 + 40);
          }
        }
      }

      return mach_port_destruct(mach_task_self_, name, 0, (mach_port_context_t)&name);
    }
  }

  return this;
}

BOOL dyld4::RemoteNotificationResponder::active(dyld4::RemoteNotificationResponder *this)
{
  unint64_t v1 = *((unsigned int *)this + 10);
  if (!(_DWORD)v1) {
    return 0LL;
  }
  unint64_t v2 = (_DWORD *)*((void *)this + 4);
  if (*v2) {
    return 1LL;
  }
  uint64_t v4 = 1LL;
  do
  {
    unint64_t v5 = v4;
    if (v1 == v4) {
      break;
    }
  }

  while (!v2[v4++]);
  return v5 < v1;
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges( dyld4::RemoteNotificationResponder *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    unint64_t v8 = a6;
    uint64_t v9 = a5;
    uint64_t v10 = a4;
    mach_msg_size_t v11 = a3;
    BOOL v12 = a2;
    int v13 = this;
    int v14 = 32 * a3;
    int v15 = 0;
    if ((_DWORD)a3)
    {
      uint64_t v16 = a3;
      unsigned int v17 = a5;
      do
      {
        stat v18 = *v17++;
        this = (dyld4::RemoteNotificationResponder *)_platform_strlen(v18);
        v15 += (_DWORD)this + 1;
        --v16;
      }

      while (v16);
    }

    mach_msg_size_t v19 = (v14 + 48 + v15 + 127) & 0xFFFFFF80;
    if ((v19 | 0x44) <= 0x8000) {
      break;
    }
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges(v13, v12, v11 >> 1, v10, v9, v8);
    a3 = v11 - (v11 >> 1);
    a4 = &v10[v11 >> 1];
    a5 = &v9[v11 >> 1];
    this = v13;
    a2 = v12;
    a6 = v8;
  }

  v33[1] = (uint64_t)v33;
  uint64_t v34 = v13;
  __chkstk_darwin((uint64_t)this, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v33[0]);
  int v22 = (mach_msg_header_t *)((char *)v33 - ((v21 + 15) & 0x1FFFFFFF0LL));
  v22[1].msgh_bits = 1;
  v22[1].msgh_vm_size_t size = v11;
  v22[1].msgh_remote_port = 48;
  v22[1].msgh_local_port = v20;
  *(void *)&v22[1].msgh_voucher_port = v8;
  if (v11)
  {
    unsigned int v23 = (_DWORD)v22 + (v20 & 0xFFFFFFF0);
    uint64_t v24 = (char *)&v22[2];
    uint64_t v25 = v11;
    uint64_t v26 = (char *)v22 + (v20 & 0xFFFFFFF0);
    do
    {
      uint64_t v27 = *v9++;
      uint64_t v28 = strcpy(v26, v27);
      int v29 = _platform_strlen(v28);
      bzero(v24, 0x10uLL);
      dyld3::MachOFile::getUuid((dyld3::MachOFile *)*v10, (unsigned __int8 *)v24);
      uint64_t v30 = *v10++;
      *((void *)v24 + 2) = v30;
      *((_DWORD *)v24 + 6) = (_DWORD)v26 - v23;
      *((_DWORD *)v24 + 7) = v29;
      v26 += (v29 + 1);
      v24 += 32;
      --v25;
    }

    while (v25);
  }

  if (v12) {
    mach_msg_id_t v31 = 0x2000;
  }
  else {
    mach_msg_id_t v31 = 4096;
  }
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)v34, v31, v19, v22);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled( dyld4::RemoteNotificationResponder *this)
{
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16385, 0x18u, &v4);
}

uint64_t dyld4::RemoteNotificationResponder::blockOnSynchronousEvent( dyld4::RemoteNotificationResponder *this, int a2)
{
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, a2 + 0x4000, 0x18u, &v3);
}

uint64_t dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers( dyld4::RemoteNotificationResponder *this)
{
  return dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 16386, 0x18u, &v2);
}

BOOL dyld4::APIs::validLoader(lsl::Allocator **this, const dyld4::Loader *a2)
{
  return a2
      && ((lsl::Allocator::owned(this[2], (unint64_t)a2, 32LL) & 1) != 0
       || dyld4::RuntimeState::inPrebuiltLoader((dyld4::RuntimeState *)this, a2, 32LL))
      && dyld4::Loader::hasMagic(a2);
}

uint64_t dyld4::APIs::_dyld_get_dlopen_image_header(dyld4::Loader **this, dyld4::Loader *a2)
{
  mach_msg_header_t v3 = a2;
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_get_dlopen_image_header(%p)\n", a2);
  }
  if (v3 == (const dyld4::Loader *)-5LL)
  {
    ImageContaining = this[3];
  }

  else
  {
    if (v3)
    {
      if (v3 == (const dyld4::Loader *)-3LL)
      {
        ImageContaining = (dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, v2);
        if (ImageContaining) {
          return dyld4::Loader::analyzer(ImageContaining, (dyld4::RuntimeState *)this);
        }
      }

      mach_msg_header_t v3 = (const dyld4::Loader *)((unint64_t)v3 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_180058000);
    }

    if (!dyld4::APIs::validLoader(this, v3)) {
      return 0LL;
    }
    ImageContaining = v3;
  }

  return dyld4::Loader::analyzer(ImageContaining, (dyld4::RuntimeState *)this);
}

uint64_t dyld4::APIs::findImageContaining(dyld4::APIs *this, void *a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  mach_msg_header_t v2 = (void *)*((void *)this + 17);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld44APIs19findImageContainingEPv_block_invoke;
  v5[3] = &unk_189620690;
  void v5[5] = this;
  void v5[6] = a2;
  v5[4] = &v6;
  dyld4::RuntimeLocks::withLoadersReadLock(v2, (uint64_t)v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

os_unfair_lock_s *dyld4::APIs::_libdyld_initialize(dyld4::RuntimeState *a1, uint64_t a2)
{
  mach_msg_header_t v4 = (lsl::Lock *)*((void *)a1 + 16);
  lsl::MemoryManager::lockGuard(v4, &v8);
  uint64_t v5 = *((void *)v4 + 3);
  if (!v5)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    uint64_t v5 = *((void *)v4 + 3);
  }

  *((void *)v4 + 3) = v5 + 1;
  lsl::Lock::unlock(v8);
  dyld4::RuntimeState::setHelpers((uint64_t)a1, a2);
  dyld4::RuntimeState::initialize(a1);
  lsl::MemoryManager::lockGuard(v4, &v8);
  uint64_t v6 = *((void *)v4 + 3) - 1LL;
  *((void *)v4 + 3) = v6;
  if (!v6) {
    lsl::MemoryManager::writeProtect(v4, 1);
  }
  return lsl::Lock::unlock(v8);
}

uint64_t dyld4::APIs::_dyld_image_count(dyld4::APIs *this)
{
  uint64_t v1 = *((unsigned int *)this + 12);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_image_count() => %d\n", *((_DWORD *)this + 12));
  }
  return v1;
}

uint64_t dyld4::APIs::_dyld_get_image_header(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  mach_msg_header_t v4 = (void *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke;
  void v7[3] = &unk_189620350;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_header(%u) => %p\n", a2, (const void *)v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t ___ZN5dyld44APIs22_dyld_get_image_headerEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    uint64_t result = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t dyld4::APIs::_dyld_get_image_slide(dyld4::APIs *this, mach_header *a2)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_slide(%p)", a2);
  }
  BOOL hasMachOMagic = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  uint64_t v6 = *((void *)this + 1);
  if (hasMachOMagic)
  {
    if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v6 + 240), (const DyldSharedCache *)a2, v5))
    {
      uint64_t v6 = *((void *)this + 1);
      uint64_t Slide = *(void *)(v6 + 264);
    }

    else
    {
      uint64_t Slide = dyld3::MachOLoaded::getSlide((dyld3::MachOLoaded *)a2);
      uint64_t v6 = *((void *)this + 1);
    }
  }

  else
  {
    uint64_t Slide = 0LL;
  }

  if (*(_BYTE *)(v6 + 204)) {
    dyld4::RuntimeState::log(this, " => 0x%lX\n", Slide);
  }
  return Slide;
}

uint64_t dyld4::APIs::_dyld_get_image_vmaddr_slide(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  mach_msg_header_t v4 = (void *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke;
  void v7[3] = &unk_189620378;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_vmaddr_slide(%u) => 0x%lX\n", a2, v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t ___ZN5dyld44APIs28_dyld_get_image_vmaddr_slideEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    uint64_t result = dyld3::MachOLoaded::getSlide(Address);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t dyld4::APIs::_dyld_get_image_name(dyld4::APIs *this, int a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  mach_msg_header_t v4 = (void *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke;
  void v7[3] = &unk_1896203A0;
  int v8 = a2;
  v7[4] = &v9;
  v7[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_name(%u) => %s\n", a2, (const char *)v10[3]);
  }
  uint64_t v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t ___ZN5dyld44APIs20_dyld_get_image_nameEj_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  unint64_t v2 = *(unsigned int *)(result + 48);
  if (*((void *)v1 + 6) > v2)
  {
    uint64_t v3 = result;
    uint64_t result = dyld4::Loader::path(*(dyld4::Loader **)(*((void *)v1 + 5) + 8 * v2), v1);
    *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t dyld4::APIs::NSVersionOfLinkTimeLibrary(dyld4::Loader **this, const char *a2)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = -1;
  unint64_t Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(this[3], (const dyld4::RuntimeState *)this);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke;
  void v7[3] = &unk_1896203C8;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachDependentDylib(Address, (uint64_t)v7);
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "NSVersionOfLinkTimeLibrary(%s) =>0x%08X\n",  a2,  *((_DWORD *)v9 + 6));
  }
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

BOOL ___ZN5dyld44APIs26NSVersionOfLinkTimeLibraryEPKc_block_invoke( uint64_t a1, dyld4 *this, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  BOOL result = dyld4::nameMatch(this, *(const char **)(a1 + 40), a3);
  if (result) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a7;
  }
  return result;
}

BOOL dyld4::nameMatch(dyld4 *this, const char *a2, const char *a3)
{
  mach_msg_header_t v4 = (const char *)this;
  uint64_t v5 = strrchr((const char *)this, 47);
  if (v5) {
    mach_msg_header_t v4 = v5 + 1;
  }
  if (!_platform_strcmp(v4, a2)) {
    return 1LL;
  }
  size_t v6 = _platform_strlen(v4);
  size_t v7 = _platform_strlen(a2);
  if (v6 < v7 + 9) {
    return 0LL;
  }
  size_t v8 = v7;
  return !_platform_strncmp(v4, "lib", 3uLL)
      && !_platform_strcmp(&v4[v6 - 6], ".dylib")
      && !_platform_strncmp(v4 + 3, a2, v8)
      && v4[v8 + 3] == 46;
}

uint64_t dyld4::APIs::NSVersionOfRunTimeLibrary(dyld4::APIs *this, const char *a2)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = -1;
  mach_msg_header_t v4 = (void *)*((void *)this + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke;
  void v7[3] = &unk_1896203F0;
  v7[5] = this;
  void v7[6] = a2;
  v7[4] = &v8;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v7);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "NSVersionOfRunTimeLibrary(%s) => 0x%08X\n", a2, *((_DWORD *)v9 + 6));
  }
  uint64_t v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t ___ZN5dyld44APIs25NSVersionOfRunTimeLibraryEPKc_block_invoke(uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    mach_msg_header_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      unint64_t Address = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*v4, v1);
      BOOL result = dyld3::MachOFile::getDylibInstallName(Address, (const char **)&v10, &v8, &v9);
      if ((_DWORD)result)
      {
        BOOL result = dyld4::nameMatch(v10, *(const char **)(v3 + 48), v7);
        if ((_DWORD)result) {
          break;
        }
      }

      ++v4;
      v5 -= 8LL;
      if (!v5) {
        return result;
      }
    }

    *(_DWORD *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = v9;
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_watch_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0LL;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  char v7 = 0;
  uint64_t v2 = *(dyld3::MachOFile **)(*((void *)this + 1) + 8LL);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke;
  v5[3] = &unk_189620418;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

void dyld4::APIs::forEachImageVersion(uint64_t a1, dyld3::MachOFile *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(dyld3::MachOFile **)(v7 + 8) == a2)
  {
    (*(void (**)(uint64_t, void, void, void))(a3 + 16))( a3,  *(unsigned int *)(v7 + 68),  *(unsigned int *)(v7 + 48),  *(unsigned int *)(v7 + 56));
  }

  else if (DyldSharedCache::inDyldCache(*(DyldSharedCache **)(v7 + 240), a2, v6))
  {
    (*(void (**)(uint64_t, void, void, void))(a3 + 16))( a3,  *(unsigned int *)(*(void *)(a1 + 8) + 384LL),  *(unsigned int *)(*(void *)(a1 + 8) + 388LL),  *(unsigned int *)(*(void *)(a1 + 8) + 388LL));
  }

  else if (dyld3::MachOFile::isMachO(a2, (vm_address_t *)&v8, *((unsigned int *)a2 + 5) + 32LL))
  {
    dyld4::APIs::forEachPlatform(a1, a2, a3);
  }

  mach_o::Error::~Error(&v8);
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_sdk_watch_os_versionEv_block_invoke( uint64_t result, uint64_t a2, int a3)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v4 = result;
    BOOL result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 4)
    {
      *(_BYTE *)(*(void *)(*(void *)(v4 + 32) + 8LL) + 24LL) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL) = a3;
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_watch_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0LL;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  char v7 = 0;
  uint64_t v2 = *(dyld3::MachOFile **)(*((void *)this + 1) + 8LL);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke;
  v5[3] = &unk_189620440;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_min_watch_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs37dyld_get_program_min_watch_os_versionEv_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v5 = result;
    BOOL result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 4)
    {
      *(_BYTE *)(*(void *)(*(void *)(v5 + 32) + 8LL) + 24LL) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8LL) + 24LL) = a4;
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_bridge_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0LL;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  char v7 = 0;
  uint64_t v2 = *(dyld3::MachOFile **)(*((void *)this + 1) + 8LL);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke;
  v5[3] = &unk_189620468;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_sdk_bridge_os_versionEv_block_invoke( uint64_t result, uint64_t a2, int a3)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v4 = result;
    BOOL result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 5)
    {
      *(_BYTE *)(*(void *)(*(void *)(v4 + 32) + 8LL) + 24LL) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL) = a3;
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_program_min_bridge_os_version(dyld4::APIs *this)
{
  uint64_t v8 = 0LL;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  char v7 = 0;
  uint64_t v2 = *(dyld3::MachOFile **)(*((void *)this + 1) + 8LL);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke;
  v5[3] = &unk_189620490;
  v5[4] = v6;
  void v5[5] = &v8;
  dyld4::APIs::forEachImageVersion((uint64_t)this, v2, (uint64_t)v5);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_min_bridge_os_version() => 0x%08X\n", *((_DWORD *)v9 + 6));
  }
  uint64_t v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t ___ZN5dyld44APIs38dyld_get_program_min_bridge_os_versionEv_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v5 = result;
    BOOL result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result == 5)
    {
      *(_BYTE *)(*(void *)(*(void *)(v5 + 32) + 8LL) + 24LL) = 1;
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8LL) + 24LL) = a4;
    }
  }

  return result;
}

uint64_t dyld4::APIs::getSdkVersion(dyld4::APIs *this, mach_header *a2)
{
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  char v10 = 0;
  uint64_t v5 = 0LL;
  size_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke;
  void v4[3] = &unk_1896204B8;
  void v4[5] = &v5;
  v4[6] = this;
  v4[4] = v9;
  dyld4::APIs::forEachImageVersion((uint64_t)this, (dyld3::MachOFile *)a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(v9, 8);
  return v2;
}

uint64_t ___ZN5dyld44APIs13getSdkVersionEPK11mach_header_block_invoke(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8LL);
  if (!*(_BYTE *)(v3 + 24))
  {
    uint64_t v4 = result;
    int v5 = *(_DWORD *)(*(void *)(*(void *)(result + 48) + 8LL) + 68LL);
    if (v5 == (_DWORD)a2)
    {
      *(_BYTE *)(v3 + 24) = 1;
      BOOL result = dyld3::MachOFile::basePlatform(a2);
      int v7 = a3 + 458752;
      int v8 = a3 + 589824;
      if ((_DWORD)result != 5) {
        int v8 = a3;
      }
      if ((_DWORD)result != 4) {
        int v7 = v8;
      }
      goto LABEL_10;
    }

    if ((_DWORD)a2 == 7 && v5 == 6)
    {
      *(_BYTE *)(v3 + 24) = 1;
      int v7 = 786432;
LABEL_10:
      *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL) = v7;
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_sdk_version(dyld4::APIs *this, mach_header *a2)
{
  uint64_t SdkVersion = dyld4::APIs::getSdkVersion(this, a2);
  uint64_t v5 = SdkVersion;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_sdk_version(%p) => 0x%08X\n", a2, SdkVersion);
  }
  return v5;
}

uint64_t dyld4::APIs::dyld_get_program_sdk_version(dyld4::APIs *this)
{
  uint64_t SdkVersion = dyld4::APIs::getSdkVersion(this, *(mach_header **)(*((void *)this + 1) + 8LL));
  uint64_t v3 = SdkVersion;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_program_sdk_version() => 0x%08X\n", SdkVersion);
  }
  return v3;
}

uint64_t dyld4::APIs::dyld_get_min_os_version(dyld4::APIs *this, mach_header *a2)
{
  v11[0] = 0LL;
  v11[1] = v11;
  __int128 v11[2] = 0x2000000000LL;
  char v12 = 0;
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  int v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke;
  void v6[3] = &unk_1896204E0;
  void v6[5] = &v7;
  v6[6] = this;
  v6[4] = v11;
  dyld4::APIs::forEachImageVersion((uint64_t)this, (dyld3::MachOFile *)a2, (uint64_t)v6);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_min_os_version(%p) => 0x%08X\n", a2, *((_DWORD *)v8 + 6));
  }
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(v11, 8);
  return v4;
}

uint64_t ___ZN5dyld44APIs23dyld_get_min_os_versionEPK11mach_header_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)(result + 32) + 8LL);
  if (!*(_BYTE *)(v4 + 24))
  {
    uint64_t v5 = result;
    int v6 = *(_DWORD *)(*(void *)(*(void *)(result + 48) + 8LL) + 68LL);
    if (v6 == (_DWORD)a2)
    {
      *(_BYTE *)(v4 + 24) = 1;
      BOOL result = dyld3::MachOFile::basePlatform(a2);
      int v8 = a4 + 458752;
      int v9 = a4 + 589824;
      if ((_DWORD)result != 5) {
        int v9 = a4;
      }
      if ((_DWORD)result != 4) {
        int v8 = v9;
      }
      goto LABEL_10;
    }

    if ((_DWORD)a2 == 7 && v6 == 6)
    {
      *(_BYTE *)(v4 + 24) = 1;
      int v8 = 786432;
LABEL_10:
      *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8LL) + 24LL) = v8;
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_get_active_platform(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(unsigned int *)(v1 + 68);
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_get_active_platform() => %d\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::dyld_get_base_platform(dyld4::APIs *this, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = dyld3::MachOFile::basePlatform(a2);
  uint64_t v5 = v4;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_base_platform(%d) => %d\n", v2, v4);
  }
  return v5;
}

uint64_t dyld4::APIs::dyld_is_simulator_platform(dyld4::APIs *this, int a2)
{
  uint64_t isSimulatorPlatform = dyld3::MachOFile::isSimulatorPlatform(a2, 0LL);
  uint64_t v5 = isSimulatorPlatform;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_is_simulator_platform(%d) => %d\n", a2, isSimulatorPlatform);
  }
  return v5;
}

unint64_t dyld4::APIs::mapFromVersionSet(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = HIDWORD(a2);
  if ((_DWORD)a2 == -1)
  {
    int v4 = dyld3::MachOFile::basePlatform(a3);
    LODWORD(a2) = v4;
    uint64_t v5 = 0LL;
    while (dyld3::sVersionMap[v5] < v3)
    {
      v5 += 9LL;
      if (v5 == 441)
      {
        LODWORD(a2) = 0;
        unint64_t v3 = 0LL;
        return a2 | (v3 << 32);
      }
    }

    unint64_t v3 = 0LL;
    switch(v4)
    {
      case 1:
        int v6 = &dyld3::sVersionMap[v5 + 1];
        goto LABEL_13;
      case 2:
        int v6 = &dyld3::sVersionMap[v5 + 2];
        goto LABEL_13;
      case 3:
        int v6 = &dyld3::sVersionMap[v5 + 4];
        goto LABEL_13;
      case 4:
        int v6 = &dyld3::sVersionMap[v5 + 3];
        goto LABEL_13;
      case 5:
        int v6 = &dyld3::sVersionMap[v5 + 5];
        goto LABEL_13;
      case 11:
        int v6 = &dyld3::sVersionMap[v5 + 7];
LABEL_13:
        unint64_t v3 = *v6;
        break;
      default:
        return a2 | (v3 << 32);
    }
  }

  return a2 | (v3 << 32);
}

uint64_t dyld4::APIs::dyld_sdk_at_least(dyld4::RuntimeState *a1, dyld3::MachOFile *a2, unint64_t a3)
{
  unint64_t v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((void *)a1 + 1) + 68LL));
  uint64_t v10 = 0LL;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  void v9[3] = &unk_189620508;
  void v9[4] = &v10;
  void v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(_BYTE *)(*((void *)a1 + 1) + 204LL)) {
    dyld4::RuntimeState::log( a1,  "dyld_sdk_at_least(%p, <%d,0x%08X>) => %d\n",  a2,  a3,  HIDWORD(a3),  *((unsigned __int8 *)v11 + 24));
  }
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t ___ZN5dyld44APIs17dyld_sdk_at_leastEPK11mach_header20dyld_build_version_t_block_invoke( uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = dyld3::MachOFile::basePlatform(a2);
  uint64_t result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v6 == (_DWORD)result)
  {
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)(a1 + 44) <= a3) {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      }
    }
  }

  return result;
}

uint64_t dyld4::APIs::dyld_minos_at_least(dyld4::RuntimeState *a1, dyld3::MachOFile *a2, unint64_t a3)
{
  unint64_t v6 = dyld4::APIs::mapFromVersionSet((uint64_t)a1, a3, *(unsigned int *)(*((void *)a1 + 1) + 68LL));
  uint64_t v10 = 0LL;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke;
  void v9[3] = &unk_189620530;
  void v9[4] = &v10;
  void v9[5] = v6;
  dyld4::APIs::forEachImageVersion((uint64_t)a1, a2, (uint64_t)v9);
  if (*(_BYTE *)(*((void *)a1 + 1) + 204LL)) {
    dyld4::RuntimeState::log( a1,  "dyld_minos_at_least(%p, <%d,0x%08X>) => %d\n",  a2,  a3,  HIDWORD(a3),  *((unsigned __int8 *)v11 + 24));
  }
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t ___ZN5dyld44APIs19dyld_minos_at_leastEPK11mach_header20dyld_build_version_t_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v7 = dyld3::MachOFile::basePlatform(a2);
  uint64_t result = dyld3::MachOFile::basePlatform(*(unsigned int *)(a1 + 40));
  if (v7 == (_DWORD)result)
  {
    uint64_t result = dyld3::MachOFile::basePlatform(a2);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)(a1 + 44) <= a4) {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      }
    }
  }

  return result;
}

BOOL dyld4::APIs::dyld_program_minos_at_least(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD **)(a1 + 8);
  int v3 = v2[16];
  BOOL v4 = v3 != 0;
  if ((_DWORD)a2 == -1)
  {
    unsigned int v5 = v2[15];
  }

  else if (v3 == (_DWORD)a2 || v2[17] == (_DWORD)a2)
  {
    unsigned int v5 = v2[14];
  }

  else
  {
    unsigned int v5 = 0;
    BOOL v4 = 0;
  }

  return v5 >= HIDWORD(a2) && v4;
}

BOOL dyld4::APIs::dyld_program_sdk_at_least(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD **)(a1 + 8);
  int v3 = v2[16];
  BOOL v4 = v3 != 0;
  if ((_DWORD)a2 == -1)
  {
    unsigned int v5 = v2[13];
  }

  else if (v3 == (_DWORD)a2 || v2[17] == (_DWORD)a2)
  {
    unsigned int v5 = v2[12];
  }

  else
  {
    unsigned int v5 = 0;
    BOOL v4 = 0;
  }

  return v5 >= HIDWORD(a2) && v4;
}

unint64_t dyld4::APIs::dyld_get_program_sdk_version_token(dyld4::APIs *this)
{
}

unint64_t dyld4::APIs::dyld_get_program_minos_version_token(dyld4::APIs *this)
{
}

uint64_t dyld4::APIs::dyld_version_token_get_platform(dyld4::APIs *this, uint64_t a2)
{
  return a2;
}

BOOL dyld4::APIs::dyld_version_token_at_least(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = dyld4::APIs::mapFromVersionSet(a1, a3, a2);
  BOOL result = 0;
  if ((_DWORD)a2)
  {
    unsigned int v5 = HIDWORD(v4);
  }

  return result;
}

void dyld4::APIs::forEachPlatform(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  v4[0] = 0LL;
  v4[1] = v4;
  v4[2] = 0x2000000000LL;
  char v5 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke;
  mach_msg_header_t v3[3] = &unk_189620558;
  void v3[6] = a1;
  v3[7] = a2;
  void v3[4] = a3;
  void v3[5] = v4;
  dyld3::MachOFile::forEachSupportedPlatform(a2, (uint64_t)v3);
  _Block_object_dispose(v4, 8);
}

uint64_t ___ZN5dyld44APIs15forEachPlatformEPKN5dyld39MachOFileEU13block_pointerFvjjjE_block_invoke( uint64_t a1)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void dyld4::APIs::dyld_get_image_versions(dyld4::RuntimeState *this, dyld3::MachOFile *a2, const void *a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_get_image_versions(%p, %p)\n", a2, a3);
  }
  dyld4::APIs::forEachImageVersion((uint64_t)this, a2, (uint64_t)a3);
}

uint64_t dyld4::APIs::dyld_get_program_min_os_version(dyld4::APIs *this)
{
  return (*(uint64_t (**)(dyld4::APIs *, void))(*(void *)this + 392LL))( this,  *(void *)(*((void *)this + 1) + 8LL));
}

BOOL dyld4::APIs::_dyld_get_image_uuid(dyld4::APIs *this, mach_header *a2, unsigned __int8 *a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_image_uuid(%p, %p)\n", a2, a3);
  }
  BOOL result = dyld3::MachOFile::hasMachOMagic((dyld3::MachOFile *)a2);
  if ((_DWORD)result) {
    return dyld3::MachOFile::getUuid((dyld3::MachOFile *)a2, a3);
  }
  return result;
}

uint64_t dyld4::APIs::_NSGetExecutablePath(dyld4::APIs *this, char *a2, unsigned int *a3)
{
  uint64_t v5 = *((void *)this + 1);
  if (*(_BYTE *)(v5 + 204))
  {
    dyld4::RuntimeState::log(this, "_NSGetExecutablePath(%p, %p)\n", a2, a3);
    uint64_t v5 = *((void *)this + 1);
  }

  uint64_t v7 = 16LL;
  if (*(_DWORD *)(v5 + 68) == 1) {
    uint64_t v7 = 24LL;
  }
  int v8 = *(const char **)(v5 + v7);
  size_t v9 = _platform_strlen(v8);
  size_t v10 = *a3;
  if (v9 + 1 <= v10)
  {
    strlcpy(a2, v8, v10);
    return 0LL;
  }

  else
  {
    *a3 = v9 + 1;
    return 0xFFFFFFFFLL;
  }

os_unfair_lock_s *dyld4::APIs::_dyld_register_func_for_add_image( lsl::Lock **this, void (*a2)(const mach_header *, uint64_t))
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_func_for_add_image(%p)\n", a2);
  }
  unint64_t v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  __int128 v11[2] = ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke;
  void v11[3] = &__block_descriptor_tmp_44;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  unint64_t v6 = this[16];
  uint64_t v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v8 = *((void *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    uint64_t v8 = *((void *)v6 + 3);
  }

  *((void *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(void *)v7)
  {
    (*(void (**)(void, void *, void))(**(void **)v7 + 104LL))(*(void *)v7, (void *)v7 + 2, 0LL);
    dyld4::RuntimeState::addNotifyAddFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(void, void *))(**(void **)v7 + 112LL))(*(void *)v7, (void *)v7 + 2);
  }

  else
  {
    dyld4::RuntimeState::addNotifyAddFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
  }

  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v9 = *((void *)v6 + 3) - 1LL;
  *((void *)v6 + 3) = v9;
  if (!v9) {
    lsl::MemoryManager::writeProtect(v6, 1);
  }
  return lsl::Lock::unlock(v12);
}

void ___ZN5dyld44APIs33_dyld_register_func_for_add_imageEPFvPK11mach_headerlE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(unsigned int *)(v9 + 48);
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v27);
  int v11 = (const void **)((char *)&v27 - ((8 * v10 + 15) & 0xFFFFFFFF0LL));
  __chkstk_darwin(v12, v13, v14, v15, v16, v17, v18, v19, v27);
  uint64_t v21 = (uint64_t *)((char *)&v27 - v20);
  if (v10)
  {
    for (uint64_t i = 0LL; i != v10; ++i)
    {
      unint64_t Address = (dyld3::MachOLoaded *)dyld4::Loader::loadAddress( *(dyld4::Loader **)(*(void *)(v9 + 40) + i * 8),  (const dyld4::RuntimeState *)v9);
      v11[i] = Address;
      if ((*(_BYTE *)(*(void *)(*(void *)(v9 + 40) + i * 8) + 4LL) & 2) != 0) {
        uint64_t Slide = *(void *)(*(void *)(v9 + 8) + 264LL);
      }
      else {
        uint64_t Slide = dyld3::MachOLoaded::getSlide(Address);
      }
      v21[i] = Slide;
    }

    do
    {
      uint64_t v25 = *v11;
      if (*(_BYTE *)(*(void *)(v9 + 8) + 205LL)) {
        dyld4::RuntimeState::log( (dyld4::RuntimeState *)v9,  "add notifier %p called with mh=%p\n",  *(const void **)(a1 + 40),  *v11);
      }
      uint64_t v26 = *v21++;
      (*(void (**)(const void *, uint64_t))(a1 + 40))(v25, v26);
      ++v11;
      --v10;
    }

    while (v10);
  }

os_unfair_lock_s *dyld4::APIs::_dyld_register_func_for_remove_image( lsl::Lock **this, void (*a2)(const mach_header *, uint64_t))
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_func_for_remove_image(%p)\n", a2);
  }
  ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  uint64_t v5 = this[16];
  unint64_t v6 = this[17];
  lsl::MemoryManager::lockGuard(v5, &v10);
  uint64_t v7 = *((void *)v5 + 3);
  if (!v7)
  {
    lsl::MemoryManager::writeProtect(v5, 0);
    uint64_t v7 = *((void *)v5 + 3);
  }

  *((void *)v5 + 3) = v7 + 1;
  lsl::Lock::unlock(v10);
  if (*(void *)v6)
  {
    (*(void (**)(void, void *, void))(**(void **)v6 + 104LL))(*(void *)v6, (void *)v6 + 2, 0LL);
    dyld4::RuntimeState::addNotifyRemoveFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(void, void *))(**(void **)v6 + 112LL))(*(void *)v6, (void *)v6 + 2);
  }

  else
  {
    dyld4::RuntimeState::addNotifyRemoveFunc((dyld4::RuntimeState *)this, ImageContaining, a2);
  }

  lsl::MemoryManager::lockGuard(v5, &v10);
  uint64_t v8 = *((void *)v5 + 3) - 1LL;
  *((void *)v5 + 3) = v8;
  if (!v8) {
    lsl::MemoryManager::writeProtect(v5, 1);
  }
  return lsl::Lock::unlock(v10);
}

void dyld4::APIs::_dyld_objc_notify_register( dyld4::APIs *this, void (*a2)(unsigned int, const char *const *, const mach_header *const *), void (*a3)(const char *, const mach_header *), void (*a4)(const char *, const mach_header *))
{
}

void dyld4::APIs::_dyld_objc_register_callbacks(dyld4::PrebuiltLoaderSet **this, uint64_t a2)
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "_dyld_objc_register_callbacks(%lu, %p, %p, %p, %p)\n",  *(void *)a2,  *(const void **)(a2 + 8),  *(const void **)(a2 + 16),  *(const void **)(a2 + 248),  *(const void **)(a2 + 32));
  }
  switch(*(void *)a2)
  {
    case 1LL:
      int v11 = "_dyld_objc_register_callbacks v1 is no longer supported";
      goto LABEL_11;
    case 2LL:
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(a2 + 32);
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v8 = (lsl::Lock *)this;
      uint64_t v7 = 0LL;
      goto LABEL_6;
    case 3LL:
    case 4LL:
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(a2 + 32);
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v8 = (lsl::Lock *)this;
      uint64_t v9 = 0LL;
LABEL_6:
      dyld4::RuntimeState::setObjCNotifiers(v8, v4, v5, v9, v6, v7);
      uint64_t v10 = this[123];
      if (v10) {
        dyld4::PrebuiltLoaderSet::logDuplicateObjCClasses(v10, this);
      }
      return;
    default:
      int v11 = "_dyld_objc_register_callbacks unknown version";
LABEL_11:
      dyld4::halt(v11, 0LL);
  }

uint64_t dyld4::APIs::findImageMappedAt( dyld4::APIs *this, char *a2, const dyld3::MachOLoaded **a3, BOOL *a4, const char **a5, void **a6, unint64_t *a7, unsigned __int8 *a8, const dyld4::Loader **a9)
{
  char v16 = 0;
  uint64_t v41 = 0LL;
  uint64_t v42 = &v41;
  uint64_t v43 = 0x2000000000LL;
  char v44 = 0;
  uint64_t v17 = *((void *)this + 1);
  uint64_t v18 = *(DyldSharedCache **)(v17 + 240);
  if (v18) {
    BOOL v19 = v18 >= (DyldSharedCache *)a2;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    if ((char *)v18 + DyldSharedCache::mappedSize(*(DyldSharedCache **)(v17 + 240)) <= a2)
    {
      char v16 = 0;
    }

    else
    {
      uint64_t v27 = a8;
      uint64_t v20 = (char *)v18 - DyldSharedCache::unslidLoadAddress(v18);
      int v37 = 0LL;
      uint64_t v38 = &v37;
      uint64_t v39 = 0x2000000000LL;
      int v40 = 0;
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 0x40000000LL;
      v36[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke;
      uint64_t v36[3] = &unk_1896205A0;
      v36[4] = &v37;
      v36[5] = a2 - v20;
      DyldSharedCache::forEachRange((char *)v18, (uint64_t)v36, 0LL);
      if (*((_DWORD *)v38 + 6) == 5)
      {
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000LL;
        v35[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_2;
        _DWORD v35[3] = &unk_1896205C8;
        v35[6] = a3;
        v35[7] = v20;
        v35[8] = a4;
        void v35[9] = a5;
        v35[10] = a6;
        v35[11] = a7;
        void v35[12] = v27;
        v35[13] = a9;
        v35[4] = &v41;
        v35[5] = a2 - v20;
        DyldSharedCache::forEachImageTextSegment((uint64_t)v18, (uint64_t)v35);
        if (*((_BYTE *)v42 + 24))
        {
          _Block_object_dispose(&v37, 8);
LABEL_28:
          uint64_t ImageMappedAt = 1LL;
          goto LABEL_31;
        }
      }

      _Block_object_dispose(&v37, 8);
      char v16 = 1;
      a8 = v27;
    }
  }

  if (dyld4::RuntimeState::inPermanentRange( this,  (unint64_t)a2,  (unint64_t)(a2 + 1),  &v34,  (const Loader **)&v37))
  {
    if (a3) {
      *a3 = (const dyld3::MachOLoaded *)dyld4::Loader::loadAddress((dyld4::Loader *)v37, this);
    }
    if (a4) {
      *a4 = 1;
    }
    if (a5) {
      *a5 = (const char *)dyld4::Loader::path((dyld4::Loader *)v37, this);
    }
    if ((unint64_t)a6 | (unint64_t)a7
      && dyld4::Loader::contains((dyld4::Loader *)v37, this, a2, (const void **)&v33, &v32, &v31))
    {
      if (a6) {
        *a6 = v33;
      }
      if (a7) {
        *a7 = v32;
      }
    }

    if (a8) {
      *a8 = v34;
    }
    if (a9) {
      *a9 = (const dyld4::Loader *)v37;
    }
    goto LABEL_28;
  }

  int v22 = (void *)*((void *)this + 17);
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 0x40000000LL;
  v29[2] = ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3;
  v29[3] = &unk_1896205F0;
  char v30 = v16;
  v29[6] = a2;
  v29[7] = a3;
  v29[8] = a4;
  v29[9] = a5;
  v29[10] = a6;
  v29[11] = a7;
  v29[12] = a8;
  v29[13] = a9;
  v29[4] = &v41;
  v29[5] = this;
  dyld4::RuntimeLocks::withLoadersReadLock(v22, (uint64_t)v29);
  if (*((_BYTE *)v42 + 24) || (uint64_t v24 = *((void *)this + 30)) == 0)
  {
LABEL_30:
    uint64_t ImageMappedAt = *((unsigned __int8 *)v42 + 24) != 0;
  }

  else
  {
    uint64_t v25 = (const void **)(*((void *)this + 29) + 8LL);
    uint64_t v26 = 16 * v24;
    while (*(v25 - 1) != a2)
    {
      v25 += 2;
      v26 -= 16LL;
      if (!v26) {
        goto LABEL_30;
      }
    }

    uint64_t ImageMappedAt = dyld4::APIs::findImageMappedAt(this, *v25, a3, a4, a5, (const void **)a6, a7, a8, a9);
  }

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke( uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, _BYTE *a9)
{
  unint64_t v9 = *(void *)(result + 40);
  if (v9 >= a3 && v9 < a4 + a3)
  {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a7;
    *a9 = 1;
  }

  return result;
}

void *___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_2( void *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  unint64_t v6 = result[5];
  if (v6 >= a2 && v6 < a3 + a2)
  {
    uint64_t v8 = (void *)result[6];
    if (v8) {
      *uint64_t v8 = result[7] + a2;
    }
    unint64_t v9 = (_BYTE *)result[8];
    if (v9) {
      _BYTE *v9 = 1;
    }
    uint64_t v10 = (void *)result[9];
    if (v10) {
      *uint64_t v10 = a5;
    }
    int v11 = (void *)result[10];
    if (v11) {
      *int v11 = result[7] + a2;
    }
    uint64_t v12 = (void *)result[11];
    if (v12) {
      void *v12 = a3;
    }
    uint64_t v13 = (_BYTE *)result[12];
    if (v13) {
      _BYTE *v13 = 5;
    }
    uint64_t v14 = (void *)result[13];
    if (v14) {
      void *v14 = 0LL;
    }
    *a6 = 1;
    *(_BYTE *)(*(void *)(result[4] + 8LL) + 24LL) = 1;
  }

  return result;
}

uint64_t ___ZN5dyld44APIs17findImageMappedAtEPKvPPKN5dyld311MachOLoadedEPbPPKcPS2_PyPhPPKNS_6LoaderE_block_invoke_3( uint64_t result)
{
  uint64_t v1 = *(dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      unint64_t v6 = *v4;
      if (((*((unsigned __int16 *)*v4 + 2) >> 1) & 1) == *(_BYTE *)(v3 + 112))
      {
        BOOL result = dyld4::Loader::contains(*v4, v1, *(char **)(v3 + 48), (const void **)&v14, &v13, &v12);
        if ((_DWORD)result) {
          break;
        }
      }

      ++v4;
      v5 -= 8LL;
      if (!v5) {
        return result;
      }
    }

    if (*(void *)(v3 + 56))
    {
      BOOL result = dyld4::Loader::loadAddress(v6, v1);
      **(void **)(v3 + 56) = result;
    }

    uint64_t v7 = *(BOOL **)(v3 + 64);
    if (v7) {
      *uint64_t v7 = (*((_BYTE *)v6 + 4) & 0x20) != 0;
    }
    if (*(void *)(v3 + 72))
    {
      BOOL result = dyld4::Loader::path(v6, v1);
      **(void **)(v3 + 72) = result;
    }

    uint64_t v8 = *(void ***)(v3 + 80);
    if (v8) {
      *uint64_t v8 = v14;
    }
    unint64_t v9 = *(unint64_t **)(v3 + 88);
    if (v9) {
      unint64_t *v9 = v13;
    }
    uint64_t v10 = *(unsigned __int8 **)(v3 + 96);
    if (v10) {
      *uint64_t v10 = v12;
    }
    int v11 = *(dyld4::Loader ***)(v3 + 104);
    if (v11) {
      *int v11 = v6;
    }
    *(_BYTE *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = 1;
  }

  return result;
}

dyld3::MachOLoaded *dyld4::APIs::dyld_image_header_containing_address(dyld4::APIs *this, char *a2)
{
  uint64_t v5 = 0LL;
  dyld4::APIs::findImageMappedAt(this, a2, &v5, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_image_header_containing_address(%p) =>%p\n", a2, v5);
  }
  return v5;
}

char *dyld4::APIs::dyld_image_path_containing_address(dyld4::APIs *this, char *a2)
{
  uint64_t v5 = 0LL;
  dyld4::APIs::findImageMappedAt(this, a2, &v7, &v6, (const char **)&v5, 0LL, 0LL, 0LL, 0LL);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_image_path_containing_address(%p) => '%s'\n", a2, v5);
  }
  return v5;
}

uint64_t dyld4::APIs::_dyld_is_memory_immutable(dyld4::APIs *this, char *a2, uint64_t a3)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  char v19 = 0;
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = *(char **)(v6 + 240);
  if (v7) {
    BOOL v8 = v7 >= a2;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && &v7[DyldSharedCache::mappedSize(*(DyldSharedCache **)(v6 + 240))] > a2)
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000LL;
    v15[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke;
    v15[3] = &unk_189620640;
    void v15[5] = a2;
    void v15[6] = a3;
    v15[4] = &v16;
    DyldSharedCache::forEachCache(v7, (uint64_t)v15);
  }

  unint64_t v9 = v17;
  if (!*((_BYTE *)v17 + 24))
  {
    BOOL v10 = dyld4::RuntimeState::inPermanentRange( this,  (unint64_t)a2,  (unint64_t)&a2[a3],  &v13,  (const Loader **)&v14);
    unint64_t v9 = v17;
    if (v10) {
      *((_BYTE *)v17 + 24) = ((v13 >> 1) & 1) == 0;
    }
  }

  if (*(_BYTE *)(*((void *)this + 1) + 204LL))
  {
    dyld4::RuntimeState::log(this, "_dyld_is_memory_immutable(%p, %lu) => %d\n", a2, a3, *((unsigned __int8 *)v9 + 24));
    unint64_t v9 = v17;
  }

  uint64_t v11 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v16, 8);
  return v11;
}

uint64_t ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke_2;
  mach_msg_header_t v3[3] = &unk_189620618;
  uint64_t v5 = *(void *)(a1 + 48);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  return DyldSharedCache::forEachRegion(a2, (uint64_t)v3);
}

void *___ZN5dyld44APIs25_dyld_is_memory_immutableEPKvm_block_invoke_2( void *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  unint64_t v6 = result[5];
  if (v6 > a2 && (a6 & 2) == 0 && v6 + result[6] < a2 + a4) {
    *(_BYTE *)(*(void *)(result[4] + 8LL) + 24LL) = 1;
  }
  return result;
}

uint64_t dyld4::APIs::dladdr( dyld4::APIs *this, int *a2, dl_info *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v32 = 520618000;
  int v33 = a2;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v32, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dladdr(%p, %p)\n", a2, a3);
  }
  if (a3)
  {
    if (dyld4::APIs::findImageMappedAt( this,  (char *)a2,  &v30,  &v31,  (const char **)&v28,  &v27,  &v26,  &v25,  &v29))
    {
      uint64_t v11 = v30;
      a3->dli_fmach_port_name_t name = v28;
      a3->dli_fbase = v11;
      if (v11 == (dyld3::MachOLoaded *)a2)
      {
        a3->dli_smach_port_name_t name = "__dso_handle";
        a3->dli_saddr = a2;
      }

      else
      {
        p_dli_smach_port_name_t name = &a3->dli_sname;
        if (dyld3::MachOLoaded::findClosestSymbol(v11, (uint64_t)a2, &a3->dli_sname, &v21))
        {
          unsigned __int8 v13 = (void *)v21;
          a3->dli_saddr = (void *)v21;
          if (a3->dli_fbase == v13)
          {
            *p_dli_smach_port_name_t name = 0LL;
            a3->dli_saddr = 0LL;
          }

          else
          {
            uint64_t v14 = *p_dli_sname;
            if (*p_dli_sname && *v14 == 95) {
              *p_dli_smach_port_name_t name = v14 + 1;
            }
          }
        }

        else
        {
          *p_dli_smach_port_name_t name = 0LL;
          a3->dli_saddr = 0LL;
          if (v29)
          {
            if ((*((_WORD *)v29 + 2) & 1) == 0)
            {
              uint64_t v17 = (dyld4::PseudoDylib *)*((void *)v29 + 13);
              if (v17) {
                dyld4::PseudoDylib::lookupAddress(v17, a2, a3);
              }
            }
          }
        }
      }

      uint64_t v15 = 1LL;
    }

    else
    {
      uint64_t v15 = 0LL;
      if (a2 >= &dword_180058000 && (unint64_t)a2 < 0x180258000LL)
      {
        unint64_t v21 = 0LL;
        int v22 = &v21;
        uint64_t v23 = 0x2000000000LL;
        char v24 = 0;
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 0x40000000LL;
        void v20[2] = ___ZN5dyld44APIs6dladdrEPKvP7dl_info_block_invoke;
        v20[3] = &unk_189620668;
        v20[5] = &dword_180058000;
        v20[6] = a2;
        v20[4] = &v21;
        dyld3::MachOFile::forEachSegment(&dword_180058000, (uint64_t)v20);
        if (*((_BYTE *)v22 + 24))
        {
          a3->dli_fmach_port_name_t name = "/usr/lib/dyld";
          a3->dli_fbase = &dword_180058000;
          if (dyld3::MachOLoaded::findClosestSymbol( (dyld3::MachOLoaded *)&dword_180058000,  (uint64_t)a2,  &a3->dli_sname,  &v19))
          {
            a3->dli_saddr = (void *)v19;
            dli_smach_port_name_t name = a3->dli_sname;
            if (*dli_sname == 95) {
              a3->dli_smach_port_name_t name = ++dli_sname;
            }
            if (!_platform_strcmp(dli_sname, "_ZN5dyld45startEPKNS_10KernelArgsE"))
            {
              a3->dli_smach_port_name_t name = "start";
              a3->dli_saddr = a2;
            }
          }
        }

        _Block_object_dispose(&v21, 8);
        uint64_t v15 = 0LL;
      }
    }

    *((void *)&v36 + 1) = v15;
    *(void *)&__int128 v37 = 0LL;
    *((void *)&v37 + 1) = a3->dli_fbase;
    *(void *)&__int128 v38 = 0LL;
    *((void *)&v38 + 1) = a3->dli_saddr;
    *(void *)&__int128 v39 = 0LL;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v32);
  return v15;
}

void *___ZN5dyld44APIs6dladdrEPKvP7dl_info_block_invoke(void *result, uint64_t a2, _BYTE *a3)
{
  unint64_t v3 = result[6];
  unint64_t v4 = result[5] + *(void *)(a2 + 16);
  if (v4 <= v3 && v3 < *(void *)(a2 + 24) + v4)
  {
    *(_BYTE *)(*(void *)(result[4] + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

vm_address_t *dyld4::APIs::setErrorString(vm_address_t *this, char *a2, ...)
{
  if (this[139] != -1LL)
  {
    uint64_t v2 = this;
    if (this[19])
    {
      this = (vm_address_t *)_simple_salloc();
      if (this)
      {
        unint64_t v4 = this;
        _simple_vsprintf((uint64_t)this, a2, (int *)va);
        uint64_t v5 = (const char *)_simple_string((_BYTE **)v4);
        size_t v6 = _platform_strlen(v5) + 17;
        uint64_t v7 = (size_t *)(*(uint64_t (**)(vm_address_t, vm_address_t))(*(void *)v2[19] + 64LL))( v2[19],  v2[139]);
        if (v7)
        {
          uint64_t v8 = (uint64_t)v7;
          if (*v7 >= v6)
          {
LABEL_10:
            unint64_t v9 = (const char *)_simple_string((_BYTE **)v4);
            strcpy((char *)(v8 + 9), v9);
            *(_BYTE *)(v8 + 8) = 1;
            return _simple_sfree(v4);
          }

          (*(void (**)(vm_address_t, size_t *))(*(void *)v2[19] + 16LL))(v2[19], v7);
        }

        if (v6 <= 0x100) {
          size_t v6 = 256LL;
        }
        uint64_t v8 = (*(uint64_t (**)(vm_address_t, size_t))(*(void *)v2[19] + 8LL))(v2[19], v6);
        *(void *)uint64_t v8 = v6;
        *(_BYTE *)(v8 + 8) = 0;
        (*(void (**)(vm_address_t, vm_address_t, uint64_t))(*(void *)v2[19] + 72LL))(v2[19], v2[139], v8);
        goto LABEL_10;
      }
    }
  }

  return this;
}

uint64_t dyld4::APIs::dlerror(dyld4::APIs *this)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dlerror()");
  }
  if (*((void *)this + 139) == -1LL) {
    return 0LL;
  }
  uint64_t result = *((void *)this + 19);
  if (!result) {
    return result;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 64LL))(result);
  if (!v3 || (uint64_t v4 = v3, !*(_BYTE *)(v3 + 8)))
  {
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log(this, " => NULL\n");
    }
    return 0LL;
  }

  *(_BYTE *)(v3 + 8) = 0;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, " => '%s'\n", (const char *)(v3 + 9));
  }
  return v4 + 9;
}

uint64_t ___ZN5dyld44APIs19findImageContainingEPv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(dyld4::RuntimeState **)(result + 40);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      size_t v6 = *v4;
      uint64_t result = dyld4::Loader::contains(*v4, v1, *(char **)(v3 + 48), (const void **)&v9, &v8, &v7);
      if ((_DWORD)result) {
        break;
      }
      ++v4;
      v5 -= 8LL;
      if (!v5) {
        return result;
      }
    }

    *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = v6;
  }

  return result;
}

uint64_t dyld4::APIs::dlopen(dyld4::APIs *this, const char *a2, uint64_t a3)
{
  return (*(uint64_t (**)(dyld4::APIs *, const char *, uint64_t, uint64_t))(*(void *)this + 776LL))( this,  a2,  a3,  v3);
}

unint64_t dyld4::APIs::dlopen_from( dyld4::RuntimeLocks **this, dyld4::Loader *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v9 = a3;
  uint64_t v158 = a2;
  int v157 = a3;
  int v148 = 520617984;
  uint64_t v149 = 0LL;
  v150 = a2;
  uint64_t v151 = (int)a3;
  __int128 v152 = 0u;
  __int128 v153 = 0u;
  __int128 v154 = 0u;
  __int128 v155 = 0u;
  __int128 v156 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v148, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "dlopen(%s, 0x%08X)\n", (const char *)a2, v9);
  }
  if (this[139] != (dyld4::RuntimeLocks *)-1LL)
  {
    unsigned __int8 v12 = this[19];
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(dyld4::RuntimeLocks *))(*(void *)v12 + 64LL))(v12);
      if (v13) {
        *(_BYTE *)(v13 + 8) = 0;
      }
    }
  }

  int v14 = v157;
  unsigned __int8 v147 = BYTE1(v157) & 1;
  if (!v158)
  {
    if ((v157 & 0x100) != 0) {
      unint64_t v23 = -5LL;
    }
    else {
      unint64_t v23 = -2LL;
    }
    goto LABEL_81;
  }

  uint64_t v15 = this[120];
  if (v15)
  {
    LODWORD(v14dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
    uint64_t v16 = dyld4::ProcessConfig::DyldCache::indexOfPath( (DyldSharedCache **)this[1] + 30,  (const char *)v158,  (unsigned int *)&v140);
    if ((_DWORD)v16)
    {
      unint64_t v19 = (dyld4::RuntimeLocks *)((char *)v15
                                  + *(unsigned int *)((char *)v15
                                                    + 4 * (unsigned __int16)v140
                                                    + *((unsigned int *)v15 + 4)));
      BOOL isInitialized = dyld4::PrebuiltLoader::isInitialized(v19, (const dyld4::RuntimeState *)this);
      if (isInitialized)
      {
        unint64_t v23 = (unint64_t)v19 ^ (unint64_t)&dword_180058000 | v147;
        if (*((_BYTE *)this[1] + 204))
        {
          char v24 = dyld4::Loader::leafName(v158, v21);
          dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "      dlopen(%s) => %p\n",  (const char *)v24,  (const void *)v23);
        }

        *((void *)&v153 + 1) = v23;
        *(void *)&__int128 v154 = 0LL;
        goto LABEL_81;
      }
    }

    int v14 = v157;
  }

  unsigned __int8 v25 = this[17];
  if ((v14 & 0x10) == 0) {
    dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
  }
  ImageContaining = (lsl::AllocatorLayout *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a4);
  fsobj_id v144 = 0LL;
  unint64_t v145 = 0LL;
  uint64_t v26 = lsl::AllocatorLayout::minSize(ImageContaining);
  __chkstk_darwin(v26, v27, v28, v29, v30, v31, v32, v33, (uint64_t)v122);
  __int128 v35 = (lsl::Allocator *)((char *)&v122 - (((unint64_t)v34 + 1103) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v36 = lsl::AllocatorLayout::minSize(v34);
  uint64_t v126 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v35, (char *)(v36 + 1088), v37, v38);
  v140 = v126;
  uint64_t v141 = 0LL;
  v142 = 0LL;
  uint64_t v143 = 0LL;
  __int128 v39 = (lsl::AllocatorLayout *)lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v140, 0x80uLL);
  uint64_t v40 = lsl::AllocatorLayout::minSize(v39);
  __chkstk_darwin(v40, v41, v42, v43, v44, v45, v46, v47, (uint64_t)v122);
  __int128 v49 = (lsl::Allocator *)((char *)&v122 - (((unint64_t)v48 + 207) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v50 = lsl::AllocatorLayout::minSize(v48);
  char v53 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v49, (char *)(v50 + 192), v51, v52);
  unint64_t v136 = v53;
  uint64_t v137 = 0LL;
  uint64_t v138 = 0LL;
  uint64_t v139 = 0LL;
  lsl::Vector<dyld4::RuntimeState::DynamicReference>::reserveExact((uint64_t)&v136, 8uLL);
  stat v55 = this[16];
  int v54 = this[17];
  v135[0] = this;
  v135[1] = &ImageContaining;
  v135[2] = &v157;
  v135[3] = &v144;
  v135[4] = &v158;
  v135[5] = &v145;
  v135[6] = &v147;
  v135[7] = &v136;
  v135[8] = &v140;
  lsl::MemoryManager::lockGuard(v55, &v131);
  uint64_t v56 = *((void *)v55 + 3);
  if (!v56)
  {
    lsl::MemoryManager::writeProtect(v55, 0);
    uint64_t v56 = *((void *)v55 + 3);
  }

  *((void *)v55 + 3) = v56 + 1;
  lsl::Lock::unlock(v131);
  if (*(void *)v54)
  {
    (*(void (**)(void, void *, void))(**(void **)v54 + 104LL))( *(void *)v54,  (void *)v54 + 1,  0LL);
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v135);
    (*(void (**)(void, void *))(**(void **)v54 + 112LL))(*(void *)v54, (void *)v54 + 1);
  }

  else
  {
    dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()((uint64_t)v135);
  }

  lsl::MemoryManager::lockGuard(v55, &v131);
  uint64_t v57 = *((void *)v55 + 3) - 1LL;
  *((void *)v55 + 3) = v57;
  if (!v57) {
    lsl::MemoryManager::writeProtect(v55, 1);
  }
  __int128 v58 = (lsl::AllocatorLayout *)lsl::Lock::unlock(v131);
  if (!v138) {
    goto LABEL_60;
  }
  unsigned int v125 = v53;
  uint64_t v66 = lsl::AllocatorLayout::minSize(v58);
  __chkstk_darwin(v66, v67, v68, v69, v70, v71, v72, v73, (uint64_t)v122);
  int v75 = (lsl::Allocator *)((char *)&v122 - (((unint64_t)v74 + 143) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v76 = lsl::AllocatorLayout::minSize(v74);
  unint64_t v79 = (lsl::Lock *)lsl::Allocator::stackAllocatorInternal(v75, (char *)(v76 + 128), v77, v78);
  int v131 = v79;
  uint64_t v132 = 0LL;
  uint64_t v133 = 0LL;
  uint64_t v134 = 0LL;
  uint64_t v80 = (lsl::AllocatorLayout *)lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v131, 8uLL);
  uint64_t v81 = v138;
  if (!v138) {
    goto LABEL_57;
  }
  uint64_t v122 = v79;
  char v123 = v25;
  int v124 = v14;
  char v82 = 0;
  uint64_t v83 = 0LL;
  while (1)
  {
    uint64_t v84 = v137;
    unsigned int v85 = (uint64_t *)(v137 + 16 * v83);
    if (v133)
    {
      uint64_t v86 = 8 * v133;
      uint64_t v87 = v132;
      while (*v87 != *v85)
      {
        ++v87;
        v86 -= 8LL;
        if (!v86)
        {
          uint64_t v87 = &v132[v133];
          break;
        }
      }
    }

    else
    {
      uint64_t v87 = v132;
    }

    if (v133 == v87 - v132) {
      break;
    }
    uint64_t v105 = v83 + 1;
LABEL_54:
    uint64_t v83 = v105;
    if (v105 == v81) {
      goto LABEL_55;
    }
  }

  uint64_t v88 = lsl::AllocatorLayout::minSize(v80);
  __chkstk_darwin(v88, v89, v90, v91, v92, v93, v94, v95, (uint64_t)v122);
  char v97 = (lsl::Allocator *)((char *)&v122 - (((unint64_t)v96 + 143) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v98 = lsl::AllocatorLayout::minSize(v96);
  uint64_t v101 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v97, (char *)(v98 + 128), v99, v100);
  uint64_t v127 = v101;
  uint64_t v129 = 0LL;
  uint64_t v130 = 0LL;
  uint64_t v128 = 0LL;
  lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v127, 8uLL);
  lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v127, v129 + 1);
  uint64_t v102 = *(void *)(v84 + 16 * v83 + 8);
  uint64_t v103 = v129;
  uint64_t v104 = ++v129;
  *(void *)(v128 + 8 * v103) = v102;
  uint64_t v105 = v83 + 1;
  uint64_t v106 = v138;
  if (v83 + 1 != v138)
  {
    uint64_t v107 = 16 * v83;
    uint64_t v108 = v105;
    do
    {
      uint64_t v109 = v137 + v107;
      if (*(void *)(v137 + v107 + 16) == *v85)
      {
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v127, v104 + 1);
        uint64_t v110 = *(void *)(v109 + 24);
        uint64_t v111 = v129;
        uint64_t v104 = ++v129;
        *(void *)(v128 + 8 * v111) = v110;
        uint64_t v106 = v138;
      }

      ++v108;
      v107 += 16LL;
    }

    while (v108 != v106);
  }

  uint64_t v112 = *v85;
  if ((*(_WORD *)(*v85 + 4) & 1) != 0) {
    uint64_t v112 = 0LL;
  }
  unsigned int v113 = *(uint64_t (****)(char *))(v112 + 104);
  uint64_t v114 = (const char *)dyld4::PseudoDylib::finalizeRequestedSymbols(v113, v128, v104);
  uint64_t v115 = (char *)v114;
  if (v114)
  {
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen(%s, 0x%04X): %s", (const char *)v158, v157, v114);
    dyld4::PseudoDylib::disposeString(v113, v115);
    char v82 = 1;
  }

  else
  {
    lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v131, v133 + 1);
    uint64_t v116 = *v85;
    uint64_t v117 = v133++;
    v132[v117] = v116;
  }

  if (v128) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v127, 0LL);
  }
  lsl::Allocator::~Allocator(v101);
  if (!v115)
  {
    uint64_t v81 = v138;
    goto LABEL_54;
  }

LABEL_57:
  if (v132) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v131, 0LL);
  }
  lsl::Allocator::~Allocator(v79);
  char v53 = v125;
LABEL_60:
  if (v144 && (v157 & 0x10) == 0)
  {
    if (v142)
    {
      int v131 = v141;
      uint64_t v132 = v142;
      dyld4::RuntimeState::notifyLoad((const dyld4::RuntimeState *)this, (uint64_t)&v131, v60, v61, v62, v63, v64, v65);
    }

    if (*((_BYTE *)this + 648))
    {
      __int128 v58 = (lsl::AllocatorLayout *)dyld4::Loader::runInitializersBottomUpPlusUpwardLinks( v144,  (dyld4::RuntimeState *)this);
    }

    else if (*((_BYTE *)this[1] + 203))
    {
      unint64_t v118 = (const char *)dyld4::Loader::path(v144, (const dyld4::RuntimeState *)this);
      dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "dlopen() within libSystem's initializer, so skipping initialization of %s\n",  v118);
    }

    unint64_t v145 = (unint64_t)v144 ^ (unint64_t)&dword_180058000 | v147;
  }

  if (*((_BYTE *)this[1] + 204))
  {
    uint64_t v119 = (*(uint64_t (**)(dyld4::RuntimeLocks *, dyld4::RuntimeLocks *))(*(void *)this[19] + 64LL))( this[19],  this[139]);
    if (v119 && *(_BYTE *)(v119 + 8))
    {
      dyld4::Loader::leafName(v158, v120);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => NULL, '%s'\n");
    }

    else
    {
      dyld4::Loader::leafName(v158, v120);
      dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "      dlopen(%s) => %p\n");
    }
  }

  unint64_t v23 = v145;
  *((void *)&v153 + 1) = v145;
  *(void *)&__int128 v154 = 0LL;
  if (v137) {
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((os_unfair_lock_s *)&v136, 0LL);
  }
  lsl::Allocator::~Allocator(v53);
  if (v141) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v140, 0LL);
  }
  lsl::Allocator::~Allocator(v126);
  if ((v14 & 0x10) == 0) {
    dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v25);
  }
LABEL_81:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v148);
  return v23;
}

  ++*(_DWORD *)(*(void *)(v30 + 8) + 24LL);
  return result;
}

uint64_t dyld4::APIs::dlclose(dyld4::APIs *this, unint64_t a2)
{
  uint64_t v4 = (dyld4::RuntimeLocks *)*((void *)this + 17);
  dyld4::RuntimeLocks::takeDlopenLockBeforeFork(v4);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dlclose(%p)\n", (const void *)a2);
  }
  int v17 = 520617992;
  unint64_t v18 = a2;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v17, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v12 = 0LL;
  if (a2 != -5LL && a2 != -2LL)
  {
    if (a2) {
      uint64_t v13 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_180058000);
    }
    else {
      uint64_t v13 = 0LL;
    }
    if (dyld4::APIs::validLoader((lsl::Allocator **)this, v13))
    {
      dyld4::RuntimeState::decDlRefCount((os_unfair_lock_s *)this, v13);
      if (*((void *)this + 139) != -1LL
        && (uint64_t v14 = *((void *)this + 19)) != 0
        && (uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 64LL))(v14)) != 0)
      {
        uint64_t v12 = 0LL;
        *(_BYTE *)(v15 + 8) = 0;
      }

      else
      {
        uint64_t v12 = 0LL;
      }
    }

    else
    {
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlclose(%p): invalid handle", (const void *)a2);
      uint64_t v12 = 0xFFFFFFFFLL;
    }
  }

  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v17);
  dyld4::RuntimeLocks::releaseDlopenLockInForkParent(v4);
  return v12;
}

BOOL dyld4::APIs::dlopen_preflight( dyld4::APIs *this, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v34 = 520617988;
  uint64_t v35 = 0LL;
  uint64_t v36 = a2;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  uint64_t v42 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v34, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *((void *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "dlopen_preflight(%s)\n", a2);
    uint64_t v10 = *((void *)this + 1);
  }

  uint64_t v11 = *(DyldSharedCache **)(v10 + 240);
  if (v11)
  {
    if ((DyldSharedCache::hasImagePath(*(DyldSharedCache **)(v10 + 240), a2, &v33) & 1) != 0)
    {
LABEL_12:
      __int128 v39 = xmmword_1800B7B20;
      BOOL v14 = 1LL;
      goto LABEL_19;
    }

    uint64_t v10 = *((void *)this + 1);
  }

  if (dyld4::SyscallDelegate::realpath((dyld4::SyscallDelegate *)v10, (dyld3 *)a2, __s2))
  {
    int v12 = _platform_strcmp(a2, __s2);
    BOOL v13 = !v11 || v12 == 0;
  }

  char v32 = 0;
  uint64_t v28 = 0LL;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2000000000LL;
  char v31 = 0;
  uint64_t v22 = 0LL;
  __int128 v23 = &v22;
  uint64_t v24 = 0x3002000000LL;
  unsigned __int8 v25 = __Block_byref_object_copy__6;
  uint64_t v26 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v27);
  uint64_t v15 = *((void *)this + 1);
  uint64_t v16 = (const char *)*(unsigned int *)(v15 + 68);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000LL;
  _OWORD v21[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke;
  void v21[3] = &unk_1896206E0;
  void v21[6] = this;
  void v21[7] = a2;
  v21[4] = &v28;
  uint64_t v21[5] = &v22;
  dyld4::ProcessConfig::PathOverrides::forEachPathVariant(v15 + 400, (dyld4::Utils *)a2, v16, 0, 1, &v32, (uint64_t)v21);
  if (!*((_BYTE *)v29 + 24) && Diagnostics::hasError((Diagnostics *)(v23 + 5)))
  {
    unint64_t v18 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v23 + 5));
    dyld4::APIs::setErrorString((vm_address_t *)this, "dlopen_preflight(%s) => false, %s", a2, v18);
  }

  if (*(_BYTE *)(*((void *)this + 1) + 204LL))
  {
    __int128 v19 = dyld4::Loader::leafName((dyld4::Loader *)a2, v17);
    dyld4::RuntimeState::log( this,  "      dlopen_preflight(%s) => %d\n",  (const char *)v19,  *((unsigned __int8 *)v29 + 24));
  }

  BOOL v14 = *((_BYTE *)v29 + 24) != 0;
  __int128 v39 = *((unsigned __int8 *)v29 + 24);
  _Block_object_dispose(&v22, 8);
  mach_o::Error::~Error(&v27);
  _Block_object_dispose(&v28, 8);
LABEL_19:
  dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v34);
  return v14;
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 40);
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke(void *a1, dyld3 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1[6];
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x3002000000LL;
  unint64_t v18 = __Block_byref_object_copy__6;
  __int128 v19 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v20);
  uint64_t v8 = *(void *)(v7 + 8);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  _WORD v14[2] = ___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke_2;
  void v14[3] = &unk_1896206B8;
  uint64_t v9 = a1[7];
  void v14[6] = v7;
  void v14[7] = v9;
  uint64_t v10 = a1[4];
  v14[4] = &v15;
  void v14[5] = v10;
  void v14[8] = a4;
  dyld4::SyscallDelegate::withReadOnlyMappedFile(v8, (vm_address_t *)v16 + 5, a2, 1, (uint64_t)v14);
  if (!*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) && Diagnostics::hasError((Diagnostics *)(v16 + 5)))
  {
    BOOL v11 = Diagnostics::noError((Diagnostics *)(*(void *)(a1[5] + 8LL) + 40LL));
    int v12 = (vm_address_t *)(*(void *)(a1[5] + 8LL) + 40LL);
    BOOL v13 = (const char *)Diagnostics::errorMessage((Diagnostics *)(v16 + 5));
    if (v11) {
      Diagnostics::error(v12, "tried: '%s' (%s)", (const char *)a2, v13);
    }
    else {
      Diagnostics::appendError(v12, ", '%s' (%s)", (const char *)a2, v13);
    }
  }

  _Block_object_dispose(&v15, 8);
  mach_o::Error::~Error(&v20);
}

int *___ZN5dyld44APIs16dlopen_preflightEPKc_block_invoke_2( uint64_t a1, dyld3::FatFile *this, unint64_t a3, int a4)
{
  unint64_t v6 = 0LL;
  uint64_t result = dyld3::MachOFile::compatibleSlice( (vm_address_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  &v6,  this,  a3,  *(const char **)(a1 + 56),  *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 68LL),  a4,  *(dyld3::GradedArchs **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 144LL),  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 169LL));
  if (result)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
    **(_BYTE **)(a1 + 64) = 1;
  }

  return result;
}

uint64_t dyld4::APIs::dlopen_audited(dyld4::APIs *this, const char *a2)
{
  return (*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 112LL))(this, a2);
}

const void *dyld4::APIs::dlsym( dyld4::APIs *this, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v84 = 520617996;
  uint64_t v85 = a2;
  uint64_t v86 = 0LL;
  uint64_t v87 = 0LL;
  uint64_t v88 = a3;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v92 = 0u;
  uint64_t v93 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v84, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dlsym(%p, %s)\n", (const void *)a2, a3);
  }
  if (*((void *)this + 139) != -1LL)
  {
    uint64_t v12 = *((void *)this + 19);
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 64LL))(v12);
      if (v13) {
        *(_BYTE *)(v13 + 8) = 0;
      }
    }
  }

  if (!_platform_strcmp(a3, "pthread_jit_write_with_callback_np")
    || !_platform_strncmp(a3, "se_memory_inline_jit", 0x14uLL))
  {
    goto LABEL_12;
  }

  if (dyld4::APIs::addressLookupsDisabled(this, a3))
  {
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log(this, "     dlsym(%s) => NULL (blocked)\n", a3);
    }
LABEL_12:
    BOOL v14 = 0LL;
    goto LABEL_13;
  }

  size_t v16 = _platform_strlen(a3);
  __chkstk_darwin(v16, v17, v18, v19, v20, v21, v22, v23, v66);
  unsigned __int8 v25 = (char *)&v67[-1] - ((v24 + 17) & 0xFFFFFFFFFFFFFFF0LL);
  *unsigned __int8 v25 = 95;
  strlcpy(v25 + 1, a3, v24 + 1);
  uint64_t v78 = 0LL;
  unint64_t v79 = &v78;
  uint64_t v80 = 0x3002000000LL;
  uint64_t v81 = __Block_byref_object_copy__6;
  char v82 = __Block_byref_object_dispose__6;
  Diagnostics::Diagnostics((Diagnostics *)&v83);
  uint64_t v72 = 0LL;
  uint64_t v73 = &v72;
  uint64_t v74 = 0x5002000000LL;
  int v75 = __Block_byref_object_copy__95;
  uint64_t v76 = __Block_byref_object_dispose__96;
  int v26 = 0;
  uint64_t v27 = 0LL;
  switch(a2)
  {
    case -5LL:
      if ((dyld4::Loader::hasExportedSymbol( *((void *)this + 3),  (vm_address_t *)v79 + 5,  this,  (const unsigned __int8 *)v25,  0,  1,  v77,  0LL) & 1) != 0) {
        goto LABEL_31;
      }
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_MAIN_ONLY, %s): symbol not found");
      goto LABEL_51;
    case -3LL:
      uint64_t ImageContaining = dyld4::APIs::findImageContaining(this, v8);
      if (!ImageContaining)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): called by unknown image (caller=%p)");
        goto LABEL_51;
      }

      __chkstk_darwin(ImageContaining, v40, v41, v42, v43, v44, v45, v46, v66);
      vm_size_t v48 = (uint64_t *)*((void *)this + 6);
      uint64_t v68 = (uint64_t)&v67[-1] - ((v47 + 23) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v69 = v48;
      uint64_t v70 = 0LL;
      if ((dyld4::Loader::hasExportedSymbol( v49,  (vm_address_t *)v79 + 5,  this,  (const unsigned __int8 *)v25,  3u,  0,  v73 + 5,  &v68) & 1) != 0) {
        goto LABEL_31;
      }
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_SELF, %s): symbol not found");
      goto LABEL_54;
    case -2LL:
      uint64_t v68 = 0LL;
      uint64_t v69 = &v68;
      uint64_t v70 = 0x2000000000LL;
      char v71 = 0;
      uint64_t v50 = (void *)*((void *)this + 17);
      v67[0] = _NSConcreteStackBlock;
      v67[1] = 0x40000000LL;
      v67[2] = ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke;
      vm_address_t v67[3] = &unk_189620708;
      v67[7] = this;
      v67[8] = v25;
      v67[4] = &v78;
      v67[5] = &v72;
      v67[6] = &v68;
      dyld4::RuntimeLocks::withLoadersReadLock(v50, (uint64_t)v67);
      if (*((_BYTE *)v69 + 24))
      {
        _Block_object_dispose(&v68, 8);
        goto LABEL_31;
      }

      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_DEFAULT, %s): symbol not found", a3);
      if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
        dyld4::RuntimeState::log(this, "     dlsym(%s) => NULL\n", a3);
      }
      _Block_object_dispose(&v68, 8);
      goto LABEL_56;
    case -1LL:
      uint64_t v51 = dyld4::APIs::findImageContaining(this, v8);
      if (!v51)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): called by unknown image (caller=%p)");
        goto LABEL_51;
      }

      __chkstk_darwin(v51, v52, v53, v54, v55, v56, v57, v58, v66);
      unsigned int v60 = (uint64_t *)*((void *)this + 6);
      uint64_t v68 = (uint64_t)&v67[-1] - ((v59 + 23) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v69 = v60;
      uint64_t v70 = 0LL;
      if ((dyld4::Loader::hasExportedSymbol( v61,  (vm_address_t *)v79 + 5,  this,  (const unsigned __int8 *)v25,  2u,  0,  v73 + 5,  &v68) & 1) != 0) {
        goto LABEL_31;
      }
      dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(RTLD_NEXT, %s): symbol not found");
LABEL_54:
      if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
        goto LABEL_55;
      }
      goto LABEL_56;
    case 0LL:
      goto LABEL_18;
    default:
      int v26 = a2 & 1;
      uint64_t v27 = (const dyld4::Loader *)(a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_180058000);
LABEL_18:
      BOOL valid = dyld4::APIs::validLoader((lsl::Allocator **)this, v27);
      if (!valid)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): invalid handle");
        goto LABEL_51;
      }

      __chkstk_darwin(valid, v29, v30, v31, v32, v33, v34, v35, v66);
      __int128 v37 = (uint64_t *)*((void *)this + 6);
      uint64_t v68 = (uint64_t)&v67[-1] - ((v36 + 23) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v69 = v37;
      uint64_t v70 = 0LL;
      if (v26) {
        unsigned int v38 = 0;
      }
      else {
        unsigned int v38 = 3;
      }
      if ((dyld4::Loader::hasExportedSymbol( (uint64_t)v27,  (vm_address_t *)v79 + 5,  this,  (const unsigned __int8 *)v25,  v38,  0,  v73 + 5,  &v68) & 1) == 0)
      {
        dyld4::APIs::setErrorString((vm_address_t *)this, "dlsym(%p, %s): symbol not found", (const void *)a2, a3);
        if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
          dyld4::RuntimeState::log(this, "     dlsym(%s) => NULL\n", a3);
        }
        goto LABEL_56;
      }

uint64_t dyld4::APIs::addressLookupsDisabled(dyld4::APIs *this, const char *__little)
{
  uint64_t v4 = *((void *)this + 1);
  if (__little && (uint64_t v5 = *(const char **)(v4 + 176)) != 0LL)
  {
    unint64_t v6 = strstr(v5, __little);
    if (v6)
    {
      int v7 = *(v6 - 1);
      int v8 = v6[_platform_strlen(__little)];
      BOOL v9 = v8 == 58 || v8 == 0;
      if (v9 && v7 == 58) {
        return 0LL;
      }
    }
  }

  else if (*(_BYTE *)(v4 + 170))
  {
    goto LABEL_14;
  }

  uint64_t v10 = (void (*)(const char *))*((void *)this + 119);
  if (v10) {
    v10(__little);
  }
LABEL_14:
  uint64_t v11 = *((void *)this + 1);
  if (!*(_BYTE *)(v11 + 170)) {
    return 0LL;
  }
  if (*(_BYTE *)(v11 + 171))
  {
    v13[0] = 10LL;
    v13[1] = 0LL;
    uint64_t v13[2] = 0LL;
    void v13[3] = (uint64_t)__little;
    dyld4::halt("symbol address lookup (dlsym) disabled in process", v13);
  }

  return 1LL;
}

__n128 __Block_byref_object_copy__95(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

unint64_t ___ZN5dyld44APIs5dlsymEPvPKc_block_invoke(unint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 56);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    unint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      unint64_t v6 = *v4;
      __n128 result = dyld4::Loader::hiddenFromFlat(*v4, 0);
      if ((result & 1) == 0)
      {
        __n128 result = dyld4::Loader::hasExportedSymbol( (uint64_t)v6,  (vm_address_t *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 40LL),  v1,  *(const unsigned __int8 **)(v3 + 64),  1u,  0,  (uint64_t *)(*(void *)(*(void *)(v3 + 40) + 8LL) + 40LL),  0LL);
        if ((_DWORD)result) {
          break;
        }
      }

      ++v4;
      v5 -= 8LL;
      if (!v5) {
        return result;
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL) = 1;
  }

  return result;
}

BOOL dyld4::APIs::dyld_shared_cache_some_image_overridden(dyld4::APIs *this)
{
  int v1 = *((unsigned __int8 *)this + 1126);
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log( this,  "dyld_shared_cache_some_image_overridden() => %d\n",  *((unsigned __int8 *)this + 1126));
  }
  return v1 != 0;
}

BOOL dyld4::APIs::_dyld_get_shared_cache_uuid(dyld4::APIs *this, __n128 *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if (*(_BYTE *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_uuid(%p)\n", a2);
    uint64_t v3 = *((void *)this + 1);
  }

  uint64_t v5 = *(void *)(v3 + 240);
  if (v5) {
    DyldSharedCache::getUUID(*(DyldSharedCache **)(v3 + 240), a2);
  }
  return v5 != 0;
}

const void *dyld4::APIs::_dyld_get_shared_cache_range(dyld4::APIs *this, unint64_t *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (*(_BYTE *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_shared_cache_range(%p)", a2);
    uint64_t v4 = *((void *)this + 1);
  }

  *a2 = 0LL;
  uint64_t v5 = *(const void **)(v4 + 240);
  if (v5)
  {
    unint64_t v6 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v4 + 240));
    *a2 = v6;
    uint64_t v4 = *((void *)this + 1);
  }

  else
  {
    unint64_t v6 = 0LL;
  }

  if (*(_BYTE *)(v4 + 204)) {
    dyld4::RuntimeState::log(this, " => %p,0x%lX\n", v5, v6);
  }
  return v5;
}

BOOL dyld4::APIs::_dyld_shared_cache_optimized(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(void *)(v1 + 240);
  if (v2) {
    BOOL v3 = *(void *)(v2 + 104) == 1LL;
  }
  else {
    BOOL v3 = 0LL;
  }
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_optimized() => %d\n", v3);
  }
  return v3;
}

void dyld4::APIs::_dyld_images_for_addresses( dyld4::RuntimeState *this, unsigned int a2, char **a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = a3;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_images_for_addresses(%d, %p, %p)\n", a2, a3, a4);
  }
  uint64_t v18 = 0LL;
  if (a2)
  {
    int v8 = 0LL;
    for (uint64_t i = a2; i; --i)
    {
      uint64_t v10 = *v5;
      bzero(v4, 0x20uLL);
      uint64_t v11 = v18;
      if (v18) {
        BOOL v12 = v10 >= (char *)v18;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12 && v10 <= v8) {
        goto LABEL_15;
      }
      if ((dyld4::APIs::findImageMappedAt(this, v10, &v18, &v17, (const char **)&v16, &v15, &v14, 0LL, 0LL) & 1) == 0)
      {
        uint64_t v18 = 0LL;
        goto LABEL_17;
      }

      uint64_t v11 = v18;
      int v8 = (char *)v18 + v14;
      if (v18)
      {
LABEL_15:
        v4[2] = v10 - (char *)v11;
        void v4[3] = v11;
        dyld3::MachOFile::getUuid(v11, (unsigned __int8 *)v4);
      }

os_unfair_lock_s *dyld4::APIs::_dyld_register_for_image_loads( lsl::Lock **this, void (*a2)(const mach_header *, const char *, BOOL))
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_image_loads(%p)\n", a2);
  }
  uint64_t v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  __int128 v11[2] = ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke;
  void v11[3] = &__block_descriptor_tmp_117;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  uint64_t ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  unint64_t v6 = this[16];
  int v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v8 = *((void *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    uint64_t v8 = *((void *)v6 + 3);
  }

  *((void *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(void *)v7)
  {
    (*(void (**)(void, void *, void))(**(void **)v7 + 104LL))(*(void *)v7, (void *)v7 + 2, 0LL);
    dyld4::RuntimeState::addNotifyLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(void, void *))(**(void **)v7 + 112LL))(*(void *)v7, (void *)v7 + 2);
  }

  else
  {
    dyld4::RuntimeState::addNotifyLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
  }

  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v9 = *((void *)v6 + 3) - 1LL;
  *((void *)v6 + 3) = v9;
  if (!v9) {
    lsl::MemoryManager::writeProtect(v6, 1);
  }
  return lsl::Lock::unlock(v12);
}

uint64_t ___ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke( uint64_t result)
{
  uint64_t v1 = *(const dyld4::RuntimeState **)(result + 32);
  uint64_t v2 = *((void *)v1 + 6);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (dyld4::Loader **)*((void *)v1 + 5);
    uint64_t v5 = 8 * v2;
    do
    {
      unint64_t v6 = *v4;
      unint64_t Address = (const void *)dyld4::Loader::loadAddress(*v4, v1);
      uint64_t v8 = Address;
      if (*(_BYTE *)(*((void *)v1 + 1) + 205LL)) {
        dyld4::RuntimeState::log(v1, "add notifier %p called with mh=%p\n", *(const void **)(v3 + 40), Address);
      }
      uint64_t v9 = *(uint64_t (**)(const void *, uint64_t, BOOL))(v3 + 40);
      uint64_t v10 = dyld4::Loader::path(v6, v1);
      __n128 result = v9(v8, v10, (*((_WORD *)v6 + 2) & 0x20) == 0);
      ++v4;
      v5 -= 8LL;
    }

    while (v5);
  }

  return result;
}

os_unfair_lock_s *dyld4::APIs::_dyld_register_for_bulk_image_loads( lsl::Lock **this, void (*a2)(unsigned int, const mach_header **, const char **))
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_register_for_bulk_image_loads(%p)\n", a2);
  }
  uint64_t v4 = this[17];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  __int128 v11[2] = ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke;
  void v11[3] = &__block_descriptor_tmp_121_0;
  v11[4] = this;
  v11[5] = a2;
  dyld4::RuntimeLocks::withLoadersReadLock(v4, (uint64_t)v11);
  uint64_t ImageContaining = (const dyld4::Loader *)dyld4::APIs::findImageContaining((dyld4::APIs *)this, a2);
  unint64_t v6 = this[16];
  int v7 = this[17];
  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v8 = *((void *)v6 + 3);
  if (!v8)
  {
    lsl::MemoryManager::writeProtect(v6, 0);
    uint64_t v8 = *((void *)v6 + 3);
  }

  *((void *)v6 + 3) = v8 + 1;
  lsl::Lock::unlock(v12);
  if (*(void *)v7)
  {
    (*(void (**)(void, void *, void))(**(void **)v7 + 104LL))(*(void *)v7, (void *)v7 + 2, 0LL);
    dyld4::RuntimeState::addNotifyBulkLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
    (*(void (**)(void, void *))(**(void **)v7 + 112LL))(*(void *)v7, (void *)v7 + 2);
  }

  else
  {
    dyld4::RuntimeState::addNotifyBulkLoadImage((dyld4::RuntimeState *)this, ImageContaining, a2);
  }

  lsl::MemoryManager::lockGuard(v6, &v12);
  uint64_t v9 = *((void *)v6 + 3) - 1LL;
  *((void *)v6 + 3) = v9;
  if (!v9) {
    lsl::MemoryManager::writeProtect(v6, 1);
  }
  return lsl::Lock::unlock(v12);
}

uint64_t ___ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(const dyld4::RuntimeState **)(a1 + 32);
  uint64_t v10 = *((void *)v9 + 6);
  uint64_t v11 = 8LL * v10;
  __chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, v25);
  BOOL v12 = (char *)&v25 - ((v11 + 15) & 0xFFFFFFFF0LL);
  __chkstk_darwin(v13, v14, v15, v16, v17, v18, v19, v20, v25);
  uint64_t v22 = (char *)&v25 - v21;
  if ((_DWORD)v10)
  {
    uint64_t v23 = 0LL;
    do
    {
      *(void *)&v12[v23] = dyld4::Loader::loadAddress(*(dyld4::Loader **)(*((void *)v9 + 5) + v23), v9);
      *(void *)&v22[v23] = dyld4::Loader::path(*(dyld4::Loader **)(*((void *)v9 + 5) + v23), v9);
      v23 += 8LL;
    }

    while (v11 != v23);
  }

  if (*(_BYTE *)(*((void *)v9 + 1) + 205LL)) {
    dyld4::RuntimeState::log(v9, "add bulk notifier %p called with %d images\n", *(const void **)(a1 + 40), v10);
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(a1 + 40))(v10, v12, v22);
}

uint64_t dyld4::APIs::_dyld_find_unwind_sections(dyld4::APIs *this, char *a2, dyld3::MachOLoaded **a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_find_unwind_sections(%p, %p)\n", a2, a3);
  }
  uint64_t v18 = 0LL;
  uint64_t ImageMappedAt = dyld4::APIs::findImageMappedAt(this, a2, &v19, 0LL, 0LL, 0LL, 0LL, 0LL, &v18);
  if ((_DWORD)ImageMappedAt)
  {
    uint64_t v8 = v18;
    int v7 = v19;
    *a3 = v19;
    *(_OWORD *)(a3 + 1) = 0u;
    *(_OWORD *)(a3 + 3) = 0u;
    if (!v8) {
      goto LABEL_13;
    }
    if ((*((_WORD *)v8 + 2) & 1) != 0) {
      goto LABEL_13;
    }
    uint64_t v9 = (uint64_t (***)(char *))*((void *)v8 + 13);
    if (!v9) {
      goto LABEL_13;
    }
    LOBYTE(v17) = 0;
    UnwindSections = (const char *)dyld4::PseudoDylib::findUnwindSections(v9, (uint64_t)a2, (uint64_t)&v17, (uint64_t)a3);
    if (UnwindSections)
    {
      uint64_t v11 = (char *)UnwindSections;
      if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
        dyld4::RuntimeState::log( this,  "_dyld_pseudodylib_find_unwind_sections(%p, %p) returned error: %s",  a2,  a3,  UnwindSections);
      }
      dyld4::PseudoDylib::disposeString(v9, v11);
    }

    if (!(_BYTE)v17)
    {
      int v7 = v19;
LABEL_13:
      uint64_t SectionContent = dyld3::MachOLoaded::findSectionContent(v7, "__TEXT", "__eh_frame", &v17);
      if (SectionContent)
      {
        unint64_t v13 = v17;
        a3[1] = (dyld3::MachOLoaded *)SectionContent;
        a3[2] = (dyld3::MachOLoaded *)v13;
      }

      uint64_t v14 = dyld3::MachOLoaded::findSectionContent(v19, "__TEXT", "__unwind_info", &v17);
      if (v14)
      {
        unint64_t v15 = v17;
        a3[3] = (dyld3::MachOLoaded *)v14;
        a3[4] = (dyld3::MachOLoaded *)v15;
      }
    }
  }

  return ImageMappedAt;
}

BOOL dyld4::APIs::dyld_process_is_restricted(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(_BYTE *)(v1 + 204)) {
    return *(_BYTE *)(v1 + 186) == 0;
  }
  dyld4::RuntimeState::log(this, "dyld_process_is_restricted()");
  uint64_t v3 = *((void *)this + 1);
  int v4 = *(unsigned __int8 *)(v3 + 204);
  int v5 = *(unsigned __int8 *)(v3 + 186);
  BOOL v6 = v5 == 0;
  if (v4) {
    dyld4::RuntimeState::log(this, " => %d\n", v5 == 0);
  }
  return v6;
}

const char *dyld4::APIs::dyld_shared_cache_file_path(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(const char **)(v1 + 280);
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_file_path() => %s\n", v2);
  }
  return v2;
}

BOOL dyld4::APIs::dyld_has_inserted_or_interposing_libraries(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*((void *)this + 22)) {
    BOOL v2 = 1LL;
  }
  else {
    BOOL v2 = *(_DWORD *)(v1 + 540) != 0;
  }
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "dyld_has_inserted_or_interposing_libraries() => %d\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::dyld_shared_cache_find_iterate_text( dyld4::RuntimeState *this, dyld4::RuntimeState *a2, char **a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v9 = *((void *)this + 1);
  if (*(_BYTE *)(v9 + 204))
  {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_find_iterate_text()\n");
    uint64_t v9 = *((void *)this + 1);
  }

  size_t v25 = 0LL;
  CacheInDirAndMap = *(void **)(v9 + 240);
  if (!CacheInDirAndMap
    || ((DyldSharedCache::getUUID(*(DyldSharedCache **)(v9 + 240), &v26), v26.n128_u64[0] == *(void *)a2)
      ? (BOOL v11 = v26.n128_u64[1] == *((void *)a2 + 1))
      : (BOOL v11 = 0),
        !v11))
  {
    CacheInDirAndMap = (void *)dyld4::findCacheInDirAndMap( this,  a2,  "/System/Library/Caches/com.apple.dyld/",  (const char *)&v25,  a5);
    if (!CacheInDirAndMap)
    {
      uint64_t v12 = 0LL;
      while (1)
      {
        unint64_t v13 = cryptexPrefixes[v12];
        v26.n128_u8[0] = 0;
        if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v13, (const char *)0x400) <= 0x3FF
          && dyld4::Utils::concatenatePaths( (dyld4::Utils *)&v26,  "/System/Library/Caches/com.apple.dyld/",  (const char *)0x400) <= 0x3FF)
        {
          uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, (char *)&v26, (const char *)&v25, v14);
          if (v15) {
            break;
          }
        }

        if (++v12 == 3)
        {
          CacheInDirAndMap = (void *)dyld4::findCacheInDirAndMap( this,  a2,  "/System/DriverKit/System/Library/dyld/",  (const char *)&v25,  v14);
          if (CacheInDirAndMap) {
            goto LABEL_26;
          }
          uint64_t v16 = 0LL;
          while (1)
          {
            unint64_t v17 = cryptexPrefixes[v16];
            v26.n128_u8[0] = 0;
            if (dyld4::Utils::concatenatePaths((dyld4::Utils *)&v26, v17, (const char *)0x400) <= 0x3FF
              && dyld4::Utils::concatenatePaths( (dyld4::Utils *)&v26,  "/System/DriverKit/System/Library/dyld/",  (const char *)0x400) <= 0x3FF)
            {
              uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, (char *)&v26, (const char *)&v25, v18);
              if (v15) {
                goto LABEL_25;
              }
            }

            if (++v16 == 3)
            {
              uint64_t v19 = *a3;
              if (!*a3) {
                return 0xFFFFFFFFLL;
              }
              uint64_t v20 = a3 + 1;
              while (1)
              {
                uint64_t v15 = dyld4::findCacheInDirAndMap(this, a2, v19, (const char *)&v25, v18);
                if (v15) {
                  break;
                }
                uint64_t v21 = *v20++;
                uint64_t v19 = v21;
                uint64_t result = 0xFFFFFFFFLL;
                if (!v21) {
                  return result;
                }
              }

              goto LABEL_25;
            }
          }
        }
      }

LABEL_26:
  v26.n128_u64[0] = 0LL;
  v26.n128_u64[1] = (unint64_t)&v26;
  uint64_t v27 = 0x2000000000LL;
  uint64_t v28 = 0LL;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000LL;
  _OWORD v24[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke;
  v24[3] = &unk_189620788;
  v24[4] = &v26;
  DyldSharedCache::forEachRegion((uint64_t)CacheInDirAndMap, (uint64_t)v24);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000LL;
  v23[2] = ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2;
  v23[3] = &unk_1896207B0;
  void v23[4] = a4;
  v23[5] = &v26;
  DyldSharedCache::forEachImageTextSegment((uint64_t)CacheInDirAndMap, (uint64_t)v23);
  if (v25) {
    munmap(CacheInDirAndMap, v25);
  }
  _Block_object_dispose(&v26, 8);
  return 0LL;
}

      int v7 = v42 + 1;
      int v5 = a2[2];
      uint64_t v8 = v44;
    }

    while (v42 + 1 != v5);
  }

  return result;
}

      std::__throw_bad_optional_access[abi:nn180100]();
    }

uint64_t dyld4::findCacheInDirAndMap( dyld4 *this, dyld4::RuntimeState *a2, char *a3, const char *a4, unint64_t *a5)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  uint64_t v12 = 0LL;
  uint64_t v5 = *((void *)this + 1);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke;
  v8[3] = &unk_189620CD8;
  void v8[4] = &v9;
  v8[5] = a2;
  void v8[6] = a4;
  dyld4::SyscallDelegate::forEachInDirectory(v5, a3, 0, (uint64_t)v8);
  uint64_t v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 32) + 8LL);
  if (!*(void *)(v3 + 24)) {
    *(void *)(v3 + 24) = a3;
  }
  return result;
}

uint64_t ___ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v10[0] = 2LL;
  v10[1] = a2;
  _OWORD v10[2] = a3;
  uint64_t v12 = a5;
  __int128 v11 = *a4;
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v13 = a2 - *(void *)(*(void *)(*(void *)(v8 + 8) + 8LL) + 24LL);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, __int128 *, uint64_t, uint64_t, uint64_t))(v7 + 16))( v7,  v10,  a3,  a4,  a5,  a6,  a7);
}

uint64_t dyld4::APIs::dyld_shared_cache_iterate_text(dyld4::RuntimeState *this, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_shared_cache_iterate_text()\n");
  }
  uint64_t v7 = 0LL;
  return (*(uint64_t (**)(dyld4::RuntimeState *, uint64_t, uint64_t *, uint64_t))(*(void *)this + 528LL))( this,  a2,  &v7,  a3);
}

uint64_t (***dyld4::APIs::_dyld_fork_child(dyld4::RuntimeLocks **this))(void)
{
  mach_task_self_ = task_self_trap();
  dyld4::ExternallyViewableState::fork_child((uint64_t)(this + 67));
  return dyld4::RuntimeLocks::resetLockInForkChild(this[17]);
}

unint64_t dyld4::APIs::_dyld_atfork_prepare(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeLockBeforeFork(this[17]);
}

unint64_t dyld4::APIs::_dyld_atfork_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseLockInForkParent(this[17]);
}

uint64_t dyld4::APIs::_dyld_before_fork_dlopen(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::takeDlopenLockBeforeFork(this[17]);
}

uint64_t dyld4::APIs::_dyld_after_fork_dlopen_parent(dyld4::RuntimeLocks **this)
{
  return dyld4::RuntimeLocks::releaseDlopenLockInForkParent(this[17]);
}

uint64_t (***dyld4::APIs::_dyld_after_fork_dlopen_child(dyld4::RuntimeLocks **this))(void)
{
  return dyld4::RuntimeLocks::resetDlopenLockInForkChild(this[17]);
}

const char *dyld4::APIs::_dyld_get_objc_selector(dyld4::APIs *this, char *__s)
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(v4 + 304);
  if (v5)
  {
    uint64_t Index = objc::StringHashTable::tryGetIndex(*(objc::StringHashTable **)(v4 + 304), __s);
    if ((Index & 0xFF00000000LL) != 0)
    {
      Selector = (const char *)(v5
                              + *(int *)(v5
                                       + *(unsigned int *)(v5 + 4)
                                       + (*(_DWORD *)(v5 + 16) + 1)
                                       + 4LL * Index
                                       + 1056));
      goto LABEL_6;
    }
  }

  if (*((void *)this + 123))
  {
    Selector = (const char *)prebuilt_objc::findSelector(this, (void *)this + 43, __s);
LABEL_6:
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => %s\n", __s, Selector);
    }
    return Selector;
  }

  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_selector(%s) => nullptr\n", __s);
  }
  return 0LL;
}

void dyld4::APIs::_dyld_for_each_objc_class(dyld4::RuntimeState *this, char *a2, uint64_t a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_class(%s)\n", a2);
  }
  if (!*((void *)this + 123)) {
    goto LABEL_5;
  }
  uint64_t v10 = 0LL;
  __int128 v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke;
  void v9[3] = &unk_1896207D8;
  void v9[5] = &v10;
  void v9[6] = this;
  void v9[4] = a3;
  prebuilt_objc::forEachClass(this, (void *)this + 49, a2, (uint64_t)v9);
  int v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    uint64_t v7 = *(unsigned int **)(*((void *)this + 1) + 312LL);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000LL;
      v8[2] = ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_189620800;
      void v8[4] = a3;
      v8[5] = this;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(dyld4::RuntimeState **)(result + 48);
    int v6 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    uint64_t v7 = 8 * v3 - 8;
    do
    {
      uint64_t v8 = *v6++;
      uint64_t v9 = *(void *)(v4 + 32);
      unint64_t v10 = dyld4::PrebuiltLoader::BindTargetRef::value(v8, v5, a3);
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v9 + 16))( v9,  v10,  1LL,  *(void *)(*(void *)(v4 + 40) + 8LL) + 24LL);
      if (*(_BYTE *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL)) {
        BOOL v11 = 1;
      }
      else {
        BOOL v11 = v7 == 0;
      }
      v7 -= 8LL;
    }

    while (!v11);
  }

  return result;
}

uint64_t ___ZN5dyld44APIs25_dyld_for_each_objc_classEPKcU13block_pointerFvPvbPbE_block_invoke_2( uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded( *(unsigned int **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 296LL),  a3);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
  return result;
}

uint64_t objc::objc_headeropt_rw_t<unsigned long>::isLoaded(unsigned int *a1, unsigned int a2)
{
  if (*a1 <= a2) {
    objc::objc_headeropt_rw_t<unsigned long>::isLoaded();
  }
  return *(unsigned int *)((char *)a1 + a1[1] * a2 + 8) & 1;
}

void dyld4::APIs::_dyld_for_each_objc_protocol(dyld4::RuntimeState *this, char *a2, uint64_t a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_get_objc_protocol(%s)\n", a2);
  }
  if (!*((void *)this + 123)) {
    goto LABEL_5;
  }
  uint64_t v10 = 0LL;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke;
  void v9[3] = &unk_189620828;
  void v9[5] = &v10;
  void v9[6] = this;
  void v9[4] = a3;
  prebuilt_objc::forEachProtocol(this, (void *)this + 55, a2, (uint64_t)v9);
  int v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
LABEL_5:
    uint64_t v7 = *(unsigned int **)(*((void *)this + 1) + 320LL);
    if (v7)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000LL;
      v8[2] = ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2;
      v8[3] = &unk_189620850;
      void v8[4] = a3;
      v8[5] = this;
      objc::ObjectHashTable::forEachObject(v7, a2, (uint64_t)v8);
    }
  }

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(dyld4::RuntimeState **)(result + 48);
    int v6 = *(dyld4::PrebuiltLoader::BindTargetRef ***)a2;
    uint64_t v7 = 8 * v3 - 8;
    do
    {
      uint64_t v8 = *v6++;
      uint64_t v9 = *(void *)(v4 + 32);
      unint64_t v10 = dyld4::PrebuiltLoader::BindTargetRef::value(v8, v5, a3);
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(v9 + 16))( v9,  v10,  1LL,  *(void *)(*(void *)(v4 + 40) + 8LL) + 24LL);
      if (*(_BYTE *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL)) {
        BOOL v11 = 1;
      }
      else {
        BOOL v11 = v7 == 0;
      }
      v7 -= 8LL;
    }

    while (!v11);
  }

  return result;
}

uint64_t ___ZN5dyld44APIs28_dyld_for_each_objc_protocolEPKcU13block_pointerFvPvbPbE_block_invoke_2( uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = objc::objc_headeropt_rw_t<unsigned long>::isLoaded( *(unsigned int **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 296LL),  a3);
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
  return result;
}

uint64_t dyld4::APIs::_dyld_visit_objc_classes( dyld4::RuntimeState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *((void *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_visit_objc_classes()\n");
    uint64_t v10 = *((void *)this + 1);
  }

  uint64_t result = *(void *)(v10 + 312);
  if (result)
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000LL;
    v12[2] = ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke;
    v12[3] = &unk_189620878;
    v12[4] = a2;
    v12[5] = this;
    return objc::ObjectHashTable::forEachObject(result, (uint64_t)v12, a3, a4, a5, a6, a7, a8);
  }

  return result;
}

uint64_t ___ZN5dyld44APIs24_dyld_visit_objc_classesEU13block_pointerFvPKvE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = a4[2];
  if (v4)
  {
    uint64_t v5 = result;
    uint64_t v6 = *a4;
    uint64_t v7 = 16 * v4;
    do
    {
      v6 += 16LL;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v5 + 32) + 16LL))();
      v7 -= 16LL;
    }

    while (v7);
  }

  return result;
}

uint64_t dyld4::APIs::_dyld_objc_class_count(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(_BYTE *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_objc_class_count()\n");
    uint64_t v1 = *((void *)this + 1);
  }

  uint64_t v3 = *(unsigned int **)(v1 + 312);
  if (v3) {
    return *(unsigned int *)((char *)&v3[2 * v3[1] + 264 + v3[1]] + v3[1] + v3[4] + 1) + v3[2];
  }
  else {
    return 0LL;
  }
}

uint64_t dyld4::APIs::_dyld_is_preoptimized_objc_image_loaded(dyld4::APIs *this, unsigned int a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (!*(void *)(v4 + 240))
  {
    if (*(_BYTE *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no dyld shared cache\n");
    }
    return 0LL;
  }

  uint64_t v5 = *(unsigned int **)(v4 + 296);
  if (!v5)
  {
    if (*(_BYTE *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : no objC RW header\n");
    }
    return 0LL;
  }

  if (*v5 <= a2)
  {
    if (*(_BYTE *)(v4 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) : imageID is invalid\n");
    }
    return 0LL;
  }

  uint64_t isLoaded = objc::objc_headeropt_rw_t<unsigned long>::isLoaded(v5, a2);
  uint64_t v7 = isLoaded;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_is_preoptimized_objc_image_loaded(%d) => %d\n", a2, isLoaded);
  }
  return v7;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_rw(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(void *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no dyld shared cache\n");
    }
    return 0LL;
  }

  uint64_t v2 = *(void *)(v1 + 296);
  int v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw(): no objC RW header\n");
    }
    return 0LL;
  }

  if (v3) {
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_rw() => 0x%llx\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::_dyld_for_objc_header_opt_ro(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(void *)(v1 + 240))
  {
    if (*(_BYTE *)(v1 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no dyld shared cache\n");
    }
    return 0LL;
  }

  uint64_t v2 = *(void *)(v1 + 288);
  int v3 = *(unsigned __int8 *)(v1 + 204);
  if (!v2)
  {
    if (v3) {
      dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro(): no objC RO header\n");
    }
    return 0LL;
  }

  if (v3) {
    dyld4::RuntimeState::log(this, "_dyld_for_objc_header_opt_ro() => 0x%llx\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::_dyld_objc_uses_large_shared_cache(dyld4::APIs *this)
{
  return 1LL;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance(dyld4::APIs *this, char *a2, char *a3, char *a4)
{
  uint64_t v8 = *((void *)this + 1);
  if (*(_BYTE *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %p, %p)\n", a2, a3, a4);
    uint64_t v8 = *((void *)this + 1);
  }

  uint64_t v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  uint64_t v10 = *(void *)(v8 + 344);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    return 2LL;
  }
  if (!a4) {
    goto LABEL_12;
  }
  uint64_t v12 = *(void *)(v10 + 8);
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v13 = *(void *)(v8 + 240);
  uint64_t v29 = &a4[-v13];
  uint64_t v30 = &a2[-v13];
  unsigned int Potential = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( (unsigned int *)(v13 + v12),  (objc *)&v29);
  if (Potential == *(_DWORD *)(v13 + v12 + 16)) {
    goto LABEL_12;
  }
  unsigned int v15 = Potential;
  unint64_t v16 = *(void *)(v13 + v12 + Potential + 16);
  char isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v16));
  if ((v16 & 1) != 0)
  {
    if ((isLoaded & 1) == 0)
    {
      for (uint64_t i = v12 + v15 + v13 + 40; (*(_BYTE *)(i - 24) & 1) != 0; i += 24LL)
      {
        char v26 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if ((v26 & 1) != 0) {
          return 0LL;
        }
      }

      goto LABEL_12;
    }

    return 0LL;
  }

  if ((isLoaded & 1) != 0) {
    return 0LL;
  }
LABEL_12:
  if (!a3) {
    return 2LL;
  }
  uint64_t v18 = *(void *)(v10 + 16);
  if (!v18) {
    return 2LL;
  }
  uint64_t v19 = *(void *)(*((void *)this + 1) + 240LL);
  uint64_t v29 = &a3[-v19];
  uint64_t v30 = &a2[-v19];
  unsigned int v20 = SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( (unsigned int *)(v19 + v18),  (objc *)&v29);
  if (v20 == *(_DWORD *)(v19 + v18 + 16)) {
    return 2LL;
  }
  unsigned int v22 = v20;
  unint64_t v23 = *(void *)(v19 + v18 + v20 + 16);
  char v24 = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v23));
  if ((v23 & 1) != 0)
  {
    if ((v24 & 1) == 0)
    {
      for (uint64_t j = v18 + v22 + v19 + 40; (*(_BYTE *)(j - 24) & 1) != 0; j += 24LL)
      {
        char v28 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(j + 6));
        if ((v28 & 1) != 0) {
          return 0LL;
        }
      }

      return 2LL;
    }
  }

  else if ((v24 & 1) == 0)
  {
    return 2LL;
  }

  return 0LL;
}

uint64_t dyld4::objc_headeropt_rw_t::isLoaded(dyld4::objc_headeropt_rw_t *this, unsigned int a2)
{
  if (*(_DWORD *)this <= a2) {
    dyld4::objc_headeropt_rw_t::isLoaded();
  }
  return *(_DWORD *)((_BYTE *)this + *((_DWORD *)this + 1) * a2 + 8) & 1;
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance( dyld4::APIs *this, char *a2, const char *a3, uint64_t a4)
{
  uint64_t v8 = *((void *)this + 1);
  if (*(_BYTE *)(v8 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_protocol_conformance(%p, %s)\n", a2, a3);
    uint64_t v8 = *((void *)this + 1);
  }

  uint64_t v9 = *(dyld4::objc_headeropt_rw_t **)(v8 + 296);
  uint64_t v10 = *(void *)(v8 + 344);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    return 2LL;
  }
  uint64_t v12 = *(void *)(v10 + 24);
  if (!v12) {
    return 2LL;
  }
  uint64_t v13 = *(void *)(v8 + 240);
  v21[0] = a3;
  v21[1] = a4;
  _OWORD v21[2] = &a2[-v13];
  unsigned int Potential = SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( (unsigned int *)(v13 + v12),  (uint64_t)v21,  v13);
  if (Potential == *(_DWORD *)(v13 + v12 + 16)) {
    return 2LL;
  }
  unsigned int v16 = Potential;
  unint64_t v17 = *(void *)(v13 + v12 + Potential + 16);
  char isLoaded = dyld4::objc_headeropt_rw_t::isLoaded(v9, HIWORD(v17));
  if ((v17 & 1) != 0)
  {
    if ((isLoaded & 1) == 0)
    {
      for (uint64_t i = v12 + v16 + v13 + 40; (*(_BYTE *)(i - 24) & 1) != 0; i += 24LL)
      {
        char v20 = dyld4::objc_headeropt_rw_t::isLoaded(v9, *(unsigned __int16 *)(i + 6));
        if ((v20 & 1) != 0) {
          return 0LL;
        }
      }

      return 2LL;
    }
  }

  else if ((isLoaded & 1) == 0)
  {
    return 2LL;
  }

  return 0LL;
}

uint64_t dyld4::APIs::_dyld_swift_optimizations_version(dyld4::APIs *this)
{
  return 1LL;
}

BOOL dyld4::APIs::_dyld_has_preoptimized_swift_protocol_conformances(dyld4::APIs *this, mach_header *a2)
{
  BOOL result = dyld3::MachOAnalyzer::hasSwift((dyld3::MachOAnalyzer *)a2);
  if (result)
  {
    uint64_t v5 = *((void *)this + 123);
    if (!v5) {
      return 0LL;
    }
    BOOL result = dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 123));
    if (!result) {
      return result;
    }
    uint64_t v8 = *(unsigned int *)(v5 + 12);
    if ((_DWORD)v8)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = v8 - 1;
      do
      {
        BOOL v11 = dyld4::Loader::analyzer( (dyld4::Loader *)(v5 + *(unsigned int *)(v5 + *(unsigned int *)(v5 + 16) + 4LL * (unsigned __int16)v9)),  this) == (void)a2;
        BOOL result = v11;
        BOOL v11 = v11 || v10 == v9++;
      }

      while (!v11);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t dyld4::APIs::_dyld_find_protocol_conformance_on_disk( dyld4::PrebuiltLoaderSet **this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, dyld4::PrebuiltLoader::BindTargetRef *a4)
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "_dyld_find_protocol_conformance_on_disk(%p, %p, %p)\n",  a2,  a3,  a4);
  }
  uint64_t v8 = this[123];
  if (!v8 || !dyld4::PrebuiltLoaderSet::hasOptimizedSwift(this[123])) {
    return 2LL;
  }
  uint64_t v9 = dyld4::PrebuiltLoaderSet::swiftTypeProtocolTable(v8);
  if (a4)
  {
    if (v9)
    {
      if (this[61])
      {
        unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a4);
        unint64_t v31 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
        uint64_t v10 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find( this[61],  (uint64_t)&Absolute);
        if (v10 != *((void *)this[61] + 7) + 32LL * *((void *)this[61] + 9))
        {
          uint64_t v11 = v10;
          if (dyld4::EqualTypeConformanceLookupKey::equal(v10, (uint64_t)a4, (uint64_t)a2, (dyld4::RuntimeState *)this))
          {
LABEL_12:
            unsigned int v15 = (dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16);
            uint64_t v16 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef( (dyld4::PrebuiltLoader::BindTargetRef *)(v11 + 16),  v12,  v13);
            unsigned int v19 = v16 & 0x7FFF;
            if (*((_DWORD *)v8 + 3) <= v19) {
              dyld4::RuntimeState::findPrebuiltLoader(v16, v17, v18);
            }
            goto LABEL_22;
          }

          while (1)
          {
            unint64_t v14 = *(void *)(v11 + 24);
            if ((v14 & 3) == 0) {
              break;
            }
            uint64_t v11 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)this[61] + 7,  v14 >> 3);
          }
        }
      }
    }
  }

  uint64_t v20 = dyld4::PrebuiltLoaderSet::swiftMetadataProtocolTable(v8);
  uint64_t result = 2LL;
  if (a3 && v20)
  {
    if (this[62])
    {
      unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
      unint64_t v31 = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
      uint64_t v22 = dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find( this[62],  (uint64_t)&Absolute);
      if (v22 != *((void *)this[62] + 7) + 32LL * *((void *)this[62] + 9))
      {
        for (uint64_t i = v22;
              !dyld4::EqualMetadataConformanceLookupKey::equal(i, (uint64_t)a3, (uint64_t)a2, (dyld4::RuntimeState *)this);
              uint64_t i = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)this[62] + 7,  v26 >> 3))
        {
          unint64_t v26 = *(void *)(i + 24);
          if ((v26 & 3) == 0) {
            return 2LL;
          }
        }

        unsigned int v15 = (dyld4::PrebuiltLoader::BindTargetRef *)(i + 16);
        uint64_t v27 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef( (dyld4::PrebuiltLoader::BindTargetRef *)(i + 16),  v24,  v25);
        unsigned int v19 = v27 & 0x7FFF;
        if (*((_DWORD *)v8 + 3) <= v19) {
          dyld4::RuntimeState::findPrebuiltLoader(v27, v28, v29);
        }
LABEL_22:
        dyld4::PrebuiltLoader::loadAddress( (dyld4::PrebuiltLoaderSet *)((char *)v8 + *(unsigned int *)((char *)v8 + 4 * v19 + *((unsigned int *)v8 + 4))),  (const dyld4::RuntimeState *)this);
        dyld4::PrebuiltLoader::BindTargetRef::offset(v15);
        return 0LL;
      }
    }

    return 2LL;
  }

  return result;
}

uint64_t dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::find( void *a1, uint64_t a2)
{
  unint64_t v4 = (a1[4] - 1LL) & dyld4::HashTypeConformanceKey::hash(a2);
  unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
  if (v5 == -1LL) {
    return a1[7] + 32LL * a1[9];
  }
  for (uint64_t i = 1LL; ; ++i)
  {
    uint64_t v7 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
    if (dyld4::EqualTypeConformanceKey::equal(v7, a2)) {
      break;
    }
    unint64_t v4 = (a1[4] - 1LL) & (v4 + i);
    unint64_t v5 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](a1 + 2, v4);
    if (v5 == -1LL) {
      return a1[7] + 32LL * a1[9];
    }
  }

  return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[](a1 + 7, v5);
}

BOOL dyld4::EqualTypeConformanceLookupKey::equal( uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  if (!a4) {
    dyld4::EqualTypeConformanceLookupKey::equal();
  }
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4, a3) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4, v7) == a3;
}

BOOL dyld4::EqualMetadataConformanceLookupKey::equal( uint64_t a1, uint64_t a2, uint64_t a3, dyld4::RuntimeState *a4)
{
  if (!a4) {
    dyld4::EqualMetadataConformanceLookupKey::equal();
  }
  return dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)a1, a4, a3) == a2
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8), a4, v7) == a3;
}

uint64_t dyld4::APIs::_dyld_find_foreign_type_protocol_conformance_on_disk( dyld4::APIs *this, dyld4::PrebuiltLoader::BindTargetRef *a2, dyld4::PrebuiltLoader::BindTargetRef *a3, uint64_t a4)
{
  unint64_t v4 = (dyld4::PrebuiltLoaderSet *)*((void *)this + 123);
  if (!v4) {
    return 2LL;
  }
  if (!dyld4::PrebuiltLoaderSet::hasOptimizedSwift(*((dyld4::PrebuiltLoaderSet **)this + 123))) {
    return 2LL;
  }
  if (!dyld4::PrebuiltLoaderSet::swiftForeignTypeProtocolTable(v4)) {
    return 2LL;
  }
  if (!*((void *)this + 63)) {
    return 2LL;
  }
  v21[0] = 0LL;
  v21[1] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a3);
  _OWORD v21[2] = a4;
  void v21[3] = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute(a2);
  uint64_t v10 = (void *)dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find( *((void *)this + 63),  (uint64_t)v21,  v9);
  if (v10 == (void *)(*(void *)(*((void *)this + 63) + 56LL) + 48LL * *(void *)(*((void *)this + 63) + 72LL))) {
    return 2LL;
  }
  uint64_t v11 = v10;
  if (dyld4::EqualForeignConformanceLookupKey::equal(v10, (const char *)a3, a4, (uint64_t)a2, this))
  {
LABEL_10:
    uint64_t v20 = v11[4];
    uint64_t v16 = dyld4::PrebuiltLoader::BindTargetRef::loaderRef((dyld4::PrebuiltLoader::BindTargetRef *)&v20, v12, v13);
    dyld4::PrebuiltLoader::loadAddress( (dyld4::PrebuiltLoaderSet *)((char *)v4 + *(unsigned int *)((char *)v4 + 4 * (v16 & 0x7FFF) + *((unsigned int *)v4 + 4))),  this);
    dyld4::PrebuiltLoader::BindTargetRef::offset((dyld4::PrebuiltLoader::BindTargetRef *)&v20);
    return 0LL;
  }

  else
  {
    uint64_t v14 = 2LL;
    while (1)
    {
      unint64_t v15 = v11[5];
      if ((v15 & 3) == 0) {
        break;
      }
      uint64_t v11 = (void *)dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(*((void *)this + 63) + 56LL),  v15 >> 3);
    }
  }

  return v14;
}

uint64_t dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::find( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (*(void *)(a1 + 32) - 1LL) & dyld4::HashForeignConformanceKey::hash(a2, *(dyld4::RuntimeState **)(a1 + 96), a3);
  unint64_t v6 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v5);
  if (v6 == -1LL) {
    return *(void *)(a1 + 56) + 48LL * *(void *)(a1 + 72);
  }
  for (uint64_t i = 1LL; ; ++i)
  {
    uint64_t v8 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v6);
    if (dyld4::EqualForeignConformanceKey::equal(v8, a2, *(dyld4::RuntimeState **)(a1 + 96))) {
      break;
    }
    unint64_t v5 = (*(void *)(a1 + 32) - 1LL) & (v5 + i);
    unint64_t v6 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v5);
    if (v6 == -1LL) {
      return *(void *)(a1 + 56) + 48LL * *(void *)(a1 + 72);
    }
  }

  return dyld3::OverflowSafeArray<dyld3::MultiMapBase<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v6);
}

BOOL dyld4::EqualForeignConformanceLookupKey::equal( void *a1, const char *a2, uint64_t a3, uint64_t a4, dyld4::RuntimeState *a5)
{
  if (!a5) {
    dyld4::EqualForeignConformanceLookupKey::equal();
  }
  uint64_t v10 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value( (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 1),  a5,  a3);
  size_t v11 = a1[2];
  int v12 = _platform_strncmp(v10, a2, v11);
  return v11 == a3
      && v12 == 0
      && dyld4::PrebuiltLoader::BindTargetRef::value((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 3), a5, v13) == a4;
}

uint64_t dyld4::APIs::_dyld_lookup_section_info( void *a1, dyld3::MachOFile *a2, dyld4::Loader *this, uint64_t a4)
{
  v16[49] = v4;
  v16[50] = v5;
  if (this)
  {
    uint64_t v11 = a1[1];
    unint64_t v12 = *(void *)(v11 + 240);
    if (v12)
    {
      unint64_t v13 = DyldSharedCache::mappedSize(*(DyldSharedCache **)(v11 + 240)) + v12;
      BOOL v14 = v12 > (unint64_t)this || v13 >= (unint64_t)this;
      if (!v14 && !a1[120]) {
        return (*(uint64_t (**)(void *, dyld3::MachOFile *, void, uint64_t))(*a1 + 928LL))(a1, a2, 0LL, a4);
      }
    }

    if (*(_DWORD *)this != 1815378276 || *(_DWORD *)dyld4::Loader::getSectionLocations(this) != 1) {
      return (*(uint64_t (**)(void *, dyld3::MachOFile *, void, uint64_t))(*a1 + 928LL))(a1, a2, 0LL, a4);
    }
    uint64_t v15 = *(void *)(dyld4::Loader::getSectionLocations(this) + 8LL * a4 + 8);
    if (v15) {
      return (uint64_t)a2 + v15;
    }
  }

  else
  {
    v16[0] = 1LL;
    dyld4::JustInTimeLoader::parseSectionLocations(a2, (uint64_t)v16);
    uint64_t v15 = v16[a4 + 1];
    if (v15) {
      return (uint64_t)a2 + v15;
    }
  }

  return 0LL;
}

uint64_t dyld4::APIs::_dyld_pseudodylib_register_callbacks(dyld4::RuntimeState *this, const void *a2)
{
  uint64_t v11 = a2;
  uint64_t v3 = *((void *)this + 1);
  if (!*(_BYTE *)(v3 + 192))
  {
    if (*(_BYTE *)(v3 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register_callbacks() => nullptr: blocked by security policy");
    }
    return 0LL;
  }

  v9[2] = (uint64_t **)this;
  uint64_t v10 = 0LL;
  uint64_t v4 = (lsl::Lock *)*((void *)this + 16);
  uint64_t v5 = (void *)*((void *)this + 17);
  v9[0] = (uint64_t **)&v11;
  v9[1] = (uint64_t **)&v10;
  lsl::MemoryManager::lockGuard(v4, &v12);
  uint64_t v6 = *((void *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    uint64_t v6 = *((void *)v4 + 3);
  }

  *((void *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v12);
  if (*v5)
  {
    (*(void (**)(void, void *, void))(*(void *)*v5 + 104LL))(*v5, v5 + 1, 0LL);
    dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v9);
    (*(void (**)(void, void *))(*(void *)*v5 + 112LL))(*v5, v5 + 1);
  }

  else
  {
    dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()(v9);
  }

  lsl::MemoryManager::lockGuard(v4, &v12);
  uint64_t v7 = *((void *)v4 + 3) - 1LL;
  *((void *)v4 + 3) = v7;
  if (!v7) {
    lsl::MemoryManager::writeProtect(v4, 1);
  }
  lsl::Lock::unlock(v12);
  uint64_t result = v10;
  if (!v10)
  {
    if (*(_BYTE *)(*((void *)this + 1) + 204LL))
    {
      dyld4::RuntimeState::log( this,  "_dyld_pseudodylib_register_callbacks(%p): callbacks struct version not recognized",  v11);
      return v10;
    }

    return 0LL;
  }

  return result;
}

void dyld4::APIs::_dyld_pseudodylib_deregister_callbacks(dyld4::RuntimeState *this, void *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if (*(_BYTE *)(v3 + 192))
  {
    if (a2)
    {
      uint64_t v5 = (lsl::Lock *)*((void *)this + 16);
      uint64_t v6 = (void *)*((void *)this + 17);
      lsl::MemoryManager::lockGuard(v5, &v9);
      uint64_t v7 = *((void *)v5 + 3);
      if (!v7)
      {
        lsl::MemoryManager::writeProtect(v5, 0);
        uint64_t v7 = *((void *)v5 + 3);
      }

      *((void *)v5 + 3) = v7 + 1;
      lsl::Lock::unlock(v9);
      if (*v6)
      {
        (*(void (**)(void, void *, void))(*(void *)*v6 + 104LL))(*v6, v6 + 1, 0LL);
        lsl::Allocator::free(*((lsl::Lock ***)this + 2), a2);
        (*(void (**)(void, void *))(*(void *)*v6 + 112LL))(*v6, v6 + 1);
      }

      else
      {
        lsl::Allocator::free(*((lsl::Lock ***)this + 2), a2);
      }

      lsl::MemoryManager::lockGuard(v5, &v9);
      uint64_t v8 = *((void *)v5 + 3) - 1LL;
      *((void *)v5 + 3) = v8;
      if (!v8) {
        lsl::MemoryManager::writeProtect(v5, 1);
      }
      lsl::Lock::unlock(v9);
    }
  }

  else if (*(_BYTE *)(v3 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_pseudodylib_deregister_callbacks(): blocked by security policy");
  }

void *dyld4::APIs::_dyld_pseudodylib_register( dyld4::RuntimeState *this, dyld3::MachOFile *a2, uint64_t a3, const void *a4, const void *a5)
{
  uint64_t v6 = *((void *)this + 1);
  if (!*(_BYTE *)(v6 + 192))
  {
    if (*(_BYTE *)(v6 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_pseudodylib_register() => nullptr: blocked by security policy");
    }
    return 0LL;
  }

  uint64_t v11 = dyld3::MachOFile::installName(a2);
  if (!v11)
  {
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log( this,  "_dyld_register_pseudodylib(%p, %lx, %p, %p): registered range does not contain an install name");
    }
    return 0LL;
  }

  unint64_t v12 = v11;
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log( this,  "_dyld_register_pseudodylib(%p, %lx, %p, %p): [%p, %p) %s\n",  a2,  a3,  a4,  a5,  a2,  (char *)a2 + a3,  v11);
  }
  unint64_t v13 = (lsl::Lock *)*((void *)this + 16);
  BOOL v14 = (void *)*((void *)this + 17);
  lsl::MemoryManager::lockGuard(v13, &v32);
  uint64_t v15 = *((void *)v13 + 3);
  if (!v15)
  {
    lsl::MemoryManager::writeProtect(v13, 0);
    uint64_t v15 = *((void *)v13 + 3);
  }

  uint64_t v31 = a3;
  *((void *)v13 + 3) = v15 + 1;
  lsl::Lock::unlock(v32);
  if (*v14)
  {
    (*(void (**)(void))(*(void *)*v14 + 104LL))(*v14);
    uint64_t v16 = *((void *)this + 75);
    if (v16)
    {
      uint64_t v17 = (uint64_t *)*((void *)this + 74);
      uint64_t v18 = 8 * v16;
      while (1)
      {
        uint64_t v19 = *v17;
        ++v17;
        v18 -= 8LL;
        if (!v18) {
          goto LABEL_12;
        }
      }

      uint64_t v21 = 0LL;
      uint64_t v20 = v31;
    }

    else
    {
LABEL_12:
      uint64_t v20 = v31;
      uint64_t v21 = dyld4::PseudoDylib::create( *((lsl::Lock ***)this + 2),  (unint64_t)v12,  (unint64_t)a2,  v31,  (uint64_t)a4,  (uint64_t)a5);
      lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 584, *((void *)this + 75) + 1LL);
      uint64_t v19 = 0LL;
      uint64_t v22 = *((void *)this + 74);
      uint64_t v23 = *((void *)this + 75);
      *((void *)this + 75) = v23 + 1;
      *(void *)(v22 + 8 * v23) = v21;
    }

    (*(void (**)(void, void *))(*(void *)*v14 + 112LL))(*v14, v14 + 1);
  }

  else
  {
    uint64_t v24 = *((void *)this + 75);
    if (v24)
    {
      uint64_t v25 = (uint64_t *)*((void *)this + 74);
      uint64_t v26 = 8 * v24;
      while (1)
      {
        uint64_t v19 = *v25;
        ++v25;
        v26 -= 8LL;
        if (!v26) {
          goto LABEL_22;
        }
      }

      uint64_t v21 = 0LL;
      uint64_t v20 = v31;
    }

    else
    {
LABEL_22:
      uint64_t v20 = v31;
      uint64_t v21 = dyld4::PseudoDylib::create( *((lsl::Lock ***)this + 2),  (unint64_t)v12,  (unint64_t)a2,  v31,  (uint64_t)a4,  (uint64_t)a5);
      lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 584, *((void *)this + 75) + 1LL);
      uint64_t v19 = 0LL;
      uint64_t v27 = *((void *)this + 74);
      uint64_t v28 = *((void *)this + 75);
      *((void *)this + 75) = v28 + 1;
      *(void *)(v27 + 8 * v28) = v21;
    }
  }

  lsl::MemoryManager::lockGuard(v13, &v32);
  uint64_t v29 = *((void *)v13 + 3) - 1LL;
  *((void *)v13 + 3) = v29;
  if (!v29) {
    lsl::MemoryManager::writeProtect(v13, 1);
  }
  lsl::Lock::unlock(v32);
  if (v19)
  {
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log( this,  "_dyld_register_pseudodylib(%s, %p, %lx): identifier conflicts with existing registration covering [%p, %p)",  v12,  a2,  v20,  *(const void **)v19,  (const void *)(*(void *)v19 + *(void *)(v19 + 8)));
    }
    if (v21) {
      dyld4::APIs::_dyld_pseudodylib_register();
    }
  }

  return v21;
}

void dyld4::APIs::_dyld_pseudodylib_deregister(lsl::Lock ***this, uint64_t a2)
{
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "_dyld_deregister_pseudodylib(<handle for %s>)\n",  *(const char **)(a2 + 32));
  }
  uint64_t v4 = (lsl::Lock *)this[16];
  uint64_t v5 = this[17];
  lsl::MemoryManager::lockGuard(v4, &v19);
  uint64_t v6 = *((void *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    uint64_t v6 = *((void *)v4 + 3);
  }

  *((void *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v19);
  if (*v5)
  {
    (*(void (**)(lsl::Lock *, lsl::Lock **, void))(*(void *)*v5 + 104LL))(*v5, v5 + 1, 0LL);
    uint64_t v7 = this[75];
    if (v7)
    {
      uint64_t v8 = this[74];
      size_t v9 = 8LL * (void)v7 - 8;
      uint64_t v10 = v8;
      while (1)
      {
        uint64_t v11 = (uint64_t)*v10++;
        if (v11 == a2) {
          break;
        }
        v9 -= 8LL;
        uint64_t v8 = v10;
        if (v9 == -8LL) {
          goto LABEL_10;
        }
      }

      if (v9)
      {
        memmove(v8, v8 + 1, v9);
        uint64_t v7 = this[75];
      }

      this[75] = (lsl::Lock **)((char *)v7 - 1);
      lsl::Allocator::free(this[2], (void *)a2);
      int v12 = 1;
    }

    else
    {
LABEL_10:
      int v12 = 0;
    }

    (*(void (**)(lsl::Lock *, lsl::Lock **))(*(void *)*v5 + 112LL))(*v5, v5 + 1);
  }

  else
  {
    unint64_t v13 = this[75];
    if (v13)
    {
      BOOL v14 = this[74];
      size_t v15 = 8LL * (void)v13 - 8;
      uint64_t v16 = v14;
      while (1)
      {
        uint64_t v17 = (uint64_t)*v16++;
        if (v17 == a2) {
          break;
        }
        v15 -= 8LL;
        BOOL v14 = v16;
        if (v15 == -8LL) {
          goto LABEL_15;
        }
      }

      if (v15)
      {
        memmove(v14, v14 + 1, v15);
        unint64_t v13 = this[75];
      }

      this[75] = (lsl::Lock **)((char *)v13 - 1);
      lsl::Allocator::free(this[2], (void *)a2);
      int v12 = 1;
    }

    else
    {
LABEL_15:
      int v12 = 0;
    }
  }

  lsl::MemoryManager::lockGuard(v4, &v19);
  uint64_t v18 = *((void *)v4 + 3) - 1LL;
  *((void *)v4 + 3) = v18;
  if (!v18) {
    lsl::MemoryManager::writeProtect(v4, 1);
  }
  lsl::Lock::unlock(v19);
  if (!v12)
  {
    if (*((_BYTE *)this[1] + 204)) {
      dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "_dyld_deregister_pseudodylib(<handle for %s>): no registered pseudo-dylib for handle",  *(const char **)(a2 + 32));
    }
  }

const void *dyld4::APIs::_dyld_get_prog_image_header(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(const void **)(v1 + 8);
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_prog_image_header() => %p\n", v2);
  }
  return v2;
}

uint64_t dyld4::APIs::_dyld_has_fix_for_radar(dyld4::APIs *this, const char *a2)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_has_fix_for_radar(%s)\n", a2);
  }
  return 0LL;
}

uint64_t dyld4::APIs::_dyld_is_objc_constant(dyld4::RuntimeState *a1, int a2, const void *a3)
{
  if (*(_BYTE *)(*((void *)a1 + 1) + 204LL)) {
    dyld4::RuntimeState::log(a1, "_dyld_is_objc_constant(%d, %p)\n", a2, a3);
  }
  return 0LL;
}

uint64_t dyld4::APIs::_dyld_launch_mode(dyld4::APIs *this)
{
  unint64_t v1 = *((void *)this + 3);
  int v2 = *(_WORD *)(v1 + 4) & 1;
  if (*((_BYTE *)this + 1008))
  {
    int v3 = v2 | 4;
    if (!*((_BYTE *)this + 1128)) {
      int v3 = *(_WORD *)(v1 + 4) & 1;
    }
  }

  else
  {
    int v3 = *(_WORD *)(v1 + 4) & 1;
  }

  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = *(void *)(v4 + 240);
  BOOL v6 = v1 <= v5 || v5 == 0;
  int v7 = v3 | 8;
  if (v6) {
    int v7 = v3;
  }
  if (v2) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = v3;
  }
  if (*((void *)this + 22)) {
    uint64_t v9 = v8 | 0x20;
  }
  else {
    uint64_t v9 = v8;
  }
  if (v5)
  {
    if (*(void *)(v5 + 104) == 1LL) {
      uint64_t v9 = v9 | 0x40;
    }
    else {
      uint64_t v9 = v9;
    }
  }

  if (*(_BYTE *)(v4 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_launch_mode() => 0x%08X\n", v9);
  }
  return v9;
}

void dyld4::APIs::_dyld_register_driverkit_main(dyld4::APIs *this, void (*a2)(void))
{
  uint64_t v4 = *((void *)this + 1);
  if (*(_BYTE *)(v4 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main(%p)\n", a2);
    uint64_t v4 = *((void *)this + 1);
  }

  if (*(_DWORD *)(v4 + 68) == 10)
  {
    if (*((void *)this + 128)) {
      dyld4::halt("_dyld_register_driverkit_main() may only be called once", 0LL);
    }
    *((void *)this + 128) = a2;
  }

  else
  {
    dyld4::RuntimeState::log(this, "_dyld_register_driverkit_main() can only be called in DriverKit processes\n");
  }

BOOL dyld4::APIs::_dyld_shared_cache_contains_path(DyldSharedCache ***this, const char *a2)
{
  uint64_t v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  unint64_t v5 = v4;
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log((dyld4::RuntimeState *)this, "_dyld_shared_cache_contains_path(%s) => %d\n", a2, v4 != 0LL);
  }
  return v5 != 0LL;
}

DyldSharedCache *dyld4::APIs::_dyld_shared_cache_real_path(DyldSharedCache ***this, const char *a2)
{
  uint64_t v4 = dyld4::ProcessConfig::canonicalDylibPathInCache(this[1], a2);
  unint64_t v5 = v4;
  if (*((_BYTE *)this[1] + 204)) {
    dyld4::RuntimeState::log( (dyld4::RuntimeState *)this,  "_dyld_shared_cache_real_path(%s) => '%s'\n",  a2,  (const char *)v4);
  }
  return v5;
}

uint64_t dyld4::APIs::_dyld_shared_cache_is_locally_built(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(void *)(v1 + 240);
  if (v2) {
    uint64_t v3 = (*(unsigned __int8 *)(v2 + 221) >> 2) & 1;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (*(_BYTE *)(v1 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_shared_cache_is_locally_built() => %d\n", v3);
  }
  return v3;
}

uint64_t dyld4::APIs::dyld_need_closure(dyld4::APIs *this, const char *a2, const char *a3)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "dyld_need_closure()\n", a3);
  }
  return 0LL;
}

void dyld4::APIs::_dyld_missing_symbol_abort(dyld4::APIs *this)
{
}

uint64_t dyld4::APIs::_dyld_dlsym_blocked(dyld4::APIs *this)
{
  return *(unsigned __int8 *)(*((void *)this + 1) + 170LL);
}

void dyld4::APIs::_tlv_bootstrap(dyld4::APIs *this)
{
}

void dyld4::APIs::obsolete(dyld4::APIs *this)
{
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromFile( dyld4::APIs *this, const char *a2, __NSObjectFileImage **a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, __NSObjectFileImage **))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSCreateObjectFileImageFromMemory(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSCreateObjectFileImageFromMemory( dyld4::APIs *this, const void *a2, uint64_t a3, __NSObjectFileImage **a4)
{
  uint64_t v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *, uint64_t, __NSObjectFileImage **))(*(void *)this + 800LL))( this,  a2,  a3,  a4);
  return dyld4::APIs::NSLinkModule(v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSLinkModule(dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSUnLinkModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSUnLinkModule(dyld4::APIs *this, __NSModule *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSDestroyObjectFileImage(v2, v3);
}

uint64_t dyld4::APIs::NSDestroyObjectFileImage(dyld4::APIs *this, __NSObjectFileImage *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *))(*(void *)this + 800LL))( this,  a2);
  return dyld4::APIs::NSIsSymbolDefinedInObjectFileImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolDefinedInObjectFileImage( dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSGetSectionDataInObjectFileImage(v3, v4, v5, v6, v7);
}

uint64_t dyld4::APIs::NSGetSectionDataInObjectFileImage( dyld4::APIs *this, __NSObjectFileImage *a2, const char *a3, const char *a4, unint64_t *a5)
{
  unsigned int v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSObjectFileImage *, const char *, const char *, unint64_t *))(*(void *)this + 800LL))( this,  a2,  a3,  a4,  a5);
  return dyld4::APIs::NSNameOfModule(v5, v6);
}

void dyld4::APIs::NSNameOfModule(dyld4::APIs *this, __NSModule *a2)
{
}

uint64_t dyld4::APIs::NSIsSymbolNameDefined(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSIsSymbolNameDefinedWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSIsSymbolNameDefinedInImage(v3, v4, v5);
}

uint64_t dyld4::APIs::NSIsSymbolNameDefinedInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(void *)this
                                                                                                  + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSLookupAndBindSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbol(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSLookupAndBindSymbolWithHint(v2, v3, v4);
}

uint64_t dyld4::APIs::NSLookupAndBindSymbolWithHint(dyld4::APIs *this, const char *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSLookupSymbolInModule(v3, v4, v5);
}

uint64_t dyld4::APIs::NSLookupSymbolInModule(dyld4::APIs *this, __NSModule *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSModule *, const char *))(*(void *)this + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSLookupSymbolInImage(v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLookupSymbolInImage(dyld4::APIs *this, const mach_header *a2, const char *a3)
{
  uint64_t v3 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const mach_header *, const char *))(*(void *)this
                                                                                                  + 800LL))( this,  a2,  a3);
  return dyld4::APIs::NSAddressOfSymbol(v3, v4);
}

uint64_t dyld4::APIs::NSAddressOfSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSModuleForSymbol(v2, v3);
}

uint64_t dyld4::APIs::NSModuleForSymbol(dyld4::APIs *this, __NSSymbol *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, __NSSymbol *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSLinkEditError(v2, v3, v4, v5, v6);
}

uint64_t dyld4::APIs::NSLinkEditError( dyld4::APIs *this, NSLinkEditErrors *a2, int *a3, const char **a4, const char **a5)
{
  unsigned int v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, NSLinkEditErrors *, int *, const char **, const char **))(*(void *)this + 800LL))( this,  a2,  a3,  a4,  a5);
  return dyld4::APIs::NSAddLibrary(v5, v6);
}

uint64_t dyld4::APIs::NSAddLibrary(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSAddLibraryWithSearching(v2, v3);
}

uint64_t dyld4::APIs::NSAddLibraryWithSearching(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::NSAddImage(v2, v3, v4);
}

uint64_t dyld4::APIs::NSAddImage(dyld4::APIs *this, const char *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::_dyld_image_containing_address(v2, v3);
}

uint64_t dyld4::APIs::_dyld_image_containing_address(dyld4::APIs *this, const void *a2)
{
  uint64_t v2 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const void *))(*(void *)this + 800LL))(this, a2);
  return dyld4::APIs::_dyld_lookup_and_bind(v2, v3, v4, v5);
}

uint64_t dyld4::APIs::_dyld_lookup_and_bind(dyld4::APIs *this, const char *a2, void **a3, __NSModule **a4)
{
  unsigned int v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, void **, __NSModule **))(*(void *)this + 800LL))( this,  a2,  a3,  a4);
  return dyld4::APIs::_dyld_lookup_and_bind_with_hint(v4, v5, v6, v7, v8);
}

uint64_t dyld4::APIs::_dyld_lookup_and_bind_with_hint( dyld4::APIs *this, const char *a2, const char *a3, void **a4, __NSModule **a5)
{
  unsigned int v5 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, const char *, void **, __NSModule **))(*(void *)this + 800LL))( this,  a2,  a3,  a4,  a5);
  return dyld4::APIs::_dyld_lookup_and_bind_fully(v5, v6, v7, v8);
}

uint64_t dyld4::APIs::_dyld_lookup_and_bind_fully( dyld4::APIs *this, const char *a2, void **a3, __NSModule **a4)
{
  unsigned int v4 = (dyld4::APIs *)(*(uint64_t (**)(dyld4::APIs *, const char *, void **, __NSModule **))(*(void *)this + 800LL))( this,  a2,  a3,  a4);
  return dyld4::APIs::runAllInitializersForMain(v4);
}

void dyld4::APIs::runAllInitializersForMain(dyld4::APIs *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (!*(_BYTE *)(v2 + 169) || *(_DWORD *)(v2 + 164) != 3) {
    dyld4::SyscallDelegate::disablePageInLinking((dyld4::SyscallDelegate *)v2);
  }
  if (!*((void *)this + 19))
  {
    dyld4::Loader::beginInitializers(*((dyld4::Loader **)this + 12), this);
    dyld4::Loader::runInitializers(*((dyld4::Loader **)this + 12), this);
    *((_BYTE *)this + 648) = 1;
  }

  dyld4::ExternallyViewableState::setLibSystemInitialized((dyld4::APIs *)((char *)this + 536));
  dyld4::RuntimeState::notifyObjCInit(this, *((const dyld4::Loader **)this + 12));
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {
    uint64_t v4 = 0LL;
    unsigned int v5 = 1;
    do
    {
      unsigned int v6 = *(dyld4::Loader **)(*((void *)this + 5) + 8 * v4);
      if ((*((_WORD *)v6 + 2) & 0x2000) != 0)
      {
        dyld4::Loader::beginInitializers(v6, this);
        dyld4::RuntimeState::notifyObjCInit(this, v6);
        dyld4::Loader::runInitializers(v6, this);
        uint64_t v3 = *((void *)this + 6);
      }

      uint64_t v4 = v5;
      BOOL v7 = v3 == v5++;
    }

    while (!v7);
    if (v3)
    {
      uint64_t v8 = 0LL;
      unsigned int v9 = 1;
      do
      {
        uint64_t v10 = *(dyld4::Loader **)(*((void *)this + 5) + 8 * v8);
        dyld4::Loader::runInitializersBottomUpPlusUpwardLinks(v10, this);
        uint64_t v11 = (dyld3::MachOFile *)dyld4::Loader::analyzer(v10, this);
        if (dyld3::MachOFile::isMainExecutable(v11)) {
          break;
        }
        uint64_t v8 = v9;
        BOOL v7 = *((void *)this + 6) == v9++;
      }

      while (!v7);
    }
  }

os_unfair_lock_s *dyld4::APIs::_dyld_register_dlsym_notifier( dyld4::APIs *this, void (*a2)(const char *))
{
  uint64_t v4 = (lsl::Lock *)*((void *)this + 16);
  unsigned int v5 = (void *)*((void *)this + 17);
  lsl::MemoryManager::lockGuard(v4, &v9);
  uint64_t v6 = *((void *)v4 + 3);
  if (!v6)
  {
    lsl::MemoryManager::writeProtect(v4, 0);
    uint64_t v6 = *((void *)v4 + 3);
  }

  *((void *)v4 + 3) = v6 + 1;
  lsl::Lock::unlock(v9);
  if (*v5)
  {
    (*(void (**)(void, void *, void))(*(void *)*v5 + 104LL))(*v5, v5 + 2, 0LL);
    *((void *)this + 119) = a2;
    (*(void (**)(void, void *))(*(void *)*v5 + 112LL))(*v5, v5 + 2);
  }

  else
  {
    *((void *)this + 119) = a2;
  }

  lsl::MemoryManager::lockGuard(v4, &v9);
  uint64_t v7 = *((void *)v4 + 3) - 1LL;
  *((void *)v4 + 3) = v7;
  if (!v7) {
    lsl::MemoryManager::writeProtect(v4, 1);
  }
  return lsl::Lock::unlock(v9);
}

const void *dyld4::APIs::_dyld_get_swift_prespecialized_data(dyld4::APIs *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((*(_BYTE *)(v1 + 97) & 1) != 0) {
    return 0LL;
  }
  if (*(_BYTE *)(v1 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data()\n");
    uint64_t v1 = *((void *)this + 1);
  }

  uint64_t v3 = *(DyldSharedCache **)(v1 + 240);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = DyldSharedCache::swiftOpt(v3);
  if (!v4) {
    return 0LL;
  }
  if (*(_DWORD *)v4 < 2u) {
    return 0LL;
  }
  uint64_t v5 = *(void *)(v4 + 32);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = (const void *)(*(void *)(v6 + 240) + v5);
  if (*(_BYTE *)(v6 + 204)) {
    dyld4::RuntimeState::log(this, "_dyld_get_swift_prespecialized_data() => %p\n", v7);
  }
  return v7;
}

BOOL dyld4::APIs::_dyld_is_pseudodylib(dyld4::APIs *this, unint64_t a2)
{
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_is_pseudodylib(%p)\n", (const void *)a2);
  }
  if (a2) {
    unint64_t v4 = a2 & 0xFFFFFFFFFFFFFFFELL ^ (unint64_t)&dword_180058000;
  }
  else {
    unint64_t v4 = 0LL;
  }
  BOOL result = dyld4::APIs::validLoader((lsl::Allocator **)this, (const dyld4::Loader *)v4);
  if ((_DWORD)result)
  {
    BOOL result = 0LL;
    if (v4)
    {
      if ((*(_WORD *)(v4 + 4) & 1) == 0) {
        return *(void *)(v4 + 104) != 0LL;
      }
    }
  }

  return result;
}

char *dyld4::APIs::_dyld_find_pointer_hash_table_entry( dyld4::APIs *this, unsigned int *a2, DyldSharedCache *a3, unint64_t a4, const void **a5)
{
  uint64_t v10 = *((void *)this + 1);
  if (*(_BYTE *)(v10 + 204))
  {
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry(%p, %p, %lu, %p)\n", a2, a3, a4, a5);
    uint64_t v10 = *((void *)this + 1);
  }

  uint64_t v11 = *(DyldSharedCache **)(v10 + 240);
  if (!v11) {
    return 0LL;
  }
  uint64_t v12 = DyldSharedCache::swiftOpt(v11);
  if (!v12 || *(_DWORD *)v12 < 3u) {
    return 0LL;
  }
  uint64_t v13 = 0LL;
  while (1)
  {
    uint64_t v14 = *(void *)(v12 + 40 + v13);
    if (!v14) {
      goto LABEL_16;
    }
    v13 += 8LL;
    if (v13 == 64) {
      goto LABEL_16;
    }
  }

  if (!a2)
  {
LABEL_16:
    if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() invalid table pointer %p\n");
    }
    return 0LL;
  }

  if (!*(void *)(v12 + 32)) {
    return 0LL;
  }
  uint64_t v15 = *((void *)this + 1);
  if (a4 >= 0x40)
  {
    if (*(_BYTE *)(v15 + 204)) {
      dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() exceeded key pointers limit: %lu\n");
    }
    return 0LL;
  }

  uint64_t v18 = *(DyldSharedCache **)(v15 + 240);
  unint64_t v19 = (unint64_t)v18 + DyldSharedCache::mappedSize(v18);
  uint64_t v20 = *((void *)this + 1);
  if (v18 > a3 || v19 <= (unint64_t)a3)
  {
    if (!*(_BYTE *)(v20 + 204)) {
      return 0LL;
    }
    goto LABEL_40;
  }

  uint64_t v22 = *(void *)(v20 + 240);
  v30[0] = (char *)a3 - v22;
  if (a4)
  {
    uint64_t v23 = 0LL;
    while (1)
    {
      uint64_t v24 = (DyldSharedCache *)a5[v23];
      v30[++v23] = (char *)v24 - v22;
      if (a4 == v23)
      {
        int v26 = v23 + 1;
        goto LABEL_35;
      }
    }

    if (!*(_BYTE *)(v20 + 204)) {
      return 0LL;
    }
LABEL_40:
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() key %p not in shared cache\n");
    return 0LL;
  }

  int v26 = 1;
LABEL_35:
  uint64_t v28 = (objc *)v30;
  int v29 = v26;
  unsigned int Potential = SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a2, &v28);
  uint64_t v16 = 0LL;
  if (Potential != a2[4]) {
    uint64_t v16 = (char *)v18 + (*(void *)((_BYTE *)a2 + Potential + 8) & 0x7FFFFFFFFFFFFFFFLL);
  }
  if (*(_BYTE *)(*((void *)this + 1) + 204LL)) {
    dyld4::RuntimeState::log(this, "_dyld_find_pointer_hash_table_entry() => %p\n", v16);
  }
  return v16;
}

void ___ZN5dyld4L20findCacheInDirAndMapERNS_12RuntimeStateEPKhPKcRm_block_invoke( uint64_t a1, dyld3 *a2, DyldSharedCache *this)
{
  if (!DyldSharedCache::isSubCachePath(this, (const char *)a2)
    && !*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    if (stat64((const char *)a2, &v15) == -1)
    {
      unsigned int v9 = 0LL;
      st_vm_size_t size = 0x100000LL;
    }

    else
    {
      if (v15.st_size >= 0x100000uLL) {
        st_vm_size_t size = 0x100000LL;
      }
      else {
        st_vm_size_t size = v15.st_size;
      }
      int v6 = dyld3::open(a2, 0LL, 0LL);
      if (v6 < 0)
      {
        unsigned int v9 = 0LL;
      }

      else
      {
        int v7 = v6;
        uint64_t v8 = mmap(0LL, st_size, 1, 2, v6, 0LL);
        close(v7);
        else {
          unsigned int v9 = v8;
        }
      }
    }

    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v9;
    uint64_t v10 = *(DyldSharedCache **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    if (v10)
    {
      DyldSharedCache::getUUID(v10, (__n128 *)&v15);
      uint64_t v11 = *(uint64_t **)(a1 + 40);
      uint64_t v13 = *v11;
      uint64_t v12 = v11[1];
      if (*(void *)&v15.st_dev == v13 && v15.st_ino == v12)
      {
        **(void **)(a1 + 48) = st_size;
      }

      else
      {
        munmap(*(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), st_size);
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
      }
    }
  }

uint64_t objc::ObjectHashTable::forEachObject(unsigned int *a1, char *a2, uint64_t a3)
{
  uint64_t result = objc::StringHashTable::tryGetIndex((objc::StringHashTable *)a1, a2);
  if ((result & 0xFF00000000LL) != 0)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = (uint64_t)&a1[v6 + 264] + v6 + a1[4] + 1;
    unint64_t v8 = *(void *)(v7 + 8LL * result);
    uint64_t v9 = (v8 >> 1) & 0x7FFFFFFFFFFFLL;
    if ((v8 & 1) != 0)
    {
      unint64_t v10 = HIWORD(v8);
      if (v10)
      {
        uint64_t v11 = (unint64_t *)(v7 + 8 * v6 + 8 * v9 + 4);
        unint64_t v12 = v10 - 1;
        do
        {
          char v15 = 0;
          unint64_t v13 = *v11++;
          uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, char *))(a3 + 16))( a3,  (v13 >> 1) & 0x7FFFFFFFFFFFLL,  HIWORD(v13),  &v15);
          if (v15) {
            BOOL v14 = 1;
          }
          else {
            BOOL v14 = v12 == 0;
          }
          --v12;
        }

        while (!v14);
      }
    }

    else
    {
      char v16 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, char *))(a3 + 16))(a3, v9, HIWORD(v8), &v16);
    }
  }

  return result;
}

uint64_t objc::ObjectHashTable::forEachObject( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(result + 4);
  if (v8)
  {
    uint64_t v10 = result;
    unsigned int v11 = 0;
    int64x2_t v24 = vdupq_n_s64(1uLL);
    do
    {
      uint64_t v12 = v10 + (*(_DWORD *)(v10 + 16) + 1) + v8 + 1056;
      uint64_t v13 = v11;
      uint64_t v14 = *(int *)(v12 + 4LL * v11);
      if ((_DWORD)v14)
      {
        uint64_t v15 = v10 + v14;
        unint64_t v16 = *(void *)(v12 + 4LL * v8 + 8 * v13);
        if ((v16 & 1) != 0)
        {
          __chkstk_darwin(result, a2, v15, a4, a5, a6, a7, a8, v24.i64[0]);
          if (v17)
          {
            unint64_t v19 = &v24 - v17;
            do
            {
              v19->i64[0] = 0LL;
              v19->i16[4] = 0;
              ++v19;
            }

            while (v19 != &v24);
          }

          if (v17)
          {
            uint64_t v20 = (unint64_t *)(v10
                                     + *(unsigned int *)(v10 + 4)
                                     + (*(_DWORD *)(v10 + 16) + 1)
                                     + 4LL * *(unsigned int *)(v10 + 4)
                                     + 8LL * *(unsigned int *)(v10 + 4)
                                     + 8 * ((*(void *)(v18 + 8 * v13) >> 1) & 0x7FFFFFFFFFFFLL)
                                     + 1060);
            uint64_t v21 = &v24.i16[-8 * v17 + 4];
            uint64_t v22 = v17;
            do
            {
              unint64_t v23 = *v20++;
              *((void *)v21 - 1) = (v23 >> 1) & 0x7FFFFFFFFFFFLL;
              __int16 *v21 = HIWORD(v23);
              v21 += 8;
              --v22;
            }

            while (v22);
          }

          uint64_t v25 = &v24.i64[-2 * v17];
          v26.i64[0] = v17;
          v26.i64[1] = v17;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v13);
        }

        else
        {
          uint64_t v27 = (v16 >> 1) & 0x7FFFFFFFFFFFLL;
          __int16 v28 = HIWORD(v16);
          uint64_t v25 = &v27;
          int64x2_t v26 = v24;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t **))(a2 + 16))(a2, v13, v15, &v25);
        }
      }

      unsigned int v11 = v13 + 1;
      unsigned int v8 = *(_DWORD *)(v10 + 4);
    }

    while ((_DWORD)v13 + 1 != v8);
  }

  return result;
}

os_unfair_lock_s *lsl::Vector<dyld4::Loader const*>::resize(os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  8 * a2);
  }

  else
  {
    uint64_t v3 = result + 2;
    uint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

os_unfair_lock_s *lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize( os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  16 * a2);
  }

  else
  {
    uint64_t v3 = result + 2;
    uint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

void dyld4::APIs::dlopen_from(char const*,int,void *)::$_0::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)(*(void *)a1 + 48LL);
  unint64_t v4 = *(void *)(*(void *)a1 + 240LL);
  unint64_t v5 = *(void *)(*(void *)a1 + 304LL);
  Diagnostics::Diagnostics((Diagnostics *)&v108);
  uint64_t v6 = *(void *)(v2 + 24);
  v107[0] = 0LL;
  v107[1] = v6;
  uint64_t v7 = (void **)v107;
  uint64_t v105 = v107;
  unsigned int v8 = *(_DWORD **)(a1 + 16);
  uint64_t v106 = **(void **)(a1 + 8);
  LOBYTE(v9) = v106;
  uint64_t v104 = 0LL;
  uint64_t v97 = 0LL;
  LODWORD(v8) = *v8;
  *(_DWORD *)((char *)&v97 + 3) = (v8 & 4) != 0;
  WORD2(v97) = (v8 & 0x80) != 0;
  BYTE5(v97) = (v8 & 0x10) != 0;
  HIBYTE(v97) = 1;
  char v98 = 1;
  BOOL v99 = *(_DWORD *)(*(void *)(v2 + 8) + 68LL) == 1;
  BOOL v100 = (int)v8 < 0;
  if (v106)
  {
    int v9 = HIBYTE(*(unsigned __int16 *)(v106 + 4)) & 1;
    uint64_t v7 = &v105;
  }

  char v101 = v9;
  uint64_t v102 = v7;
  uint64_t v103 = 0LL;
  **(void **)(a1 + 24) = dyld4::Loader::getLoader( &v108,  (DyldSharedCache ***)v2,  **(const char ***)(a1 + 32),  (uint64_t)&v97);
  uint64_t v10 = **(dyld4::Loader ***)(a1 + 24);
  if (!v10)
  {
    unint64_t v79 = **(const char ***)(a1 + 32);
    int v80 = **(_DWORD **)(a1 + 16);
    uint64_t v81 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v108);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v79, v80, v81);
    goto LABEL_69;
  }

  unsigned int v11 = *(_DWORD **)(a1 + 16);
  if ((*v11 & 0x10) == 0)
  {
    uint64_t v12 = *(uint64_t **)(a1 + 24);
    if ((*v11 & 0x80) != 0 && (*(_WORD *)(*v12 + 4) & 0x63) == 0)
    {
      *(void *)(*v12 + 40) |= 0x200000uLL;
      unsigned int v11 = *(_DWORD **)(a1 + 16);
      uint64_t v12 = *(uint64_t **)(a1 + 24);
    }

    v96[0] = v102;
    v96[1] = *v12;
    *(void *)&__int128 v92 = 256LL;
    DWORD2(v92) = 0;
    uint64_t v94 = 0LL;
    uint64_t v95 = 0LL;
    uint64_t v93 = 0LL;
    BYTE4(v92) = (*v11 & 0x80) != 0;
    BYTE7(v92) = 1;
    BYTE11(v92) = *(_BYTE *)(*v12 + 5) & 1;
    uint64_t v93 = v96;
    dyld4::Loader::loadDependents(*v12, (vm_address_t *)&v108, (dyld4::RuntimeState *)v2, &v92);
    uint64_t v14 = lsl::AllocatorLayout::minSize(v13);
    __chkstk_darwin(v14, v15, v16, v17, v18, v19, v20, v21, v86);
    unint64_t v23 = (lsl::Allocator *)&v87[-v22 - 8];
    uint64_t v24 = *(void *)(v2 + 48);
    uint64_t v26 = lsl::AllocatorLayout::minSize(v25);
    int v29 = (lsl::Allocator *)lsl::Allocator::stackAllocatorInternal(v23, (char *)(v26 - v3 + 8 * v24 + 64), v27, v28);
    uint64_t v88 = v29;
    __int128 v89 = 0LL;
    unint64_t v90 = 0LL;
    uint64_t v91 = 0LL;
    lsl::Vector<void (*)(mach_header const*,long)>::reserveExact((uint64_t)&v88, *(void *)(v2 + 48) - v3);
    if (v3 != *(void *)(v2 + 48))
    {
      uint64_t v30 = v90;
      unint64_t v31 = v3;
      do
      {
        uint64_t v32 = *(void *)(v2 + 40);
        lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)&v88, v30 + 1);
        uint64_t v33 = *(dyld4::Loader **)(v32 + 8 * v31);
        uint64_t v34 = v90;
        uint64_t v30 = ++v90;
        v89[v34] = v33;
        ++v31;
      }

      while (v31 != *(void *)(v2 + 48));
    }

    dyld4::DyldCacheDataConstLazyScopedWriter::DyldCacheDataConstLazyScopedWriter( (uint64_t)v87,  (dyld4::RuntimeState *)v2);
    if (Diagnostics::noError((Diagnostics *)&v108) && v90)
    {
      if (*(_BYTE *)(*(void *)(v2 + 8) + 161LL))
      {
        uint64_t v109 = v89;
        *(void *)&__int128 v110 = v90;
        dyld4::Loader::addWeakDefsToMap((dyld4::RuntimeState *)v2, (uint64_t)&v109);
      }

      LODWORD(v109) = 520552460;
      __int128 v110 = 0u;
      __int128 v111 = 0u;
      __int128 v112 = 0u;
      __int128 v113 = 0u;
      __int128 v114 = 0u;
      __int128 v115 = 0u;
      uint64_t v116 = 0LL;
      dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v109, v35, v36, v37, v38, v39, v40, v41);
      if (v90)
      {
        uint64_t v42 = (uint64_t *)v89;
        uint64_t v43 = 8 * v90;
        do
        {
          uint64_t v44 = (dyld4::Loader *)*v42;
          dyld4::Loader::applyFixups( *v42,  (Diagnostics *)&v108,  v2,  (dyld4::DyldCacheDataConstLazyScopedWriter *)v87,  (**(_DWORD **)(a1 + 16) & 2) == 0,  *(void *)(a1 + 56));
          if (Diagnostics::hasError((Diagnostics *)&v108)) {
            break;
          }
          dyld4::Loader::applyCachePatches( v44,  (dyld4::RuntimeState *)v2,  (dyld4::DyldCacheDataConstLazyScopedWriter *)v87);
          ++v42;
          v43 -= 8LL;
        }

        while (v43);
      }

      dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v109);
      BOOL v45 = Diagnostics::noError((Diagnostics *)&v108);
      if (v45)
      {
        __chkstk_darwin(v45, v46, v47, v48, v49, v50, v51, v52, v86);
        uint64_t v54 = (dyld4::Loader **)&v87[-((v53 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        unint64_t v55 = v90;
        uint64_t v109 = v54;
        __int128 v110 = v90;
        if (v90)
        {
          unint64_t v56 = 0LL;
          uint64_t v57 = v89;
          uint64_t v58 = 8 * v90;
          do
          {
            uint64_t v59 = *v57;
            if ((*((_WORD *)*v57 + 2) & 0x22) == 0x20)
            {
              if (v56 >= v55) {
                ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1();
              }
              *((void *)&v110 + 1) = v56 + 1;
              v109[v56++] = v59;
            }

            ++v57;
            v58 -= 8LL;
          }

          while (v58);
          if (v56)
          {
            dyld4::RuntimeState::addPermanentRanges(v2, (uint64_t)&v109);
            unint64_t v55 = v90;
          }
        }

        uint64_t v117 = v89;
        uint64_t v118 = v55;
        dyld4::RuntimeState::notifyDtrace(v2, (uint64_t)&v117);
        uint64_t v117 = v89;
        uint64_t v118 = v90;
        dyld4::RuntimeState::rebindMissingFlatLazySymbols(v2, &v117);
      }
    }

    if (Diagnostics::noError((Diagnostics *)&v108)) {
      dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
    }
    if (!Diagnostics::hasError((Diagnostics *)&v108)) {
      goto LABEL_49;
    }
    unsigned int v60 = **(const char ***)(a1 + 32);
    int v61 = **(_DWORD **)(a1 + 16);
    uint64_t v62 = (const char *)Diagnostics::errorMessage((Diagnostics *)&v108);
    dyld4::APIs::setErrorString((vm_address_t *)v2, "dlopen(%s, 0x%04X): %s", v60, v61, v62);
    uint64_t v109 = v89;
    *(void *)&__int128 v110 = v90;
    dyld4::RuntimeState::removeMissingFlatLazySymbols(v2, (uint64_t)&v109);
    uint64_t v64 = v89;
    uint64_t v63 = v90;
    if (*(void *)(v2 + 336))
    {
      if (!v90)
      {
LABEL_43:
        if (*(void *)(v2 + 48) > v3) {
          *(void *)(v2 + 48) = v3;
        }
        **(void **)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
        **(void **)(a1 + 24) = 0LL;
        *(void *)(v2 + 272) = 0LL;
        if (*(void *)(v2 + 240) > v4) {
          *(void *)(v2 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v4;
        }
        if (*(void *)(v2 + 304) > v5) {
          *(void *)(v2 + 304) = v5;
        }
LABEL_49:
        if (**(void **)(a1 + 24) && (**(_BYTE **)(a1 + 16) & 0x10) == 0 && Diagnostics::noError((Diagnostics *)&v108))
        {
          uint64_t v117 = **(dyld4::Loader ****)(a1 + 24);
          dyld4::RuntimeState::partitionDelayLoads(v2, v89, v90, (dyld4::Loader **)&v117, 1LL, *(void *)(a1 + 64));
          if (*(void *)(*(void *)(v2 + 8) + 232LL))
          {
            strcpy((char *)&v109, "dlopen");
            uint64_t v69 = **(dyld4::Loader ***)(a1 + 8);
            if (v69)
            {
              uint64_t v70 = dyld4::Loader::leafName(v69, (const dyld4::RuntimeState *)v2);
              strlcpy((char *)&v109, v70, 0x100uLL);
              strlcat((char *)&v109, ": dlopen(", 0x100uLL);
              char v71 = dyld4::Loader::leafName(**(dyld4::Loader ***)(a1 + 24), (const dyld4::RuntimeState *)v2);
              strlcat((char *)&v109, v71, 0x100uLL);
              strlcat((char *)&v109, ")", 0x100uLL);
            }

            dyld4::Loader::logChainToLinksWith( **(dyld4::Loader ***)(a1 + 24),  (dyld4::RuntimeState *)v2,  (const char *)&v109);
          }

          uint64_t v72 = *(void *)(a1 + 64);
          uint64_t v73 = *(void *)(v72 + 16);
          if (v73)
          {
            uint64_t v109 = *(dyld4::Loader ***)(v72 + 8);
            *(void *)&__int128 v110 = v73;
            dyld4::RuntimeState::notifyDebuggerLoad((lsl::AllocatorLayout *)v2, (uint64_t)&v109);
            uint64_t v74 = *(void *)(a1 + 64);
            uint64_t v75 = *(void *)(v74 + 16);
            if (v75)
            {
              uint64_t v76 = *(dyld4::Loader ***)(v74 + 8);
              uint64_t v77 = 8 * v75;
              do
              {
                if ((*((_WORD *)*v76 + 2) & 0x1000) != 0)
                {
                  uint64_t v78 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*v76, (dyld4::RuntimeState *)v2);
                  dyld4::RuntimeState::setUpTLVs((dyld4::RuntimeState *)v2, v78);
                }

                ++v76;
                v77 -= 8LL;
              }

              while (v77);
            }
          }

          dyld4::RuntimeState::doSingletonPatching( (dyld4::RuntimeState *)v2,  (dyld4::DyldCacheDataConstLazyScopedWriter *)v87);
          dyld4::RuntimeState::notifyObjCPatching((dyld4::RuntimeState *)v2);
        }

        dyld4::DyldCacheDataConstLazyScopedWriter::~DyldCacheDataConstLazyScopedWriter((dyld4::DyldCacheDataConstLazyScopedWriter *)v87);
        if (v89) {
          lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v88, 0LL);
        }
        lsl::Allocator::~Allocator(v29);
        goto LABEL_69;
      }

      uint64_t v65 = 8 * v90;
      do
      {
        uint64_t v66 = *v64++;
        dyld4::RuntimeState::removeDynamicDependencies((void *)v2, v66);
        v65 -= 8LL;
      }

      while (v65);
      uint64_t v64 = v89;
      uint64_t v63 = v90;
    }

    if (v63)
    {
      uint64_t v67 = 8 * v63;
      do
      {
        uint64_t v68 = *v64++;
        dyld4::Loader::unmap(v68, (dyld4::RuntimeState *)v2, 1);
        v67 -= 8LL;
      }

      while (v67);
    }

    goto LABEL_43;
  }

  uint64_t v82 = dyld4::RuntimeState::incDlRefCount(v2, **(const dyld4::Loader ***)(a1 + 24));
  uint64_t v85 = **(void **)(a1 + 24);
  if ((v85 & 1) != 0) {
    dyld4::APIs::dlopen_from(v82, v83, v84);
  }
  **(void **)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v85 ^ (unint64_t)&dword_180058000 | **(unsigned __int8 **)(a1 + 48);
LABEL_69:
  mach_o::Error::~Error(&v108);
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( unsigned int *a1, objc *a2)
{
  uint64_t v3 = SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>(a1, a2);
  if ((_DWORD)v3 == -1)
  {
    uint64_t v7 = a1 + 4;
  }

  else
  {
    uint64_t v6 = *a1;
    if (v6 <= v3) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v3,  v4,  v5);
    }
    uint64_t v7 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v6);
  }

  return *v7;
}

uint64_t SwiftHashTable::getIndex<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( unsigned int *a1, objc *a2)
{
  uint64_t v4 = SwiftHashTable::hash<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, a2);
  if (*a1 <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v4,  v5,  v6);
  }
  uint64_t v7 = v4;
  int v8 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  uint64_t v9 = SwiftHashTable::checkbyte<SwiftTypeProtocolConformanceLocationKey>((uint64_t)a1, (unsigned __int8 *)a2);
  if (v8 != (_DWORD)v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *a1;
  if (v12 <= v7) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v9,  v10,  v11);
  }
  uint64_t v13 = *(unsigned int *)((char *)&a1[v7 + 264] + a1[5] + v12);
  if ((_DWORD)v13 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<SwiftTypeProtocolConformanceLocationKey,SwiftTypeProtocolConformanceLocationKey>( (uint64_t)a1,  (unsigned int *)((char *)a1 + v13),  a2))
  {
    return v7;
  }

  return 0xFFFFFFFFLL;
}

uint64_t SwiftHashTable::getPotentialTarget<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( a1,  a2,  a3);
  if ((_DWORD)v4 == -1)
  {
    int v8 = a1 + 4;
  }

  else
  {
    uint64_t v7 = *a1;
    if (v7 <= v4) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v4,  v5,  v6);
    }
    int v8 = (unsigned int *)((char *)&a1[v4 + 264] + a1[5] + v7);
  }

  return *v8;
}

uint64_t SwiftHashTable::getIndex<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = SwiftHashTable::hash<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2);
  if (*a1 <= v6) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v6,  v7,  v8);
  }
  uint64_t v9 = v6;
  int v10 = *((unsigned __int8 *)a1 + v6 + a1[5] + 1056);
  uint64_t v11 = SwiftHashTable::checkbyte<SwiftForeignTypeProtocolConformanceLookupKey>((uint64_t)a1, a2);
  if (v10 != (_DWORD)v11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *a1;
  if (v14 <= v9) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v11,  v12,  v13);
  }
  uint64_t v15 = *(unsigned int *)((char *)&a1[v9 + 264] + a1[5] + v14);
  if ((_DWORD)v15 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<SwiftForeignTypeProtocolConformanceLookupKey,SwiftForeignTypeProtocolConformanceLocationKey>( (uint64_t)a1,  (unsigned int *)((char *)a1 + v15),  a2,  a3))
  {
    return v9;
  }

  return 0xFFFFFFFFLL;
}

BOOL dyld4::EqualTypeConformanceKey::equal(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v4 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)a1);
  int v6 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8)) ^ v6) & 0xFFFLL) == 0;
}

BOOL dyld4::EqualForeignConformanceKey::equal(uint64_t a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  if (a3)
  {
    int v6 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value( (dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 8),  a3,  (uint64_t)a3);
    uint64_t v8 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value( (dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 8),  a3,  v7);
  }

  else
  {
    int v6 = *(const char **)a1;
    uint64_t v8 = *(const char **)a2;
  }

  size_t v9 = *(void *)(a1 + 16);
  if (_platform_strncmp(v6, v8, v9)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v9 == *(void *)(a2 + 16);
  }
  if (!v10) {
    return 0LL;
  }
  int v12 = dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a1 + 24));
  return ((dyld4::PrebuiltLoader::BindTargetRef::absValueOrOffset((dyld4::PrebuiltLoader::BindTargetRef *)(a2 + 24)) ^ v12) & 0xFFFLL) == 0;
}

uint64_t ***dyld4::APIs::_dyld_pseudodylib_register_callbacks(_dyld_pseudodylib_callbacks const*)::$_0::operator()( uint64_t ***result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[2];
  uint64_t v3 = **result;
  uint64_t v4 = *v3;
  if (*v3 == 3)
  {
    __int128 v14 = *(_OWORD *)(v3 + 1);
    __int128 v8 = *(_OWORD *)(v3 + 5);
    __int128 v11 = *(_OWORD *)(v3 + 3);
    __int128 v6 = *(_OWORD *)(v3 + 7);
    uint64_t result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Lock **)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)uint64_t result = v14;
    *((_OWORD *)result + 1) = v11;
    *((_OWORD *)result + 2) = v8;
    *((_OWORD *)result + 3) = v6;
  }

  else if (v4 == 2)
  {
    uint64_t v5 = (uint64_t **)v3[7];
    __int128 v15 = *(_OWORD *)(v3 + 1);
    __int128 v9 = *(_OWORD *)(v3 + 5);
    __int128 v12 = *(_OWORD *)(v3 + 3);
    uint64_t result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Lock **)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)uint64_t result = v15;
    *((_OWORD *)result + 1) = v12;
    *((_OWORD *)result + 2) = v9;
    result[6] = v5;
    result[7] = 0LL;
  }

  else
  {
    if (v4 != 1) {
      return result;
    }
    __int128 v13 = *(_OWORD *)(v3 + 1);
    __int128 v7 = *(_OWORD *)(v3 + 5);
    __int128 v10 = *(_OWORD *)(v3 + 3);
    uint64_t result = (uint64_t ***)lsl::Allocator::aligned_alloc((lsl::Lock **)v2[2], 8uLL, 0x40uLL);
    *(_OWORD *)uint64_t result = v13;
    *((_OWORD *)result + 1) = v10;
    *((_OWORD *)result + 2) = v7;
    result[6] = 0LL;
    result[7] = 0LL;
  }

  *v1[1] = (uint64_t *)result;
  return result;
}

uint64_t SwiftHashTable::getPotentialTarget<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>( unsigned int *a1, objc **a2)
{
  uint64_t v3 = SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>(a1, a2);
  if ((_DWORD)v3 == -1)
  {
    __int128 v7 = a1 + 4;
  }

  else
  {
    uint64_t v6 = *a1;
    if (v6 <= v3) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v3,  v4,  v5);
    }
    __int128 v7 = (unsigned int *)((char *)&a1[v3 + 264] + a1[5] + v6);
  }

  return *v7;
}

uint64_t SwiftHashTable::getIndex<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>( unsigned int *a1, objc **a2)
{
  uint64_t v4 = SwiftHashTable::hash<PointerHashTableBuilderKey>((uint64_t)a1, a2);
  if (*a1 <= v4) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v4,  v5,  v6);
  }
  uint64_t v7 = v4;
  int v8 = *((unsigned __int8 *)a1 + v4 + a1[5] + 1056);
  uint64_t v9 = SwiftHashTable::checkbyte<PointerHashTableBuilderKey>((uint64_t)a1, (uint64_t)a2);
  if (v8 != (_DWORD)v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *a1;
  if (v12 <= v7) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v9,  v10,  v11);
  }
  uint64_t v13 = *(unsigned int *)((char *)&a1[v7 + 264] + a1[5] + v12);
  if ((_DWORD)v13 == -1) {
    return 0xFFFFFFFFLL;
  }
  if (SwiftHashTable::equal<PointerHashTableBuilderKey,PointerHashTableOnDiskKey>( (uint64_t)a1,  (unsigned int *)((char *)a1 + v13),  (uint64_t)a2))
  {
    return v7;
  }

  return 0xFFFFFFFFLL;
}

void OUTLINED_FUNCTION_3_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void mach_o::Header::platformAndVersions(mach_o::Header *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x4002000000LL;
  uint64_t v10 = __Block_byref_object_copy__7;
  uint64_t v11 = __Block_byref_object_dispose__7;
  mach_o::Platform::Platform((mach_o::Platform *)v12, 0);
  *(void *)&__int128 v4 = 0x1000000010000LL;
  *((void *)&v4 + 1) = 0x1000000010000LL;
  *(_OWORD *)&void v12[8] = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke;
  void v6[3] = &unk_189620D00;
  v6[4] = &v7;
  mach_o::Header::forEachPlatformLoadCommand(this, (uint64_t)v6);
  uint64_t v5 = v8;
  *(void *)a2 = v8[5];
  *(_OWORD *)(a2 + 8) = *((_OWORD *)v5 + 3);
  _Block_object_dispose(&v7, 8);
}

__n128 __Block_byref_object_copy__7(__n128 *a1, __n128 *a2)
{
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void mach_o::Header::forEachPlatformLoadCommand(mach_o::Error *a1, uint64_t a2)
{
  v3[0] = 0LL;
  v3[1] = v3;
  v3[2] = 0x2000000000LL;
  char v4 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke;
  v2[3] = &unk_189620D28;
  v2[5] = v3;
  v2[6] = a1;
  v2[4] = a2;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v2, (mach_o::Error *)&v5);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(v3, 8);
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  char v4 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  uint64_t v5 = *a2;
  int v6 = a3;
  int v7 = a4;
  uint64_t v8 = 0x1000000010000LL;
  mach_o::PlatformAndVersions::zip(v4, &v5, (mach_o::Error *)&v9);
  if (v9) {
    ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1();
  }
  mach_o::Error::~Error(&v9);
}

mach_o::Error *mach_o::Header::forEachLoadCommand@<X0>( mach_o::Error *result@<X0>, uint64_t a2@<X1>, mach_o::Error *a3@<X8>)
{
  char v4 = result;
  int v6 = *(_DWORD *)result;
  if (*(_DWORD *)result == -17958193)
  {
    uint64_t v7 = 32LL;
  }

  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) == 0xCEFAEDFE) {
        return mach_o::Error::Error(a3, "big endian mach-o file");
      }
      else {
        return mach_o::Error::Error(a3, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
      }
    }

    uint64_t v7 = 28LL;
  }

  if (*((_DWORD *)result + 3) >= 0xDu) {
    return mach_o::Error::Error(a3, "unknown mach-o filetype (%u)");
  }
  if (*((_DWORD *)result + 4))
  {
    uint64_t v8 = (char *)result + v7;
    uint64_t v9 = (char *)result + v7 + *((unsigned int *)result + 5);
    int v10 = 1;
    for (uint64_t i = (char *)result + v7; ; uint64_t i = v13)
    {
      if (i >= v9) {
        return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, off end of load commands");
      }
      uint64_t v12 = *((unsigned int *)i + 1);
      uint64_t v13 = &i[v12];
      if (&i[v12] > v9 || v13 < v8) {
        return mach_o::Error::Error( a3,  "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      }
      __n128 result = (mach_o::Error *)(*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
    }

    return mach_o::Error::Error(a3, "malformed load command (%d of %d) at %p with mh=%p, size (0x%X) too small");
  }

  else
  {
LABEL_20:
    *(void *)a3 = 0LL;
  }

  return result;
}

uint64_t ___ZNK6mach_o6Header26forEachPlatformLoadCommandEU13block_pointerFvNS_8PlatformENS_9Version32ES2_E_block_invoke( uint64_t result, int *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 48);
  int v5 = *a2;
  if (*a2 <= 46)
  {
    if (v5 == 36)
    {
      uint64_t v11 = a2[2];
      unsigned int v12 = a2[3];
      if (v12) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v11;
      }
      uint64_t v14 = *(void *)(result + 32);
      uint64_t v21 = 0x189622810LL;
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v14 + 16))(v14, &v21, v11, v13);
    }

    else
    {
      if (v5 != 37) {
        return result;
      }
      uint64_t v7 = *(void *)(result + 32);
      if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
      {
        uint64_t v20 = 0x1896228D0LL;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v7 + 16))( v7,  &v20,  a2[2],  a2[3]);
      }

      else
      {
        uint64_t v19 = 0x189622870LL;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v7 + 16))( v7,  &v19,  a2[2],  a2[3]);
      }
    }
  }

  else
  {
    switch(v5)
    {
      case '/':
        uint64_t v8 = *(void *)(result + 32);
        if (*(_DWORD *)(v4 + 4) == 16777223)
        {
          uint64_t v18 = 0x189622990LL;
          uint64_t v9 = &v18;
        }

        else
        {
          uint64_t v17 = 0x189622930LL;
          uint64_t v9 = &v17;
        }

        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v8 + 16))( v8,  v9,  a2[2],  a2[3]);
        break;
      case '0':
        uint64_t v10 = *(void *)(result + 32);
        if ((*(_DWORD *)(v4 + 4) | 0x1000000) == 0x1000007)
        {
          uint64_t v16 = 0x189622B10LL;
          __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v10 + 16))( v10,  &v16,  a2[2],  a2[3]);
        }

        else
        {
          uint64_t v15 = 0x189622AB0LL;
          __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, void, void))(v10 + 16))( v10,  &v15,  a2[2],  a2[3]);
        }

        break;
      case '2':
        uint64_t v6 = *(void *)(result + 32);
        mach_o::Platform::Platform((mach_o::Platform *)v22, a2[2]);
        __n128 result = (*(uint64_t (**)(uint64_t, char *, void, void))(v6 + 16))( v6,  v22,  a2[3],  a2[4]);
        break;
      default:
        return result;
    }
  }

  *(_BYTE *)(*(void *)(*(void *)(v3 + 40) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t mach_o::Header::getDylibInstallName(mach_o::Error *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke;
  void v6[3] = &unk_189620D50;
  v6[6] = a4;
  void v6[7] = a2;
  v6[4] = &v7;
  void v6[5] = a3;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v6, (mach_o::Error *)&v11);
  mach_o::Error::~Error(&v11);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZNK6mach_o6Header19getDylibInstallNameEPPKcPNS_9Version32ES5__block_invoke( uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 13)
  {
    uint64_t v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2[5];
    *uint64_t v3 = a2[4];
    **(void **)(result + 56) = (char *)a2 + a2[2];
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

uint64_t mach_o::Header::linkedDylibCount(mach_o::Header *this, BOOL *a2)
{
  if (a2) {
    *a2 = 1;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke;
  void v4[3] = &unk_189620D78;
  v4[4] = &v5;
  void v4[5] = a2;
  mach_o::Header::forEachLinkedDylib(this, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void mach_o::Header::forEachLinkedDylib(mach_o::Error *a1, uint64_t a2)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  int v18 = 0;
  uint64_t v11 = 0LL;
  unsigned int v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke;
  void v10[3] = &unk_189620DA0;
  void v10[4] = a2;
  v10[5] = &v15;
  void v10[6] = &v11;
  mach_o::Header::forEachLoadCommand(a1, (uint64_t)v10, (mach_o::Error *)v19);
  mach_o::Error::~Error(v19);
  if (!*((_DWORD *)v16 + 6) && !*((_BYTE *)v12 + 24))
  {
    mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
    if (v19[0] == (vm_address_t *)&mach_o::PlatformInfo_driverKit::singleton)
    {
      if (*((_DWORD *)a1 + 3) != 6
        || ((int v20 = 0x10000,
             int v21 = 0x10000,
             !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
          ? (int v8 = 0LL)
          : (int v8 = (const char *)v19[0]),
            _platform_strncmp(v8, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        uint64_t v7 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }

    else
    {
      mach_o::Header::platformAndVersions(a1, (uint64_t)v19);
      BOOL isExclaveKit = mach_o::Platform::isExclaveKit((mach_o::Platform *)v19);
      int v5 = *((_DWORD *)a1 + 3);
      if (isExclaveKit)
      {
        if (v5 != 6
          || ((int v20 = 0x10000,
               int v21 = 0x10000,
               !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
            ? (uint64_t v6 = 0LL)
            : (uint64_t v6 = (const char *)v19[0]),
              _platform_strncmp(v6, "/System/ExclaveKit/usr/lib/system/", 0x22uLL)))
        {
          uint64_t v7 = "/System/ExclaveKit/usr/lib/libSystem.dylib";
LABEL_23:
          (*(void (**)(uint64_t, const char *, void, uint64_t, uint64_t, uint64_t *))(a2 + 16))( a2,  v7,  0LL,  0x10000LL,  0x10000LL,  v12 + 3);
        }
      }

      else if (v5 != 6 {
             || ((int v20 = 0x10000,
      }
                  int v21 = 0x10000,
                  !mach_o::Header::getDylibInstallName(a1, (uint64_t)v19, (uint64_t)&v21, (uint64_t)&v20))
               ? (uint64_t v9 = 0LL)
               : (uint64_t v9 = (const char *)v19[0]),
                 _platform_strncmp(v9, "/usr/lib/system/", 0x10uLL)))
      {
        uint64_t v7 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_23;
      }
    }
  }

  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
}

uint64_t ___ZNK6mach_o6Header16linkedDylibCountEPb_block_invoke(uint64_t result, uint64_t a2, char a3)
{
  uint64_t v3 = *(_BYTE **)(result + 40);
  if (v3) {
    BOOL v4 = a3 == 0LL;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    *uint64_t v3 = 0;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL);
  return result;
}

uint64_t mach_o::Header::loadCommandToDylibKind(mach_o::Header *this, const dylib_command *a2)
{
  if (*((_DWORD *)this + 3) == 443815936 && *((_DWORD *)this + 2) == 28) {
    return *((unsigned int *)this + 6);
  }
  int v3 = *(_DWORD *)this;
  if (*(int *)this > -2147483614)
  {
    if (v3 == -2147483613)
    {
      return 4LL;
    }

    else
    {
      if (v3 != 12) {
        goto LABEL_14;
      }
      return 0LL;
    }
  }

  else
  {
    if (v3 != -2147483624)
    {
      if (v3 == -2147483617) {
        return 2LL;
      }
LABEL_14:
      mach_o::Header::loadCommandToDylibKind();
    }

    return 1LL;
  }

uint64_t ___ZNK6mach_o6Header18forEachLinkedDylibEU13block_pointerFvPKcNS_21LinkedDylibAttributesENS_9Version32ES4_RbE_block_invoke( uint64_t result, mach_o::Header *this, _BYTE *a3)
{
  if ((*(_DWORD *)this + 2147483624) <= 0xB && ((1 << (*(_DWORD *)this - 24)) & 0x881) != 0
    || *(_DWORD *)this == 12)
  {
    uint64_t v7 = result;
    int v8 = (char *)this + *((unsigned int *)this + 2);
    uint64_t v9 = *(void *)(result + 32);
    unsigned __int8 CommandToDylibKind = mach_o::Header::loadCommandToDylibKind(this, (const dylib_command *)this);
    __n128 result = (*(uint64_t (**)(uint64_t, char *, void, void, void, _BYTE *))(v9 + 16))( v9,  v8,  CommandToDylibKind,  *((unsigned int *)this + 5),  *((unsigned int *)this + 4),  a3);
    ++*(_DWORD *)(*(void *)(*(void *)(v7 + 40) + 8LL) + 24LL);
    if (*a3) {
      *(_BYTE *)(*(void *)(*(void *)(v7 + 48) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

unint64_t prebuilt_objc::findSelector(dyld4::RuntimeState *a1, void *a2, const char *a3)
{
  int v8 = a3;
  int v5 = (dyld4::PrebuiltLoader::BindTargetRef *)dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>( (uint64_t)a2,  a2,  a2 + 3,  a1,  &v8);
  if (v5 == (dyld4::PrebuiltLoader::BindTargetRef *)(a2[3] + 8LL * a2[5])) {
    return 0LL;
  }
  else {
    return dyld4::PrebuiltLoader::BindTargetRef::value(v5, a1, v6);
  }
}

void prebuilt_objc::forEachClass(dyld4::RuntimeState *a1, void *a2, const char *a3, uint64_t a4)
{
  int v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  void v4[3] = &unk_189620DC8;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>( (uint64_t)a2,  a2,  a2 + 3,  a1,  &v5,  (uint64_t)v4);
}

uint64_t ___ZN13prebuilt_objc12forEachClassEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 16))
  {
    __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, v18[0]);
    unsigned int v12 = (char *)v18 - ((v11 + 23) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = v9[2];
    v18[0] = (uint64_t)v12;
    v18[1] = v13;
    if (v13)
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = *v9;
      uint64_t v16 = 8 * v13;
      do
      {
        if (v13 == v14) {
          dyld4::RuntimeState::appendInterposingTuples(v8, (uint64_t)v9, v10);
        }
        uint64_t v17 = v14 + 1;
        *(void *)&v12[8 * v14] = *(void *)(v15 + 8 * v14);
        ++v14;
        v16 -= 8LL;
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    v18[2] = v17;
    return (*(uint64_t (**)(void, uint64_t *, uint64_t))(*(void *)(v8 + 32) + 16LL))( *(void *)(v8 + 32),  v18,  v10);
  }

  return result;
}

void prebuilt_objc::forEachProtocol(dyld4::RuntimeState *a1, void *a2, const char *a3, uint64_t a4)
{
  int v5 = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke;
  void v4[3] = &unk_189620DF0;
  v4[4] = a4;
  dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>( (uint64_t)a2,  a2,  a2 + 3,  a1,  &v5,  (uint64_t)v4);
}

uint64_t ___ZN13prebuilt_objc15forEachProtocolEPN5dyld412RuntimeStateERKN5dyld312MultiMapViewINS_19ObjCStringKeyOnDiskENS_24ObjCObjectOnDiskLocationENS_23HashObjCStringKeyOnDiskENS_24EqualObjCStringKeyOnDiskEEEPKcU13block_pointerFvRKNS3_5ArrayIPKNS0_14PrebuiltLoader13BindTargetRefEEEE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 16))
  {
    __chkstk_darwin(result, a2, a3, a4, a5, a6, a7, a8, v18[0]);
    unsigned int v12 = (char *)v18 - ((v11 + 23) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = v9[2];
    v18[0] = (uint64_t)v12;
    v18[1] = v13;
    if (v13)
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = *v9;
      uint64_t v16 = 8 * v13;
      do
      {
        if (v13 == v14) {
          dyld4::RuntimeState::appendInterposingTuples(v8, (uint64_t)v9, v10);
        }
        uint64_t v17 = v14 + 1;
        *(void *)&v12[8 * v14] = *(void *)(v15 + 8 * v14);
        ++v14;
        v16 -= 8LL;
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    v18[2] = v17;
    return (*(uint64_t (**)(void, uint64_t *, uint64_t))(*(void *)(v8 + 32) + 16LL))( *(void *)(v8 + 32),  v18,  v10);
  }

  return result;
}

uint64_t prebuilt_objc::forEachClass( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a1;
  v13[0] = a1 + 1;
  v13[1] = v8;
  uint64_t v9 = &a1[v8];
  uint64_t v10 = v9[1];
  uint64_t v13[2] = v8;
  v14[0] = (uint64_t)(v9 + 2);
  v14[1] = v10;
  _WORD v14[2] = v10;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke;
  v12[3] = &unk_189620E18;
  v12[4] = a2;
  return dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry( (uint64_t)v13,  (uint64_t)v13,  v14,  (uint64_t)v12,  a5,  a6,  a7,  a8);
}

uint64_t ___ZN13prebuilt_objc12forEachClassEPKvU13block_pointerFvRKN5dyld414PrebuiltLoader13BindTargetRefERKN5dyld35ArrayIPS5_EEE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = (char *)v18 - ((v12 + 23) & 0xFFFFFFFFFFFFFFF0LL);
  v18[0] = (uint64_t)v13;
  v18[1] = v11;
  if (v11)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = *v10;
    do
    {
      if (v11 == v14) {
        dyld4::RuntimeState::appendInterposingTuples(v8, v9, (uint64_t)v10);
      }
      uint64_t v16 = v14 + 1;
      *(void *)&v13[8 * v14] = *(void *)(v15 + 8 * v14);
      ++v14;
      v12 -= 8LL;
    }

    while (v12);
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  v18[2] = v16;
  return (*(uint64_t (**)(void, uint64_t, uint64_t *))(*(void *)(v8 + 32) + 16LL))( *(void *)(v8 + 32),  v9,  v18);
}

unint64_t prebuilt_objc::hashStringKey(uint64_t a1)
{
  return murmurHash(*(uint64_t **)a1, *(_DWORD *)(a1 + 8), 0LL);
}

dyld4::PrebuiltObjC::ObjCOptimizerImage *dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage( dyld4::PrebuiltObjC::ObjCOptimizerImage *this, const dyld4::JustInTimeLoader *a2, uint64_t a3, int a4)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a4;
  *((void *)this + 2) = a3;
  *((_BYTE *)this + 24) = 1;
  Diagnostics::Diagnostics((dyld4::PrebuiltObjC::ObjCOptimizerImage *)((char *)this + 32));
  *((void *)this + 19) = 0LL;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 160);
  dyld3::Map<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::Map((uint64_t)this + 256);
  *((void *)this + 48) = 0LL;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::Map((uint64_t)this + 392);
  *((void *)this + 69) = 0LL;
  *((_DWORD *)this + 14dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 52dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)((char *)this + 535) = 0u;
  return this;
}

void *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitReferenceToObjCSelector( uint64_t a1, objc::StringHashTable *this, uint64_t *a3, int a4, int a5, unint64_t a6, char a7, char *__s)
{
  uint64_t Index = objc::StringHashTable::tryGetIndex(this, __s);
  if ((Index & 0xFF00000000LL) != 0)
  {
    unint64_t Absolute = dyld4::PrebuiltLoader::BindTargetRef::makeAbsolute((dyld4::PrebuiltLoader::BindTargetRef *)*(int *)((char *)this + 4 * Index + *((unsigned int *)this + 1) + *((_DWORD *)this + 4) + 1 + 1056));
    __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(a1 + 352), 1LL);
    uint64_t v17 = *(void *)(a1 + 352);
    uint64_t v18 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = v18 + 1;
    *(void *)(v17 + 8 * v18) = Absolute;
    return result;
  }

  v31.var0 = (Loader *)__s;
  v31.unint64_t var1 = _platform_strlen(__s);
  uint64_t v19 = dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>( (uint64_t)a3,  a3 + 2,  a3 + 7,  0LL,  (uint64_t)&v31);
  if (v19 == a3[7] + 32 * a3[9])
  {
    uint64_t v29 = 0LL;
    uint64_t v30 = 0LL;
    BindTarget v28 = v31;
    uint64_t v22 = (BindTarget *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( a1 + 392,  (uint64_t)&v28);
    if ((v23 & 1) != 0)
    {
      v28.var0 = *(Loader **)a1;
      if (!a7) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      v28.unint64_t var1 = a6;
      v22[1] = v28;
      dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v27, &v28);
      __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace((void *)(a1 + 352), 1LL);
      uint64_t v24 = *(void *)(a1 + 352);
      uint64_t v25 = *(void *)(a1 + 368);
      *(void *)(a1 + 368) = v25 + 1;
      var0 = v27;
      goto LABEL_8;
    }

    int v21 = v22 + 1;
    int v20 = (void *)(a1 + 352);
  }

  else
  {
    int v20 = (void *)(a1 + 352);
    int v21 = (const BindTarget *)(v19 + 16);
  }

  dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v28, v21);
  __n128 result = dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v20, 1LL);
  uint64_t v24 = *(void *)(a1 + 352);
  uint64_t v25 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = v25 + 1;
  var0 = v28.var0;
LABEL_8:
  *(void *)(v24 + 8 * v25) = var0;
  return result;
}

uint64_t dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v29, 0, sizeof(v29));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v29, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v29, 1LL);
      uint64_t v6 = (*(void *)&v29[1])++;
      *(_DWORD *)(*(void *)&v29[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        unint64_t v9 = murmurHash(*(uint64_t **)v8, *(_DWORD *)(v8 + 8), 0LL);
        unint64_t v10 = (*(void *)&v29[1] - 1LL) & v9;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v10) != -1)
        {
          uint64_t v11 = 1LL;
          do
            unint64_t v10 = (*(void *)&v29[1] - 1LL) & (v10 + v11++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v10) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v29, v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v29)
    {
      *(void *)&v29[1] = 0LL;
      if (*((void *)&v29[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v29[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v12 = *(void *)(a1 + 40);
      if (v12) {
        vm_deallocate(mach_task_self_, v12, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v29[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v29 + 8);
      vm_size_t v13 = size;
      *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)&v29[1] + 1);
      *(void *)(a1 + 48) = v13;
    }
  }

  unint64_t v14 = (*(void *)(a1 + 32) - 1LL) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0LL);
  unint64_t v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14);
  if ((_DWORD)v15 == -1)
  {
LABEL_21:
    uint64_t v19 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14) = v19;
    ++*(void *)(a1 + 8);
    int v20 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v24 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v24 + 1;
    uint64_t v25 = (_OWORD *)(v23 + 32 * v24);
    __int128 v26 = *(_OWORD *)(a2 + 16);
    *uint64_t v25 = *(_OWORD *)a2;
    v25[1] = v26;
    uint64_t v27 = *(void *)(a1 + 72);
    if (!v27) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v20,  v21,  v22);
    }
    return *(void *)(a1 + 56) + 32 * v27 - 32;
  }

  else
  {
    uint64_t v16 = 1LL;
    while (1)
    {
      uint64_t v17 = dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v15);
      size_t v18 = *(void *)(v17 + 8);
      if (v18 == *(void *)(a2 + 8) && !_platform_memcmp(*(const void **)v17, *(const void **)a2, v18)) {
        return dyld3::OverflowSafeArray<dyld4::RuntimeState::PermanentRanges::Range,4294967295ull>::operator[]( (void *)(a1 + 56),  v15);
      }
      unint64_t v14 = (*(void *)(a1 + 32) - 1LL) & (v14 + v16++);
      unint64_t v15 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v14);
      if ((_DWORD)v15 == -1) {
        goto LABEL_21;
      }
    }
  }

void *dyld4::PrebuiltObjC::ObjCOptimizerImage::visitClass( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, char a10, char *a11)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000LL;
  _OWORD v21[2] = ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
  void v21[3] = &__block_descriptor_tmp_36_0;
  void v21[4] = a5;
  uint64_t v21[5] = a6;
  void v21[6] = a11;
  void v21[7] = a2;
  void v21[8] = a3;
  v21[9] = a1;
  objc::ObjectHashTable::forEachObject(a4, a11, (uint64_t)v21);
  if (!a10 || !*(_BYTE *)(a1 + 24) || !a8) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v14 = *(void *)(a1 + 16);
  unint64_t v15 = (char *)(a9 - v14);
  uint64_t v16 = (char *)(a7 - v14);
  __n128 result = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace( (void *)(a1 + 40),  1LL);
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v19 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v19 + 1;
  int v20 = (char **)(v18 + 40 * v19);
  void *v20 = a11;
  v20[1] = v15;
  void v20[2] = (char *)1;
  v20[3] = v16;
  v20[4] = (char *)1;
  return result;
}

void dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, char a7, char *a8)
{
  uint64_t v16 = *(void *)(a1 + 136);
  dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace((void *)(a1 + 120), 1LL);
  uint64_t v17 = *(void *)(a1 + 120);
  uint64_t v18 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = v18 + 1;
  *(_BYTE *)(v17 + v18) = 0;
  uint64_t v31 = 0LL;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2000000000LL;
  char v34 = 0;
  uint64_t v25 = _NSConcreteStackBlock;
  uint64_t v26 = 0x40000000LL;
  uint64_t v27 = ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke;
  BindTarget v28 = &unk_189621000;
  uint64_t v29 = &v31;
  uint64_t v30 = a3;
  objc::ObjectHashTable::forEachObject(a2, a8, (uint64_t)&v25);
  LODWORD(a3) = *((unsigned __int8 *)v32 + 24);
  _Block_object_dispose(&v31, 8);
  if (!(_DWORD)a3)
  {
    if (!a7 || !*(_BYTE *)(a1 + 24) || !a5) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v19 = *(void *)(a1 + 16);
    int v20 = (char *)(a6 - v19);
    uint64_t v21 = (void **)(a4 - v19);
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace( (void *)(a1 + 80),  1LL);
    uint64_t v22 = *(void *)(a1 + 80);
    uint64_t v23 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v23 + 1;
    uint64_t v24 = (char **)(v22 + 40 * v23);
    DyldSharedCache *v24 = a8;
    v24[1] = v20;
    _OWORD v24[2] = (char *)1;
    v24[3] = (char *)v21;
    v24[4] = (char *)1;
    uint64_t v25 = v21;
    uint64_t v26 = 1LL;
    LODWORD(v27) = 0;
    *(_DWORD *)(dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert( a1 + 256,  (uint64_t)&v25)
              + 16) = v16;
  }

__n128 dyld4::PrebuiltObjC::commitImage( dyld4::PrebuiltObjC *this, const dyld4::PrebuiltObjC::ObjCOptimizerImage *a2)
{
  uint64_t v4 = *((void *)a2 + 29);
  if (v4)
  {
    unint64_t v5 = (unint64_t *)*((void *)a2 + 27);
    uint64_t v6 = &v5[3 * v4];
    do
    {
      __int128 v14 = *v5;
      uint64_t v15 = 0LL;
      uint64_t v7 = dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert( (uint64_t)this + 344,  &v14);
      __n128 result = *(__n128 *)(v5 + 1);
      *(__n128 *)(v7 + 8) = result;
      v5 += 3;
    }

    while (v5 != v6);
  }

  uint64_t v9 = *((void *)a2 + 58);
  if (v9)
  {
    uint64_t v10 = *((void *)a2 + 56);
    uint64_t v11 = v10 + 32 * v9;
    vm_address_t v12 = (char *)this + 40;
    do
    {
      __int128 v14 = *(_OWORD *)v10;
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      vm_size_t v13 = (__n128 *)dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( (uint64_t)v12,  (uint64_t)&v14);
      __n128 result = *(__n128 *)(v10 + 16);
      v13[1] = result;
      v10 += 32LL;
    }

    while (v10 != v11);
  }

  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeSelectorMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>( (uint64_t)this + 40,  a2,  (uint64_t)&__block_literal_global_1);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC20serializeSelectorMapERNS_13BumpAllocatorE_block_invoke( Absolute a1)
{
  return (ObjCStringKeyOnDisk)v3;
}

void *dyld3::Map<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,void>( uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3)
{
  uint64_t v11 = *(void *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v11, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 4 * v11);
  uint64_t v11 = *(void *)(a1 + 72);
  __n128 result = dyld4::BumpAllocator::append(this, &v11, 8uLL);
  uint64_t v7 = *(void *)(a1 + 72);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = v8 + 32 * v7;
    do
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v8, v8 + 16);
      __n128 result = dyld4::BumpAllocator::append(this, &v10, 8uLL);
      v8 += 32LL;
    }

    while (v8 != v9);
  }

  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeClassMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>( (uint64_t)this + 136,  a2,  (uint64_t)&__block_literal_global_13,  (uint64_t)&__block_literal_global_16);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC17serializeClassMapERNS_13BumpAllocatorE_block_invoke( Absolute a1)
{
  return (ObjCStringKeyOnDisk)v3;
}

ObjCObjectOnDiskLocation ___ZNK5dyld412PrebuiltObjC17serializeClassMapERNS_13BumpAllocatorE_block_invoke_2( Absolute a1)
{
  return (ObjCObjectOnDiskLocation)v3;
}

void *dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>( uint64_t a1, dyld4::BumpAllocator *this, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = *(void *)(a1 + 32);
  dyld4::BumpAllocator::append(this, &v13, 8uLL);
  dyld4::BumpAllocator::append(this, *(const void **)(a1 + 16), 8 * v13);
  uint64_t v13 = *(void *)(a1 + 72);
  __n128 result = dyld4::BumpAllocator::append(this, &v13, 8uLL);
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = v10 + 56 * v9;
    do
    {
      v12[0] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v10, v10 + 16);
      v12[1] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v10, v10 + 16);
      v12[2] = *(void *)(v10 + 48);
      __n128 result = dyld4::BumpAllocator::append(this, v12, 0x18uLL);
      v10 += 56LL;
    }

    while (v10 != v11);
  }

  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeProtocolMap(dyld4::PrebuiltObjC *this, dyld4::BumpAllocator *a2)
{
  uint64_t v2 = (*((_DWORD *)a2 + 4) - *(_DWORD *)a2);
  dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::serialize<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation>( (uint64_t)this + 240,  a2,  (uint64_t)&__block_literal_global_18,  (uint64_t)&__block_literal_global_20);
  return v2;
}

ObjCStringKeyOnDisk ___ZNK5dyld412PrebuiltObjC20serializeProtocolMapERNS_13BumpAllocatorE_block_invoke( Absolute a1)
{
  return (ObjCStringKeyOnDisk)v3;
}

ObjCObjectOnDiskLocation ___ZNK5dyld412PrebuiltObjC20serializeProtocolMapERNS_13BumpAllocatorE_block_invoke_2( Absolute a1)
{
  return (ObjCObjectOnDiskLocation)v3;
}

uint64_t dyld4::PrebuiltObjC::generateHashTables(dyld4::PrebuiltObjC *this)
{
  uint64_t v2 = (char *)this + 344;
  dyld4::generateClassOrProtocolHashTable( 0LL,  (uint64_t *)this,  (uint64_t)this + 344,  (uint64_t)this + 136,  (_BYTE *)this + 440);
  return dyld4::generateClassOrProtocolHashTable(1LL, (uint64_t *)this, (uint64_t)v2, (uint64_t)this + 240, &v4);
}

uint64_t dyld4::generateClassOrProtocolHashTable( uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  int v35 = result;
  unint64_t v5 = a2[2];
  if (v5)
  {
    uint64_t v7 = 0LL;
    uint64_t v36 = (void *)(a3 + 56);
    uint64_t v37 = (uint64_t *)(a3 + 16);
    unint64_t v8 = a2[2];
    do
    {
      unint64_t v9 = v8 - 1;
      if (v5 <= v9) {
        ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( result,  (uint64_t)a2,  a3);
      }
      uint64_t v42 = v7;
      unint64_t v44 = v9;
      __n128 result = Diagnostics::hasError((Diagnostics *)(*a2 + 568 * v9 + 32));
      if ((result & 1) == 0)
      {
        if (a2[2] <= v44) {
          ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( result,  (uint64_t)a2,  a3);
        }
        uint64_t v10 = *a2;
        BOOL v45 = (uint64_t *)(*a2 + 568 * v44);
        if (v35 == 1)
        {
          uint64_t v22 = v10 + 568 * v44;
          uint64_t v23 = *(void *)(v22 + 96);
          if (v23)
          {
            uint64_t v24 = (void *)(v10 + 568 * v44);
            uint64_t v41 = v24 + 32;
            uint64_t v40 = v24 + 34;
            uint64_t v25 = v24 + 39;
            uint64_t v39 = v24 + 41;
            uint64_t v26 = v24 + 15;
            uint64_t v27 = 40 * v23;
            uint64_t v28 = *(void *)(v22 + 80) + 16LL;
            do
            {
              if (!*(_BYTE *)v28 || !*(_BYTE *)(v28 + 16)) {
LABEL_31:
              }
                std::__throw_bad_optional_access[abi:nn180100]();
              uint64_t v29 = *v45;
              uint64_t v30 = *(void *)(v28 + 8);
              uint64_t v32 = *(const char **)(v28 - 16);
              uint64_t v31 = *(void *)(v28 - 8);
              size_t v33 = _platform_strlen(v32);
              v54[0] = 0;
              uint64_t v48 = v32;
              size_t v49 = v33;
              uint64_t v50 = v29;
              uint64_t v51 = v31;
              uint64_t v52 = v29;
              uint64_t v53 = v30;
              __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( a4,  (uint64_t)&v48,  v54);
              if (!v54[0])
              {
                uint64_t v34 = dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>( (BOOL)v41,  v40,  v25,  0LL,  v28 + 8);
                if (v34 == *v25 + 24LL * *v39) {
                  dyld4::generateClassOrProtocolHashTable();
                }
                __n128 result = dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](v26, *(unsigned int *)(v34 + 16));
                *(_BYTE *)__n128 result = 1;
              }

              v28 += 40LL;
              v27 -= 40LL;
            }

            while (v27);
          }
        }

        else if (!v35)
        {
          uint64_t v11 = v10 + 568 * v44;
          uint64_t v12 = *(void *)(v11 + 56);
          if (v12)
          {
            uint64_t v13 = *(void *)(v11 + 40);
            uint64_t v14 = 40 * v12;
            while (1)
            {
              if (!*(_BYTE *)(v13 + 16) || !*(_BYTE *)(v13 + 32)) {
                goto LABEL_31;
              }
              uint64_t v15 = *v45;
              uint64_t v16 = *(void *)(v13 + 24);
              uint64_t v18 = *(const char **)v13;
              uint64_t v17 = *(void *)(v13 + 8);
              size_t v19 = _platform_strlen(*(const char **)v13);
              v54[0] = 0;
              uint64_t v48 = v18;
              size_t v49 = v19;
              uint64_t v50 = v15;
              uint64_t v51 = v17;
              uint64_t v52 = v15;
              uint64_t v53 = v16;
              __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( a4,  (uint64_t)&v48,  v54);
              if (v54[0]) {
                goto LABEL_15;
              }
              uint64_t v20 = result;
              __n128 result = (uint64_t)dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>( a3,  v37,  v36,  0LL,  (const char **)v13);
              if (result != *(void *)(a3 + 56) + 24LL * *(void *)(a3 + 72)) {
                break;
              }
LABEL_16:
              v13 += 40LL;
              v14 -= 40LL;
              if (!v14) {
                goto LABEL_26;
              }
            }

            __int128 v21 = *(_OWORD *)(result + 8);
            *(void *)(v20 + 16) = v15;
            *(void *)(v20 + 24) = v17;
            *(_OWORD *)(v20 + 32) = v21;
            uint64_t v48 = v18;
            size_t v49 = v19;
            uint64_t v50 = v15;
            uint64_t v51 = v17;
            uint64_t v52 = v15;
            uint64_t v53 = v16;
            __n128 result = dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( a4,  (uint64_t)&v48,  v47);
LABEL_15:
            *a5 = 1;
            goto LABEL_16;
          }
        }
      }

void dyld4::PrebuiltObjC::generatePerImageFixups(vm_address_t *this, dyld4::RuntimeState *a2)
{
  uint64_t v3 = *((void *)a2 + 6);
  if (v3)
  {
    unsigned __int16 v4 = 0;
    uint64_t v5 = *((void *)a2 + 5);
    uint64_t v6 = 8 * v3;
    do
    {
      if ((*(_WORD *)(*(void *)v5 + 4LL) & 1) == 0)
      {
        int v7 = *(__int16 *)(*(void *)v5 + 6LL);
        if ((v7 & 0x80000000) == 0) {
          dyld4::PrebuiltObjC::generatePerImageFixups();
        }
        unsigned int v8 = v7 & 0x7FFF;
        if (v4 <= v8) {
          unsigned __int16 v4 = v8;
        }
      }

      v5 += 8LL;
      v6 -= 8LL;
    }

    while (v6);
  }

  else
  {
    unsigned __int16 v4 = 0;
  }

  unint64_t v9 = this + 58;
  if (this[59] < (unsigned __int16)(v4 + 1)) {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo( this + 58,  (unsigned __int16)(v4 + 1));
  }
  int v10 = 0;
  do
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back(this + 58);
    int v11 = (unsigned __int16)v10++;
  }

  while (v11 != v4);
  vm_address_t v12 = this[2];
  if (v12)
  {
    vm_address_t v13 = *this;
    uint64_t v14 = *this + 568 * v12;
    do
    {
      if (!Diagnostics::hasError((Diagnostics *)(v13 + 32)))
      {
        uint64_t v15 = dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[]( v9,  *(_WORD *)(*(void *)v13 + 6LL) & 0x7FFF);
        uint64_t v16 = (void *)v15;
        *(_OWORD *)uint64_t v15 = *(_OWORD *)(v13 + 488);
        __int128 v17 = *(_OWORD *)(v13 + 504);
        __int128 v18 = *(_OWORD *)(v13 + 520);
        __int128 v19 = *(_OWORD *)(v13 + 536);
        *(_OWORD *)(v15 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(v13 + 548);
        *(_OWORD *)(v15 + 32) = v18;
        *(_OWORD *)(v15 + 48) = v19;
        *(_OWORD *)(v15 + 16) = v17;
        unint64_t v20 = *(void *)(v13 + 136);
        if (v20)
        {
          dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((void *)(v15 + 80), v20);
          uint64_t v21 = *(void *)(v13 + 136);
          if (v21)
          {
            uint64_t v22 = *(char **)(v13 + 120);
            do
            {
              char v23 = *v22++;
              dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(v16 + 10, 1LL);
              uint64_t v24 = v16[10];
              uint64_t v25 = v16[12];
              v16[12] = v25 + 1;
              *(_BYTE *)(v24 + v25) = v23;
              --v21;
            }

            while (v21);
          }
        }

        unint64_t v26 = *(void *)(v13 + 368);
        if (v26)
        {
          dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v16 + 15, v26);
          uint64_t v27 = *(void *)(v13 + 368);
          if (v27)
          {
            uint64_t v28 = *(uint64_t **)(v13 + 352);
            uint64_t v29 = 8 * v27;
            do
            {
              dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v16 + 15, 1LL);
              uint64_t v30 = v16[15];
              uint64_t v31 = v16[17];
              v16[17] = v31 + 1;
              uint64_t v32 = *v28++;
              *(void *)(v30 + 8 * v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v32;
              v29 -= 8LL;
            }

            while (v29);
          }
        }
      }

      v13 += 568LL;
    }

    while (v13 != v14);
  }

double dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::default_constuct_back( vm_address_t *a1)
{
  vm_address_t v2 = a1[2];
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > a1[1])
  {
    dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, v3);
    vm_address_t v2 = a1[2];
    unint64_t v3 = v2 + 1;
  }

  vm_address_t v4 = *a1;
  a1[2] = v3;
  uint64_t v5 = (_OWORD *)(v4 + 160 * v2);
  double result = 0.0;
  _BYTE v5[8] = 0u;
  v5[9] = 0u;
  void v5[6] = 0u;
  void v5[7] = 0u;
  v5[4] = 0u;
  void v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  *uint64_t v5 = 0u;
  v5[1] = 0u;
  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[]( vm_address_t *a1, vm_address_t a2)
{
  vm_address_t v4 = a1[2];
  vm_address_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5 && a1[1] < v5) {
      dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo(a1, a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 160 * a2;
}

void *dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(void *result, unint64_t a2)
{
  unint64_t v2 = result[1];
  if (v2 < a2)
  {
    unint64_t v3 = (const void **)result;
    vm_address_t v4 = result[3];
    vm_size_t v5 = result[4];
    unint64_t v6 = 2 * v2;
    if (v6 <= a2) {
      unint64_t v6 = a2;
    }
    vm_size_t v7 = (v6 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v7;
    uint64_t v8 = vm_allocate(mach_task_self_, result + 3, v7, 1006632961);
    if ((_DWORD)v8) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v8, v9, v10);
    }
    double result = memmove((void *)v3[3], *v3, (size_t)v3[2]);
    int v11 = v3[4];
    *unint64_t v3 = v3[3];
    v3[1] = v11;
    if (v4) {
      return (void *)vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique( dyld4::RuntimeState *a1, dyld4::Loader *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(a2, a1);
  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v11, v10);
  if (Diagnostics::hasError((Diagnostics *)&v12)) {
    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique();
  }
  dyld4::forEachSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachClassSelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachCategorySelectorReferenceToUnique(v11, a3, a4, a5);
  dyld4::forEachProtocolSelectorReferenceToUnique(v11, a3, a4, a5);
  mach_o::Error::~Error(&v12);
}

void dyld4::forEachSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a3 + 40))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
    void v4[3] = &unk_189621028;
    v4[4] = a4;
    void v4[5] = a2;
    objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v4);
  }

void dyld4::forEachClassSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  void v6[3] = &unk_189621050;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_189621078;
  v5[4] = v6;
  void v5[5] = a1;
  if (*(_BYTE *)(a3 + 60))
  {
    if (*(_DWORD *)(a3 + 44))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000LL;
      v4[2] = ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_1896210A0;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachClassAndMetaClass(a1, (uint64_t)v4);
    }
  }

void dyld4::forEachCategorySelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  void v6[3] = &unk_1896210C8;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_1896210F0;
  v5[4] = v6;
  void v5[5] = a1;
  if (*(_BYTE *)(a3 + 61))
  {
    if (*(_DWORD *)(a3 + 48))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000LL;
      v4[2] = ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_189621118;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachCategory(a1, (uint64_t)v4);
    }
  }

void dyld4::forEachProtocolSelectorReferenceToUnique(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke;
  void v6[3] = &unk_189621140;
  void v6[5] = a1;
  v6[6] = a2;
  v6[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2;
  v5[3] = &unk_189621168;
  v5[4] = v6;
  void v5[5] = a1;
  if (*(_BYTE *)(a3 + 62))
  {
    if (*(_DWORD *)(a3 + 52))
    {
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000LL;
      v4[2] = ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3;
      void v4[3] = &unk_189621190;
      v4[4] = v5;
      void v4[5] = a1;
      objc_visitor::Visitor::forEachProtocol(a1, (uint64_t)v4);
    }
  }

void dyld4::PrebuiltObjC::make(dyld4::PrebuiltObjC *this, Diagnostics *a2, dyld4::RuntimeState *a3)
{
  uint64_t v3 = *((void *)a3 + 1);
  uint64_t v4 = *(void *)(v3 + 304);
  vm_size_t v5 = *(Diagnostics **)(v3 + 320);
  uint64_t v71 = *(void *)(v3 + 312);
  if (v71) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && v5 != 0LL)
  {
    uint64_t v8 = a3;
    uint64_t v74 = *(void *)(v3 + 296);
    uint64_t v75 = *(int **)(v3 + 288);
    uint64_t v72 = *(void *)(v3 + 352);
    uint64_t v10 = DyldSharedCache::objcOptPtrs(*(DyldSharedCache **)(v3 + 240));
    if (v10)
    {
      int v11 = (unsigned int *)v10;
      vm_address_t v12 = (dyld3::MachOFile *)dyld4::Loader::loadAddress(*((dyld4::Loader **)v8 + 3), v8);
      else {
        uint64_t v13 = *v11;
      }
      *((void *)this + 56) = v13 - *(void *)(*((void *)v8 + 1) + 240LL);
      *((_BYTE *)this + 456) = 1;
    }

    uint64_t v14 = *((void *)v8 + 10);
    if (v14)
    {
      uint64_t v15 = *((void *)v8 + 9);
      uint64_t v16 = 8 * v14;
      while (!*(void *)v15 || (*(_WORD *)(*(void *)v15 + 4LL) & 1) != 0)
      {
        v15 += 8LL;
        v16 -= 8LL;
        if (!v16) {
          goto LABEL_20;
        }
      }
    }

    else
    {
LABEL_20:
      uint64_t v68 = v4;
      uint64_t v69 = v5;
      uint64_t v73 = this;
      dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map((uint64_t)v83);
      uint64_t v18 = *((void *)v8 + 6);
      if (v18)
      {
        uint64_t v19 = 8 * v18;
        unint64_t v20 = (dyld4::Loader **)*((void *)v8 + 5);
        uint64_t v70 = v8;
        do
        {
          uint64_t v21 = *v20;
          uint64_t v22 = (dyld3::MachOFile *)dyld4::Loader::mf(*v20, v8);
          int v23 = dyld3::MachOFile::pointerSize(v22);
          unint64_t v90 = 0LL;
          uint64_t v91 = (uint64_t)&v90;
          uint64_t v92 = 0x4002000000LL;
          uint64_t v93 = __Block_byref_object_copy__8;
          uint64_t v94 = (void ***)__Block_byref_object_dispose__8;
          LOBYTE(v95[0]) = 0;
          LOBYTE(v96) = 0;
          char v101 = _NSConcreteStackBlock;
          uint64_t v102 = 0x40000000LL;
          uint64_t v103 = (uint64_t)___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke;
          uint64_t v104 = (__n128 (*)(uint64_t, uint64_t))&unk_1896211E0;
          uint64_t v107 = a2;
          uint64_t v108 = v8;
          uint64_t v105 = &v90;
          uint64_t v106 = v21;
          dyld3::MachOFile::forEachSection(v22, (uint64_t)&v101);
          uint64_t v24 = *(void *)(v91 + 40);
          int v25 = *(unsigned __int8 *)(v91 + 48);
          int v26 = *(unsigned __int8 *)(v91 + 56);
          _Block_object_dispose(&v90, 8);
          if (v26)
          {
            if ((*((_WORD *)v21 + 2) & 2) != 0)
            {
              unint64_t v38 = dyld3::MachOFile::preferredLoadAddress(v22);
              BOOL v39 = dyld3::MachOFile::is64(v22);
              if (!v75) {
                dyld4::PrebuiltObjC::make();
              }
              if (!v74) {
                dyld4::PrebuiltObjC::make();
              }
              if (v39)
              {
                uint64_t v40 = objc::objc_headeropt_ro_t<unsigned long long>::get(v75, v72, v38);
                if (!v40) {
                  goto LABEL_72;
                }
                __int16 v42 = objc::objc_headeropt_ro_t<unsigned long long>::index(v75, (unint64_t)v40, v41);
                if (*(_DWORD *)(v74 + 4) != 8) {
                  dyld4::PrebuiltObjC::make();
                }
                unsigned __int8 v43 = v42;
              }

              else
              {
                unint64_t v44 = objc::objc_headeropt_ro_t<unsigned int>::get(v75, v72, v38);
                if (!v44) {
                  goto LABEL_72;
                }
                __int16 v42 = objc::objc_headeropt_ro_t<unsigned long long>::index(v75, (unint64_t)v44, v45);
                if (*(_DWORD *)(v74 + 4) != 4) {
                  dyld4::PrebuiltObjC::make();
                }
                unsigned __int8 v43 = v42;
              }

              LOWORD(v9dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v42 & 0xFF00 | v43;
              uint64_t v91 = v38;
              LOBYTE(v92) = 1;
              uint64_t v93 = (__n128 (*)(uint64_t, uint64_t))v21;
              dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert( (uint64_t)v83,  (unsigned __int16 *)&v90);
            }

            else
            {
              if (dyld4::Loader::matchesPath(v21, v8, "/usr/lib/libobjc.A.dylib")) {
                goto LABEL_72;
              }
              uint64_t v27 = dyld3::MachOFile::preferredLoadAddress(v22);
              dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace( (vm_address_t *)v73,  1LL);
              vm_address_t v28 = *(void *)v73;
              uint64_t v29 = *((void *)v73 + 2);
              *((void *)v73 + 2) = v29 + 1;
              uint64_t v30 = dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage( (dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v28 + 568 * v29),  v21,  v27,  v23);
              uint64_t v33 = *((void *)v73 + 2);
              if (!v33) {
                dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v30,  v31,  v32);
              }
              vm_address_t v34 = *(void *)v73;
              uint64_t v35 = v33 - 1;
              uint64_t v36 = (dyld4::Loader **)(*(void *)v73 + 568 * (v33 - 1));
              *uint64_t v36 = v21;
              if (!v25) {
LABEL_82:
              }
                std::__throw_bad_optional_access[abi:nn180100]();
              vm_address_t v37 = v34 + 568 * v35;
              *(void *)(v37 + 488) = v24;
              v77[0] = _NSConcreteStackBlock;
              v77[1] = 0x40000000LL;
              uint64_t v78 = ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke;
              unint64_t v79 = &__block_descriptor_tmp_27_0;
              int v82 = v23;
              int v80 = v22;
              uint64_t v81 = v36;
              ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke( (uint64_t)v77,  "__objc_selrefs",  (unint64_t *)(v37 + 496),  (unsigned int *)(v37 + 528));
              v78((uint64_t)v77, "__objc_classlist", (unint64_t *)(v37 + 504), (unsigned int *)(v37 + 532));
              v78((uint64_t)v77, "__objc_catlist", (unint64_t *)(v37 + 512), (unsigned int *)(v37 + 536));
              v78((uint64_t)v77, "__objc_protolist", (unint64_t *)(v37 + 520), (unsigned int *)(v37 + 540));
              uint64_t v8 = v70;
            }
          }

          ++v20;
          v19 -= 8LL;
        }

        while (v19);
      }

      uint64_t v46 = *((void *)v73 + 2);
      if (v46)
      {
        uint64_t v47 = 0LL;
        vm_address_t v48 = *(void *)v73;
        uint64_t v49 = 568 * v46;
        do
        {
          vm_address_t v50 = v48 + v47;
          if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
          {
            if (*(_DWORD *)(v50 + 532))
            {
              char v101 = 0LL;
              uint64_t v102 = (uint64_t)&v101;
              uint64_t v103 = 0x4802000000LL;
              uint64_t v104 = __Block_byref_object_copy__69;
              uint64_t v105 = (void ***)__Block_byref_object_dispose__70;
              uint64_t v51 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v50, v8);
              metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)&v106, v51);
              if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
              {
                uint64_t v52 = *(void *)(*((void *)v8 + 1) + 272LL);
                unint64_t v90 = _NSConcreteStackBlock;
                uint64_t v91 = 0x40000000LL;
                uint64_t v92 = (uint64_t)___ZN5dyld4L19optimizeObjCClassesERNS_12RuntimeStateEPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS7_IPKcNSB_10BindTargetENS6_11HashCStringENS6_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                uint64_t v93 = (__n128 (*)(uint64_t, uint64_t))&unk_189621208;
                uint64_t v94 = &v101;
                v95[0] = v48 + v47;
                v95[1] = v8;
                uint64_t v96 = v52;
                char v97 = 1;
                uint64_t v98 = v71;
                BOOL v99 = v83;
                BOOL v100 = (char *)v73 + 344;
                objc_visitor::Visitor::forEachClass((unsigned int *)(v102 + 40), (uint64_t)&v90);
              }

              _Block_object_dispose(&v101, 8);
            }

            if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
            {
              vm_address_t v53 = v48 + v47;
              unint64_t v54 = *(unsigned int *)(v48 + v47 + 540);
              if ((_DWORD)v54)
              {
                dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve((void *)(v53 + 120), v54);
                unint64_t v90 = 0LL;
                uint64_t v91 = (uint64_t)&v90;
                uint64_t v92 = 0x4802000000LL;
                uint64_t v93 = __Block_byref_object_copy__69;
                uint64_t v94 = (void ***)__Block_byref_object_dispose__70;
                unint64_t v55 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v53, v8);
                metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v95, v55);
                if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
                {
                  char v101 = _NSConcreteStackBlock;
                  uint64_t v102 = 0x40000000LL;
                  uint64_t v103 = (uint64_t)___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                  uint64_t v104 = (__n128 (*)(uint64_t, uint64_t))&unk_189621230;
                  uint64_t v105 = &v90;
                  uint64_t v106 = (dyld4::Loader *)(v48 + v47);
                  uint64_t v107 = v69;
                  uint64_t v108 = (dyld4::RuntimeState *)v83;
                  objc_visitor::Visitor::forEachProtocol((unsigned int *)(v91 + 40), (uint64_t)&v101);
                }

                _Block_object_dispose(&v90, 8);
              }

              if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
              {
                unint64_t v56 = (dyld3::MachOFile *)dyld4::JustInTimeLoader::mf(*(dyld4::JustInTimeLoader **)v50, v8);
                int v57 = dyld3::MachOFile::pointerSize(v56);
                uint64_t v133 = 0LL;
                uint64_t v134 = &v133;
                uint64_t v135 = 0x2000000000LL;
                char v136 = 0;
                v132[0] = _NSConcreteStackBlock;
                v132[1] = 0x40000000LL;
                v132[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke;
                v132[3] = &unk_189621258;
                v132[4] = &v133;
                dyld3::MachOFile::forEachSection(v56, (uint64_t)v132);
                if (*((_BYTE *)v134 + 24))
                {
                  Diagnostics::error((vm_address_t *)(v48 + v47 + 32), "Old objc section");
                }

                else if ((dyld3::MachOFile::isArch(v56, "x86_64") || dyld3::MachOFile::isArch(v56, "x86_64h")) {
                       && dyld3::MachOFile::hasObjCMessageReferences(v56))
                }
                {
                  Diagnostics::error((vm_address_t *)(v48 + v47 + 32), "Cannot handle message refs");
                }

                else
                {
                  unint64_t v90 = 0LL;
                  uint64_t v91 = (uint64_t)&v90;
                  uint64_t v92 = 0x4802000000LL;
                  uint64_t v93 = __Block_byref_object_copy__69;
                  uint64_t v94 = (void ***)__Block_byref_object_dispose__70;
                  uint64_t v58 = (const dyld3::MachOAnalyzer *)dyld4::Loader::analyzer(*(dyld4::Loader **)v50, v8);
                  metadata_visitor::Visitor::Visitor((metadata_visitor::Visitor *)v95, v58);
                  if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32)))
                  {
                    vm_address_t v59 = v48 + v47;
                    unsigned int v60 = *(Diagnostics **)(v48 + v47 + 496);
                    int v61 = (Diagnostics *)((char *)v60 + (*(_DWORD *)(v48 + v47 + 528) * v57));
                    char v101 = _NSConcreteStackBlock;
                    uint64_t v102 = 0x40000000LL;
                    uint64_t v103 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2;
                    uint64_t v104 = (__n128 (*)(uint64_t, uint64_t))&unk_189621280;
                    uint64_t v105 = &v90;
                    uint64_t v106 = (dyld4::Loader *)(v48 + v47);
                    uint64_t v107 = v60;
                    uint64_t v108 = v61;
                    v131[0] = _NSConcreteStackBlock;
                    v131[1] = 0x40000000LL;
                    v131[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3;
                    v131[3] = &unk_1896212A8;
                    v131[4] = &v101;
                    v131[5] = &v90;
                    if (*(_DWORD *)(v50 + 532))
                    {
                      char v123 = 0LL;
                      uint64_t v124 = (uint64_t)&v123;
                      uint64_t v125 = 0x2000000000LL;
                      LOBYTE(v126) = 0;
                      v130[0] = _NSConcreteStackBlock;
                      v130[1] = 0x40000000LL;
                      v130[2] = ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4;
                      v130[3] = &unk_1896212D0;
                      v130[5] = &v90;
                      v130[4] = v131;
                      v130[6] = &v123;
                      objc_visitor::Visitor::forEachClassAndMetaClass((unsigned int *)(v91 + 40), (uint64_t)v130);
                      uint64_t v62 = v124;
                      *(_BYTE *)(v59 + 548) = *(_BYTE *)(v124 + 24);
                      *(_BYTE *)(v59 + 545) = *(_BYTE *)(v62 + 24);
                      _Block_object_dispose(&v123, 8);
                    }

                    if (*(_DWORD *)(v59 + 536))
                    {
                      uint64_t v116 = 0LL;
                      uint64_t v117 = (uint64_t)&v116;
                      uint64_t v118 = 0x2000000000LL;
                      LOBYTE(v119) = 0;
                      char v123 = _NSConcreteStackBlock;
                      uint64_t v124 = 0x40000000LL;
                      uint64_t v125 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5;
                      uint64_t v126 = &unk_1896212F8;
                      uint64_t v128 = &v90;
                      uint64_t v127 = v131;
                      uint64_t v129 = &v116;
                      objc_visitor::Visitor::forEachCategory((unsigned int *)(v91 + 40), (uint64_t)&v123);
                      uint64_t v63 = v117;
                      vm_address_t v64 = v48 + v47;
                      *(_BYTE *)(v64 + 549) = *(_BYTE *)(v117 + 24);
                      *(_BYTE *)(v64 + 546) = *(_BYTE *)(v63 + 24);
                      _Block_object_dispose(&v116, 8);
                    }

                    if (*(_DWORD *)(v53 + 540))
                    {
                      uint64_t v109 = 0LL;
                      uint64_t v110 = (uint64_t)&v109;
                      uint64_t v111 = 0x2000000000LL;
                      LOBYTE(v112) = 0;
                      uint64_t v116 = _NSConcreteStackBlock;
                      uint64_t v117 = 0x40000000LL;
                      uint64_t v118 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6;
                      uint64_t v119 = &unk_189621320;
                      unsigned __int16 v120 = v131;
                      unint64_t v121 = &v90;
                      uint64_t v122 = &v109;
                      objc_visitor::Visitor::forEachProtocol((unsigned int *)(v91 + 40), (uint64_t)&v116);
                      uint64_t v65 = v110;
                      vm_address_t v66 = v48 + v47;
                      *(_BYTE *)(v66 + 55dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v110 + 24);
                      *(_BYTE *)(v66 + 547) = *(_BYTE *)(v65 + 24);
                      _Block_object_dispose(&v109, 8);
                    }

                    uint64_t v109 = _NSConcreteStackBlock;
                    uint64_t v110 = 0x40000000LL;
                    uint64_t v111 = (uint64_t)___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_7;
                    __int128 v112 = &__block_descriptor_tmp_92_0;
                    vm_address_t v113 = v48 + v47;
                    uint64_t v114 = v68;
                    __int128 v115 = (char *)v73 + 40;
                    if (!*(_BYTE *)(v48 + v47 + 24)) {
                      goto LABEL_82;
                    }
                    dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique( v8,  *(dyld4::Loader **)(v48 + v47),  *(void *)(v48 + v47 + 16),  v59 + 488,  (uint64_t)&v109);
                  }

                  _Block_object_dispose(&v90, 8);
                }

                _Block_object_dispose(&v133, 8);
                if (!Diagnostics::hasError((Diagnostics *)(v48 + v47 + 32))) {
                  dyld4::PrebuiltObjC::commitImage(v73, (const dyld4::PrebuiltObjC::ObjCOptimizerImage *)(v48 + v47));
                }
              }
            }
          }

          v47 += 568LL;
        }

        while (v49 != v47);
      }

      dyld4::PrebuiltObjC::generateHashTables(v73);
      uint64_t v67 = (dyld3::MachOFile *)dyld4::Loader::mf(*((dyld4::Loader **)v8 + 3), v8);
      dyld3::MachOFile::pointerSize(v67);
      dyld4::PrebuiltObjC::generatePerImageFixups((vm_address_t *)v73, v8);
      *((_BYTE *)v73 + 44dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 1;
LABEL_72:
      uint64_t v87 = 0LL;
      if (address) {
        vm_deallocate(mach_task_self_, address, size);
      }
      uint64_t v84 = 0LL;
      if (v85) {
        vm_deallocate(mach_task_self_, v85, v86);
      }
    }
  }

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::insert( uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v25, 0, sizeof(v25));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v25, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v25, 1LL);
      uint64_t v6 = (*(void *)&v25[1])++;
      *(_DWORD *)(*(void *)&v25[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = (unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        unint64_t v9 = (LODWORD(v25[1]) - 1) & *v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) != -1)
        {
          uint64_t v10 = 1LL;
          do
            unint64_t v9 = (*(void *)&v25[1] - 1LL) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v25, v9) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v25)
    {
      *(void *)&v25[1] = 0LL;
      if (*((void *)&v25[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v25[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v11 = *(void *)(a1 + 40);
      if (v11) {
        vm_deallocate(mach_task_self_, v11, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v25[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v25 + 8);
      vm_size_t v12 = size;
      *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)&v25[1] + 1);
      *(void *)(a1 + 48) = v12;
    }
  }

  unint64_t v13 = (*(_DWORD *)(a1 + 32) - 1) & (unint64_t)*a2;
  unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
  if ((_DWORD)v14 == -1)
  {
LABEL_20:
    uint64_t v16 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13) = v16;
    ++*(void *)(a1 + 8);
    uint64_t v17 = dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace( a1 + 56,  1LL);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v21 + 1;
    uint64_t v22 = v20 + 32 * v21;
    *(_WORD *)uint64_t v22 = *a2;
    *(_OWORD *)(v22 + 8) = *(_OWORD *)(a2 + 4);
    *(void *)(v22 + 24) = *((void *)a2 + 3);
    uint64_t v23 = *(void *)(a1 + 72);
    if (!v23) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( v17,  v18,  v19);
    }
    return *(void *)(a1 + 56) + 32 * v23 - 32;
  }

  else
  {
    uint64_t v15 = 1LL;
    while (*(unsigned __int16 *)dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14) != *a2)
    {
      unint64_t v13 = (*(void *)(a1 + 32) - 1LL) & (v13 + v15++);
      unint64_t v14 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v13);
      if ((_DWORD)v14 == -1) {
        goto LABEL_20;
      }
    }

    return dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v14);
  }

uint64_t ___ZN5dyld412PrebuiltObjC4makeER11DiagnosticsRNS_12RuntimeStateE_block_invoke( uint64_t a1, const char *a2, unint64_t *a3, unsigned int *a4)
{
  uint64_t result = dyld3::MachOFile::findObjCDataSection(*(dyld3::MachOFile **)(a1 + 32), a2, &v12, &v11);
  if ((_DWORD)result)
  {
    unsigned int v8 = v11;
    unint64_t v9 = *(unsigned int *)(a1 + 48);
    if (v11 % v9) {
      return Diagnostics::error((vm_address_t *)(*(void *)(a1 + 40) + 32LL), "Invalid objc pointer section size");
    }
    *a3 = v12;
    unsigned int v10 = v8 / v9;
  }

  else
  {
    unsigned int v10 = 0;
    *a3 = 0LL;
  }

  *a4 = v10;
  return result;
}

uint64_t dyld4::PrebuiltObjC::serializeFixups( dyld4::PrebuiltObjC *this, const dyld4::Loader *a2, dyld4::BumpAllocator *a3)
{
  if (!*((_BYTE *)this + 441)) {
    return 0LL;
  }
  uint64_t v4 = (void *)dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::operator[]( (vm_address_t *)this + 58,  *((_WORD *)a2 + 3) & 0x7FFF);
  if (!*v4) {
    return 0LL;
  }
  unint64_t v5 = v4;
  uint64_t v6 = *((void *)a3 + 2);
  uint64_t v7 = v6 - *(void *)a3;
  uint64_t v8 = (v6 - *(_DWORD *)a3);
  dyld4::BumpAllocator::append(a3, v4, 0x50uLL);
  unint64_t v9 = v5[12];
  if (v9)
  {
    if (v9 != *((_DWORD *)v5 + 13)) {
      dyld4::PrebuiltObjC::serializeFixups();
    }
    int v10 = *((_DWORD *)a3 + 4) - *(void *)a3 - v7;
    *(_DWORD *)(*(void *)a3 + v8 + 64) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(void *)a3 - v7);
    dyld4::BumpAllocator::zeroFill(a3, v9);
    dyld4::BumpAllocator::align(a3, 8u);
    memmove((void *)(*(void *)a3 + v7 + (unsigned __int16)v10), (const void *)v5[10], v5[12]);
  }

  uint64_t v11 = v5[17];
  if (v11)
  {
    int v12 = *((_DWORD *)a3 + 4) - *(void *)a3 - v7;
    uint64_t v13 = *(void *)a3 + v8;
    *(_DWORD *)(v13 + 68) = (unsigned __int16)(*((_WORD *)a3 + 8) - *(void *)a3 - v7);
    *(_DWORD *)(v13 + 72) = v11;
    dyld4::BumpAllocator::zeroFill(a3, 8 * v11);
    memmove((void *)(*(void *)a3 + v7 + (unsigned __int16)v12), (const void *)v5[15], 8LL * v5[17]);
  }

  return v7;
}

uint64_t ___ZN5dyld4L22checkForDuplicateClassE9VMAddressPKcPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairIS0_PKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS8_IS2_NSB_10BindTargetENS7_11HashCStringENS7_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke( uint64_t a1, uint64_t a2, unsigned __int16 a3, _BYTE *a4)
{
  unsigned __int16 v14 = a3;
  uint64_t result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>( *(void *)(a1 + 32),  (void *)(*(void *)(a1 + 32) + 16LL),  (void *)(*(void *)(a1 + 32) + 56LL),  0LL,  &v14);
  if (result != *(void *)(*(void *)(a1 + 32) + 56LL) + 32LL * *(void *)(*(void *)(a1 + 32) + 72LL))
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(result + 24);
    uint64_t result = (uint64_t)dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( *(void *)(a1 + 40),  (uint64_t *)(*(void *)(a1 + 40) + 16LL),  (void *)(*(void *)(a1 + 40) + 56LL),  0LL,  (const char **)(a1 + 48));
    if (result == *(void *)(*(void *)(a1 + 40) + 56LL) + 24LL * *(void *)(*(void *)(a1 + 40) + 72LL))
    {
      if (!*(_BYTE *)(a1 + 64) || !*(_BYTE *)(v8 + 16)) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      uint64_t v10 = a2 - *(void *)(v8 + 8) + *(void *)(a1 + 56);
      uint64_t v11 = *(void *)(a1 + 72) + 160LL;
      *(void *)&__int128 v12 = *(void *)(a1 + 48);
      *((void *)&v12 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v9;
      uint64_t v13 = v10;
      uint64_t result = dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert( v11,  &v12);
    }

    *a4 = 1;
  }

  return result;
}

uint64_t dyld3::Map<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::insert( uint64_t a1, __int128 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v31, 0, sizeof(v31));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v31, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v31, 1LL);
      uint64_t v6 = (*(void *)&v31[1])++;
      *(_DWORD *)(*(void *)&v31[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = *(char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        size_t v9 = _platform_strlen(v8);
        unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v33, (uint64_t *)v8, v9);
        unint64_t v11 = (*(void *)&v31[1] - 1LL) & v10;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v11) != -1)
        {
          uint64_t v12 = 1LL;
          do
            unint64_t v11 = (*(void *)&v31[1] - 1LL) & (v11 + v12++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v11) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v31, v1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v7++;
      }

      while (v7 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v31)
    {
      *(void *)&v31[1] = 0LL;
      if (*((void *)&v31[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v31[1] + 1), size);
      }
    }

    else
    {
      vm_address_t v13 = *(void *)(a1 + 40);
      if (v13) {
        vm_deallocate(mach_task_self_, v13, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v31[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v31 + 8);
      vm_size_t v14 = size;
      *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)&v31[1] + 1);
      *(void *)(a1 + 48) = v14;
    }
  }

  uint64_t v15 = *(char **)a2;
  size_t v16 = _platform_strlen(*(const char **)a2);
  unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( (uint64_t)v31,  (uint64_t *)v15,  v16);
  unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
  if ((_DWORD)v18 == -1)
  {
LABEL_20:
    uint64_t v21 = *(void *)(a1 + 72);
    *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17) = v21;
    ++*(void *)(a1 + 8);
    uint64_t v22 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v26 + 1;
    uint64_t v27 = v25 + 24 * v26;
    __int128 v28 = *a2;
    *(void *)(v27 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v27 = v28;
    uint64_t v29 = *(void *)(a1 + 72);
    if (!v29) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v22,  v23,  v24);
    }
    return *(void *)(a1 + 56) + 24 * v29 - 24;
  }

  else
  {
    uint64_t v19 = 1LL;
    while (1)
    {
      uint64_t v20 = (const char **)dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      if (!_platform_strcmp(*v20, *(const char **)a2)) {
        return dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v18);
      }
      unint64_t v17 = (*(void *)(a1 + 32) - 1LL) & (v17 + v19++);
      unint64_t v18 = *(unsigned int *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[]((void *)(a1 + 16), v17);
      if ((_DWORD)v18 == -1) {
        goto LABEL_20;
      }
    }
  }

uint64_t dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>( uint64_t a1, void *a2, void *a3, uint64_t a4, unsigned __int16 *a5)
{
  unint64_t v5 = a3[2];
  if (!v5) {
    return *a3;
  }
  uint64_t v6 = *a5;
  unint64_t v7 = a2[2];
  unint64_t v8 = (v7 - 1) & v6;
  if (v7 <= v8) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( a1,  (uint64_t)a2,  (uint64_t)a3);
  uint64_t v9 = *a3;
  uint64_t v10 = 1LL;
  while (1)
  {
    unint64_t v11 = *(unsigned int *)(*a2 + 4 * v8);
    if ((_DWORD)v11 == -1) {
      return v9 + 32 * v5;
    }
    if (v5 <= v11) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( a1,  (uint64_t)a2,  (uint64_t)a3);
    }
    unint64_t v8 = (v8 + v10++) & (v7 - 1);
    if (v7 <= v8) {
      goto LABEL_8;
    }
  }

const char **dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::find<char const*>( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return (const char **)*a3;
  }
  unint64_t v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  uint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  unint64_t v13 = a2[2];
  unint64_t v14 = v13 - 1;
  unint64_t v15 = v10 & (v13 - 1);
  if (v13 <= v15) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v10,  v11,  v12);
  uint64_t v16 = *a2;
  unint64_t v17 = a3[2];
  uint64_t v18 = *a3;
  uint64_t v19 = 1LL;
  uint64_t v20 = *a5;
  while (1)
  {
    unint64_t v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1) {
      return (const char **)(v18 + 24 * v17);
    }
    if (v17 <= v21) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v10, v11, v12);
    }
    uint64_t v22 = (const char **)(v18 + 24LL * v21);
    uint64_t v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10) {
      return v22;
    }
    unint64_t v23 = v15 + v19++;
    unint64_t v15 = v23 & v14;
    if (v13 <= (v23 & v14)) {
      goto LABEL_8;
    }
  }

uint64_t ___ZN5dyld4L23protocolIsInSharedCacheEPKcPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEE_block_invoke( uint64_t a1, uint64_t a2, unsigned __int16 a3, _BYTE *a4)
{
  unsigned __int16 v7 = a3;
  uint64_t result = dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::find<unsigned short>( *(void *)(a1 + 40),  (void *)(*(void *)(a1 + 40) + 16LL),  (void *)(*(void *)(a1 + 40) + 56LL),  0LL,  &v7);
  if (result != *(void *)(*(void *)(a1 + 40) + 56LL) + 32LL * *(void *)(*(void *)(a1 + 40) + 72LL))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    *a4 = 1;
  }

  return result;
}

uint64_t dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert( uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6 == *(void *)a1)
  {
    unint64_t v7 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v6;
    size[0] = 0LL;
    memset(v46, 0, sizeof(v46));
    dyld3::OverflowSafeArray<void const*,4294967295ull>::reserve(v46, v7);
    for (; v7; --v7)
    {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v46, 1LL);
      uint64_t v8 = (*(void *)&v46[1])++;
      *(void *)(*(void *)&v46[0] + 8 * v8) = -1LL;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v9 = 0LL;
      do
      {
        if ((*(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v9)
                       + 48) & 6) == 0)
        {
          uint64_t v10 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v9);
          unint64_t v11 = murmurHash(*(uint64_t **)v10, *(_DWORD *)(v10 + 8), 0LL);
          unint64_t v12 = (*(void *)&v46[1] - 1LL) & v11;
          if (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) != -1LL)
          {
            uint64_t v13 = 1LL;
            do
              unint64_t v12 = (*(void *)&v46[1] - 1LL) & (v12 + v13++);
            while (*(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) != -1LL);
          }

          *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[](v46, v12) = v9;
        }

        ++v9;
      }

      while (v9 != *(void *)(a1 + 72));
    }

    if ((_OWORD *)(a1 + 16) == v46)
    {
      *(void *)&v46[1] = 0LL;
      if (*((void *)&v46[1] + 1)) {
        vm_deallocate(mach_task_self_, *((vm_address_t *)&v46[1] + 1), size[0]);
      }
    }

    else
    {
      vm_address_t v14 = *(void *)(a1 + 40);
      if (v14) {
        vm_deallocate(mach_task_self_, v14, *(void *)(a1 + 48));
      }
      *(void *)(a1 + 16) = *(void *)&v46[0];
      *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)v46 + 8);
      vm_size_t v15 = size[0];
      *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)&v46[1] + 1);
      *(void *)(a1 + 48) = v15;
    }
  }

  unint64_t v16 = (*(void *)(a1 + 32) - 1LL) & murmurHash(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), 0LL);
  unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
  if (v17 == -1LL)
  {
LABEL_23:
    uint64_t v18 = (void *)(a1 + 56);
    uint64_t v22 = *(void *)(a1 + 72);
    *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16) = v22;
    ++*(void *)(a1 + 8);
    __int128 v23 = *(_OWORD *)(a2 + 16);
    v46[0] = *(_OWORD *)a2;
    v46[1] = v23;
    *(_OWORD *)vm_size_t size = *(_OWORD *)(a2 + 32);
    uint64_t v24 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v27 = *(void *)(a1 + 56);
    uint64_t v28 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v28 + 1;
    uint64_t v29 = v27 + 56 * v28;
    *(_OWORD *)uint64_t v29 = v46[0];
    *(_OWORD *)(v29 + 16) = v46[1];
    *(_OWORD *)(v29 + 32) = *(_OWORD *)size;
    *(void *)(v29 + 48) = 0LL;
    *a3 = 0;
    uint64_t v30 = *(void *)(a1 + 72);
    if (!v30) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v24,  v25,  v26);
    }
  }

  else
  {
    uint64_t v18 = (void *)(a1 + 56);
    uint64_t v19 = 1LL;
    while (1)
    {
      uint64_t v20 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v17);
      size_t v21 = *(void *)(v20 + 8);
      unint64_t v16 = (*(void *)(a1 + 32) - 1LL) & (v16 + v19++);
      unint64_t v17 = *(void *)dyld3::OverflowSafeArray<void const*,4294967295ull>::operator[]((void *)(a1 + 16), v16);
      if (v17 == -1LL) {
        goto LABEL_23;
      }
    }

    while (1)
    {
      char v31 = *(_BYTE *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( (void *)(a1 + 56),  v17)
                     + 48);
      uint64_t v32 = (void *)(a1 + 56);
      if ((v31 & 3) == 0) {
        break;
      }
      unint64_t v17 = *(void *)(dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( v32,  v17)
                      + 48) >> 3;
    }

    uint64_t v33 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( v32,  v17);
    uint64_t v34 = *(void *)(v33 + 48);
    if ((v34 & 7) != 0)
    {
      if ((v34 & 4) == 0) {
        dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert();
      }
      unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFF9LL | 2;
      *(void *)(v33 + 48) = v35;
      uint64_t v36 = v35 & 3 | (8LL * *(void *)(a1 + 72));
    }

    else
    {
      uint64_t v37 = v34 | 1;
      *(void *)(v33 + 48) = v37;
      uint64_t v36 = v37 & 7 | (8LL * *(void *)(a1 + 72));
    }

    *(void *)(v33 + 48) = v36;
    __int128 v38 = *(_OWORD *)(a2 + 16);
    v46[0] = *(_OWORD *)a2;
    v46[1] = v38;
    *(_OWORD *)vm_size_t size = *(_OWORD *)(a2 + 32);
    BOOL v39 = dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace( (void *)(a1 + 56),  1LL);
    uint64_t v42 = *(void *)(a1 + 56);
    uint64_t v43 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v43 + 1;
    uint64_t v44 = v42 + 56 * v43;
    *(_OWORD *)uint64_t v44 = v46[0];
    *(_OWORD *)(v44 + 16) = v46[1];
    *(_OWORD *)(v44 + 32) = *(_OWORD *)size;
    *(void *)(v44 + 48) = 4LL;
    *a3 = 1;
    uint64_t v30 = *(void *)(a1 + 72);
    if (!v30) {
      dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( (uint64_t)v39,  v40,  v41);
    }
  }

  return *v18 + 56 * v30 - 56;
}

unint64_t dyld3::OverflowSafeArray<BOOL,4294967295ull>::operator[](void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<unsigned char,4294967295ull>::reserve(a1, a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::reserve( a1,  a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 56 * a2;
}

void *dyld3::OverflowSafeArray<dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::NodeEntryT,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 56 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    uint64_t result = memmove((void *)v4[3], *v4, 56LL * (void)v4[2]);
    unint64_t v12 = (unint64_t)v4[4] / 0x38;
    void *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

const char **dyld3::MapBase<char const*,dyld4::Loader::BindTarget,dyld3::HashCString,dyld3::EqualCString>::const_find<char const*>( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, const char **a5)
{
  if (!a3[2]) {
    return (const char **)*a3;
  }
  vm_size_t v8 = (char *)*a5;
  size_t v9 = _platform_strlen(*a5);
  uint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v25, (uint64_t *)v8, v9);
  unint64_t v13 = a2[2];
  unint64_t v14 = v13 - 1;
  unint64_t v15 = v10 & (v13 - 1);
  if (v13 <= v15) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v10,  v11,  v12);
  uint64_t v16 = *a2;
  unint64_t v17 = a3[2];
  uint64_t v18 = *a3;
  uint64_t v19 = 1LL;
  uint64_t v20 = *a5;
  while (1)
  {
    unint64_t v21 = *(unsigned int *)(v16 + 4 * v15);
    if ((_DWORD)v21 == -1) {
      return (const char **)(v18 + 24 * v17);
    }
    if (v17 <= v21) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v10,  v11,  v12);
    }
    uint64_t v22 = (const char **)(v18 + 24LL * v21);
    uint64_t v10 = _platform_strcmp(*v22, v20);
    if (!(_DWORD)v10) {
      return v22;
    }
    unint64_t v23 = v15 + v19++;
    unint64_t v15 = v23 & v14;
    if (v13 <= (v23 & v14)) {
      goto LABEL_8;
    }
  }

uint64_t dyld3::MapBase<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::find<VMOffset>( BOOL a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a3[2]) {
    return *a3;
  }
  if (!*(_BYTE *)(a5 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v8 = a2[2];
  unint64_t v9 = (v8 - 1) & *(void *)a5;
  if (v8 <= v9) {
LABEL_9:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( a1,  (uint64_t)a2,  (uint64_t)a3);
  uint64_t v10 = 1LL;
  while (1)
  {
    unint64_t v11 = *(unsigned int *)(*a2 + 4 * v9);
    unint64_t v12 = a3[2];
    if ((_DWORD)v11 == -1) {
      return *a3 + 24 * v12;
    }
    if (v12 <= v11) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( a1,  (uint64_t)a2,  (uint64_t)a3);
    }
    a1 = dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(*a3 + 24LL * v11, a5);
    if (a1) {
      break;
    }
    unint64_t v13 = a2[2];
    unint64_t v9 = (v13 - 1) & (v9 + v10++);
    if (v13 <= v9) {
      goto LABEL_9;
    }
  }

  if (a3[2] <= v11) {
    ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( a1,  (uint64_t)a2,  (uint64_t)a3);
  }
  return *a3 + 24LL * v11;
}

BOOL dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual::equal(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 8) || !*(_BYTE *)(a2 + 8)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return *(void *)a1 == *(void *)a2;
}

uint64_t ___ZN5dyld4L32forEachSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke( uint64_t a1, uint64_t a2, char a3, uint64_t a4, char a5)
{
  if (!a3 || !a5) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke( uint64_t a1, int *a2)
{
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2( uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16LL))(Method);
        }
      }
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L37forEachClassSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke( uint64_t a1, int *a2)
{
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2( uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16LL))(Method);
        }
      }
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L40forEachCategorySelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3( uint64_t a1, lsl::Allocator::Pool *a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke( uint64_t a1, int *a2)
{
  char v5 = v4;
  objc_visitor::Method::getNameField(a2, *(void *)(a1 + 40), v9);
  metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  char v7 = v6;
  objc_visitor::Method::getName(a2, *(void *)(a1 + 40));
  if (!v5 || !v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_2( uint64_t a1, objc_visitor::MethodList *this)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((result & 1) == 0)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        int v5 = result;
        for (int i = 0; i != v5; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod(this, *(void *)(a1 + 40), i, (uint64_t)&v8);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16LL))(Method);
        }
      }
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L40forEachProtocolSelectorReferenceToUniqueERN12objc_visitor7VisitorEyRKNS_14ObjCBinaryInfoEU13block_pointerFvyyPKcE_block_invoke_3( uint64_t a1, lsl::Allocator::Pool *a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

__n128 __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

void ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke( void *a1, uint64_t a2, char a3, _BYTE *a4)
{
  if (!_platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL)
    && !_platform_strcmp(*(const char **)(a2 + 80), "__objc_imageinfo"))
  {
    if ((a3 & 1) == 0 && *(void *)(a2 + 72) == 8LL)
    {
      uint64_t v8 = (vm_address_t *)a1[6];
      unint64_t v9 = (dyld4::RuntimeState *)a1[7];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000LL;
      __int128 v11[2] = ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2;
      void v11[3] = &unk_1896211B8;
      uint64_t v10 = (dyld4::Loader *)a1[5];
      v11[4] = a1[4];
      v11[5] = a2;
      dyld4::Loader::withLayout(v10, v8, v9, (uint64_t)v11);
    }

    *a4 = 1;
  }

uint64_t ___ZN5dyld4L12getImageInfoER11DiagnosticsRNS_12RuntimeStateEPKNS_6LoaderERKN6mach_o12MachOFileRefE_block_invoke_2( uint64_t result, mach_o::Layout *this)
{
  uint64_t v2 = *(void *)(result + 40);
  unint64_t v3 = (void *)(*((void *)this + 1) + 48LL * ((unsigned __int16)*(_DWORD *)(v2 + 56) >> 4));
  uint64_t v4 = *(void *)(v2 + 64);
  if ((*(_BYTE *)(v3[4] + v4 - *v3 + 4) & 0x80) == 0)
  {
    uint64_t v5 = result;
    __n128 result = mach_o::Layout::textUnslidVMAddr(this);
    uint64_t v6 = *(void *)(*(void *)(v5 + 32) + 8LL);
    int v7 = *(unsigned __int8 *)(v6 + 56);
    *(void *)(v6 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v4 - result;
    *(_BYTE *)(v6 + 48) = 1;
    if (!v7) {
      *(_BYTE *)(v6 + 56) = 1;
    }
  }

  return result;
}

void *objc::objc_headeropt_ro_t<unsigned long long>::get(int *a1, uint64_t a2, unint64_t a3)
{
  if (*a1 < 0) {
    return 0LL;
  }
  int v3 = 0;
  int v4 = *a1;
  while (1)
  {
    int v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4)) {
      ++v5;
    }
    int v6 = v5 >> 1;
    int v7 = (void *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    uint64_t v8 = (char *)v7 + a2 - (void)a1 + *v7;
    else {
      int v4 = v6 - 1;
    }
    if (v3 > v4) {
      return 0LL;
    }
  }

  return v7;
}

unint64_t objc::objc_headeropt_ro_t<unsigned long long>::index( _DWORD *a1, unint64_t a2, uint64_t a3)
{
  if (!*a1) {
    objc::objc_headeropt_ro_t<unsigned long long>::get((uint64_t)a1, a2, a3);
  }
  int v3 = a1 + 2;
  if ((unint64_t)(a1 + 2) > a2
    || (unint64_t v4 = a1[1], (unint64_t)v3 + (v4 * *a1) <= a2))
  {
    objc::objc_headeropt_ro_t<unsigned long long>::index();
  }

  return (a2 - (unint64_t)v3) / v4;
}

int *objc::objc_headeropt_ro_t<unsigned int>::get(int *a1, uint64_t a2, unint64_t a3)
{
  if (*a1 < 0) {
    return 0LL;
  }
  int v3 = 0;
  int v4 = *a1;
  while (1)
  {
    int v5 = v3 + v4;
    if (v3 + v4 < 0 != __OFADD__(v3, v4)) {
      ++v5;
    }
    int v6 = v5 >> 1;
    int v7 = (int *)((char *)a1 + (a1[1] * (v5 >> 1)) + 8);
    uint64_t v8 = (char *)v7 + a2 - (void)a1 + *v7;
    else {
      int v4 = v6 - 1;
    }
    if (v3 > v4) {
      return 0LL;
    }
  }

  return v7;
}

__n128 __Block_byref_object_copy__69(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

void *___ZN5dyld4L19optimizeObjCClassesERNS_12RuntimeStateEPKN4objc14ClassHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS7_IPKcNSB_10BindTargetENS6_11HashCStringENS6_12EqualCStringEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke( uint64_t a1, objc_visitor::Class *a2)
{
  if ((objc_visitor::Class::isRootClass((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) & 1) == 0)
  {
    objc_visitor::Class::getSuperclassField((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), v16);
    metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v16);
    if (!v4) {
      goto LABEL_11;
    }
    if (!*(void *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v16))
    {
      Name = (const char *)objc_visitor::Class::getName( (uint64_t)a2,  (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
      uint64_t v14 = *(void *)(a1 + 40);
      unint64_t v15 = (const char *)dyld4::JustInTimeLoader::path( *(dyld4::JustInTimeLoader **)v14,  *(const dyld4::RuntimeState **)(a1 + 48));
      return (void *)Diagnostics::error( (vm_address_t *)(v14 + 32),  "Missing weak superclass of class %s in %s",  Name,  v15);
    }
  }

  if (objc_visitor::Class::isUnfixedBackwardDeployingStableSwift( (uint64_t)a2,  (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL))) {
    *(_BYTE *)(*(void *)(a1 + 40) + 544LL) = 1;
  }
  VMunint64_t Address = objc_visitor::Class::getVMAddress(a2);
  char v7 = v6;
  uint64_t NameVMAddr = objc_visitor::Class::getNameVMAddr((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
  char v10 = v9;
  unint64_t v11 = (char *)objc_visitor::Class::getName((uint64_t)a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
  if (!v7 || !v10) {
LABEL_11:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  return dyld4::PrebuiltObjC::ObjCOptimizerImage::visitClass( *(void *)(a1 + 40),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(unsigned int **)(a1 + 72),  *(void *)(a1 + 80),  *(void *)(a1 + 88),  VMAddress,  1,  NameVMAddr,  1,  v11);
}

void ___ZN5dyld4L21optimizeObjCProtocolsERNS_12RuntimeStateEPKN4objc17ProtocolHashTableERN5dyld33MapItNSt3__14pairI9VMAddressPKNS_6LoaderEEENS_10HashUInt16ENS_11EqualUInt16EEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke( uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  if (v13[16])
  {
    Diagnostics::error((vm_address_t *)(*(void *)(a1 + 40) + 32LL), "Protocol ISA must be null");
    *a3 = 1;
  }

  else
  {
    VMunint64_t Address = objc_visitor::Protocol::getVMAddress(a2);
    char v8 = v7;
    uint64_t NameVMAddr = objc_visitor::Protocol::getNameVMAddr(a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
    char v11 = v10;
    Name = (char *)objc_visitor::Protocol::getName(a2, (int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
    if (!v8 || !v11) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    dyld4::PrebuiltObjC::ObjCOptimizerImage::visitProtocol( *(void *)(a1 + 40),  *(unsigned int **)(a1 + 48),  *(void *)(a1 + 56),  VMAddress,  1,  NameVMAddr,  1,  Name);
  }

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
  if (!(_DWORD)result)
  {
    char v8 = *(const char **)(a2 + 80);
    uint64_t result = _platform_strcmp(v8, "__module_info");
    if (!(_DWORD)result
      || (uint64_t result = _platform_strcmp(v8, "__protocol"), !(_DWORD)result)
      || (uint64_t result = _platform_strcmp(v8, "__message_refs"), !(_DWORD)result))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_2( void *a1, int *a2, _BYTE *a3)
{
  uint64_t result = (uint64_t)objc_visitor::Method::getNameSelRefVMAddr(a2, *(void *)(a1[4] + 8LL) + 40LL);
  uint64_t v7 = a1[5];
  if (!*(_BYTE *)(v7 + 24) || !v6) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v8 = result - *(void *)(v7 + 16);
  if (v8 < a1[6] || v8 >= a1[7])
  {
    uint64_t result = Diagnostics::error( (vm_address_t *)(v7 + 32),  "Cannot handle relative method list pointing outside of __objc_selrefs");
    *a3 = 1;
  }

  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_3( uint64_t a1, objc_visitor::MethodList *this, _BYTE *a3)
{
  uint64_t result = objc_visitor::MethodList::numMethods(this);
  if ((_DWORD)result)
  {
    uint64_t result = objc_visitor::MethodList::usesRelativeOffsets(this);
    if ((_DWORD)result)
    {
      uint64_t result = objc_visitor::MethodList::numMethods(this);
      if ((_DWORD)result)
      {
        int v7 = result;
        for (int i = 0; i != v7; ++i)
        {
          double Method = objc_visitor::MethodList::getMethod( this,  *(void *)(*(void *)(a1 + 40) + 8LL) + 40LL,  i,  (uint64_t)&v10);
          uint64_t result = (*(uint64_t (**)(double))(*(void *)(a1 + 32) + 16LL))(Method);
        }
      }
    }

    else
    {
      *a3 = 1;
    }
  }

  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_4( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_5( uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (!*a3) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
  return result;
}

uint64_t ___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_6( uint64_t a1, lsl::Allocator::Pool *a2, _BYTE *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (!*a3)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
    if (!*a3)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
      if (!*a3) {
        return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
      }
    }
  }

  return result;
}

void *___ZN5dyld4L21optimizeObjCSelectorsERNS_12RuntimeStateEPKN4objc17SelectorHashTableERN5dyld33MapIN13prebuilt_objc13ObjCStringKeyENS8_20ObjCSelectorLocationENS8_17HashObjCStringKeyENS8_18EqualObjCStringKeyEEERNS_12PrebuiltObjC18ObjCOptimizerImageE_block_invoke_7( uint64_t a1, int a2, unint64_t a3, char *__s, int a5)
{
  return dyld4::PrebuiltObjC::ObjCOptimizerImage::visitReferenceToObjCSelector( *(void *)(a1 + 32),  *(objc::StringHashTable **)(a1 + 40),  *(uint64_t **)(a1 + 48),  (int)__s,  a5,  a3,  1,  __s);
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKeyOnDisk,void,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::const_find<char const*>( uint64_t a1, void *a2, void *a3, dyld4::RuntimeState *a4, const char **a5)
{
  if (!a3[2]) {
    return *a3;
  }
  char v9 = (char *)*a5;
  int v10 = _platform_strlen(*a5);
  uint64_t v11 = murmurHash((uint64_t *)v9, v10, 0LL);
  unint64_t v14 = a2[2];
  unint64_t v15 = (v14 - 1) & v11;
  if (v14 <= v15) {
LABEL_8:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v11,  v12,  v13);
  uint64_t v16 = 1LL;
  while (1)
  {
    unint64_t v17 = *(unsigned int *)(*a2 + 4 * v15);
    unint64_t v18 = a3[2];
    if ((_DWORD)v17 == -1) {
      return *a3 + 8 * v18;
    }
    if (v18 <= v17) {
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v11,  v12,  v13);
    }
    uint64_t v19 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 8 * v17);
    v22[0] = *a5;
    v22[1] = (const char *)_platform_strlen(v22[0]);
    uint64_t v11 = prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v19, (uint64_t)v22, a4);
    if ((_DWORD)v11) {
      break;
    }
    unint64_t v20 = a2[2];
    unint64_t v15 = (v20 - 1) & (v15 + v16++);
    if (v20 <= v15) {
      goto LABEL_8;
    }
  }

  if (a3[2] <= v17) {
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v11,  v12,  v13);
  }
  return *a3 + 8 * v17;
}

BOOL prebuilt_objc::EqualObjCStringKeyOnDisk::equal( dyld4::PrebuiltLoader::BindTargetRef *a1, uint64_t a2, dyld4::RuntimeState *a3)
{
  uint64_t v4 = (const char *)dyld4::PrebuiltLoader::BindTargetRef::value(a1, a3, (uint64_t)a3);
  size_t v5 = _platform_strlen(v4);
  return v5 == *(void *)(a2 + 8) && _platform_memcmp(v4, *(const void **)a2, v5) == 0;
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry<char const*>( uint64_t a1, void *a2, uint64_t *a3, dyld4::RuntimeState *a4, const char **a5, uint64_t a6)
{
  if (a3[2])
  {
    uint64_t v11 = (char *)*a5;
    int v12 = _platform_strlen(*a5);
    uint64_t v13 = murmurHash((uint64_t *)v11, v12, 0LL);
    unint64_t v16 = a2[2];
    unint64_t v17 = (v16 - 1) & v13;
    if (v16 <= v17) {
LABEL_8:
    }
      dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v13,  v14,  v15);
    uint64_t v18 = 1LL;
    while (1)
    {
      unint64_t v19 = *(void *)(*a2 + 8 * v17);
      if (v19 == -1LL) {
        break;
      }
      if (a3[2] <= v19) {
        dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v13,  v14,  v15);
      }
      unint64_t v20 = (dyld4::PrebuiltLoader::BindTargetRef *)(*a3 + 24 * v19);
      uint64_t v47 = *a5;
      v48.i64[0] = _platform_strlen(v47);
      uint64_t v13 = prebuilt_objc::EqualObjCStringKeyOnDisk::equal(v20, (uint64_t)&v47, a4);
      if ((_DWORD)v13)
      {
        unint64_t v27 = a3[2];
        if (v27 <= v19) {
          dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v13,  v14,  v15);
        }
        uint64_t v28 = *a3;
        unint64_t v29 = *(void *)(*a3 + 24 * v19 + 16);
        if ((v29 & 7) != 0)
        {
          if (v27 <= v29 >> 3) {
LABEL_15:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v13,  v14,  v15);
          unint64_t v30 = v29 >> 3;
          int v31 = 2;
          while (1)
          {
            unint64_t v32 = *(void *)(v28 + 24 * v30 + 16);
            if ((v32 & 3) == 0) {
              break;
            }
            unint64_t v30 = v32 >> 3;
            ++v31;
            if (v27 <= v32 >> 3) {
              goto LABEL_15;
            }
          }

          __chkstk_darwin(v13, v14, v15, v21, v22, v23, v24, v25, v46);
          __int128 v38 = (char *)&v46 - v37;
          *(uint64_t *)((char *)&v46 - v37) = v39 + 24 * v19 + 8;
          unint64_t v40 = a3[2];
          if (v40 <= *v36 >> 3) {
LABEL_20:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v33,  v34,  v35);
          uint64_t v41 = *v36 >> 3;
          uint64_t v42 = *a3;
          unsigned int v43 = 2;
          while (1)
          {
            uint64_t v44 = v42 + 24 * v41;
            unint64_t v45 = *(void *)(v44 + 16);
            *(void *)&v38[8 * v43 - 8] = v44 + 8;
            if ((v45 & 3) == 0) {
              break;
            }
            uint64_t v41 = v45 >> 3;
            ++v43;
            if (v40 <= v45 >> 3) {
              goto LABEL_20;
            }
          }

          uint64_t v47 = v38;
          v48.i64[0] = v43;
          v48.i64[1] = v43;
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v47);
        }

        else
        {
          uint64_t v49 = v28 + 24 * v19 + 8;
          uint64_t v47 = (const char *)&v49;
          int64x2_t v48 = vdupq_n_s64(1uLL);
          (*(void (**)(uint64_t, const char **))(a6 + 16))(a6, &v47);
        }

        return;
      }

      unint64_t v26 = a2[2];
      unint64_t v17 = (v26 - 1) & (v17 + v18++);
      if (v26 <= v17) {
        goto LABEL_8;
      }
    }
  }

uint64_t dyld3::MultiMapBase<prebuilt_objc::ObjCStringKeyOnDisk,prebuilt_objc::ObjCObjectOnDiskLocation,prebuilt_objc::HashObjCStringKeyOnDisk,prebuilt_objc::EqualObjCStringKeyOnDisk>::forEachEntry( uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3[2];
  if (v8)
  {
    uint64_t v11 = *a3;
    uint64_t v12 = *a3 + 24 * v8;
    int64x2_t v32 = vdupq_n_s64(1uLL);
    do
    {
      unint64_t v13 = *(void *)(v11 + 16);
      if ((v13 & 7) != 0)
      {
        if ((v13 & 1) != 0)
        {
          unint64_t v14 = a3[2];
          if (v14 <= v13 >> 3) {
LABEL_19:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( result,  a2,  (uint64_t)a3);
          unint64_t v15 = v13 >> 3;
          uint64_t v16 = 2LL;
          while (1)
          {
            unint64_t v17 = *(void *)(*a3 + 24 * v15 + 16);
            if ((v17 & 3) == 0) {
              break;
            }
            unint64_t v15 = v17 >> 3;
            ++v16;
            if (v14 <= v17 >> 3) {
              goto LABEL_19;
            }
          }

          __chkstk_darwin(result, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v32.i64[0]);
          uint64_t v22 = (uint64_t *)((char *)v32.i64 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL));
          uint64_t *v22 = v11 + 8;
          unint64_t v23 = a3[2];
          unint64_t v24 = *(void *)(v11 + 16);
          if (v23 <= v24 >> 3) {
LABEL_20:
          }
            dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v18,  v19,  v20);
          unint64_t v25 = v24 >> 3;
          uint64_t v26 = *a3;
          uint64_t v27 = 1LL;
          while (1)
          {
            uint64_t v28 = v26 + 24 * v25;
            uint64_t v30 = *(void *)(v28 + 16);
            unint64_t v29 = (unint64_t *)(v28 + 16);
            v22[v27] = (uint64_t)(v29 - 1);
            if ((v30 & 3) == 0) {
              break;
            }
            unint64_t v31 = *v29;
            unint64_t v25 = *v29 >> 3;
            ++v27;
            if (v23 <= v31 >> 3) {
              goto LABEL_20;
            }
          }

          uint64_t v33 = v22;
          v34.i64[0] = v27 + 1;
          v34.i64[1] = v27 + 1;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v33);
        }
      }

      else
      {
        uint64_t v35 = v11 + 8;
        uint64_t v33 = &v35;
        int64x2_t v34 = v32;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t **))(a4 + 16))(a4, v11, &v33);
      }

      v11 += 24LL;
    }

    while (v11 != v12);
  }

  return result;
}

uint64_t dyld3::MapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCSelectorLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::find<prebuilt_objc::ObjCStringKey>( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a3[2]) {
    return *a3;
  }
  uint64_t v8 = murmurHash(*(uint64_t **)a5, *(_DWORD *)(a5 + 8), 0LL);
  unint64_t v11 = a2[2];
  unint64_t v12 = v11 - 1;
  unint64_t v13 = v8 & (v11 - 1);
  if (v11 <= v13) {
LABEL_9:
  }
    dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( v8,  v9,  v10);
  uint64_t v14 = *a2;
  unint64_t v15 = a3[2];
  uint64_t v16 = *a3;
  uint64_t v17 = 1LL;
  uint64_t v20 = a5;
  uint64_t v19 = *(uint64_t **)a5;
  size_t v18 = *(void *)(v20 + 8);
  while (1)
  {
    unint64_t v21 = *(unsigned int *)(v14 + 4 * v13);
    if ((_DWORD)v21 == -1) {
      return v16 + 32 * v15;
    }
    if (v15 <= v21) {
      ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1(v8, v9, v10);
    }
    uint64_t v22 = v16 + 32 * v21;
    if (*(void *)(v22 + 8) == v18)
    {
      uint64_t v8 = _platform_memcmp(*(const void **)v22, v19, v18);
      if (!(_DWORD)v8) {
        return v22;
      }
    }

    unint64_t v23 = v13 + v17++;
    unint64_t v13 = v23 & v12;
    if (v11 <= (v23 & v12)) {
      goto LABEL_9;
    }
  }

void *dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 40 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    uint64_t result = memmove((void *)v4[3], *v4, 40LL * (void)v4[2]);
    unint64_t v12 = (unint64_t)v4[4] / 0x28;
    const char *v4 = v4[3];
    v4[1] = (const void *)v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void *dyld3::OverflowSafeArray<BOOL,4294967295ull>::verifySpace(void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (v3 + vm_page_size - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    uint64_t v9 = vm_allocate(mach_task_self_, result + 3, v8, 1006632961);
    if ((_DWORD)v9) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v9, v10, v11);
    }
    uint64_t result = memmove((void *)v4[3], *v4, (size_t)v4[2]);
    unint64_t v12 = v4[4];
    const char *v4 = v4[3];
    v4[1] = v12;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

uint64_t dyld3::Map<VMOffset,unsigned int,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetHash,dyld4::PrebuiltObjC::ObjCOptimizerImage::VMOffsetEqual>::insert( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 == *(void *)a1)
  {
    unint64_t v5 = 2LL * *(void *)(a1 + 32);
    *(void *)a1 = 2 * v4;
    vm_size_t size = 0LL;
    memset(v27, 0, sizeof(v27));
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve(v27, v5);
    for (; v5; --v5)
    {
      dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v27, 1LL);
      uint64_t v6 = (*(void *)&v27[1])++;
      *(_DWORD *)(*(void *)&v27[0] + 4 * v6) = -1;
    }

    if (*(void *)(a1 + 72))
    {
      unint64_t v7 = 0LL;
      while (1)
      {
        uint64_t v8 = dyld3::OverflowSafeArray<dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::NodeImplT<false>,4294967295ull>::operator[]( (void *)(a1 + 56),  v7);
        if (!*(_BYTE *)(v8 + 8)) {
          break;
        }
        unint64_t v9 = (*(void *)&v27[1] - 1LL) & *(void *)v8;
        if (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) != -1)
        {
          uint64_t v10 = 1LL;
          do
            unint64_t v9 = (*(void *)&v27[1] - 1LL) & (v9 + v10++);
          while (*(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) != -1);
        }

        *(_DWORD *)dyld3::OverflowSafeArray<unsigned int,4294967295ull>::operator[](v27, v9) = v7++;
        if (v7 == *(void *)(a1 + 72)) {
          goto LABEL_11;
        }
      }

uint64_t dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCImageFixups,4294967295ull>::growTo( vm_address_t *a1, unint64_t a2)
{
  vm_address_t v3 = a1[3];
  vm_size_t v4 = a1[4];
  unint64_t v5 = a1 + 3;
  unint64_t v6 = 2 * a1[1];
  if (v6 <= a2) {
    unint64_t v6 = a2;
  }
  vm_size_t v7 = (vm_page_size + 160 * v6 - 1) & -(uint64_t)vm_page_size;
  a1[4] = v7;
  uint64_t result = vm_allocate(mach_task_self_, v5, v7, 1006632961);
  if ((_DWORD)result) {
    dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v9, v10);
  }
  vm_address_t v11 = a1[3];
  if (a1[2])
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    do
    {
      unint64_t v14 = (__int128 *)(*a1 + v12);
      vm_address_t v15 = v11 + v12;
      __int128 v16 = v14[1];
      __int128 v17 = v14[2];
      __int128 v18 = v14[4];
      *(_OWORD *)(v15 + 48) = v14[3];
      *(_OWORD *)(v15 + 64) = v18;
      *(_OWORD *)(v15 + 16) = v16;
      *(_OWORD *)(v15 + 32) = v17;
      __int128 v19 = *v14;
      *(_OWORD *)(v15 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0uLL;
      *(_OWORD *)(v15 + 96) = 0uLL;
      *(_OWORD *)vm_address_t v15 = v19;
      *(void *)(v15 + 112) = 0LL;
      uint64_t v20 = *((void *)v14 + 10);
      *(_OWORD *)(v15 + 88) = *(__int128 *)((char *)v14 + 88);
      uint64_t v21 = *((void *)v14 + 13);
      *(void *)(v15 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v20;
      uint64_t v22 = *((void *)v14 + 14);
      *(void *)(v15 + 104) = v21;
      *(void *)(v15 + 112) = v22;
      *((void *)v14 + 14) = 0LL;
      void v14[5] = 0uLL;
      void v14[6] = 0uLL;
      *(void *)(v15 + 152) = 0LL;
      *(_OWORD *)(v15 + 136) = 0uLL;
      *(_OWORD *)(v15 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0uLL;
      __int128 v23 = v14[8];
      *(void *)(v15 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)v14 + 15);
      *(_OWORD *)(v15 + 128) = v23;
      uint64_t v24 = *((void *)v14 + 19);
      *(void *)(v15 + 144) = *((void *)v14 + 18);
      *(void *)(v15 + 152) = v24;
      *((void *)v14 + 19) = 0LL;
      *(__int128 *)((char *)v14 + 136) = 0uLL;
      *(__int128 *)((char *)v14 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0uLL;
      ++v13;
      v12 += 160LL;
    }

    while (v13 != a1[2]);
    vm_address_t v11 = *v5;
  }

  unint64_t v25 = a1[4] / 0xA0;
  *a1 = v11;
  a1[1] = v25;
  if (v3) {
    return vm_deallocate(mach_task_self_, v3, v4);
  }
  return result;
}

uint64_t dyld3::Map<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::Map( uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v2 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = xmmword_1800B7B30;
  uint64_t v3 = 32LL;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::reserve((void *)(a1 + 16), 0x20uLL);
  do
  {
    dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v2, 1LL);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    *(_DWORD *)(v4 + 4 * v5) = -1;
    --v3;
  }

  while (v3);
  dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve( a1 + 56,  0x20uLL);
  return a1;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve( uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(void *)(result + 8);
  if (v2 < a2)
  {
    uint64_t v3 = (void *)result;
    vm_address_t v4 = *(void *)(result + 24);
    vm_size_t v5 = *(void *)(result + 32);
    unint64_t v6 = (vm_address_t *)(result + 24);
    unint64_t v7 = 2 * v2;
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    vm_size_t v8 = (vm_page_size + 32 * v7 - 1) & -(uint64_t)vm_page_size;
    *(void *)(result + 32) = v8;
    uint64_t result = vm_allocate(mach_task_self_, v6, v8, 1006632961);
    if ((_DWORD)result) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v9, v10);
    }
    vm_address_t v11 = v3[3];
    if (v3[2])
    {
      uint64_t v12 = 0LL;
      uint64_t v13 = 0LL;
      do
      {
        unint64_t v14 = (_OWORD *)(v11 + v12);
        vm_address_t v15 = (_OWORD *)(*v3 + v12);
        __int128 v16 = v15[1];
        _OWORD *v14 = *v15;
        v14[1] = v16;
        ++v13;
        v12 += 32LL;
      }

      while (v13 != v3[2]);
      vm_address_t v11 = *v6;
    }

    uint64_t v17 = v3[4] >> 5;
    *uint64_t v3 = v11;
    v3[1] = v17;
    if (v4) {
      return vm_deallocate(mach_task_self_, v4, v5);
    }
  }

  return result;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::operator[]( void *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a2 + 1;
  if (v4 <= a2 && v4 != v5)
  {
    if (v4 <= v5) {
      dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::reserve( (uint64_t)a1,  a2 + 1);
    }
    a1[2] = v5;
  }

  return *a1 + 32 * a2;
}

uint64_t dyld3::OverflowSafeArray<dyld3::MapBase<unsigned short,std::pair<VMAddress,dyld4::Loader const*>,dyld4::HashUInt16,dyld4::EqualUInt16>::NodeImplT<false>,4294967295ull>::verifySpace( uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 8);
  unint64_t v3 = *(void *)(result + 16) + a2;
  if (v3 > v2)
  {
    unint64_t v4 = (void *)result;
    vm_address_t v5 = *(void *)(result + 24);
    vm_size_t v6 = *(void *)(result + 32);
    unint64_t v7 = (vm_address_t *)(result + 24);
    unint64_t v8 = 2 * v2;
    if (v8 > v3) {
      unint64_t v3 = v8;
    }
    vm_size_t v9 = (vm_page_size + 32 * v3 - 1) & -(uint64_t)vm_page_size;
    *(void *)(result + 32) = v9;
    uint64_t result = vm_allocate(mach_task_self_, v7, v9, 1006632961);
    if ((_DWORD)result) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(result, v10, v11);
    }
    vm_address_t v12 = v4[3];
    if (v4[2])
    {
      uint64_t v13 = 0LL;
      uint64_t v14 = 0LL;
      do
      {
        vm_address_t v15 = (_OWORD *)(v12 + v13);
        __int128 v16 = (_OWORD *)(*v4 + v13);
        __int128 v17 = v16[1];
        *vm_address_t v15 = *v16;
        v15[1] = v17;
        ++v14;
        v13 += 32LL;
      }

      while (v14 != v4[2]);
      vm_address_t v12 = *v7;
    }

    uint64_t v18 = v4[4] >> 5;
    void *v4 = v12;
    v4[1] = v18;
    if (v5) {
      return vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void dyld3::OverflowSafeArray<dyld4::PrebuiltObjC::ObjCOptimizerImage,4294967295ull>::verifySpace( vm_address_t *a1, uint64_t a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a1[2] + a2;
  if (v3 > v2)
  {
    vm_address_t v5 = a1[3];
    vm_size_t v6 = a1[4];
    unint64_t v7 = a1 + 3;
    unint64_t v8 = 2 * v2;
    if (v8 > v3) {
      unint64_t v3 = v8;
    }
    vm_size_t v9 = (vm_page_size + 568 * v3 - 1) & -(uint64_t)vm_page_size;
    a1[4] = v9;
    uint64_t v10 = vm_allocate(mach_task_self_, v7, v9, 1006632961);
    if ((_DWORD)v10) {
      dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace(v10, v11, v12);
    }
    vm_address_t v13 = a1[3];
    if (a1[2])
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = 0LL;
      do
      {
        dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(v13 + v14, (__int128 *)(*a1 + v14));
        ++v15;
        v14 += 568LL;
      }

      while (v15 != a1[2]);
      vm_address_t v13 = *v7;
    }

    unint64_t v16 = a1[4] / 0x238;
    *a1 = v13;
    a1[1] = v16;
    if (v5) {
      vm_deallocate(mach_task_self_, v5, v6);
    }
  }

__n128 dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCOptimizerImage(uint64_t a1, __int128 *a2)
{
  __int128 v2 = *a2;
  __int128 v3 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 48) = a2[3];
  uint64_t v4 = *((void *)a2 + 9);
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(void *)(a1 + 72) = v4;
  *((void *)a2 + 9) = 0LL;
  *(__int128 *)((char *)a2 + 56) = 0u;
  *(__int128 *)((char *)a2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 112) = 0LL;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 10);
  *(_OWORD *)(a1 + 88) = *(__int128 *)((char *)a2 + 88);
  uint64_t v5 = *((void *)a2 + 14);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(void *)(a1 + 112) = v5;
  *((void *)a2 + 14) = 0LL;
  a2[5] = 0u;
  a2[6] = 0u;
  *(void *)(a1 + 152) = 0LL;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 15);
  *(_OWORD *)(a1 + 128) = a2[8];
  uint64_t v6 = *((void *)a2 + 19);
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(void *)(a1 + 152) = v6;
  *((void *)a2 + 19) = 0LL;
  *(__int128 *)((char *)a2 + 136) = 0u;
  *(__int128 *)((char *)a2 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  __int128 v7 = a2[10];
  *(void *)(a1 + 208) = 0LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 16dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v7;
  *(void *)(a1 + 176) = *((void *)a2 + 22);
  *(_OWORD *)(a1 + 184) = *(__int128 *)((char *)a2 + 184);
  uint64_t v8 = *((void *)a2 + 26);
  *(void *)(a1 + 20dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 25);
  *(void *)(a1 + 208) = v8;
  *((void *)a2 + 26) = 0LL;
  a2[11] = 0u;
  a2[12] = 0u;
  *(void *)(a1 + 248) = 0LL;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  *(_OWORD *)(a1 + 224) = a2[14];
  uint64_t v9 = *((void *)a2 + 31);
  *(void *)(a1 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 30);
  *(void *)(a1 + 248) = v9;
  *((void *)a2 + 3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
  *(__int128 *)((char *)a2 + 232) = 0u;
  *(__int128 *)((char *)a2 + 216) = 0u;
  __int128 v10 = a2[16];
  *(void *)(a1 + 304) = 0LL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 256) = v10;
  uint64_t v11 = *((void *)a2 + 35);
  *(void *)(a1 + 272) = *((void *)a2 + 34);
  *(void *)(a1 + 28dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v11;
  *(_OWORD *)(a1 + 288) = a2[18];
  *(void *)(a1 + 304) = *((void *)a2 + 38);
  *((void *)a2 + 38) = 0LL;
  a2[17] = 0u;
  a2[18] = 0u;
  *(void *)(a1 + 344) = 0LL;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(_OWORD *)(a1 + 32dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2[20];
  uint64_t v12 = *((void *)a2 + 43);
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(void *)(a1 + 344) = v12;
  *((void *)a2 + 43) = 0LL;
  *(__int128 *)((char *)a2 + 328) = 0u;
  *(__int128 *)((char *)a2 + 312) = 0u;
  *(void *)(a1 + 384) = 0LL;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  uint64_t v13 = *((void *)a2 + 45);
  *(void *)(a1 + 352) = *((void *)a2 + 44);
  *(void *)(a1 + 36dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v13;
  *(_OWORD *)(a1 + 368) = a2[23];
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *((void *)a2 + 48) = 0LL;
  a2[22] = 0u;
  a2[23] = 0u;
  __int128 v14 = *(__int128 *)((char *)a2 + 392);
  *(void *)(a1 + 44dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 392) = v14;
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(_OWORD *)(a1 + 416) = a2[26];
  uint64_t v15 = *((void *)a2 + 55);
  *(void *)(a1 + 432) = *((void *)a2 + 54);
  *(void *)(a1 + 44dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v15;
  *((void *)a2 + 55) = 0LL;
  *(__int128 *)((char *)a2 + 408) = 0u;
  *(__int128 *)((char *)a2 + 424) = 0u;
  *(void *)(a1 + 48dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  uint64_t v16 = *((void *)a2 + 57);
  *(void *)(a1 + 448) = *((void *)a2 + 56);
  *(void *)(a1 + 456) = v16;
  *(_OWORD *)(a1 + 464) = a2[29];
  *(void *)(a1 + 48dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 60);
  *((void *)a2 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  a2[28] = 0u;
  a2[29] = 0u;
  __int128 v17 = *(__int128 *)((char *)a2 + 552);
  __int128 v19 = *(__int128 *)((char *)a2 + 504);
  __int128 v18 = *(__int128 *)((char *)a2 + 520);
  *(_OWORD *)(a1 + 536) = *(__int128 *)((char *)a2 + 536);
  *(_OWORD *)(a1 + 552) = v17;
  *(_OWORD *)(a1 + 504) = v19;
  *(_OWORD *)(a1 + 52dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v18;
  __n128 result = *(__n128 *)((char *)a2 + 488);
  *(__n128 *)(a1 + 488) = result;
  return result;
}

void OUTLINED_FUNCTION_4_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t dyld3::kdebug_trace_dyld_image( dyld3 *this, void *a2, void **a3, unsigned __int8 (*a4)[16], fsobj_id a5, fsid a6, const void *a7, uint64_t a8, const void *a9)
{
  int v12 = (int)a7;
  fsobj_id v13 = a5;
  return dyld3::kdebug_trace_dyld_region(this, 16777228LL, v12, a2, a3, a4, v13, a6, a9);
}

uint64_t dyld3::kdebug_trace_dyld_region( dyld3 *this, uint64_t a2, int a3, void *a4, void **a5, unsigned __int8 (*a6)[16], fsobj_id a7, fsid a8, const void *a9)
{
  __int16 v15 = 4 * (_WORD)this;
  uint64_t v16 = (void *)((4 * ((unsigned __int16)this & 0x3FFF)) | 0x1F050000u);
  __int128 v17 = (void *)kdebug_trace_string(v16, 0LL, a4, a4, a5, a6, *(void **)&a7, *(void **)&a8);
  kdebug_trace( v16,  *a5,  a5[1],  *(void **)&a8,  (void *)((int)a7.fid_objno | *(void *)&a7 & 0xFFFFFFFF00000000LL),  v18,  v19,  v20);
  kdebug_trace( (void *)((v15 + 4) & 0xFFFC | 0x1F050000u),  a6,  v17,  (void *)(a3 | (unint64_t)(a2 << 32)),  0LL,  v21,  v22,  v23);
  return kdebug_trace_string(v16, v17, 0LL, v24, v25, v26, v27, v28);
}

uint64_t dyld3::kdebug_trace_dyld_cache( unsigned __int8 (*this)[16], fsobj_id a2, void *a3, void *a4, unsigned __int8 *a5, void *a6, void *a7, void *a8)
{
  fsobj_id v14 = a2;
  uint64_t result = kdebug_is_enabled(0x1F050028u, *(void *)&a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    uint64_t result = dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)&dword_180058000);
    if ((result & 1) == 0)
    {
      bzero(v15, 0x400uLL);
      fsobj_id v12 = v14;
      fsid v13 = (fsid)a3;
      return dyld3::kdebug_trace_dyld_region( (dyld3 *)0xA,  0LL,  0,  v15,  (void **)a4,  this,  v12,  v13,  *(const void **)&v14);
    }
  }

  return result;
}

int64_t dyld3::kdebug_trace_dyld_marker( void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  uint64_t v11 = a6;
  fsid v13 = a4;
  __int16 v15 = (void *)a2;
  int64_t result = kdebug_is_enabled(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result) {
    return result;
  }
  if (a3)
  {
    int64_t v23 = kdebug_trace_string(a1, 0LL, a3, v18, v19, v20, v21, v22);
    if (v23 == -1) {
      __int16 v15 = 0LL;
    }
    else {
      __int16 v15 = (void *)v23;
    }
  }

  if (a5)
  {
    int64_t v24 = kdebug_trace_string(a1, 0LL, a5, v18, v19, v20, v21, v22);
    if (v24 == -1) {
      fsid v13 = 0LL;
    }
    else {
      fsid v13 = (void *)v24;
    }
  }

  if (a7)
  {
    int64_t v25 = kdebug_trace_string(a1, 0LL, a7, v18, v19, v20, v21, v22);
    if (v25 == -1) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = (void *)v25;
    }
  }

  if (a10)
  {
    int64_t v26 = kdebug_trace_string(a1, 0LL, a10, v18, v19, v20, v21, v22);
    if (v26 == -1) {
      uint64_t v30 = 0LL;
    }
    else {
      uint64_t v30 = (void *)v26;
    }
    int64_t result = kdebug_trace(a1, v15, v13, v11, v30, v27, v28, v29);
    if (v30) {
      int64_t result = kdebug_trace_string(a1, v30, 0LL, v31, v32, v33, v34, v35);
    }
    if (!a7) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }

  int64_t result = kdebug_trace(a1, v15, v13, v11, a9, v20, v21, v22);
  if (a7)
  {
LABEL_23:
    if (v11) {
      int64_t result = kdebug_trace_string(a1, v11, 0LL, v31, v32, v33, v34, v35);
    }
  }

void *dyld3::kdebug_trace_dyld_duration_start( void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v11 = a4;
  fsid v13 = (void *)a2;
  do
  {
    unint64_t v20 = __ldaxr(&dyld3::trace_pair_id);
    uint64_t v21 = (void *)(v20 + 1);
  }

  while (__stlxr(v20 + 1, &dyld3::trace_pair_id));
  if (a3)
  {
    int64_t v22 = kdebug_trace_string(a1, 0LL, a3, v15, v16, v17, v18, v19);
    if (v22 == -1) {
      fsid v13 = 0LL;
    }
    else {
      fsid v13 = (void *)v22;
    }
  }

  if (a5)
  {
    int64_t v23 = kdebug_trace_string(a1, 0LL, a5, v15, v16, v17, v18, v19);
    if (v23 == -1) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = (void *)v23;
    }
  }

  if (a7)
  {
    int64_t v24 = kdebug_trace_string(a1, 0LL, a7, v15, v16, v17, v18, v19);
    if (v24 == -1) {
      uint64_t v28 = 0LL;
    }
    else {
      uint64_t v28 = (void *)v24;
    }
    kdebug_trace((void *)(a1 | 1), v21, v13, v11, v28, v25, v26, v27);
    if (v28) {
      kdebug_trace_string(a1, v28, 0LL, v29, v30, v31, v32, v33);
    }
    if (!a5) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }

  kdebug_trace((void *)(a1 | 1), v21, v13, v11, a6, v17, v18, v19);
  if (a5)
  {
LABEL_21:
    if (v11) {
      kdebug_trace_string(a1, v11, 0LL, v29, v30, v31, v32, v33);
    }
  }

int64_t dyld3::kdebug_trace_dyld_duration_end( int64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!result) {
    return result;
  }
  uint64_t v11 = a5;
  fsid v13 = a3;
  __int16 v15 = (void *)result;
  int64_t result = kdebug_is_enabled(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result) {
    return result;
  }
  if (a4)
  {
    int64_t v21 = kdebug_trace_string(a2, 0LL, a4, v16, v17, v18, v19, v20);
    if (v21 == -1) {
      fsid v13 = 0LL;
    }
    else {
      fsid v13 = (void *)v21;
    }
  }

  if (a6)
  {
    int64_t v22 = kdebug_trace_string(a2, 0LL, a6, v16, v17, v18, v19, v20);
    if (v22 == -1) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = (void *)v22;
    }
  }

  if (a8)
  {
    int64_t v23 = kdebug_trace_string(a2, 0LL, a8, v16, v17, v18, v19, v20);
    if (v23 == -1) {
      uint64_t v27 = 0LL;
    }
    else {
      uint64_t v27 = (void *)v23;
    }
    int64_t result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, v27, v24, v25, v26);
    if (v27) {
      int64_t result = kdebug_trace_string(a2, v27, 0LL, v28, v29, v30, v31, v32);
    }
    if (!a6) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }

  int64_t result = kdebug_trace((void *)(a2 | 2), v15, v13, v11, a7, v18, v19, v20);
  if (a6)
  {
LABEL_20:
    if (v11) {
      int64_t result = kdebug_trace_string(a2, v11, 0LL, v28, v29, v30, v31, v32);
    }
  }

void *dyld3::ScopedTimer::startTimer( dyld3::ScopedTimer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int64_t result = dyld3::kdebug_trace_dyld_duration_start( (void *)*(unsigned int *)this,  *((void *)this + 1),  *((void **)this + 2),  *((void **)this + 3),  *((void **)this + 4),  *((void **)this + 5),  *((void **)this + 6),  a8);
  *((void *)this + 13) = result;
  return result;
}

uint64_t dyld3::ScopedTimer::endTimer(dyld3::ScopedTimer *this)
{
  return dyld3::kdebug_trace_dyld_duration_end( *((void *)this + 13),  (void *)*(unsigned int *)this,  *((void **)this + 7),  *((void **)this + 8),  *((void **)this + 9),  *((void **)this + 10),  *((void **)this + 11),  *((void **)this + 12));
}

uint64_t lldb_image_notifier( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v8 = (uint64_t *)a3;
  unsigned int v9 = a2;
  int v26 = 520552492;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  uint64_t v33 = 0LL;
  started = dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v26, a2, a3, a4, a5, a6, a7, a8);
  __chkstk_darwin((uint64_t)started, v9, v12, v13, v14, v15, v16, v17, v25);
  unint64_t v20 = (char *)&v25 - v19;
  if (v9)
  {
    uint64_t v21 = v18;
    int64_t v22 = v20;
    do
    {
      uint64_t v23 = *v8;
      v8 += 3;
      *v22++ = v23;
      --v21;
    }

    while (v21);
  }

  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v26);
}

void *dyld4::ExternallyViewableState::initOld(void *a1, lsl::Lock **this, int a3)
{
  uint64_t v5 = sProcessInfo;
  a1[3] = sProcessInfo;
  v5[80] = a3;
  uint64_t v6 = lsl::Allocator::malloc(this, 0x20uLL);
  *uint64_t v6 = this;
  v6[1] = 0LL;
  void v6[2] = 0LL;
  void v6[3] = 0LL;
  a1[4] = v6;
  int64_t result = lsl::Allocator::malloc(this, 0x20uLL);
  *int64_t result = this;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  a1[5] = result;
  return result;
}

void *dyld4::ExternallyViewableState::init( uint64_t *a1, lsl::Lock **a2, lsl::Lock **this, dyld4::FileManager *a4, unsigned int a5)
{
  a1[1] = (uint64_t)a4;
  __int128 v10 = (dyld4::Atlas::ProcessSnapshot *)lsl::Allocator::aligned_alloc(this, 8uLL, 0x70uLL);
  uint64_t v13 = 0LL;
  *a1 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v10, (lsl::Allocator *)this, a4, 1);
  lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v13, v11);
  dyld4::Atlas::ProcessSnapshot::setDyldState(*a1, 16LL);
  dyld4::Atlas::ProcessSnapshot::setPlatform(*a1, a5);
  return dyld4::ExternallyViewableState::initOld(a1, a2, a5);
}

void dyld4::ExternallyViewableState::addImageInfo(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  uint64_t v6 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
  dyld4::Atlas::Image::Image((uint64_t)v17, (uint64_t)a2, (dyld4::FileRecord *)v24, v6, *(void *)(a3 + 24));
  dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)v17);
  uint64_t v7 = mach_absolute_time();
  uint64_t v8 = (dyld4::FileRecord *)dyld4::Atlas::Image::file((dyld4::Atlas::Image *)v17);
  uint64_t v9 = dyld4::FileRecord::mtime(v8);
  dyld4::ExternallyViewableState::addImageInfoOld((dyld4::ExternallyViewableState *)a1, (int8x16_t *)a3, v7, v9);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200LL) == 1229016646)
  {
    uint64_t v13 = *(mach_header **)(a3 + 24);
    uint64_t v15 = *(char **)(a3 + 16);
    uint64_t v16 = v13;
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges( (dyld4::ExternallyViewableState *)a1,  0LL,  1LL,  (const mach_header **)&v16,  (const char **)&v15,  v10,  v11,  v12);
  }

  uint64_t v14 = v22;
  if (v22 && v23) {
    dyld4::Atlas::Mapper::unmap(v20, (unint64_t)v22, v21);
  }
  if (v19) {
    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v19, v14);
  }
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v18);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v24);
}

void dyld4::recordFromInfo( lsl::Lock **a1@<X0>, dyld4::FileManager *this@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v15 = 0x1FFFFFFFFLL;
  __int16 v16 = 0;
  char v17 = 1;
  uint64_t v8 = *(void *)a3;
  if (!*(void *)a3 || (uint64_t v9 = *(void *)(a3 + 8)) == 0)
  {
LABEL_9:
    dyld4::FileManager::fileRecordForPath(this, a1, *(const char **)(a3 + 16), a4);
    goto LABEL_10;
  }

  dyld4::FileManager::fileRecordForVolumeDevIDAndObjID(this, v8, v9, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::operator=((dyld4::FileRecord *)v14, (dyld4::FileRecord *)v13);
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v13);
  uint64_t v10 = (_BYTE *)dyld4::FileRecord::volume((dyld4::FileRecord *)v14);
  if (!*v10)
  {
    uint64_t v11 = 1LL;
    while (v11 != 16)
    {
      if (v10[v11++])
      {
        goto LABEL_9;
      }
    }

    goto LABEL_9;
  }

LABEL_4:
  dyld4::FileRecord::FileRecord(a4, (dyld4::FileRecord *)v14);
LABEL_10:
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v14);
}

uint64_t dyld4::ExternallyViewableState::addImageInfoOld( dyld4::ExternallyViewableState *a1, int8x16_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *((void *)a1 + 4);
  int8x16_t v15 = a2[1];
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v8, *(void *)(v8 + 16) + 1LL);
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t v10 = *(void *)(v8 + 16);
  *(void *)(v8 + 16) = v10 + 1;
  uint64_t v11 = (int8x16_t *)(v9 + 24 * v10);
  *uint64_t v11 = vextq_s8(v15, v15, 8uLL);
  v11[1].i64[0] = a4;
  uint64_t v12 = *((void *)a1 + 3);
  *(_DWORD *)(v12 + 4) = *(void *)(*((void *)a1 + 4) + 16LL);
  atomic_store(a3, (unint64_t *)(v12 + 184));
  atomic_store(*(void *)(*((void *)a1 + 4) + 8LL), (unint64_t *)(*((void *)a1 + 3) + 8LL));
  __n128 v13 = dyld4::ExternallyViewableState::addImageUUID(a1, (const dyld3::MachOFile *)a2[1].i64[1]);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, __n128))(*((void *)a1 + 3) + 16LL))( 0LL,  1LL,  *(void *)(*((void *)a1 + 4) + 8LL) + 24LL * *(void *)(*((void *)a1 + 4) + 16LL) - 24,  v13);
}

BOOL dyld4::ExternallyViewableState::notifyMonitorNeeded(dyld4::ExternallyViewableState *this)
{
  return *(_DWORD *)(*((void *)this + 3) + 200LL) == 1229016646;
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges( dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, const mach_header **a4, const char **a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v18 = 520552496;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  uint64_t v25 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v18, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder( (dyld4::RemoteNotificationResponder *)v17,  *(_DWORD *)(*((void *)this + 3) + 200LL));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v17))
  {
    uint64_t v15 = atomic_load((unint64_t *)(*((void *)this + 3) + 184LL));
    dyld4::RemoteNotificationResponder::notifyMonitorOfImageListChanges( (dyld4::RemoteNotificationResponder *)v17,  a2,  a3,  a4,  a5,  v15,  v13,  v14);
  }

  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v17);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v18);
}

__n128 dyld4::ExternallyViewableState::addImageUUID( dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  v10.n128_u64[0] = (unint64_t)a2;
  dyld3::MachOFile::getUuid(a2, &v10.n128_u8[8]);
  *(void *)(*((void *)this + 3) + 96LL) = 0LL;
  uint64_t v3 = *((void *)this + 5);
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(v3, *(void *)(v3 + 16) + 1LL);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  *(void *)(v3 + 16) = v5 + 1;
  uint64_t v6 = (__n128 *)(v4 + 24 * v5);
  __n128 result = v10;
  v6[1].n128_u64[0] = v11;
  *uint64_t v6 = result;
  uint64_t v8 = *((void *)this + 5);
  uint64_t v9 = *((void *)this + 3);
  *(void *)(v9 + 88) = *(void *)(v8 + 16);
  *(void *)(v9 + 96) = *(void *)(v8 + 8);
  return result;
}

double dyld4::ExternallyViewableState::setDyldOld(dyld4::ExternallyViewableState *a1, uint64_t a2)
{
  uint64_t v3 = *(const dyld3::MachOFile **)(a2 + 24);
  *(void *)(*((void *)a1 + 3) + 192LL) = *(void *)(a2 + 16);
  if ((dyld3::MachOFile::inDyldCache(v3) & 1) == 0) {
    *(void *)&double result = dyld4::ExternallyViewableState::addImageUUID(a1, v3).n128_u64[0];
  }
  return result;
}

double dyld4::ExternallyViewableState::setDyld(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  uint64_t v6 = *(mach_header **)(a3 + 24);
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a2);
  if (dyld3::MachOFile::inDyldCache((dyld3::MachOFile *)v6)
    && *(void *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1))
  {
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(void *)a1, v6);
  }

  else
  {
    dyld4::recordFromInfo(a2, *(dyld4::FileManager **)(a1 + 8), a3, (uint64_t)v17);
    uint64_t v7 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::Image::Image((uint64_t)v10, (uint64_t)a2, (dyld4::FileRecord *)v17, v7, *(void *)(a3 + 24));
    dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)v10);
    uint64_t v8 = v15;
    if (v15 && v16) {
      dyld4::Atlas::Mapper::unmap(v13, (unint64_t)v15, v14);
    }
    if (v12) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v12, v8);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v11);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v17);
  }

  return dyld4::ExternallyViewableState::setDyldOld((dyld4::ExternallyViewableState *)a1, a3);
}

uint64_t *dyld4::ExternallyViewableState::ensureSnapshot(uint64_t *this, lsl::Lock **a2)
{
  if (!*this)
  {
    uint64_t v3 = this;
    uint64_t v4 = this[3];
    uint64_t v5 = *(void *)(v4 + 304);
    uint64_t v6 = *(void *)(v4 + 312);
    uint64_t v7 = this[1];
    uint64_t v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x70uLL);
    __n128 v10 = 0LL;
    *uint64_t v3 = dyld4::Atlas::ProcessSnapshot::ProcessSnapshot(v8, a2, v7, 1LL, v5, v6);
    lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr(&v10, v9);
    return (uint64_t *)dyld4::Atlas::ProcessSnapshot::setDyldState(*v3, 80LL);
  }

  return this;
}

uint64_t dyld4::ExternallyViewableState::setLibSystemInitialized(dyld4::ExternallyViewableState *this)
{
  uint64_t result = *(void *)this;
  if (result) {
    uint64_t result = dyld4::Atlas::ProcessSnapshot::setDyldState(result, 48LL);
  }
  *(_BYTE *)(*((void *)this + 3) + 25LL) = 1;
  return result;
}

os_unfair_lock_s *lsl::Vector<dyld_image_info>::resize(os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  24 * a2);
  }

  else
  {
    uint64_t v3 = result + 2;
    __int128 v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

os_unfair_lock_s *dyld4::ExternallyViewableState::setInitialImageCount( dyld4::ExternallyViewableState *this, unsigned int a2)
{
  unint64_t v3 = a2;
  dyld4::Atlas::ProcessSnapshot::setInitialImageCount(*(void *)this, a2);
  uint64_t v4 = (os_unfair_lock_s *)*((void *)this + 4);
  *(void *)(*((void *)this + 3) + 112LL) = v3;
  return lsl::Vector<dyld_image_info>::resize(v4, v3);
}

uint64_t dyld4::ExternallyViewableState::addImagesOld(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  *(_DWORD *)(v6 + 4) = *(void *)(*(void *)(a1 + 32) + 16LL);
  atomic_store(a3, (unint64_t *)(v6 + 184));
  atomic_store(*(void *)(*(void *)(a1 + 32) + 8LL), (unint64_t *)(*(void *)(a1 + 24) + 8LL));
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 24) + 16LL))( 0LL,  *(unsigned int *)(a2 + 16),  *(void *)(a2 + 8));
}

uint64_t lsl::Vector<dyld_image_info>::insert<dyld_image_info*>(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *(void *)(a1 + 8)) >> 3);
  size_t v8 = a4 - a3;
  uint64_t v9 = (a4 - a3) >> 3;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * v9;
  lsl::Vector<dyld4::InterposeTupleSpecific>::reserve(a1, *(void *)(a1 + 16) - 0x5555555555555555LL * v9);
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11 != v7) {
    memmove( (void *)(24 * (v11 + v10) - (24 * v11 - (*(void *)(a1 + 8) + 24 * v7))),  (const void *)(*(void *)(a1 + 8) + 24 * v7),  24 * v11 - 24 * v7);
  }
  if (a4 != a3) {
    memmove((void *)(*(void *)(a1 + 8) + 24 * v7), a3, v8);
  }
  uint64_t v12 = *(void *)(a1 + 8);
  *(void *)(a1 + 16) += v10;
  return v12 + 24 * v7;
}

void dyld4::ExternallyViewableState::addImages(uint64_t a1, lsl::Lock **a2, lsl::Lock **a3, uint64_t *a4)
{
  uint64_t v51 = a2;
  vm_address_t v53 = a3;
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v56 = 0LL;
  os_unfair_lock_t v50 = (os_unfair_lock_t)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  uint64_t v52 = a4;
  uint64_t v8 = a4[1];
  if (v8)
  {
    uint64_t v9 = *v52;
    uint64_t v10 = 40 * v8;
    do
    {
      int v11 = *(unsigned __int8 *)(v9 + 32);
      uint64_t v12 = *(const mach_header **)(v9 + 16);
      uint64_t v13 = *(const mach_header **)(v9 + 24);
      lsl::Vector<dyld4::InterposeTupleSpecific>::reserve((uint64_t)&v53, v55 + 1);
      uint64_t v14 = v55++;
      uint64_t v15 = (const mach_header **)(v54 + 24 * v14);
      *uint64_t v15 = v13;
      v15[1] = v12;
      v15[2] = 0LL;
      if (v11)
      {
        if (*(void *)dyld4::Atlas::ProcessSnapshot::sharedCache(*(dyld4::Atlas::ProcessSnapshot **)a1)) {
          dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(*(void *)a1, v13);
        }
      }

      else
      {
        dyld4::ExternallyViewableState::addImageUUID( (dyld4::ExternallyViewableState *)a1,  (const dyld3::MachOFile *)v13);
        dyld4::recordFromInfo(a3, *(dyld4::FileManager **)(a1 + 8), v9, (uint64_t)v64);
        char v16 = (unsigned int **)dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
        dyld4::Atlas::Image::Image((uint64_t)&v57, (uint64_t)a3, (dyld4::FileRecord *)v64, v16, (uint64_t)v13);
        dyld4::Atlas::ProcessSnapshot::addImage(*(lsl::Lock ****)a1, (dyld4::Atlas::Image *)&v57);
        char v17 = v62;
        if (v62 && v63) {
          dyld4::Atlas::Mapper::unmap(v60, (unint64_t)v62, v61);
        }
        if (v59) {
          lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v59, v17);
        }
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v58);
        dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v64);
      }

      v9 += 40LL;
      v10 -= 40LL;
    }

    while (v10);
  }

  dyld4::ExternallyViewableState::commit((os_unfair_lock_s *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, v51, v7);
  dyld4::ExternallyViewableState::release((os_unfair_lock_s *)a1, (lsl::Allocator *)a3);
  uint64_t v18 = mach_absolute_time();
  uint64_t v19 = dyld4::ExternallyViewableState::addImagesOld(a1, (uint64_t)&v53, v18);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200LL) == 1229016646)
  {
    __chkstk_darwin(v19, v20, v21, v22, v23, v24, v25, v26, v49);
    __chkstk_darwin( v29,  v30,  *(void *)(v28 + 8),  v31,  (uint64_t)&v49 - ((v27 + 23) & 0xFFFFFFFFFFFFFFF0LL),  v32,  v33,  v34,  v49);
    uint64_t v44 = (const mach_header **)((char *)&v49 - ((v43 + 23) & 0xFFFFFFFFFFFFFFF0LL));
    if (!v37) {
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    }
    uint64_t v45 = 0LL;
    uint64_t v46 = (const mach_header **)(*v42 + 24LL);
    uint64_t v47 = 40 * v37;
    do
    {
      if (v37 == v45) {
        dyld4::RuntimeState::appendInterposingTuples(v35, v36, v37);
      }
      v38[v45] = (const char *)*(v46 - 1);
      int64x2_t v48 = *v46;
      v46 += 5;
      v44[v45++] = v48;
      v47 -= 40LL;
    }

    while (v47);
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges( (dyld4::ExternallyViewableState *)a1,  0LL,  v37,  v44,  v38,  v39,  v40,  v41);
  }

  os_unfair_lock_unlock(v50);
  if (v54) {
    lsl::Vector<dyld_image_info>::resize((os_unfair_lock_s *)&v53, 0LL);
  }
}

os_unfair_lock_s *dyld4::ExternallyViewableState::commit( os_unfair_lock_s *this, lsl::Lock **a2, lsl::Allocator *a3, lsl::Allocator *a4)
{
  return dyld4::ExternallyViewableState::release(this, a3);
}

uint64_t dyld4::ExternallyViewableState::removeImagesOld( uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5 = (void *)result;
  atomic_store(0LL, (unint64_t *)(*(void *)(result + 24) + 8LL));
  uint64_t v6 = *(void *)(result + 24);
  *(void *)(v6 + 96) = 0LL;
  uint64_t v7 = *(void *)(a4 + 8);
  if (v7)
  {
    unint64_t v32 = a5;
    uint64_t v10 = *(uint64_t **)a4;
    uint64_t v11 = *(void *)a4 + 8 * v7;
    do
    {
      uint64_t v12 = *v10;
      uint64_t v35 = *v10;
      uint64_t v13 = v5[4];
      uint64_t v14 = *(void *)(v13 + 16);
      if (v14)
      {
        uint64_t v15 = *(void *)(v13 + 8) + 24LL;
        uint64_t v16 = 24 * v14;
        char v17 = (void *)v15;
        while (*(v17 - 3) != v12)
        {
          v17 += 3;
          v15 += 24LL;
          v16 -= 24LL;
          if (!v16) {
            goto LABEL_11;
          }
        }

        dyld3::Array<dyld4::Loader const*>::push_back(a2, v17 - 2, (uint64_t)a3);
        dyld3::Array<dyld4::Loader const*>::push_back(a3, &v35, v18);
        __int128 v19 = *(_OWORD *)(v17 - 3);
        uint64_t v34 = *(v17 - 1);
        __int128 v33 = v19;
        uint64_t v20 = v5[4];
        uint64_t v21 = *(void *)(v20 + 16);
        uint64_t v22 = *(void *)(v20 + 8) + 24 * v21;
        if (v17 != (void *)v22)
        {
          memmove(v17 - 3, v17, v22 - v15);
          uint64_t v21 = *(void *)(v20 + 16);
        }

        *(void *)(v20 + 16) = v21 - 1;
      }

void dyld4::ExternallyViewableState::removeImages(uint64_t a1, lsl::Lock **a2, lsl::Lock **a3, uint64_t **a4)
{
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  dyld4::ExternallyViewableState::ensureSnapshot((uint64_t *)a1, a3);
  uint64_t v11 = a4[1];
  if (v11)
  {
    uint64_t v12 = *a4;
    uint64_t v13 = 8LL * (void)v11;
    do
    {
      uint64_t v14 = *v12++;
      dyld4::Atlas::ProcessSnapshot::removeImageAtAddress(*(dyld4::Atlas::ProcessSnapshot **)a1, v14, v9);
      v13 -= 8LL;
    }

    while (v13);
  }

  dyld4::ExternallyViewableState::commit((os_unfair_lock_s *)a1, *(dyld4::Atlas::ProcessSnapshot **)a1, a2, v10);
  uint64_t v15 = dyld4::ExternallyViewableState::release((os_unfair_lock_s *)a1, (lsl::Allocator *)a3);
  __chkstk_darwin((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22, v40);
  v43[0] = (const char **)((char *)&v41[-1] - ((v23 + 23) & 0xFFFFFFFFFFFFFFF0LL));
  v43[1] = v24;
  uint64_t v44 = 0LL;
  __chkstk_darwin(v25, v26, v27, v28, v29, v30, v31, v32, v40);
  v41[0] = (const mach_header **)((char *)&v41[-1] - v34);
  v41[1] = v33;
  uint64_t v42 = 0LL;
  uint64_t v35 = mach_absolute_time();
  dyld4::ExternallyViewableState::removeImagesOld(a1, (uint64_t *)v43, (uint64_t *)v41, (uint64_t)a4, v35);
  if (*(_DWORD *)(*(void *)(a1 + 24) + 200LL) == 1229016646 && v42 != 0)
  {
    if (!v44) {
      dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>();
    }
    dyld4::ExternallyViewableState::notifyMonitorOfImageListChanges( (dyld4::ExternallyViewableState *)a1,  1LL,  *((unsigned int *)a4 + 2),  v41[0],  v43[0],  v36,  v37,  v38);
  }

  os_unfair_lock_unlock(v8);
}

void dyld4::ExternallyViewableState::setSharedCacheInfo( uint64_t a1, lsl::Lock **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (dyld4::FileRecord::exists((dyld4::FileRecord *)v19))
  {
    uint64_t v10 = dyld4::Atlas::ProcessSnapshot::identityMapper(*(dyld4::Atlas::ProcessSnapshot **)a1);
    dyld4::Atlas::SharedCache::SharedCache(v14, a2, v19, v10, *(void *)(a4 + 24), a5);
    dyld4::Atlas::ProcessSnapshot::addSharedCache(*(void *)a1, (uint64_t)v14);
    if (v18) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v18, v11);
    }
    if (v16 && v17) {
      dyld4::Atlas::Mapper::unmap(v15[13], (unint64_t)v16, (uint64_t)v15[14]);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v15);
  }

  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(v12 + 152) = a3;
  uint64_t v13 = *(DyldSharedCache **)(a4 + 24);
  *(void *)(v12 + 176) = v13;
  *(_OWORD *)(v12 + 288) = *(_OWORD *)a4;
  *(_BYTE *)(v12 + 24) = a5;
  if (v13) {
    DyldSharedCache::getUUID(v13, (__n128 *)(v12 + 160));
  }
  dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v19);
}

os_unfair_lock_s *dyld4::ExternallyViewableState::release(os_unfair_lock_s *this, lsl::Allocator *a2)
{
  uint64_t v2 = *(void *)&this->_os_unfair_lock_opaque;
  if (*(void *)&this->_os_unfair_lock_opaque)
  {
    uint64_t v4 = this;
    uint64_t v5 = *(os_unfair_lock_s **)(v2 + 72);
    if (v5) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v5, a2);
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((os_unfair_lock_s **)(v2 + 64), a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)(v2 + 56), v6);
    uint64_t v7 = *(void *)(v2 + 16);
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate( v7,  *(lsl::Lock ***)(v2 + 24));
      *(void *)(v2 + 16) = 0LL;
    }

    *(void *)(v2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
    *(_BYTE *)(v2 + 48) = 0;
    this = lsl::Allocator::free((lsl::Lock **)a2, *(void **)&v4->_os_unfair_lock_opaque);
    *(void *)&v4->_os_unfair_lock_opaque = 0LL;
  }

  return this;
}

os_unfair_lock_s *dyld4::ExternallyViewableState::commit( os_unfair_lock_s *this, dyld4::Atlas::ProcessSnapshot *a2, lsl::Lock **a3, lsl::Allocator *a4)
{
  if (!a2) {
    return this;
  }
  uint64_t v5 = (uint64_t)this;
  dyld4::Atlas::ProcessSnapshot::serialize(a2, &v29);
  unint64_t v7 = (unint64_t)v30;
  unint64_t v6 = v31;
  uint64_t v8 = (unsigned __int128 *)(*(void *)(v5 + 24) + 304LL);
  uint64_t v9 = *(void **)v8;
  do
    __ldxp(v8);
  while (__stxp(__PAIR128__(v6, v7), v8));
  if (!v9) {
    goto LABEL_10;
  }
  if ((lsl::Allocator::owned((lsl::Allocator *)a3, (unint64_t)v9, 8LL) & 1) == 0)
  {
LABEL_9:
    unint64_t v6 = v31;
LABEL_10:
    uint64_t v9 = lsl::Allocator::malloc(a3, v6);
    goto LABEL_11;
  }

  unint64_t v10 = lsl::Allocator::size((lsl::Allocator *)a3, v9);
  unint64_t v17 = v31;
  if (v10 < v31)
  {
    if (lsl::Allocator::realloc(a3, v9, v31))
    {
LABEL_11:
      unint64_t v17 = v31;
      goto LABEL_12;
    }

    lsl::Allocator::free(a3, v9);
    goto LABEL_9;
  }

LABEL_12:
  if (v17)
  {
    memmove(v9, v30, v17);
    unint64_t v18 = v31;
  }

  else
  {
    unint64_t v18 = 0LL;
  }

  uint64_t v19 = (unsigned __int128 *)(*(void *)(v5 + 24) + 304LL);
  do
    __ldxp(v19);
  while (__stxp(__PAIR128__(v18, (unint64_t)v9), v19));
  int v21 = 520552496;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  uint64_t v28 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v21, v11, v17, v12, v13, v14, v15, v16);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder( (dyld4::RemoteNotificationResponder *)v20,  *(_DWORD *)(*(void *)(v5 + 24) + 200LL));
  dyld4::RemoteNotificationResponder::blockOnSynchronousEvent((dyld4::RemoteNotificationResponder *)v20, 0);
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v20);
  this = (os_unfair_lock_s *)dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v21);
  if (v30) {
    return lsl::Vector<std::byte>::resize((os_unfair_lock_s *)&v29, 0LL);
  }
  return this;
}

    unint64_t v7 = (_BYTE *)(*this)++;
    *unint64_t v7 = a2 / 0x64 + 48;
    LODWORD(a2) = a2 % 0x64;
LABEL_13:
    if (a2 < 0xA)
    {
      uint64_t v8 = (_BYTE *)(*this)++;
      *uint64_t v8 = 48;
      if (!(_DWORD)a2) {
        goto LABEL_6;
      }
      goto LABEL_17;
    }

    goto LABEL_16;
  }

  if (a2 >= 0xA)
  {
LABEL_16:
    uint64_t v9 = (_BYTE *)(*this)++;
    void *v9 = a2 / 0xA + 48;
    LODWORD(a2) = a2 % 0xA;
    if (!(_DWORD)a2) {
      goto LABEL_6;
    }
    goto LABEL_17;
  }

  if (!(_DWORD)a2)
  {
LABEL_6:
    uint64_t v2 = (_BYTE *)(*this)++;
    void *v2 = 48;
    return this;
  }

    unint64_t v18 = 0;
    goto LABEL_13;
  }

  uint64_t v11 = a3 + 8;
  uint64_t v12 = a3 + 32;
  *(void *)int v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *(void *)v10);
  *(void *)&void v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((void *)v10 + 1));
  uint64_t v13 = *((void *)v10 + 3);
  if (v13) {
    uint64_t v14 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v13);
  }
  else {
    uint64_t v14 = 0LL;
  }
  *(void *)&v21[16] = v14;
  *(void *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *((void *)v10 + 4)) & 0x7FFFFFFFFFF8LL;
  *(_OWORD *)__int128 v22 = *(_OWORD *)a2;
  *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
  unint64_t v17 = *((void *)v10 + 4);
  v21[36] = v17 & 1;
  v21[37] = (v17 & 2) != 0;
  if ((v17 & 3) == 0) {
    goto LABEL_12;
  }
  unint64_t v18 = v10[10];
LABEL_13:
  *(_DWORD *)&v21[32] = v18;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, v11, v12, v21);
}

    uint64_t v8 = __ldxr(v12);
    if (v8 == -1LL) {
      goto LABEL_19;
    }
  }

  __clrex();
  __dmb(9u);
  if (4LL * MEMORY[0xFFFFFC180] - v8 - 15 <= 0xFFFFFFFFFFFFFFEFLL) {
    uint64_t *v12 = -1LL;
  }
  return result;
}

  a1[5] |= 8uLL;
  if ((a2 & 0x8000000) == 0)
  {
LABEL_5:
    if ((a2 & 0x4000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }

uint64_t dyld4::ExternallyViewableState::disableCrashReportBacktrace(uint64_t this)
{
  *(void *)(*(void *)(this + 24) + 64LL) = 1LL;
  return this;
}

uint64_t dyld4::ExternallyViewableState::fork_child(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24);
  *(void *)(v1 + 72) = 0LL;
  *(void *)(v1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  return this;
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfMainCalled( dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v11 = 520552496;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  uint64_t v18 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder( (dyld4::RemoteNotificationResponder *)v10,  *(_DWORD *)(*((void *)this + 3) + 200LL));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10)) {
    dyld4::RemoteNotificationResponder::notifyMonitorOfMainCalled((dyld4::RemoteNotificationResponder *)v10);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

uint64_t dyld4::ExternallyViewableState::notifyMonitorOfDyldBeforeInitializers( dyld4::ExternallyViewableState *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v11 = 520552496;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  uint64_t v18 = 0LL;
  dyld3::ScopedTimer::startTimer((dyld3::ScopedTimer *)&v11, a2, a3, a4, a5, a6, a7, a8);
  dyld4::RemoteNotificationResponder::RemoteNotificationResponder( (dyld4::RemoteNotificationResponder *)v10,  *(_DWORD *)(*((void *)this + 3) + 200LL));
  if (dyld4::RemoteNotificationResponder::active((dyld4::RemoteNotificationResponder *)v10)) {
    dyld4::RemoteNotificationResponder::notifyMonitorOfDyldBeforeInitializers((dyld4::RemoteNotificationResponder *)v10);
  }
  dyld4::RemoteNotificationResponder::~RemoteNotificationResponder((dyld4::RemoteNotificationResponder *)v10);
  return dyld3::ScopedTimer::endTimer((dyld3::ScopedTimer *)&v11);
}

uint64_t dyld4::ExternallyViewableState::switchDyldLoadAddress(uint64_t result)
{
  *((void *)sProcessInfo + 4) = result;
  return result;
}

uint64_t dyld4::ExternallyViewableState::switchToDyldInDyldCache( dyld4::ExternallyViewableState *this, const dyld3::MachOFile *a2)
{
  mach_msg_type_number_t task_info_outCnt = 5;
  if (task_info(mach_task_self_, 0x11u, task_info_out, &task_info_outCnt)) {
    return 0LL;
  }
  uint64_t v3 = *(void *)task_info_out;
  if (proc_set_dyld_all_image_info(&dyld_all_image_infos, (void *)0x170))
  {
    sProcessInfo = (_UNKNOWN *)v3;
    uint64_t v4 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
    *(void *)(v3 + 32) = this;
    *(void *)(v3 + 192) = "/usr/lib/dyld";
    *(void *)(v3 + 16) = lldb_image_notifier;
    *(void *)(v3 + 48) = "cache";
    uint64_t v8 = this;
    uint64_t v9 = "/usr/lib/dyld";
    uint64_t v10 = 0LL;
    v4(3LL, 1LL, &v8);
    return 0LL;
  }

  if (*(_DWORD *)(v3 + 200)) {
    dword_18C435E48 = *(_DWORD *)(v3 + 200);
  }
  unint64_t v7 = *(void (**)(uint64_t, uint64_t, dyld4::ExternallyViewableState **))(v3 + 16);
  uint64_t v8 = this;
  uint64_t v9 = "/usr/lib/dyld";
  uint64_t v10 = 0LL;
  uint64_t v5 = 1LL;
  v7(3LL, 1LL, &v8);
  return v5;
}

uint64_t dyld4::ExternallyViewableState::storeProcessInfoPointer(uint64_t this, dyld_all_image_infos **a2)
{
  *a2 = *(dyld_all_image_infos **)(this + 24);
  return this;
}

uint64_t *lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  if (v3)
  {
    if (*(void *)(v3 + 8))
    {
      lsl::Allocator::freeObject(*(os_unfair_lock_s **)(v3 + 8), a2);
      uint64_t v3 = *a1;
    }

    lsl::Allocator::freeObject((os_unfair_lock_s *)v3, a2);
  }

  return a1;
}

os_unfair_lock_s *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate( uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    uint64_t v4 = (uint64_t *)(a1 + 120);
    uint64_t v5 = 8LL * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate( v6,  a2);
      v5 -= 8LL;
    }

    while (v5);
  }

  unint64_t v7 = 0LL;
  uint64_t v8 = (os_unfair_lock_s **)a1;
  do
  {
    uint64_t v9 = lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(v8);
    ++v7;
    else {
      unint64_t v10 = 31LL;
    }
    uint64_t v8 = v9 + 1;
  }

  while (v7 < v10);
  return lsl::Allocator::free(a2, (void *)a1);
}

os_unfair_lock_s **lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(os_unfair_lock_s **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v2[28]);
    uint64_t v4 = *(os_unfair_lock_s **)&v2[22]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, v3);
    }
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)&v2[2]);
    lsl::Allocator::freeObject(*a1, v5);
  }

  return a1;
}

os_unfair_lock_s **lsl::UniquePtr<dyld4::Atlas::ProcessSnapshot>::~UniquePtr( os_unfair_lock_s **a1, void *a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(os_unfair_lock_s **)&v3[18]._os_unfair_lock_opaque;
    if (v4) {
      lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v4, a2);
    }
    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((os_unfair_lock_s **)&v3[16], a2);
    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v3[14], v5);
    uint64_t v7 = *(void *)&v3[4]._os_unfair_lock_opaque;
    if (v7)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate( v7,  *(lsl::Lock ***)&v3[6]._os_unfair_lock_opaque);
      *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
    }

    *(void *)&v3[10]._os_unfair_lock_opaque = 0LL;
    LOBYTE(v3[12]._os_unfair_lock_opaque) = 0;
    lsl::Allocator::freeObject(*a1, v6);
  }

  return a1;
}

os_unfair_lock_s *lsl::Vector<std::byte>::resize(os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<std::byte>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  a2);
  }

  else
  {
    uint64_t v3 = result + 2;
    uint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return 0;
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  uint64_t v8 = (vm_address_t *)_simple_salloc();
  LODWORD(a4) = _simple_vsprintf((uint64_t)v8, (char *)__format, (int *)a4);
  uint64_t v9 = (const char *)_simple_string((_BYTE **)v8);
  strlcpy(__str, v9, __size);
  _simple_sfree(v8);
  return (int)a4;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return write(2, __ptr, __nitems * __size);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return vsnprintf(__str, __size, __format, va);
}

uint64_t __guard_setup(void *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v2 = a1;
    uint64_t v3 = __stack_chk_guard;
    while (1)
    {
      uint64_t result = _platform_strncmp((const char *)v1, "stack_guard=", 0xCuLL);
      if (!(_DWORD)result)
      {
        char v5 = *(_BYTE *)(v1 + 12);
        if (v5)
        {
          uint64_t v6 = (unsigned __int8 *)(v1 + 13);
          do
          {
            int v7 = v5;
            unsigned int v8 = (v5 - 97);
            unsigned int v9 = v7 - 48;
            else {
              unsigned int v10 = v9;
            }
            unsigned int v11 = v7 - 87;
            if (v8 <= 5) {
              uint64_t v12 = v11;
            }
            else {
              uint64_t v12 = v10;
            }
            uint64_t v3 = v12 | (16 * v3);
            __stack_chk_guard = v3;
            int v13 = *v6++;
            char v5 = v13;
          }

          while (v13);
        }

        if (v3) {
          break;
        }
      }

      uint64_t v14 = v2[1];
      ++v2;
      uint64_t v1 = v14;
      if (!v14) {
        goto LABEL_17;
      }
    }
  }

  else
  {
LABEL_17:
    uint64_t v15 = arc4random();
    uint64_t result = arc4random();
    __stack_chk_guard = result | (unint64_t)(v15 << 32);
  }

  return result;
}

void _Block_object_dispose(const void *a1, const int a2)
{
  if (a2 != 8) {
    dyld4::halt("_Block_object_dispose()", 0LL);
  }
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  if (!__s) {
    return 22;
  }
  if (__n >= __smax) {
    size_t v4 = __smax;
  }
  else {
    size_t v4 = __n;
  }
  if (__n <= __smax) {
    errno_t v5 = 0;
  }
  else {
    errno_t v5 = 84;
  }
  _platform_memset(__s, __c, v4);
  return v5;
}

__int32 *__cdecl wmemchr(__int32 *result, __int32 a2, size_t a3)
{
  if (!a3) {
    return 0LL;
  }
  while (*result != a2)
  {
    ++result;
    if (!--a3) {
      return 0LL;
    }
  }

  return result;
}

uint64_t mach_o::DebugNoteFileInfo::dump(const char **this)
{
  if (this[8]) {
    uint64_t v2 = this[7];
  }
  else {
    uint64_t v2 = "N/A";
  }
  fprintf(__stdoutp, "libPath:     %s\n", v2);
  if (this[10]) {
    uint64_t v3 = this[9];
  }
  else {
    uint64_t v3 = "N/A";
  }
  return fprintf(__stdoutp, "origlibPath: %s\n", v3);
}

uint64_t dyld4::Atlas::Bitmap::Bitmap(uint64_t a1, lsl::Lock **a2, uint64_t a3)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  uint64_t PVLEUInt64 = lsl::readPVLEUInt64((unsigned __int8 **)a3);
  *(void *)a1 = PVLEUInt64;
  unint64_t v7 = PVLEUInt64 + 7;
  unint64_t v8 = (unint64_t)(PVLEUInt64 + 7) >> 3;
  unsigned int v10 = lsl::Allocator::malloc(a2, v8);
  unsigned int v11 = *(os_unfair_lock_s **)(a1 + 8);
  *(void *)(a1 + 8) = v10;
  if (v11) {
    lsl::Allocator::freeObject(v11, v9);
  }
  if (v7 >= 8) {
    memmove(*(void **)(a1 + 8), *(const void **)a3, v8);
  }
  unint64_t v12 = *(void *)(a3 + 8) - v8;
  *(void *)a3 += v8;
  *(void *)(a3 + 8) = v12;
  return a1;
}

char *dyld4::Atlas::Bitmap::emit(uint64_t a1, uint64_t a2)
{
  return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( (uint64_t)&v5,  *(char **)(a1 + 8),  (char *)(*(void *)(a1 + 8) + ((unint64_t)(*(void *)a1 + 7LL) >> 3)),  a2);
}

void *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>@<X0>( lsl::Lock **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  unint64_t v7 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  unint64_t v8 = lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(v7, a3, a2);
  void v8[4] = 0LL;
  v8[5] = a2;
  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a4, v7);
}

void dyld4::Atlas::Mapper::mapperForMachO( lsl::Lock **this@<X0>, lsl::Allocator *a2@<X1>, dyld4::FileRecord *a3@<X2>, const UUID *a4@<X3>, void *a5@<X8>)
{
  Path = (dyld3 *)dyld4::FileRecord::getPath(a2);
  int v11 = dyld3::open(Path, 0LL, 0LL);
  if (v11 == -1) {
    goto LABEL_20;
  }
  int v12 = v11;
  if (fstat64(v11, &v37) == -1 || (int v13 = mmap(0LL, v37.st_size, 1, 8194, v12, 0LL), v13 == (_DWORD *)-1LL))
  {
    int v11 = v12;
LABEL_20:
    close(v11);
    *a5 = 0LL;
    return;
  }

  uint64_t v15 = v13;
  uint64_t v33 = 0LL;
  uint64_t v34 = &v33;
  uint64_t v35 = 0x2000000000LL;
  uint64_t v36 = 0LL;
  __int128 v16 = (dyld3::FatFile *)dyld3::FatFile::isFatFile(v13, v14);
  v32[0] = 0LL;
  v32[1] = v32;
  uint64_t v32[2] = 0x2000000000LL;
  v32[3] = 0LL;
  uint64_t v18 = (_BYTE *)(&loc_1800B6FFC + 4);
  if (v16)
  {
    uint64_t v19 = v16;
    st_vm_size_t size = v37.st_size;
    Diagnostics::Diagnostics((Diagnostics *)&v41);
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 0x40000000LL;
    _OWORD v31[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke;
    v31[3] = &unk_189621368;
    v31[4] = &v33;
    v31[5] = v32;
    v31[6] = a3;
    v31[7] = v19;
    unint64_t v21 = st_size;
    uint64_t v18 = (char *)&loc_1800B6FFC + 4;
    dyld3::FatFile::forEachSlice(v19, (vm_address_t *)&v41, v21, (uint64_t)v31);
    Diagnostics::clearError((vm_address_t **)&v41);
    mach_o::Error::~Error((vm_address_t **)&v41);
  }

  if (!v34[3])
  {
    __int128 v22 = (dyld3::MachOFile *)dyld3::MachOFile::isMachO(v15, v17);
    if (v22)
    {
      __int128 v23 = v22;
      dyld3::MachOFile::getUuid(v22, (unsigned __int8 *)&v41);
      uint64_t v24 = 0LL;
      __int128 v38 = v41;
      do
      {
        int v25 = *((unsigned __int8 *)a3 + v24);
        int v26 = *((unsigned __int8 *)&v38 + v24);
      }

      while (v25 == v26 && v24++ != 15);
      if (v25 == v26) {
        v34[3] = (uint64_t)v23;
      }
    }
  }

  uint64_t v28 = (_DWORD *)v34[3];
  if (v28)
  {
    *(void *)&__int128 v41 = 0LL;
    *((void *)&v41 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = &v41;
    uint64_t v42 = 0x4802000000LL;
    uint64_t v43 = __Block_byref_object_copy__9;
    uint64_t v44 = __Block_byref_object_dispose__9;
    uint64_t v45 = this;
    uint64_t v46 = 0LL;
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    *(void *)&__int128 v38 = 0LL;
    *((void *)&v38 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = &v38;
    uint64_t v39 = 0x2000000000LL;
    uint64_t v40 = 0LL;
    v29[0] = _NSConcreteStackBlock;
    v29[1] = *((void *)v18 + 351);
    _OWORD v29[2] = ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3;
    v29[3] = &unk_189621390;
    v29[4] = &v38;
    v29[5] = &v41;
    v29[6] = v32;
    v29[7] = a4;
    int v30 = v12;
    dyld3::MachOFile::forEachSegment(v28, (uint64_t)v29);
    munmap(v15, v37.st_size);
    lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&,lsl::Vector<dyld4::Atlas::Mapper::Mapping> &>( this,  (uint64_t)this,  *((void *)&v41 + 1) + 40LL,  a5);
    _Block_object_dispose(&v38, 8);
    _Block_object_dispose(&v41, 8);
    if (v46) {
      lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((os_unfair_lock_s *)&v45, 0LL);
    }
  }

  else
  {
    munmap(v15, v37.st_size);
    close(v12);
    *a5 = 0LL;
  }

  _Block_object_dispose(v32, 8);
  _Block_object_dispose(&v33, 8);
}

BOOL ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke( void *a1, int a2, int a3, dyld3::MachOFile *this, uint64_t a5, _BYTE *a6)
{
  BOOL result = dyld3::MachOFile::getUuid(this, v15);
  uint64_t v10 = 0LL;
  __int128 v14 = *(_OWORD *)v15;
  do
  {
    int v11 = *(unsigned __int8 *)(a1[6] + v10);
    int v12 = v15[v10 - 8];
  }

  while (v11 == v12 && v10++ != 15);
  if (v11 == v12)
  {
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = this;
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = (char *)this - a1[7];
    *a6 = 1;
  }

  return result;
}

uint64_t *__Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 40);
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  BOOL result = (uint64_t *)(a1 + 40);
  *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  if (result != v2)
  {
    uint64_t v4 = *result;
    *BOOL result = *v2;
    uint64_t *v2 = v4;
    uint64_t v6 = result[1];
    uint64_t v5 = result[2];
    uint64_t v7 = v2[2];
    result[1] = v2[1];
    result[2] = v7;
    v2[2] = v5;
    uint64_t v8 = result[3];
    result[3] = v2[3];
    v2[3] = v8;
    v2[1] = v6;
  }

  return result;
}

os_unfair_lock_s *__Block_byref_object_dispose__9(os_unfair_lock_s *result)
{
  if (*(void *)&result[12]._os_unfair_lock_opaque) {
    return lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize(result + 10, 0LL);
  }
  return result;
}

uint64_t ___ZN5dyld45Atlas6Mapper14mapperForMachOERN3lsl9AllocatorERNS_10FileRecordERKNS2_4UUIDEPKv_block_invoke_3( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) + *(void *)a2;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) + *(void *)(a2 + 16);
  int v8 = *(_DWORD *)(a1 + 64);
  uint64_t result = lsl::Vector<dyld4::ObjCClassReplacement>::reserve(v4 + 40, *(void *)(v4 + 56) + 1LL);
  uint64_t v10 = *(void *)(v4 + 48) + 32LL * *(void *)(v4 + 56);
  *(void *)uint64_t v10 = v5;
  *(void *)(v10 + 8) = v6;
  *(void *)(v10 + 16) = v7;
  *(_DWORD *)(v10 + 24) = v8;
  ++*(void *)(v4 + 56);
  return result;
}

void dyld4::Atlas::Mapper::~Mapper(dyld4::Atlas::Mapper *this)
{
  if (*((void *)this + 4)) {
    dyld4::Atlas::Mapper::~Mapper();
  }
  uint64_t v15 = *((void *)this + 5);
  __int128 v16 = 0LL;
  size_t v17 = 0LL;
  uint64_t v18 = 0LL;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    size_t v4 = 0LL;
    uint64_t v5 = 0LL;
    uint64_t v6 = 32 * v3;
    uint64_t v7 = (__int32 *)(v2 + 24);
    do
    {
      if (*v7 != -1)
      {
        int v8 = (__int32 *)&v5[v4];
        unsigned int v9 = wmemchr(v5, *v7, v4);
        uint64_t v10 = v9 ? v9 : v8;
        uint64_t v5 = v16;
        size_t v4 = v17;
        if (v10 == &v16[v17])
        {
          lsl::Vector<unsigned int>::reserve((uint64_t)&v15, v17 + 1);
          __int32 v11 = *v7;
          uint64_t v5 = v16;
          size_t v12 = v17;
          size_t v4 = ++v17;
          v16[v12] = v11;
        }
      }

      v7 += 8;
      v6 -= 32LL;
    }

    while (v6);
    if (v4)
    {
      uint64_t v13 = 4 * v4;
      do
      {
        int v14 = *v5++;
        close(v14);
        v13 -= 4LL;
      }

      while (v13);
      uint64_t v5 = v16;
    }

    if (v5) {
      lsl::Vector<unsigned int>::resize((os_unfair_lock_s *)&v15, 0LL);
    }
    uint64_t v2 = *((void *)this + 1);
  }

  if (v2) {
    lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize((os_unfair_lock_s *)this, 0LL);
  }
}

char *dyld4::Atlas::Mapper::map(dyld4::Atlas::Mapper *this, char *a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    return &a2[v3 - *(void *)(*((void *)this + 1) + 16LL)];
  }
  uint64_t v5 = *((void *)this + 2);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 1);
    uint64_t v7 = 32 * v5;
    while (1)
    {
      unint64_t v8 = *(void *)(v6 + 16);
      if (v8 <= (unint64_t)a2)
      {
        unint64_t v9 = *(void *)(v6 + 8) + v8;
      }

      v6 += 32LL;
      v7 -= 32LL;
      if (!v7) {
        return 0LL;
      }
    }

    int v10 = *(_DWORD *)(v6 + 24);
    if (v10 == -1)
    {
      return &a2[*(void *)v6 - v8];
    }

    else
    {
      unint64_t v11 = (unint64_t)&a2[*(void *)v6 - v8];
      off_t v12 = v11 & -(uint64_t)vm_page_size;
      uint64_t v13 = (char *)(v11 - v12);
      int v14 = (char *)mmap(0LL, v11 - v12 + a3, 1, 2, v10, v12);
      else {
        return &v14[(void)v13];
      }
    }
  }

  return a2;
}

uint64_t dyld4::Atlas::Mapper::unmap(dyld4::Atlas::Mapper *this, unint64_t a2, uint64_t a3)
{
  return munmap((void *)(-(uint64_t)vm_page_size & a2), a2 + a3 - (-(uint64_t)vm_page_size & a2));
}

uint64_t dyld4::Atlas::Image::Image( uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, unsigned int **a4, uint64_t a5)
{
  *(void *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  unint64_t v8 = *a4;
  *(void *)(a1 + 88) = *a4;
  if (v8)
  {
    do
      unsigned int v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 16dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a5;
  *(_DWORD *)(a1 + 183) = 0;
  return a1;
}

void dyld4::Atlas::Image::swap(dyld4::Atlas::Image *this, dyld4::Atlas::Image *a2)
{
  if (this != a2)
  {
    __int128 v4 = *((_OWORD *)this + 6);
    *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
    *((_OWORD *)a2 + 6) = v4;
    dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap((uint64_t *)this + 14, (uint64_t *)a2 + 14);
    std::optional<unsigned long long>::swap[abi:nn180100]((uint64_t *)this + 18, (uint64_t *)a2 + 18);
    uint64_t v5 = *((void *)this + 20);
    *((void *)this + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *((void *)a2 + 20);
    *((void *)a2 + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v5;
    uint64_t v6 = *((void *)this + 11);
    *((void *)this + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = *((void *)a2 + 11);
    *((void *)a2 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v6;
    uint64_t v7 = *((void *)this + 21);
    *((void *)this + 2dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = *((void *)a2 + 21);
    *((void *)a2 + 2dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v7;
    uint64_t v8 = *((void *)this + 22);
    *((void *)this + 22) = *((void *)a2 + 22);
    *((void *)a2 + 22) = v8;
    dyld4::FileRecord::swap((dyld4::Atlas::Image *)((char *)this + 8), (dyld4::Atlas::Image *)((char *)a2 + 8));
    char v9 = *((_BYTE *)this + 184);
    *((_BYTE *)this + 184) = *((_BYTE *)a2 + 184);
    *((_BYTE *)a2 + 184) = v9;
    char v10 = *((_BYTE *)this + 185);
    *((_BYTE *)this + 185) = *((_BYTE *)a2 + 185);
    *((_BYTE *)a2 + 185) = v10;
    char v11 = *((_BYTE *)this + 186);
    *((_BYTE *)this + 186) = *((_BYTE *)a2 + 186);
    *((_BYTE *)a2 + 186) = v11;
  }

_DWORD *dyld4::Atlas::Image::ml(dyld4::Atlas::Image *this)
{
  if (*((_BYTE *)this + 186)) {
    return 0LL;
  }
  uint64_t result = (_DWORD *)*((void *)this + 16);
  if (result) {
    return result;
  }
  __int128 v4 = (__int128 *)((char *)this + 88);
  uint64_t v3 = (os_unfair_lock_s *)*((void *)this + 11);
  uint64_t v5 = (char *)*((void *)this + 20);
  if (!v3 || !*(void *)&v3[2]._os_unfair_lock_opaque)
  {
    dyld4::Atlas::Mapper::mapperForMachO( *(lsl::Lock ***)this,  (dyld4::Atlas::Image *)((char *)this + 8),  (dyld4::Atlas::Image *)((char *)this + 96),  *((const UUID **)this + 20),  &v19);
    if (&v19 == v4)
    {
      uint64_t v7 = (os_unfair_lock_s *)v19;
      if (!(void)v19)
      {
LABEL_9:
        uint64_t v3 = *(os_unfair_lock_s **)v4;
        if (!*(void *)v4)
        {
LABEL_25:
          uint64_t result = 0LL;
          *((_BYTE *)this + 186) = 1;
          return result;
        }

        goto LABEL_10;
      }
    }

    else
    {
      uint64_t v7 = *(os_unfair_lock_s **)v4;
      *(void *)__int128 v4 = v19;
      *(void *)&__int128 v19 = v7;
      if (!v7) {
        goto LABEL_9;
      }
    }

    lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v7, v6);
    goto LABEL_9;
  }

uint64_t dyld4::Atlas::Image::uuid(dyld4::Atlas::Image *this)
{
  if (!*((_BYTE *)this + 184))
  {
    uint64_t v2 = (dyld3::MachOFile *)dyld4::Atlas::Image::ml(this);
    if (v2)
    {
      uint64_t v3 = v2;
      if (dyld3::MachOFile::hasMachOMagic(v2) && dyld3::MachOFile::getUuid(v3, v5)) {
        *((_OWORD *)this + 6) = *(_OWORD *)v5;
      }
    }

    *((_BYTE *)this + 184) = 1;
  }

  return (uint64_t)this + 96;
}

uint64_t dyld4::Atlas::Image::file(dyld4::Atlas::Image *this)
{
  return (uint64_t)this + 8;
}

uint64_t dyld4::Atlas::SharedCache::SharedCache( uint64_t a1, uint64_t a2, dyld4::FileRecord *a3, unsigned int **a4, char *a5, char a6)
{
  *(void *)a1 = a2;
  dyld4::FileRecord::FileRecord(a1 + 8, a3);
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  char v10 = (__int128 *)(a1 + 112);
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *(void *)(a1 + 128) = 0LL;
  *(_BYTE *)(a1 + 136) = 0;
  char v11 = *a4;
  *(void *)(a1 + 144) = *a4;
  if (!v11)
  {
    *(void *)(a1 + 152) = 0LL;
    *(void *)(a1 + 16dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a5;
    *(_BYTE *)(a1 + 168) = a6;
    goto LABEL_52;
  }

  do
    unsigned int v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  uint64_t v13 = *(void *)(a1 + 144);
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 16dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a5;
  *(_BYTE *)(a1 + 168) = a6;
  if (!v13 || (uint64_t v14 = *(dyld4::Atlas::Mapper **)(v13 + 8)) == 0LL) {
LABEL_52:
  }
    dyld4::Atlas::SharedCache::SharedCache();
  vm_size_t v15 = vm_page_size;
  *(void *)&__int128 v57 = *(void *)(v13 + 8);
  *((void *)&v57 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = vm_page_size;
  __int128 v16 = dyld4::Atlas::Mapper::map(v14, a5, vm_page_size);
  uint64_t v58 = v16;
  char v59 = v17;
  if (v10 != &v57)
  {
    __int128 v57 = *(_OWORD *)(a1 + 112);
    *(void *)(a1 + 112) = v14;
    *(void *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v15;
    uint64_t v18 = *(char **)(a1 + 128);
    *(void *)(a1 + 128) = v16;
    uint64_t v58 = v18;
    LOBYTE(v18) = *(_BYTE *)(a1 + 136);
    *(_BYTE *)(a1 + 136) = v17;
    char v59 = (char)v18;
  }

  dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
  uint64_t v19 = *(void *)(a1 + 128);
  unsigned int v20 = *(_DWORD *)(v19 + 16);
  if (v20 >= 0x18C) {
    vm_size_t v21 = *(unsigned int *)(v19 + 392) + 56LL * *(unsigned int *)(v19 + 396);
  }
  else {
    vm_size_t v21 = *(unsigned int *)(v19 + 24) + 32LL * *(unsigned int *)(v19 + 28);
  }
  if (v21 > vm_page_size)
  {
    uint64_t v22 = *(void *)(a1 + 144);
    if (v22) {
      __int128 v23 = *(dyld4::Atlas::Mapper **)(v22 + 8);
    }
    else {
      __int128 v23 = 0LL;
    }
    uint64_t v24 = *(char **)(a1 + 160);
    *(void *)&__int128 v57 = v23;
    *((void *)&v57 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v21;
    int v25 = dyld4::Atlas::Mapper::map(v23, v24, v21);
    uint64_t v58 = v25;
    char v59 = v26;
    if (v10 != &v57)
    {
      __int128 v57 = *(_OWORD *)(a1 + 112);
      *(void *)(a1 + 112) = v23;
      *(void *)(a1 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v21;
      __int128 v27 = *(char **)(a1 + 128);
      *(void *)(a1 + 128) = v25;
      uint64_t v58 = v27;
      LOBYTE(v27) = *(_BYTE *)(a1 + 136);
      *(_BYTE *)(a1 + 136) = v26;
      char v59 = (char)v27;
    }

    dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
    uint64_t v19 = *(void *)(a1 + 128);
  }

  *(_OWORD *)(a1 + 88) = *(_OWORD *)(v19 + 88);
  uint64_t v28 = *(void *)(v19 + 224);
  *(void *)(a1 + 152) = *(void *)(a1 + 160) - v28;
  if (*(_DWORD *)(v19 + 16) < 0x18Cu)
  {
    uint64_t v30 = *(unsigned int *)(v19 + 316);
    if ((_DWORD)v30)
    {
      unint64_t v31 = 0LL;
      uint64_t v32 = (void *)(*(unsigned int *)(v19 + 312) + v19 + 8);
      do
      {
        if (v31 <= *v32 + *(v32 - 1)) {
          unint64_t v31 = *v32 + *(v32 - 1);
        }
        v32 += 7;
        --v30;
      }

      while (v30);
    }

    else
    {
      unint64_t v31 = 0LL;
    }

    if (v20 >= 0x18C && *(_DWORD *)(v19 + 396))
    {
      unint64_t v33 = 0LL;
      uint64_t v34 = v19;
      do
      {
        unsigned int v35 = *(_DWORD *)(v34 + 16);
        uint64_t v36 = v19 + *(unsigned int *)(v34 + 392);
        uint64_t v37 = v36 + 24 * v33 + 16;
        __int128 v38 = (void *)(v36 + 56 * v33 + 16);
        if (v35 < 0x1C9) {
          __int128 v38 = (void *)v37;
        }
        uint64_t v39 = *(void *)(a1 + 144);
        if (v39) {
          uint64_t v40 = *(dyld4::Atlas::Mapper **)(v39 + 8);
        }
        else {
          uint64_t v40 = 0LL;
        }
        __int128 v41 = &a5[*v38];
        *(void *)&__int128 v57 = v40;
        *((void *)&v57 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = vm_page_size;
        uint64_t v42 = dyld4::Atlas::Mapper::map(v40, v41, vm_page_size);
        uint64_t v58 = v42;
        char v59 = v43;
        if (*((_DWORD *)v42 + 4) < 0x18Cu) {
          vm_size_t v44 = *((unsigned int *)v42 + 6) + 32LL * *((unsigned int *)v42 + 7);
        }
        else {
          vm_size_t v44 = *((unsigned int *)v42 + 98) + 56LL * *((unsigned int *)v42 + 99);
        }
        if (v44 > vm_page_size)
        {
          uint64_t v45 = *(void *)(a1 + 144);
          if (v45) {
            uint64_t v46 = *(dyld4::Atlas::Mapper **)(v45 + 8);
          }
          else {
            uint64_t v46 = 0LL;
          }
          *(void *)&__int128 v54 = v46;
          *((void *)&v54 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v44;
          uint64_t v47 = dyld4::Atlas::Mapper::map(v46, v41, v44);
          __int128 v48 = v54;
          __int128 v54 = v57;
          __int128 v57 = v48;
          uint64_t v49 = v58;
          uint64_t v58 = v47;
          uint64_t v55 = v49;
          LOBYTE(v49) = v59;
          char v59 = v50;
          char v56 = (char)v49;
          dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v54);
          uint64_t v42 = v58;
        }

        uint64_t v51 = *((unsigned int *)v42 + 79);
        if ((_DWORD)v51)
        {
          uint64_t v52 = &v42[*((unsigned int *)v42 + 78) + 8];
          do
          {
            if (v31 <= *(void *)v52 + *((void *)v52 - 1)) {
              unint64_t v31 = *(void *)v52 + *((void *)v52 - 1);
            }
            v52 += 56;
            --v51;
          }

          while (v51);
        }

        dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)&v57);
        ++v33;
        uint64_t v34 = *(void *)(a1 + 128);
      }

      while (v33 < *(unsigned int *)(v34 + 396));
      uint64_t v28 = *(void *)(v34 + 224);
    }

    uint64_t v29 = v31 - v28;
  }

  else
  {
    uint64_t v29 = *(void *)(v19 + 232);
  }

  *(void *)(a1 + 104) = v29;
  return a1;
}

double lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert@<D0>( uint64_t *a1@<X0>, char **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v8 = *a2;
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, &v8);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, &v8, (uint64_t)&v9);
  uint64_t v5 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  char v7 = v17;
  *(void *)a3 = v5;
  *(_BYTE *)(a3 + 98) = v7;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

{
  uint64_t v6;
  double result;
  char v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  char v18;
  _BYTE v19[104];
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator((uint64_t)v19, a1, a2);
  lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal((uint64_t)a1, (uint64_t)v19, a2, (uint64_t)&v9);
  uint64_t v6 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  uint64_t v8 = v17;
  *(void *)a3 = v6;
  *(_BYTE *)(a3 + 98) = v8;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

dyld4::Atlas::ProcessSnapshot *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot( dyld4::Atlas::ProcessSnapshot *this, lsl::Lock **a2, dyld4::FileManager *a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = a3;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = a2;
  *((void *)this + 5) = 0LL;
  *((_BYTE *)this + 48) = 0;
  char v7 = (void *)((char *)this + 72);
  *((void *)this + 7) = 0LL;
  *((void *)this + 8) = 0LL;
  uint64_t v8 = lsl::Allocator::aligned_alloc(a2, 8uLL, 0x30uLL);
  *uint64_t v8 = a2;
  *(_OWORD *)(v8 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  *(_OWORD *)(v8 + 3) = 0u;
  v8[5] = a2;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v7, (lsl::Allocator::AllocationMetadata *)v8);
  *((void *)this + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *((void *)this + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
  *((void *)this + 12) = 0LL;
  *((_BYTE *)this + 104) = a4;
  *((_BYTE *)this + 105) = 1;
  return this;
}

void *lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>@<X0>( lsl::Lock **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0x30uLL);
  *uint64_t v5 = a2;
  *(_OWORD *)(v5 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  void v5[5] = a2;
  return lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(a3, (lsl::Allocator::AllocationMetadata *)v5);
}

__int128 *dyld4::Atlas::ProcessSnapshot::ProcessSnapshot( __int128 *a1, lsl::Lock **this, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = this;
  *((void *)a1 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = a3;
  *((void *)a1 + 2) = 0LL;
  __int128 v11 = (uint64_t *)(a1 + 1);
  *((void *)a1 + 3) = this;
  *((void *)a1 + 5) = 0LL;
  *((_BYTE *)a1 + 48) = 0;
  *((void *)a1 + 7) = 0LL;
  __int128 v12 = (os_unfair_lock_s **)a1 + 7;
  __int128 v13 = (void *)a1 + 9;
  *((void *)a1 + 8) = 0LL;
  __int128 v14 = (os_unfair_lock_s **)(a1 + 4);
  uint64_t v15 = lsl::Allocator::aligned_alloc(this, 8uLL, 0x30uLL);
  *uint64_t v15 = this;
  *(_OWORD *)(v15 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  *(_OWORD *)(v15 + 3) = 0u;
  void v15[5] = this;
  lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v13, (lsl::Allocator::AllocationMetadata *)v15);
  *((void *)a1 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  *((void *)a1 + 12) = 0LL;
  *((void *)a1 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
  *((_BYTE *)a1 + 104) = a4;
  *((_BYTE *)a1 + 105) = 1;
  uint64_t v22 = a1;
  __int128 v23 = *a1;
  uint64_t v24 = v11;
  int v25 = v14;
  char v26 = v12;
  uint64_t v27 = v23;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v31 = v23;
  uint64_t v33 = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v35 = v23;
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v36 = 0LL;
  uint64_t v39 = v23;
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  int v43 = -1491447450;
  uint64_t v45 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t v46 = 0LL;
  uint64_t v47 = 0LL;
  uint64_t v48 = 0LL;
  uint64_t v49 = a1 + 5;
  uint64_t v50 = (uint64_t)a1 + 88;
  uint64_t v51 = a1 + 6;
  if ((dyld4::Atlas::ProcessSnapshot::Serializer::deserialize((uint64_t)&v22, a5, a6) & 1) == 0)
  {
    if (*v11)
    {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::deallocate( *v11,  *((lsl::Lock ***)a1 + 3));
      *((void *)a1 + 2) = 0LL;
    }

    *((void *)a1 + 5) = 0LL;
    *((_BYTE *)a1 + 48) = 0;
    vm_size_t v21 = 0LL;
    if (&v21 != v12)
    {
      char v17 = *v12;
      uint64_t *v12 = 0LL;
      vm_size_t v21 = v17;
    }

    lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v21, v16);
    vm_size_t v21 = 0LL;
    if (&v21 != v14)
    {
      uint64_t v19 = *v14;
      dyld4::Atlas::Mapper *v14 = 0LL;
      vm_size_t v21 = v19;
    }

    lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v21, v18);
    *((_BYTE *)a1 + 105) = 0;
    *((void *)a1 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
    *((void *)a1 + 12) = 0LL;
    *((void *)a1 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
  }

  if (v40) {
    lsl::Vector<unsigned int>::resize((os_unfair_lock_s *)&v39, 0LL);
  }
  if (v36) {
    lsl::Vector<std::byte>::resize((os_unfair_lock_s *)&v35, 0LL);
  }
  if (v32) {
    lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v31, 0LL);
  }
  if (v28) {
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((os_unfair_lock_s *)&v27, 0LL);
  }
  return a1;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::deserialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  unsigned int v4 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)a2;
  unsigned int v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 18dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v5;
  *(void *)(a1 + 184) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 208) = *(_DWORD *)(a2 + 20);
  *(void *)(a1 + 20dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 24);
  int v6 = *(_DWORD *)(a2 + 32);
  uint64_t v7 = a3 - 36;
  uint64_t v8 = a2 + 36;
  uint64_t v51 = (char *)(a2 + 36);
  uint64_t v52 = a3 - 36;
  *(_DWORD *)(a1 + 212) = v6;
  if (__PAIR64__(v5, v4) != 2803519846) {
    return v3;
  }
  uint64_t v9 = a2;
  lsl::CRC32c::CRC32c((uint64_t)v50);
  lsl::CRC32c::operator()(v50, v9, 32LL);
  lsl::CRC32c::operator()(v50, 0LL);
  lsl::CRC32c::operator()(v50, v8, v7);
  LODWORD(v9) = *(_DWORD *)(a1 + 212);
  uint64_t v3 = 0LL;
  *(void *)(a1 + 216) = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  **(void **)(a1 + 224) = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  **(void **)(a1 + 232) = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  **(void **)(a1 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  uint64_t PVLEUInt64 = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  uint64_t v12 = PVLEUInt64;
  if (PVLEUInt64)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = PVLEUInt64;
    do
    {
      v54[0] = *(_OWORD *)&v51[v13];
      lsl::Vector<dyld4::InterposeTupleAll>::reserve(a1 + 48, *(void *)(a1 + 64) + 1LL);
      uint64_t v15 = *(void *)(a1 + 56);
      uint64_t v16 = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = v16 + 1;
      *(_OWORD *)(v15 + 16 * v16) = v54[0];
      v13 += 16LL;
      --v14;
    }

    while (v14);
  }

  v51 += 16 * v12;
  v52 -= 16 * v12;
  unint64_t v17 = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  lsl::Vector<std::byte>::reserve(a1 + 112, v17);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>( (uint64_t)v54,  v51,  &v51[v17],  a1 + 112);
  v51 += v17;
  v52 -= v17;
  if ((*(_BYTE *)(a1 + 216) & 1) != 0)
  {
    v53[0] = 0uLL;
    memset(v54, 0, sizeof(v54));
    uint64_t v55 = 0x1FFFFFFFFLL;
    __int16 v56 = 0;
    char v57 = 1;
    if ((dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo( a1,  (unsigned __int8 **)&v51,  (uint64_t *)v64,  v53,  (dyld4::FileRecord *)v54) & 1) != 0)
    {
      char v32 = 14;
      if ((*(void *)(a1 + 216) & 4LL) == 0) {
        char v32 = 12;
      }
      *(void *)&v64[0] <<= v32;
      if (*(_BYTE *)(*(void *)a1 + 104LL))
      {
        uint64_t v33 = *(lsl::Allocator **)(*(void *)a1 + 72LL);
        if (v33)
        {
          do
            unsigned int v34 = __ldxr((unsigned int *)v33);
          while (__stxr(v34 + 1, (unsigned int *)v33));
        }
      }

      else
      {
        lsl::Allocator::makeShared<dyld4::Atlas::Mapper,lsl::Allocator&>( *(lsl::Lock ***)(a1 + 8),  *(void *)(a1 + 8),  &v49);
        uint64_t v33 = v49;
      }

      *(void *)&__int128 v68 = v33;
      if (v33)
      {
        if (*((void *)v33 + 1))
        {
          uint64_t v36 = *(lsl::Lock ***)(a1 + 8);
          uint64_t v48 = (os_unfair_lock_s *)(*(void *)(a1 + 216) & 2LL);
          lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>( v36,  (uint64_t)v36,  (dyld4::FileRecord *)v54,  (unsigned int **)&v68,  (char **)v64,  &v48,  (uint64_t *)&v49);
          uint64_t v38 = *(lsl::Allocator ***)(a1 + 32);
          if (&v49 != v38)
          {
            uint64_t v39 = *v38;
            *uint64_t v38 = v49;
            uint64_t v49 = v39;
          }

          lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr((os_unfair_lock_s **)&v49, v37);
          uint64_t v40 = *(lsl::Lock ***)(a1 + 8);
          uint64_t v41 = lsl::Allocator::aligned_alloc(v40, 8uLL, 0x10uLL);
          uint64_t v42 = (lsl::Allocator *)dyld4::Atlas::Bitmap::Bitmap((uint64_t)v41, v40, (uint64_t)&v51);
          uint64_t v49 = v42;
          uint64_t v44 = *(lsl::Allocator ***)(a1 + 40);
          if (&v49 != v44)
          {
            uint64_t v45 = *v44;
            int *v44 = v42;
            uint64_t v49 = v45;
          }

          lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v49, v43);
          if ((void)v68) {
            lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v68, v46);
          }
          dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v54);
          goto LABEL_7;
        }

        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v33, v31);
      }
    }

    uint64_t v35 = (dyld4::FileRecord *)v54;
LABEL_45:
    dyld4::FileRecord::~FileRecord(v35);
    return 0LL;
  }

LABEL_7:
  uint64_t v18 = lsl::readPVLEUInt64((unsigned __int8 **)&v51);
  uint64_t v3 = 1LL;
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = 0LL;
    vm_size_t v21 = 0LL;
    while (1)
    {
      __int128 v68 = 0uLL;
      memset(v64, 0, sizeof(v64));
      uint64_t v65 = 0x1FFFFFFFFLL;
      __int16 v66 = 0;
      char v67 = 1;
      if (!dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo( a1,  (unsigned __int8 **)&v51,  (uint64_t *)&v49,  &v68,  (dyld4::FileRecord *)v64)) {
        break;
      }
      char v22 = 14;
      if ((*(void *)(a1 + 216) & 4LL) == 0) {
        char v22 = 12;
      }
      vm_size_t v21 = (lsl::Allocator *)((char *)v21 + ((void)v49 << v22));
      uint64_t v49 = v21;
      if (*(_BYTE *)(*(void *)a1 + 104LL))
      {
        __int128 v23 = *(os_unfair_lock_s **)(*(void *)a1 + 72LL);
        if (v23)
        {
          do
            unsigned int v24 = __ldxr(&v23->_os_unfair_lock_opaque);
          while (__stxr(v24 + 1, &v23->_os_unfair_lock_opaque));
        }
      }

      else
      {
        int v25 = *(lsl::Lock ***)(a1 + 8);
        char v26 = lsl::Allocator::aligned_alloc(v25, 8uLL, 0x30uLL);
        void *v26 = v25;
        *(_OWORD *)(v26 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
        *(_OWORD *)(v26 + 3) = 0u;
        v26[5] = v25;
        lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr(v54, (lsl::Allocator::AllocationMetadata *)v26);
        __int128 v23 = *(os_unfair_lock_s **)&v54[0];
      }

      *(void *)&v54[0] = *(void *)(a1 + 8);
      dyld4::FileRecord::FileRecord((uint64_t)v54 + 8, (dyld4::FileRecord *)v64);
      uint64_t v58 = (lsl::Allocator *)v23;
      if (v23)
      {
        do
          unsigned int v27 = __ldxr(&v23->_os_unfair_lock_opaque);
        while (__stxr(v27 + 1, &v23->_os_unfair_lock_opaque));
      }

      __int128 v59 = v68;
      memset(v60, 0, 25);
      _BYTE v60[32] = 0;
      v60[40] = 0;
      uint64_t v61 = v21;
      uint64_t v62 = 0LL;
      v63[0] = 0LL;
      *(_DWORD *)((char *)v63 + 7) = 0;
      uint64_t v28 = *(void *)(a1 + 24);
      lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>( *(lsl::Lock ***)(a1 + 8),  (dyld4::Atlas::Image *)v54,  &v48);
      lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert( v28,  (uint64_t *)&v48,  (uint64_t)v53);
      lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v48);
      dyld4::Atlas::Mapper::Pointer<dyld_cache_header>::~Pointer((uint64_t)v60);
      if (v58) {
        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount((os_unfair_lock_s *)v58, v29);
      }
      dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)((char *)v54 + 8));
      if (v23) {
        lsl::SharedPtr<dyld4::Atlas::Mapper>::Ctrl::decrementRefCount(v23, v30);
      }
      dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v64);
      if (++v20 == v19) {
        return 1LL;
      }
    }

    uint64_t v35 = (dyld4::FileRecord *)v64;
    goto LABEL_45;
  }

  return v3;
}

    std::__throw_bad_optional_access[abi:nn180100]();
  }

  if (!v8) {
    goto LABEL_7;
  }
  uint64_t v9 = 1;
LABEL_6:
  *(_BYTE *)a3 = v9;
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1LL, (void *)(a3 + 8));
}

  uint64_t v20 = v18[6 * a8];
  if (a15)
  {
    vm_size_t v21 = *(void *)(*(void *)(a1 + 48) + 8LL);
    char v22 = *(_DWORD *)(v21 + 24);
    *(_DWORD *)(v21 + 24) = v22 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 4dyld4::halt((char *)__format, 0LL) = v22;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 44LL) = a6;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL) = a11;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL) = a14;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 64LL) = a12;
    if (a13) {
      __int128 v23 = *(_BYTE *)(a1 + 64) != 0;
    }
    else {
      __int128 v23 = 0;
    }
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 65LL) = v23;
  }

  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  v20 + a9 - v17,  a8,  *(void *)(*(void *)(a1 + 40) + 8LL) + 40LL,  a16);
}

uint64_t dyld4::Atlas::ProcessSnapshot::identityMapper(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 72;
}

uint64_t dyld4::Atlas::ProcessSnapshot::sharedCache(dyld4::Atlas::ProcessSnapshot *this)
{
  return (uint64_t)this + 64;
}

double lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert@<D0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = v9;
  *(_OWORD *)(a3 + 24) = v11;
  *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v12;
  *(_OWORD *)(a3 + 56) = v13;
  *(_OWORD *)(a3 + 72) = v14;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 8) = v10;
  *(void *)(a3 + 88) = v15;
  *(_WORD *)(a3 + 96) = v16;
  char v8 = v17;
  *(void *)a3 = v6;
  *(_BYTE *)(a3 + 98) = v8;
  *(_BYTE *)(a3 + 104) = v18;
  return result;
}

double dyld4::Atlas::ProcessSnapshot::removeImageAtAddress( dyld4::Atlas::ProcessSnapshot *this, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = (char *)this + 16;
  uint64_t v31 = (char *)this + 16;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  memset(v36, 0, 27);
  uint64_t v5 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&v31, a2, a3);
  uint64_t v6 = *(void *)v5;
  __int128 v15 = *(_OWORD *)(v5 + 8);
  __int128 v7 = *(_OWORD *)(v5 + 72);
  __int128 v8 = *(_OWORD *)(v5 + 56);
  __int128 v9 = *(_OWORD *)(v5 + 40);
  __int128 v16 = *(_OWORD *)(v5 + 24);
  __int128 v17 = v9;
  __int128 v18 = v8;
  __int128 v19 = v7;
  uint64_t v10 = *(void *)(v5 + 88);
  __int16 v21 = *(_WORD *)(v5 + 96);
  uint64_t v20 = v10;
  LOBYTE(v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v5 + 98);
  uint64_t v14 = v6;
  unsigned __int8 v22 = v10;
  *(_OWORD *)&_OWORD v28[2] = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  memset(v36, 0, 27);
  uint64_t v31 = v4;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&v14,  (uint64_t)&v31))
  {
    while (*(void *)(*(void *)(*((void *)&v15 + v22 - 1) + 8LL * *((unsigned __int8 *)&v20 + v22 - 1)) + 160LL) != a2)
    {
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&v14, v11, v12);
      *(_OWORD *)&_OWORD v28[2] = 0u;
      uint64_t v31 = v4;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      memset(v36, 0, 27);
      if (!lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&v14,  (uint64_t)&v31)) {
        return result;
      }
    }

    __int128 v25 = v16;
    __int128 v26 = v17;
    __int128 v27 = v18;
    *(_OWORD *)uint64_t v28 = v19;
    __int128 v24 = v15;
    *(void *)&v28[16] = v20;
    __int16 v29 = v21;
    uint64_t v23 = v14;
    unsigned __int8 v30 = v22;
    *(void *)&double result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase( (uint64_t)v4,  (uint64_t)&v23,  v12,  (uint64_t)&v31).n128_u64[0];
  }

  return result;
}

os_unfair_lock_s **dyld4::Atlas::ProcessSnapshot::addImage(lsl::Lock ***a1, dyld4::Atlas::Image *a2)
{
  uint64_t v2 = (uint64_t)(a1 + 2);
  lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>(*a1, a2, &v4);
  lsl::OrderedSet<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>>::insert( v2,  (uint64_t *)&v4,  (uint64_t)v5);
  return lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v4);
}

void lsl::Allocator::makeUnique<dyld4::Atlas::Image,dyld4::Atlas::Image>( lsl::Lock **a1@<X0>, dyld4::Atlas::Image *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xC0uLL);
  *uint64_t v5 = *(void *)a2;
  *(_OWORD *)(v5 + 7) = 0u;
  *(_OWORD *)(v5 + 5) = 0u;
  *(_OWORD *)(v5 + 3) = 0u;
  *(_OWORD *)(v5 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  v5[9] = 0x1FFFFFFFFLL;
  *((_WORD *)v5 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
  *((_BYTE *)v5 + 82) = 1;
  *((_BYTE *)v5 + 144) = 0;
  *((_BYTE *)v5 + 152) = 0;
  *((_BYTE *)v5 + 136) = 0;
  *(_OWORD *)(v5 + 15) = 0u;
  *(_OWORD *)(v5 + 13) = 0u;
  *(_OWORD *)(v5 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  *(_DWORD *)((char *)v5 + 183) = 0;
  v5[21] = 0LL;
  v5[22] = 0LL;
  v5[20] = 0LL;
  dyld4::Atlas::Image::swap((dyld4::Atlas::Image *)v5, a2);
  *a3 = v5;
}

uint64_t *dyld4::Atlas::ProcessSnapshot::addSharedCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (os_unfair_lock_s **)(a1 + 64);
  lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>(*(lsl::Lock ***)a1, a2, &v13);
  if (&v13 != v3)
  {
    uint64_t v5 = *v3;
    *uint64_t v3 = v13;
    __int128 v13 = v5;
  }

  lsl::UniquePtr<dyld4::Atlas::SharedCache>::~UniquePtr(&v13, v4);
  uint64_t v6 = *(lsl::Lock ***)a1;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 64) + 128LL) + 144LL);
  __int128 v8 = (os_unfair_lock_s *)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)a1, 8uLL, 0x10uLL);
  *(void *)&v8->_os_unfair_lock_opaque = v7;
  *(void *)&v8[2]._os_unfair_lock_opaque = lsl::Allocator::malloc(v6, (unint64_t)(v7 + 7) >> 3);
  __int128 v13 = v8;
  uint64_t v10 = (os_unfair_lock_s **)(a1 + 56);
  if (&v13 != (os_unfair_lock_s **)(a1 + 56))
  {
    uint64_t v11 = *v10;
    *uint64_t v10 = v8;
    __int128 v13 = v11;
  }

  return lsl::UniquePtr<dyld4::Atlas::Bitmap>::~UniquePtr((uint64_t *)&v13, v9);
}

__n128 lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,dyld4::Atlas::SharedCache>@<Q0>( lsl::Lock **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  *uint64_t v5 = *(void *)a2;
  dyld4::FileRecord::FileRecord((uint64_t)(v5 + 1), (dyld4::FileRecord *)(a2 + 8));
  __int128 v6 = *(_OWORD *)(a2 + 88);
  v5[13] = *(void *)(a2 + 104);
  *(_OWORD *)(v5 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v6;
  v5[15] = 0LL;
  unsigned __int8 v5[16] = 0LL;
  *((_BYTE *)v5 + 136) = 0;
  v5[14] = 0LL;
  dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(v5 + 14, (uint64_t *)(a2 + 112));
  v5[18] = 0LL;
  if (v5 != (void *)a2)
  {
    v5[18] = *(void *)(a2 + 144);
    *(void *)(a2 + 144) = 0LL;
  }

  __n128 result = *(__n128 *)(a2 + 152);
  *((_BYTE *)v5 + 168) = *(_BYTE *)(a2 + 168);
  *(__n128 *)(v5 + 19) = result;
  *a3 = v5;
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::addSharedCacheImage(uint64_t this, const mach_header *a2)
{
  uint64_t v2 = *(char **)(*(void *)(this + 64) + 160LL);
  uint64_t v3 = *((void *)v2 + 18);
  unsigned int v4 = &v2[*((void *)v2 + 17)];
  if (v3)
  {
    uint64_t v5 = (char *)((char *)a2 - v2 + *((void *)v2 + 28));
    uint64_t v6 = 32 * v3;
    uint64_t v7 = &v2[*((void *)v2 + 17)];
    while (*((char **)v7 + 2) != v5)
    {
      v7 += 32;
      v6 -= 32LL;
      if (!v6) {
        goto LABEL_5;
      }
    }
  }

  else
  {
    uint64_t v7 = &v2[*((void *)v2 + 17)];
  }

  if (v7 == &v4[32 * v3]) {
LABEL_5:
  }
    dyld4::Atlas::ProcessSnapshot::addSharedCacheImage();
  *(_BYTE *)(*(void *)(*(void *)(this + 56) + 8LL) + ((unint64_t)((v7 - v4) >> 5) >> 3)) |= 1 << (((v7 - v4) >> 5) & 7);
  return this;
}

os_unfair_lock_s *dyld4::Atlas::ProcessSnapshot::serialize@<X0>( dyld4::Atlas::ProcessSnapshot *this@<X0>, lsl::Lock ***a2@<X8>)
{
  uint64_t v3 = this;
  uint64_t v5 = (char *)this + 16;
  uint64_t v6 = (char *)this + 64;
  uint64_t v7 = (char *)this + 56;
  int v24 = -1491447450;
  __int128 v4 = *(_OWORD *)this;
  uint64_t v8 = v4;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v12 = v4;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v16 = v4;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v20 = v4;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  unsigned __int8 v30 = (char *)this + 80;
  uint64_t v31 = (char *)this + 88;
  __int128 v32 = (char *)this + 96;
  __n128 result = dyld4::Atlas::ProcessSnapshot::Serializer::serialize((dyld4::Atlas::ProcessSnapshot::Serializer *)&v3, a2);
  if (v21) {
    __n128 result = lsl::Vector<unsigned int>::resize((os_unfair_lock_s *)&v20, 0LL);
  }
  if (v17) {
    __n128 result = lsl::Vector<std::byte>::resize((os_unfair_lock_s *)&v16, 0LL);
  }
  if (v13) {
    __n128 result = lsl::Vector<dyld4::Loader const*>::resize((os_unfair_lock_s *)&v12, 0LL);
  }
  if (v9) {
    return lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize((os_unfair_lock_s *)&v8, 0LL);
  }
  return result;
}

os_unfair_lock_s *dyld4::Atlas::ProcessSnapshot::Serializer::serialize@<X0>( dyld4::Atlas::ProcessSnapshot::Serializer *this@<X0>, lsl::Lock ***a2@<X8>)
{
  *((void *)this + 25) = mach_absolute_time();
  ++*((_DWORD *)this + 52);
  uint64_t v6 = (lsl::Lock **)*((void *)this + 1);
  *a2 = v6;
  a2[1] = 0LL;
  a2[2] = 0LL;
  a2[3] = 0LL;
  uint64_t v107 = 0LL;
  uint64_t v108 = v6;
  uint64_t v109 = 0LL;
  char v110 = 0;
  uint64_t v103 = 0LL;
  uint64_t v104 = v6;
  uint64_t v105 = 0LL;
  char v106 = 0;
  if (vm_page_size == 0x4000) {
    *((void *)this + 27) |= 4uLL;
  }
  uint64_t v7 = **((void **)this + 4);
  if (v7)
  {
    *((void *)this + 27) |= 1uLL;
    uint64_t v8 = (dyld4::FileRecord *)(v7 + 8);
    if (dyld4::FileRecord::persistent((dyld4::FileRecord *)(v7 + 8)))
    {
      uint64_t v9 = (__n128 *)dyld4::FileRecord::volume(v8);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v103, v9, (uint64_t)v148);
    }

    else
    {
      Path = (char *)dyld4::FileRecord::getPath(v8);
      if (Path)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &Path, (uint64_t)v148);
      }

      else
      {
        int v131 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v131, (uint64_t)v148);
      }
    }
  }

  *(void *)&v148[0] = *((void *)this + 3);
  uint64_t v10 = *(char **)&v148[0];
  memset((char *)v148 + 8, 0, 91);
  uint64_t v11 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v4, v5);
  uint64_t v12 = *(char **)v11;
  __int128 v140 = *(_OWORD *)(v11 + 8);
  __int128 v13 = *(_OWORD *)(v11 + 72);
  __int128 v14 = *(_OWORD *)(v11 + 56);
  __int128 v15 = *(_OWORD *)(v11 + 40);
  __int128 v141 = *(_OWORD *)(v11 + 24);
  __int128 v142 = v15;
  __int128 v143 = v14;
  __int128 v144 = v13;
  uint64_t v16 = *(void *)(v11 + 88);
  __int16 v146 = *(_WORD *)(v11 + 96);
  unsigned __int8 v17 = *(_BYTE *)(v11 + 98);
  uint64_t v145 = v16;
  Path = v12;
  unsigned __int8 v147 = v17;
  *(_OWORD *)((char *)&v148[4] + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  __int128 v132 = 0u;
  __int128 v133 = 0u;
  __int128 v134 = 0u;
  __int128 v135 = 0u;
  memset(v136, 0, sizeof(v136));
  int v131 = v10;
  __int16 v137 = 0;
  char v138 = 0;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&Path,  (uint64_t)&v131))
  {
    if (dyld4::FileRecord::persistent(v20))
    {
      uint64_t v21 = (__n128 *)dyld4::FileRecord::volume(v20);
      lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert((uint64_t)&v103, v21, (uint64_t)v148);
    }

    else
    {
      uint64_t v102 = (char *)dyld4::FileRecord::getPath(v20);
      if (v102)
      {
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v102, (uint64_t)v148);
      }

      else
      {
        char v101 = "???";
        lsl::OrderedSet<char const*,lsl::ConstCharStarCompare>::insert((uint64_t *)&v107, &v101, (uint64_t)v148);
      }
    }

    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v22, v23);
  }

  *(void *)&v148[0] = &v103;
  memset((char *)v148 + 8, 0, 109);
  uint64_t v24 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++((uint64_t)v148, v18, v19);
  uint64_t v25 = *(void *)v24;
  __int128 v26 = *(_OWORD *)(v24 + 88);
  __int128 v27 = *(_OWORD *)(v24 + 72);
  __int128 v28 = *(_OWORD *)(v24 + 56);
  __int128 v124 = *(_OWORD *)(v24 + 40);
  __int128 v125 = v28;
  __int128 v126 = v27;
  __int128 v127 = v26;
  __int128 v29 = *(_OWORD *)(v24 + 24);
  __int128 v122 = *(_OWORD *)(v24 + 8);
  __int128 v123 = v29;
  uint64_t v30 = *(void *)(v24 + 104);
  int v129 = *(_DWORD *)(v24 + 112);
  char v31 = *(_BYTE *)(v24 + 116);
  uint64_t v128 = v30;
  uint64_t v121 = v25;
  char v130 = v31;
  memset(v148, 0, 108);
  uint64_t v111 = &v103;
  __int128 v117 = 0u;
  __int128 v116 = 0u;
  __int128 v115 = 0u;
  __int128 v114 = 0u;
  __int128 v113 = 0u;
  __int128 v112 = 0u;
  int v119 = 0;
  uint64_t v118 = 0LL;
  char v120 = 0;
  __int128 v32 = (os_unfair_lock_s *)lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>( v148,  &v121,  (uint64_t)&v111,  *((void *)this + 1));
  if ((_OWORD *)((char *)this + 48) != v148)
  {
    __int128 v35 = v148[1];
    v148[1] = *((_OWORD *)this + 4);
    uint64_t v37 = *((void *)this + 6);
    uint64_t v36 = *((void *)this + 7);
    *((_OWORD *)this + 3) = v148[0];
    *((_OWORD *)this + 4) = v35;
    *(void *)&v148[0] = v37;
    *((void *)&v148[0] + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v36;
    if (!v36) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (*((void *)&v148[0] + 1)) {
LABEL_18:
  }
    lsl::Vector<std::pair<dyld4::Loader const*,char const*>>::resize(v32, 0LL);
LABEL_19:
  *(void *)&v148[0] = &v107;
  memset((char *)v148 + 8, 0, 91);
  uint64_t v38 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v33, v34);
  uint64_t v39 = *(char **)v38;
  __int128 v140 = *(_OWORD *)(v38 + 8);
  __int128 v40 = *(_OWORD *)(v38 + 72);
  __int128 v41 = *(_OWORD *)(v38 + 56);
  __int128 v42 = *(_OWORD *)(v38 + 40);
  __int128 v141 = *(_OWORD *)(v38 + 24);
  __int128 v142 = v42;
  __int128 v143 = v41;
  __int128 v144 = v40;
  uint64_t v43 = *(void *)(v38 + 88);
  __int16 v146 = *(_WORD *)(v38 + 96);
  unsigned __int8 v44 = *(_BYTE *)(v38 + 98);
  uint64_t v145 = v43;
  Path = v39;
  unsigned __int8 v147 = v44;
  *(_OWORD *)((char *)v136 + 2) = 0u;
  memset((char *)v148 + 8, 0, 91);
  *(void *)&v148[0] = &v107;
  while (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&Path,  (uint64_t)v148))
  {
    uint64_t v45 = v147 - 1LL;
    uint64_t v46 = *((void *)&v140 + v45);
    uint64_t v47 = *((unsigned __int8 *)&v145 + v45);
    uint64_t v48 = *((void *)this + 16);
    lsl::Vector<unsigned int>::reserve((uint64_t)this + 144, *((void *)this + 20) + 1LL);
    uint64_t v49 = *((void *)this + 19);
    uint64_t v50 = *((void *)this + 20);
    *((void *)this + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v50 + 1;
    *(_DWORD *)(v49 + 4 * v5dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v48;
    uint64_t v51 = *(char **)(v46 + 8 * v47);
    if (*v51)
    {
      uint64_t v52 = 1LL;
      do
      {
        lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((void *)this + 16) + 1LL);
        char v53 = *v51;
        uint64_t v54 = *((void *)this + 15);
        uint64_t v55 = *((void *)this + 16);
        *((void *)this + 16) = v55 + 1;
        *(_BYTE *)(v54 + v55) = v53;
        uint64_t v51 = (char *)(*(void *)(v46 + 8 * v47) + v52++);
      }

      while (*v51);
    }

    lsl::Vector<std::byte>::reserve((uint64_t)this + 112, *((void *)this + 16) + 1LL);
    uint64_t v56 = *((void *)this + 15);
    uint64_t v57 = *((void *)this + 16);
    *((void *)this + 16) = v57 + 1;
    *(_BYTE *)(v56 + v57) = 0;
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v58, v59);
  }

  uint64_t v60 = *((void *)this + 20);
  if (v60)
  {
    uint64_t v61 = (unsigned int *)*((void *)this + 19);
    uint64_t v62 = *((void *)this + 12);
    uint64_t v63 = 4 * v60;
    do
    {
      unsigned int v64 = *v61++;
      uint64_t v65 = *((void *)this + 15) + v64;
      lsl::Vector<void (*)(mach_header const*,long)>::reserve((uint64_t)this + 80, v62 + 1);
      uint64_t v66 = *((void *)this + 11);
      uint64_t v67 = *((void *)this + 12);
      uint64_t v62 = v67 + 1;
      *((void *)this + 12) = v67 + 1;
      *(void *)(v66 + 8 * v67) = v65;
      v63 -= 4LL;
    }

    while (v63);
  }

  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 44), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 45), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((void *)this + 23), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 48), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 52), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(*((void *)this + 25), (uint64_t)a2);
  dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(*((_DWORD *)this + 53), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((void *)this + 27), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 28), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 29), (uint64_t)a2);
  lsl::emitPVLEUInt64(**((void **)this + 30), (uint64_t)a2);
  lsl::emitPVLEUInt64(*((void *)this + 8), (uint64_t)a2);
  uint64_t v68 = *((void *)this + 8);
  if (v68)
  {
    uint64_t v69 = (char *)*((void *)this + 7);
    uint64_t v70 = 16 * v68;
    do
    {
      uint64_t v71 = v69 + 16;
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( (uint64_t)v148,  v69,  v69 + 16,  (uint64_t)a2);
      uint64_t v69 = v71;
      v70 -= 16LL;
    }

    while (v70);
  }

  lsl::emitPVLEUInt64(*((void *)this + 16), (uint64_t)a2);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( (uint64_t)v148,  *((char **)this + 15),  (char *)(*((void *)this + 15) + *((void *)this + 16)),  (uint64_t)a2);
  if ((*((void *)this + 27) & 1) != 0)
  {
    char v72 = 14;
    if ((*((void *)this + 27) & 4LL) == 0) {
      char v72 = 12;
    }
    dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo( (uint64_t)this,  *(void *)(**((void **)this + 4) + 160LL) >> v72,  (char *)(**((void **)this + 4) + 88LL),  (dyld4::FileRecord *)(**((void **)this + 4) + 8LL),  (uint64_t)a2);
    dyld4::Atlas::Bitmap::emit(**((void **)this + 5), (uint64_t)a2);
  }

  lsl::emitPVLEUInt64(*(void *)(*((void *)this + 3) + 24LL), (uint64_t)a2);
  *(void *)&v148[0] = *((void *)this + 3);
  uint64_t v73 = *(void *)&v148[0];
  memset((char *)v148 + 8, 0, 91);
  uint64_t v76 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)v148, v74, v75);
  uint64_t v77 = *(char **)v76;
  __int128 v140 = *(_OWORD *)(v76 + 8);
  __int128 v78 = *(_OWORD *)(v76 + 72);
  __int128 v79 = *(_OWORD *)(v76 + 56);
  __int128 v80 = *(_OWORD *)(v76 + 40);
  __int128 v141 = *(_OWORD *)(v76 + 24);
  __int128 v142 = v80;
  __int128 v143 = v79;
  __int128 v144 = v78;
  uint64_t v81 = *(void *)(v76 + 88);
  __int16 v146 = *(_WORD *)(v76 + 96);
  unsigned __int8 v82 = *(_BYTE *)(v76 + 98);
  uint64_t v145 = v81;
  Path = v77;
  unsigned __int8 v147 = v82;
  *(_OWORD *)((char *)v136 + 2) = 0u;
  memset((char *)v148 + 8, 0, 91);
  *(void *)&v148[0] = v73;
  if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&Path,  (uint64_t)v148))
  {
    uint64_t v83 = 0LL;
    do
    {
      uint64_t v84 = v147 - 1LL;
      uint64_t v85 = *((void *)&v140 + v84);
      uint64_t v86 = *((unsigned __int8 *)&v145 + v84);
      uint64_t v87 = *(dyld4::Atlas::Image **)(v85 + 8 * v86);
      uint64_t v88 = *((void *)v87 + 20);
      unint64_t v89 = v88 - v83;
      if ((*((void *)this + 27) & 4LL) != 0) {
        char v90 = 14;
      }
      else {
        char v90 = 12;
      }
      unint64_t v91 = v89 >> v90;
      uint64_t v92 = (char *)dyld4::Atlas::Image::uuid(v87);
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo( (uint64_t)this,  v91,  v92,  (dyld4::FileRecord *)(*(void *)(v85 + 8 * v86) + 8LL),  (uint64_t)a2);
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++((uint64_t)&Path, v93, v94);
      char v95 = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( (uint64_t)&Path,  (uint64_t)v148);
      uint64_t v83 = v88;
    }

    while (v95);
  }

  while (1)
  {
    uint64_t v98 = a2[2];
    lsl::Vector<std::byte>::reserve((uint64_t)a2, (unint64_t)v98 + 1);
    uint64_t v96 = a2[1];
    char v97 = a2[2];
    a2[2] = (lsl::Lock **)((char *)v97 + 1);
    *((_BYTE *)v97 + (void)v96) = 0;
  }

  BOOL v99 = (unsigned int *)lsl::CRC32c::CRC32c((uint64_t)v148);
  lsl::CRC32c::operator()(v99, (uint64_t)a2[1], (uint64_t)a2[2]);
  *((_DWORD *)a2[1] + 8) = lsl::CRC32c::operator unsigned int((uint64_t)v148);
  if (v103) {
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v103, v104);
  }
  __n128 result = v107;
  if (v107) {
    return lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate((uint64_t)v107, v108);
  }
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setInitialImageCount(uint64_t this, uint64_t a2)
{
  *(void *)(this + 88) = a2;
  return this;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setDyldState(uint64_t this, uint64_t a2)
{
  *(void *)(this + 96) = a2;
  return this;
}

uint64_t dyld4::Atlas::ProcessSnapshot::setPlatform(uint64_t this, uint64_t a2)
{
  *(void *)(this + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2;
  return this;
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a2;
  uint64_t v5 = *(void **)(a1 + 88);
  uint64_t v6 = &v5[*(void *)(a1 + 96)];
  char v11 = 0;
  uint64_t v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>( v5,  v6,  &v10);
  uint64_t v8 = *(void **)(a1 + 88);
  if (v7 == &v8[*(void *)(a1 + 96)])
  {
    char v12 = 0;
    uint64_t v7 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>( v8,  v7,  "???");
  }

  return lsl::emitPVLEUInt64((*(_DWORD *)v7 - *(_DWORD *)(a1 + 120)), a3);
}

char *dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo( uint64_t a1, unint64_t a2, char *a3, dyld4::FileRecord *this, uint64_t a5)
{
  uint64_t v10 = 0LL;
  do
  {
    int v11 = a3[v10];
    if (a3[v10]) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = v10 == 15;
    }
    ++v10;
  }

  while (!v12);
  unint64_t v13 = 4LL * (v11 != 0);
  if (dyld4::FileRecord::persistent(this))
  {
    v13 |= 1uLL;
  }

  else if (dyld4::FileRecord::getPath(this))
  {
    v13 |= 2uLL;
  }

  lsl::emitPVLEUInt64(v13, a5);
  __n128 result = lsl::emitPVLEUInt64(a2, a5);
  if ((v13 & 4) != 0) {
    __n128 result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::byte *,std::byte *,std::back_insert_iterator<lsl::Vector<std::byte>>>( (uint64_t)&v31,  a3,  a3 + 16,  a5);
  }
  if ((v13 & 1) != 0)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    unint64_t v16 = *(void *)(a1 + 64);
    uint64_t v17 = dyld4::FileRecord::volume(this);
    if (v16)
    {
      do
      {
        uint64_t v18 = 0LL;
        unint64_t v19 = v16 >> 1;
        uint64_t v20 = v15 + 16 * (v16 >> 1);
        while (1)
        {
          unsigned int v21 = *(unsigned __int8 *)(v20 + v18);
          unsigned int v22 = *(unsigned __int8 *)(v17 + v18);
          if (v21 < v22) {
            break;
          }
          if (v22 < v21 || v18++ == 15) {
            goto LABEL_24;
          }
        }

        uint64_t v15 = v20 + 16;
        unint64_t v19 = v16 + ~v19;
LABEL_24:
        unint64_t v16 = v19;
      }

      while (v19);
    }

    if (v15 == *(void *)(a1 + 56) + 16LL * *(void *)(a1 + 64)) {
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    }
    uint64_t v24 = dyld4::FileRecord::volume(this);
    uint64_t v25 = 0LL;
    do
    {
      int v26 = *(unsigned __int8 *)(v15 + v25);
      int v27 = *(unsigned __int8 *)(v24 + v25);
    }

    while (v26 == v27 && v25++ != 15);
    if (v26 != v27) {
      dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo();
    }
    lsl::emitPVLEUInt64((unsigned __int16)((unint64_t)(v15 - *(_DWORD *)(a1 + 56)) >> 4), a5);
    unint64_t v29 = dyld4::FileRecord::objectID(this);
    __n128 result = lsl::emitPVLEUInt64(v29, a5);
  }

  if ((v13 & 2) != 0)
  {
    uint64_t Path = dyld4::FileRecord::getPath(this);
    return dyld4::Atlas::ProcessSnapshot::Serializer::emitStringRef(a1, Path, a5);
  }

  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::readMappedFileInfo( uint64_t a1, unsigned __int8 **a2, uint64_t *a3, _OWORD *a4, dyld4::FileRecord *a5)
{
  char PVLEUInt64 = lsl::readPVLEUInt64(a2);
  *a3 = lsl::readPVLEUInt64(a2);
  if ((PVLEUInt64 & 4) != 0)
  {
    *a4 = *(_OWORD *)*a2;
    uint64_t v11 = (uint64_t)(a2[1] - 16);
    *a2 += 16;
    a2[1] = (unsigned __int8 *)v11;
  }

  if ((PVLEUInt64 & 1) != 0)
  {
    unint64_t v12 = lsl::readPVLEUInt64(a2);
    uint64_t v13 = lsl::readPVLEUInt64(a2);
    if (v12 >= *(void *)(a1 + 64)) {
      return 0LL;
    }
    dyld4::FileManager::fileRecordForVolumeUUIDAndObjID( *(dyld4::FileManager **)(a1 + 16),  (const UUID *)(*(void *)(a1 + 56) + 16 * v12),  v13,  (uint64_t)v16);
    dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
  }

  if ((PVLEUInt64 & 2) == 0) {
    return 1LL;
  }
  unint64_t v14 = lsl::readPVLEUInt64(a2);
  if (v14 < *(void *)(a1 + 128))
  {
    dyld4::FileManager::fileRecordForPath( *(dyld4::FileManager **)(a1 + 16),  *(lsl::Lock ***)(a1 + 8),  (const char *)(*(void *)(a1 + 120) + v14),  (uint64_t)v16);
    dyld4::FileRecord::operator=(a5, (dyld4::FileRecord *)v16);
    dyld4::FileRecord::~FileRecord((dyld4::FileRecord *)v16);
    return 1LL;
  }

  return 0LL;
}

double lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::insert@<D0>( uint64_t a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v19 = *a2;
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator((uint64_t)v20, a1, (uint64_t)&v19);
  lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal(a1, (uint64_t)v20, &v19, (uint64_t)&v8);
  uint64_t v5 = v8;
  *(_OWORD *)(a3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v11;
  *(_OWORD *)(a3 + 56) = v12;
  *(_OWORD *)(a3 + 72) = v13;
  *(_OWORD *)(a3 + 88) = v14;
  *(_OWORD *)(a3 + 8) = v9;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 24) = v10;
  *(void *)(a3 + 104) = v15;
  *(_DWORD *)(a3 + 112) = v16;
  char v7 = v17;
  *(void *)a3 = v5;
  *(_BYTE *)(a3 + 116) = v7;
  *(_BYTE *)(a3 + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v18;
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned int>(int a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  int v8 = a1;
  do
  {
    uint64_t result = lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1LL);
    char v5 = *((_BYTE *)&v8 + v3);
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v7 + 1;
    *(_BYTE *)(v6 + v7) = v5;
    ++v3;
  }

  while (v3 != 4);
  return result;
}

uint64_t dyld4::Atlas::ProcessSnapshot::Serializer::emit<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  uint64_t v8 = a1;
  do
  {
    uint64_t result = lsl::Vector<std::byte>::reserve(a2, *(void *)(a2 + 16) + 1LL);
    char v5 = *((_BYTE *)&v8 + v3);
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v7 + 1;
    *(_BYTE *)(v6 + v7) = v5;
    ++v3;
  }

  while (v3 != 8);
  return result;
}

uint64_t lsl::Allocator::makeUnique<dyld4::Atlas::SharedCache,lsl::Allocator&,dyld4::FileRecord,lsl::SharedPtr<dyld4::Atlas::Mapper> &,unsigned long long &,unsigned long long>@<X0>( lsl::Lock **a1@<X0>, uint64_t a2@<X1>, dyld4::FileRecord *a3@<X2>, unsigned int **a4@<X3>, char **a5@<X4>, void *a6@<X5>, uint64_t *a7@<X8>)
{
  __int128 v13 = lsl::Allocator::aligned_alloc(a1, 8uLL, 0xB0uLL);
  uint64_t result = dyld4::Atlas::SharedCache::SharedCache((uint64_t)v13, a2, a3, a4, *a5, *a6 != 0LL);
  *a7 = result;
  return result;
}

uint64_t *std::optional<unsigned long long>::swap[abi:nn180100](uint64_t *result, uint64_t *a2)
{
  if ((*((_BYTE *)result + 8) != 0) != (*((_BYTE *)a2 + 8) != 0))
  {
    if (*((_BYTE *)result + 8))
    {
      *a2 = *result;
      *((_BYTE *)a2 + 8) = 1;
      if (*((_BYTE *)result + 8)) {
        *((_BYTE *)result + 8) = 0;
      }
    }

    else
    {
      *uint64_t result = *a2;
      *((_BYTE *)result + 8) = 1;
      if (*((_BYTE *)a2 + 8)) {
        *((_BYTE *)a2 + 8) = 0;
      }
    }
  }

  else if (*((_BYTE *)result + 8))
  {
    uint64_t v2 = *result;
    *uint64_t result = *a2;
    *a2 = v2;
  }

  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 98);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 98);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 98);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 98);
  }
  if ((_DWORD)v4)
  {
    char v5 = (unsigned __int8 *)(a1 + 88);
    uint64_t v6 = (unsigned __int8 *)(a2 + 88);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }

    if (v10) {
      return 1LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0LL;
    }
    else {
      return v12;
    }
  }

os_unfair_lock_s *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate( uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    uint64_t v4 = (uint64_t *)(a1 + 120);
    uint64_t v5 = 8LL * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::deallocate(v6, a2);
      v5 -= 8LL;
    }

    while (v5);
  }

  return lsl::Allocator::free(a2, (void *)a1);
}

os_unfair_lock_s *lsl::Vector<unsigned int>::resize(os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<unsigned int>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  4 * a2);
  }

  else
  {
    unsigned int v3 = result + 2;
    unsigned int v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

uint64_t lsl::Vector<unsigned int>::reserve(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    if (a2 >= 0x10)
    {
      unint64_t v3 = (a2 - 1) | ((a2 - 1) >> 1) | (((a2 - 1) | ((a2 - 1) >> 1)) >> 2);
      unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
      unint64_t v2 = (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
    }

    else
    {
      unint64_t v2 = 16LL;
    }

    return lsl::Vector<unsigned int>::reserveExact(result, v2);
  }

  return result;
}

uint64_t lsl::Vector<unsigned int>::reserveExact(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 24) < a2)
  {
    uint64_t v3 = result;
    uint64_t result = lsl::Allocator::realloc(*(lsl::Lock ***)result, *(void **)(result + 8), 4 * a2);
    if ((result & 1) != 0)
    {
LABEL_12:
      *(void *)(v3 + 24) = a2;
      return result;
    }

    uint64_t result = (uint64_t)lsl::Allocator::aligned_alloc(*(lsl::Lock ***)v3, 0x10uLL, 4 * a2);
    uint64_t v4 = result;
    uint64_t v5 = *(void **)(v3 + 8);
    uint64_t v6 = *(void *)(v3 + 16);
    if (v6)
    {
      unsigned int v7 = (_DWORD *)result;
      unsigned int v8 = *(int **)(v3 + 8);
      do
      {
        int v9 = *v8++;
        *v7++ = v9;
        --v6;
      }

      while (v6);
    }

    else if (!v5)
    {
      unint64_t v10 = 0LL;
      goto LABEL_9;
    }

    uint64_t result = (uint64_t)lsl::Allocator::free(*(lsl::Lock ***)v3, v5);
    unint64_t v10 = *(void *)(v3 + 16);
LABEL_9:
    if (v10 >= a2) {
      unint64_t v10 = a2;
    }
    *(void *)(v3 + 8) = v4;
    *(void *)(v3 + 16) = v10;
    goto LABEL_12;
  }

  return result;
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char const*,std::__identity,lsl::ConstCharStarCompare>( void *a1, void *a2, void *a3)
{
  if (a2 != a1)
  {
    unint64_t v3 = a2 - a1;
    a2 = a1;
    do
    {
      unint64_t v4 = v3 >> 1;
      uint64_t v5 = &a2[v3 >> 1];
      int v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        a2 = v5 + 1;
        unint64_t v4 = v3 + ~v4;
      }

      else
      {
        unsigned int v7 = (char *)(*v5 + 1LL);
        unsigned int v8 = (char *)(*a3 + 1LL);
        int v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            int v10 = *v7++;
            int v6 = v10;
            int v11 = *v8++;
            int v9 = v11;
            if (v6 >= v11) {
              continue;
            }
          }

          goto LABEL_9;
        }
      }

      unint64_t v3 = v4;
    }

    while (v4);
  }

  return a2;
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,char const**,char const**,char [4],std::__identity,lsl::ConstCharStarCompare>( void *a1, void *a2, unsigned __int8 *a3)
{
  if (a2 != a1)
  {
    unint64_t v3 = a2 - a1;
    int v6 = *a3;
    unint64_t v4 = a3 + 1;
    int v5 = v6;
    a2 = a1;
    do
    {
      unint64_t v7 = v3 >> 1;
      unsigned int v8 = &a2[v3 >> 1];
      int v9 = *(char *)*v8;
      if (v9 < (char)v5)
      {
LABEL_9:
        a2 = v8 + 1;
        unint64_t v7 = v3 + ~v7;
      }

      else
      {
        int v10 = (char *)(*v8 + 1LL);
        int v11 = v4;
        int v12 = v5;
        while (v12 && (char)v12 >= (char)v9)
        {
          if ((_BYTE)v9)
          {
            int v13 = *v10++;
            int v9 = v13;
            int v14 = (char)*v11++;
            int v12 = v14;
            if (v9 >= v14) {
              continue;
            }
          }

          goto LABEL_9;
        }
      }

      unint64_t v3 = v7;
    }

    while (v7);
  }

  return a2;
}

os_unfair_lock_s *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate( uint64_t a1, lsl::Lock **a2)
{
  if ((*(char *)(a1 + 248) & 0x80000000) == 0)
  {
    unint64_t v4 = (uint64_t *)(a1 + 160);
    uint64_t v5 = 8LL * *(unsigned __int8 *)(a1 + 248) + 8;
    do
    {
      uint64_t v6 = *v4++;
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::deallocate(v6, a2);
      v5 -= 8LL;
    }

    while (v5);
  }

  return lsl::Allocator::free(a2, (void *)a1);
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<unsigned char *,unsigned char *,std::back_insert_iterator<lsl::Vector<char>>>( uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      char v7 = *v5++;
      lsl::Vector<std::byte>::reserve(a4, *(void *)(a4 + 16) + 1LL);
      uint64_t v8 = *(void *)(a4 + 8);
      uint64_t v9 = *(void *)(a4 + 16);
      *(void *)(a4 + 16) = v9 + 1;
      *(_BYTE *)(v8 + v9) = v7;
    }

    while (v5 != a3);
    return a3;
  }

  return v5;
}

os_unfair_lock_s *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::resize( os_unfair_lock_s *result, unint64_t a2)
{
  if (*(void *)&result[6]._os_unfair_lock_opaque < a2) {
    return (os_unfair_lock_s *)lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)result, a2);
  }
  if (a2)
  {
    *(void *)&result[4]._os_unfair_lock_opaque = a2;
    *(void *)&result[6]._os_unfair_lock_opaque = a2;
    return (os_unfair_lock_s *)lsl::Allocator::realloc( *(lsl::Lock ***)&result->_os_unfair_lock_opaque,  *(void **)&result[2]._os_unfair_lock_opaque,  32 * a2);
  }

  else
  {
    unint64_t v3 = result + 2;
    unint64_t v2 = *(void **)&result[2]._os_unfair_lock_opaque;
    if (v2) {
      uint64_t result = lsl::Allocator::free(*(lsl::Lock ***)&result->_os_unfair_lock_opaque, v2);
    }
    *(void *)&v3->_os_unfair_lock_opaque = 0LL;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;
    *(void *)&v3[4]._os_unfair_lock_opaque = 0LL;
  }

  return result;
}

void *lsl::SharedPtr<dyld4::Atlas::Mapper>::SharedPtr( void *a1, lsl::Allocator::AllocationMetadata *this)
{
  *a1 = 0LL;
  unint64_t v4 = (lsl::Allocator::AllocationMetadata *)lsl::Allocator::AllocationMetadata::forPtr(this, this);
  uint64_t v5 = (lsl::Allocator::Pool *)lsl::Allocator::AllocationMetadata::pool(v4, 1);
  uint64_t v6 = (lsl::Lock **)lsl::Allocator::Pool::allocator(v5);
  char v7 = lsl::Allocator::aligned_alloc(v6, 8uLL, 0x10uLL);
  *(_DWORD *)char v7 = 0;
  v7[1] = this;
  *a1 = v7;
  return a1;
}

void *lsl::Vector<dyld4::Atlas::Mapper::Mapping>::Vector(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a3;
  a1[1] = 0LL;
  uint64_t v5 = (void **)(a1 + 1);
  a1[2] = 0LL;
  a1[3] = 0LL;
  lsl::Vector<dyld4::ObjCClassReplacement>::reserve((uint64_t)a1, *(void *)(a2 + 16));
  a1[2] = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6) {
    memmove(*v5, *(const void **)(a2 + 8), 32 * v6);
  }
  return a1;
}

uint64_t *dyld4::Atlas::Mapper::Pointer<dyld3::MachOLoaded>::swap(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = result[1];
    uint64_t v4 = a2[1];
    *uint64_t result = *a2;
    result[1] = v4;
    *a2 = v2;
    a2[1] = v3;
    uint64_t v5 = result[2];
    result[2] = a2[2];
    a2[2] = v5;
    LOBYTE(v5) = *((_BYTE *)result + 24);
    *((_BYTE *)result + 24) = *((_BYTE *)a2 + 24);
    *((_BYTE *)a2 + 24) = v5;
  }

  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::insert_internal@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v29 = a1;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    memset(v34, 0, sizeof(v34));
    uint64_t result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v29);
    if ((_BYTE)result
      && (uint64_t v9 = *(unsigned __int8 *)(a2 + 98),
          int v10 = *(char **)(*(void *)(a2 + 8 + 8 * (v9 - 1)) + 8LL * *(unsigned __int8 *)(a2 + 88 + v9 - 1)),
          int v11 = **a3,
          v11 >= *v10))
    {
      int v12 = *v10;
      int v13 = v10 + 1;
      int v14 = *a3 + 1;
      while (v12 && (char)v12 >= (char)v11)
      {
        if ((_BYTE)v11)
        {
          int v15 = *v14++;
          int v11 = v15;
          int v16 = *v13++;
          int v12 = v16;
          if (v11 >= v16) {
            continue;
          }
        }

        goto LABEL_9;
      }

      char v25 = 0;
      __int128 v27 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      __int128 v28 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v28;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 8) = v27;
      *(void *)(a4 + 88) = *(void *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(_BYTE *)(a4 + 98) = v9;
    }

    else
    {
LABEL_9:
      uint64_t v29 = a1;
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      memset(v34, 0, sizeof(v34));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( a2,  (uint64_t)&v29)
        && *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v17,  v18);
        uint64_t v19 = a2 + 88;
        uint64_t v20 = *(unsigned __int8 *)(a2 + 98) - 1LL;
        unsigned __int8 v21 = *(_BYTE *)(a2 + 88 + v20);
      }

      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v17, v18);
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v22,  v23);
        uint64_t v19 = a2 + 88;
        uint64_t v24 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        unsigned __int8 v21 = *(_BYTE *)(v24 - 1) + 1;
        *(_BYTE *)(v24 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v21;
        uint64_t v20 = *(unsigned __int8 *)(a2 + 98) - 1LL;
      }

      uint64_t result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert( *(char **)(a2 + 8 + 8 * v20),  v21,  a3);
      ++*(void *)(a1 + 24);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(a4 + 88) = *(void *)v19;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v19 + 8);
      *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
      char v25 = 1;
    }
  }

  else
  {
    int v26 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v26 + 248) = 0x80;
    *(_OWORD *)int v26 = 0u;
    *((_OWORD *)v26 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v26 + 2) = 0u;
    *((_OWORD *)v26 + 3) = 0u;
    *((_OWORD *)v26 + 4) = 0u;
    *((_OWORD *)v26 + 5) = 0u;
    *((_OWORD *)v26 + 6) = 0u;
    *((_OWORD *)v26 + 7) = 0u;
    *((_OWORD *)v26 + 8) = 0u;
    *((_OWORD *)v26 + 9) = 0u;
    *((_OWORD *)v26 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)v26 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v26 + 12) = 0u;
    *((_OWORD *)v26 + 13) = 0u;
    *((_OWORD *)v26 + 14) = 0u;
    v26[30] = 0LL;
    *(void *)a1 = v26;
    char v25 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v26;
    *(_BYTE *)(a2 + 98) = 1;
    uint64_t result = (uint64_t)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert( (char *)v26,  0LL,  a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(a4 + 88) = *(void *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  }

  *(_BYTE *)(a4 + 104) = v25;
  return result;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert( char *result, uint64_t a2, void *a3)
{
  int v3 = result[248];
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 15;
  }
  else {
    int v5 = 31;
  }
  if (v4 == v5) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((uint64_t)result, a2, (uint64_t)a3);
  }
  if (v5 == (_DWORD)a2) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert((uint64_t)result, a2, (uint64_t)a3);
  }
  char v7 = result;
  uint64_t v8 = &result[8 * a2];
  if (v4 != (_DWORD)a2)
  {
    uint64_t result = (char *)memmove( &result[8 * a2 + 8],  &result[8 * a2],  8LL * (v3 & 0x7F) - 8LL * a2);
    LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v7[248];
  }

  v7[248] = v3 + 1;
  *(void *)uint64_t v8 = *a3;
  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 98);
  int v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 98))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      uint64_t v5 = result + 88;
      uint64_t v6 = v3 - 1;
      char v7 = (char *)(result + 88 + v3 - 1);
      char v8 = *v7;
      if (!*(_BYTE *)(result + 88 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v3 - 1;
            *(_BYTE *)(result + 98) = v3;
            uint64_t v6 = v3 - 1LL;
            char v8 = *(_BYTE *)(v5 + v6);
          }

          while (!v8);
        }

        char v7 = (char *)(v5 + v6);
      }
    }

    else
    {
      uint64_t v16 = result + 8;
      uint64_t v17 = result + 88;
      do
      {
        uint64_t v18 = *(void *)(v16 + 8 * (v3 - 1LL));
        if (*(char *)(v18 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
        }
        uint64_t v19 = *(void *)(v18 + 8LL * *(unsigned __int8 *)(v17 + v3 - 1LL) + 120);
        *(void *)(v16 + 8LL * dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v19;
        *(_BYTE *)(v17 + dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(v19 + 248) & 0x7F;
        LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(result + 98) + 1;
        *(_BYTE *)(result + 98) = v3;
      }

      while (*((unsigned __int8 *)v4 + 32) != v3);
      uint64_t v20 = v17 + v3;
      char v21 = *(_BYTE *)(v20 - 1);
      char v7 = (char *)(v20 - 1);
      char v8 = v21;
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 98) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 88 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v9 + 248) & 0x7F;
        uint64_t v12 = *(unsigned __int8 *)(result + 98);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 8LL * *(unsigned __int8 *)(v14 + 248) + 120);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 98) = v10;
      }

      while (v13 > v10);
      uint64_t v15 = v10 - 1LL;
    }

    else
    {
      uint64_t v15 = -1LL;
    }

    char v7 = (char *)(result + v15 + 88);
    char v8 = *v7;
  }

  *char v7 = v8 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[98];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(void *)result + 32LL)) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( (uint64_t)result,  a2,  a3);
  }
  int v4 = result;
  uint64_t v5 = result + 8;
  else {
    int v6 = 31;
  }
  if ((*(_BYTE *)(*(void *)&result[8 * v3] + 248LL) & 0x7F) == v6)
  {
    if (!result[98]) {
      goto LABEL_15;
    }
    uint64_t v7 = 0LL;
    unsigned int v8 = 0;
    do
    {
      else {
        int v9 = 31;
      }
      if ((*(_BYTE *)(v5[v7] + 248LL) & 0x7F) != v9) {
        unsigned int v8 = v7;
      }
      ++v7;
    }

    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      else {
        int v10 = 31;
      }
      if ((*(_BYTE *)(*v5 + 248LL) & 0x7F) == v10)
      {
        uint64_t result = (unsigned __int8 *)lsl::Allocator::aligned_alloc( *(lsl::Lock ***)(*(void *)result + 8LL),  0x100uLL,  0x100uLL);
        uint64_t v11 = **(void **)v4;
        result[248] = 0;
        *(_OWORD *)uint64_t result = 0u;
        *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((void *)result + 14) = 0LL;
        *((void *)result + 15) = v11;
        **(void **)int v4 = result;
        if (v4[98] && (uint64_t result = (unsigned __int8 *)memmove(v4 + 89, v4 + 88, v4[98]), v4[98]))
        {
          uint64_t result = (unsigned __int8 *)memmove(v5 + 1, v5, 8LL * v4[98]);
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v4[98] + 1;
        }

        else
        {
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = 1;
        }

        unsigned int v8 = 0;
        v4[88] = 0;
        uint64_t v12 = *(uint64_t **)v4;
        *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = **(void **)v4;
        ++*((_BYTE *)v12 + 32);
        v4[98] = v3;
      }

      else
      {
        unsigned int v8 = 0;
      }
    }

    if (v8 + 1 < v3)
    {
      unsigned int v13 = v4 + 88;
      uint64_t v14 = v8;
      do
      {
        int v15 = v14;
        uint64_t result = (unsigned __int8 *)lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (char *)v5[v14],  v13[v14],  *(lsl::Lock ***)(*(void *)v4 + 8LL));
        uint64_t v18 = v5[v14];
        if (*(char *)(v18 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v16,  v17);
        }
        uint64_t v19 = v13[v14];
        uint64_t v20 = *(void *)(v18 + 8 * v19 + 120);
        unsigned int v21 = v4[v14 + 89];
        if (v21 > (*(_BYTE *)(v20 + 248) & 0x7Fu))
        {
          unsigned __int8 v22 = v19 + 1;
          v13[v14] = v22;
          v4[v14 + 89] = v21 + (~*(_BYTE *)(v20 + 248) | 0x80);
          uint64_t v23 = v5[v14];
          if (*(char *)(v23 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v16,  v17);
          }
          *(void *)&v4[8 * v14 + 16] = *(void *)(v23 + 8LL * v22 + 120);
        }

        ++v14;
      }

      while (v15 + 2 < v4[98]);
    }
  }

  return result;
}

char *lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( char *a1, uint64_t a2, lsl::Lock **this)
{
  if (a1[248] < 0) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  uint64_t v3 = a1[248];
  if (v3 >= 0xF) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  int v4 = a1;
  uint64_t v5 = a1 + 120;
  uint64_t v6 = (uint64_t)&a1[8 * a2 + 120];
  char v7 = *(_BYTE *)(*(void *)v6 + 248LL);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 15;
  }
  else {
    int v10 = 31;
  }
  if (v9 != v10) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 7LL;
  }
  else {
    uint64_t v13 = 15LL;
  }
  uint64_t v14 = &a1[8 * a2];
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    a1 = (char *)memmove(&a1[8 * a2 + 8], &a1[8 * a2], 8 * v3 - 8LL * a2);
    a2 = v4[248];
  }

  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  int v15 = &v5[8 * a2];
  if (v15 != (char *)v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), (size_t)&v15[-v6]);
    LOBYTE(a2) = v4[248];
  }

  v4[248] = a2 + 1;
  *(void *)uint64_t v14 = *(void *)(*(void *)v6 + 8 * v13);
  uint64_t result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  uint64_t v19 = result;
  char v20 = *(_BYTE *)(*(void *)v6 + 248LL);
  result[248] = v20 & 0x80;
  if (v20 < 0)
  {
    *((void *)result + 3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
    __int128 v21 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }

  else
  {
    *((void *)result + 14) = 0LL;
    __int128 v21 = 0uLL;
  }

  *((_OWORD *)result + 5) = v21;
  *((_OWORD *)result + 6) = v21;
  *((_OWORD *)result + 3) = v21;
  *((_OWORD *)result + 4) = v21;
  *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v21;
  *((_OWORD *)result + 2) = v21;
  *(_OWORD *)uint64_t result = v21;
  if (v4[248] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
  }
  char v22 = v9 + ~(_BYTE)v13;
  *(void *)&v5[8 * v12 + 8] = result;
  if (v22) {
    uint64_t result = (char *)memmove( result,  (const void *)(*(void *)v6 + 8 * v13 + 8),  8LL * (v9 + ~(_BYTE)v13));
  }
  uint64_t v23 = *(void *)v6;
  int v24 = *(char *)(*(void *)v6 + 248LL);
  if ((v24 & 0x80000000) == 0)
  {
    if (v19[248] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
    }
    uint64_t result = (char *)memmove( v19 + 120,  (const void *)(v23 + 8 * v13 + 128),  8LL * (v9 + ~(_BYTE)v13) + 8);
    uint64_t v23 = *(void *)v6;
    LOBYTE(v24) = *(_BYTE *)(*(void *)v6 + 248LL);
  }

  *(_BYTE *)(v23 + 248) = v24 + ~v22;
  char v25 = v19[248] + v22;
  v19[248] = v25;
  if (v25 >= 0) {
    int v26 = 15;
  }
  else {
    int v26 = 31;
  }
  if ((v25 & 0x7F) == v26
    || ((char v27 = *(_BYTE *)(v23 + 248), v28 = v27, v29 = v27 & 0x7F, v28 >= 0) ? (v30 = 15) : (v30 = 31), v29 == v30))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v17, v18);
  }

  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::const_iterator( uint64_t a1, uint64_t *a2, void *a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*((_BYTE *)a2 + 32))
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = *a2;
    uint64_t v9 = a1 + 88;
    do
    {
      *(void *)(v4 + 8 * v7) = v8;
      int v10 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>( (void *)v8,  (void *)(v8 + 8LL * (*(_BYTE *)(v8 + 248) & 0x7F)),  a3);
      __int16 v13 = (_WORD)v10 - v8;
      unint64_t v14 = ((unint64_t)v10 - v8) >> 3;
      *(_BYTE *)(v9 + v7) = v14;
      uint64_t v15 = *(void *)(v4 + 8 * v7);
      if ((*(_BYTE *)(v15 + 248) & 0x7F) != v14)
      {
        uint64_t v17 = *(char **)(v15 + (v13 & 0x7F8));
        int v18 = *v17;
        if (v18 < *(char *)*a3)
        {
LABEL_15:
          *(_BYTE *)(a1 + 98) = v7 + 1;
          return a1;
        }

        int v19 = *(unsigned __int8 *)*a3;
        char v20 = (char *)(*a3 + 1LL);
        __int128 v21 = v17 + 1;
        while (v19 && (char)v19 >= (char)v18)
        {
          if ((_BYTE)v18)
          {
            int v22 = *v21++;
            int v18 = v22;
            int v23 = *v20++;
            int v19 = v23;
            if (v18 >= v23) {
              continue;
            }
          }

          goto LABEL_15;
        }
      }

      unint64_t v16 = *((unsigned __int8 *)a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v16)
      {
        if ((*(_BYTE *)(v15 + 248) & 0x80) != 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)v10,  v11,  v12);
        }
        uint64_t v8 = *(void *)(v15 + (v13 & 0x7F8) + 120);
      }

      ++v7;
    }

    while (v7 < v16);
    for (*(_BYTE *)(a1 + 98) = v16; (_BYTE)v16; *(_BYTE *)(a1 + 98) = v16)
    {
      if (*(_BYTE *)(v9 + v16 - 1) != (*(_BYTE *)(*(void *)(v4
                                                                                            + 8LL * v16
                                                                                            - 8)
                                                                                + 248LL) & 0x7F))
        break;
      LOBYTE(v16) = v16 - 1;
    }
  }

  return a1;
}

void *std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<char const**>,std::__wrap_iter<char const**>,char const*,std::__identity,lsl::ConstCharStarCompare>( void *result, void *a2, void *a3)
{
  if (a2 != result)
  {
    unint64_t v3 = a2 - result;
    do
    {
      unint64_t v4 = v3 >> 1;
      uint64_t v5 = &result[v3 >> 1];
      int v6 = *(char *)*v5;
      if (v6 < *(char *)*a3)
      {
LABEL_9:
        uint64_t result = v5 + 1;
        unint64_t v4 = v3 + ~v4;
      }

      else
      {
        unint64_t v7 = (char *)(*v5 + 1LL);
        uint64_t v8 = (char *)(*a3 + 1LL);
        int v9 = *(unsigned __int8 *)*a3;
        while (v9 && (char)v9 >= (char)v6)
        {
          if ((_BYTE)v6)
          {
            int v10 = *v7++;
            int v6 = v10;
            int v11 = *v8++;
            int v9 = v11;
            if (v6 >= v11) {
              continue;
            }
          }

          goto LABEL_9;
        }
      }

      unint64_t v3 = v4;
    }

    while (v4);
  }

  return result;
}

uint64_t lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++( uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(result + 98);
  unint64_t v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 98))
  {
    int v5 = *((unsigned __int8 *)v4 + 32);
    uint64_t v6 = result + 88;
    ++*(_BYTE *)(result + 88 + (v3 - 1));
    if (v3 == v5)
    {
      uint64_t v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(void *)(result
                                                                                           + 8
                                                                                           + 8LL
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 248LL) & 0x7F))
            break;
          *(_BYTE *)(result + 98) = v7 + ~(_BYTE)i;
        }
      }
    }

    else
    {
      int v15 = *(unsigned __int8 *)(result + 98);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        uint64_t v16 = result + 8;
        do
        {
          uint64_t v17 = *(void *)(v16 + 8 * (v15 - 1LL));
          if (*(char *)(v17 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          *(void *)(v16 + 8LL * v15) = *(void *)(v17
                                                                    + 8LL
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1LL)
                                                                    + 120);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 98) + 1;
          *(_BYTE *)(result + 98) = v15;
        }

        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 98) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 88 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
        uint64_t v12 = *(unsigned __int8 *)(result + 98);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 120);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 98) = v10;
      }

      while (v13 > v10);
    }
  }

  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::insert_internal@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v22 = a1;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    memset(v27, 0, sizeof(v27));
    uint64_t result = lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>(a2, (uint64_t)&v22);
    if ((_BYTE)result
      && (uint64_t v9 = *(unsigned __int8 *)(a2 + 98),
          *(void *)(*a3 + 160) >= *(void *)(*(void *)(*(void *)(a2 + 8 + 8 * (v9 - 1))
                                                          + 8LL * *(unsigned __int8 *)(a2 + 88 + v9 - 1))
                                              + 160LL)))
    {
      char v16 = 0;
      __int128 v20 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      __int128 v21 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = v21;
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 8) = v20;
      *(void *)(a4 + 88) = *(void *)(a2 + 88);
      *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
      *(_BYTE *)(a4 + 98) = v9;
    }

    else
    {
      uint64_t v22 = a1;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      memset(v27, 0, sizeof(v27));
      if (lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator<=>( a2,  (uint64_t)&v22)
        && *(unsigned __int8 *)(a2 + 98) == *(unsigned __int8 *)(a1 + 32))
      {
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v10,  v11);
        uint64_t v12 = a2 + 88;
        uint64_t v13 = *(unsigned __int8 *)(a2 + 98) - 1LL;
        unsigned __int8 v14 = *(_BYTE *)(a2 + 88 + v13);
      }

      else
      {
        lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v10, v11);
        lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v17,  v18);
        uint64_t v12 = a2 + 88;
        uint64_t v19 = *(unsigned __int8 *)(a2 + 98) + a2 + 88;
        unsigned __int8 v14 = *(_BYTE *)(v19 - 1) + 1;
        *(_BYTE *)(v19 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v14;
        uint64_t v13 = *(unsigned __int8 *)(a2 + 98) - 1LL;
      }

      uint64_t result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert( *(void *)(a2 + 8 + 8 * v13),  v14,  a3);
      ++*(void *)(a1 + 24);
      *(void *)a4 = *(void *)a2;
      *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(a4 + 88) = *(void *)v12;
      *(_WORD *)(a4 + 96) = *(_WORD *)(v12 + 8);
      *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
      char v16 = 1;
    }
  }

  else
  {
    int v15 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v15 + 248) = 0x80;
    *(_OWORD *)int v15 = 0u;
    *((_OWORD *)v15 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v15 + 2) = 0u;
    *((_OWORD *)v15 + 3) = 0u;
    *((_OWORD *)v15 + 4) = 0u;
    *((_OWORD *)v15 + 5) = 0u;
    *((_OWORD *)v15 + 6) = 0u;
    *((_OWORD *)v15 + 7) = 0u;
    *((_OWORD *)v15 + 8) = 0u;
    *((_OWORD *)v15 + 9) = 0u;
    *((_OWORD *)v15 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)v15 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v15 + 12) = 0u;
    *((_OWORD *)v15 + 13) = 0u;
    *((_OWORD *)v15 + 14) = 0u;
    v15[30] = 0LL;
    *(void *)a1 = v15;
    char v16 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v15;
    *(_BYTE *)(a2 + 98) = 1;
    uint64_t result = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert( (uint64_t)v15,  0LL,  a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(a4 + 88) = *(void *)(a2 + 88);
    *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
    *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  }

  *(_BYTE *)(a4 + 104) = v16;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::insert( uint64_t result, uint64_t a2, uint64_t *a3)
{
  int v3 = *(char *)(result + 248);
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 15;
  }
  else {
    int v5 = 31;
  }
  if (v4 == v5) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(result, a2, (uint64_t)a3);
  }
  if (v5 == (_DWORD)a2) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(result, a2, (uint64_t)a3);
  }
  uint64_t v6 = (uint64_t *)(result + 8LL * a2);
  if (v4 != (_DWORD)a2)
  {
    uint64_t v7 = (uint64_t *)(result + 8LL * (v3 & 0x7F));
    uint64_t v10 = *v7;
    uint64_t v8 = v7 - 1;
    uint64_t v9 = v10;
    uint64_t v11 = 8LL * a2 - 8LL * (v3 & 0x7F);
    do
    {
      uint64_t v12 = *v8;
      *uint64_t v8 = v9;
      v8[1] = v12;
      --v8;
      v11 += 8LL;
    }

    while (v11);
  }

  *(_BYTE *)(result + 248) = v3 + 1;
  if (v6 != a3)
  {
    uint64_t v13 = *v6;
    *uint64_t v6 = *a3;
    *a3 = v13;
  }

  return result;
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::prepareForInsertion( unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[98];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(void *)result + 32LL)) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( (uint64_t)result,  a2,  a3);
  }
  int v4 = result;
  int v5 = result + 8;
  else {
    int v6 = 31;
  }
  if ((*(_BYTE *)(*(void *)&result[8 * v3] + 248LL) & 0x7F) == v6)
  {
    if (!result[98]) {
      goto LABEL_15;
    }
    uint64_t v7 = 0LL;
    unsigned int v8 = 0;
    do
    {
      else {
        int v9 = 31;
      }
      if ((*(_BYTE *)(v5[v7] + 248LL) & 0x7F) != v9) {
        unsigned int v8 = v7;
      }
      ++v7;
    }

    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      else {
        int v10 = 31;
      }
      if ((*(_BYTE *)(*v5 + 248LL) & 0x7F) == v10)
      {
        uint64_t v11 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(*(void *)result + 8LL), 0x100uLL, 0x100uLL);
        uint64_t result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore( (uint64_t)v11,  **(void **)v4,  v12);
        **(void **)int v4 = result;
        if (v4[98] && (uint64_t result = (unsigned __int8 *)memmove(v4 + 89, v4 + 88, v4[98]), v4[98]))
        {
          uint64_t result = (unsigned __int8 *)memmove(v5 + 1, v5, 8LL * v4[98]);
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v4[98] + 1;
        }

        else
        {
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = 1;
        }

        unsigned int v8 = 0;
        v4[88] = 0;
        uint64_t v13 = *(uint64_t **)v4;
        *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = **(void **)v4;
        ++*((_BYTE *)v13 + 32);
        v4[98] = v3;
      }

      else
      {
        unsigned int v8 = 0;
      }
    }

    if (v8 + 1 < v3)
    {
      unsigned __int8 v14 = v4 + 88;
      uint64_t v15 = v8;
      do
      {
        int v16 = v15;
        uint64_t result = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild( v5[v15],  v14[v15],  *(lsl::Lock ***)(*(void *)v4 + 8LL));
        uint64_t v19 = v5[v15];
        if (*(char *)(v19 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
        }
        uint64_t v20 = v14[v15];
        uint64_t v21 = *(void *)(v19 + 8 * v20 + 120);
        unsigned int v22 = v4[v15 + 89];
        if (v22 > (*(_BYTE *)(v21 + 248) & 0x7Fu))
        {
          unsigned __int8 v23 = v20 + 1;
          v14[v15] = v23;
          v4[v15 + 89] = v22 + (~*(_BYTE *)(v21 + 248) | 0x80);
          uint64_t v24 = v5[v15];
          if (*(char *)(v24 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
          }
          *(void *)&v4[8 * v15 + 16] = *(void *)(v24 + 8LL * v23 + 120);
        }

        ++v15;
      }

      while (v16 + 2 < v4[98]);
    }
  }

  return result;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::splitChild( uint64_t a1, uint64_t a2, lsl::Lock **this)
{
  unsigned int v3 = *(unsigned __int8 *)(a1 + 248);
  if (v3 >= 0xF) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(a1, a2, (uint64_t)this);
  }
  uint64_t v5 = a1 + 120;
  uint64_t v6 = a1 + 120 + 8LL * a2;
  char v7 = *(_BYTE *)(*(void *)v6 + 248LL);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 15;
  }
  else {
    int v10 = 31;
  }
  if (v9 != v10) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild(a1, a2, (uint64_t)this);
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 248);
  uint64_t v13 = v12 + 1;
  uint64_t v14 = a2;
  if (v8 >= 0) {
    uint64_t v15 = 7LL;
  }
  else {
    uint64_t v15 = 15LL;
  }
  if (v3 != (_DWORD)a2)
  {
    int v16 = (uint64_t *)(a1 + 8 * v12);
    uint64_t v19 = *v16;
    uint64_t v17 = v16 - 1;
    uint64_t v18 = v19;
    uint64_t v20 = 8LL * a2 - 8 * v12;
    do
    {
      uint64_t v21 = *v17;
      *uint64_t v17 = v18;
      v17[1] = v21;
      --v17;
      v20 += 8LL;
    }

    while (v20);
  }

  unsigned int v22 = (uint64_t *)(a1 + 8LL * a2);
  uint64_t v23 = v5 + 8 * v13;
  if (v23 != v6 + 8)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), v23 - (v6 + 8));
    LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(a1 + 248);
  }

  *(_BYTE *)(a1 + 248) = v3 + 1;
  uint64_t v24 = (uint64_t *)(*(void *)v6 + 8 * v15);
  if (v24 != v22)
  {
    uint64_t v25 = *v22;
    uint64_t *v22 = *v24;
    uint64_t *v24 = v25;
  }

  uint64_t result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  int v29 = result;
  int v30 = *(char *)(*(void *)v6 + 248LL);
  result[248] = *(_BYTE *)(*(void *)v6 + 248LL) & 0x80;
  if (v30 < 0)
  {
    *((void *)result + 3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
    __int128 v31 = 0uLL;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
  }

  else
  {
    *((void *)result + 14) = 0LL;
    __int128 v31 = 0uLL;
  }

  *((_OWORD *)result + 5) = v31;
  *((_OWORD *)result + 6) = v31;
  *((_OWORD *)result + 3) = v31;
  *((_OWORD *)result + 4) = v31;
  *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v31;
  *((_OWORD *)result + 2) = v31;
  *(_OWORD *)uint64_t result = v31;
  if (*(char *)(a1 + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v27,  v28);
  }
  char v32 = v9 + ~(_BYTE)v15;
  __int128 v33 = (uint64_t *)(v5 + 8 * v14);
  v33[1] = (uint64_t)result;
  uint64_t v34 = *v33;
  if (v32)
  {
    __int128 v35 = (uint64_t *)(v34 + 8 * v15 + 8);
    uint64_t v36 = 8LL * (v9 + ~(_BYTE)v15);
    uint64_t v37 = (uint64_t *)result;
    do
    {
      if (v35 != v37)
      {
        uint64_t v38 = *v37;
        *uint64_t v37 = *v35;
        *__int128 v35 = v38;
      }

      ++v35;
      ++v37;
      v36 -= 8LL;
    }

    while (v36);
    uint64_t v34 = *(void *)v6;
  }

  int v39 = *(char *)(v34 + 248);
  if ((v39 & 0x80000000) == 0)
  {
    if (v30 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v27,  v28);
    }
    uint64_t result = (char *)memmove( result + 120,  (const void *)(v34 + 8 * v15 + 128),  8LL * (v9 + ~(_BYTE)v15) + 8);
    uint64_t v34 = *(void *)v6;
    LOBYTE(v39) = *(_BYTE *)(*(void *)v6 + 248LL);
  }

  *(_BYTE *)(v34 + 248) = v39 + ~v32;
  char v40 = v29[248] + v32;
  v29[248] = v40;
  if (v40 >= 0) {
    int v41 = 15;
  }
  else {
    int v41 = 31;
  }
  if ((v40 & 0x7F) == v41
    || ((char v42 = *(_BYTE *)(v34 + 248), v43 = v42, v44 = v42 & 0x7F, v43 >= 0) ? (v45 = 15) : (v45 = 31), v44 == v45))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v27, v28);
  }

  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::NodeCore( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  *(_BYTE *)(result + 248) = 0;
  do
  {
    *(void *)(result + dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = 0LL;
    v3 += 8LL;
  }

  while (v3 != 120);
  if (*(char *)(result + 248) < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
  }
  *(void *)(result + 12dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2;
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::const_iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 83) = 0u;
  if (*(_BYTE *)(a2 + 32))
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = *(void *)a2;
    uint64_t v9 = a1 + 88;
    do
    {
      uint64_t v10 = v9 + 8 * v7;
      *(void *)(v10 - 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v8;
      uint64_t v11 = lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index( v8,  a3);
      *(_BYTE *)(v9 + v7) = v11;
      uint64_t v14 = *(void *)(v10 - 80);
      int v15 = *(char *)(v14 + 248);
      if ((_DWORD)v11 != (v15 & 0x7F)
        && *(void *)(*(void *)(v14 + 8LL * v11) + 160LL) < *(void *)(*(void *)a3 + 160LL))
      {
        *(_BYTE *)(a1 + 98) = v7 + 1;
        return a1;
      }

      unint64_t v16 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v16)
      {
        if (v15 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( v11,  v12,  v13);
        }
        uint64_t v8 = *(void *)(v14 + 8LL * v11 + 120);
      }

      ++v7;
    }

    while (v7 < v16);
    for (*(_BYTE *)(a1 + 98) = v16; (_BYTE)v16; *(_BYTE *)(a1 + 98) = v16)
    {
      if (*(_BYTE *)(v9 + v16 - 1) != (*(_BYTE *)(*(void *)(v4
                                                                                            + 8LL * v16
                                                                                            - 8)
                                                                                + 248LL) & 0x7F))
        break;
      LOBYTE(v16) = v16 - 1;
    }
  }

  return a1;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::lower_bound_index( uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(_BYTE *)(a1 + 248) & 0x7F;
  if ((*(_BYTE *)(a1 + 248) & 0x7F) != 0)
  {
    uint64_t v3 = (void *)a1;
    do
    {
      unint64_t v4 = v2 >> 1;
      uint64_t v5 = &v3[v2 >> 1];
      uint64_t v7 = *v5;
      uint64_t v6 = v5 + 1;
      v2 += ~(v2 >> 1);
      if (*(void *)(v7 + 160) < *(void *)(*(void *)a2 + 160LL)) {
        uint64_t v3 = v6;
      }
      else {
        unint64_t v2 = v4;
      }
    }

    while (v2);
  }

  else
  {
    LODWORD(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = a1 + 8 * v2;
  }

  return (((_DWORD)v3 - a1) >> 3);
}

__n128 lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(unsigned __int8 *)(a2 + 98);
  int v8 = *(unsigned __int8 *)(a1 + 32);
  unsigned int v9 = v7;
  if ((_DWORD)v7 != v8)
  {
    uint64_t v10 = (os_unfair_lock_s **)(*(void *)(a2 + 8 + 8 * (v7 - 1)) + 8LL * *(unsigned __int8 *)(a2 + 88 + v7 - 1));
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator++(a2, a2, a3);
    uint64_t v23 = 0LL;
    if (&v23 == v10)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v12 = *v10;
      uint64_t v23 = *v10;
      *uint64_t v10 = 0LL;
    }

    if (v11 != v10)
    {
      uint64_t v13 = *v10;
      *uint64_t v10 = *v11;
      *uint64_t v11 = v13;
    }

    if (&v23 != v11)
    {
      uint64_t v14 = *v11;
      *uint64_t v11 = v12;
      uint64_t v23 = v14;
    }

    lsl::UniquePtr<dyld4::Atlas::Image>::~UniquePtr(&v23);
    unsigned int v9 = *(unsigned __int8 *)(a2 + 98);
  }

  uint64_t v15 = v9 - 1LL;
  uint64_t v16 = *(void *)(a2 + 8 + 8 * v15);
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase( v16,  *(unsigned __int8 *)(a2 + 88 + v15));
  lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure( (unsigned __int8 *)a2,  v17);
  if ((_DWORD)v7 != v8) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::operator--(a2, v18, v19);
  }
  --*(void *)(a1 + 24);
  __int128 v20 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
  __int128 v21 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a4 + 56) = v21;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a4 + 72) = result;
  *(void *)a4 = *(void *)a2;
  *(_OWORD *)(a4 + 8) = v20;
  *(void *)(a4 + 88) = *(void *)(a2 + 88);
  *(_WORD *)(a4 + 96) = *(_WORD *)(a2 + 96);
  *(_BYTE *)(a4 + 98) = *(_BYTE *)(a2 + 98);
  return result;
}

uint64_t lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase( uint64_t result, unsigned int a2)
{
  int v2 = *(char *)(result + 248);
  if ((v2 & 0x80000000) == 0) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase();
  }
  uint64_t v3 = v2 & 0x7F;
  unint64_t v4 = (uint64_t *)(result + 8LL * a2);
  uint64_t v5 = v4 + 1;
  if (v4 + 1 != (uint64_t *)(result + 8LL * (v2 & 0x7F)))
  {
    uint64_t v6 = *v4;
    uint64_t v7 = 8 * v3 - 8LL * a2 - 8;
    do
    {
      *(v5 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = *v5;
      *v5++ = v6;
      v7 -= 8LL;
    }

    while (v7);
  }

  *(_BYTE *)(result + 248) = v2 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure( unsigned __int8 *__dst, uint64_t a2)
{
  unsigned int v2 = __dst[98];
  uint64_t v3 = *(void *)__dst;
  unint64_t v4 = __dst;
  if (v2 >= 2)
  {
    unsigned __int8 v5 = 0;
    uint64_t v6 = __dst + 8;
    uint64_t v7 = __dst + 88;
    do
    {
      uint64_t v8 = (v2 - v5 - 2);
      uint64_t v9 = v8 + 1;
      else {
        unsigned int v10 = 15;
      }
      if ((*(_BYTE *)(*(void *)&v6[8 * v8 + 8] + 248LL) & 0x7Fu) >= v10) {
        break;
      }
      uint64_t v11 = v7[v8];
      uint64_t v12 = *(char **)&v6[8 * v8];
      int v13 = v12[248];
      if ((_DWORD)v11 == (v13 & 0x7F))
      {
        int v14 = 0;
        if (v7[v8]) {
          goto LABEL_10;
        }
      }

      else
      {
        if (v13 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)v12,  a2,  v11);
        }
        else {
          int v19 = -15;
        }
        int v14 = v19 + (*(_BYTE *)(*(void *)&v12[8 * v11 + 128] + 248LL) & 0x7F);
        if (v7[v8])
        {
LABEL_10:
          if (v13 < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)v12,  a2,  v11);
          }
          int v15 = *(char *)(*(void *)&v12[8 * v11 + 112] + 248LL);
          char v16 = v15 & 0x7F;
          if (v15 >= 0) {
            char v17 = -7;
          }
          else {
            char v17 = -15;
          }
          char v18 = v17 + v16;
          goto LABEL_21;
        }
      }

      char v18 = 0;
LABEL_21:
      if (v14 < 1 || v14 < v18)
      {
        if (v18 < 1 || v14 >= v18)
        {
          if ((_DWORD)v11 == (v13 & 0x7F))
          {
            if (v13 < 0) {
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)v12,  a2,  v11);
            }
            v7[v8] = v11 - 1;
            v7[v9] += (*(_BYTE *)(*(void *)&v12[8 * (v11 - 1) + 120] + 248LL) & 0x7F) + 1;
            uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge( *(char **)&v6[8 * v8],  *(lsl::Lock ***)(v3 + 8),  (v11 - 1));
            uint64_t v24 = *(void *)&v6[8 * v8];
            if (*(char *)(v24 + 248) < 0) {
              lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)__dst,  a2,  v23);
            }
            *(void *)&v6[8 * v9] = *(void *)(v24 + 8LL * v7[v8] + 120);
          }

          else
          {
            uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge( v12,  *(lsl::Lock ***)(v3 + 8),  v11);
          }
        }

        else
        {
          if (v13 < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)v12,  a2,  v11);
          }
          char v20 = *(_BYTE *)(*(void *)&v12[8 * v11 + 120] + 248LL);
          uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft( v12,  v7[v8],  v11);
          uint64_t v22 = *(void *)&v6[8 * v8];
          if (*(char *)(v22 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)__dst,  a2,  v21);
          }
          v7[v9] += (*(_BYTE *)(*(void *)(v22 + 8LL * v7[v8] + 120) + 248LL) & 0x7F) - (v20 & 0x7F);
        }
      }

      else
      {
        uint64_t __dst = (unsigned __int8 *)lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight( v12,  v7[v8],  v11);
      }

      ++v5;
      uint64_t v3 = *(void *)v4;
      unsigned int v2 = *(unsigned __int8 *)(*(void *)v4 + 32LL);
    }

    while ((int)(v2 - 1) > v5);
  }

  uint64_t v25 = v4 + 8;
  if ((*(_BYTE *)(*((void *)v4 + 1) + 248LL) & 0x7F) != 0)
  {
    unsigned __int8 v26 = *(_BYTE *)(v3 + 32);
  }

  else
  {
    uint64_t v27 = (char *)(v4 + 88);
    if (v4[88]) {
      lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure();
    }
    uint64_t v28 = v4[98];
    if (&v27[v28] != (char *)(v4 + 89))
    {
      memmove(v27, v4 + 89, v28 - 1);
      uint64_t v28 = v4[98];
    }

    int v29 = (unsigned __int8 *)&v25[v28];
    if (v29 != v4 + 16)
    {
      memmove(v4 + 8, v4 + 16, v29 - (v4 + 16));
      LOBYTE(v28) = v4[98];
    }

    v4[98] = v28 - 1;
    uint64_t __dst = (unsigned __int8 *)lsl::Allocator::free(*(lsl::Lock ***)(v3 + 8), *(void **)v3);
    int v30 = *(void **)v4;
    unsigned __int8 v26 = *(_BYTE *)(*(void *)v4 + 32LL) - 1;
    *(_BYTE *)(*(void *)v4 + 32LL) = v26;
    if (v4[98]) {
      void *v30 = *v25;
    }
    else {
      void *v30 = 0LL;
    }
  }

  if (v26)
  {
    uint64_t v31 = 0LL;
    do
    {
      if ((*(_BYTE *)(v25[(v26 + ~(_BYTE)v31)] + 248LL) & 0x7F) != v4[(v26 + ~(_BYTE)v31)
                                                                                      + 88])
        break;
      --v4[98];
      ++v31;
    }

    while (v26 != v31);
  }

  return __dst;
}

char *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromRight( char *result, uint64_t a2, uint64_t a3)
{
  if (result[248] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  a2,  a3);
  }
  uint64_t v3 = &result[8 * a2];
  uint64_t v5 = *((void *)v3 + 15);
  uint64_t v4 = *((void *)v3 + 16);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 248);
  int v7 = *(char *)(v4 + 248);
  uint64_t v8 = v7 & 0x7F;
  unsigned int v9 = v8 + (v6 & 0x7F);
  int v10 = v8 - (v9 >> 1);
  uint64_t v11 = (char *)(v5 + 8 * (v6 & 0x7F));
  if (v3 != v11)
  {
    uint64_t v12 = *(void *)v11;
    *(void *)uint64_t v11 = *(void *)v3;
    *(void *)uint64_t v3 = v12;
  }

  unsigned int v13 = v9 >> 1;
  uint64_t v14 = ((v7 & 0x7F) - (v9 >> 1));
  int v15 = (char *)(v4 + 8LL * v10 - 8);
  if (v15 != v3)
  {
    uint64_t v16 = *(void *)v3;
    *(void *)uint64_t v3 = *(void *)v15;
    *(void *)int v15 = v16;
  }

  uint64_t v17 = 8 * v14;
  if ((_DWORD)v8 != v13)
  {
    char v18 = (uint64_t *)(v5 + 8 * (v6 & 0x7F) + 8);
    uint64_t v19 = 8 * v14;
    char v20 = (uint64_t *)v4;
    do
    {
      if (v20 != v18)
      {
        uint64_t v21 = *v18;
        *char v18 = *v20;
        uint64_t *v20 = v21;
      }

      ++v20;
      ++v18;
      v19 -= 8LL;
    }

    while (v19);
  }

  if (v9 >= 2)
  {
    uint64_t v22 = 8 * v8;
    uint64_t v23 = (uint64_t *)v4;
    do
    {
      if (v17)
      {
        uint64_t v24 = *v23;
        uint64_t *v23 = v23[v14];
        v23[v14] = v24;
      }

      ++v23;
      v22 -= 8LL;
    }

    while (v17 != v22);
  }

  if ((v6 & 0x80) == 0)
  {
    if (v7 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  a2,  v17);
    }
    if ((_DWORD)v8 != v13)
    {
      __n128 result = (char *)memmove((void *)(v5 + 8 * v6 + 128), (const void *)(v4 + 120), v17);
      int v7 = *(char *)(v4 + 248);
      if (v7 < 0) {
        lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v25,  v26);
      }
    }

    uint64_t v27 = v7 + 1LL;
    if (v27 != v14) {
      __n128 result = (char *)memmove((void *)(v4 + 120), (const void *)(v4 + 120 + 8 * v14), 8 * v27 - 8 * v14);
    }
  }

  *(_BYTE *)(v5 + 248) += v10;
  *(_BYTE *)(v4 + 248) -= v10;
  return result;
}

void *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::rotateFromLeft( void *result, uint64_t a2, uint64_t a3)
{
  if ((char)result[31] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  a2,  a3);
  }
  uint64_t v3 = a2 - 1LL;
  uint64_t v4 = result[v3 + 15];
  uint64_t v5 = result[a2 + 15];
  LOBYTE(v6) = *(_BYTE *)(v4 + 248);
  uint64_t v7 = v6 & 0x7F;
  uint64_t v8 = *(unsigned __int8 *)(v5 + 248);
  unsigned int v9 = (v8 & 0x7F) + (v6 & 0x7F);
  uint64_t v10 = ((v6 & 0x7F) - (v9 >> 1));
  if ((v8 & 0x7F) != 0)
  {
    uint64_t v11 = 8 * (v8 & 0x7F);
    uint64_t v12 = v5 + 8 * v10;
    do
    {
      if (v5 != v12)
      {
        uint64_t v13 = *(void *)(v12 + v11 - 8);
        *(void *)(v12 + v11 - 8) = *(void *)(v5 + v11 - 8);
        *(void *)(v5 + v11 - 8) = v13;
      }

      v11 -= 8LL;
    }

    while (v11);
  }

  uint64_t v14 = v4 + 8 * v7;
  if (v14 - 8 * v10 + 8 != v14)
  {
    uint64_t v15 = 8 - 8 * v10;
    uint64_t v16 = (uint64_t *)v5;
    do
    {
      uint64_t v17 = (uint64_t *)(v14 + v15);
      if ((uint64_t *)(v14 + v15) != v16)
      {
        uint64_t v18 = *v16;
        uint64_t *v16 = *v17;
        *uint64_t v17 = v18;
      }

      ++v16;
      v15 += 8LL;
    }

    while (v15);
  }

  uint64_t v19 = &result[v3];
  char v20 = (uint64_t *)(v5 + 8 * v10 - 8);
  if (v19 != v20)
  {
    uint64_t v21 = *v20;
    uint64_t *v20 = *v19;
    uint64_t *v19 = v21;
  }

  uint64_t v22 = (uint64_t *)(v4 + 8LL * ((int)v7 - (int)v10));
  if (v22 != v19)
  {
    uint64_t v23 = *v19;
    uint64_t *v19 = *v22;
    uint64_t *v22 = v23;
  }

  if (((char)v6 & 0x80000000) == 0)
  {
    if ((v8 & 0x80) != 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  a2,  a3);
    }
    __n128 result = memmove((void *)(v5 + 120 + 8 * v8 + 8 + 8 * v10 + 8 * ~v8), (const void *)(v5 + 120), 8 * v8 + 8);
    int v6 = *(char *)(v4 + 248);
    if (v6 < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v24,  v25);
    }
    if (*(char *)(v5 + 248) < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v24,  v25);
    }
    if ((_DWORD)v7 != v9 >> 1)
    {
      __n128 result = memmove( (void *)(v5 + 120),  (const void *)(v4 + 8LL * *(unsigned __int8 *)(v4 + 248) + 128 - 8 * v10),  8 * v10);
      LOBYTE(v6) = *(_BYTE *)(v4 + 248);
    }
  }

  *(_BYTE *)(v4 + 248) = v6 - v10;
  *(_BYTE *)(v5 + 248) += v10;
  return result;
}

os_unfair_lock_s *lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge( char *a1, lsl::Lock **this, unsigned int a3)
{
  if (a1[248] < 0) {
    lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge();
  }
  uint64_t v3 = a1[248];
  uint64_t v5 = a1;
  int v6 = &a1[8 * a3 + 120];
  uint64_t v8 = *(void *)v6;
  uint64_t v7 = *((void *)v6 + 1);
  unsigned int v9 = &a1[8 * a3];
  unsigned int v10 = *(unsigned __int8 *)(*(void *)v6 + 248LL);
  uint64_t v11 = v10 & 0x7F;
  uint64_t v12 = (char *)(*(void *)v6 + 8 * v11);
  if (v9 != v12)
  {
    uint64_t v13 = *(void *)v12;
    *(void *)uint64_t v12 = *(void *)v9;
    *(void *)unsigned int v9 = v13;
  }

  uint64_t v14 = v3 + 1;
  uint64_t v15 = v9 + 8;
  if (v9 + 8 != &a1[8 * v3])
  {
    uint64_t v16 = *(void *)v9;
    uint64_t v17 = 8 * v3 - 8LL * a3 - 8;
    do
    {
      *(v15 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = *v15;
      *v15++ = v16;
      v17 -= 8LL;
    }

    while (v17);
  }

  uint64_t v18 = v6 + 16;
  uint64_t v19 = (uint64_t)&a1[8 * v14 + 120];
  size_t v20 = v19 - (void)(v6 + 16);
  if ((char *)v19 != v6 + 16)
  {
    a1 = (char *)memmove(v6 + 8, v18, v20);
    unsigned int v10 = *(unsigned __int8 *)(v8 + 248);
    uint64_t v11 = v10 & 0x7F;
  }

  uint64_t v21 = *(unsigned __int8 *)(v7 + 248);
  uint64_t v22 = v21 & 0x7F;
  if ((v21 & 0x7F) != 0)
  {
    uint64_t v23 = (uint64_t *)(v8 + 8 * v11 + 8);
    uint64_t v24 = 8 * v22;
    uint64_t v25 = (uint64_t *)v7;
    do
    {
      if (v25 != v23)
      {
        uint64_t v26 = *v23;
        uint64_t *v23 = *v25;
        *uint64_t v25 = v26;
      }

      ++v25;
      ++v23;
      v24 -= 8LL;
    }

    while (v24);
  }

  if ((v10 & 0x80) == 0)
  {
    if ((v21 & 0x80) != 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)a1,  (uint64_t)v18,  v20);
    }
    memmove((void *)(v8 + 8LL * v10 + 128), (const void *)(v7 + 120), 8 * v21 + 8);
    LOBYTE(v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v8 + 248);
    LOBYTE(v22) = *(_BYTE *)(v7 + 248) & 0x7F;
  }

  *(_BYTE *)(v8 + 248) = v22 + v10 + 1;
  --v5[248];
  return lsl::Allocator::free(this, (void *)v7);
}

void lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::insert_internal( uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)a1)
  {
    uint64_t v26 = a1;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    memset(v32, 0, sizeof(v32));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>( a2,  (uint64_t)&v26))
    {
      uint64_t v8 = 0LL;
      uint64_t v9 = *(unsigned __int8 *)(a2 + 116);
      while (1)
      {
        unsigned int v10 = a3->n128_u8[v8];
        unsigned int v11 = *(unsigned __int8 *)(*(void *)(a2 + 8 + 8 * (v9 - 1))
        if (v10 < v11) {
          break;
        }
        if (v11 < v10 || v8++ == 15)
        {
          char v13 = 0;
          __int128 v14 = *(_OWORD *)(a2 + 56);
          *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
          *(_OWORD *)(a4 + 56) = v14;
          __int128 v15 = *(_OWORD *)(a2 + 88);
          *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
          *(_OWORD *)(a4 + 88) = v15;
          __int128 v16 = *(_OWORD *)(a2 + 24);
          *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
          *(void *)a4 = *(void *)a2;
          *(_OWORD *)(a4 + 24) = v16;
          *(void *)(a4 + 104) = *(void *)(a2 + 104);
          *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
          *(_BYTE *)(a4 + 116) = v9;
          goto LABEL_17;
        }
      }
    }

    uint64_t v26 = a1;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    memset(v32, 0, sizeof(v32));
    if (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>( a2,  (uint64_t)&v26)
      && *(unsigned __int8 *)(a2 + 116) == *(unsigned __int8 *)(a1 + 32))
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v17,  v18);
      uint64_t v19 = a2 + 104;
      uint64_t v20 = *(unsigned __int8 *)(a2 + 116) - 1LL;
      unsigned __int8 v21 = *(_BYTE *)(a2 + 104 + v20);
    }

    else
    {
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--(a2, v17, v18);
      lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion( (unsigned __int8 *)a2,  v23,  v24);
      uint64_t v19 = a2 + 104;
      uint64_t v25 = *(unsigned __int8 *)(a2 + 116) + a2 + 104;
      unsigned __int8 v21 = *(_BYTE *)(v25 - 1) + 1;
      *(_BYTE *)(v25 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v21;
      uint64_t v20 = *(unsigned __int8 *)(a2 + 116) - 1LL;
    }

    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert(*(void *)(a2 + 8 + 8 * v20), v21, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a4 + 104) = *(void *)v19;
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(v19 + 8);
    *(_BYTE *)(a4 + 116) = *(_BYTE *)(a2 + 116);
    char v13 = 1;
  }

  else
  {
    uint64_t v22 = lsl::Allocator::aligned_alloc(*(lsl::Lock ***)(a1 + 8), 0x100uLL, 0x100uLL);
    *((_BYTE *)v22 + 248) = 0x80;
    *(_OWORD *)uint64_t v22 = 0u;
    *((_OWORD *)v22 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v22 + 2) = 0u;
    *((_OWORD *)v22 + 3) = 0u;
    *((_OWORD *)v22 + 4) = 0u;
    *((_OWORD *)v22 + 5) = 0u;
    *((_OWORD *)v22 + 6) = 0u;
    *((_OWORD *)v22 + 7) = 0u;
    *((_OWORD *)v22 + 8) = 0u;
    *((_OWORD *)v22 + 9) = 0u;
    *((_OWORD *)v22 + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
    *((_OWORD *)v22 + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
    *((_OWORD *)v22 + 12) = 0u;
    *((_OWORD *)v22 + 13) = 0u;
    *((_OWORD *)v22 + 14) = 0u;
    *(void *)a1 = v22;
    char v13 = 1;
    *(_BYTE *)(a1 + 32) = 1;
    *(void *)(a2 + 8) = v22;
    *(_BYTE *)(a2 + 116) = 1;
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert((uint64_t)v22, 0LL, a3);
    ++*(void *)(a1 + 24);
    *(void *)a4 = *(void *)a2;
    *(_OWORD *)(a4 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a4 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a4 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a4 + 104) = *(void *)(a2 + 104);
    *(_DWORD *)(a4 + 112) = *(_DWORD *)(a2 + 112);
    *(_BYTE *)(a4 + 116) = *(_BYTE *)(a2 + 116);
  }

__n128 lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::insert( uint64_t a1, uint64_t a2, __n128 *a3)
{
  int v3 = *(char *)(a1 + 248);
  int v4 = v3 & 0x7F;
  if (v3 >= 0) {
    int v5 = 10;
  }
  else {
    int v5 = 15;
  }
  if (v4 == v5) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(a1, a2, (uint64_t)a3);
  }
  if (v5 == (_DWORD)a2) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert(a1, a2, (uint64_t)a3);
  }
  uint64_t v8 = (__n128 *)(a1 + 16LL * a2);
  if (v4 != (_DWORD)a2)
  {
    memmove( (void *)(a1 + 16LL * a2 + 16),  (const void *)(a1 + 16LL * a2),  16LL * (v3 & 0x7F) - 16LL * a2);
    LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(a1 + 248);
  }

  *(_BYTE *)(a1 + 248) = v3 + 1;
  __n128 result = *a3;
  *uint64_t v8 = *a3;
  return result;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator--( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 116);
  int v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 116))
  {
    if ((_DWORD)v3 == *((unsigned __int8 *)v4 + 32))
    {
      uint64_t v5 = result + 104;
      uint64_t v6 = v3 - 1;
      uint64_t v7 = (char *)(result + 104 + v3 - 1);
      char v8 = *v7;
      if (!*(_BYTE *)(result + 104 + (v3 - 1)))
      {
        if (!*v7)
        {
          do
          {
            LODWORD(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v3 - 1;
            *(_BYTE *)(result + 116) = v3;
            uint64_t v6 = v3 - 1LL;
            char v8 = *(_BYTE *)(v5 + v6);
          }

          while (!v8);
        }

        uint64_t v7 = (char *)(v5 + v6);
      }
    }

    else
    {
      uint64_t v16 = result + 8;
      uint64_t v17 = result + 104;
      do
      {
        uint64_t v18 = *(void *)(v16 + 8 * (v3 - 1LL));
        if (*(char *)(v18 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
        }
        uint64_t v19 = *(void *)(v18 + 8LL * *(unsigned __int8 *)(v17 + v3 - 1LL) + 160);
        *(void *)(v16 + 8LL * dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v19;
        *(_BYTE *)(v17 + dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(v19 + 248) & 0x7F;
        LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = *(_BYTE *)(result + 116) + 1;
        *(_BYTE *)(result + 116) = v3;
      }

      while (*((unsigned __int8 *)v4 + 32) != v3);
      uint64_t v20 = v17 + v3;
      char v21 = *(_BYTE *)(v20 - 1);
      uint64_t v7 = (char *)(v20 - 1);
      char v8 = v21;
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 116) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 104 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_BYTE *)(v9 + 248) & 0x7F;
        uint64_t v12 = *(unsigned __int8 *)(result + 116);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 8LL * *(unsigned __int8 *)(v14 + 248) + 160);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 116) = v10;
      }

      while (v13 > v10);
      uint64_t v15 = v10 - 1LL;
    }

    else
    {
      uint64_t v15 = -1LL;
    }

    uint64_t v7 = (char *)(result + v15 + 104);
    char v8 = *v7;
  }

  *uint64_t v7 = v8 - 1;
  return result;
}

unsigned __int8 *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::prepareForInsertion( unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[116];
  if ((_DWORD)v3 != *(unsigned __int8 *)(*(void *)result + 32LL)) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( (uint64_t)result,  a2,  a3);
  }
  int v4 = result;
  uint64_t v5 = result + 8;
  else {
    int v6 = 15;
  }
  if ((*(_BYTE *)(*(void *)&result[8 * v3] + 248LL) & 0x7F) == v6)
  {
    if (!result[116]) {
      goto LABEL_15;
    }
    uint64_t v7 = 0LL;
    unsigned int v8 = 0;
    do
    {
      else {
        int v9 = 15;
      }
      if ((*(_BYTE *)(v5[v7] + 248LL) & 0x7F) != v9) {
        unsigned int v8 = v7;
      }
      ++v7;
    }

    while (v3 != v7);
    if (!v8)
    {
LABEL_15:
      else {
        int v10 = 15;
      }
      if ((*(_BYTE *)(*v5 + 248LL) & 0x7F) == v10)
      {
        __n128 result = (unsigned __int8 *)lsl::Allocator::aligned_alloc( *(lsl::Lock ***)(*(void *)result + 8LL),  0x100uLL,  0x100uLL);
        uint64_t v11 = **(void **)v4;
        result[248] = 0;
        *(_OWORD *)__n128 result = 0u;
        *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((void *)result + 2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v11;
        **(void **)int v4 = result;
        if (v4[116] && (__n128 result = (unsigned __int8 *)memmove(v4 + 105, v4 + 104, v4[116]), v4[116]))
        {
          __n128 result = (unsigned __int8 *)memmove(v5 + 1, v5, 8LL * v4[116]);
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v4[116] + 1;
        }

        else
        {
          LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = 1;
        }

        unsigned int v8 = 0;
        v4[104] = 0;
        uint64_t v12 = *(uint64_t **)v4;
        *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = **(void **)v4;
        ++*((_BYTE *)v12 + 32);
        v4[116] = v3;
      }

      else
      {
        unsigned int v8 = 0;
      }
    }

    if (v8 + 1 < v3)
    {
      unsigned int v13 = v4 + 104;
      uint64_t v14 = v8;
      do
      {
        int v15 = v14;
        __n128 result = (unsigned __int8 *)lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild( (char *)v5[v14],  v13[v14],  *(lsl::Lock ***)(*(void *)v4 + 8LL));
        uint64_t v18 = v5[v14];
        if (*(char *)(v18 + 248) < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v16,  v17);
        }
        uint64_t v19 = v13[v14];
        uint64_t v20 = *(void *)(v18 + 8 * v19 + 160);
        unsigned int v21 = v4[v14 + 105];
        if (v21 > (*(_BYTE *)(v20 + 248) & 0x7Fu))
        {
          unsigned __int8 v22 = v19 + 1;
          v13[v14] = v22;
          v4[v14 + 105] = v21 + (~*(_BYTE *)(v20 + 248) | 0x80);
          uint64_t v23 = v5[v14];
          if (*(char *)(v23 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v16,  v17);
          }
          *(void *)&v4[8 * v14 + 16] = *(void *)(v23 + 8LL * v22 + 160);
        }

        ++v14;
      }

      while (v15 + 2 < v4[116]);
    }
  }

  return result;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>( uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 116);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 116);
  if (v2 >= v3) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 116);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 116);
  }
  if ((_DWORD)v4)
  {
    uint64_t v5 = (unsigned __int8 *)(a1 + 104);
    int v6 = (unsigned __int8 *)(a2 + 104);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 >= v9;
      if (v7 != v9) {
        break;
      }
      if (!--v4) {
        goto LABEL_8;
      }
    }

    if (v10) {
      return 1LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
LABEL_8:
    BOOL v11 = v3 == v2;
    if (v3 < v2) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v11) {
      return 0LL;
    }
    else {
      return v12;
    }
  }

char *lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::splitChild( char *a1, uint64_t a2, lsl::Lock **this)
{
  if (a1[248] < 0) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  uint64_t v3 = a1[248];
  if (v3 >= 0xA) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  uint64_t v4 = a1;
  uint64_t v5 = a1 + 160;
  uint64_t v6 = (uint64_t)&a1[8 * a2 + 160];
  char v7 = *(_BYTE *)(*(void *)v6 + 248LL);
  int v8 = v7;
  int v9 = v7 & 0x7F;
  if (v7 >= 0) {
    int v10 = 10;
  }
  else {
    int v10 = 15;
  }
  if (v9 != v10) {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  uint64_t v12 = a2;
  if (v8 >= 0) {
    uint64_t v13 = 5LL;
  }
  else {
    uint64_t v13 = 7LL;
  }
  uint64_t v14 = &a1[16 * a2];
  if ((_DWORD)v3 != (_DWORD)a2)
  {
    a1 = (char *)memmove(&a1[16 * a2 + 16], &a1[16 * a2], 16 * v3 - 16LL * a2);
    a2 = v4[248];
  }

  if ((a2 & 0x80) != 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)a1,  a2,  (uint64_t)this);
  }
  int v15 = &v5[8 * a2];
  if (v15 != (char *)v6)
  {
    memmove((void *)(v6 + 16), (const void *)(v6 + 8), (size_t)&v15[-v6]);
    LOBYTE(a2) = v4[248];
  }

  v4[248] = a2 + 1;
  *(_OWORD *)uint64_t v14 = *(_OWORD *)(*(void *)v6 + 16 * v13);
  __n128 result = (char *)lsl::Allocator::aligned_alloc(this, 0x100uLL, 0x100uLL);
  uint64_t v19 = result;
  char v20 = *(_BYTE *)(*(void *)v6 + 248LL);
  result[248] = v20 & 0x80;
  if (v20 < 0)
  {
    *((_OWORD *)result + 13) = 0uLL;
    *((_OWORD *)result + 14) = 0uLL;
    *((_OWORD *)result + 1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0uLL;
    *((_OWORD *)result + 12) = 0uLL;
    *((_OWORD *)result + 1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0uLL;
  }

  *((_OWORD *)result + 8) = 0uLL;
  *((_OWORD *)result + 9) = 0uLL;
  *((_OWORD *)result + 6) = 0uLL;
  *((_OWORD *)result + 7) = 0uLL;
  *((_OWORD *)result + 4) = 0uLL;
  *((_OWORD *)result + 5) = 0uLL;
  *((_OWORD *)result + 2) = 0uLL;
  *((_OWORD *)result + 3) = 0uLL;
  *(_OWORD *)__n128 result = 0uLL;
  *((_OWORD *)result + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0uLL;
  if (v4[248] < 0) {
    lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
  }
  unsigned __int8 v21 = v9 + ~(_BYTE)v13;
  *(void *)&v5[8 * v12 + 8] = result;
  if (v21) {
    __n128 result = (char *)memmove(result, (const void *)(*(void *)v6 + 16 * v13 + 16), 16LL * v21);
  }
  uint64_t v22 = *(void *)v6;
  int v23 = *(char *)(*(void *)v6 + 248LL);
  if ((v23 & 0x80000000) == 0)
  {
    if (v19[248] < 0) {
      lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( (uint64_t)result,  v17,  v18);
    }
    __n128 result = (char *)memmove(v19 + 160, (const void *)(v22 + 8 * v13 + 168), 8LL * v21 + 8);
    uint64_t v22 = *(void *)v6;
    LOBYTE(v23) = *(_BYTE *)(*(void *)v6 + 248LL);
  }

  *(_BYTE *)(v22 + 248) = v23 + ~v21;
  char v24 = v19[248] + v21;
  v19[248] = v24;
  if (v24 >= 0) {
    int v25 = 10;
  }
  else {
    int v25 = 15;
  }
  if ((v24 & 0x7F) == v25
    || ((char v26 = *(_BYTE *)(v22 + 248), v27 = v26, v28 = v26 & 0x7F, v27 >= 0) ? (v29 = 10) : (v29 = 15), v28 == v29))
  {
    lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild((uint64_t)result, v17, v18);
  }

  return result;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::const_iterator( uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 10dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0u;
  if (*(_BYTE *)(a2 + 32))
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = *(void *)a2;
    uint64_t v9 = a1 + 104;
    while (1)
    {
      *(void *)(v4 + 8 * v7) = v8;
      uint64_t v10 = lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index(v8, a3);
      *(_BYTE *)(v9 + v7) = v10;
      uint64_t v13 = *(void *)(v4 + 8 * v7);
      int v14 = *(char *)(v13 + 248);
      if ((_DWORD)v10 != (v14 & 0x7F)) {
        break;
      }
LABEL_11:
      unint64_t v19 = *(unsigned __int8 *)(a2 + 32);
      if ((_DWORD)v7 + 1 != (_DWORD)v19)
      {
        if (v14 < 0) {
          lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( v10,  v11,  v12);
        }
        uint64_t v8 = *(void *)(v13 + 8LL * v10 + 160);
      }

      if (++v7 >= v19)
      {
        for (*(_BYTE *)(a1 + 116) = v19; (_BYTE)v19; *(_BYTE *)(a1 + 116) = v19)
        {
          if (*(_BYTE *)(v9 + v19 - 1) != (*(_BYTE *)(*(void *)(v4
                                                                                                + 8LL
                                                                                                * v19
                                                                                                - 8)
                                                                                    + 248LL) & 0x7F))
            break;
          LOBYTE(v19) = v19 - 1;
        }

        return a1;
      }
    }

    uint64_t v15 = 0LL;
    while (1)
    {
      unsigned int v16 = *(unsigned __int8 *)(v13 + 16LL * v10 + v15);
      unsigned int v17 = *(unsigned __int8 *)(a3 + v15);
      if (v16 < v17) {
        break;
      }
      if (v17 < v16 || v15++ == 15) {
        goto LABEL_11;
      }
    }

    *(_BYTE *)(a1 + 116) = v7 + 1;
  }

  return a1;
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::NodeCore<15u,10u>::lower_bound_index( uint64_t a1, uint64_t a2)
{
  LODWORD(v2) = a1;
  unint64_t v3 = *(_BYTE *)(a1 + 248) & 0x7F;
  if ((*(_BYTE *)(a1 + 248) & 0x7F) != 0)
  {
    uint64_t v2 = a1;
    do
    {
      uint64_t v4 = 0LL;
      unint64_t v5 = v3 >> 1;
      uint64_t v6 = v2 + 16 * (v3 >> 1);
      while (1)
      {
        unsigned int v7 = *(unsigned __int8 *)(v6 + v4);
        unsigned int v8 = *(unsigned __int8 *)(a2 + v4);
        if (v7 < v8) {
          break;
        }
        if (v8 < v7 || v4++ == 15) {
          goto LABEL_12;
        }
      }

      uint64_t v2 = v6 + 16;
      unint64_t v5 = v3 + ~v5;
LABEL_12:
      unint64_t v3 = v5;
    }

    while (v5);
  }

  return ((v2 - a1) >> 4);
}

uint64_t lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++( uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(result + 116);
  uint64_t v4 = *(uint64_t **)result;
  if (*(_BYTE *)(result + 116))
  {
    int v5 = *((unsigned __int8 *)v4 + 32);
    uint64_t v6 = result + 104;
    ++*(_BYTE *)(result + 104 + (v3 - 1));
    if (v3 == v5)
    {
      uint64_t v7 = *((unsigned __int8 *)v4 + 32);
      if (v7)
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(_BYTE *)(v6 + (v7 + ~(_BYTE)i)) != (*(_BYTE *)(*(void *)(result
                                                                                           + 8
                                                                                           + 8LL
                                                                                           * (v7 + ~(_BYTE)i))
                                                                               + 248LL) & 0x7F))
            break;
          *(_BYTE *)(result + 116) = v7 + ~(_BYTE)i;
        }
      }
    }

    else
    {
      int v15 = *(unsigned __int8 *)(result + 116);
      if (v15 != *((unsigned __int8 *)v4 + 32))
      {
        uint64_t v16 = result + 8;
        do
        {
          uint64_t v17 = *(void *)(v16 + 8 * (v15 - 1LL));
          if (*(char *)(v17 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          *(void *)(v16 + 8LL * v15) = *(void *)(v17
                                                                    + 8LL
                                                                    * *(unsigned __int8 *)(v6
                                                                                         + v15
                                                                                         - 1LL)
                                                                    + 160);
          *(_BYTE *)(v6 + v15) = 0;
          LOBYTE(v15) = *(_BYTE *)(result + 116) + 1;
          *(_BYTE *)(result + 116) = v15;
        }

        while (*((unsigned __int8 *)v4 + 32) != v15);
      }
    }
  }

  else
  {
    uint64_t v9 = *v4;
    *(_BYTE *)(result + 116) = 0;
    if (*((_BYTE *)v4 + 32))
    {
      unsigned __int8 v10 = 0;
      uint64_t v11 = result + 8;
      do
      {
        *(void *)(v11 + 8LL * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
        *(_BYTE *)(result + 104 + v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
        uint64_t v12 = *(unsigned __int8 *)(result + 116);
        unsigned int v13 = *((unsigned __int8 *)v4 + 32);
        if ((_DWORD)v12 + 1 != v13)
        {
          uint64_t v14 = *(void *)(v11 + 8 * v12);
          if (*(char *)(v14 + 248) < 0) {
            lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( result,  a2,  a3);
          }
          uint64_t v9 = *(void *)(v14 + 160);
        }

        unsigned __int8 v10 = v12 + 1;
        *(_BYTE *)(result + 116) = v10;
      }

      while (v13 > v10);
    }
  }

  return result;
}

void *lsl::Vector<lsl::UUID>::Vector<lsl::OrderedSet<lsl::UUID,std::less<lsl::UUID>>::const_iterator>( void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  *a1 = a4;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  uint64_t v14 = *a2;
  v15[2] = *(_OWORD *)(a2 + 5);
  v15[3] = *(_OWORD *)(a2 + 7);
  v15[4] = *(_OWORD *)(a2 + 9);
  void v15[5] = *(_OWORD *)(a2 + 11);
  v15[0] = *(_OWORD *)(a2 + 1);
  v15[1] = *(_OWORD *)(a2 + 3);
  uint64_t v16 = a2[13];
  int v17 = *((_DWORD *)a2 + 28);
  unsigned __int8 v18 = *((_BYTE *)a2 + 116);
  while (lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator<=>( (uint64_t)&v14,  a3))
  {
    uint64_t v6 = v18 - 1LL;
    uint64_t v7 = *((void *)v15 + v6);
    uint64_t v8 = *((unsigned __int8 *)&v16 + v6);
    lsl::Vector<dyld4::InterposeTupleAll>::reserve((uint64_t)a1, a1[2] + 1LL);
    uint64_t v9 = a1[1];
    uint64_t v10 = a1[2];
    a1[2] = v10 + 1;
    *(_OWORD *)(v9 + 16 * v1dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_OWORD *)(v7 + 16 * v8);
    lsl::BTree<lsl::UUID,std::less<lsl::UUID>,false>::const_iterator::operator++((uint64_t)&v14, v11, v12);
  }

  return a1;
}

void OUTLINED_FUNCTION_1_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_2_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_3_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_4_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_5(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_6(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_7(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t DyldSharedCache::forEachRegion(uint64_t a1, uint64_t a2)
{
  uint64_t result = _platform_strncmp((const char *)a1, "dyld_v1", 7uLL);
  if (!(_DWORD)result)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    if (v5 <= 0x400)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 20);
      if (v6 <= 0x14)
      {
        if (v5 > 0x138)
        {
          if ((_DWORD)v6)
          {
            uint64_t v10 = a1 + *(unsigned int *)(a1 + 312);
            unint64_t v11 = v10 + 56LL * v6;
            unint64_t v12 = v10 + 56;
            do
            {
              char v13 = 0;
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, char *))(a2 + 16))( a2,  a1 + *(void *)(v12 - 40),  *(void *)(v12 - 56),  *(void *)(v12 - 48),  *(unsigned int *)(v12 - 4),  *(unsigned int *)(v12 - 8),  *(void *)(v12 - 16),  &v13);
              if (v13) {
                break;
              }
              BOOL v9 = v12 >= v11;
              v12 += 56LL;
            }

            while (!v9);
          }
        }

        else if ((_DWORD)v6)
        {
          unint64_t v7 = a1 + v5 + 32 * v6;
          unint64_t v8 = v5 + a1 + 32;
          do
          {
            char v14 = 0;
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, void, char *))(a2 + 16))( a2,  a1 + *(void *)(v8 - 16),  *(void *)(v8 - 32),  *(void *)(v8 - 24),  *(unsigned int *)(v8 - 4),  *(unsigned int *)(v8 - 8),  0LL,  &v14);
            if (v14) {
              BOOL v9 = 1;
            }
            else {
              BOOL v9 = v8 >= v7;
            }
            v8 += 32LL;
          }

          while (!v9);
        }
      }
    }
  }

  return result;
}

unsigned int *DyldSharedCache::forEachTPRORegion(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = result[4];
  if (v2 >= 0x205)
  {
    int v3 = result;
    uint64_t v4 = result[129];
    if ((_DWORD)v4)
    {
      uint64_t v6 = *(void *)((char *)result + v2);
      unint64_t v7 = (uint64_t *)((char *)result + result[128]);
      unint64_t v8 = &v7[2 * v4];
      do
      {
        char v11 = 0;
        uint64_t v9 = *v7;
        v7 += 2;
        uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *))(a2 + 16))(a2, (char *)v3 + v9 - v6);
        if (v11) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v7 >= v8;
        }
      }

      while (!v10);
    }
  }

  return result;
}

uint64_t DyldSharedCache::unslidLoadAddress(DyldSharedCache *this)
{
  return *(void *)((char *)this + *((unsigned int *)this + 4));
}

const char *DyldSharedCache::mappingName(DyldSharedCache *this, char a2)
{
  if ((this & 4) != 0)
  {
    if ((a2 & 8) != 0) {
      return "__TEXT_STUBS";
    }
    else {
      return "__TEXT";
    }
  }

  else
  {
    if ((this & 2) != 0)
    {
      uint64_t v2 = "__DATA_DIRTY";
      uint64_t v6 = "__TPRO_CONST";
      unint64_t v7 = "__DATA_CONST";
      if ((a2 & 4) == 0) {
        unint64_t v7 = "__DATA";
      }
      if ((a2 & 0x40) == 0) {
        uint64_t v6 = v7;
      }
      if ((a2 & 2) == 0) {
        uint64_t v2 = v6;
      }
      int v3 = "__AUTH_DIRTY";
      unint64_t v8 = "__AUTH_TPRO_CONST";
      uint64_t v9 = "__AUTH_CONST";
      if ((a2 & 4) == 0) {
        uint64_t v9 = "__AUTH";
      }
      if ((a2 & 0x40) == 0) {
        unint64_t v8 = v9;
      }
      if ((a2 & 2) == 0) {
        int v3 = v8;
      }
      BOOL v4 = (a2 & 1) == 0;
    }

    else
    {
      uint64_t v2 = "*unknown*";
      int v3 = "__READ_ONLY";
      if ((a2 & 0x20) == 0) {
        int v3 = "__LINKEDIT";
      }
      BOOL v4 = (this & 1) == 0;
    }

    if (v4) {
      return v2;
    }
    else {
      return v3;
    }
  }

void DyldSharedCache::forEachRange(char *a1, uint64_t a2, uint64_t a3)
{
  v4[0] = 0LL;
  v4[1] = v4;
  v4[2] = 0x2000000000LL;
  int v5 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke;
  void v3[3] = &unk_1896213E0;
  void v3[5] = a3;
  void v3[6] = v4;
  void v3[4] = a2;
  DyldSharedCache::forEachCache(a1, (uint64_t)v3);
  _Block_object_dispose(v4, 8);
}

uint64_t DyldSharedCache::forEachCache(char *a1, uint64_t a2)
{
  char v10 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, a1, &v10);
  if (!v10 && *((_DWORD *)a1 + 4) >= 0x18Du && *((_DWORD *)a1 + 99))
  {
    int v5 = 0;
    do
    {
      uint64_t v6 = &a1[*((unsigned int *)a1 + 98)];
      uint64_t v7 = (uint64_t)&v6[24 * v5 + 16];
      uint64_t v8 = (uint64_t)&v6[56 * v5 + 16];
      if (*((_DWORD *)a1 + 4) >= 0x1C9u) {
        uint64_t v9 = (void *)v8;
      }
      else {
        uint64_t v9 = (void *)v7;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a2 + 16))(a2, &a1[*v9], &v10);
      if (v10) {
        break;
      }
      ++v5;
    }

    while (v5 != *((_DWORD *)a1 + 99));
  }

  return result;
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke( void *a1, uint64_t a2, _BYTE *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2;
  v8[3] = &unk_1896213B8;
  uint64_t v6 = a1[6];
  void v8[4] = a1[4];
  v8[5] = v6;
  void v8[6] = a2;
  void v8[7] = a3;
  uint64_t result = DyldSharedCache::forEachRegion(a2, (uint64_t)v8);
  if (!*a3)
  {
    uint64_t result = a1[5];
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))( result,  a2,  *(unsigned int *)(*(void *)(a1[6] + 8LL) + 24LL));
    }
    ++*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
  }

  return result;
}

uint64_t ___ZNK15DyldSharedCache12forEachRangeEU13block_pointerFvPKcyyjyjjRbEU13block_pointerFvPKS_jE_block_invoke_2( uint64_t a1, int a2, int a3, int a4, int a5, DyldSharedCache *this, char a7)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))(*(void *)(a1 + 32));
}

uint64_t DyldSharedCache::numSubCaches(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x18Du) {
    return *((unsigned int *)this + 99);
  }
  else {
    return 0LL;
  }
}

uint64_t DyldSharedCache::imagesCount(DyldSharedCache *this)
{
  uint64_t v1 = 28LL;
  if (*((_DWORD *)this + 4) > 0x1C3u) {
    uint64_t v1 = 452LL;
  }
  return *(unsigned int *)((char *)this + v1);
}

unsigned int *DyldSharedCache::forEachDylib(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)((char *)result + result[4]);
  if (!v2[2])
  {
    int v3 = result;
    if (result[113])
    {
      unint64_t v5 = 0LL;
      uint64_t v6 = *v2;
      uint64_t v7 = (uint64_t)result + result[112] + 16;
      do
      {
        uint64_t v8 = *(void *)(v7 - 8);
        uint64_t v9 = (char *)v3 + *(unsigned int *)(v7 + 8);
        char v10 = (char *)v3 + *(void *)(v7 - 16) - v6;
        char v11 = 0;
        uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t, char *, char *, unint64_t, void, uint64_t, char *))(a2 + 16))( a2,  v10,  v9,  v5,  *(void *)v7,  v8,  &v11);
        if (v11) {
          break;
        }
        v7 += 32LL;
        ++v5;
      }

      while (v5 < v3[113]);
    }
  }

  return result;
}

uint64_t DyldSharedCache::getImageFromPath(DyldSharedCache *this, const char *a2)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  uint64_t v4 = 24LL;
  uint64_t v5 = *(unsigned int *)((char *)this + v4);
  else {
    return 0LL;
  }
}

uint64_t DyldSharedCache::hasImagePath(DyldSharedCache *this, const char *__s2, unsigned int *a3)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  if (v3 < 0x118)
  {
    uint64_t v12 = *((unsigned int *)this + 7);
    if ((_DWORD)v12)
    {
      uint64_t v13 = 0LL;
      char v14 = (unsigned int *)((char *)this + *((unsigned int *)this + 6) + 24);
      while (1)
      {
        unsigned int v15 = *v14;
        v14 += 8;
        if (v12 == ++v13) {
          return 0LL;
        }
      }

      *a3 = v13;
      return 1LL;
    }
  }

  else
  {
    uint64_t v8 = (const unsigned __int8 **)((char *)this + *((void *)this + 33) - *(void *)((char *)this + v3));
    uint64_t v9 = (Diagnostics *)((char *)v8 + *((void *)this + 34));
    Diagnostics::Diagnostics((Diagnostics *)&v17);
    uint64_t v16 = dyld3::MachOFile::trieWalk((vm_address_t *)&v17, v8, v9, (const unsigned __int8 *)__s2, v10);
    if (v16)
    {
      *a3 = dyld3::MachOFile::read_uleb128((vm_address_t *)&v17, &v16, (const unsigned __int8 **)v9, v11);
      mach_o::Error::~Error(&v17);
      return 1LL;
    }

    mach_o::Error::~Error(&v17);
  }

  return 0LL;
}

uint64_t DyldSharedCache::getIndexedImageEntry( DyldSharedCache *this, int a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v4 = *((unsigned int *)this + 4);
  uint64_t v5 = 24LL;
  if (v4 > 0x1C3) {
    uint64_t v5 = 448LL;
  }
  uint64_t v6 = (void *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v5));
  *a3 = v6[1];
  *a4 = v6[2];
  return (uint64_t)this + *v6 - *(void *)((char *)this + v4);
}

uint64_t DyldSharedCache::getIndexedImageEntry(DyldSharedCache *this, int a2)
{
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24LL;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448LL;
  }
  return (uint64_t)this
}

uint64_t DyldSharedCache::getIndexedImagePath(DyldSharedCache *this, int a2)
{
  uint64_t v2 = 24LL;
  if (*((_DWORD *)this + 4) > 0x1C3u) {
    uint64_t v2 = 448LL;
  }
  return (uint64_t)this + *(unsigned int *)((char *)this + 32 * a2 + *(unsigned int *)((char *)this + v2) + 24);
}

uint64_t DyldSharedCache::forEachImageTextSegment(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 16) >= 0x89u)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 144);
    if (v3)
    {
      uint64_t v4 = *(void *)(result + 136);
      char v8 = 0;
      if (v3 >= 1)
      {
        unint64_t v6 = result + v4 + 32 * v3;
        unint64_t v7 = v4 + result + 32;
        do
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, void, unint64_t, uint64_t, char *))(a2 + 16))( a2,  *(void *)(v7 - 16),  *(unsigned int *)(v7 - 8),  v7 - 32,  v2 + *(unsigned int *)(v7 - 4),  &v8);
          if (v7 >= v6) {
            break;
          }
          v7 += 32LL;
        }

        while (!v8);
      }
    }
  }

  return result;
}

uint64_t DyldSharedCache::addressInText(DyldSharedCache *this, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = *((void *)this + 18);
  if (v3 < 1) {
    return 0LL;
  }
  unsigned int v4 = 0;
  unint64_t v5 = *(void *)((char *)this + *((unsigned int *)this + 4)) + a2;
  unint64_t v6 = (char *)this + *((void *)this + 17);
  unint64_t v7 = &v6[32 * v3];
  while (1)
  {
    unint64_t v8 = *((void *)v6 + 2);
    v6 += 32;
    ++v4;
    if (v6 >= v7) {
      return 0LL;
    }
  }

  *a3 = v4;
  return 1LL;
}

__n128 DyldSharedCache::getUUID(DyldSharedCache *this, __n128 *a2)
{
  __n128 result = *(__n128 *)((char *)this + 88);
  *a2 = result;
  return result;
}

uint64_t DyldSharedCache::mappedSize(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x18Cu) {
    return *((void *)this + 29);
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  uint64_t v11 = 0LL;
  uint64_t v4 = 0LL;
  unint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke;
  void v3[3] = &unk_189621408;
  void v3[4] = &v8;
  void v3[5] = &v4;
  DyldSharedCache::forEachRegion((uint64_t)this, (uint64_t)v3);
  uint64_t v1 = v5[3] - v9[3];
  _Block_object_dispose(&v4, 8);
  _Block_object_dispose(&v8, 8);
  return v1;
}

uint64_t ___ZNK15DyldSharedCache10mappedSizeEv_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(result + 32) + 8LL);
  if (!*(void *)(v4 + 24)) {
    *(void *)(v4 + 24) = a3;
  }
  uint64_t v5 = *(void *)(*(void *)(result + 40) + 8LL);
  return result;
}

BOOL DyldSharedCache::findMachHeaderImageIndex( DyldSharedCache *this, const mach_header *a2, unsigned int *a3)
{
  uint64_t v3 = *((unsigned int *)this + 4);
  else {
    uint64_t v4 = 448LL;
  }
  uint64_t v5 = 28LL;
  unint64_t v6 = *(unsigned int *)((char *)this + v5);
  if (!(_DWORD)v6) {
    return 0LL;
  }
  int64_t v7 = (char *)a2 - (char *)this + *(void *)((char *)this + v3);
  uint64_t v8 = *(unsigned int *)((char *)this + v4);
  if (*(void *)((char *)this + v8) != v7)
  {
    unint64_t v9 = 0LL;
    uint64_t v11 = (uint64_t *)((char *)this + v8 + 32);
    while (v6 - 1 != v9)
    {
      uint64_t v12 = *v11;
      v11 += 4;
      ++v9;
      if (v12 == v7)
      {
        BOOL result = v9 < v6;
        goto LABEL_13;
      }
    }

    return 0LL;
  }

  LODWORD(v9) = 0;
  BOOL result = 1LL;
LABEL_13:
  *a3 = v9;
  return result;
}

uint64_t DyldSharedCache::slide(DyldSharedCache *this)
{
  return (uint64_t)this - *(void *)((char *)this + *((unsigned int *)this + 4));
}

char *DyldSharedCache::findLaunchLoaderSet(DyldSharedCache *this, const char *a2)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v4 = *((void *)this + 44);
  if (!v4) {
    return 0LL;
  }
  unint64_t v6 = (char *)this - *(void *)((char *)this + v2);
  int64_t v7 = (const unsigned __int8 **)&v6[v4];
  uint64_t v8 = (Diagnostics *)&v6[v4 + *((unsigned int *)this + 90)];
  uint64_t v9 = *((void *)this + 42);
  Diagnostics::Diagnostics((Diagnostics *)&v16);
  unsigned int v15 = dyld3::MachOFile::trieWalk((vm_address_t *)&v16, v7, v8, (const unsigned __int8 *)a2, v10);
  if (v15
    && (unint64_t v12 = dyld3::MachOFile::read_uleb128( (vm_address_t *)&v16,  &v15,  (const unsigned __int8 **)v8,  v11),  v12 < *((void *)this + 43)))
  {
    uint64_t v13 = &v6[v9 + v12];
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  mach_o::Error::~Error(&v16);
  return v13;
}

BOOL DyldSharedCache::hasLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *a2)
{
  return DyldSharedCache::findLaunchLoaderSetWithCDHash(this, a2) != 0LL;
}

char *DyldSharedCache::findLaunchLoaderSetWithCDHash(DyldSharedCache *this, const char *__s)
{
  if (!__s || _platform_strlen(__s) > 0x7F) {
    return 0LL;
  }
  strcpy(__dst, "/cdhash/");
  strlcat(__dst, __s, 0x8CuLL);
  return DyldSharedCache::findLaunchLoaderSet(this, __dst);
}

uint64_t DyldSharedCache::patchTable(DyldSharedCache *this)
{
  return (uint64_t)this + *((void *)this + 19) - *(void *)((char *)this + *((unsigned int *)this + 4));
}

uint64_t DyldSharedCache::patchInfoVersion(DyldSharedCache *this)
{
  uint64_t v1 = *((unsigned int *)this + 4);
  else {
    return 1LL;
  }
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableExport( dyld3::MachOFile *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *((void *)result + 19);
  if (v3)
  {
    uint64_t v5 = result;
    uint64_t v6 = *((unsigned int *)result + 4);
    if (v6 < 0x181 || *(_DWORD *)((char *)result + v3 - *(void *)((char *)result + v6)) == 1)
    {
      uint64_t v7 = 24LL;
      uint64_t v8 = (char *)result + *(void *)((char *)result + 32 * a2 + *(unsigned int *)((char *)result + v7));
      uint64_t v9 = *(char **)((char *)result + v6);
      BOOL result = (dyld3::MachOFile *)(v8 - v9);
      if (v8 != v9)
      {
        unint64_t v10 = a2;
        BOOL result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
        uint64_t v11 = *(void *)((char *)v5 + *((unsigned int *)v5 + 4));
        unint64_t v12 = (char *)v5 - v11;
        uint64_t v13 = (void *)((char *)v5 + *((void *)v5 + 19) - v11);
        if (v13[1] >= v10)
        {
          char v14 = &v12[8 * v10 + *v13];
          unsigned int v15 = *((_DWORD *)v14 + 1);
          if (v13[3] >= (unint64_t)(v15 + *(_DWORD *)v14))
          {
            if (v15)
            {
              uint64_t v16 = 0LL;
              int v17 = &v12[v13[2]];
              unsigned __int8 v18 = &v12[v13[6]];
              int v19 = v11 - (_DWORD)result;
              do
              {
                char v20 = &v17[16 * v16 + 16 * *(unsigned int *)v14];
                unint64_t v21 = *((unsigned int *)v20 + 3);
                if (v13[7] <= v21) {
                  uint64_t v22 = (char *)&unk_1800BA999;
                }
                else {
                  uint64_t v22 = &v18[v21];
                }
                BOOL result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, void, char *, void))(a3 + 16))( a3,  (*(_DWORD *)v20 + v19),  v22,  0LL);
                ++v16;
              }

              while (v16 != *((_DWORD *)v14 + 1));
            }
          }
        }
      }
    }

    else
    {
      v23[0] = (char *)result + v3 - *(void *)((char *)result + v6);
      v23[1] = v3;
      return (dyld3::MachOFile *)PatchTable::forEachPatchableExport(v23, a2, a3);
    }
  }

  return result;
}

BOOL DyldSharedCache::shouldPatchClientOfImage(DyldSharedCache *this, unsigned int a2, int a3)
{
  uint64_t v3 = *((void *)this + 19);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = *((unsigned int *)this + 4);
  uint64_t v5 = (_DWORD *)((char *)this + v3 - *(void *)((char *)this + v4));
  if (*v5 == 1) {
    return 0LL;
  }
  v7[0] = v5;
  v7[1] = v3;
  return PatchTable::imageHasClient((PatchTable *)v7, a2, a3);
}

void DyldSharedCache::forEachPatchableUseOfExportInImage( uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 152);
  if (v5)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 16);
    if (v9 < 0x181 || *(_DWORD *)(v5 + a1 - *(void *)(a1 + v9)) == 1)
    {
      uint64_t v10 = 24LL;
      uint64_t v11 = *(void *)(a1 + *(unsigned int *)(a1 + v10) + 32LL * a2) + a1;
      uint64_t v12 = *(void *)(v9 + a1);
      if (v11 != v12)
      {
        uint64_t v13 = *(void *)(a1 + v9);
        unint64_t v14 = a2;
        int Address = dyld3::MachOFile::preferredLoadAddress((dyld3::MachOFile *)(v11 - v12));
        uint64_t v16 = *(void *)(a1 + *(unsigned int *)(a1 + 16));
        int v17 = (void *)(*(void *)(a1 + 152) + a1 - v16);
        if (v17[1] >= v14)
        {
          uint64_t v18 = a1 - v16;
          int v19 = (unsigned int *)(a1 - v16 + *v17 + 8 * v14);
          unsigned int v20 = v19[1];
          uint64_t v48 = v19 + 1;
          if (v17[3] >= (unint64_t)(v20 + *v19))
          {
            uint64_t v61 = &v60;
            uint64_t v62 = 0x5002000000LL;
            uint64_t v63 = __Block_byref_object_copy__10;
            unsigned int v64 = __Block_byref_object_dispose__10;
            uint64_t v65 = v70;
            uint64_t v66 = 8LL;
            vm_address_t v68 = 0LL;
            vm_size_t v69 = 0LL;
            uint64_t v67 = 0LL;
            uint64_t v56 = 0LL;
            uint64_t v57 = &v56;
            uint64_t v58 = 0x2000000000LL;
            uint64_t v59 = 0LL;
            uint64_t v60 = 0LL;
            uint64_t v52 = 0LL;
            char v53 = &v52;
            uint64_t v54 = 0x2000000000LL;
            int v55 = -1;
            if (v20)
            {
              uint64_t v21 = 0LL;
              int v22 = Address - v13 + a3;
              uint64_t v23 = v18 + v17[2];
              uint64_t v24 = v18 + v17[4];
              uint64_t v46 = v19;
              uint64_t v47 = v17;
              int v45 = v22;
              uint64_t v44 = v23;
              do
              {
                uint64_t v25 = v21 + *v19;
                if (*(_DWORD *)(v23 + 16 * v25) == v22)
                {
                  uint64_t v26 = v23 + 16 * v25;
                  int v28 = *(_DWORD *)(v26 + 4);
                  int v27 = (unsigned int *)(v26 + 4);
                  unsigned int v29 = v27[1];
                  if (v29)
                  {
                    uint64_t v30 = 0LL;
                    do
                    {
                      uint64_t v31 = v30 + *v27;
                      char v32 = (_DWORD *)(v24 + 8 * v31);
                      __int128 v33 = (dyld3::MachOFile *)v57[3];
                      uint64_t v34 = v61;
                      if (v33 && (uint64_t v35 = v61[7]) != 0)
                      {
                        unint64_t v36 = *v32;
                        uint64_t v37 = 16 * v35;
                        uint64_t v38 = (unint64_t *)(v61[5] + 8);
                        while (*(v38 - 1) > v36 || *v38 <= v36)
                        {
                          v38 += 2;
                          v37 -= 16LL;
                          if (!v37) {
                            goto LABEL_21;
                          }
                        }
                      }

                      else
                      {
LABEL_21:
                        v57[3] = 0LL;
                        *((_DWORD *)v53 + 6) = -1;
                        void v34[7] = 0LL;
                        v51[0] = _NSConcreteStackBlock;
                        v51[1] = 0x40000000LL;
                        v51[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
                        v51[3] = &unk_189621458;
                        v51[7] = v13;
                        v51[8] = v24 + 8 * v31;
                        v51[4] = &v60;
                        v51[5] = &v56;
                        v51[6] = &v52;
                        DyldSharedCache::forEachDylib((unsigned int *)a1, (uint64_t)v51);
                        __int128 v33 = (dyld3::MachOFile *)v57[3];
                      }

                      if (!v33) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      int v39 = *((_DWORD *)v53 + 6);
                      if (v39 == -1) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      if (!v61[7]) {
                        DyldSharedCache::forEachPatchableUseOfExportInImage();
                      }
                      if (v39 == a4)
                      {
                        int v40 = v13 + *v32;
                        uint64_t v41 = v40 - dyld3::MachOFile::preferredLoadAddress(v33);
                        dyld3::MachOFile::PointerMetaData::PointerMetaData(&v50);
                        unsigned int v42 = *(_DWORD *)(v24 + 8 * v31 + 4);
                        int8x16_t v43 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v42), (uint32x4_t)xmmword_1800B8340),  (int8x16_t)xmmword_1800B8350);
                        *(int8x8_t *)v43.i8 = vorr_s8( *(int8x8_t *)v43.i8,  (int8x8_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
                        unsigned __int32 v50 = v43.i32[0] | v50 & 0xF0000000 | v43.i32[1] | HIWORD(v42);
                        (*(void (**)(uint64_t, uint64_t))(a5 + 16))(a5, v41);
                      }

                      ++v30;
                    }

                    while (v30 != v27[1]);
                    int v17 = v47;
                    unsigned int v20 = *v48;
                    int v19 = v46;
                    int v22 = v45;
                    uint64_t v23 = v44;
                  }
                }

                ++v21;
              }

              while (v21 != v20);
            }

            _Block_object_dispose(&v52, 8);
            _Block_object_dispose(&v56, 8);
            _Block_object_dispose(&v60, 8);
            uint64_t v67 = 0LL;
            if (v68) {
              vm_deallocate(mach_task_self_, v68, v69);
            }
          }
        }
      }
    }

    else
    {
      v70[0] = v5 + a1 - *(void *)(a1 + v9);
      v70[1] = v5;
      PatchTable::forEachPatchableUseOfExportInImage((PatchTableV2 *)v70, a2, a3, a4, a5);
    }
  }

double __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v3;
  *(void *)(a2 + 72) = 0LL;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__10(void *result)
{
  result[7] = 0LL;
  vm_address_t v1 = result[8];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[9]);
  }
  return result;
}

void ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke( uint64_t a1, _DWORD *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, _BYTE *a7)
{
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000LL;
  v17[2] = ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2;
  v17[3] = &unk_189621430;
  uint64_t v11 = *(void *)(a1 + 56);
  v17[4] = *(void *)(a1 + 32);
  _WORD v17[5] = v11;
  dyld3::MachOFile::forEachSegment(a2, (uint64_t)v17);
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v13 = *(void *)(v12 + 56);
  if (v13)
  {
    unint64_t v14 = **(unsigned int **)(a1 + 64);
    uint64_t v15 = 16 * v13;
    uint64_t v16 = (unint64_t *)(*(void *)(v12 + 40) + 8LL);
    while (*(v16 - 1) > v14 || *v16 <= v14)
    {
      v16 += 2;
      v15 -= 16LL;
      if (!v15) {
        goto LABEL_6;
      }
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = a4;
    *a7 = 1;
  }

  else
  {
LABEL_6:
    *(void *)(v12 + 56) = 0LL;
  }

void *___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2( void *result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 52) & 2) != 0)
  {
    uint64_t v2 = *((void *)result + 5);
    uint64_t v3 = *(void *)(*((void *)result + 4) + 8LL);
    uint64_t v5 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 24);
    unint64_t v6 = *(void *)(v3 + 48);
    unint64_t v7 = *(void *)(v3 + 56) + 1LL;
    if (v7 > v6)
    {
      vm_address_t v8 = *(void *)(v3 + 64);
      vm_size_t v9 = *(void *)(v3 + 72);
      unint64_t v10 = 2 * v6;
      if (v10 > v7) {
        unint64_t v7 = v10;
      }
      vm_size_t v11 = (vm_page_size + 16 * v7 - 1) & -(uint64_t)vm_page_size;
      *(void *)(v3 + 72) = v11;
      if (vm_allocate(mach_task_self_, (vm_address_t *)(v3 + 64), v11, 1006632961)) {
        ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1();
      }
      double result = memmove(*(void **)(v3 + 64), *(const void **)(v3 + 40), 16LL * *(void *)(v3 + 56));
      uint64_t v12 = *(void *)(v3 + 72) >> 4;
      *(void *)(v3 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(void *)(v3 + 64);
      *(void *)(v3 + 48) = v12;
      if (v8) {
        double result = (void *)vm_deallocate(mach_task_self_, v8, v9);
      }
    }

    uint64_t v13 = *(void *)(v3 + 40);
    uint64_t v14 = *(void *)(v3 + 56);
    *(void *)(v3 + 56) = v14 + 1;
    uint64_t v15 = (void *)(v13 + 16 * v14);
    *uint64_t v15 = v5 - v2;
    v15[1] = v5 - v2 + v4;
  }

  return result;
}

dyld3::MachOFile *DyldSharedCache::forEachPatchableUseOfExport( dyld3::MachOFile *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *((void *)result + 19);
  if (v4)
  {
    vm_address_t v8 = result;
    uint64_t v9 = *((unsigned int *)result + 4);
    if (v9 > 0x180)
    {
      int v10 = *(_DWORD *)((char *)result + v4 - *(void *)((char *)result + v9));
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
      if (v10 != 1)
      {
        v39[1] = 0x40000000LL;
        void v39[2] = ___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke;
        v39[3] = &__block_descriptor_tmp_36_1;
        v39[4] = v8;
        uint64_t v35 = *((void *)v8 + 19);
        uint64_t v36 = *(void *)((char *)v8 + *((unsigned int *)v8 + 4));
        v38[0] = (char *)v8 + v35 - v36;
        v38[1] = v35;
        v39[0] = _NSConcreteStackBlock;
        return (dyld3::MachOFile *)PatchTable::forEachPatchableCacheUseOfExport(v38, a2, a3, v36, (uint64_t)v39, a4);
      }
    }

    else
    {
      DyldSharedCache::forEachPatchableGOTUseOfExport((uint64_t)result, a2, a3, a4);
    }

    unint64_t v11 = *((unsigned int *)v8 + 4);
    uint64_t v12 = 24LL;
    if (v11 > 0x1C3) {
      uint64_t v12 = 448LL;
    }
    uint64_t v13 = (char *)v8 + *(void *)((char *)v8 + 32 * a2 + *(unsigned int *)((char *)v8 + v12));
    uint64_t v14 = *(char **)((char *)v8 + v11);
    double result = (dyld3::MachOFile *)(v13 - v14);
    if (v13 != v14)
    {
      int v15 = *(_DWORD *)((char *)v8 + v11);
      unint64_t v16 = a2;
      double result = (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
      uint64_t v17 = *(void *)((char *)v8 + *((unsigned int *)v8 + 4));
      uint64_t v18 = (void *)((char *)v8 + *((void *)v8 + 19) - v17);
      if (v18[1] >= v16)
      {
        int v19 = (char *)v8 - v17;
        unsigned int v20 = (unsigned int *)((char *)v8 + 8 * v16 + *v18 - v17);
        unsigned int v21 = v20[1];
        if (v18[3] >= (unint64_t)(v21 + *v20))
        {
          if (v21)
          {
            uint64_t v22 = 0LL;
            unsigned int v23 = (_DWORD)result - v15 + a3;
            uint64_t v24 = &v19[v18[2]];
            uint64_t v25 = &v19[v18[4]];
            unsigned int v37 = v23;
            do
            {
              uint64_t v26 = v22 + *v20;
              if (*(_DWORD *)&v24[16 * v26] == v23)
              {
                int v27 = &v24[16 * v26];
                int v29 = *((_DWORD *)v27 + 1);
                int v28 = (unsigned int *)(v27 + 4);
                unsigned int v30 = v28[1];
                if (v30)
                {
                  uint64_t v31 = 0LL;
                  do
                  {
                    char v32 = &v25[8 * v31 + 8 * *v28];
                    dyld3::MachOFile::PointerMetaData::PointerMetaData(v38);
                    unsigned int v33 = *((_DWORD *)v32 + 1);
                    int8x16_t v34 = vandq_s8( (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v33), (uint32x4_t)xmmword_1800B8340),  (int8x16_t)xmmword_1800B8350);
                    *(int8x8_t *)v34.i8 = vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
                    LODWORD(v38[0]) = v34.i32[0] | v38[0] & 0xF0000000 | v34.i32[1] | HIWORD(v33);
                    double result = (dyld3::MachOFile *)(*(uint64_t (**)(uint64_t, void))(a4 + 16))( a4,  *(unsigned int *)v32);
                    ++v31;
                  }

                  while (v31 != v28[1]);
                  unsigned int v21 = v20[1];
                  unsigned int v23 = v37;
                }
              }

              ++v22;
            }

            while (v22 != v21);
          }
        }
      }
    }
  }

  return result;
}

uint64_t DyldSharedCache::forEachPatchableGOTUseOfExport( uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 152);
  if (v4)
  {
    uint64_t v5 = *(unsigned int *)(result + 16);
    if (v5 >= 0x181)
    {
      unint64_t v6 = (_DWORD *)(v4 + result - *(void *)(result + v5));
      if (*v6 != 1)
      {
        v7[0] = v6;
        v7[1] = v4;
        return PatchTable::forEachPatchableGOTUseOfExport((uint64_t)v7, a2, a3, a4);
      }
    }
  }

  return result;
}

dyld3::MachOFile *___ZNK15DyldSharedCache27forEachPatchableUseOfExportEjjU13block_pointerFvyN5dyld39MachOFile15PointerMetaDataEybE_block_invoke( uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(unsigned int *)(v2 + 16);
  uint64_t v4 = 24LL;
  if (v3 > 0x1C3) {
    uint64_t v4 = 448LL;
  }
  uint64_t v5 = *(void *)(v2 + *(unsigned int *)(v2 + v4) + 32LL * a2) + v2;
  uint64_t v6 = *(void *)(v3 + v2);
  double result = (dyld3::MachOFile *)(v5 - v6);
  if (v5 != v6) {
    return (dyld3::MachOFile *)dyld3::MachOFile::preferredLoadAddress(result);
  }
  return result;
}

BOOL DyldSharedCache::inDyldCache( DyldSharedCache *this, const DyldSharedCache *a2, const dyld3::MachOFile *a3)
{
  int v5 = dyld3::MachOFile::inDyldCache(a2);
  BOOL result = 0LL;
  if (a2 >= this && this)
  {
    if (v5) {
      return (DyldSharedCache *)((char *)this + DyldSharedCache::mappedSize(this)) > a2;
    }
  }

  return result;
}

BOOL DyldSharedCache::isSubCachePath(DyldSharedCache *this, const char *a2)
{
  uint64_t v2 = _platform_strchr((const char *)this, 46);
  return v2 && _platform_strcmp(v2, ".development");
}

dyld3::MachOLoaded *DyldSharedCache::oldObjcOpt(DyldSharedCache *this)
{
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24LL;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448LL;
  }
  uint64_t v4 = (char *)this + *(void *)((char *)this + 32 * v14 + *(unsigned int *)((char *)this + v3));
  int v5 = *(char **)((char *)this + v2);
  uint64_t v6 = (dyld3::MachOLoaded *)(v4 - v5);
  if (v4 != v5)
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = &v10;
    uint64_t v12 = 0x2000000000LL;
    uint64_t v13 = 0LL;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke;
    void v9[3] = &unk_1896214A0;
    void v9[4] = &v10;
    void v9[5] = dyld3::MachOLoaded::getSlide(v6);
    dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
    unint64_t v7 = (_DWORD *)v11[3];
    if (v7)
    {
      else {
        uint64_t v6 = (dyld3::MachOLoaded *)v11[3];
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    _Block_object_dispose(&v10, 8);
  }

  return v6;
}

uint64_t ___ZNK15DyldSharedCache10oldObjcOptEv_block_invoke(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ro");
    if (!(_DWORD)result)
    {
      if (a3) {
        *a4 = 1;
      }
      else {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a1 + 40) + *(void *)(a2 + 64);
      }
    }
  }

  return result;
}

uint64_t DyldSharedCache::objcOptPtrs(DyldSharedCache *this)
{
  unint64_t v2 = *((unsigned int *)this + 4);
  uint64_t v3 = 24LL;
  if (v2 > 0x1C3) {
    uint64_t v3 = 448LL;
  }
  uint64_t v4 = (DyldSharedCache *)((char *)this
  uint64_t v10 = 0LL;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  uint64_t Slide = dyld3::MachOLoaded::getSlide(v4);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke;
  v8[3] = &unk_1896214C8;
  int v9 = dyld3::MachOFile::pointerSize(v4);
  void v8[4] = &v10;
  v8[5] = Slide;
  dyld3::MachOFile::forEachSection(v4, (uint64_t)v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t ___ZNK15DyldSharedCache11objcOptPtrsEv_block_invoke(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  vm_address_t v8 = *(const char **)(a2 + 40);
  if (!_platform_strncmp(v8, "__DATA", 6uLL) || (uint64_t result = _platform_strncmp(v8, "__AUTH", 6uLL), !(_DWORD)result))
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_opt_ptrs");
    if (!(_DWORD)result)
    {
      if (*(void *)(a2 + 72) == *(_DWORD *)(a1 + 48) && !a3) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a1 + 40) + *(void *)(a2 + 64);
      }
      else {
        *a4 = 1;
      }
    }
  }

  return result;
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRO(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 8);
    uint64_t v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }

  else
  {
    uint64_t result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 3);
    uint64_t v3 = (char *)result + v2;
    BOOL v4 = (_DWORD)v2 == 0;
  }

  if (v4) {
    return 0LL;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcHeaderInfoRW(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 16);
    uint64_t v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }

  else
  {
    uint64_t result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 6);
    uint64_t v3 = (char *)result + v2;
    BOOL v4 = (_DWORD)v2 == 0;
  }

  if (v4) {
    return 0LL;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcSelectorHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 24);
    uint64_t v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }

  else
  {
    uint64_t result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 2);
    uint64_t v3 = (char *)result + v2;
    BOOL v4 = (_DWORD)v2 == 0;
  }

  if (v4) {
    return 0LL;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcClassHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 32);
    uint64_t v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }

  else
  {
    uint64_t result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 8);
    uint64_t v3 = (char *)result + v2;
    BOOL v4 = (_DWORD)v2 == 0;
  }

  if (v4) {
    return 0LL;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

dyld3::MachOLoaded *DyldSharedCache::objcProtocolHashTable(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) >= 0x1D9u)
  {
    uint64_t v5 = *(void *)((char *)this + *((void *)this + 58) + 40);
    uint64_t v3 = (char *)this + v5;
    BOOL v4 = v5 == 0;
  }

  else
  {
    uint64_t result = DyldSharedCache::oldObjcOpt(this);
    if (!result) {
      return result;
    }
    uint64_t v2 = *((int *)result + 9);
    uint64_t v3 = (char *)result + v2;
    BOOL v4 = (_DWORD)v2 == 0;
  }

  if (v4) {
    return 0LL;
  }
  else {
    return (dyld3::MachOLoaded *)v3;
  }
}

uint64_t DyldSharedCache::swiftOpt(DyldSharedCache *this)
{
  if (*((_DWORD *)this + 4) < 0x181u) {
    return 0LL;
  }
  uint64_t v2 = *((void *)this + 47);
  if (v2) {
    return (uint64_t)this + v2;
  }
  else {
    return 0LL;
  }
}

uint64_t objc_visitor::Class::getISA@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, BOOL *a3@<X2>, void *a4@<X8>)
{
  unint64_t v7 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  metadata_visitor::Visitor::getField(a2, v7, v9);
  return metadata_visitor::Visitor::resolveBindOrRebase(a2, v9, a3, a4);
}

uint64_t objc_visitor::Class::getSuperclassField@<X0>(uint64_t a1@<X0>, int *a2@<X1>, void *a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4) {
    unint64_t v7 = (char *)(v6 + 4);
  }
  else {
    unint64_t v7 = (char *)(v6 + 8);
  }
  return metadata_visitor::Visitor::getField((uint64_t)a2, v7, a3);
}

uint64_t objc_visitor::Class::isUnfixedBackwardDeployingStableSwift(uint64_t a1, int *a2)
{
  uint64_t result = objc_visitor::Class::isSwiftLegacy(a1, a2);
  if ((_DWORD)result)
  {
    uint64_t v5 = objc_visitor::Class::swiftClassFlags(a1, a2);
    return (v5 & 0xFF00000000LL) != 0 && (v5 & 1) == 0;
  }

  return result;
}

uint64_t objc_visitor::Class::isSwiftLegacy(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4) {
    uint64_t v5 = (char *)(v4 + 16);
  }
  else {
    uint64_t v5 = (char *)(v4 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  char v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v6 & 1;
}

uint64_t objc_visitor::Class::swiftClassFlags(uint64_t a1, int *a2)
{
  if ((objc_visitor::Class::isSwiftStable(a1, a2) & 1) == 0
    && !objc_visitor::Class::isSwiftLegacy(a1, a2))
  {
    return 0LL;
  }

  int v4 = *a2;
  uint64_t v5 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  uint64_t v6 = 40LL;
  if (v4 == 4) {
    uint64_t v6 = 20LL;
  }
  return *(unsigned int *)(v5 + v6) | 0x100000000LL;
}

uint64_t objc_visitor::Class::isSwiftStable(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v3 == 4) {
    uint64_t v5 = (char *)(v4 + 16);
  }
  else {
    uint64_t v5 = (char *)(v4 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v10);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v10, v9);
  unint64_t v6 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
  if (!v7) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return (v6 >> 1) & 1;
}

__n128 objc_visitor::Class::getClassData@<Q0>(uint64_t a1@<X0>, int *a2@<X1>, __n128 *a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(a1 + 8));
  if (v5 == 4) {
    char v7 = (char *)(v6 + 16);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v17);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v17, v16);
  uint64_t v8 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v16);
  if (!v9) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v10 = 4294967292LL;
  if (*a2 != 4) {
    uint64_t v10 = 0x7FFFFFFFFFF8LL;
  }
  uint64_t v11 = v10 & v8;
  if (v11 == v8)
  {
    uint64_t v12 = (__n128 *)v16;
  }

  else
  {
    uint64_t v13 = (char *)(lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v16) + v11 - v8);
    uint64_t v12 = (__n128 *)v15;
    metadata_visitor::Visitor::getField((uint64_t)a2, v13, v15);
  }

  __n128 result = *v12;
  *a3 = *v12;
  a3[1].n128_u64[0] = v12[1].n128_u64[0];
  return result;
}

uint64_t objc_visitor::Class::isRootClass(uint64_t a1, int *a2)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v3) >> 1) & 1;
}

uint64_t objc_visitor::Class::getName(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 16);
  }
  else {
    int v5 = (char *)(v4 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Class::getNameVMAddr(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v9);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 16);
  }
  else {
    int v5 = (char *)(v4 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

uint64_t objc_visitor::Class::getBaseMethods@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)&v10);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 20);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Class::getVMAddress(objc_visitor::Class *this)
{
  return metadata_visitor::ResolvedValue::vmAddress((objc_visitor::Class *)((char *)this + 8));
}

uint64_t objc_visitor::Category::getInstanceMethods@<X0>( lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 8);
  }
  else {
    char v7 = (char *)(v6 + 16);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Category::getClassMethods@<X0>( lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 12);
  }
  else {
    char v7 = (char *)(v6 + 24);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getISAVMAddr@<X0>( lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = (char *)lsl::Allocator::Pool::allocator(a1);
  metadata_visitor::Visitor::getField(a2, v5, v11);
  uint64_t result = metadata_visitor::Visitor::resolveOptionalRebase(a2, v11, (uint64_t)v9);
  char v7 = v10;
  if (v10)
  {
    uint64_t result = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v9);
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
    char v7 = 1;
  }

  else
  {
    *(_BYTE *)a3 = 0;
  }

  *(_BYTE *)(a3 + 16) = v7;
  return result;
}

uint64_t objc_visitor::Protocol::getName(lsl::Allocator::Pool *a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 4);
  }
  else {
    int v5 = (char *)(v4 + 8);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v7);
}

uint64_t objc_visitor::Protocol::getNameVMAddr(lsl::Allocator::Pool *a1, int *a2)
{
  int v3 = *a2;
  uint64_t v4 = lsl::Allocator::Pool::allocator(a1);
  if (v3 == 4) {
    int v5 = (char *)(v4 + 4);
  }
  else {
    int v5 = (char *)(v4 + 8);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, v8);
  metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v8, v7);
  return metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v7);
}

uint64_t objc_visitor::Protocol::getClassMethods@<X0>( lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 16);
  }
  else {
    char v7 = (char *)(v6 + 32);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getOptionalInstanceMethods@<X0>( lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 20);
  }
  else {
    char v7 = (char *)(v6 + 40);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::Protocol::getOptionalClassMethods@<X0>( lsl::Allocator::Pool *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *a2;
  uint64_t v6 = lsl::Allocator::Pool::allocator(a1);
  if (v5 == 4) {
    char v7 = (char *)(v6 + 24);
  }
  else {
    char v7 = (char *)(v6 + 48);
  }
  metadata_visitor::Visitor::getField((uint64_t)a2, v7, v9);
  return metadata_visitor::Visitor::resolveOptionalRebase((uint64_t)a2, v9, a3);
}

uint64_t objc_visitor::MethodList::numMethods(objc_visitor::MethodList *this)
{
  if (!*((_BYTE *)this + 24)) {
    return 0LL;
  }
  uint64_t v1 = lsl::Allocator::Pool::allocator(this);
  if (!v1) {
    objc_visitor::MethodList::numMethods();
  }
  return *(unsigned int *)(v1 + 4);
}

uint64_t objc_visitor::MethodList::usesRelativeOffsets(objc_visitor::MethodList *this)
{
  if (!*((_BYTE *)this + 24)) {
    return 0LL;
  }
  uint64_t v1 = (_DWORD *)lsl::Allocator::Pool::allocator(this);
  if (!v1) {
    objc_visitor::MethodList::usesRelativeOffsets();
  }
  return *v1 >> 31;
}

double objc_visitor::MethodList::getMethod@<D0>( lsl::Allocator::Pool *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (!*((_BYTE *)a1 + 24)) {
    objc_visitor::MethodList::getMethod();
  }
  char v7 = (int *)lsl::Allocator::Pool::allocator(a1);
  if (!v7) {
    objc_visitor::MethodList::getMethod();
  }
  uint64_t v8 = v7;
  metadata_visitor::Visitor::getField(a2, (char *)v7 + (*v7 & 0xFFFCu) * a3 + 8, &v11);
  if (*v8 >= 0) {
    int v9 = 2;
  }
  else {
    int v9 = (*v8 >> 30) & 1;
  }
  double result = *(double *)&v11;
  *(_OWORD *)(a4 + 8) = v11;
  *(void *)(a4 + 24) = v12;
  *(_DWORD *)a4 = v9;
  return result;
}

int *objc_visitor::Method::getNameField@<X0>(int *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v4 = *result;
  if (*result == 2)
  {
    uint64_t v6 = (char *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    return (int *)metadata_visitor::Visitor::getField(a2, v6, a3);
  }

  else
  {
    if (v4 == 1) {
      objc_visitor::Method::getNameField();
    }
    if (!v4) {
      objc_visitor::Method::getNameField();
    }
  }

  return result;
}

int *objc_visitor::Method::getName(int *result, uint64_t a2)
{
  int v3 = *result;
  if (!*result)
  {
    int v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1LL, v9);
    goto LABEL_8;
  }

  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
  }

  if (v3 == 1) {
    objc_visitor::Method::getName();
  }
  return result;
}

int *objc_visitor::Method::getNameVMAddr(int *result, uint64_t a2)
{
  int v3 = *result;
  if (!*result)
  {
    int v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1LL, v9);
    goto LABEL_8;
  }

  if (v3 == 2)
  {
    objc_visitor::Method::getNameField(result, a2, v9);
LABEL_8:
    metadata_visitor::Visitor::resolveRebase(a2, v9, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }

  if (v3 == 1) {
    objc_visitor::Method::getNameVMAddr();
  }
  return result;
}

int *objc_visitor::Method::getNameSelRefVMAddr(int *result, uint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    if (v2 == 1) {
      objc_visitor::Method::getNameSelRefVMAddr();
    }
    if (v2 == 2) {
      objc_visitor::Method::getNameSelRefVMAddr();
    }
  }

  else
  {
    int v4 = (metadata_visitor::ResolvedValue *)(result + 2);
    uint64_t v5 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)(result + 2));
    uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(v4);
    if (!v7) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    metadata_visitor::Visitor::getValueFor(a2, v6 + v5, 1LL, v8);
    return (int *)metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v8);
  }

  return result;
}

uint64_t objc_visitor::ProtocolList::numProtocols(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  if (!*((_BYTE *)a1 + 24)) {
    return 0LL;
  }
  int v3 = (unsigned int *)lsl::Allocator::Pool::allocator(a1);
  if (!v3) {
    objc_visitor::ProtocolList::numProtocols();
  }
  if (*a2 == 4) {
    return *v3;
  }
  else {
    return *(void *)v3;
  }
}

uint64_t objc_visitor::ProtocolList::getProtocolField@<X0>( lsl::Allocator::Pool *a1@<X0>, _DWORD *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (!*((_BYTE *)a1 + 24)) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (objc_visitor::ProtocolList::numProtocols(a1, a2) <= a3) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (!*((_BYTE *)a1 + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v8 = lsl::Allocator::Pool::allocator(a1);
  if (!v8) {
    objc_visitor::ProtocolList::getProtocolField();
  }
  if (*a2 == 4) {
    int v9 = (char *)(v8 + 4 * a3 + 4);
  }
  else {
    int v9 = (char *)(v8 + 8 * a3 + 8);
  }
  return metadata_visitor::Visitor::getField((uint64_t)a2, v9, a4);
}

size_t objc_visitor::ProtocolList::dump(lsl::Allocator::Pool *a1, _DWORD *a2)
{
  if (!*((_BYTE *)a1 + 24)) {
    return fwrite("no value\n", 9uLL, 1uLL, __stdoutp);
  }
  uint64_t v4 = objc_visitor::ProtocolList::numProtocols(a1, a2);
  uint64_t v5 = __stdoutp;
  uint64_t v6 = metadata_visitor::ResolvedValue::vmAddress(a1);
  if (!v7) {
    goto LABEL_9;
  }
  uint64_t v8 = v6;
  int v9 = (const void *)lsl::Allocator::Pool::allocator(a1);
  size_t result = fprintf(v5, "Protocol list (count %lld): vmAddr 0x%llx at %p\n", v4, v8, v9);
  if (v4)
  {
    unint64_t v11 = 0LL;
    while (1)
    {
      objc_visitor::ProtocolList::getProtocolField(a1, a2, v11, v18);
      metadata_visitor::Visitor::resolveRebase((uint64_t)a2, v18, v17);
      uint64_t v12 = __stdoutp;
      uint64_t v13 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v17);
      if (!v14) {
        break;
      }
      uint64_t v15 = v13;
      unint64_t v16 = (const void *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v17);
      size_t result = fprintf(v12, "  Protocol[%lld]: vmAddr 0x%llx at %p\n", v11++, v15, v16);
      if (v4 == v11) {
        return result;
      }
    }

void objc_visitor::Visitor::findSection( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = *(_DWORD **)(a1 + 8);
  uint64_t v10 = 0LL;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x5002000000LL;
  uint64_t v13 = __Block_byref_object_copy__11;
  char v14 = __Block_byref_object_dispose__11;
  char v15 = 0;
  char v16 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke;
  void v9[3] = &unk_1896214F0;
  void v9[6] = a2;
  void v9[7] = a3;
  v9[8] = a4;
  void v9[4] = &v10;
  void v9[5] = a1;
  dyld3::MachOFile::forEachSection(v6, (uint64_t)v9);
  char v7 = v11;
  __int128 v8 = *(_OWORD *)(v11 + 7);
  *(_OWORD *)a5 = *(_OWORD *)(v11 + 5);
  *(_OWORD *)(a5 + 16) = v8;
  *(void *)(a5 + 32) = v7[9];
  _Block_object_dispose(&v10, 8);
}

__n128 __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

double ___ZNK12objc_visitor7Visitor11findSectionENSt3__14spanIPKcLm18446744073709551615EEES4__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    int v9 = *(const char ***)(a1 + 48);
    uint64_t v10 = 8 * v4;
    unint64_t v11 = *(const char **)(a2 + 40);
    while (_platform_strncmp(v11, *v9, 0x10uLL))
    {
      ++v9;
      v10 -= 8LL;
      if (!v10) {
        return result;
      }
    }

    if (!_platform_strncmp(*(const char **)(a2 + 80), *(const char **)(a1 + 64), 0x10uLL))
    {
      uint64_t v13 = *(void *)(a2 + 64);
      uint64_t Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v8 + 8));
      metadata_visitor::ResolvedValue::ResolvedValue(&v17, Slide + v13, *(void *)(a2 + 64), 1LL);
      uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
      uint64_t v16 = *(void *)(a2 + 72);
      double result = *(double *)&v17;
      *(_OWORD *)(v15 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v17;
      *(void *)(v15 + 56) = v18;
      *(void *)(v15 + 64) = v16;
      *(_BYTE *)(v15 + 72) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t objc_visitor::Visitor::forEachClass( unsigned int *a1, int a2, lsl::Allocator::Pool *this, uint64_t a4)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = *a1;
  unint64_t v6 = v4 / v5;
  if (v4 % v5) {
    objc_visitor::Visitor::forEachClass();
  }
  uint64_t result = lsl::Allocator::Pool::allocator(this);
  if (v4 >= v5)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0LL;
    do
    {
      while (1)
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v26);
        BOOL v25 = 0;
        metadata_visitor::Visitor::resolveBindOrRebase((uint64_t)a1, v26, &v25, &v23);
        __int128 v21 = v23;
        uint64_t v22 = v24;
        v20[0] = 0;
        v20[1] = v25;
        char v19 = 0;
        uint64_t result = (*(uint64_t (**)(uint64_t, _BYTE *, void, char *))(a4 + 16))(a4, v20, 0LL, &v19);
        if (v19 || !a2) {
          break;
        }
        BOOL v18 = 0;
        objc_visitor::Class::getISA((uint64_t)v20, (uint64_t)a1, &v18, &v16);
        __int128 v14 = v16;
        uint64_t v15 = v17;
        v13[0] = 1;
        v13[1] = v18;
        uint64_t result = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, char *))(a4 + 16))(a4, v13, 1LL, &v19);
        if (!v19 && ++v12 != v6) {
          continue;
        }
        return result;
      }

      ++v12;
    }

    while (v12 != v6 && !v19);
  }

  return result;
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, int a2, uint64_t a3)
{
  if (v6[32]) {
    objc_visitor::Visitor::forEachClass(a1, a2, (lsl::Allocator::Pool *)v6, a3);
  }
}

void objc_visitor::Visitor::forEachClass(unsigned int *a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_189621518;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 0, (uint64_t)v2);
}

uint64_t ___ZN12objc_visitor7Visitor12forEachClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void objc_visitor::Visitor::forEachClassAndMetaClass(unsigned int *a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke;
  v2[3] = &unk_189621540;
  v2[4] = a2;
  objc_visitor::Visitor::forEachClass(a1, 1, (uint64_t)v2);
}

uint64_t ___ZN12objc_visitor7Visitor24forEachClassAndMetaClassEU13block_pointerFvRKNS_5ClassERbE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void objc_visitor::Visitor::forEachCategory(unsigned int *a1, uint64_t a2)
{
  uint64_t v4 = 0LL;
  __int16 v25 = 256;
  do
  {
    char v5 = *((_BYTE *)&v25 + v4);
    if (v5) {
      unint64_t v6 = "__objc_catlist2";
    }
    else {
      unint64_t v6 = "__objc_catlist";
    }
    objc_visitor::Visitor::findSection( (uint64_t)a1,  (uint64_t)objc_visitor::Visitor::findObjCDataSection(char const*)const::objcDataSegments,  3LL,  (uint64_t)v6,  (uint64_t)v22);
    if (v24)
    {
      unint64_t v7 = v23;
      unint64_t v8 = *a1;
      unint64_t v9 = v23 / v8;
      if (v23 % v8) {
        objc_visitor::Visitor::forEachCategory();
      }
      uint64_t v10 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v22);
      if (v7 >= v8)
      {
        uint64_t v11 = v10;
        uint64_t v12 = 0LL;
        unint64_t v13 = v9 - 1;
        do
        {
          metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v11 + v12 * *a1), v21);
          metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v21, &v19);
          __int128 v16 = v19;
          uint64_t v17 = v20;
          char v18 = v5;
          char v15 = 0;
          (*(void (**)(uint64_t, __int128 *, char *))(a2 + 16))(a2, &v16, &v15);
          if (v15) {
            break;
          }
        }

        while (v13 != v12++);
      }
    }

    ++v4;
  }

  while (v4 != 2);
}

void objc_visitor::Visitor::forEachProtocol(unsigned int *a1, uint64_t a2)
{
  if (v20)
  {
    unint64_t v4 = v19;
    unint64_t v5 = *a1;
    unint64_t v6 = v19 / v5;
    if (v19 % v5) {
      objc_visitor::Visitor::forEachProtocol();
    }
    uint64_t v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v18);
    if (v4 >= v5)
    {
      uint64_t v8 = v7;
      uint64_t v9 = 0LL;
      unint64_t v10 = v6 - 1;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v17);
        metadata_visitor::Visitor::resolveRebase((uint64_t)a1, v17, &v15);
        __int128 v13 = v15;
        uint64_t v14 = v16;
        char v12 = 0;
        (*(void (**)(uint64_t, __int128 *, char *))(a2 + 16))(a2, &v13, &v12);
        if (v12) {
          break;
        }
      }

      while (v10 != v9++);
    }
  }

void objc_visitor::Visitor::forEachSelectorReference(unsigned int *a1, uint64_t a2)
{
  if (v13)
  {
    unint64_t v4 = v12;
    unint64_t v5 = *a1;
    unint64_t v6 = v12 / v5;
    if (v12 % v5) {
      objc_visitor::Visitor::forEachSelectorReference();
    }
    uint64_t v7 = lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v11);
    if (v4 >= v5)
    {
      uint64_t v8 = v7;
      uint64_t v9 = 0LL;
      do
      {
        metadata_visitor::Visitor::getField((uint64_t)a1, (char *)(v8 + v9 * *a1), v10);
        (*(void (**)(uint64_t, void *))(a2 + 16))(a2, v10);
        ++v9;
      }

      while (v6 != v9);
    }
  }

{
  void v2[6];
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke;
  v2[3] = &unk_189621568;
  v2[4] = a2;
  void v2[5] = a1;
  objc_visitor::Visitor::forEachSelectorReference(a1, (uint64_t)v2);
}

uint64_t ___ZNK12objc_visitor7Visitor24forEachSelectorReferenceEU13block_pointerFv9VMAddressS1_PKcE_block_invoke( uint64_t a1, uint64_t **a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void metadata_visitor::SwiftVisitor::forEachProtocolConformance( metadata_visitor::SwiftVisitor *a1, uint64_t a2)
{
  if (v10)
  {
    unsigned int v4 = 0;
    int v5 = v10 - 1;
    do
    {
      metadata_visitor::SwiftConformanceList::getConformance((metadata_visitor::SwiftConformanceList *)v9, a1, v4, v8);
      char v7 = 0;
      (*(void (**)(uint64_t, void *, char *))(a2 + 16))(a2, v8, &v7);
      if (v7) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v5 == v4;
      }
      ++v4;
    }

    while (!v6);
  }

void metadata_visitor::SwiftVisitor::getSwiftConformances( metadata_visitor::SwiftVisitor *this@<X0>, uint64_t a2@<X8>)
{
  LODWORD(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = v8;
  if (v8)
  {
    if ((v7 & 3) != 0) {
      metadata_visitor::SwiftVisitor::getSwiftConformances();
    }
    unint64_t v3 = v7 >> 2;
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    char v4 = 1;
  }

  else
  {
    char v4 = 0;
    *(_BYTE *)a2 = 0;
  }

  *(_BYTE *)(a2 + 24) = v4;
  *(_DWORD *)(a2 + 32) = v3;
}

uint64_t metadata_visitor::SwiftConformanceList::getConformance@<X0>( metadata_visitor::SwiftConformanceList *this@<X0>, const metadata_visitor::Visitor *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v8 = *(int *)(lsl::Allocator::Pool::allocator(this) + 4LL * a3);
  uint64_t v9 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v10) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v8 + 4 * a3 + v9, 1LL, a4);
}

void metadata_visitor::SwiftVisitor::findSection( metadata_visitor::SwiftVisitor *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v5 = (_DWORD *)*((void *)this + 1);
  uint64_t v9 = 0LL;
  char v10 = &v9;
  uint64_t v11 = 0x5002000000LL;
  unint64_t v12 = __Block_byref_object_copy__12;
  char v13 = __Block_byref_object_dispose__12;
  char v14 = 0;
  char v15 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke;
  void v8[3] = &unk_189621590;
  void v8[6] = a2;
  void v8[7] = a3;
  void v8[4] = &v9;
  v8[5] = this;
  dyld3::MachOFile::forEachSection(v5, (uint64_t)v8);
  uint64_t v6 = v10;
  __int128 v7 = *(_OWORD *)(v10 + 7);
  *(_OWORD *)a4 = *(_OWORD *)(v10 + 5);
  *(_OWORD *)(a4 + 16) = v7;
  *(void *)(a4 + 32) = v6[9];
  _Block_object_dispose(&v9, 8);
}

__n128 __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

double ___ZNK16metadata_visitor12SwiftVisitor11findSectionEPKcS2__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  if (!_platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 48))
    && !_platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 56)))
  {
    uint64_t v9 = *(void *)(a2 + 64);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(*(dyld3::MachOLoaded **)(v7 + 8));
    metadata_visitor::ResolvedValue::ResolvedValue(&v13, Slide + v9, *(void *)(a2 + 64), 1LL);
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v12 = v14;
    double result = *(double *)&v13;
    *(_OWORD *)(v11 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v13;
    *(void *)(v11 + 56) = v12;
    *(void *)(v11 + 64) = 0LL;
    *(_BYTE *)(v11 + 72) = 1;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 64LL) = *(void *)(a2 + 72);
    *a4 = 1;
  }

  return result;
}

uint64_t metadata_visitor::SwiftConformance::getProtocolPointer@<X0>( metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v5 = (char *)lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, v5, &v9);
  __int128 v7 = v9;
  uint64_t v8 = v10;
  return metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer( (metadata_visitor::SwiftConformance::SwiftRelativePointer *)&v7,  a2,  a3);
}

uint64_t metadata_visitor::SwiftConformance::SwiftRelativePointer::getTargetPointer@<X0>( metadata_visitor::SwiftConformance::SwiftRelativePointer *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
  uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(this);
  if ((v6 & 1) != 0)
  {
    if (v8)
    {
      char v9 = 0;
      v6 &= ~1u;
      goto LABEL_6;
    }

uint64_t metadata_visitor::SwiftConformance::getProtocolConformanceFlags@<X0>( metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, void *a3@<X8>)
{
  __int128 v5 = (char *)(lsl::Allocator::Pool::allocator(this) + 12);
  return metadata_visitor::Visitor::getField((uint64_t)a2, v5, a3);
}

double metadata_visitor::SwiftConformance::getTypeRef@<D0>( metadata_visitor::SwiftConformance *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v6 + 4), &v11);
  uint64_t v7 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v7 + 12), v10);
  int v8 = (*(_DWORD *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10) >> 3) & 7;
  double result = *(double *)&v11;
  *(_OWORD *)a3 = v11;
  *(void *)(a3 + 16) = v12;
  *(_DWORD *)(a3 + 24) = v8;
  return result;
}

uint64_t metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags::typeReferenceKind( metadata_visitor::SwiftConformance::SwiftProtocolConformanceFlags *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) >> 3) & 7;
}

BOOL metadata_visitor::SwiftConformance::isNull(metadata_visitor::SwiftConformance *this)
{
  return *(_OWORD *)lsl::Allocator::Pool::allocator(this) == 0LL;
}

uint64_t metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName( metadata_visitor::SwiftConformance::SwiftTypeRefPointer *this, const metadata_visitor::SwiftVisitor *a2)
{
  if (*((_DWORD *)this + 6) != 2) {
    metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName();
  }
  uint64_t v4 = *(int *)lsl::Allocator::Pool::allocator(this);
  uint64_t v5 = metadata_visitor::ResolvedValue::vmAddress(this);
  if (!v6) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  metadata_visitor::Visitor::getValueFor((uint64_t)a2, v5 + v4, 1LL, v8);
  return lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v8);
}

metadata_visitor::ResolvedValue *metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getTargetPointer@<X0>( metadata_visitor::ResolvedValue *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = this;
  switch(*((_DWORD *)this + 6))
  {
    case 0:
    case 2:
      signed int v6 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(v5);
      if (!v8) {
        goto LABEL_7;
      }
      char v9 = 1;
      goto LABEL_6;
    case 1:
    case 3:
      int v10 = *(_DWORD *)lsl::Allocator::Pool::allocator(this);
      uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress(v5);
      if (!v11) {
LABEL_7:
      }
        std::__throw_bad_optional_access[abi:nn180100]();
      char v9 = 0;
      signed int v6 = v10 & 0xFFFFFFFE;
LABEL_6:
      *(_BYTE *)a3 = v9;
      this = (metadata_visitor::ResolvedValue *)metadata_visitor::Visitor::getValueFor( (uint64_t)a2,  v7 + v6,  1LL,  (void *)(a3 + 8));
      break;
    default:
      return this;
  }

  return this;
}

BOOL metadata_visitor::SwiftConformance::TypeContextDescriptor::isForeignMetadata( metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(_DWORD *)lsl::Allocator::Pool::allocator(this) & 0x30000) == 0x20000;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::hasImportInfo( metadata_visitor::SwiftConformance::TypeContextDescriptor *this)
{
  return (*(unsigned __int8 *)(lsl::Allocator::Pool::allocator(this) + 2) >> 2) & 1;
}

uint64_t metadata_visitor::SwiftConformance::TypeContextDescriptor::getName@<X0>( metadata_visitor::SwiftConformance::TypeContextDescriptor *this@<X0>, const metadata_visitor::SwiftVisitor *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = lsl::Allocator::Pool::allocator(this);
  metadata_visitor::Visitor::getField((uint64_t)a2, (char *)(v5 + 8), v10);
  uint64_t v6 = *(int *)lsl::Allocator::Pool::allocator((lsl::Allocator::Pool *)v10);
  uint64_t v7 = metadata_visitor::ResolvedValue::vmAddress((metadata_visitor::ResolvedValue *)v10);
  if (!v8) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return metadata_visitor::Visitor::getValueFor((uint64_t)a2, v7 + v6, 1LL, a3);
}

uint64_t dyld3::stat(dyld3 *this, stat *a2, stat *a3)
{
  __int128 v3 = (const char *)a2;
  uint64_t v4 = this;
  while (1)
  {
    uint64_t result = stat_with_subsystem((const char *)this, a2);
    if ((_DWORD)result != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
    this = v4;
    a2 = (stat *)v3;
  }

  return result;
}

uint64_t dyld3::fstatat(dyld3 *this, const char *a2, stat *a3, stat *a4)
{
  int v4 = (int)a4;
  uint64_t v5 = (const char *)a3;
  uint64_t v6 = a2;
  int v7 = (int)this;
  while (1)
  {
    uint64_t result = fstatat64((int)this, a2, a3, (int)a4);
    if ((_DWORD)result != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 4) {
      return 0xFFFFFFFFLL;
    }
    LODWORD(this) = v7;
    a2 = v6;
    a3 = (stat *)v5;
    LODWORD(a4) = v4;
  }

  return result;
}

uint64_t dyld3::open(dyld3 *this, const char *a2, uint64_t a3)
{
  int v4 = (int)a2;
  do
  {
    if ((v4 & 0x200) != 0) {
      uint64_t v6 = open((const char *)this, v4, a3);
    }
    else {
      uint64_t v6 = open_with_subsystem((const char *)this, v4);
    }
    uint64_t v7 = v6;
  }

  while ((_DWORD)v6 == -1 && (*__error() == 35 || *__error() == 4));
  return v7;
}

_DWORD *dyld3::FatFile::isFatFile(_DWORD *this, const void *a2)
{
  if ((*this | 0x1000000) != 0xBFBAFECA) {
    return 0LL;
  }
  return this;
}

BOOL dyld3::FatFile::isValidSlice( dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, unsigned int a4, int a5, int a6, unint64_t a7, unint64_t a8)
{
  if (a3 < a7 || a3 - a7 < a8)
  {
    Diagnostics::error(a2, "slice %d extends beyond end of file");
  }

  else
  {
    uint64_t v12 = (char *)this + a7;
    BOOL result = dyld3::MachOFile::isMachO((dyld3::FatFile *)((char *)this + a7), a2, a8);
    if (!result) {
      return result;
    }
    if (*((_DWORD *)v12 + 1) == a5)
    {
      int v14 = *((_DWORD *)v12 + 2);
      if (((v14 ^ a6) & 0xFFFFFF) != 0)
      {
        Diagnostics::error(a2, "cpu subtype in slice (0x%08X) does not match fat header (0x%08X)");
      }

      else
      {
        if (a5 == 33554444 || a5 == 16777228 || (uint64_t v15 = 4095LL, a5 == 12) && v14 == 12 && *((_DWORD *)v12 + 3) != 11) {
          uint64_t v15 = 0x3FFFLL;
        }
        if ((v15 & a7) == 0) {
          return 1LL;
        }
        if (_platform_strncmp(v12, "!<arch>", 7uLL)) {
          Diagnostics::error(a2, "slice is not page aligned");
        }
        else {
          Diagnostics::error(a2, "file is static library");
        }
      }
    }

    else
    {
      Diagnostics::error(a2, "cpu type in slice (0x%08X) does not match fat header (0x%08X)");
    }
  }

  return 0LL;
}

BOOL dyld3::MachOFile::isMachO(dyld3::MachOFile *this, vm_address_t *a2, unint64_t a3)
{
  if (a3 <= 0x1B)
  {
    Diagnostics::error(a2, "MachO header exceeds file length");
    return 0LL;
  }

  int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this >> 1 != 2138504551)
  {
    if ((v4 & 0xFEFFFFFF) != 0xCEFAEDFE) {
      Diagnostics::error(a2, "file does not start with MH_MAGIC[_64]");
    }
    return 0LL;
  }

  BOOL v5 = v4 == -17958193;
  uint64_t v6 = 28LL;
  if (v5) {
    uint64_t v6 = 32LL;
  }
  if (v6 + (unint64_t)*((unsigned int *)this + 5) > a3)
  {
    Diagnostics::error(a2, "load commands exceed length of first segment");
    return 0LL;
  }

  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)&__block_literal_global_2);
  return Diagnostics::noError((Diagnostics *)a2);
}

void dyld3::FatFile::forEachSlice( dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, int a4, uint64_t a5)
{
  if (*(_DWORD *)this == -1078264118)
  {
    unsigned int v10 = *((_DWORD *)this + 1);
    uint64_t v11 = bswap32(v10);
    if (v11 >= 0x80)
    {
      Diagnostics::error(a2, "fat header too large: %u entries", v11);
      return;
    }

    if (((32 * v11) | 8uLL) <= a3)
    {
      char v38 = 0;
      if (v10)
      {
        uint64_t v19 = 0LL;
        uint64_t v20 = v11 - 1;
        __int128 v21 = (char *)this + 12;
        do
        {
          uint64_t v22 = bswap32(*((_DWORD *)v21 - 1));
          uint64_t v23 = bswap32(*(_DWORD *)v21);
          unint64_t v24 = bswap64(*(void *)(v21 + 4));
          unint64_t v25 = bswap64(*(void *)(v21 + 12));
          if (!a4 || dyld3::FatFile::isValidSlice(this, a2, a3, v19, v22, v23, v24, v25)) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, unint64_t, char *))(a5 + 16))( a5,  v22,  v23,  (char *)this + v24,  v25,  &v38);
          }
          if (v38) {
            break;
          }
          v21 += 32;
        }

        while (v20 != v19++);
      }

      return;
    }

void dyld3::FatFile::forEachSlice(dyld3::FatFile *a1, vm_address_t *a2, unint64_t a3, uint64_t a4)
{
}

char *dyld3::FatFile::archNames(dyld3::FatFile *this, char *a2, unint64_t a3)
{
  *a2 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v10);
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  char v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke;
  void v7[3] = &unk_1896215B8;
  v7[4] = v8;
  v7[5] = a2;
  dyld3::FatFile::forEachSlice(this, (vm_address_t *)&v10, a3, 0, (uint64_t)v7);
  _Block_object_dispose(v8, 8);
  mach_o::Error::~Error(&v10);
  return a2;
}

size_t ___ZNK5dyld37FatFile9archNamesEPcy_block_invoke(uint64_t a1, int a2, int a3)
{
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
    strlcat(*(char **)(a1 + 40), ",", 0x100uLL);
  }
  uint64_t v6 = 0LL;
  uint64_t v7 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v6 + 1]) != a2
       || (a3 & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v6 + 3))
  {
    v6 += 2LL;
    if (v6 == 26) {
      goto LABEL_9;
    }
  }

  uint64_t v7 = (&dyld3::MachOFile::_s_archInfos)[v6];
LABEL_9:
  size_t result = strlcat(*(char **)(a1 + 40), v7, 0x100uLL);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  return result;
}

BOOL dyld3::FatFile::isFatFileWithSlice( dyld3::FatFile *this, vm_address_t *a2, unint64_t a3, const dyld3::GradedArchs *a4, char a5, unint64_t *a6, unint64_t *a7, BOOL *a8)
{
  *a8 = 0;
  if ((*(_DWORD *)this | 0x1000000) != 0xBFBAFECA) {
    return 0LL;
  }
  uint64_t v16 = 0LL;
  unint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  int v19 = 0;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  _WORD v14[2] = ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke;
  uint64_t v14[3] = &unk_1896215E0;
  char v15 = a5;
  _OWORD v14[4] = &v16;
  void v14[5] = this;
  void v14[6] = a4;
  void v14[7] = a6;
  _BYTE v14[8] = a7;
  dyld3::FatFile::forEachSlice(this, a2, a3, 1, (uint64_t)v14);
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  BOOL v11 = 0LL;
  if (!hasError)
  {
    int v12 = *((_DWORD *)v17 + 6);
    if (!v12) {
      *a8 = 1;
    }
    BOOL v11 = v12 != 0;
  }

  _Block_object_dispose(&v16, 8);
  return v11;
}

uint64_t ___ZNK5dyld37FatFile18isFatFileWithSliceER11DiagnosticsyRKNS_11GradedArchsEbRyS6_Rb_block_invoke( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t result = dyld3::GradedArchs::grade(*(dyld3::GradedArchs **)(a1 + 48), a2, a3, *(_BYTE *)(a1 + 72));
  if ((_DWORD)result)
  {
    if ((int)result > *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      unsigned int v10 = *(void **)(a1 + 64);
      **(void **)(a1 + 56) = a4 - v8;
      *unsigned int v10 = a5;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
    }
  }

  return result;
}

uint64_t dyld3::GradedArchs::grade(dyld3::GradedArchs *this, int a2, int a3, char a4)
{
  uint64_t v4 = 0LL;
  while (1)
  {
    int v5 = *(_DWORD *)((char *)this + v4);
    if (!v5) {
      return 0LL;
    }
    if (v5 == a2
      && *(_DWORD *)((char *)this + v4 + 4) == (a3 & 0xFFFFFF)
      && (!*((_BYTE *)this + v4 + 8) || (a4 & 1) != 0))
    {
      break;
    }

    v4 += 12LL;
    if (v4 == 48) {
      return 0LL;
    }
  }

  return *(unsigned __int16 *)((char *)this + v4 + 10);
}

uint64_t dyld3::GradedArchs::forEachArch(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v5 = result;
  for (uint64_t i = 0LL; i != 4; ++i)
  {
    int v7 = *(_DWORD *)(v5 + 12 * i);
    if (!v7) {
      break;
    }
    if (*(_BYTE *)(v5 + 12 * i + 8)) {
      BOOL v8 = a2 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8)
    {
      uint64_t v9 = 0LL;
      while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v9 + 1]) != v7
           || (*(_DWORD *)(v5 + 12 * i + 4) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v9 + 3))
      {
        v9 += 2LL;
        if (v9 == 26)
        {
          unsigned int v10 = "unknown";
          goto LABEL_13;
        }
      }

      unsigned int v10 = (&dyld3::MachOFile::_s_archInfos)[v9];
LABEL_13:
      uint64_t result = (*(uint64_t (**)(uint64_t, const char *))(a3 + 16))(a3, v10);
    }
  }

  return result;
}

uint64_t dyld3::GradedArchs::checksOSBinary(dyld3::GradedArchs *this)
{
  for (uint64_t i = 0LL; i != 48; i += 12LL)
  {
    int v2 = *(_DWORD *)((char *)this + i);
    if (!v2) {
      break;
    }
    LOBYTE(v2) = *((_BYTE *)this + i + 8);
    if ((_BYTE)v2)
    {
      LOBYTE(v2) = 1;
      return v2 & 1;
    }
  }

  return v2 & 1;
}

void *dyld3::GradedArchs::forCurrentOS(dyld3::GradedArchs *this)
{
  return &dyld3::GradedArchs::arm64;
}

BOOL dyld3::MachOFile::is64(dyld3::MachOFile *this)
{
  return *(_DWORD *)this == -17958193;
}

uint64_t dyld3::MachOFile::maskedCpuSubtype(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 2) & 0xFFFFFF;
}

uint64_t dyld3::MachOFile::pointerSize(dyld3::MachOFile *this)
{
  if (*(_DWORD *)this == -17958193) {
    return 8LL;
  }
  else {
    return 4LL;
  }
}

BOOL dyld3::MachOFile::isArch(dyld3::MachOFile *this, const char *__s1)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v3 + 1]) != *((_DWORD *)this + 1)
       || (*((_DWORD *)this + 2) & 0xFFFFFF) != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v3 + 3))
  {
    v3 += 2LL;
    if (v3 == 26) {
      return _platform_strcmp(__s1, v4) == 0;
    }
  }

  uint64_t v4 = (&dyld3::MachOFile::_s_archInfos)[v3];
  return _platform_strcmp(__s1, v4) == 0;
}

const char *dyld3::MachOFile::archName(dyld3::MachOFile *this)
{
  uint64_t v1 = 0LL;
  int v2 = *((_DWORD *)this + 1);
  int v3 = *((_DWORD *)this + 2) & 0xFFFFFF;
  uint64_t result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_archInfos)[v1 + 1]) != v2
       || v3 != *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * v1 + 3))
  {
    v1 += 2LL;
    if (v1 == 26) {
      return result;
    }
  }

  return (&dyld3::MachOFile::_s_archInfos)[v1];
}

void *dyld3::MachOFile::packedVersionToString(dyld3::MachOFile *this, _BYTE *a2, char *a3)
{
  __int16 v3 = (__int16)this;
  int v7 = a2;
  dyld3::appendNumber(&v7, (char **)(this >> 16));
  uint64_t v4 = v7;
  *int v7 = 46;
  int v7 = v4 + 1;
  uint64_t result = dyld3::appendNumber(&v7, (char **)HIBYTE(v3));
  if ((_BYTE)v3)
  {
    uint64_t v6 = v7;
    *int v7 = 46;
    int v7 = v6 + 1;
    uint64_t result = dyld3::appendNumber(&v7, (char **)v3);
  }

  *int v7 = 0;
  return result;
}

void *dyld3::appendNumber(void *this, char **a2)
{
  if (a2 >> 4 > 0x270)
  {
    __int16 v3 = (_BYTE *)(*this)++;
    *__int16 v3 = a2 / 0x2710 + 48;
    LODWORD(a2) = a2 % 0x2710;
    if (a2 < 0x3E8)
    {
      uint64_t v4 = (_BYTE *)(*this)++;
      _BYTE *v4 = 48;
      goto LABEL_10;
    }

BOOL dyld3::MachOFile::builtForPlatform(_DWORD *a1, int a2, int a3)
{
  uint64_t v14 = 0LL;
  char v15 = &v14;
  uint64_t v16 = 0x2000000000LL;
  char v17 = 0;
  uint64_t v10 = 0LL;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  char v13 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke;
  void v8[3] = &unk_189621858;
  int v9 = a2;
  void v8[4] = &v14;
  v8[5] = &v10;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v8);
  if (!*((_BYTE *)v11 + 24) || (BOOL v6 = 0LL, !a3))
  {
    if (*((_BYTE *)v15 + 24))
    {
      BOOL v6 = 1LL;
    }

    else
    {
      BOOL v6 = 0LL;
      if (a2 == 1 && !*((_BYTE *)v11 + 24)) {
        BOOL v6 = ((a1[1] - 7) & 0xFEFFFFFF) == 0;
      }
    }
  }

  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v6;
}

void dyld3::MachOFile::forEachSupportedPlatform(_DWORD *a1, uint64_t a2)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x2000000000LL;
  char v6 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke;
  void v4[3] = &unk_1896218B0;
  void v4[5] = v5;
  void v4[6] = a1;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v7, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v7);
  _Block_object_dispose(v5, 8);
  mach_o::Error::~Error(&v7);
}

uint64_t ___ZNK5dyld39MachOFile16builtForPlatformENS_8PlatformEb_block_invoke(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 48) == a2) {
    uint64_t v2 = *(void *)(result + 32);
  }
  else {
    uint64_t v2 = *(void *)(result + 40);
  }
  *(_BYTE *)(*(void *)(v2 + 8) + 24LL) = 1;
  return result;
}

uint64_t dyld3::MachOFile::loadableIntoProcess(_DWORD *a1, unsigned int a2, const char *a3, int a4)
{
  if (!dyld3::MachOFile::builtForPlatform(a1, a2, 0))
  {
    if (a2 <= 0xC && ((1 << a2) & 0x1380) != 0)
    {
      if (dyld3::MachOFile::builtForPlatform(a1, 1, 0))
      {
        uint64_t v10 = 0LL;
        while (_platform_strcmp( dyld3::MachOFile::loadableIntoProcess(dyld3::Platform,char const*,BOOL)const::macOSHost[v10],  a3))
        {
          if (++v10 == 6) {
            goto LABEL_10;
          }
        }

        return 1LL;
      }
    }

    else
    {
LABEL_10:
      if (a2 == 1 && a1[3] == 2)
      {
        uint64_t v8 = 1LL;
        BOOL v11 = a1;
        int v12 = 6;
        goto LABEL_17;
      }
    }

    if (a2 == 7)
    {
      uint64_t v8 = 1LL;
      BOOL v11 = a1;
      int v12 = 12;
    }

    else
    {
      if (a2 != 2) {
        goto LABEL_18;
      }
      uint64_t v8 = 1LL;
      BOOL v11 = a1;
      int v12 = 11;
    }

uint64_t dyld3::MachOFile::isSimulatorPlatform(int a1, int *a2)
{
  uint64_t result = 0LL;
  switch(a1)
  {
    case 7:
      if (!a2) {
        return 1LL;
      }
      int v4 = 2;
      break;
    case 8:
      if (!a2) {
        return 1LL;
      }
      int v4 = 3;
      break;
    case 9:
      if (!a2) {
        return 1LL;
      }
      int v4 = 4;
      break;
    case 12:
      if (!a2) {
        return 1LL;
      }
      int v4 = 11;
      break;
    default:
      return result;
  }

  *a2 = v4;
  return 1LL;
}

uint64_t dyld3::MachOFile::inDyldCache(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 6) >> 31;
}

uint64_t dyld3::MachOFile::basePlatform(uint64_t result)
{
  return result;
}

uint64_t dyld3::MachOFile::isExclaveKitPlatform(int a1, _DWORD *a2)
{
  if (a1 == 20)
  {
    if (a2)
    {
      LODWORD(result) = 3;
LABEL_10:
      *a2 = result;
    }

    return 1LL;
  }

  if (a1 == 18)
  {
    if (a2)
    {
      LODWORD(result) = 2;
      goto LABEL_10;
    }

    return 1LL;
  }

  if (a1 != 16) {
    return 0LL;
  }
  uint64_t result = 1LL;
  if (a2) {
    goto LABEL_10;
  }
  return result;
}

BOOL dyld3::MachOFile::isDylib(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 6;
}

BOOL dyld3::MachOFile::isBundle(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 8;
}

BOOL dyld3::MachOFile::isMainExecutable(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 2;
}

uint64_t dyld3::MachOFile::hasLoadCommand(dyld3::MachOFile *this, int a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke;
  void v6[3] = &unk_189621B40;
  int v7 = a2;
  v6[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v8, (uint64_t)v6);
  uint64_t v4 = *((unsigned __int8 *)v10 + 24);
  mach_o::Error::~Error(&v8);
  _Block_object_dispose(&v9, 8);
  return v4;
}

BOOL dyld3::MachOFile::isFileSet(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 12;
}

BOOL dyld3::MachOFile::isPreload(dyld3::MachOFile *this)
{
  return *((_DWORD *)this + 3) == 5;
}

const char *dyld3::MachOFile::platformName(int a1)
{
  uint64_t v2 = 0LL;
  uint64_t result = "unknown";
  while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v2 + 1]) != a1)
  {
    v2 += 2LL;
    if (v2 == 48) {
      return result;
    }
  }

  return (&dyld3::MachOFile::_s_platformInfos)[v2];
}

_DWORD *dyld3::MachOFile::forEachLoadCommand(_DWORD *result, vm_address_t *this, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *result;
  if (*result == -17958193)
  {
    uint64_t v7 = 8LL;
  }

  else
  {
    if (v6 != -17958194)
    {
      if ((v6 & 0xFEFFFFFF) != 0xCEFAEDFE) {
        return (_DWORD *)Diagnostics::error(this, "file does not start with MH_MAGIC[_64]: 0x%08X 0x%08X");
      }
      return result;
    }

    uint64_t v7 = 7LL;
  }

  if (result[3] >= 0xDu) {
    return (_DWORD *)Diagnostics::error(this, "unknown mach-o filetype (%u)");
  }
  if (result[4])
  {
    unsigned int v8 = 0;
    uint64_t v9 = &result[v7];
    unint64_t v10 = (unint64_t)&result[v7] + result[5];
    unint64_t v11 = (unint64_t)&result[v7];
    while (1)
    {
      if (v11 > v10 - 8) {
        return (_DWORD *)Diagnostics::error( this,  "malformed load command #%u of %u at %p with mh=%p, extends past sizeofcmds");
      }
      uint64_t v12 = *(unsigned int *)(v11 + 4);
      if (v12 <= 7) {
        return (_DWORD *)Diagnostics::error( this,  "malformed load command #%u of %u at %p with mh=%p, size (0x%X) too small");
      }
      if ((v12 & 3) != 0) {
        break;
      }
      unint64_t v13 = v11 + v12;
      if (v11 + v12 > v10 || v13 < (unint64_t)v9) {
        return (_DWORD *)Diagnostics::error( this,  "malformed load command #%u of %u at %p with mh=%p, size (0x%X) is too large, load commands end at %p");
      }
      uint64_t result = (_DWORD *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      ++v8;
      unint64_t v11 = v13;
      if (v8 >= v5[4]) {
        return result;
      }
    }

    return (_DWORD *)Diagnostics::error( this,  "malformed load command #%u of %u at %p with mh=%p, size (0x%X) not multiple of 4");
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile24forEachSupportedPlatformEU13block_pointerFvNS_8PlatformEjjE_block_invoke( uint64_t result, int *a2)
{
  uint64_t v2 = result;
  int v3 = *a2;
  if (*a2 <= 46)
  {
    if (v3 == 36)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16LL);
    }

    else
    {
      if (v3 != 37) {
        return result;
      }
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16LL);
    }

    goto LABEL_13;
  }

  if (v3 != 47)
  {
    if (v3 != 48)
    {
      if (v3 != 50) {
        return result;
      }
      uint64_t v4 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16LL);
      goto LABEL_10;
    }

    uint64_t v5 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16LL);
LABEL_13:
    uint64_t result = v5();
    goto LABEL_14;
  }

  uint64_t v4 = *(uint64_t (**)(void))(*(void *)(result + 32) + 16LL);
LABEL_10:
  uint64_t result = v4();
LABEL_14:
  *(_BYTE *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL) = 1;
  return result;
}

BOOL dyld3::MachOFile::hasMachOMagic(dyld3::MachOFile *this)
{
  return *(_DWORD *)this >> 1 == 2138504551;
}

_DWORD *dyld3::MachOFile::isMachO(_DWORD *this, const void *a2)
{
  if (*this >> 1 != 2138504551) {
    return 0LL;
  }
  return this;
}

uint64_t dyld3::MachOFile::hasObjC(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke;
  void v3[3] = &unk_189621918;
  void v3[4] = &v4;
  void v3[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void dyld3::MachOFile::forEachSection(_DWORD *a1, uint64_t a2)
{
  BOOL v4 = a1[1] == 7;
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  int v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke;
  void v5[3] = &unk_189621A78;
  void v5[6] = a1;
  void v5[7] = &v10;
  v5[4] = a2;
  void v5[5] = v7;
  BOOL v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

uint64_t ___ZNK5dyld39MachOFile7hasObjCEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  int v8 = *(const char **)(a2 + 80);
  uint64_t result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  if (*(_DWORD *)(v7 + 4) == 7)
  {
    uint64_t result = _platform_strcmp(v8, "__image_info");
    if (!(_DWORD)result)
    {
      uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!(_DWORD)result)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
        *a4 = 1;
      }
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::hasConstObjCSection(dyld3::MachOFile *this)
{
  if ((dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_selrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_classrefs") & 1) != 0
    || (dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_protorefs") & 1) != 0)
  {
    return 1LL;
  }

  else
  {
    return dyld3::MachOFile::hasSection(this, "__DATA_CONST", "__objc_superrefs");
  }

uint64_t dyld3::MachOFile::hasSection(dyld3::MachOFile *this, const char *a2, const char *a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke;
  void v5[3] = &unk_189621940;
  void v5[5] = a2;
  void v5[6] = a3;
  v5[4] = &v6;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile10hasSectionEPKcS2__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 40));
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

char *dyld3::MachOFile::installName(dyld3::MachOFile *this)
{
  else {
    return 0LL;
  }
}

uint64_t dyld3::MachOFile::getDylibInstallName( dyld3::MachOFile *this, const char **a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _OWORD v10[2] = ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke;
  void v10[3] = &unk_189621968;
  void v10[6] = a4;
  void v10[7] = a2;
  void v10[4] = &v11;
  v10[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v15, (uint64_t)v10);
  Diagnostics::assertNoError((Diagnostics *)&v15);
  uint64_t v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  mach_o::Error::~Error(&v15);
  return v8;
}

uint64_t ___ZNK5dyld39MachOFile19getDylibInstallNameEPPKcPjS4__block_invoke( uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if ((*a2 | 2) == 0xF)
  {
    unsigned int v3 = *(_DWORD **)(result + 48);
    **(_DWORD **)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2[5];
    *unsigned int v3 = a2[4];
    **(void **)(result + 56) = (char *)a2 + a2[2];
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

BOOL dyld3::MachOFile::getUuid(dyld3::MachOFile *this, unsigned __int8 *a2)
{
  uint64_t v8 = 0LL;
  char v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  char v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke;
  void v7[3] = &unk_189621990;
  v7[4] = &v8;
  v7[5] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v12, (uint64_t)v7);
  Diagnostics::assertNoError((Diagnostics *)&v12);
  BOOL v4 = v9;
  if (*((_BYTE *)v9 + 24))
  {
    BOOL v5 = 1LL;
  }

  else
  {
    bzero(a2, 0x10uLL);
    BOOL v5 = *((_BYTE *)v4 + 24) != 0;
  }

  _Block_object_dispose(&v8, 8);
  mach_o::Error::~Error(&v12);
  return v5;
}

__n128 ___ZNK5dyld39MachOFile7getUuidEPh_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (*(_DWORD *)a2 == 27)
  {
    __n128 result = *(__n128 *)(a2 + 8);
    *(__n128 *)*(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

void dyld3::MachOFile::forEachDependentDylib(dyld3::MachOFile *a1, uint64_t a2)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  int v15 = 0;
  uint64_t v8 = 0LL;
  char v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  char v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke;
  void v7[3] = &unk_1896219B8;
  v7[4] = a2;
  v7[5] = &v12;
  void v7[6] = &v8;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v16, (uint64_t)v7);
  if (!*((_DWORD *)v13 + 6) && !*((_BYTE *)v9 + 24))
  {
    if (dyld3::MachOFile::builtForPlatform(a1, 10, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || (!dyld3::MachOFile::getDylibInstallName(a1, (const char **)&v19, &v18, &v17)
          ? (BOOL v4 = 0LL)
          : (BOOL v4 = v19),
            _platform_strncmp(v4, "/System/DriverKit/usr/lib/system/", 0x21uLL)))
      {
        BOOL v5 = "/System/DriverKit/usr/lib/libSystem.B.dylib";
LABEL_10:
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, uint64_t, uint64_t *))(a2 + 16))( a2,  v5,  0LL,  0LL,  0LL,  0x10000LL,  0x10000LL,  v9 + 3);
      }
    }

    else if (!dyld3::MachOFile::builtForPlatform(a1, 16, 1) {
           && !dyld3::MachOFile::builtForPlatform(a1, 18, 1)
    }
           && !dyld3::MachOFile::builtForPlatform(a1, 20, 1))
    {
      if (*((_DWORD *)a1 + 3) != 6
        || (!dyld3::MachOFile::getDylibInstallName(a1, (const char **)&v19, &v18, &v17)
          ? (uint64_t v6 = 0LL)
          : (uint64_t v6 = v19),
            _platform_strncmp(v6, "/usr/lib/system/", 0x10uLL)))
      {
        BOOL v5 = "/usr/lib/libSystem.B.dylib";
        goto LABEL_10;
      }
    }
  }

  Diagnostics::assertNoError((Diagnostics *)&v16);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  mach_o::Error::~Error(&v16);
}

uint64_t ___ZNK5dyld39MachOFile21forEachDependentDylibEU13block_pointerFvPKcbbbjjRbE_block_invoke( uint64_t result, char *a2, _BYTE *a3)
{
  int v3 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 + 2147483624) <= 0xB && ((1 << (*(_DWORD *)a2 - 24)) & 0x881) != 0 || v3 == 12)
  {
    uint64_t v7 = result;
    __n128 result = (*(uint64_t (**)(void, char *, BOOL, BOOL, BOOL, void, void, _BYTE *))(*(void *)(result + 32)
                                                                                                  + 16LL))( *(void *)(result + 32),  &a2[*((unsigned int *)a2 + 2)],  v3 == -2147483624,  v3 == -2147483617,  v3 == -2147483613,  *((unsigned int *)a2 + 5),  *((unsigned int *)a2 + 4),  a3);
    ++*(_DWORD *)(*(void *)(*(void *)(v7 + 40) + 8LL) + 24LL);
    if (*a3) {
      *(_BYTE *)(*(void *)(*(void *)(v7 + 48) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

void dyld3::MachOFile::forDyldEnv(_DWORD *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke;
  void v4[3] = &unk_1896219E0;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

char *___ZNK5dyld39MachOFile10forDyldEnvEU13block_pointerFvPKcRbE_block_invoke(char *result, _DWORD *a2)
{
  if (*a2 == 39)
  {
    unsigned int v2 = result;
    int v3 = (char *)a2 + a2[2];
    __n128 result = (char *)_platform_strncmp(v3, "DYLD_", 5uLL);
    if (!(_DWORD)result)
    {
      __n128 result = _platform_strchr(v3, 61);
      if (result) {
        return (char *)(*(uint64_t (**)(void))(*((void *)v2 + 4) + 16LL))();
      }
    }
  }

  return result;
}

thread_command dyld3::MachOFile::entryAddrFromThreadCmd(dyld3::MachOFile *this, const thread_command *a2)
{
  if (a2->cmd != 5) {
    dyld3::MachOFile::entryAddrFromThreadCmd();
  }
  uint64_t v2 = 0LL;
  int v3 = *((_DWORD *)this + 1);
  if (v3 <= 16777222)
  {
    if (v3 == 7)
    {
      uint64_t v5 = 10LL;
    }

    else
    {
      if (v3 != 12) {
        return (thread_command)v2;
      }
      uint64_t v5 = 15LL;
    }
  }

  else if (v3 == 33554444 || v3 == 16777228)
  {
    uint64_t v5 = 32LL;
  }

  else
  {
    if (v3 != 16777223) {
      return (thread_command)v2;
    }
    uint64_t v5 = 16LL;
  }

  uint64_t v6 = a2 + 2;
  if (*(_DWORD *)this == -17958193 || dyld3::MachOFile::isArch(this, "arm64_32")) {
    return v6[v5];
  }
  else {
    return (thread_command)*(&v6->cmd + v5);
  }
}

BOOL dyld3::MachOFile::getEntry(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  *a2 = 0LL;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld39MachOFile8getEntryERyRb_block_invoke;
  void v8[3] = &__block_descriptor_tmp_104_0;
  void v8[4] = this;
  v8[5] = a3;
  void v8[6] = a2;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v8);
  BOOL v6 = *a2 != 0;
  mach_o::Error::~Error(&v9);
  return v6;
}

void *___ZNK5dyld39MachOFile8getEntryERyRb_block_invoke(void *result, uint64_t a2, _BYTE *a3)
{
  int v3 = result;
  if (*(_DWORD *)a2 == 5)
  {
    BOOL v6 = (dyld3::MachOFile *)result[4];
    uint64_t v5 = (_BYTE *)result[5];
    *a3 = 1;
    *uint64_t v5 = 1;
    thread_command v7 = dyld3::MachOFile::entryAddrFromThreadCmd(v6, (const thread_command *)a2);
    __n128 result = (void *)dyld3::MachOFile::preferredLoadAddress(v6);
    *(void *)void v3[6] = *(void *)&v7 - (void)result;
  }

  else if (*(_DWORD *)a2 == -2147483608)
  {
    BOOL v4 = (void *)result[6];
    *(_BYTE *)result[5] = 0;
    void *v4 = *(void *)(a2 + 8);
    *a3 = 1;
  }

  return result;
}

uint64_t dyld3::MachOFile::preferredLoadAddress(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke;
  void v3[3] = &unk_189621A50;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void dyld3::MachOFile::forEachSegment(_DWORD *a1, uint64_t a2)
{
  BOOL v4 = a1[1] == 7;
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  int v8 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke;
  void v5[3] = &unk_189621A28;
  void v5[5] = v7;
  void v5[6] = a1;
  v5[4] = a2;
  BOOL v6 = v4;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v9, (uint64_t)v5);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  _Block_object_dispose(v7, 8);
  mach_o::Error::~Error(&v9);
}

uint64_t ___ZNK5dyld39MachOFile14forEachSegmentEU13block_pointerFvRKNS0_11SegmentInfoERbE_block_invoke( uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    unint64_t v13 = *(unsigned int *)(a2 + 28);
    unsigned int v14 = *(_DWORD *)(a2 + 48);
    if (v14)
    {
      int v15 = 0;
      LOBYTE(v16) = 0;
      unint64_t v17 = a2 + 56;
      unint64_t v18 = a2 + 56 + 68LL * v14;
      do
      {
        v15 |= (*(_BYTE *)(v17 + 57) & 3) != 0;
        v17 += 68LL;
      }

      while (v17 < v18);
      int v19 = *(_DWORD *)(v17 - 32) + *(_DWORD *)(v17 - 36);
      unsigned int v20 = *(_DWORD *)(a2 + 24);
      unsigned int v21 = v19 - v20;
      int v22 = v16 << 16;
    }

    else
    {
      int v22 = 0;
      int v15 = 0;
      unsigned int v20 = *(_DWORD *)(a2 + 24);
      unsigned int v21 = *(_DWORD *)(a2 + 28);
    }

    unint64_t v29 = *(unsigned int *)(a2 + 36);
    uint64_t v36 = *(unsigned int *)(a2 + 32);
    unint64_t v37 = v29;
    uint64_t v38 = v20;
    unint64_t v39 = v13;
    uint64_t v40 = v21;
    uint64_t v41 = a2 + 8;
    int v30 = *(_DWORD *)(a2 + 44);
    int v42 = a2 - v3;
    int v43 = v30;
    BOOL v32 = (v30 & 2) == 0 && *(_BYTE *)(result + 56) != 0;
    int v33 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v32 & v15;
    else {
      int v35 = 0;
    }
    uint64_t v27 = *(void *)(result + 32);
    int v28 = v35 | v22 | v33 | (16 * (*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL) & 0xFFF));
  }

  else
  {
    if (*(_DWORD *)a2 != 25) {
      return result;
    }
    unint64_t v4 = *(void *)(a2 + 32);
    unsigned int v5 = *(_DWORD *)(a2 + 64);
    if (v5)
    {
      LOBYTE(v6) = 0;
      unint64_t v7 = a2 + 72;
      unint64_t v8 = a2 + 72 + 80LL * v5;
      do
      {
        v7 += 80LL;
      }

      while (v7 < v8);
      uint64_t v9 = *(void *)(v7 - 40) + *(void *)(v7 - 48);
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v11 = v9 - v10;
      int v12 = v6 << 16;
    }

    else
    {
      int v12 = 0;
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v11 = *(void *)(a2 + 32);
    }

    unint64_t v23 = *(void *)(a2 + 48);
    uint64_t v36 = *(void *)(a2 + 40);
    unint64_t v37 = v23;
    uint64_t v38 = v10;
    unint64_t v39 = v4;
    uint64_t v40 = v11;
    uint64_t v41 = a2 + 8;
    int v24 = *(_DWORD *)(a2 + 60);
    int v42 = a2 - v3;
    int v43 = v24;
    if (v23 < v4 && v24 == 3) {
      int v26 = 8;
    }
    else {
      int v26 = 0;
    }
    uint64_t v27 = *(void *)(result + 32);
    int v28 = v26 | v12 | (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | (16
                                                                                         * (*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL) & 0xFFF));
  }

  int v44 = v28;
  __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *))(v27 + 16))(v27, &v36);
  ++*(_DWORD *)(*(void *)(*(void *)(v2 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t ___ZNK5dyld39MachOFile20preferredLoadAddressEv_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__TEXT");
  if (!(_DWORD)result)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(a2 + 16);
    *a3 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile14forEachSectionEU13block_pointerFvRKNS0_11SectionInfoEbRbE_block_invoke( uint64_t result, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = result;
  uint64_t v11 = *(void *)(result + 48);
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t v20 = *(unsigned int *)(a2 + 28);
    unint64_t v21 = a2 + 56;
    unsigned int v22 = *(_DWORD *)(a2 + 48);
    unint64_t v23 = a2 + 56 + 68LL * v22;
    if (v22)
    {
      int v24 = 0;
      LOBYTE(v25) = 0;
      do
      {
        v24 |= (*(_BYTE *)(v21 + 57) & 3) != 0;
        v21 += 68LL;
      }

      while (v21 < v23);
      unsigned int v26 = *(_DWORD *)(a2 + 24);
      unsigned int v27 = *(_DWORD *)(v21 - 32) + *(_DWORD *)(v21 - 36) - v26;
      int v28 = v25 << 16;
    }

    else
    {
      int v28 = 0;
      int v24 = 0;
      unsigned int v26 = *(_DWORD *)(a2 + 24);
      unsigned int v27 = *(_DWORD *)(a2 + 28);
    }

    uint64_t v42 = *(void *)(a2 + 32);
    *(void *)&__int128 v43 = v42;
    *((void *)&v43 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = HIDWORD(v42);
    __int128 v57 = v43;
    uint64_t v58 = v26;
    uint64_t v59 = v20;
    uint64_t v60 = v27;
    uint64_t v61 = a2 + 8;
    int v44 = *(_DWORD *)(a2 + 44);
    int v62 = a2 - v11;
    int v63 = v44;
    unint64_t v31 = (uint64_t *)(result + 40);
    uint64_t v30 = *(void *)(result + 40);
    BOOL v46 = (v44 & 2) == 0 && *(_BYTE *)(result + 64) != 0;
    int v64 = (*(_DWORD *)(a2 + 52) >> 3) & 2 | v46 & v24 & 0xFF0007 | (*(_DWORD *)(a2 + 52) >> 1) & 4 | v28 & 0xFF0007 | (16 * (*(_DWORD *)(*(void *)(v30 + 8) + 24LL) & 0xFFF));
    if (*a3 || !v22) {
      goto LABEL_57;
    }
    unint64_t v47 = a2 + 124;
    do
    {
      uint64_t v48 = (const char *)(v47 - 68);
      if (*(_BYTE *)(v47 - 53))
      {
        strlcpy(*(char **)(v10 + 56), v48, 0x11uLL);
        uint64_t v48 = *(const char **)(v10 + 56);
      }

      unsigned int v49 = *(_DWORD *)(a2 + 24);
      unint64_t v50 = *(unsigned int *)(v47 - 36);
      if (v50 >= v49)
      {
        unsigned int v52 = *(_DWORD *)(a2 + 36) + v49;
        BOOL v39 = v52 >= v50;
        unsigned int v53 = v52 - v50;
        uint64_t v51 = !v39 || v53 < *(_DWORD *)(v47 - 32);
      }

      else
      {
        uint64_t v51 = 1LL;
      }

      uint64_t v66 = *(unsigned int *)(v47 - 32);
      uint64_t v67 = v48;
      int v55 = *(_DWORD *)(v47 - 12);
      int v56 = *(_DWORD *)(v47 - 24);
      int v68 = *(_DWORD *)(v47 - 28);
      int v69 = v55;
      unint64_t v65 = v50;
      int v70 = v56;
      uint64_t v71 = *(void *)(v47 - 8);
      uint64_t result = (*(uint64_t (**)(void, __int128 *, uint64_t, _BYTE *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 32) + 16LL))( *(void *)(v10 + 32),  &v57,  v51,  a3,  a5,  a6,  a7,  a8);
      if (*a3) {
        break;
      }
      BOOL v39 = v47 >= v23;
      v47 += 68LL;
    }

    while (!v39);
    goto LABEL_56;
  }

  if (*(_DWORD *)a2 != 25) {
    return result;
  }
  uint64_t v12 = *(void *)(a2 + 32);
  unint64_t v13 = a2 + 72;
  unsigned int v14 = *(_DWORD *)(a2 + 64);
  unint64_t v15 = a2 + 72 + 80LL * v14;
  if (v14)
  {
    LOBYTE(v16) = 0;
    do
    {
      v13 += 80LL;
    }

    while (v13 < v15);
    uint64_t v17 = *(void *)(a2 + 24);
    uint64_t v18 = *(void *)(v13 - 40) + *(void *)(v13 - 48) - v17;
    int v19 = v16 << 16;
  }

  else
  {
    int v19 = 0;
    uint64_t v17 = *(void *)(a2 + 24);
    uint64_t v18 = *(void *)(a2 + 32);
  }

  __int128 v57 = *(_OWORD *)(a2 + 40);
  uint64_t v58 = v17;
  uint64_t v59 = v12;
  uint64_t v60 = v18;
  uint64_t v61 = a2 + 8;
  int v29 = *(_DWORD *)(a2 + 60);
  int v62 = a2 - v11;
  int v63 = v29;
  int v64 = (*(_DWORD *)(a2 + 68) >> 3) & 2 | (*(_DWORD *)(a2 + 68) >> 1) & 4 | v19;
  unint64_t v31 = (uint64_t *)(result + 40);
  uint64_t v30 = *(void *)(result + 40);
  int v64 = v64 & 0xFF0006 | (16 * (*(_DWORD *)(*(void *)(v30 + 8) + 24LL) & 0xFFF));
  if (!*a3 && v14)
  {
    unint64_t v32 = a2 + 152;
    do
    {
      int v33 = (const char *)(v32 - 80);
      if (*(_BYTE *)(v32 - 65))
      {
        strlcpy(*(char **)(v10 + 56), v33, 0x11uLL);
        int v33 = *(const char **)(v10 + 56);
      }

      unint64_t v34 = *(void *)(a2 + 24);
      unint64_t v35 = *(void *)(v32 - 48);
      if (v35 >= v34)
      {
        unint64_t v37 = *(void *)(a2 + 48) + v34;
        BOOL v39 = v37 >= v35;
        unint64_t v38 = v37 - v35;
        BOOL v39 = v39 && v38 >= *(void *)(v32 - 40);
        uint64_t v36 = !v39;
      }

      else
      {
        uint64_t v36 = 1LL;
      }

      uint64_t v66 = *(void *)(v32 - 40);
      uint64_t v67 = v33;
      int v40 = *(_DWORD *)(v32 - 16);
      int v41 = *(_DWORD *)(v32 - 28);
      int v68 = *(_DWORD *)(v32 - 32);
      int v69 = v40;
      unint64_t v65 = v35;
      int v70 = v41;
      uint64_t v71 = *(void *)(v32 - 12);
      uint64_t result = (*(uint64_t (**)(void, __int128 *, uint64_t, _BYTE *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 32) + 16LL))( *(void *)(v10 + 32),  &v57,  v36,  a3,  a5,  a6,  a7,  a8);
      if (*a3) {
        break;
      }
      BOOL v39 = v32 >= v15;
      v32 += 80LL;
    }

    while (!v39);
LABEL_56:
    uint64_t v30 = *v31;
  }

void dyld3::MachOFile::forEachInterposingSection(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = *a1 == -17958193;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke;
  void v5[3] = &unk_189621AA0;
  if (v3) {
    int v4 = 8;
  }
  else {
    int v4 = 4;
  }
  void v5[5] = a1;
  void v5[6] = a2;
  int v6 = 2 * v4;
  int v7 = v4;
  v5[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

uint64_t ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke( uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  unint64_t v8 = *(dyld3::MachOFile **)(a1 + 40);
  if (*(_BYTE *)(a2 + 92) == 13
    || (uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__interpose"), !(_DWORD)result)
    && ((uint64_t v10 = *(const char **)(a2 + 40), !_platform_strncmp(v10, "__DATA", 6uLL))
     || (uint64_t result = _platform_strncmp(v10, "__AUTH", 6uLL), !(_DWORD)result)))
  {
    if (*(void *)(a2 + 72) % (unint64_t)*(unsigned int *)(a1 + 56))
    {
      uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s has bad size");
    }

    else if (a3)
    {
      uint64_t result = Diagnostics::error( *(vm_address_t **)(a1 + 48),  "interposing section %s/%s extends beyond the end of the segment");
    }

    else
    {
      unint64_t v11 = *(void *)(a2 + 64);
      if (!(v11 % *(unsigned int *)(a1 + 60)))
      {
        uint64_t v12 = *(void *)(a1 + 32);
        uint64_t v13 = v11 - dyld3::MachOFile::preferredLoadAddress(v8);
        return (*(uint64_t (**)(uint64_t, uint64_t, void, _BYTE *))(v12 + 16))( v12,  v13,  *(void *)(a2 + 72),  a4);
      }

      uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 48), "interposing section %s/%s is not pointer aligned");
    }

    *a4 = 1;
  }

  return result;
}

uint64_t dyld3::MachOFile::isRestricted(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  unsigned int v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke;
  void v3[3] = &unk_189621AC8;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile12isRestrictedEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__RESTRICT");
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__restrict");
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::hasWeakDefs(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 25) >> 7;
}

uint64_t dyld3::MachOFile::usesWeakDefs(dyld3::MachOFile *this)
{
  return *((_BYTE *)this + 26) & 1;
}

uint64_t dyld3::MachOFile::hasThreadLocalVariables(dyld3::MachOFile *this)
{
  return *((unsigned __int8 *)this + 26) >> 7;
}

uint64_t dyld3::MachOFile::hasInterposingTuples(dyld3::MachOFile *this)
{
  uint64_t v7 = 0LL;
  unint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v6);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke;
  void v5[3] = &unk_189621AF0;
  v5[4] = &v7;
  if (*(_DWORD *)this == -17958193) {
    int v2 = 8;
  }
  else {
    int v2 = 4;
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000LL;
  __int128 v11[2] = ___ZNK5dyld39MachOFile25forEachInterposingSectionER11DiagnosticsU13block_pointerFvyyRbE_block_invoke;
  void v11[3] = &unk_189621AA0;
  v11[5] = this;
  void v11[6] = &v6;
  int v12 = 2 * v2;
  int v13 = v2;
  v11[4] = v5;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v11);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  mach_o::Error::~Error(&v6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile20hasInterposingTuplesEv_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  *a4 = 1;
  return result;
}

uint64_t dyld3::MachOFile::isFairPlayEncrypted(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  FairPlayEncryptionLoadCommand = (_DWORD *)dyld3::MachOFile::findFairPlayEncryptionLoadCommand(this);
  if (FairPlayEncryptionLoadCommand && FairPlayEncryptionLoadCommand[4] == 1)
  {
    *a2 = FairPlayEncryptionLoadCommand[2];
    unsigned int v6 = FairPlayEncryptionLoadCommand[3];
    uint64_t result = 1LL;
  }

  else
  {
    unsigned int v6 = 0;
    uint64_t result = 0LL;
    *a2 = 0;
  }

  *a3 = v6;
  return result;
}

uint64_t dyld3::MachOFile::findFairPlayEncryptionLoadCommand(dyld3::MachOFile *this)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke;
  void v4[3] = &unk_189621B18;
  v4[4] = &v6;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v5, (uint64_t)v4);
  uint64_t v2 = 0LL;
  if (Diagnostics::noError((Diagnostics *)&v5)) {
    uint64_t v2 = v7[3];
  }
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile33findFairPlayEncryptionLoadCommandEv_block_invoke( uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 44 || *a2 == 33)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
    *a3 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasLoadCommandEj_block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == *(_DWORD *)(result + 40))
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

uint64_t dyld3::MachOFile::allowsAlternatePlatform(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  unsigned int v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke;
  void v3[3] = &unk_189621B68;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile23allowsAlternatePlatformEv_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__allow_alt_plat");
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::hasChainedFixups(dyld3::MachOFile *this)
{
  if (*((_DWORD *)this + 1) == 16777228
    && (*((_DWORD *)this + 2) & 0xFFFFFF) == 2
    && (dyld3::MachOFile::hasLoadCommand(this, -2147483614) & 1) != 0)
  {
    return 1LL;
  }

  else
  {
    return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
  }

uint64_t dyld3::MachOFile::hasChainedFixupsLoadCommand(dyld3::MachOFile *this)
{
  return dyld3::MachOFile::hasLoadCommand(this, -2147483596);
}

uint64_t dyld3::MachOFile::hasOpcodeFixups(dyld3::MachOFile *this)
{
  if ((dyld3::MachOFile::hasLoadCommand(this, -2147483614) & 1) != 0) {
    return 1LL;
  }
  else {
    return dyld3::MachOFile::hasLoadCommand(this, 34);
  }
}

uint64_t dyld3::MachOFile::chainedPointerFormat(dyld3::MachOFile *this, const dyld_chained_fixups_header *a2)
{
  uint64_t v2 = *((unsigned int *)this + 1);
  uint64_t v3 = (char *)this + v2;
  uint64_t v4 = *(unsigned int *)((char *)this + v2);
  if (!(_DWORD)v4) {
    return 0LL;
  }
  unsigned int v5 = (unsigned int *)((char *)this + v2 + 4);
  while (1)
  {
    unsigned int v7 = *v5++;
    uint64_t v6 = v7;
    if (v7)
    {
      uint64_t v8 = &v3[v6];
      if (*((_WORD *)v8 + 10)) {
        break;
      }
    }

    if (!--v4) {
      return 0LL;
    }
  }

  return *((unsigned __int16 *)v8 + 3);
}

uint64_t dyld3::MachOFile::walkChain( vm_address_t *a1, unsigned int *a2, mach_o::ChainedFixupPointerOnDisk *this, char a4, unsigned int a5, uint64_t a6)
{
  int v9 = (int)this;
  int v12 = mach_o::ChainedFixupPointerOnDisk::strideSize(this);
  char v21 = 0;
  unsigned int v14 = *a2;
  unsigned int v13 = a2[1];
  (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
  if (v21) {
    return 1LL;
  }
  while (2)
  {
    switch(v9)
    {
      case 1:
      case 7:
      case 9:
      case 10:
      case 12:
        int v15 = (v13 >> 19) & 0x7FF;
        if (!v15) {
          return 0LL;
        }
        goto LABEL_17;
      case 2:
      case 6:
        int v16 = (v13 >> 19) & 0xFFF;
        if (!v16) {
          return 0LL;
        }
        uint64_t v17 = (4 * v16);
        goto LABEL_18;
      case 3:
        int v18 = (v14 >> 26) & 0x1F;
        if (!v18) {
          return 0LL;
        }
        a2 = (unsigned int *)((char *)a2 + (4 * v18));
        if ((a4 & 1) == 0)
        {
          while (1)
          {
            unsigned int v19 = *a2;
            if ((*a2 & 0x80000000) != 0 || (v19 & 0x3FFFFFF) <= a5) {
              break;
            }
            a2 = (unsigned int *)((char *)a2 + (HIBYTE(v19) & 0x7CLL));
          }
        }

        goto LABEL_19;
      case 5:
        if (!(v14 >> 26)) {
          return 0LL;
        }
        uint64_t v17 = HIBYTE(v14) & 0xFC;
        goto LABEL_18;
      case 8:
      case 11:
        int v15 = (v13 >> 19) & 0xFFF;
        if (!v15) {
          return 0LL;
        }
        goto LABEL_17;
      case 13:
        int v15 = (v13 >> 20) & 0x7FF;
        if (v15)
        {
LABEL_17:
          uint64_t v17 = (v15 * v12);
LABEL_18:
          a2 = (unsigned int *)((char *)a2 + v17);
LABEL_19:
          unsigned int v14 = *a2;
          unsigned int v13 = a2[1];
          (*(void (**)(uint64_t, unsigned int *, char *))(a6 + 16))(a6, a2, &v21);
          if (v21) {
            return 1LL;
          }
          continue;
        }

        return 0LL;
      default:
        Diagnostics::error(a1, "unknown pointer format 0x%04X", v9);
        return 1LL;
    }
  }

vm_address_t *dyld3::MachOFile::forEachChainedFixupTarget( vm_address_t *this, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = this;
  uint64_t v5 = a2[2];
  unsigned int v6 = *(_DWORD *)(a3 + 12);
  uint64_t v8 = a2[3];
  char v25 = 0;
  char v10 = (char *)a2 + v8;
  unsigned int v11 = v6 - v8;
  unsigned int v12 = a2[5];
  switch(v12)
  {
    case 3u:
      if (!a2[4]) {
        return this;
      }
      uint64_t v17 = 0LL;
      int v18 = (void *)((char *)a2 + v5 + 8);
      while (1)
      {
        unint64_t v19 = *(v18 - 1);
        if (v11 < HIDWORD(v19)) {
          break;
        }
        else {
          uint64_t v20 = (__int16)v19;
        }
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, unint64_t, char *))(a4 + 16))( a4,  v20,  &v10[HIDWORD(v19)],  *v18,  (v19 >> 16) & 1,  &v25);
        if (!v25)
        {
          v18 += 2;
        }

        return this;
      }

      break;
    case 2u:
      if (!a2[4]) {
        return this;
      }
      uint64_t v21 = 0LL;
      unsigned int v22 = (int *)((char *)a2 + v5 + 4);
      while (1)
      {
        unint64_t v23 = *(v22 - 1);
        else {
          uint64_t v24 = (char)v23;
        }
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, void, char *))(a4 + 16))( a4,  v24,  &v10[v23 >> 9],  *v22,  (v23 >> 8) & 1,  &v25);
        if (!v25)
        {
          v22 += 2;
        }

        return this;
      }

      break;
    case 1u:
      if (!a2[4]) {
        return this;
      }
      uint64_t v13 = 0LL;
      unsigned int v14 = (char *)a2 + v5;
      while (1)
      {
        unint64_t v15 = *(unsigned int *)&v14[4 * v13];
        if (*(_DWORD *)&v14[4 * v13] >> 9 > v11) {
          break;
        }
        else {
          uint64_t v16 = (char)v15;
        }
        this = (vm_address_t *)(*(uint64_t (**)(uint64_t, uint64_t, char *, void, void, char *))(a4 + 16))( a4,  v16,  &v10[v15 >> 9],  0LL,  (v15 >> 8) & 1,  &v25);
        return this;
      }

      break;
    default:
      return (vm_address_t *)Diagnostics::error(this, "unknown imports format");
  }

  return (vm_address_t *)Diagnostics::error(v4, "malformed import table, string overflow");
}

uint64_t dyld3::MachOFile::read_uleb128( vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  unint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  unsigned int v7 = *a2;
  uint64_t v8 = "malformed uleb128";
  while (v7 != a3)
  {
    if (v5 > 0x3F)
    {
      uint64_t v8 = "uleb128 too big for uint64";
      break;
    }

    v6 |= (unint64_t)(*(_BYTE *)v7 & 0x7F) << v5;
    v5 += 7LL;
    *a2 = (const unsigned __int8 **)((char *)v7 + 1);
    int v9 = *(char *)v7;
    unsigned int v7 = (const unsigned __int8 **)((char *)v7 + 1);
    if ((v9 & 0x80000000) == 0) {
      return v6;
    }
  }

  Diagnostics::error(this, v8);
  return v6;
}

uint64_t dyld3::MachOFile::read_sleb128( vm_address_t *this, const unsigned __int8 ***a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  uint64_t v4 = *a2;
  if (*a2 == a3)
  {
    uint64_t v6 = 0LL;
    int v7 = 0;
    unsigned int v9 = 0;
LABEL_7:
    Diagnostics::error(this, "malformed sleb128");
  }

  else
  {
    int v5 = 0;
    uint64_t v6 = 0LL;
    int v7 = -7 * (_DWORD)v4 - (_DWORD)a3 + 8 * (_DWORD)a3;
    while (1)
    {
      uint64_t v8 = (const unsigned __int8 **)((char *)v4 + 1);
      *a2 = (const unsigned __int8 **)((char *)v4 + 1);
      unsigned int v9 = *(unsigned __int8 *)v4;
      v6 |= (unint64_t)(v9 & 0x7F) << v5;
      if ((v9 & 0x80) == 0) {
        break;
      }
      v5 += 7;
      uint64_t v4 = (const unsigned __int8 **)((char *)v4 + 1);
      if (v8 == a3) {
        goto LABEL_7;
      }
    }

    int v7 = v5 + 7;
  }

  if (((v7 < 64) & (v9 >> 6)) != 0) {
    uint64_t v10 = -1LL << v7;
  }
  else {
    uint64_t v10 = 0LL;
  }
  return v10 | v6;
}

int *dyld3::MachOFile::compatibleSlice( vm_address_t *a1, unint64_t *a2, dyld3::FatFile *this, unint64_t a4, const char *a5, unsigned int a6, int a7, dyld3::GradedArchs *a8, unsigned __int8 a9)
{
  unsigned int v14 = (int *)this;
  unsigned int v17 = *(_DWORD *)this;
  if ((*(_DWORD *)this | 0x1000000) == 0xBFBAFECA)
  {
    if (!dyld3::FatFile::isFatFileWithSlice(this, a1, a4, a8, a7, &v27, &v26, &v25))
    {
      LOBYTE(v33) = 0;
      *(void *)int v28 = _NSConcreteStackBlock;
      uint64_t v29 = 0x40000000LL;
      uint64_t v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
      unint64_t v31 = &__block_descriptor_tmp_211;
      unint64_t v32 = &v33;
      dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
      dyld3::FatFile::archNames((dyld3::FatFile *)v14, v28, a4);
      Diagnostics::error(a1, "fat file, but missing compatible architecture (have '%s', need '%s')");
      return 0LL;
    }

    unsigned int v14 = (int *)((char *)v14 + v27);
    *a2 = v26;
    unsigned int v17 = *v14;
  }

  else
  {
    *a2 = a4;
  }

  if (v17 >> 1 != 2138504551 || !dyld3::MachOFile::isMachO((dyld3::MachOFile *)v14, a1, a4))
  {
    if (Diagnostics::noError((Diagnostics *)a1)) {
      Diagnostics::error(a1, "not a mach-o file");
    }
    return 0LL;
  }

  if (!dyld3::GradedArchs::grade(a8, v14[1], v14[2], a7))
  {
    LOBYTE(v33) = 0;
    *(void *)int v28 = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000LL;
    uint64_t v30 = ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke;
    unint64_t v31 = &__block_descriptor_tmp_211;
    unint64_t v32 = &v33;
    dyld3::GradedArchs::forEachArch((uint64_t)a8, a7, (uint64_t)v28);
    for (uint64_t i = 0LL; i != 26; i += 2LL)
    {
      if (LODWORD((&dyld3::MachOFile::_s_archInfos)[i + 1]) == v14[1]
        && (v14[2] & 0xFFFFFF) == *((_DWORD *)&dyld3::MachOFile::_s_archInfos + 2 * i + 3))
      {
        break;
      }
    }

    Diagnostics::error(a1, "mach-o file, but is an incompatible architecture (have '%s', need '%s')");
    return 0LL;
  }

  if ((dyld3::MachOFile::loadableIntoProcess(v14, a6, a5, a9) & 1) == 0)
  {
    uint64_t v33 = 0LL;
    unint64_t v34 = &v33;
    uint64_t v35 = 0x2000000000LL;
    int v36 = 0;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000LL;
    _OWORD v24[2] = ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke;
    v24[3] = &unk_189621B90;
    v24[4] = &v33;
    dyld3::MachOFile::forEachSupportedPlatform(v14, (uint64_t)v24);
    uint64_t v18 = 0LL;
    unint64_t v19 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v18 + 1]) != *((_DWORD *)v34 + 6))
    {
      v18 += 2LL;
      if (v18 == 48) {
        goto LABEL_24;
      }
    }

    unint64_t v19 = (&dyld3::MachOFile::_s_platformInfos)[v18];
LABEL_24:
    uint64_t v22 = 0LL;
    unint64_t v23 = "unknown";
    while (LODWORD((&dyld3::MachOFile::_s_platformInfos)[v22 + 1]) != a6)
    {
      v22 += 2LL;
      if (v22 == 48) {
        goto LABEL_29;
      }
    }

    unint64_t v23 = (&dyld3::MachOFile::_s_platformInfos)[v22];
LABEL_29:
    Diagnostics::error(a1, "mach-o file (%s), but incompatible platform (have '%s', need '%s')", a5, v19, v23);
    _Block_object_dispose(&v33, 8);
    return 0LL;
  }

  return v14;
}

uint64_t ___ZN5dyld39MachOFile15compatibleSliceER11DiagnosticsRyPKvmPKcNS_8PlatformEbRKNS_11GradedArchsEb_block_invoke( uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  return result;
}

const unsigned __int8 **dyld3::MachOFile::trieWalk( vm_address_t *this, const unsigned __int8 **a2, Diagnostics *a3, const unsigned __int8 *a4, const char *a5)
{
  v34[0] = &v38;
  v34[1] = 128LL;
  vm_address_t address = 0LL;
  vm_size_t size = 0LL;
  uint64_t v35 = 0LL;
  dyld3::OverflowSafeArray<unsigned int,4294967295ull>::verifySpace(v34, 1LL);
  uint64_t v10 = 0LL;
  uint64_t v11 = v35++;
  *(_DWORD *)(v34[0] + 4 * v1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0;
  unsigned int v12 = a2;
  while (2)
  {
    int v13 = *(char *)v12;
    uint64_t v33 = (const unsigned __int8 **)((char *)v12 + 1);
    if (v13 < 0)
    {
      uint64_t v33 = v12;
      uint64_t v14 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
      if (Diagnostics::hasError((Diagnostics *)this))
      {
LABEL_37:
        uint64_t v10 = 0LL;
        break;
      }
    }

    else
    {
      uint64_t v14 = v13;
    }

    uint64_t v10 = v33;
    if (*a4) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = v14 == 0;
    }
    if (!v15) {
      break;
    }
    uint64_t v16 = (unsigned __int8 *)v33 + v14;
    int v19 = *v16;
    unsigned int v17 = (const unsigned __int8 **)(v16 + 1);
    int v18 = v19;
    uint64_t v33 = v17;
    if (!v19) {
      goto LABEL_37;
    }
    while (1)
    {
      int v20 = *(unsigned __int8 *)v17;
      if (!*(_BYTE *)v17) {
        break;
      }
      BOOL v21 = 0;
      uint64_t v22 = (const unsigned __int8 **)((char *)v17 + 1);
      unint64_t v23 = (const unsigned __int8 **)((char *)v17 + 2);
      uint64_t v24 = a4;
      do
      {
        unsigned int v17 = v23;
        if (v21)
        {
          BOOL v21 = 1;
        }

        else
        {
          int v25 = *v24++;
          BOOL v21 = v20 != v25;
        }

        uint64_t v33 = v22;
        int v26 = *(unsigned __int8 *)v22;
        uint64_t v22 = (const unsigned __int8 **)((char *)v22 + 1);
        int v20 = v26;
        unint64_t v23 = (const unsigned __int8 **)((char *)v23 + 1);
      }

      while (v26);
      if (!v21)
      {
        unsigned int v17 = (const unsigned __int8 **)((char *)v22 - 1);
        a4 = v24;
        break;
      }

      do
      {
        int v27 = *(char *)v17;
        unsigned int v17 = (const unsigned __int8 **)((char *)v17 + 1);
      }

      while (v27 < 0);
      uint64_t v33 = v17;
      if (v17 > (const unsigned __int8 **)a3)
      {
        Diagnostics::error(this, "malformed trie node, child node extends past end of trie\n");
        goto LABEL_37;
      }

      if (!(_BYTE)--v18) {
        goto LABEL_37;
      }
    }

    uint64_t v33 = (const unsigned __int8 **)((char *)v17 + 1);
    unint64_t v28 = dyld3::MachOFile::read_uleb128(this, &v33, (const unsigned __int8 **)a3, v9);
    if (Diagnostics::hasError((Diagnostics *)this)) {
      goto LABEL_37;
    }
    if (!v28
      || (unsigned int v12 = (const unsigned __int8 **)((char *)a2 + v28), (char *)a2 + v28 > (char *)a3)
      || v28 > a3 - (Diagnostics *)a2)
    {
      Diagnostics::error(this, "malformed trie child, nodeOffset=0x%llX out of range\n");
      goto LABEL_37;
    }

    if (v35)
    {
      uint64_t v29 = (_DWORD *)v34[0];
      uint64_t v30 = 4 * v35;
      while (v28 != *v29)
      {
        ++v29;
        v30 -= 4LL;
        if (!v30) {
          goto LABEL_33;
        }
      }

      Diagnostics::error(this, "malformed trie child, cycle to nodeOffset=0x%llX\n");
      goto LABEL_37;
    }

LABEL_38:
  uint64_t v35 = 0LL;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
  return v10;
}

void dyld3::MachOFile::forEachRPath(_DWORD *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke;
  void v4[3] = &unk_189621BB8;
  v4[4] = a2;
  dyld3::MachOFile::forEachLoadCommand(a1, (vm_address_t *)&v5, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v5);
  mach_o::Error::~Error(&v5);
}

uint64_t ___ZNK5dyld39MachOFile12forEachRPathEU13block_pointerFvPKcRbE_block_invoke( uint64_t result, _DWORD *a2)
{
  if (*a2 == -2147483620) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
  }
  return result;
}

BOOL dyld3::MachOFile::inCodeSection(dyld3::MachOFile *this, int a2)
{
  if (*((_DWORD *)this + 1) != 16777228 || (*((_DWORD *)this + 2) & 0xFFFFFF) != 2) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  char v10 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke;
  void v5[3] = &unk_189621BE0;
  int v6 = a2;
  v5[4] = &v7;
  void v5[5] = dyld3::MachOFile::preferredLoadAddress(this);
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  BOOL v3 = *((_BYTE *)v8 + 24) != 0;
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile13inCodeSectionEj_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4 = *(void *)(a2 + 64) - *(void *)(result + 40);
  unint64_t v5 = *(unsigned int *)(result + 48);
  if (v4 <= v5 && v4 + *(void *)(a2 + 72) > v5)
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }

  return result;
}

uint64_t dyld3::MachOFile::dependentDylibCount(dyld3::MachOFile *this, BOOL *a2)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  int v13 = 0;
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke;
  void v5[3] = &unk_189621C08;
  v5[4] = &v10;
  void v5[5] = &v6;
  dyld3::MachOFile::forEachDependentDylib(this, (uint64_t)v5);
  if (a2) {
    *a2 = *((_BYTE *)v7 + 24);
  }
  uint64_t v3 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t ___ZNK5dyld39MachOFile19dependentDylibCountEPb_block_invoke( uint64_t result, uint64_t a2, char a3, char a4, int a5)
{
  if ((a3 & 1) != 0 || (a4 & 1) != 0 || a5) {
    *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0;
  }
  return result;
}

uint64_t dyld3::MachOFile::hasPlusLoadMethod(dyld3::MachOFile *this, Diagnostics *a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke;
  void v4[3] = &unk_189621C30;
  v4[4] = &v5;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile17hasPlusLoadMethodER11Diagnostics_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!(_DWORD)result)
  {
    char v8 = *(const char **)(a2 + 80);
    uint64_t result = _platform_strcmp(v8, "__objc_nlclslist");
    if (!(_DWORD)result || (uint64_t result = _platform_strcmp(v8, "__objc_nlcatlist"), !(_DWORD)result))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::getFixupsLoadCommandFileOffset(dyld3::MachOFile *this)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke;
  void v4[3] = &unk_189621C58;
  v4[4] = &v5;
  void v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  uint64_t v2 = 0LL;
  if (!Diagnostics::hasError((Diagnostics *)&v9)) {
    uint64_t v2 = *((unsigned int *)v6 + 6);
  }
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile30getFixupsLoadCommandFileOffsetEv_block_invoke(uint64_t result, int *a2)
{
  int v2 = *a2;
  if (*a2 == -2147483614 || (v2 != 34 ? (BOOL v3 = v2 == -2147483596) : (BOOL v3 = 1), v3)) {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = (_DWORD)a2 - *(_DWORD *)(result + 40);
  }
  return result;
}

BOOL dyld3::MachOFile::hasInitializer(dyld3::MachOFile *this, vm_address_t *a2)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke;
  void v8[3] = &unk_189621C80;
  void v8[4] = &v9;
  dyld3::MachOFile::forEachLoadCommand(this, a2, (uint64_t)v8);
  if (*((_BYTE *)v10 + 24)
    || (v7[0] = _NSConcreteStackBlock,
        v7[1] = 0x40000000LL,
        void v7[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2,
        void v7[3] = &unk_189621CA8,
        v7[4] = &v9,
        dyld3::MachOFile::forEachInitializerPointerSection(this, (uint64_t)a2, (uint64_t)v7),
        *((_BYTE *)v10 + 24)))
  {
    BOOL v4 = 1LL;
  }

  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    void v6[2] = ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3;
    void v6[3] = &unk_189621CD0;
    v6[4] = &v9;
    dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
    BOOL v4 = *((_BYTE *)v10 + 24) != 0;
  }

  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke( uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 26 || *a2 == 17)
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *a3 = 1;
  }

  return result;
}

void dyld3::MachOFile::forEachInitializerPointerSection(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a1 == -17958193) {
    int v4 = 8;
  }
  else {
    int v4 = 4;
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke;
  void v5[3] = &unk_189621CF8;
  int v6 = v4;
  v5[4] = a3;
  void v5[5] = a2;
  void v5[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v5);
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_2( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  *a4 = 1;
  return result;
}

uint64_t ___ZNK5dyld39MachOFile14hasInitializerER11Diagnostics_block_invoke_3( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (*(_BYTE *)(a2 + 92) == 22)
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    *a4 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile32forEachInitializerPointerSectionER11DiagnosticsU13block_pointerFvjjRbE_block_invoke( uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (*(_BYTE *)(a2 + 92) == 9)
  {
    unint64_t v5 = *(unsigned int *)(result + 56);
    if (*(void *)(a2 + 72) % v5)
    {
      uint64_t result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s has bad size");
    }

    else if (a3)
    {
      uint64_t result = Diagnostics::error( *(vm_address_t **)(result + 40),  "initializer section %s/%s extends beyond its segment");
    }

    else
    {
      unint64_t v6 = *(void *)(a2 + 64);
      if (!(v6 % v5)) {
        return (*(uint64_t (**)(void, void))(*(void *)(result + 32) + 16LL))( *(void *)(result + 32),  (v6 - *(_DWORD *)(result + 48)));
      }
      uint64_t result = Diagnostics::error(*(vm_address_t **)(result + 40), "initializer section %s/%s is not pointer aligned");
    }

    *a4 = 1;
  }

  return result;
}

BOOL dyld3::MachOFile::hasCodeSignature(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  *a2 = 0;
  *a3 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v18);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000LL;
  v17[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke;
  void v17[3] = &__block_descriptor_tmp_157_0;
  v17[4] = a2;
  _WORD v17[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v18, (uint64_t)v17);
  Diagnostics::assertNoError((Diagnostics *)&v18);
  if (*a2)
  {
    if ((*((_DWORD *)this + 1) | 0x1000000) == 0x1000007)
    {
      uint64_t v13 = 0LL;
      uint64_t v14 = &v13;
      uint64_t v15 = 0x2000000000LL;
      char v16 = 0;
      uint64_t v9 = 0LL;
      uint64_t v10 = &v9;
      uint64_t v11 = 0x2000000000LL;
      char v12 = 0;
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000LL;
      v8[2] = ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2;
      void v8[3] = &unk_189621D40;
      void v8[4] = &v13;
      void v8[5] = &v9;
      dyld3::MachOFile::forEachSupportedPlatform(this, (uint64_t)v8);
      if (*((_BYTE *)v14 + 24)) {
        BOOL v6 = *((_BYTE *)v10 + 24) == 0;
      }
      else {
        BOOL v6 = 0LL;
      }
      _Block_object_dispose(&v9, 8);
      _Block_object_dispose(&v13, 8);
    }

    else
    {
      BOOL v6 = 1LL;
    }
  }

  else
  {
    BOOL v6 = 0LL;
  }

  mach_o::Error::~Error(&v18);
  return v6;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke(uint64_t result, _DWORD *a2, _BYTE *a3)
{
  if (*a2 == 29)
  {
    BOOL v3 = *(_DWORD **)(result + 40);
    **(_DWORD **)(result + 32) = a2[2];
    *BOOL v3 = a2[3];
    *a3 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile16hasCodeSignatureERjS1__block_invoke_2( uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  if (a2 == 1 && a4 >> 8 <= 0xA08) {
    *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

unint64_t dyld3::MachOFile::mappedSize(dyld3::MachOFile *this)
{
  return v3;
}

void dyld3::MachOFile::analyzeSegmentsLayout(dyld3::MachOFile *this, unint64_t *a2, BOOL *a3)
{
  uint64_t v25 = 0LL;
  int v26 = &v25;
  uint64_t v27 = 0x2000000000LL;
  char v28 = 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000LL;
  uint64_t v24 = -1LL;
  uint64_t v17 = 0LL;
  int v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  uint64_t v20 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000LL;
  uint64_t v16 = 0LL;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke;
  void v12[3] = &unk_189621D68;
  v12[4] = &v25;
  void v12[5] = &v21;
  void v12[6] = &v17;
  void v12[7] = &v13;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v12);
  int v6 = *((_DWORD *)this + 1);
  if (v6 == 33554444 || v6 == 16777228 || v6 == 12 && *((_DWORD *)this + 3) != 11 && *((_DWORD *)this + 2) == 12) {
    uint64_t v7 = 0x3FFFLL;
  }
  else {
    uint64_t v7 = 4095LL;
  }
  unint64_t v8 = (v18[3] - v22[3] + v7) & ~v7;
  uint64_t v9 = v14[3];
  *a2 = v8;
  if (*((_BYTE *)v26 + 24)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v8 == v9;
  }
  BOOL v11 = !v10;
  *a3 = v11;
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
}

uint64_t ___ZNK5dyld39MachOFile21analyzeSegmentsLayoutERyRb_block_invoke(void *a1, uint64_t a2)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__PAGEZERO");
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a2 + 52) & 2) != 0)
    {
      uint64_t v5 = *(void *)(a2 + 8);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v5 != v6)
      {
        *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
        uint64_t v5 = v6;
      }
    }

    else
    {
      uint64_t v5 = *(void *)(a2 + 24);
    }

    if (!v5) {
      *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    }
    unint64_t v7 = *(void *)(a2 + 16);
    uint64_t v8 = *(void *)(a1[5] + 8LL);
    if (v7 < *(void *)(v8 + 24))
    {
      *(void *)(v8 + 24) = v7;
      unint64_t v7 = *(void *)(a2 + 16);
      uint64_t v5 = *(void *)(a2 + 24);
    }

    unint64_t v9 = v5 + v7;
    uint64_t v10 = *(void *)(a1[6] + 8LL);
    if (v9 > *(void *)(v10 + 24))
    {
      *(void *)(v10 + 24) = v9;
      uint64_t v5 = *(void *)(a2 + 24);
    }

    *(void *)(*(void *)(a1[7] + 8LL) + 24LL) += v5;
  }

  return result;
}

uint64_t dyld3::MachOFile::segmentCount(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke;
  void v3[3] = &unk_189621D90;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile12segmentCountEv_block_invoke(uint64_t result)
{
  return result;
}

void dyld3::MachOFile::forEachDOFSection(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke;
  void v3[3] = &unk_189621DB8;
  void v3[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v3);
}

uint64_t ___ZNK5dyld39MachOFile17forEachDOFSectionER11DiagnosticsU13block_pointerFvjE_block_invoke( uint64_t result, uint64_t a2, char a3)
{
  if (*(_BYTE *)(a2 + 92) == 15 && (a3 & 1) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
  }
  return result;
}

uint64_t dyld3::MachOFile::hasExportTrie(dyld3::MachOFile *this, unsigned int *a2, unsigned int *a3)
{
  uint64_t v24 = 0LL;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2000000000LL;
  uint64_t v27 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000LL;
  uint64_t v23 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke;
  void v15[3] = &unk_189621DE0;
  v15[4] = &v24;
  void v15[5] = &v20;
  _OWORD v15[6] = &v16;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v15);
  Diagnostics::Diagnostics((Diagnostics *)&v14);
  uint64_t v10 = 0LL;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  int v13 = -1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2;
  void v9[3] = &unk_189621E08;
  void v9[4] = &v10;
  void v9[5] = a3;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v14, (uint64_t)v9);
  uint64_t v6 = 0LL;
  if (!Diagnostics::hasError((Diagnostics *)&v14))
  {
    int v7 = *((_DWORD *)v11 + 6);
    if (v7 == -1)
    {
      uint64_t v6 = 0LL;
    }

    else
    {
      *a2 = *((_DWORD *)v21 + 6) + v7 - (*((_DWORD *)v17 + 6) + *((_DWORD *)v25 + 6));
      uint64_t v6 = 1LL;
    }
  }

  _Block_object_dispose(&v10, 8);
  mach_o::Error::~Error(&v14);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return v6;
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke(void *a1, void *a2, _BYTE *a3)
{
  uint64_t v6 = (const char *)a2[5];
  uint64_t result = _platform_strcmp(v6, "__TEXT");
  if ((_DWORD)result)
  {
    uint64_t result = _platform_strcmp(v6, "__LINKEDIT");
    if (!(_DWORD)result)
    {
      *(void *)(*(void *)(a1[5] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2[2];
      *(void *)(*(void *)(a1[6] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *a2;
      *a3 = 1;
    }
  }

  else
  {
    *(void *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2[2];
  }

  return result;
}

uint64_t ___ZNK5dyld39MachOFile13hasExportTrieERjS1__block_invoke_2(uint64_t result, int *a2)
{
  int v2 = *a2;
  if (*a2 != 34)
  {
    if (v2 == -2147483597)
    {
      *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2[2];
      unint64_t v3 = a2 + 3;
      goto LABEL_6;
    }

    if (v2 != -2147483614) {
      return result;
    }
  }

  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2[10];
  unint64_t v3 = a2 + 11;
LABEL_6:
  **(_DWORD **)(result + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *v3;
  return result;
}

uint64_t dyld3::MachOFile::forEachCodeDirectoryBlob( uint64_t result, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  if (a3 >= 0xC && *a2 == -1072898310)
  {
    unsigned int v5 = a2[2];
    unint64_t v6 = bswap32(v5);
    if (v6 <= (a3 - 12) >> 3)
    {
      uint64_t v9 = result;
      uint64_t result = dyld3::MachOFile::builtForPlatform((_DWORD *)result, 4, 0);
      uint64_t v10 = dyld3::hash_rank;
      if ((_DWORD)result) {
        uint64_t v10 = dyld3::hash_rank_watchOS_dylibs;
      }
      uint64_t v19 = v10;
      if (v5)
      {
        BOOL v11 = 0LL;
        if (*(_DWORD *)(v9 + 12) == 2) {
          int v12 = result;
        }
        else {
          int v12 = 0;
        }
        int v13 = a2 + 4;
        do
        {
          int v14 = *(v13 - 1);
          if (v14) {
            BOOL v15 = (v14 - 0x100000) > 0x5000000;
          }
          else {
            BOOL v15 = 0;
          }
          if (!v15)
          {
            unint64_t v16 = bswap32(*v13);
            if (a3 - 88 >= v16)
            {
              uint64_t v17 = (_DWORD *)((char *)a2 + v16);
              if (a3 - v16 >= bswap32(*(_DWORD *)((char *)a2 + v16 + 4)))
              {
                if (v12)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16))(a4, v17);
                }

                else if (*v17 == 34397946)
                {
                  if (!v11
                    || (unsigned int v18 = ((uint64_t (*)(_DWORD *))v19)(v17),
                        uint64_t result = ((uint64_t (*)(_DWORD *))v19)(v11),
                        v18 > result))
                  {
                    BOOL v11 = v17;
                  }
                }
              }
            }
          }

          v13 += 2;
          --v6;
        }

        while (v6);
        if (v11) {
          return (*(uint64_t (**)(uint64_t, _DWORD *))(a4 + 16))(a4, v11);
        }
      }
    }
  }

  return result;
}

uint64_t dyld3::hash_rank_watchOS_dylibs(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2 = 0LL;
  while (dyld3::hashPriorities_watchOS_dylibs[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4) {
      return 0LL;
    }
  }

  return (v2 + 1);
}

uint64_t dyld3::hash_rank(dyld3 *this, const CS_CodeDirectory *a2)
{
  uint64_t v2 = 0LL;
  while (dyld3::hashPriorities[v2] != *((unsigned __int8 *)this + 37))
  {
    if (++v2 == 4) {
      return 0LL;
    }
  }

  return (v2 + 1);
}

uint64_t dyld3::MachOFile::forEachCDHashOfCodeSignature( uint64_t a1, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke;
  void v5[3] = &unk_189621E30;
  v5[4] = a4;
  return dyld3::MachOFile::forEachCodeDirectoryBlob(a1, a2, a3, (uint64_t)v5);
}

uint64_t ___ZNK5dyld39MachOFile28forEachCDHashOfCodeSignatureEPKvmU13block_pointerFvPKhE_block_invoke( uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  size_t v4 = bswap32(*(_DWORD *)(a2 + 4));
  int v5 = *(unsigned __int8 *)(a2 + 37);
  if ((v5 - 2) < 2)
  {
    unint64_t v6 = (unint64_t *)ccsha256_di();
  }

  else
  {
    if (v5 == 1)
    {
      unsigned int v18 = (unint64_t *)ccsha1_di();
      __chkstk_darwin((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, v29);
      uint64_t v27 = (void *)((char *)&v29 - v26);
      ccdigest_init(v28, (__int128 *)((char *)&v29 - v26));
      ccdigest_update(v18, v27, v4, (char *)a2);
      ((void (*)(unint64_t *, void *, __int128 *))v18[7])(v18, v27, &v31);
      cc_clear(v18[1] + v18[2] + 12, v27);
      return (*(uint64_t (**)(void))(*(void *)(v3 + 32) + 16LL))();
    }

    if (v5 != 4) {
      return result;
    }
    unint64_t v6 = (unint64_t *)ccsha384_di();
  }

  int v14 = v6;
  __chkstk_darwin((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, v29);
  unint64_t v16 = (void *)((char *)&v29 - v15);
  ccdigest_init(v17, (__int128 *)((char *)&v29 - v15));
  ccdigest_update(v14, v16, v4, (char *)a2);
  ((void (*)(unint64_t *, void *, __int128 *))v14[7])(v14, v16, &v29);
  cc_clear(v14[1] + v14[2] + 12, v16);
  int v32 = v30;
  __int128 v31 = v29;
  return (*(uint64_t (**)(void))(*(void *)(v3 + 32) + 16LL))();
}

uint64_t dyld3::MachOFile::forEachTreatAsWeakDef(uint64_t a1)
{
  for (uint64_t i = 0LL; i != 22; ++i)
    uint64_t result = (*(uint64_t (**)(uint64_t, char *))(a1 + 16))(a1, dyld3::sTreatAsWeak[i]);
  return result;
}

_DWORD *dyld3::MachOFile::PointerMetaData::PointerMetaData(_DWORD *this)
{
  *this &= 0xF0000000;
  return this;
}

uint64_t dyld3::MachOFile::hasObjCMessageReferences(dyld3::MachOFile *this)
{
  uint64_t v4 = 0LL;
  int v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke;
  void v3[3] = &unk_189621F08;
  void v3[4] = &v4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK5dyld39MachOFile24hasObjCMessageReferencesEv_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__objc_msgrefs");
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::findObjCDataSection( dyld3::MachOFile *this, const char *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke;
  void v8[3] = &unk_189621F30;
  void v8[4] = &v9;
  void v8[5] = a2;
  void v8[6] = a3;
  void v8[7] = dyld3::MachOFile::preferredLoadAddress(this);
  void v8[8] = a4;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v8);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t ___ZNK5dyld39MachOFile19findObjCDataSectionEPKcRyS3__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  char v7 = *(const char **)(a2 + 40);
  if (!_platform_strcmp(v7, "__DATA")
    || !_platform_strcmp(v7, "__DATA_CONST")
    || (uint64_t result = _platform_strcmp(v7, "__DATA_DIRTY"), !(_DWORD)result))
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 40));
    if (!(_DWORD)result)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      **(void **)(a1 + 48) = *(void *)(a2 + 64) - *(void *)(a1 + 56);
      **(void **)(a1 + 64) = *(void *)(a2 + 72);
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOFile::enforceFormat(_DWORD *a1, int a2)
{
  uint64_t v6 = 0LL;
  char v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke;
  void v4[3] = &unk_189621F58;
  int v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSupportedPlatform(a1, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld39MachOFile13enforceFormatENS0_9MalformedE_block_invoke( uint64_t result, int a2, uint64_t a3, unsigned int a4)
{
  switch(a2)
  {
    case 1:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 1:
        case 3:
          if (a4 >> 9 >= 0x507) {
            goto LABEL_23;
          }
          break;
        case 2:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
          unsigned int v6 = 659199;
          goto LABEL_22;
        case 9:
          unsigned int v6 = 659455;
          goto LABEL_22;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          goto LABEL_15;
        case 0xD:
        case 0x10:
          goto LABEL_20;
        default:
          return result;
      }

      break;
    case 2:
    case 3:
    case 6:
      switch(*(_DWORD *)(result + 40))
      {
        case 0:
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_23;
        case 1:
        case 2:
        case 4:
        case 8:
LABEL_15:
          if (a4 >= 0xD0000) {
            goto LABEL_23;
          }
          break;
        case 9:
LABEL_20:
          int v9 = 851967;
          goto LABEL_21;
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xE:
        case 0xF:
          if (a4 >= 0x100000) {
            goto LABEL_23;
          }
          break;
        case 0xD:
        case 0x10:
          unsigned int v6 = 1114111;
          goto LABEL_22;
        default:
          return result;
      }

      break;
    case 4:
      unsigned int v7 = *(_DWORD *)(result + 40);
      if (v7 <= 0x10)
      {
        int v8 = 1 << v7;
        if ((v8 & 0xDF16) != 0)
        {
          if (a4 >= 0x90000) {
            goto LABEL_23;
          }
        }

        else
        {
          if ((v8 & 0xE9) != 0) {
            goto LABEL_23;
          }
          int v9 = 589823;
LABEL_21:
          unsigned int v6 = v9 | 0x10000;
LABEL_22:
          if (a4 > v6) {
            goto LABEL_23;
          }
        }
      }

      break;
    case 11:
    case 12:
      uint64_t v5 = *(void *)(result + 32);
      result += 32LL;
      *(_BYTE *)(*(void *)(v5 + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      if (!(a4 >> 17) && *(_DWORD *)(result + 8) == 16)
      {
        char v4 = 0;
        goto LABEL_24;
      }

      break;
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      char v4 = 0;
      result += 32LL;
      goto LABEL_24;
    default:
LABEL_23:
      result += 32LL;
      char v4 = 1;
LABEL_24:
      *(_BYTE *)(*(void *)(*(void *)result + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v4;
      break;
  }

  return result;
}

void dyld3::MachOFile::forEachSingletonPatch(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a1 == -17958193) {
    int v5 = 16;
  }
  else {
    int v5 = 8;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke;
  void v6[3] = &unk_189621F80;
  int v7 = v5;
  void v6[5] = a2;
  v6[6] = dyld3::MachOFile::preferredLoadAddress(a1);
  v6[4] = a3;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v6);
}

uint64_t ___ZNK5dyld39MachOFile21forEachSingletonPatchER11DiagnosticsU13block_pointerFvNS0_18SingletonPatchKindEyE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__const_cfobj2");
  if (!(_DWORD)result)
  {
    *a4 = 1;
    unint64_t v8 = *(void *)(a2 + 72);
    unint64_t v9 = *(unsigned int *)(a1 + 56);
    if (v8 % v9)
    {
      return Diagnostics::error( *(vm_address_t **)(a1 + 40),  "Incorrect patching size (%lld).  Should be a multiple of (2 * ptrSize)");
    }

    else if (*(_DWORD *)(a2 + 104) == (_DWORD)v9)
    {
      if (v8)
      {
        uint64_t v10 = 0LL;
        do
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
          v10 += *(unsigned int *)(a1 + 56);
        }

        while (v10 != *(void *)(a2 + 72));
      }
    }

    else
    {
      return Diagnostics::error(*(vm_address_t **)(a1 + 40), "reserved2 is unsupported value %d.  Expected %d");
    }
  }

  return result;
}

size_t ___ZN5dyld3L12getArchNamesERKNS_11GradedArchsEbPc_block_invoke(uint64_t a1, char *__source)
{
  char v4 = *(char **)(a1 + 32);
  if (*v4)
  {
    strlcat(v4, "' or '", 0x100uLL);
    char v4 = *(char **)(a1 + 32);
  }

  return strlcat(v4, __source, 0x100uLL);
}

void dyld3::MachOLoaded::getLinkEditLoadCommands(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  *(void *)(a3 + 64) = 0LL;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v10[0] = 0LL;
  v10[1] = v10;
  _OWORD v10[2] = 0x2000000000LL;
  char v11 = 0;
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  char v9 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  char v7 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke;
  void v5[3] = &unk_189621FC8;
  void v5[8] = a2;
  v5[9] = a3;
  v5[4] = v10;
  void v5[5] = v8;
  void v5[6] = v6;
  void v5[7] = a1;
  dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v5);
  if (Diagnostics::noError((Diagnostics *)a2) && *(void *)(a3 + 32) && !*(void *)(a3 + 24)) {
    Diagnostics::error(a2, "LC_DYSYMTAB but no LC_SYMTAB load command");
  }
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v10, 8);
}

uint64_t ___ZNK5dyld311MachOLoaded23getLinkEditLoadCommandsER11DiagnosticsRNS0_12LinkEditInfoE_block_invoke( uint64_t result, int *a2)
{
  uint64_t v3 = result;
  int v4 = *a2;
  if (*a2 <= 1)
  {
    switch(v4)
    {
      case -2147483614:
LABEL_12:
        if (a2[1] == 48)
        {
          if (**(void **)(v3 + 72)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYLD_INFO load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYLD_INFO load command size wrong");
        }

        **(void **)(v3 + 72) = a2;
        break;
      case -2147483597:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(result + 72) + 8LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(result + 64), "multiple LC_DYLD_EXPORTS_TRIE load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_EXPORTS_TRIE load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 8LL) = a2;
        break;
      case -2147483596:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(result + 72) + 16LL)) {
            uint64_t result = Diagnostics::error( *(vm_address_t **)(result + 64),  "multiple LC_DYLD_CHAINED_FIXUPS load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(result + 64), "LC_DYLD_CHAINED_FIXUPS load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 16LL) = a2;
        break;
    }
  }

  else
  {
    uint64_t result = *(void *)(result + 56);
    switch(v4)
    {
      case 27:
        if (a2[1] == 24)
        {
          if (*(_BYTE *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_UUID load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_UUID load command size wrong");
        }

        uint64_t v5 = *(void *)(v3 + 32);
        goto LABEL_70;
      case 28:
      case 31:
      case 32:
      case 35:
      case 39:
      case 40:
      case 42:
      case 43:
      case 45:
      case 46:
      case 49:
        return result;
      case 29:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 64LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_CODE_SIGNATURE load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_CODE_SIGNATURE load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 64LL) = a2;
        return result;
      case 30:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 40LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SEGMENT_SPLIT_INFO load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SEGMENT_SPLIT_INFO load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 4dyld4::halt((char *)__format, 0LL) = a2;
        return result;
      case 33:
        if (a2[1] == 20)
        {
          if (*(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL))
          {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO load commands");
          }

          else
          {
            uint64_t result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if ((_DWORD)result) {
              uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO found in 64-bit mach-o");
            }
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO load command size wrong");
        }

        goto LABEL_69;
      case 34:
        goto LABEL_12;
      case 36:
      case 37:
      case 47:
      case 48:
        if (a2[1] == 16)
        {
          if (*(_BYTE *)(*(void *)(*(void *)(v3 + 40) + 8LL) + 24LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_VERSION_MIN_* load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_VERSION_* load command size wrong");
        }

        uint64_t v5 = *(void *)(v3 + 40);
        goto LABEL_70;
      case 38:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 48LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_FUNCTION_STARTS load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_FUNCTION_STARTS load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 48LL) = a2;
        return result;
      case 41:
        if (a2[1] == 16)
        {
          if (*(void *)(*(void *)(v3 + 72) + 56LL)) {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DATA_IN_CODE load commands");
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DATA_IN_CODE load command size wrong");
        }

        *(void *)(*(void *)(v3 + 72) + 56LL) = a2;
        return result;
      case 44:
        if (a2[1] == 24)
        {
          if (*(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL))
          {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_ENCRYPTION_INFO_64 load commands");
          }

          else
          {
            uint64_t result = dyld3::MachOFile::is64((dyld3::MachOFile *)result);
            if ((result & 1) == 0) {
              uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 found in 32-bit mach-o");
            }
          }
        }

        else
        {
          uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_ENCRYPTION_INFO_64 load command size wrong");
        }

LABEL_69:
        uint64_t v5 = *(void *)(v3 + 48);
LABEL_70:
        *(_BYTE *)(*(void *)(v5 + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
        break;
      case 50:
        break;
      default:
        if (v4 == 2)
        {
          if (a2[1] == 24)
          {
            if (*(void *)(*(void *)(v3 + 72) + 24LL)) {
              uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_SYMTAB load commands");
            }
          }

          else
          {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_SYMTAB load command size wrong");
          }

          *(void *)(*(void *)(v3 + 72) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
        }

        else if (v4 == 11)
        {
          if (a2[1] == 80)
          {
            if (*(void *)(*(void *)(v3 + 72) + 32LL)) {
              uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "multiple LC_DYSYMTAB load commands");
            }
          }

          else
          {
            uint64_t result = Diagnostics::error(*(vm_address_t **)(v3 + 64), "LC_DYSYMTAB load command size wrong");
          }

          *(void *)(*(void *)(v3 + 72) + 32LL) = a2;
        }

        break;
    }
  }

  return result;
}

void dyld3::MachOLoaded::getLinkEditPointers(_DWORD *a1, vm_address_t *a2, uint64_t a3)
{
  if (Diagnostics::noError((Diagnostics *)a2))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    void v6[2] = ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke;
    void v6[3] = &__block_descriptor_tmp_34_0;
    v6[4] = a1;
    void v6[5] = a3 + 72;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v6);
  }

uint64_t ___ZNK5dyld311MachOLoaded13getLayoutInfoERNS0_10LayoutInfoE_block_invoke(uint64_t a1, int64x2_t *a2)
{
  int v4 = (const char *)a2[2].i64[1];
  uint64_t result = _platform_strcmp(v4, "__TEXT");
  if ((_DWORD)result)
  {
    uint64_t result = _platform_strcmp(v4, "__LINKEDIT");
    unsigned int v6 = *(int32x2_t **)(a1 + 40);
    if (!(_DWORD)result)
    {
      void v6[2] = *(int32x2_t *)a2[1].i8;
      void v6[3] = vmovn_s64(*a2);
      v6[4].i32[0] = (unsigned __int16)a2[3].i32[2] >> 4;
    }
  }

  else
  {
    uint64_t v7 = a2[1].i64[0];
    unsigned int v6 = *(int32x2_t **)(a1 + 40);
    *unsigned int v6 = (int32x2_t)(*(void *)(a1 + 32) - v7);
    v6[1] = (int32x2_t)v7;
  }

  v6[4].i32[1] = (unsigned __int16)a2[3].i32[2] >> 4;
  return result;
}

uint64_t dyld3::MachOLoaded::hasExportedSymbol( dyld3::MachOFile *a1, const unsigned __int8 *a2, uint64_t a3, void *a4, _BYTE *a5)
{
  uint64_t ExportedSymbol = dyld3::MachOLoaded::findExportedSymbol(a1, (vm_address_t *)&v18, a2, 0LL, (uint64_t)&v14, a3);
  if ((_DWORD)ExportedSymbol)
  {
    switch(v14)
    {
      case 2:
        *a4 = ((uint64_t (*)(void))((char *)v15 + v17))();
        *a5 = 1;
        break;
      case 1:
        *a4 = v16;
        *a5 = 0;
        break;
      case 0:
        char v11 = v15;
        *a4 = (char *)v15 + v16;
        *a5 = 0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000LL;
        uint64_t v13[2] = ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke;
        void v13[3] = &__block_descriptor_tmp_36_2;
        uint64_t v13[4] = dyld3::MachOLoaded::getSlide(v11);
        void v13[5] = a4;
        void v13[6] = a5;
        dyld3::MachOFile::forEachSection(v15, (uint64_t)v13);
        break;
    }
  }

  mach_o::Error::~Error(&v18);
  return ExportedSymbol;
}

uint64_t dyld3::MachOLoaded::findExportedSymbol( dyld3::MachOFile *a1, vm_address_t *a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return 0LL;
  }
  if (*((void *)&v51[0] + 1))
  {
    int v14 = (unsigned int *)(*((void *)&v51[0] + 1) + 12LL);
    uint64_t v15 = (_DWORD *)(*((void *)&v51[0] + 1) + 8LL);
    if (!a1)
    {
LABEL_18:
      __int128 v23 = v51[2];
      __int128 v37 = v51[3];
      __int128 v38 = v51[4];
      __int128 v39 = v52;
      __int128 v40 = v53;
      __int128 v24 = v51[1];
      __int128 v34 = v51[0];
      *(void *)(a5 + 8) = 0LL;
      v33[0] = _NSConcreteStackBlock;
      __int128 v35 = v24;
      v33[1] = 0x40000000LL;
      uint64_t v33[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2;
      v33[3] = &__block_descriptor_tmp_43;
      v33[4] = a1;
      v33[5] = a3;
      void v33[6] = a5;
      __int128 v36 = v23;
      dyld3::MachOLoaded::forEachGlobalSymbol(a1, a2, (uint64_t)v33);
      uint64_t v25 = *(void *)(a5 + 8);
      if (!v25)
      {
        unint64_t v47 = 0LL;
        uint64_t v48 = &v47;
        uint64_t v49 = 0x2000000000LL;
        int v50 = 0;
        v31[0] = _NSConcreteStackBlock;
        v31[1] = 0x40000000LL;
        _OWORD v31[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3;
        v31[3] = &unk_189622078;
        v31[4] = a6;
        v31[5] = &v47;
        v31[6] = a1;
        v31[7] = a2;
        char v32 = a4;
        void v31[8] = a3;
        v31[9] = a5;
        dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v31);
        _Block_object_dispose(&v47, 8);
        uint64_t v25 = *(void *)(a5 + 8);
      }

      return v25 != 0;
    }
  }

  else
  {
    if (!*(void *)&v51[0]) {
      goto LABEL_18;
    }
    int v14 = (unsigned int *)(*(void *)&v51[0] + 44LL);
    uint64_t v15 = (_DWORD *)(*(void *)&v51[0] + 40LL);
    if (!a1) {
      goto LABEL_18;
    }
  }

  uint64_t v16 = (const unsigned __int8 **)((char *)a1 + *((void *)&v52 + 1) - v52 + (*v15 - v53));
  unsigned int v17 = (Diagnostics *)((char *)v16 + *v14);
  unsigned int v18 = dyld3::MachOFile::trieWalk(a2, v16, v17, a3, v12);
  if (!v18)
  {
    unint64_t v47 = 0LL;
    uint64_t v48 = &v47;
    uint64_t v49 = 0x2000000000LL;
    int v50 = 0;
    uint64_t v43 = 0LL;
    int v44 = &v43;
    uint64_t v45 = 0x2000000000LL;
    char v46 = 0;
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 0x40000000LL;
    v41[2] = ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke;
    uint64_t v41[3] = &unk_189622030;
    v41[4] = a6;
    void v41[5] = &v47;
    v41[8] = a2;
    v41[9] = a3;
    char v42 = a4;
    v41[10] = a5;
    v41[6] = &v43;
    v41[7] = a1;
    dyld3::MachOFile::forEachDependentDylib(a1, (uint64_t)v41);
    BOOL v13 = *((_BYTE *)v44 + 24) != 0;
    _Block_object_dispose(&v43, 8);
    _Block_object_dispose(&v47, 8);
    return v13;
  }

  unint64_t v47 = v18;
  char v21 = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v19);
  if ((v21 & 8) != 0)
  {
    if (a6)
    {
      unint64_t v27 = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v20);
      int v28 = v27;
      if (*(_BYTE *)v47) {
        __int128 v29 = v47;
      }
      else {
        __int128 v29 = (const unsigned __int8 **)a3;
      }
      if (v27 && v27 <= dyld3::MachOFile::dependentDylibCount(a1, 0LL))
      {
        uint64_t v30 = (*(uint64_t (**)(uint64_t, dyld3::MachOFile *, void))(a6 + 16))( a6,  a1,  (v28 - 1));
        if (v30) {
          return dyld3::MachOLoaded::findExportedSymbol(v30, a2, v29, a4, a5, a6);
        }
        if ((a4 & 1) == 0) {
          Diagnostics::error(a2, "dependent dylib %lld not found for re-exported symbol %s");
        }
      }

      else
      {
        Diagnostics::error(a2, "re-export ordinal %lld out of range for %s");
      }
    }

    return 0LL;
  }

  *(_DWORD *)a5 = 0;
  *(_WORD *)(a5 + 4) = 0;
  *(void *)(a5 + 8) = a1;
  *(void *)(a5 + 16) = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v20);
  *(_DWORD *)(a5 + 24) = 0;
  *(void *)(a5 + 32) = a3;
  BOOL v13 = 0LL;
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return v13;
  }
  if ((v21 & 3) == 2LL)
  {
    BOOL v13 = 1LL;
    *(_DWORD *)a5 = 1;
    return v13;
  }

  if ((v21 & 3) == 1LL)
  {
    BOOL v13 = 1LL;
    *(_BYTE *)(a5 + 4) = 1;
    return v13;
  }

  if ((v21 & 3) != 0)
  {
    Diagnostics::error(a2, "unsupported exported symbol kind. flags=%llu at node offset=0x%0lX");
    return 0LL;
  }

  *(_DWORD *)a5 = 0;
  if ((v21 & 0x10) != 0) {
    *(_DWORD *)(a5 + 24) = dyld3::MachOFile::read_uleb128(a2, &v47, (const unsigned __int8 **)v17, v22);
  }
  BOOL v13 = 1LL;
  if ((v21 & 4) != 0) {
    *(_BYTE *)(a5 + 5) = 1;
  }
  return v13;
}

uint64_t dyld3::MachOLoaded::getSlide(dyld3::MachOLoaded *this)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke;
  void v4[3] = &unk_1896220A0;
  v4[4] = &v5;
  void v4[5] = this;
  dyld3::MachOFile::forEachLoadCommand(this, (vm_address_t *)&v9, (uint64_t)v4);
  Diagnostics::assertNoError((Diagnostics *)&v9);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  mach_o::Error::~Error(&v9);
  return v2;
}

uint64_t ___ZNK5dyld311MachOLoaded17hasExportedSymbolEPKcU13block_pointerFPKS0_S4_jEPPvPb_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4 = *(void *)(result + 32) + *(void *)(a2 + 64);
  unint64_t v5 = **(void **)(result + 40);
  if (v4 <= v5 && *(void *)(a2 + 72) + v4 > v5)
  {
    **(_BYTE **)(result + 48) = (*(_DWORD *)(a2 + 92) & 0x80000400) != 0;
    *a4 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  uint64_t v8 = result;
  if (a4)
  {
    uint64_t result = *(void *)(result + 32);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(result + 16))( result,  *(void *)(v8 + 56),  *(unsigned int *)(*(void *)(*(void *)(v8 + 40) + 8LL) + 24LL));
      if (result)
      {
        uint64_t result = dyld3::MachOLoaded::findExportedSymbol( result,  *(void *)(v8 + 64),  *(void *)(v8 + 72),  *(unsigned __int8 *)(v8 + 88),  *(void *)(v8 + 80),  *(void *)(v8 + 32));
        if ((_DWORD)result)
        {
          *a8 = 1;
          *(_BYTE *)(*(void *)(*(void *)(v8 + 48) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
        }
      }
    }
  }

  ++*(_DWORD *)(*(void *)(*(void *)(v8 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t dyld3::MachOLoaded::forEachGlobalSymbol(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    uint64_t result = dyld3::MachOFile::is64(a1);
    if (v23)
    {
      int v7 = result;
      if (v24)
      {
        int v8 = *(_DWORD *)(v24 + 16);
        char v9 = (unsigned int *)(v24 + 20);
      }

      else
      {
        int v8 = 0;
        char v9 = v23 + 3;
      }

      unint64_t v10 = *v9;
      unsigned int v11 = v23[5];
      if ((_DWORD)v10)
      {
        uint64_t v12 = v25 + v26 + (v23[4] - v27);
        uint64_t v13 = v25 + v26 + (v23[2] - v27);
        unint64_t v14 = 1LL;
        int v15 = v8;
        while (1)
        {
          uint64_t v16 = (v15 + v14 - 1);
          if (v7)
          {
            uint64_t v17 = *(unsigned int *)(v13 + 16 * v16);
            if (v17 <= v11)
            {
              uint64_t v18 = v13 + 16 * v16;
              if ((*(_BYTE *)(v18 + 4) & 0xEF) == 0xF)
              {
                uint64_t v19 = v12 + v17;
                uint64_t v20 = *(void *)(v18 + 8);
LABEL_15:
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
              }
            }
          }

          else
          {
            uint64_t v21 = *(unsigned int *)(v13 + 12LL * v16);
            if (v21 <= v11 && (*(_BYTE *)(v13 + 12LL * v16 + 4) & 0xEF) == 0xF)
            {
              uint64_t v19 = v12 + v21;
              uint64_t v20 = *(unsigned int *)(v13 + 12LL * v16 + 8);
              goto LABEL_15;
            }
          }

          if (v14 >= v10) {
            return result;
          }
          ++v14;
        }
      }
    }
  }

  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_2( uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _BYTE *a7)
{
  uint64_t result = _platform_strcmp(__s1, *(const char **)(a1 + 40));
  if (!(_DWORD)result)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 48);
    *(_DWORD *)uint64_t v12 = 0;
    *(_BYTE *)(v12 + 4) = 0;
    *(void *)(v12 + 8) = v11;
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 48);
    *(void *)(v13 + 16) = a3 - *(void *)(a1 + 136);
    *(_DWORD *)(v13 + 24) = 0;
    *(void *)(v13 + 32) = v14;
    *a7 = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded18findExportedSymbolER11DiagnosticsPKcbRNS0_11FoundSymbolEU13block_pointerFPKS0_S8_jE_block_invoke_3( uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  uint64_t v8 = result;
  if (a4)
  {
    uint64_t result = *(void *)(result + 32);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(result + 16))( result,  *(void *)(v8 + 48),  *(unsigned int *)(*(void *)(*(void *)(v8 + 40) + 8LL) + 24LL));
      if (result)
      {
        uint64_t result = dyld3::MachOLoaded::findExportedSymbol( result,  *(void *)(v8 + 56),  *(void *)(v8 + 64),  *(unsigned __int8 *)(v8 + 80),  *(void *)(v8 + 72),  *(void *)(v8 + 32));
        if ((_DWORD)result) {
          *a8 = 1;
        }
      }
    }
  }

  ++*(_DWORD *)(*(void *)(*(void *)(v8 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded8getSlideEv_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 40);
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v7 = *(unsigned int *)(a2 + 24);
    goto LABEL_7;
  }

  if (*(_DWORD *)a2 == 25)
  {
    uint64_t result = _platform_strcmp((const char *)(a2 + 8), "__TEXT");
    if (!(_DWORD)result)
    {
      uint64_t v7 = *(void *)(a2 + 24);
LABEL_7:
      *(void *)(*(void *)(*(void *)(v5 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6 - v7;
      *a3 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOLoaded::getLinkEditContent(uint64_t a1, uint64_t a2, int a3)
{
  return *(void *)a2 + *(void *)(a2 + 16) + (a3 - *(_DWORD *)(a2 + 24));
}

uint64_t dyld3::MachOLoaded::segmentName(dyld3::MachOLoaded *this, int a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke;
  void v4[3] = &unk_1896220C8;
  int v5 = a2;
  v4[4] = &v6;
  dyld3::MachOFile::forEachSegment(this, (uint64_t)v4);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld311MachOLoaded11segmentNameEj_block_invoke(uint64_t result, uint64_t a2, _BYTE *a3)
{
  if (*(_DWORD *)(result + 40) == (unsigned __int16)*(_DWORD *)(a2 + 56) >> 4)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(a2 + 40);
    *a3 = 1;
  }

  return result;
}

uint64_t dyld3::MachOLoaded::findClosestSymbol( dyld3::MachOLoaded *this, uint64_t a2, const char **a3, unint64_t *a4)
{
  uint64_t v8 = 0LL;
  if (!Diagnostics::hasError((Diagnostics *)&v46))
  {
    uint64_t v8 = 0LL;
    if (v41)
    {
      if (v42)
      {
        unint64_t v9 = a2 - v43;
        uint64_t v36 = 0LL;
        __int128 v37 = &v36;
        uint64_t v38 = 0x2000000000LL;
        int v39 = 0;
        v35[0] = _NSConcreteStackBlock;
        v35[1] = 0x40000000LL;
        v35[2] = ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke;
        _DWORD v35[3] = &unk_1896220F0;
        v35[4] = &v36;
        v35[5] = a2 - v43;
        dyld3::MachOFile::forEachSection(this, (uint64_t)v35);
        int v10 = v41[4];
        unsigned int v11 = v41[5];
        int v12 = v45;
        uint64_t v13 = v43 + v44;
        uint64_t v14 = v43 + v44 + (v41[2] - v45);
        BOOL v15 = dyld3::MachOFile::is64(this);
        uint64_t v16 = v42[4];
        uint64_t v17 = v42[5];
        uint64_t v18 = 0LL;
        if (v15)
        {
          if ((_DWORD)v17)
          {
            uint64_t v19 = (unsigned int *)(v14 + 16 * v16);
            uint64_t v20 = &v19[4 * v17];
            do
            {
              if ((~*((unsigned __int8 *)v19 + 4) & 0xE) == 0)
              {
                unint64_t v21 = *((void *)v19 + 1);
                if (v18)
                {
                  if (v21 <= v9 && *((void *)v18 + 1) < v21)
                  {
LABEL_13:
                  }
                }

                else if (v21 <= v9)
                {
                  goto LABEL_13;
                }
              }

              v19 += 4;
            }

            while (v19 < v20);
          }

          uint64_t v22 = v42[3];
          if ((_DWORD)v22)
          {
            __int128 v23 = (unsigned int *)(v14 + 16LL * v42[2]);
            uint64_t v24 = &v23[4 * v22];
            do
            {
              if ((v23[1] & 0xEE) == 0xE)
              {
                unint64_t v25 = *((void *)v23 + 1);
                if (v18)
                {
                  if (v25 <= v9 && *((void *)v18 + 1) < v25)
                  {
LABEL_24:
                  }
                }

                else if (v25 <= v9)
                {
                  goto LABEL_24;
                }
              }

              v23 += 4;
            }

            while (v23 < v24);
          }

          if (v18)
          {
            uint64_t v26 = *((void *)v18 + 1);
LABEL_53:
            *a4 = v43 + v26;
            if (*v18 < v11) {
              *a3 = (const char *)(v13 + (v10 - v12) + *v18);
            }
            uint64_t v8 = 1LL;
            goto LABEL_57;
          }

          goto LABEL_56;
        }

        if ((_DWORD)v17)
        {
          int v27 = (unsigned int *)(v14 + 12LL * v16);
          int v28 = &v27[3 * v17];
          do
          {
            if ((~*((unsigned __int8 *)v27 + 4) & 0xE) == 0)
            {
              unint64_t v29 = v27[2];
              if (v18)
              {
                if (v9 >= v29 && v18[2] < v29)
                {
LABEL_37:
                }
              }

              else if (v9 >= v29)
              {
                goto LABEL_37;
              }
            }

            v27 += 3;
          }

          while (v27 < v28);
        }

        unsigned int v30 = v42[3];
        if (!v30)
        {
LABEL_51:
          if (v18)
          {
            uint64_t v26 = v18[2];
            goto LABEL_53;
          }

LABEL_56:
          uint64_t v8 = 0LL;
LABEL_57:
          _Block_object_dispose(&v36, 8);
          goto LABEL_58;
        }

        __int128 v31 = (unsigned int *)(v14 + 12LL * v42[2]);
        char v32 = &v31[3 * v30];
        while (1)
        {
          if ((v31[1] & 0xEE) == 0xE)
          {
            unint64_t v33 = v31[2];
            if (v18)
            {
              if (v9 >= v33 && v18[2] < v33)
              {
LABEL_48:
              }
            }

            else if (v9 >= v33)
            {
              goto LABEL_48;
            }
          }

          v31 += 3;
          if (v31 >= v32) {
            goto LABEL_51;
          }
        }
      }
    }
  }

uint64_t ___ZNK5dyld311MachOLoaded17findClosestSymbolEyPPKcPy_block_invoke( uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v4 = *(void *)(result + 40);
  ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL);
  unint64_t v5 = *(void *)(a2 + 64);
  if (v5 <= v4 && v4 < *(void *)(a2 + 72) + v5) {
    *a4 = 1;
  }
  return result;
}

uint64_t dyld3::MachOLoaded::findSectionContent( dyld3::MachOLoaded *this, const char *a2, const char *a3, unint64_t *a4)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke;
  void v6[3] = &unk_189622118;
  void v6[6] = a3;
  void v6[7] = a2;
  void v6[8] = a4;
  v6[4] = &v7;
  void v6[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZNK5dyld311MachOLoaded18findSectionContentEPKcS2_Ry_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), *(const char **)(a1 + 48));
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), *(const char **)(a1 + 56));
    if (!(_DWORD)result)
    {
      **(void **)(a1 + 64) = *(void *)(a2 + 72);
      uint64_t result = dyld3::MachOFile::isPreload(v7);
      if ((_DWORD)result)
      {
        uint64_t v9 = (char *)v7 + *(unsigned int *)(a2 + 88);
      }

      else
      {
        uint64_t v10 = *(void *)(a2 + 64);
        uint64_t result = dyld3::MachOLoaded::getSlide(v7);
        uint64_t v9 = (char *)(result + v10);
      }

      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v9;
      *a4 = 1;
    }
  }

  return result;
}

uint64_t dyld3::MachOLoaded::fixupAllChainedFixups( uint64_t a1, vm_address_t *a2, unsigned int *a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke;
  void v7[3] = &unk_189622140;
  __int128 v8 = *a5;
  uint64_t v9 = *((void *)a5 + 2);
  uint64_t v10 = a2;
  uint64_t v11 = a4;
  v7[4] = a6;
  void v7[5] = a1;
  return dyld3::MachOLoaded::forEachFixupInAllChains(a1, a2, a3, 1, (uint64_t)v7);
}

uint64_t dyld3::MachOLoaded::forEachFixupInAllChains( uint64_t result, vm_address_t *a2, unsigned int *a3, char a4, uint64_t a5)
{
  unint64_t v5 = *a3;
  if ((_DWORD)v5)
  {
    uint64_t v10 = result;
    uint64_t v11 = 1LL;
    do
    {
      uint64_t v12 = a3[v11];
      if ((_DWORD)v12)
      {
        uint64_t result = dyld3::MachOLoaded::forEachFixupInSegmentChains(v10, a2, (uint64_t)a3 + v12, a4, a5);
        unint64_t v5 = *a3;
      }

      ++v11;
    }

    while (v11 - 1 < v5);
  }

  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded21fixupAllChainedFixupsER11DiagnosticsPK28dyld_chained_starts_in_imagemNS_5ArrayIPKvEEU13block_pointerFvPvSA_E_block_invoke( uint64_t a1, mach_o::ChainedFixupPointerOnDisk::Generic64 *this, uint64_t a3, _BYTE *a4)
{
  int v6 = *(unsigned __int16 *)(a3 + 6);
  if ((v6 | 4) != 6)
  {
    uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 72), "unsupported pointer chain format: 0x%04X");
    goto LABEL_14;
  }

  uint64_t v8 = *(void *)this;
  if ((*(void *)this & 0x8000000000000000LL) != 0)
  {
    if ((v8 & 0xFFFFFFuLL) < *(void *)(a1 + 64))
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8 * (v8 & 0xFFFFFF));
      unint64_t v12 = mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend(this);
LABEL_9:
      unint64_t v9 = v12 + v11;
      goto LABEL_10;
    }

    uint64_t result = Diagnostics::error(*(vm_address_t **)(a1 + 72), "out of range bind ordinal %d (max %llu)");
LABEL_14:
    *a4 = 1;
    return result;
  }

  if (v6 != 2)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    unint64_t v12 = mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
    goto LABEL_9;
  }

  unint64_t v9 = *(void *)(a1 + 80) + mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget(this);
LABEL_10:
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, mach_o::ChainedFixupPointerOnDisk::Generic64 *, unint64_t))(result + 16))( result,  this,  v9);
  }
  *(void *)this = v9;
  return result;
}

uint64_t dyld3::MachOLoaded::forEachFixupInSegmentChains( uint64_t result, vm_address_t *a2, uint64_t a3, char a4, uint64_t a5)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000LL;
  uint64_t v13[2] = ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke;
  void v13[3] = &unk_189622168;
  uint64_t v13[4] = a5;
  void v13[5] = a3;
  if (*(_WORD *)(a3 + 20))
  {
    uint64_t v8 = result;
    unint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(unsigned __int16 *)(a3 + 2 * v9 + 22);
      if ((_DWORD)v10 == 0xFFFF)
      {
        uint64_t result = 0LL;
      }

      else if ((v10 & 0x8000) != 0)
      {
        unsigned int v11 = v10 & 0x7FFF;
        do
        {
          __int16 v12 = *(_WORD *)(a3 + 2LL * v11 + 22);
          uint64_t result = dyld3::MachOFile::walkChain( a2,  (unsigned int *)(v8 + *(void *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + (v12 & 0x7FFF)),  (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6),  a4,  *(_DWORD *)(a3 + 16),  (uint64_t)v13);
          if (v12 < 0) {
            break;
          }
          ++v11;
        }

        while ((result & 1) == 0);
      }

      else
      {
        uint64_t result = dyld3::MachOFile::walkChain( a2,  (unsigned int *)(v8 + *(void *)(a3 + 8) + v9 * *(unsigned __int16 *)(a3 + 4) + v10),  (mach_o::ChainedFixupPointerOnDisk *)*(unsigned __int16 *)(a3 + 6),  a4,  *(_DWORD *)(a3 + 16),  (uint64_t)v13);
      }

      ++v9;
    }

    while (v9 < *(unsigned __int16 *)(a3 + 20) && (result & 1) == 0);
  }

  return result;
}

uint64_t ___ZNK5dyld311MachOLoaded27forEachFixupInSegmentChainsER11DiagnosticsPK30dyld_chained_starts_in_segmentbU13block_pointerFvPN6mach_o25ChainedFixupPointerOnDiskES5_RbE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, void, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a2,  *(void *)(a1 + 40),  a3);
}

void *mach_o::Layout::Layout(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

uint64_t mach_o::Layout::textUnslidVMAddr(mach_o::Layout *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = (_DWORD *)*((void *)this + 1);
  uint64_t v3 = 48 * v1;
  while (v2[11] != 1)
  {
    v2 += 12;
    v3 -= 48LL;
    if (!v3) {
      return 0LL;
    }
  }

  return *(void *)v2;
}

void *mach_o::SymbolTable::SymbolTable(void *this, const mach_o::Layout *a2)
{
  *this = a2;
  return this;
}

uint64_t mach_o::SymbolTable::forEachGlobalSymbol(dyld3::MachOFile ***a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = dyld3::MachOFile::is64(**a1);
  int v6 = (*a1)[3];
  if (*((_BYTE *)v6 + 220))
  {
    int v7 = result;
    int v8 = *((unsigned __int8 *)v6 + 156);
    if (*((_BYTE *)v6 + 156))
    {
      int v8 = *((_DWORD *)v6 + 37);
      unint64_t v9 = (unsigned int *)((char *)v6 + 152);
    }

    else
    {
      unint64_t v9 = (unsigned int *)((char *)v6 + 216);
    }

    unint64_t v10 = *v9;
    unsigned int v11 = *((_DWORD *)v6 + 60);
    uint64_t v12 = *((void *)v6 + 29);
    uint64_t v13 = *((void *)v6 + 25);
    char v22 = 0;
    if ((_DWORD)v10)
    {
      int v14 = v8;
      unint64_t v15 = 1LL;
      while (1)
      {
        uint64_t v16 = (v14 + v15 - 1);
        if (v7)
        {
          uint64_t v17 = *(unsigned int *)(v13 + 16 * v16);
          uint64_t v18 = v13 + 16 * v16;
          if ((*(_BYTE *)(v18 + 4) & 0xEF) != 0xF) {
            goto LABEL_15;
          }
          uint64_t v19 = v12 + v17;
          uint64_t v20 = *(void *)(v18 + 8);
        }

        else
        {
          uint64_t v21 = *(unsigned int *)(v13 + 12LL * v16);
          uint64_t v19 = v12 + v21;
          uint64_t v20 = *(unsigned int *)(v13 + 12LL * v16 + 8);
        }

        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, v19, v20);
LABEL_15:
        if (v15 < v10)
        {
          ++v15;
          if (!v22) {
            continue;
          }
        }

        return result;
      }
    }
  }

  return result;
}

void mach_o::Fixups::forEachBindTarget( dyld3::MachOFile ***a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!dyld3::MachOFile::isPreload(**a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_ChainedFixups(a1, a2, a5);
    }

    else if (dyld3::MachOFile::hasOpcodeFixups(**a1))
    {
      mach_o::Fixups::forEachBindTarget_Opcodes(a1, (Diagnostics *)a2, a3, a5, a6);
    }
  }

void mach_o::Fixups::forEachBindTarget_ChainedFixups(dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3)
{
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  int v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  void v7[3] = &unk_189622190;
  v7[4] = a3;
  void v7[5] = v8;
  mach_o::Fixups::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(**a1)
    && dyld3::MachOFile::hasWeakDefs(**a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    void v6[2] = ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    void v6[3] = &unk_1896221B8;
    v6[4] = a3;
    void v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }

  _Block_object_dispose(v8, 8);
}

void mach_o::Fixups::forEachBindTarget_Opcodes( dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  int v10 = -1;
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  int v8 = -1;
  void v5[5] = v7;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v6[3] = &unk_189622298;
  v6[4] = a4;
  void v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  void v5[3] = &unk_1896222C0;
  v5[4] = a5;
  mach_o::Fixups::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

dyld3::MachOFile ***mach_o::Fixups::forEachChainedFixupTarget( dyld3::MachOFile ***result, vm_address_t *this, uint64_t a3)
{
  uint64_t v3 = (*result)[3];
  if (*((_BYTE *)v3 + 316))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000LL;
    v4[2] = ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
    void v4[3] = &unk_1896221E0;
    v4[4] = a3;
    return (dyld3::MachOFile ***)mach_o::Fixups::parseOrgArm64eChainedFixups(result, this, 0LL, (uint64_t)v4, 0LL);
  }

  else if (*((_BYTE *)v3 + 412))
  {
    return (dyld3::MachOFile ***)dyld3::MachOFile::forEachChainedFixupTarget( this,  *((unsigned int **)v3 + 49),  *((void *)v3 + 52),  a3);
  }

  return result;
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke( uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 8LL) + 24LL);
  v10[1] = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  char v13 = a5;
  char v14 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t ___ZNK6mach_o6Fixups31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(*(void *)(*(void *)(v4 + 8) + 8LL) + 24LL);
  int v8 = -3;
  uint64_t v9 = a2;
  uint64_t v10 = 0LL;
  __int16 v11 = 0;
  char v6 = 0;
  uint64_t result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t mach_o::Fixups::parseOrgArm64eChainedFixups( dyld3::MachOFile ***a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v30 = 0;
  uint64_t result = dyld3::MachOFile::dependentDylibCount(**a1, 0LL);
  __int16 v11 = (*a1)[3];
  if (*((_BYTE *)v11 + 316))
  {
    unsigned int v27 = result;
    uint64_t v25 = a3;
    uint64_t v26 = a5;
    uint64_t v12 = 0LL;
    char v13 = 0;
    char v14 = 0LL;
    char v15 = 0;
    uint64_t v16 = 0LL;
    uint64_t v28 = 0LL;
    unint64_t v29 = (const unsigned __int8 **)*((void *)v11 + 37);
    uint64_t v17 = (const unsigned __int8 **)((char *)v29 + *((unsigned int *)v11 + 76));
    while (2)
    {
      if (Diagnostics::noError((Diagnostics *)a2))
      {
        uint64_t v19 = v29;
        if (v29 < v17)
        {
          uint64_t v20 = (char *)v29 + 1;
          unsigned int v21 = *(unsigned __int8 *)v29;
          uint64_t v22 = v21 & 0xF;
          unint64_t v29 = (const unsigned __int8 **)((char *)v29 + 1);
          switch(v21 >> 4)
          {
            case 0u:
              goto LABEL_6;
            case 1u:
              char v15 = 1;
              uint64_t v16 = v21 & 0xF;
              goto LABEL_30;
            case 2u:
              uint64_t v16 = dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18);
              goto LABEL_12;
            case 3u:
              if ((v21 & 0xF) != 0) {
                uint64_t v16 = v21 | 0xFFFFFFF0;
              }
              else {
                uint64_t v16 = 0LL;
              }
LABEL_12:
              char v15 = 1;
              goto LABEL_30;
            case 4u:
              if (*v20)
              {
                __int128 v23 = (const unsigned __int8 **)((char *)v19 + 2);
                do
                {
                  unint64_t v29 = v23;
                  int v24 = *(unsigned __int8 *)v23;
                  __int128 v23 = (const unsigned __int8 **)((char *)v23 + 1);
                }

                while (v24);
                uint64_t v19 = (const unsigned __int8 **)((char *)v23 - 2);
              }

              char v13 = v21 & 1;
              unint64_t v29 = (const unsigned __int8 **)((char *)v19 + 2);
              char v14 = v20;
              goto LABEL_30;
            case 5u:
              goto LABEL_31;
            case 6u:
              uint64_t v28 = dyld3::MachOFile::read_sleb128(a2, &v29, v17, v18);
              goto LABEL_30;
            case 7u:
              dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18);
              goto LABEL_30;
            case 9u:
              if (a4) {
                (*(void (**)(uint64_t, void, void, uint64_t, void, _BYTE *, uint64_t, void, char *))(a4 + 16))( a4,  v15 & 1,  v27,  v16,  v12,  v14,  v28,  v13 & 1,  &v30);
              }
              goto LABEL_30;
            case 0xDu:
              if ((_DWORD)v22 == 1)
              {
                if (v26) {
                  (*(void (**)(void))(v26 + 16))();
                }
              }

              else if ((v21 & 0xF) != 0)
              {
                Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
              }

              else if ((unint64_t)dyld3::MachOFile::read_uleb128(a2, &v29, v17, v18) < 0x10000)
              {
                if (v25) {
                  (*(void (**)(void))(v25 + 16))();
                }
              }

              else
              {
                Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_6:
                char v30 = 1;
              }

              goto LABEL_30;
            default:
              Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_30:
              uint64_t v22 = v12;
LABEL_31:
              uint64_t v12 = v22;
              if (v30) {
                return Diagnostics::hasError((Diagnostics *)a2);
              }
              continue;
          }
        }
      }

      return Diagnostics::hasError((Diagnostics *)a2);
    }
  }

  return result;
}

uint64_t ___ZNK6mach_o6Fixups25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void mach_o::Fixups::forEachBindUnified_Opcodes( dyld3::MachOFile ***a1, Diagnostics *a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = 0LL;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  int v20 = 0;
  uint64_t v12 = 0LL;
  char v13 = &v12;
  uint64_t v14 = 0x4802000000LL;
  char v15 = __Block_byref_object_copy__53_0;
  uint64_t v16 = __Block_byref_object_dispose__54_0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _DWORD v10[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v10[3] = &unk_189622208;
  void v10[6] = &v17;
  void v10[7] = a1;
  char v11 = a3;
  void v10[4] = a4;
  v10[5] = &v12;
  if (!mach_o::Fixups::forEachBind_OpcodesRegular(a1, a2, (uint64_t)v10))
  {
    BOOL v8 = mach_o::Fixups::forEachBind_OpcodesLazy(a1, a2, (uint64_t)v10);
    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(&v17, 8);
    if (v8) {
      return;
    }
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    int v20 = 0;
    uint64_t v12 = 0LL;
    char v13 = &v12;
    uint64_t v14 = 0x4802000000LL;
    char v15 = __Block_byref_object_copy__53_0;
    uint64_t v16 = __Block_byref_object_dispose__54_0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2;
    void v9[3] = &unk_189622230;
    void v9[6] = &v17;
    void v9[7] = a1;
    void v9[4] = a5;
    void v9[5] = &v12;
    mach_o::Fixups::forEachBind_OpcodesWeak(a1, a2, (uint64_t)v9, (uint64_t)&__block_literal_global_3);
  }

  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v17, 8);
}

__n128 __Block_byref_object_copy__53_0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char a13, uint64_t a14, char a15, uint64_t a16)
{
  uint64_t v16 = **(void **)(a1 + 56);
  uint64_t v18 = *(uint64_t **)(v16 + 8);
  uint64_t v17 = *(void *)(v16 + 16);
  if (v17)
  {
    v17 *= 48LL;
    uint64_t v19 = v18;
    while (*((_DWORD *)v19 + 11) != 1)
    {
      v19 += 6;
      v17 -= 48LL;
      if (!v17) {
        goto LABEL_7;
      }
    }

    uint64_t v17 = *v19;
  }

BOOL mach_o::Fixups::forEachBind_OpcodesRegular(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  if (!*((_BYTE *)(*a1)[3] + 316)) {
    return 0LL;
  }
  unsigned int v6 = dyld3::MachOFile::pointerSize(**a1);
  char v42 = 0;
  unsigned __int8 v35 = 0;
  unsigned int v36 = dyld3::MachOFile::dependentDylibCount(**a1, 0LL);
  uint64_t v39 = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v7 = 0LL;
  char v38 = 0;
  __int128 v37 = 0LL;
  char v8 = 0;
  char v9 = 0;
  char v10 = 0;
  uint64_t v11 = 0LL;
  uint64_t v12 = (*a1)[3];
  int v41 = (const unsigned __int8 **)*((void *)v12 + 37);
  char v13 = (const unsigned __int8 **)((char *)v41 + *((unsigned int *)v12 + 76));
  uint64_t v14 = v6;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v16 = v41;
    if ((v41 >= v13) | v8 & 1) {
      break;
    }
    uint64_t v17 = (unsigned __int8 *)v41 + 1;
    unsigned int v18 = *(unsigned __int8 *)v41;
    int v41 = (const unsigned __int8 **)((char *)v41 + 1);
    int v19 = v18 & 0xF;
    char v8 = 1;
    switch(v18 >> 4)
    {
      case 0u:
        break;
      case 1u:
        char v8 = 0;
        char v10 = 1;
        uint64_t v11 = v18 & 0xF;
        break;
      case 2u:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        char v8 = 0;
        goto LABEL_12;
      case 3u:
        char v8 = 0;
        if ((v18 & 0xF) != 0) {
          uint64_t v11 = v18 | 0xFFFFFFF0;
        }
        else {
          uint64_t v11 = 0LL;
        }
LABEL_12:
        char v10 = 1;
        break;
      case 4u:
        if (*v17)
        {
          uint64_t v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            int v41 = v20;
            int v21 = *(unsigned __int8 *)v20;
            uint64_t v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }

          while (v21);
          uint64_t v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }

        char v8 = 0;
        char v38 = v18 & 1;
        int v41 = (const unsigned __int8 **)((char *)v16 + 2);
        char v9 = 1;
        __int128 v37 = v17;
        break;
      case 5u:
        char v8 = 0;
        BYTE4(v39) = v18 & 0xF;
        break;
      case 6u:
        uint64_t v40 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v41, v13, v15);
        char v8 = 0;
        char v9 = 1;
        break;
      case 7u:
        uint64_t v7 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        char v8 = 0;
        LOBYTE(v39) = 1;
        unsigned __int8 v35 = v19;
        break;
      case 8u:
        char v8 = 0;
        v7 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        break;
      case 9u:
        LOBYTE(v32) = v9;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v38 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, void, void, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  v39 & 1,  v10 & 1,  v36,  v11,  v14,  v35,  v7,  v30,  v37,  v31,  v40,  v32,  &v42);
        char v9 = 0;
        char v8 = 0;
        v7 += v14;
        break;
      case 0xAu:
        LOBYTE(v32) = v9;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v38 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, void, void, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  v39 & 1,  v10 & 1,  v36,  v11,  v14,  v35,  v7,  v30,  v37,  v31,  v40,  v32,  &v42);
        char v9 = 0;
        char v8 = 0;
        v7 += v14 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v22);
        break;
      case 0xBu:
        LOBYTE(v32) = v9;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v38 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = BYTE4(v39);
        (*(void (**)(uint64_t, const char *, uint64_t, void, void, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  v39 & 1,  v10 & 1,  v36,  v11,  v14,  v35,  v7,  v30,  v37,  v31,  v40,  v32,  &v42);
        char v9 = 0;
        char v8 = 0;
        v7 += (v14 + v14 * v19);
        break;
      case 0xCu:
        unint64_t v23 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v15);
        uint64_t v25 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v41, v13, v24);
        if (!v23) {
          goto LABEL_30;
        }
        unint64_t v33 = v13;
        __int128 v34 = a2;
        uint64_t v26 = v25 + v14;
        unsigned int v27 = 1;
        do
        {
          LOBYTE(v32) = v9;
          LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v38 & 1;
          LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = BYTE4(v39);
          (*(void (**)(uint64_t, const char *, uint64_t, void, void, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  v39 & 1,  v10 & 1,  v36,  v11,  v14,  v35,  v7,  v30,  v37,  v31,  v40,  v32,  &v42);
          char v9 = 0;
          v7 += v26;
          if (v42) {
            break;
          }
          unint64_t v28 = v27++;
        }

        while (v23 > v28);
        char v8 = 0;
        char v13 = v33;
        a2 = v34;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X", *v17);
LABEL_30:
        char v8 = 0;
        break;
    }
  }

  while (!v42);
  return v42 != 0;
}

BOOL mach_o::Fixups::forEachBind_OpcodesLazy(dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3)
{
  if (!*((_BYTE *)(*a1)[3] + 380)) {
    return 0LL;
  }
  unsigned int v6 = dyld3::MachOFile::pointerSize(**a1);
  char v30 = 0;
  unsigned int v26 = dyld3::MachOFile::dependentDylibCount(**a1, 0LL);
  char v7 = 0;
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  char v8 = 0;
  uint64_t v9 = 0LL;
  char v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = (*a1)[3];
  char v13 = (const unsigned __int8 **)(*((void *)v12 + 45) + *((unsigned int *)v12 + 92));
  unint64_t v29 = (const unsigned __int8 **)*((void *)v12 + 45);
  uint64_t v25 = v6;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    char v15 = v29;
    if (v29 >= v13) {
      break;
    }
    uint64_t v16 = (char *)v29 + 1;
    unsigned __int8 v17 = *(_BYTE *)v29;
    unint64_t v29 = (const unsigned __int8 **)((char *)v29 + 1);
    char v18 = v17 & 0xF;
    switch(v17 >> 4)
    {
      case 0:
        break;
      case 1:
        char v8 = 1;
        uint64_t v9 = v17 & 0xF;
        break;
      case 2:
        uint64_t v9 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v29, v13, v14);
        goto LABEL_11;
      case 3:
        if ((v17 & 0xF) != 0) {
          uint64_t v9 = *(_DWORD *)&v17 | 0xFFFFFFF0;
        }
        else {
          uint64_t v9 = 0LL;
        }
LABEL_11:
        char v8 = 1;
        break;
      case 4:
        if (*v16)
        {
          int v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            unint64_t v29 = v19;
            int v20 = *(unsigned __int8 *)v19;
            int v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }

          while (v20);
          char v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }

        char v7 = v17 & 1;
        unint64_t v29 = (const unsigned __int8 **)((char *)v15 + 2);
        char v10 = v16;
        break;
      case 6:
        uint64_t v28 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v29, v13, v14);
        break;
      case 7:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v29, v13, v14);
        LOBYTE(v27) = v18;
        BYTE4(v27) = 1;
        break;
      case 9:
        LOBYTE(v24) = 1;
        BYTE1(v23) = 1;
        LOBYTE(v23) = v7 & 1;
        LOBYTE(v22) = 1;
        (*(void (**)(uint64_t, const char *, void, void, void, uint64_t, uint64_t, void, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  BYTE4(v27) & 1,  v8 & 1,  v26,  v9,  v25,  v27,  v11,  v22,  v10,  v23,  v28,  v24,  &v30);
        v11 += v25;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v17 & 0xF0);
        break;
    }
  }

  while (!v30);
  return v30 != 0;
}

uint64_t ___ZNK6mach_o6Fixups26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyjRKNS0_14BindTargetInfoERbES8__block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13 = **(void **)(a1 + 56);
  uint64_t v15 = *(void *)(v13 + 8);
  uint64_t v14 = *(void *)(v13 + 16);
  if (v14)
  {
    uint64_t v16 = 48 * v14;
    uint64_t v17 = v15;
    do
    {
      if (*(_DWORD *)(v17 + 44) == 1) {
        break;
      }
      v17 += 48LL;
      v16 -= 48LL;
    }

    while (v16);
  }

  uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(void *)(v18 + 48) != a11 || *(void *)(v18 + 56) != a13)
  {
    uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
    int v20 = *(_DWORD *)(v19 + 24);
    *(_DWORD *)(v19 + 24) = v20 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 4dyld4::halt((char *)__format, 0LL) = v20;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 44LL) = -3;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL) = a11;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL) = a13;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 64LL) = 0;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 65LL) = 0;
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

BOOL mach_o::Fixups::forEachBind_OpcodesWeak( dyld3::MachOFile ***a1, Diagnostics *a2, uint64_t a3, uint64_t a4)
{
  if (!*((_BYTE *)(*a1)[3] + 348)) {
    return 0LL;
  }
  unsigned int v7 = dyld3::MachOFile::pointerSize(**a1);
  char v40 = 0;
  unsigned int v35 = dyld3::MachOFile::dependentDylibCount(**a1, 0LL);
  uint64_t v8 = 0LL;
  unsigned __int8 v33 = 0;
  char v9 = 0;
  uint64_t v36 = 0LL;
  uint64_t v37 = 0LL;
  char v10 = 0LL;
  uint64_t v11 = (*a1)[3];
  __int128 v34 = (unsigned __int8 **)(*((void *)v11 + 41) + *((unsigned int *)v11 + 84));
  uint64_t v39 = (const unsigned __int8 **)*((void *)v11 + 41);
  char v12 = 1;
  char v13 = 1;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v15 = v39;
    uint64_t v17 = (char *)v39 + 1;
    unsigned int v16 = *(unsigned __int8 *)v39;
    uint64_t v39 = (const unsigned __int8 **)((char *)v39 + 1);
    unsigned int v18 = v16 & 0xF;
    char v9 = 1;
    switch(v16 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_16;
      case 4u:
        if (*v17)
        {
          uint64_t v19 = (const unsigned __int8 **)((char *)v15 + 2);
          do
          {
            uint64_t v39 = v19;
            int v20 = *(unsigned __int8 *)v19;
            uint64_t v19 = (const unsigned __int8 **)((char *)v19 + 1);
          }

          while (v20);
          uint64_t v15 = (const unsigned __int8 **)((char *)v19 - 2);
        }

        LOBYTE(v36) = v16 & 1;
        uint64_t v39 = (const unsigned __int8 **)((char *)v15 + 2);
        if (v18 >= 8) {
          (*(void (**)(uint64_t, _BYTE *))(a4 + 16))(a4, v17);
        }
        char v9 = 0;
        char v13 = 1;
        char v10 = v17;
        break;
      case 5u:
        char v9 = 0;
        char v12 = v16 & 0xF;
        break;
      case 6u:
        uint64_t v37 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        char v9 = 0;
        char v13 = 1;
        break;
      case 7u:
        uint64_t v8 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        char v9 = 0;
        BYTE4(v36) = 1;
        unsigned __int8 v33 = v18;
        break;
      case 8u:
        char v9 = 0;
        v8 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        break;
      case 9u:
        LOBYTE(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v13;
        LOWORD(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36 & 1;
        LOBYTE(v29) = v12;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  BYTE4(v36) & 1,  1LL,  v35,  4294967293LL,  v7,  v33,  v8,  v29,  v10,  v30,  v37,  v31,  &v40);
        char v13 = 0;
        char v9 = 0;
        v8 += v7;
        break;
      case 0xAu:
        LOBYTE(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v13;
        LOWORD(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36 & 1;
        LOBYTE(v29) = v12;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  BYTE4(v36) & 1,  1LL,  v35,  4294967293LL,  v7,  v33,  v8,  v29,  v10,  v30,  v37,  v31,  &v40);
        char v13 = 0;
        char v9 = 0;
        v8 += v7 + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v21);
        break;
      case 0xBu:
        LOBYTE(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v13;
        LOWORD(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36 & 1;
        LOBYTE(v29) = v12;
        (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  BYTE4(v36) & 1,  1LL,  v35,  4294967293LL,  v7,  v33,  v8,  v29,  v10,  v30,  v37,  v31,  &v40);
        char v13 = 0;
        char v9 = 0;
        v8 += v7 + v7 * v18;
        break;
      case 0xCu:
        unint64_t v22 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v14);
        uint64_t v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &v39, (const unsigned __int8 **)v34, v23);
        if (!v22) {
          goto LABEL_16;
        }
        uint64_t v32 = a4;
        uint64_t v25 = v24 + v7;
        unsigned int v26 = 1;
        do
        {
          LOBYTE(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v13;
          LOWORD(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v36 & 1;
          LOBYTE(v29) = v12;
          (*(void (**)(uint64_t, const char *, void, uint64_t, void, uint64_t, void, void, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  BYTE4(v36) & 1,  1LL,  v35,  4294967293LL,  v7,  v33,  v8,  v29,  v10,  v30,  v37,  v31,  &v40);
          char v13 = 0;
          v8 += v25;
          if (v40) {
            break;
          }
          unint64_t v27 = v26++;
        }

        while (v22 > v27);
        char v9 = 0;
        a4 = v32;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_16:
        char v9 = 0;
        break;
    }
  }

  while (!v40);
  return v40 != 0;
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke( uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) != *a4)
  {
    uint64_t v5 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
    *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *a4;
  }

  return result;
}

uint64_t ___ZNK6mach_o6Fixups25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2( uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) != *a4)
  {
    uint64_t v5 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
    *(_DWORD *)(*(void *)(*(void *)(v5 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *a4;
  }

  return result;
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget( mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1 = *(void *)this;
  if ((*(void *)this & 0x4000000000000000LL) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  }
  if ((v1 & 0x8000000000000000LL) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget();
  }
  return v1 & 0x7FFFFFFFFFFLL | ((unint64_t)(v1 >> 43) << 56);
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend( mach_o::ChainedFixupPointerOnDisk::Arm64e *this)
{
  unint64_t v1 = *(void *)this;
  if ((*(void *)this & 0x4000000000000000LL) == 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  }
  if ((v1 & 0x8000000000000000LL) != 0) {
    mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend();
  }
  if ((v1 & 0x4000000000000LL) != 0) {
    return HIDWORD(v1) | 0xFFFFFFFFFFFC0000LL;
  }
  else {
    return HIDWORD(v1) & 0x7FFFF;
  }
}

unint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::unpackedTarget( mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *(void *)this & 0xFFFFFFFFFLL | ((unint64_t)(*(void *)this >> 36) << 56);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::Generic64::signExtendedAddend( mach_o::ChainedFixupPointerOnDisk::Generic64 *this)
{
  return *((unsigned __int8 *)this + 3);
}

uint64_t mach_o::ChainedFixupPointerOnDisk::isRebase( mach_o::ChainedFixupPointerOnDisk *this, int a2, uint64_t a3, unint64_t *a4)
{
  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      if ((*(void *)this & 0x4000000000000000LL) != 0) {
        return 0LL;
      }
      if ((*(void *)this & 0x8000000000000000LL) != 0)
      {
        unint64_t v7 = *(void *)this;
      }

      else
      {
        unint64_t v7 = mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget(this);
        if (a2 == 10 || a2 == 1) {
          v7 -= a3;
        }
      }

      goto LABEL_19;
    case 2:
    case 6:
      unint64_t v8 = *(void *)this;
      if ((*(void *)this & 0x8000000000000000LL) != 0) {
        return 0LL;
      }
      unint64_t v9 = v8 >> 36;
      uint64_t v10 = v8 & 0xFFFFFFFFFLL;
      if (a2 == 2) {
        uint64_t v11 = a3;
      }
      else {
        uint64_t v11 = 0LL;
      }
      unint64_t v7 = v10 - v11 + (v9 << 56);
      goto LABEL_19;
    case 3:
      int v12 = *(_DWORD *)this;
      if ((*(_DWORD *)this & 0x80000000) == 0) {
        goto LABEL_16;
      }
      return 0LL;
    case 5:
      int v12 = *(_DWORD *)this;
LABEL_16:
      unint64_t v7 = (v12 & 0x3FFFFFF) - a3;
      goto LABEL_19;
    case 8:
    case 11:
      unint64_t v7 = *(void *)this & 0x3FFFFFFFLL;
      goto LABEL_19;
    case 13:
      unint64_t v7 = *(void *)this & 0x3FFFFFFFFLL;
LABEL_19:
      *a4 = v7;
      return 1LL;
    default:
      mach_o::ChainedFixupPointerOnDisk::isRebase();
  }

uint64_t mach_o::ChainedFixupPointerOnDisk::isBind( mach_o::ChainedFixupPointerOnDisk *this, int a2, unsigned int *a3, unint64_t *a4)
{
  *a4 = 0LL;
  uint64_t v5 = 0LL;
  switch(a2)
  {
    case 1:
    case 7:
    case 9:
    case 10:
    case 12:
      uint64_t v6 = *(void *)this;
      if ((*(void *)this & 0x4000000000000000LL) == 0) {
        return 0LL;
      }
      if (a2 == 12) {
        int v7 = 0xFFFFFF;
      }
      else {
        int v7 = 0xFFFF;
      }
      *a3 = v7 & v6;
      if (v6 < 0) {
        return 1LL;
      }
      unint64_t v8 = mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend(this);
      goto LABEL_13;
    case 2:
    case 6:
      if ((*(void *)this & 0x8000000000000000LL) == 0) {
        return 0LL;
      }
      *a3 = *(void *)this & 0xFFFFFF;
      unint64_t v8 = *((unsigned __int8 *)this + 3);
      goto LABEL_13;
    case 3:
      if ((*(_DWORD *)this & 0x80000000) == 0) {
        return 0LL;
      }
      *a3 = *(_DWORD *)this & 0xFFFFF;
      unint64_t v8 = ((unint64_t)*(unsigned int *)this >> 20) & 0x3F;
LABEL_13:
      *a4 = v8;
      return 1LL;
    case 8:
    case 11:
      return v5;
    default:
      mach_o::ChainedFixupPointerOnDisk::isBind();
  }

uint64_t mach_o::ChainedFixupPointerOnDisk::strideSize(mach_o::ChainedFixupPointerOnDisk *this)
{
  return dword_1800B903C[(__int16)((_WORD)this - 1)];
}

char *dyld4::Utils::strrstr(dyld4::Utils *this, const char *__s, const char *a3)
{
  size_t v5 = _platform_strlen(__s);
  size_t v6 = _platform_strlen((const char *)this);
  if (!v6) {
    return 0LL;
  }
  size_t v7 = v6;
  while (1)
  {
    unint64_t v8 = (char *)this + v7;
    if (!--v7) {
      return 0LL;
    }
  }

  return v8;
}

size_t dyld4::Utils::concatenatePaths(dyld4::Utils *this, char *a2, const char *a3)
{
  if (*((_BYTE *)this + _platform_strlen((const char *)this) - 1) == 47 && *a2 == 47)
  {
    size_t v6 = a2 + 1;
    size_t v7 = (char *)this;
  }

  else
  {
    size_t v7 = (char *)this;
    size_t v6 = a2;
  }

  return strlcat(v7, v6, (size_t)a3);
}

BOOL dyld3::MachOAnalyzer::isOSBinary(dyld3::MachOAnalyzer *this, int a2, uint64_t a3)
{
  if (a2 == -1) {
    return 0LL;
  }
  BOOL result = dyld3::MachOFile::hasCodeSignature(this, &v10, &v9);
  if (!(_DWORD)result) {
    return result;
  }
  v11[0] = a3;
  v11[1] = v10;
  __int128 v11[2] = v9;
  if (fcntl(a2, 97, v11) == -1) {
    return 0LL;
  }
  uint64_t v8 = 1LL;
  uint64_t v7 = a3;
  return fcntl(a2, 105, &v7) != -1 && HIDWORD(v8) != 0;
}

void dyld3::MachOAnalyzer::withVMLayout(dyld3::MachOLoaded *a1, vm_address_t *a2, uint64_t a3)
{
  int v20 = a2;
  uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v82 = 0LL;
  uint64_t v83 = &v82;
  uint64_t v84 = 0x2000000000LL;
  uint64_t v85 = 0LL;
  uint64_t v78 = 0LL;
  __int128 v79 = &v78;
  uint64_t v80 = 0x2000000000LL;
  uint64_t v81 = 0LL;
  uint64_t v6 = dyld3::MachOFile::segmentCount(a1);
  uint64_t v7 = v6;
  __chkstk_darwin(v6, v8, v9, v10, v11, v12, v13, v14, (uint64_t)&v19);
  unsigned int v16 = &v19 - 2 * v15;
  if (v17) {
    bzero(v16, 48 * ((48 * (unint64_t)v7 - 48) / 0x30) + 48);
  }
  v77[0] = _NSConcreteStackBlock;
  v77[1] = 0x40000000LL;
  void v77[2] = ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke;
  v77[3] = &unk_1896227C8;
  v77[4] = &v82;
  uint64_t v77[5] = &v78;
  v77[6] = Slide;
  v77[7] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v77);
  int v21 = 0;
  uint64_t v22 = 0LL;
  v23[0] = 0LL;
  *(void *)((char *)v23 + 5) = 0LL;
  int v24 = 0;
  uint64_t v25 = 0LL;
  v26[0] = 0LL;
  *(void *)((char *)v26 + 5) = 0LL;
  int v27 = 0;
  uint64_t v28 = 0LL;
  v29[0] = 0LL;
  *(void *)((char *)v29 + 5) = 0LL;
  int v30 = 0;
  uint64_t v31 = 0LL;
  v32[0] = 0LL;
  *(void *)((char *)v32 + 5) = 0LL;
  int v33 = 0;
  *(void *)((char *)v35 + 5) = 0LL;
  uint64_t v34 = 0LL;
  v35[0] = 0LL;
  int v36 = 0;
  uint64_t v37 = 0LL;
  v38[0] = 0LL;
  *(void *)((char *)v38 + 5) = 0LL;
  int v39 = 0;
  uint64_t v40 = 0LL;
  v41[0] = 0LL;
  *(void *)((char *)v41 + 5) = 0LL;
  int v42 = 0;
  uint64_t v43 = 0LL;
  v44[0] = 0LL;
  *(void *)((char *)v44 + 5) = 0LL;
  int v45 = 0;
  *(void *)((char *)v47 + 5) = 0LL;
  uint64_t v46 = 0LL;
  v47[0] = 0LL;
  int v48 = 0;
  *(void *)((char *)v50 + 5) = 0LL;
  uint64_t v49 = 0LL;
  v50[0] = 0LL;
  int v51 = 0;
  *(void *)((char *)v53 + 5) = 0LL;
  uint64_t v52 = 0LL;
  v53[0] = 0LL;
  int v54 = 0;
  *(void *)((char *)v56 + 5) = 0LL;
  uint64_t v55 = 0LL;
  v56[0] = 0LL;
  int v57 = 0;
  *(void *)((char *)v59 + 5) = 0LL;
  uint64_t v58 = 0LL;
  v59[0] = 0LL;
  void v59[2] = 0LL;
  int v60 = 0;
  *(void *)((char *)v62 + 5) = 0LL;
  uint64_t v61 = 0LL;
  v62[0] = 0LL;
  int v63 = 0;
  *(void *)((char *)v65 + 5) = 0LL;
  uint64_t v64 = 0LL;
  v65[0] = 0LL;
  int v66 = 0;
  *(void *)((char *)v68 + 5) = 0LL;
  v68[0] = 0LL;
  uint64_t v67 = 0LL;
  int v69 = 0;
  *(void *)((char *)v71 + 5) = 0LL;
  v71[0] = 0LL;
  uint64_t v70 = 0LL;
  int v72 = 0;
  *(void *)((char *)v74 + 5) = 0LL;
  v74[0] = 0LL;
  uint64_t v73 = 0LL;
  int v75 = 0;
  __int16 v76 = 0;
  uint64_t v18 = v83[3];
  uint64_t v87 = v79[3];
  uint64_t v88 = v18;
  v86[0] = _NSConcreteStackBlock;
  v86[1] = 0x40000000LL;
  v86[2] = ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke;
  v86[3] = &__block_descriptor_tmp_269;
  v86[4] = a1;
  v86[5] = &v21;
  v86[6] = &v88;
  v86[7] = &v87;
  dyld3::MachOFile::forEachLoadCommand(a1, v20, (uint64_t)v86);
  mach_o::Layout::Layout(v86, (uint64_t)a1, (uint64_t)v16, v7, (uint64_t)&v21);
  (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v86);
  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(&v82, 8);
}

__n128 ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke( uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32) + ((unint64_t)((unsigned __int16)*(_DWORD *)(a2 + 56) >> 4) << 6);
  __n128 result = *(__n128 *)a2;
  __int128 v4 = *(_OWORD *)(a2 + 16);
  __int128 v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 48) = v5;
  *(__n128 *)unint64_t v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  __int128 v4 = (Diagnostics *)a2;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v74);
  uint64_t result = Diagnostics::hasError(v4);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v63);
    uint64_t v15 = &v63 - 8 * v14;
    v76[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v76[1] = (const unsigned __int8 **)0x40000000;
    v16[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    void v16[3] = &__block_descriptor_tmp_58_0;
    v16[4] = v15;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v76);
    uint64_t result = Diagnostics::hasError(v4);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::is64(a1);
      if ((_DWORD)result) {
        int v17 = 2;
      }
      else {
        int v17 = 1;
      }
      if (v74[0])
      {
        uint64_t v69 = a3;
        uint64_t v70 = v15;
        unsigned int v66 = v17;
        uint64_t v67 = &v63;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)&v75,  *(_DWORD *)(v74[0] + 8LL));
        uint64_t v64 = *(unsigned int *)(v74[0] + 12LL);
        int v72 = (const unsigned __int8 **)((char *)LinkEditContent + v64);
        unint64_t v65 = LinkEditContent;
        v76[0] = LinkEditContent;
        unsigned int v19 = dyld3::MachOFile::pointerSize(a1);
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
        uint64_t v22 = 0LL;
        uint64_t v23 = 0LL;
        char v73 = 0;
        uint64_t v24 = v19;
        uint64_t v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
        int v68 = v4;
        while (2)
        {
          uint64_t result = Diagnostics::noError(v4);
          if ((_DWORD)result)
          {
            int v27 = v76[0];
            if (v76[0] < v72)
            {
              unsigned __int8 v28 = *(_BYTE *)v76[0]++;
              uint64_t v29 = v28 & 0xF;
              switch(v28 >> 4)
              {
                case 0:
                  int v62 = (char *)v27 + 1;
                  if ((char *)v72 - v62 >= 16) {
                    return Diagnostics::error( (vm_address_t *)v4,  "rebase opcodes terminated early at offset %d of %d",  (int)v62 - (int)v65,  v64);
                  }
                  return result;
                case 1:
                  switch((_DWORD)v29)
                  {
                    case 1:
                      uint64_t v20 = v66;
                      break;
                    case 3:
                      uint64_t v20 = 3LL;
                      break;
                    case 2:
                      uint64_t v20 = 4LL;
                      break;
                    default:
                      uint64_t v20 = 0LL;
                      break;
                  }

                  goto LABEL_47;
                case 2:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  uint64_t v23 = result;
                  uint64_t v21 = 1LL;
                  uint64_t v22 = v29;
                  goto LABEL_47;
                case 3:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  v23 += result;
                  goto LABEL_47;
                case 4:
                  v23 += (v24 * v29);
                  goto LABEL_47;
                case 5:
                  if ((v28 & 0xF) == 0) {
                    goto LABEL_47;
                  }
                  unsigned int v30 = 1;
                  uint64_t v31 = v20;
                  uint64_t v32 = v22;
                  uint64_t v33 = v21;
                  uint64_t v34 = v70;
                  uint64_t v35 = v69;
                  do
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, uint64_t, uint64_t, void, uint64_t, _DWORD, char *))(v35 + 16))( v35,  "REBASE_OPCODE_DO_REBASE_IMM_TIMES",  v74,  v34,  v33 & 1,  v24,  v32,  v23,  v31,  &v73);
                    v23 += v24;
                    if (v73) {
                      BOOL v36 = 1;
                    }
                    else {
                      BOOL v36 = v30 >= v29;
                    }
                    ++v30;
                  }

                  while (!v36);
                  __int128 v4 = v68;
                  uint64_t v21 = v33;
                  uint64_t v22 = v32;
                  uint64_t v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
                  uint64_t v20 = v31;
                  if (v73) {
                    return result;
                  }
                  continue;
                case 6:
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  if (result)
                  {
                    unint64_t v37 = result;
                    unsigned int v38 = 1;
                    uint64_t v39 = v21;
                    uint64_t v40 = v20;
                    uint64_t v41 = v22;
                    uint64_t v42 = v39;
                    uint64_t v43 = v70;
                    uint64_t v44 = v69;
                    do
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, uint64_t, uint64_t, void, uint64_t, _DWORD, char *))(v44 + 16))( v44,  "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB",  v74,  v43,  v42 & 1,  v24,  v41,  v23,  v40,  &v73);
                      v23 += v24;
                      unint64_t v45 = v38++;
                      if (v73) {
                        BOOL v46 = 0;
                      }
                      else {
                        BOOL v46 = v37 > v45;
                      }
                    }

                    while (v46);
                    __int128 v4 = v68;
                    uint64_t v47 = v42;
                    uint64_t v22 = v41;
                    uint64_t v25 = "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB";
                    uint64_t v20 = v40;
                    uint64_t v21 = v47;
                  }

                  goto LABEL_47;
                case 7:
                  (*(void (**)(uint64_t, const char *, void *, uint64_t *, uint64_t, uint64_t, void, uint64_t, _DWORD, char *))(v69 + 16))( v69,  "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB",  v74,  v70,  v21 & 1,  v24,  v22,  v23,  v20,  &v73);
                  uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v48);
                  v23 += v24 + result;
                  goto LABEL_47;
                case 8:
                  unint64_t uleb128 = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v26);
                  uint64_t result = Diagnostics::hasError(v4);
                  if ((result & 1) == 0)
                  {
                    uint64_t result = dyld3::MachOFile::read_uleb128((vm_address_t *)v4, v76, v72, v50);
                    if (uleb128)
                    {
                      uint64_t v71 = result + v24;
                      unsigned int v51 = 1;
                      uint64_t v52 = v21;
                      uint64_t v53 = v20;
                      uint64_t v54 = v22;
                      uint64_t v55 = v52;
                      int v56 = v70;
                      int v57 = v25;
                      uint64_t v58 = v69;
                      do
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, uint64_t *, uint64_t, uint64_t, void, uint64_t, _DWORD, char *))(v58 + 16))( v58,  v57,  v74,  v56,  v55 & 1,  v24,  v54,  v23,  v53,  &v73);
                        unint64_t v59 = v51++;
                        v23 += v71;
                        if (v73) {
                          BOOL v60 = 0;
                        }
                        else {
                          BOOL v60 = uleb128 > v59;
                        }
                      }

                      while (v60);
                      __int128 v4 = v68;
                      uint64_t v61 = v55;
                      uint64_t v22 = v54;
                      uint64_t v20 = v53;
                      uint64_t v21 = v61;
                      uint64_t v25 = v57;
                    }
                  }

                  goto LABEL_47;
                default:
                  uint64_t result = Diagnostics::error((vm_address_t *)v4, "unknown rebase opcode 0x%02X", v28 & 0xF0);
LABEL_47:
                  if (v73) {
                    return result;
                  }
                  continue;
              }
            }
          }

          break;
        }
      }

      else if (v74[2])
      {
        return dyld3::MachOFile::isFileSet(a1);
      }
    }
  }

  return result;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  v13[0] = 0LL;
  v13[1] = v13;
  uint64_t v13[2] = 0x2000000000LL;
  char v14 = 0;
  v12[0] = 0LL;
  v12[1] = v12;
  v12[2] = 0x2000000000LL;
  void v12[3] = 0LL;
  v11[0] = 0LL;
  v11[1] = v11;
  __int128 v11[2] = 0x2000000000LL;
  void v11[3] = 0LL;
  v10[0] = 0LL;
  v10[1] = v10;
  _DWORD v10[2] = 0x2000000000LL;
  void v10[3] = 0LL;
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  void v9[3] = 0LL;
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  void v8[3] = 0LL;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke;
  void v7[3] = &unk_189622308;
  v7[4] = v11;
  void v7[5] = v10;
  void v7[6] = v9;
  void v7[7] = v8;
  dyld3::MachOFile::forEachSection(a1, (uint64_t)v7);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2;
  void v6[3] = &unk_189622330;
  void v6[6] = v12;
  void v6[7] = v11;
  void v6[8] = v10;
  void v6[9] = v9;
  v6[10] = v8;
  v6[11] = a1;
  v6[4] = a3;
  void v6[5] = v13;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v6);
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v13, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke( uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(a2 + 92) == 7)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(a2 + 64);
    uint64_t v4 = *(void *)(a2 + 72) + *(void *)(a2 + 64);
    uint64_t v5 = *(void *)(result + 40);
LABEL_3:
    *(void *)(*(void *)(v5 + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v4;
    return result;
  }

  if ((*(_DWORD *)(a2 + 92) & 0x80000000) != 0)
  {
    uint64_t result = _platform_strcmp(*(const char **)(a2 + 80), "__stub_helper");
    if (!(_DWORD)result)
    {
      *(void *)(*(void *)(*(void *)(v3 + 48) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(void *)(a2 + 64);
      uint64_t v4 = *(void *)(a2 + 72) + *(void *)(a2 + 64);
      uint64_t v5 = *(void *)(v3 + 56);
      goto LABEL_3;
    }
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsU13block_pointerFvybRbE_block_invoke_2( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, unsigned int a9)
{
  if (a9 > 4 || ((1 << a9) & 0x19) == 0)
  {
    char v14 = (void *)result;
    uint64_t v15 = *(dyld3::MachOAnalyzer **)(result + 88);
    if (*(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL)) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = a7 == 0;
    }
    if (!v16)
    {
      uint64_t v17 = a7;
      uint64_t v18 = (const char **)(a4 + 40);
      while (_platform_strcmp(*v18, "__TEXT"))
      {
        v18 += 8;
        if (!--v17) {
          goto LABEL_15;
        }
      }

      *(void *)(*(void *)(v14[6] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(v18 - 3);
      *(_BYTE *)(*(void *)(v14[5] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    }

BOOL dyld3::MachOAnalyzer::contentIsRegularStub(dyld3::MachOAnalyzer *this, const unsigned __int8 *a2)
{
  BOOL result = 0LL;
  int v4 = *((_DWORD *)this + 1);
  if (v4 > 16777222)
  {
    if (v4 == 16777228)
    {
      if (*a2 == 80 && !a2[1] && !a2[2])
      {
        int v5 = 24;
        goto LABEL_20;
      }

      return 0LL;
    }

    if (v4 != 16777223) {
      return result;
    }
    if (*a2 != 104) {
      return 0LL;
    }
    int v5 = 233;
    uint64_t v6 = 5LL;
  }

  else
  {
    if (v4 != 7)
    {
      if (v4 != 12) {
        return result;
      }
      if (!*a2 && a2[1] == 192 && a2[2] == 159)
      {
        int v5 = 229;
LABEL_20:
        uint64_t v6 = 3LL;
        return a2[v6] == v5;
      }

      return 0LL;
    }

    if (*a2 != 104 || a2[5] != 255) {
      return 0LL;
    }
    int v5 = 38;
    uint64_t v6 = 2LL;
  }

  return a2[v6] == v5;
}

void dyld3::MachOAnalyzer::forEachRebase(dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke;
  void v4[3] = &unk_189622358;
  char v5 = a3;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachRebase(a1, a2, (uint64_t)v4);
}

uint64_t ___ZNK5dyld313MachOAnalyzer13forEachRebaseER11DiagnosticsbU13block_pointerFvyRbE_block_invoke( uint64_t result, uint64_t a2, int a3)
{
  if (!a3 || !*(_BYTE *)(result + 40)) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
  }
  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v95 = dyld3::MachOFile::pointerSize(a1);
  char v98 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v96);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v9, v10, v11, v12, v13, v14, v15, v80);
    v99[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v99[1] = (const unsigned __int8 **)0x40000000;
    v99[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v99[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    uint64_t v94 = (const unsigned __int8 **)(&v80 - 8 * v16);
    v99[4] = v94;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v99);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::dependentDylibCount(a1, 0LL);
      unsigned int v93 = result;
      if (v96[0])
      {
        uint64_t v86 = &v80;
        uint64_t v84 = a4;
        int v17 = *(_DWORD *)(v96[0] + 16LL);
        uint64_t v85 = v97;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)v97,  v17);
        v99[0] = LinkEditContent;
        if (!v98)
        {
          uint64_t v55 = 0LL;
          uint64_t v56 = 0LL;
          LODWORD(v89) = 0;
          uint64_t v87 = 0LL;
          uint64_t uleb128 = 0LL;
          LODWORD(v9dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
          LODWORD(v88) = 0;
          uint64_t sleb128 = 0LL;
          LODWORD(v92) = 0;
          uint64_t v58 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v96[0] + 20LL));
          uint64_t v59 = v95;
          while (2)
          {
            if (Diagnostics::noError((Diagnostics *)a2))
            {
              uint64_t v61 = v99[0];
              if (v99[0] < v58)
              {
                int v62 = (unsigned __int8 *)v99[0] + 1;
                unsigned int v63 = *(unsigned __int8 *)v99[0]++;
                uint64_t v64 = v63 & 0xF;
                switch(v63 >> 4)
                {
                  case 0u:
                    char v98 = 1;
                    goto LABEL_82;
                  case 1u:
                    LODWORD(v92) = 1;
                    uint64_t uleb128 = v63 & 0xF;
                    goto LABEL_82;
                  case 2u:
                    uint64_t uleb128 = dyld3::MachOFile::read_uleb128(a2, v99, v58, v60);
                    goto LABEL_70;
                  case 3u:
                    if ((v63 & 0xF) != 0) {
                      uint64_t uleb128 = v63 | 0xFFFFFFF0;
                    }
                    else {
                      uint64_t uleb128 = 0LL;
                    }
LABEL_70:
                    LODWORD(v92) = 1;
                    goto LABEL_82;
                  case 4u:
                    if (*v62)
                    {
                      unint64_t v65 = (const unsigned __int8 **)((char *)v61 + 2);
                      do
                      {
                        v99[0] = v65;
                        int v66 = *(unsigned __int8 *)v65;
                        unint64_t v65 = (const unsigned __int8 **)((char *)v65 + 1);
                      }

                      while (v66);
                      uint64_t v61 = (const unsigned __int8 **)((char *)v65 - 2);
                    }

                    LODWORD(v88) = v63 & 1;
                    v99[0] = (const unsigned __int8 **)((char *)v61 + 2);
                    uint64_t v87 = v62;
                    goto LABEL_82;
                  case 5u:
                    goto LABEL_83;
                  case 6u:
                    uint64_t sleb128 = dyld3::MachOFile::read_sleb128(a2, v99, v58, v60);
                    goto LABEL_82;
                  case 7u:
                    uint64_t v56 = dyld3::MachOFile::read_uleb128(a2, v99, v58, v60);
                    LODWORD(v9dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
                    LODWORD(v89) = v64;
                    goto LABEL_82;
                  case 8u:
                    v56 += dyld3::MachOFile::read_uleb128(a2, v99, v58, v60);
                    goto LABEL_82;
                  case 9u:
                    LOWORD(v79) = v88 & 1;
                    LOBYTE(v78) = v55;
                    BYTE4(v77) = (_BYTE)v89;
                    LODWORD(v77) = v95;
                    (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  v96,  v94,  v90 & 1,  v92 & 1,  v93,  uleb128,  v77,  v56,  v78,  v87,  v79,  sleb128,  &v98);
                    v56 += v59;
                    goto LABEL_82;
                  case 0xAu:
                    LOWORD(v79) = v88 & 1;
                    LOBYTE(v78) = v55;
                    BYTE4(v77) = (_BYTE)v89;
                    LODWORD(v77) = v95;
                    (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  v96,  v94,  v90 & 1,  v92 & 1,  v93,  uleb128,  v77,  v56,  v78,  v87,  v79,  sleb128,  &v98);
                    v56 += v59 + dyld3::MachOFile::read_uleb128(a2, v99, v58, v67);
                    goto LABEL_82;
                  case 0xBu:
                    LOWORD(v79) = v88 & 1;
                    LOBYTE(v78) = v55;
                    BYTE4(v77) = (_BYTE)v89;
                    uint64_t v68 = v59;
                    unsigned int v69 = v95;
                    LODWORD(v77) = v95;
                    (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  v96,  v94,  v90 & 1,  v92 & 1,  v93,  uleb128,  v77,  v56,  v78,  v87,  v79,  sleb128,  &v98);
                    uint64_t v70 = v69 + v69 * (_DWORD)v64;
                    uint64_t v59 = v68;
                    v56 += v70;
                    goto LABEL_82;
                  case 0xCu:
                    uint64_t v83 = uleb128;
                    unint64_t v71 = dyld3::MachOFile::read_uleb128(a2, v99, v58, v60);
                    uint64_t v73 = dyld3::MachOFile::read_uleb128(a2, v99, v58, v72);
                    if (v71)
                    {
                      uint64_t v82 = v58;
                      uint64_t v81 = v59;
                      uint64_t v74 = v73 + v59;
                      unsigned int v75 = 1;
                      uint64_t uleb128 = v83;
                      do
                      {
                        LOWORD(v79) = v88 & 1;
                        LOBYTE(v78) = v55;
                        BYTE4(v77) = (_BYTE)v89;
                        LODWORD(v77) = v95;
                        (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  v96,  v94,  v90 & 1,  v92 & 1,  v93,  uleb128,  v77,  v56,  v78,  v87,  v79,  sleb128,  &v98);
                        v56 += v74;
                        if (v98) {
                          break;
                        }
                        unint64_t v76 = v75++;
                      }

                      while (v71 > v76);
                      uint64_t v64 = v55;
                      uint64_t v58 = v82;
                      uint64_t v59 = v81;
                    }

                    else
                    {
                      uint64_t v64 = v55;
                      uint64_t uleb128 = v83;
                    }

                    goto LABEL_83;
                  default:
                    Diagnostics::error(a2, "bad bind opcode 0x%02X", *v62);
LABEL_82:
                    uint64_t v64 = v55;
LABEL_83:
                    uint64_t v55 = v64;
                    if (v98) {
                      break;
                    }
                    continue;
                }
              }
            }

            break;
          }
        }

        uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
        if ((result & 1) == 0)
        {
          if (*(_DWORD *)(v96[0] + 36LL))
          {
            unint64_t v19 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)v85,  *(_DWORD *)(v96[0] + 32LL));
            uint64_t v20 = 0LL;
            LODWORD(v9dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
            uint64_t v21 = 0LL;
            uint64_t v22 = 0LL;
            LODWORD(sleb128) = 0;
            LODWORD(v89) = 0;
            uint64_t v92 = 0LL;
            char v23 = 0;
            v99[0] = v19;
            uint64_t v24 = (const unsigned __int8 **)((char *)v19 + *(unsigned int *)(v96[0] + 36LL));
            char v98 = 0;
            uint64_t v88 = v95;
            do
            {
              if (!Diagnostics::noError((Diagnostics *)a2)) {
                break;
              }
              unsigned int v26 = v99[0];
              if (v99[0] >= v24) {
                break;
              }
              int v27 = (char *)v99[0] + 1;
              unsigned __int8 v28 = *(_BYTE *)v99[0]++;
              int v29 = v28 & 0xF;
              switch(v28 >> 4)
              {
                case 0:
                  break;
                case 1:
                  char v23 = 1;
                  uint64_t v22 = v28 & 0xF;
                  break;
                case 2:
                  uint64_t v22 = dyld3::MachOFile::read_uleb128(a2, v99, v24, v25);
                  goto LABEL_16;
                case 3:
                  if ((v28 & 0xF) != 0) {
                    uint64_t v22 = *(_DWORD *)&v28 | 0xFFFFFFF0;
                  }
                  else {
                    uint64_t v22 = 0LL;
                  }
LABEL_16:
                  char v23 = 1;
                  break;
                case 4:
                  if (*v27)
                  {
                    unsigned int v30 = (const unsigned __int8 **)((char *)v26 + 2);
                    do
                    {
                      v99[0] = v30;
                      int v31 = *(unsigned __int8 *)v30;
                      unsigned int v30 = (const unsigned __int8 **)((char *)v30 + 1);
                    }

                    while (v31);
                    unsigned int v26 = (const unsigned __int8 **)((char *)v30 - 2);
                  }

                  LODWORD(v89) = v28 & 1;
                  v99[0] = (const unsigned __int8 **)((char *)v26 + 2);
                  uint64_t v21 = v27;
                  break;
                case 6:
                  uint64_t v92 = dyld3::MachOFile::read_sleb128(a2, v99, v24, v25);
                  break;
                case 7:
                  uint64_t v20 = dyld3::MachOFile::read_uleb128(a2, v99, v24, v25);
                  LODWORD(sleb128) = 1;
                  LODWORD(v9dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v29;
                  break;
                case 9:
                  BYTE1(v79) = 1;
                  LOBYTE(v79) = v89 & 1;
                  LOBYTE(v78) = 1;
                  BYTE4(v77) = v90;
                  LODWORD(v77) = v95;
                  (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  v96,  v94,  sleb128 & 1,  v23 & 1,  v93,  v22,  v77,  v20,  v78,  v21,  v79,  v92,  &v98);
                  v20 += v88;
                  break;
                default:
                  Diagnostics::error(a2, "bad lazy bind opcode 0x%02X", v28 & 0xF0);
                  break;
              }
            }

            while (!v98);
          }

          uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
          if ((result & 1) == 0 && *(_DWORD *)(v96[0] + 28LL))
          {
            uint64_t v32 = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)v85,  *(_DWORD *)(v96[0] + 24LL));
            uint64_t v33 = 0LL;
            char v34 = 0;
            uint64_t v35 = 0LL;
            LODWORD(sleb128) = 0;
            char v36 = 0;
            uint64_t v92 = 0LL;
            v99[0] = v32;
            unint64_t v37 = (const unsigned __int8 **)((char *)v32 + *(unsigned int *)(v96[0] + 28LL));
            char v98 = 0;
            uint64_t v90 = v95;
            uint64_t v38 = 1LL;
            do
            {
              uint64_t result = Diagnostics::noError((Diagnostics *)a2);
              if (!(_DWORD)result) {
                break;
              }
              uint64_t v40 = v99[0];
              if (v99[0] >= v37) {
                break;
              }
              uint64_t v42 = (unsigned __int8 *)v99[0] + 1;
              unsigned int v41 = *(unsigned __int8 *)v99[0]++;
              uint64_t v43 = v41 & 0xF;
              switch(v41 >> 4)
              {
                case 0u:
                  char v98 = 1;
                  goto LABEL_50;
                case 1u:
                case 2u:
                case 3u:
                  uint64_t result = Diagnostics::error(a2, "unexpected dylib ordinal in weak_bind");
                  goto LABEL_50;
                case 4u:
                  if (*v42)
                  {
                    uint64_t v44 = (const unsigned __int8 **)((char *)v40 + 2);
                    do
                    {
                      v99[0] = v44;
                      int v45 = *(unsigned __int8 *)v44;
                      uint64_t v44 = (const unsigned __int8 **)((char *)v44 + 1);
                    }

                    while (v45);
                    uint64_t v40 = (const unsigned __int8 **)((char *)v44 - 2);
                  }

                  char v36 = v41 & 1;
                  v99[0] = (const unsigned __int8 **)((char *)v40 + 2);
                  uint64_t v35 = v42;
                  goto LABEL_50;
                case 5u:
                  break;
                case 6u:
                  uint64_t result = dyld3::MachOFile::read_sleb128(a2, v99, v37, v39);
                  uint64_t v92 = result;
                  goto LABEL_50;
                case 7u:
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v99, v37, v39);
                  uint64_t v33 = result;
                  LODWORD(sleb128) = 1;
                  char v34 = v43;
                  goto LABEL_50;
                case 8u:
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v99, v37, v39);
                  v33 += result;
                  goto LABEL_50;
                case 9u:
                  LOWORD(v79) = v36 & 1;
                  LOBYTE(v78) = v38;
                  BYTE4(v77) = v34;
                  LODWORD(v77) = v95;
                  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND",  v96,  v94,  sleb128 & 1,  1LL,  v93,  4294967293LL,  v77,  v33,  v78,  v35,  v79,  v92,  &v98);
                  uint64_t v46 = v90;
                  goto LABEL_49;
                case 0xAu:
                  LOWORD(v79) = v36 & 1;
                  LOBYTE(v78) = v38;
                  BYTE4(v77) = v34;
                  LODWORD(v77) = v95;
                  (*(void (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  v96,  v94,  sleb128 & 1,  1LL,  v93,  4294967293LL,  v77,  v33,  v78,  v35,  v79,  v92,  &v98);
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v99, v37, v47);
                  v33 += v90 + result;
                  goto LABEL_50;
                case 0xBu:
                  LOWORD(v79) = v36 & 1;
                  LOBYTE(v78) = v38;
                  BYTE4(v77) = v34;
                  int v48 = v37;
                  unsigned int v49 = v95;
                  LODWORD(v77) = v95;
                  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  v96,  v94,  sleb128 & 1,  1LL,  v93,  4294967293LL,  v77,  v33,  v78,  v35,  v79,  v92,  &v98);
                  uint64_t v46 = v49 + v49 * (_DWORD)v43;
                  unint64_t v37 = v48;
LABEL_49:
                  v33 += v46;
                  goto LABEL_50;
                case 0xCu:
                  unint64_t v50 = dyld3::MachOFile::read_uleb128(a2, v99, v37, v39);
                  uint64_t result = dyld3::MachOFile::read_uleb128(a2, v99, v37, v51);
                  if (!v50) {
                    goto LABEL_50;
                  }
                  unint64_t v89 = v37;
                  uint64_t v52 = result + v90;
                  unsigned int v53 = 1;
                  do
                  {
                    LOWORD(v79) = v36 & 1;
                    LOBYTE(v78) = v38;
                    BYTE4(v77) = v34;
                    LODWORD(v77) = v95;
                    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void *, const unsigned __int8 **, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, char *))(a3 + 16))( a3,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  v96,  v94,  sleb128 & 1,  1LL,  v93,  4294967293LL,  v77,  v33,  v78,  v35,  v79,  v92,  &v98);
                    v33 += v52;
                    if (v98) {
                      break;
                    }
                    unint64_t v54 = v53++;
                  }

                  while (v50 > v54);
                  uint64_t v43 = v38;
                  unint64_t v37 = v89;
                  break;
                default:
                  uint64_t result = Diagnostics::error(a2, "bad bind opcode 0x%02X", *v42);
LABEL_50:
                  uint64_t v43 = v38;
                  break;
              }

              uint64_t v38 = v43;
            }

            while (!v98);
          }
        }
      }
    }
  }

  return result;
}

void dyld3::MachOAnalyzer::forEachBind(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  char v8 = 0;
  v6[0] = 0LL;
  v6[1] = v6;
  void v6[2] = 0x2000000000LL;
  void v6[3] = 0LL;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke;
  void v5[3] = &unk_189622380;
  void v5[5] = v7;
  void v5[6] = v6;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2;
  void v4[3] = &unk_1896223A8;
  v4[4] = a4;
  dyld3::MachOAnalyzer::forEachBind(a1, a2, (uint64_t)v5, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(v7, 8);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned __int8 a10)
{
  if (!*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL))
  {
    uint64_t v11 = (const char **)(a4 + 40);
    uint64_t v12 = a10 + 1LL;
    while (_platform_strcmp(*v11, "__TEXT"))
    {
      v11 += 8;
      if (!--v12) {
        return (*(uint64_t (**)(void))(a1[4] + 16LL))(a1[4]);
      }
    }

    *(void *)(*(void *)(a1[6] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(v11 - 3);
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  return (*(uint64_t (**)(void))(a1[4] + 16LL))(a1[4]);
}

uint64_t ___ZNK5dyld313MachOAnalyzer11forEachBindER11DiagnosticsU13block_pointerFvyihPKcbbyRbEU13block_pointerFvS4_E_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v44 = 0;
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)v42);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v11, v12, v13, v14, v15, v16, v17, v33);
    unint64_t v19 = (const unsigned __int8 **)(&v33 - 8 * v18);
    v45[0] = (const unsigned __int8 **)_NSConcreteStackBlock;
    v45[1] = (const unsigned __int8 **)0x40000000;
    void v45[2] = (const unsigned __int8 **)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    v45[3] = (const unsigned __int8 **)&__block_descriptor_tmp_58_0;
    v45[4] = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v45);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      uint64_t result = dyld3::MachOFile::dependentDylibCount(a1, 0LL);
      if (v42[0])
      {
        HIDWORD(v33) = result;
        LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)&v43,  *(_DWORD *)(v42[0] + 16LL));
        uint64_t v21 = 0LL;
        uint64_t v36 = 0LL;
        int v38 = 0;
        uint64_t sleb128 = 0LL;
        int v34 = 0;
        int v41 = 0;
        int v35 = 0;
        uint64_t uleb128 = 0LL;
        unint64_t v37 = 0LL;
        v45[0] = LinkEditContent;
        uint64_t v22 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(v42[0] + 20LL));
        while (2)
        {
          if (Diagnostics::noError((Diagnostics *)a2))
          {
            uint64_t v24 = v45[0];
            if (v45[0] < v22)
            {
              uint64_t v25 = (char *)v45[0] + 1;
              unsigned int v26 = *(unsigned __int8 *)v45[0];
              uint64_t v27 = v26 & 0xF;
              ++v45[0];
              switch(v26 >> 4)
              {
                case 0u:
                  goto LABEL_8;
                case 1u:
                  int v41 = 1;
                  uint64_t uleb128 = v26 & 0xF;
                  goto LABEL_33;
                case 2u:
                  uint64_t uleb128 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                  goto LABEL_15;
                case 3u:
                  LODWORD(v28) = v26 | 0xFFFFFFF0;
                  if ((v26 & 0xF) != 0) {
                    uint64_t v28 = v28;
                  }
                  else {
                    uint64_t v28 = 0LL;
                  }
                  uint64_t uleb128 = v28;
LABEL_15:
                  int v41 = 1;
                  goto LABEL_33;
                case 4u:
                  if (*v25)
                  {
                    int v29 = (const unsigned __int8 **)((char *)v24 + 2);
                    do
                    {
                      v45[0] = v29;
                      int v30 = *(unsigned __int8 *)v29;
                      int v29 = (const unsigned __int8 **)((char *)v29 + 1);
                    }

                    while (v30);
                    uint64_t v24 = (const unsigned __int8 **)((char *)v29 - 2);
                  }

                  int v38 = v26 & 1;
                  v45[0] = (const unsigned __int8 **)((char *)v24 + 2);
                  unint64_t v37 = v25;
                  goto LABEL_33;
                case 5u:
                  goto LABEL_34;
                case 6u:
                  uint64_t sleb128 = dyld3::MachOFile::read_sleb128(a2, v45, v22, v23);
                  goto LABEL_33;
                case 7u:
                  uint64_t v36 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                  int v35 = 1;
                  int v34 = v27;
                  goto LABEL_33;
                case 9u:
                  if (a4)
                  {
                    LOBYTE(v32) = v38 & 1;
                    (*(void (**)(uint64_t, void *, const unsigned __int8 **, void, void, uint64_t, void, _BYTE *, uint64_t, int, char *))(a4 + 16))( a4,  v42,  v19,  v41 & 1,  HIDWORD(v33),  uleb128,  v21,  v37,  sleb128,  v32,  &v44);
                  }

                  goto LABEL_33;
                case 0xDu:
                  if ((_DWORD)v27 == 1)
                  {
                    if (a5) {
                      (*(void (**)(uint64_t, void *, const unsigned __int8 **, void, void, uint64_t, uint64_t, char *))(a5 + 16))( a5,  v42,  v19,  v34,  v35 & 1,  v36,  1LL,  &v44);
                    }
                  }

                  else if ((v26 & 0xF) != 0)
                  {
                    Diagnostics::error(a2, "bad BIND_OPCODE_THREADED sub-opcode 0x%02X");
                  }

                  else
                  {
                    unint64_t v31 = dyld3::MachOFile::read_uleb128(a2, v45, v22, v23);
                    if (v31 < 0x10000)
                    {
                      if (a3) {
                        (*(void (**)(uint64_t, unint64_t, char *))(a3 + 16))(a3, v31, &v44);
                      }
                    }

                    else
                    {
                      Diagnostics::error(a2, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size too large");
LABEL_8:
                      char v44 = 1;
                    }
                  }

                  goto LABEL_33;
                default:
                  Diagnostics::error(a2, "bad bind opcode 0x%02X");
LABEL_33:
                  uint64_t v27 = v21;
LABEL_34:
                  uint64_t v21 = v27;
                  if (v44) {
                    return Diagnostics::hasError((Diagnostics *)a2);
                  }
                  continue;
              }
            }
          }

          return Diagnostics::hasError((Diagnostics *)a2);
        }
      }
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachChainedFixupTarget(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    __chkstk_darwin(result, v7, v8, v9, v10, v11, v12, v13, v16);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000LL;
    _OWORD v21[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    void v21[3] = &__block_descriptor_tmp_58_0;
    void v21[4] = &v17[-8 * v14 - 1];
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)v21);
    uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
    if ((result & 1) == 0)
    {
      if (v18)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 0x40000000LL;
        v17[2] = ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke;
        void v17[3] = &unk_1896223D0;
        v17[4] = a3;
        return dyld3::MachOAnalyzer::parseOrgArm64eChainedFixups(a1, a2, 0LL, (uint64_t)v17, 0LL);
      }

      else if (v19)
      {
        LinkEditContent = (unsigned int *)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  (uint64_t)&v20,  *(_DWORD *)(v19 + 8));
        return (uint64_t)dyld3::MachOFile::forEachChainedFixupTarget(a2, LinkEditContent, v19, a3);
      }
    }
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachChainedFixupTargetER11DiagnosticsU13block_pointerFviPKcybRbE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v6 = a2;
  if (*(_BYTE *)(a1 + 18))
  {
    if (a2) {
      return a2 - *(void *)(a1 + 8);
    }
  }

  else if (*(_WORD *)(a1 + 16) && a2)
  {
    if ((mach_o::ChainedFixupPointerOnDisk::isRebase( (mach_o::ChainedFixupPointerOnDisk *)&v6,  *(unsigned __int16 *)(a1 + 16),  *(void *)a1,  &v5) & 1) != 0) {
      return v5 + *(void *)a1;
    }
    else {
      return v6;
    }
  }

  return v2;
}

uint64_t dyld3::MachOAnalyzer::makeVMAddrConverter@<X0>( dyld3::MachOAnalyzer *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = dyld3::MachOFile::preferredLoadAddress(this);
  *(void *)(a3 + 8) = dyld3::MachOLoaded::getSlide(this);
  uint64_t result = dyld3::MachOFile::hasChainedFixups(this);
  if ((_DWORD)result) {
    uint64_t result = dyld3::MachOAnalyzer::chainedPointerFormat(this);
  }
  *(_WORD *)(a3 + 16) = result;
  *(_BYTE *)(a3 + 18) = a2;
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedPointerFormat(dyld3::MachOAnalyzer *this)
{
  uint64_t v2 = (dyld3::MachOFile *)dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (v2) {
    return dyld3::MachOFile::chainedPointerFormat(v2, v3);
  }
  return 1LL;
}

void dyld3::MachOAnalyzer::forEachInitializer( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x6802000000LL;
  uint64_t v18 = __Block_byref_object_copy__13;
  uint64_t v19 = __Block_byref_object_dispose__13;
  v20[3] = v20;
  v20[4] = 1LL;
  vm_size_t v23 = 0LL;
  uint64_t v21 = 0LL;
  vm_address_t v22 = 0LL;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  _WORD v14[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke;
  uint64_t v14[3] = &unk_1896223F8;
  _OWORD v14[4] = &v15;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v14);
  if (v16[10])
  {
    uint64_t Address = dyld3::MachOFile::preferredLoadAddress(a1);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    uint64_t v13[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2;
    void v13[3] = &unk_189622420;
    uint64_t v13[4] = a4;
    void v13[5] = &v15;
    void v13[6] = Address;
    void v13[7] = a2;
    dyld3::MachOFile::forEachLoadCommand(a1, a2, (uint64_t)v13);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    __int128 v11[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3;
    void v11[3] = &unk_189622448;
    int v12 = dyld3::MachOFile::pointerSize(a1);
    void v11[6] = a1;
    void v11[7] = a3;
    void v11[4] = a4;
    v11[5] = &v15;
    unsigned int v11[8] = a2;
    v11[9] = Address;
    dyld3::MachOFile::forEachInitializerPointerSection(a1, (uint64_t)a2, (uint64_t)v11);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000LL;
    _DWORD v10[2] = ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4;
    void v10[3] = &unk_189622470;
    void v10[6] = Slide;
    void v10[7] = a2;
    void v10[8] = Address;
    void v10[4] = a4;
    v10[5] = &v15;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }

  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }

  _Block_object_dispose(&v15, 8);
  uint64_t v21 = 0LL;
  if (v22) {
    vm_deallocate(mach_task_self_, v22, v23);
  }
}

double __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v2;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  uint64_t v4 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v4;
  *(void *)(a2 + 96) = 0LL;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0u;
  return result;
}

void *__Block_byref_object_dispose__13(void *result)
{
  result[10] = 0LL;
  vm_address_t v1 = result[11];
  if (v1) {
    return (void *)vm_deallocate(mach_task_self_, v1, result[12]);
  }
  return result;
}

void *___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke( void *result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 52) & 4) != 0)
  {
    uint64_t v2 = *(void *)(result[4] + 8LL);
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 24) + v3;
    double result = dyld3::OverflowSafeArray<dyld3::SegmentRanges::SegmentRange,4294967295ull>::verifySpace( (void *)(v2 + 64),  1LL);
    uint64_t v6 = *(void *)(v2 + 64);
    uint64_t v7 = *(void *)(v2 + 80);
    *(void *)(v2 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v7 + 1;
    uint64_t v8 = v6 + 24 * v7;
    *(void *)uint64_t v8 = v3;
    *(void *)(v8 + 8) = v5;
    *(_DWORD *)(v8 + 16) = v4;
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_2( uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)a2 == 26)
  {
    uint64_t v8 = *(void *)(*(void *)(result + 40) + 8LL);
    uint64_t v9 = *(void *)(v8 + 80);
    if (v9)
    {
      unint64_t v4 = *(void *)(a2 + 8);
      uint64_t v10 = *(void *)(v8 + 64);
      uint64_t v11 = 24 * v9;
      for (uint64_t i = (unint64_t *)(v10 + 8); *(i - 1) > v4 || *i <= v4; i += 3)
      {
        v11 -= 24LL;
        if (!v11) {
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
        }
      }

      return (*(uint64_t (**)(void, void))(*(void *)(result + 32) + 16LL))( *(void *)(result + 32),  (v4 - *(_DWORD *)(result + 48)));
    }

    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }

  if (*(_DWORD *)a2 == 17)
  {
    uint64_t v2 = *(void *)(*(void *)(result + 40) + 8LL);
    uint64_t v3 = *(void *)(v2 + 80);
    if (v3)
    {
      unint64_t v4 = *(unsigned int *)(a2 + 8);
      uint64_t v5 = *(void *)(v2 + 64);
      uint64_t v6 = 24 * v3;
      for (uint64_t j = (unint64_t *)(v5 + 8); *(j - 1) > v4 || *j <= v4; j += 3)
      {
        v6 -= 24LL;
        if (!v6) {
          return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
        }
      }

      return (*(uint64_t (**)(void, void))(*(void *)(result + 32) + 16LL))( *(void *)(result + 32),  (v4 - *(_DWORD *)(result + 48)));
    }

    return Diagnostics::error(*(vm_address_t **)(result + 56), "-init does not point within __TEXT segment");
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_3( uint64_t result, unsigned int a2, unsigned int a3, _BYTE *a4)
{
  uint64_t v5 = result;
  uint64_t v6 = (uint64_t *)(*(void *)(result + 48) + a2);
  uint64_t v7 = (uint64_t *)((char *)v6 + a3);
  if (*(_DWORD *)(result + 80) == 8)
  {
    if (!a3) {
      return result;
    }
    while (1)
    {
      unint64_t v8 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 56), *v6);
      uint64_t v9 = *(void *)(*(void *)(v5 + 40) + 8LL);
      uint64_t v10 = *(void *)(v9 + 80);
      if (!v10) {
        break;
      }
      uint64_t v11 = *(void *)(v9 + 64);
      uint64_t v12 = 24 * v10;
      uint64_t v13 = (unint64_t *)(v11 + 8);
      while (*(v13 - 1) > v8 || *v13 <= v8)
      {
        v13 += 3;
        v12 -= 24LL;
        if (!v12) {
          goto LABEL_20;
        }
      }

      double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16LL))( *(void *)(v5 + 32),  (v8 - *(_DWORD *)(v5 + 72)));
      if (++v6 >= v7) {
        return result;
      }
    }

uint64_t ___ZNK5dyld313MachOAnalyzer18forEachInitializerER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjEPKv_block_invoke_4( uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (*(_BYTE *)(a2 + 92) == 22)
  {
    uint64_t v5 = result;
    if ((*(_BYTE *)(a2 + 52) & 2) != 0)
    {
      double result = Diagnostics::error( *(vm_address_t **)(result + 56),  "initializer offsets section %s/%s must be in read-only segment");
      goto LABEL_6;
    }

    uint64_t v6 = *(void *)(a2 + 72);
    if ((v6 & 3) != 0)
    {
      double result = Diagnostics::error(*(vm_address_t **)(result + 56), "initializer offsets section %s/%s has bad size");
LABEL_6:
      *a4 = 1;
      return result;
    }

    if (a3)
    {
      double result = Diagnostics::error( *(vm_address_t **)(result + 56),  "initializer offsets section %s/%s extends beyond the end of the segment");
      goto LABEL_6;
    }

    uint64_t v7 = *(void *)(a2 + 64);
    if ((v7 & 3) != 0)
    {
      double result = Diagnostics::error( *(vm_address_t **)(result + 56),  "initializer offsets section %s/%s is not 4-byte aligned");
      goto LABEL_6;
    }

    if (v6 >= 1)
    {
      unint64_t v8 = (unsigned int *)(*(void *)(result + 48) + v7);
      uint64_t v9 = (unsigned int *)((char *)v8 + v6);
      while (1)
      {
        uint64_t v10 = *(void *)(*(void *)(v5 + 40) + 8LL);
        uint64_t v11 = *(void *)(v10 + 80);
        if (!v11) {
          break;
        }
        unint64_t v12 = *(void *)(v5 + 64) + *v8;
        uint64_t v13 = *(void *)(v10 + 64);
        uint64_t v14 = 24 * v11;
        uint64_t v15 = (unint64_t *)(v13 + 8);
        while (*(v15 - 1) > v12 || *v15 <= v12)
        {
          v15 += 3;
          v14 -= 24LL;
          if (!v14) {
            goto LABEL_22;
          }
        }

        double result = (*(uint64_t (**)(void))(*(void *)(v5 + 32) + 16LL))();
        if (++v8 >= v9) {
          return result;
        }
      }

void dyld3::MachOAnalyzer::forEachTerminator(dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x6802000000LL;
  uint64_t v16 = __Block_byref_object_copy__13;
  uint64_t v17 = __Block_byref_object_dispose__13;
  uint64_t v18[3] = v18;
  v18[4] = 1LL;
  vm_size_t size = 0LL;
  uint64_t v19 = 0LL;
  vm_address_t address = 0LL;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke;
  void v12[3] = &unk_189622498;
  void v12[4] = &v13;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v12);
  if (v14[10])
  {
    uint64_t v8 = dyld3::MachOFile::preferredLoadAddress(a1);
    uint64_t Slide = dyld3::MachOLoaded::getSlide(a1);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000LL;
    _DWORD v10[2] = ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2;
    void v10[3] = &unk_1896224C0;
    int v11 = dyld3::MachOFile::pointerSize(a1);
    void v10[6] = Slide;
    void v10[7] = a2;
    void v10[4] = a4;
    v10[5] = &v13;
    void v10[8] = a3;
    void v10[9] = v8;
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v10);
  }

  else
  {
    Diagnostics::error(a2, "no exeutable segments");
  }

  _Block_object_dispose(&v13, 8);
  uint64_t v19 = 0LL;
  if (address) {
    vm_deallocate(mach_task_self_, address, size);
  }
}

void *___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke( void *result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 52) & 4) != 0)
  {
    uint64_t v2 = *(void *)(result[4] + 8LL);
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 24) + v3;
    double result = dyld3::OverflowSafeArray<dyld3::SegmentRanges::SegmentRange,4294967295ull>::verifySpace( (void *)(v2 + 64),  1LL);
    uint64_t v6 = *(void *)(v2 + 64);
    uint64_t v7 = *(void *)(v2 + 80);
    *(void *)(v2 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v7 + 1;
    uint64_t v8 = v6 + 24 * v7;
    *(void *)uint64_t v8 = v3;
    *(void *)(v8 + 8) = v5;
    *(_DWORD *)(v8 + 16) = v4;
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer17forEachTerminatorER11DiagnosticsRKNS0_15VMAddrConverterEU13block_pointerFvjE_block_invoke_2( uint64_t result, uint64_t a2, int a3, _BYTE *a4)
{
  if (*(_BYTE *)(a2 + 92) == 10)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(a2 + 72);
    unint64_t v7 = *(unsigned int *)(result + 80);
    if (v6 % v7)
    {
      double result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s has bad size");
    }

    else if (a3)
    {
      double result = Diagnostics::error( *(vm_address_t **)(result + 56),  "terminator section %s/%s extends beyond its segment");
    }

    else
    {
      uint64_t v8 = *(void *)(result + 48) + *(void *)(a2 + 64);
      if (v8 % (uint64_t)v7)
      {
        double result = Diagnostics::error(*(vm_address_t **)(result + 56), "terminator section %s/%s is not pointer aligned");
      }

      else
      {
        uint64_t v9 = (char *)(v8 + v6);
        if ((_DWORD)v7 == 8)
        {
          if (v6 < 1) {
            return result;
          }
          while (1)
          {
            unint64_t v10 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 64), *(void *)v8);
            uint64_t v11 = *(void *)(*(void *)(v5 + 40) + 8LL);
            uint64_t v12 = *(void *)(v11 + 80);
            if (!v12) {
              break;
            }
            uint64_t v13 = *(void *)(v11 + 64);
            uint64_t v14 = 24 * v12;
            uint64_t v15 = (unint64_t *)(v13 + 8);
            while (*(v15 - 1) > v10 || *v15 <= v10)
            {
              v15 += 3;
              v14 -= 24LL;
              if (!v14) {
                goto LABEL_27;
              }
            }

            double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16LL))( *(void *)(v5 + 32),  (v10 - *(_DWORD *)(v5 + 72)));
            v8 += 8LL;
          }

LABEL_27:
          double result = Diagnostics::error( *(vm_address_t **)(v5 + 56),  "terminator 0x%0llX does not point within executable segment");
        }

        else
        {
          if (v6 < 1) {
            return result;
          }
          while (1)
          {
            unsigned int v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(*(void *)(v5 + 64), *(unsigned int *)v8);
            uint64_t v17 = *(void *)(*(void *)(v5 + 40) + 8LL);
            uint64_t v18 = *(void *)(v17 + 80);
            if (!v18) {
              break;
            }
            uint64_t v19 = *(void *)(v17 + 64);
            uint64_t v20 = 24 * v18;
            uint64_t v21 = (void *)(v19 + 8);
            while (*(v21 - 1) > (unint64_t)v16 || *v21 <= (unint64_t)v16)
            {
              v21 += 3;
              v20 -= 24LL;
              if (!v20) {
                goto LABEL_28;
              }
            }

            double result = (*(uint64_t (**)(void, void))(*(void *)(v5 + 32) + 16LL))( *(void *)(v5 + 32),  v16 - *(_DWORD *)(v5 + 72));
            v8 += 4LL;
          }

        mach_msg_destroy(&v29);
        return v21;
      }

      mig_dealloc_reply_port(v29.msgh_local_port);
    }
  }

  return v21;
}

    mach_msg_destroy(&v17);
  }

  return v10;
}

uint64_t dyld3::MachOAnalyzer::hasSwiftOrObjC(dyld3::MachOAnalyzer *this, BOOL *a2)
{
  if (a2) {
    *a2 = 0;
  }
  uint64_t v6 = 0LL;
  unint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke;
  void v5[3] = &unk_1896224E8;
  void v5[6] = a2;
  void v5[7] = dyld3::MachOLoaded::getSlide(this);
  v5[4] = &v6;
  void v5[5] = this;
  dyld3::MachOFile::forEachSection(this, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZNK5dyld313MachOAnalyzer14hasSwiftOrObjCEPb_block_invoke( void *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7 = a1[5];
  uint64_t v8 = *(const char **)(a2 + 80);
  uint64_t result = _platform_strcmp(v8, "__objc_imageinfo");
  if (!(_DWORD)result)
  {
    uint64_t result = _platform_strncmp(*(const char **)(a2 + 40), "__DATA", 6uLL);
    if (!(_DWORD)result)
    {
      unint64_t v10 = (_BYTE *)a1[6];
      if (v10 && *(_BYTE *)(a1[7] + *(void *)(a2 + 64) + 5LL)) {
        *unint64_t v10 = 1;
      }
      *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
      *a4 = 1;
    }
  }

  if (*(_DWORD *)(v7 + 4) == 7)
  {
    uint64_t result = _platform_strcmp(v8, "__image_info");
    if (!(_DWORD)result)
    {
      uint64_t result = _platform_strcmp(*(const char **)(a2 + 40), "__OBJC");
      if (!(_DWORD)result)
      {
        *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
        *a4 = 1;
      }
    }
  }

  return result;
}

BOOL dyld3::MachOAnalyzer::hasSwift(dyld3::MachOAnalyzer *this)
{
  BOOL v2 = 0;
  dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v2);
  return v2;
}

void dyld3::MachOAnalyzer::forEachCDHash(_DWORD *a1, uint64_t a2)
{
  if (!Diagnostics::hasError((Diagnostics *)&v8) && v6)
  {
    LinkEditContent = (_DWORD *)dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v7, *(_DWORD *)(v6 + 8));
    dyld3::MachOFile::forEachCDHashOfCodeSignature((uint64_t)a1, LinkEditContent, *(unsigned int *)(v6 + 12), a2);
  }

  mach_o::Error::~Error(&v8);
}

uint64_t dyld3::MachOAnalyzer::withChainStarts(char *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    return (*(uint64_t (**)(uint64_t, char *))(a4 + 16))(a4, &a1[a3]);
  }
  dyld3::MachOLoaded::getLinkEditPointers(a1, a2, (uint64_t)&v9);
  uint64_t result = Diagnostics::hasError((Diagnostics *)a2);
  if ((result & 1) == 0)
  {
    if (v10)
    {
      uint64_t LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)a1, (uint64_t)&v11, *(_DWORD *)(v10 + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))( a4,  LinkEditContent + *(unsigned int *)(LinkEditContent + 4));
    }

    else
    {
      return Diagnostics::error(a2, "image does not use chained fixups");
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::chainStartsOffset(dyld3::MachOAnalyzer *this)
{
  uint64_t result = dyld3::MachOAnalyzer::chainedFixupsHeader(this);
  if (result) {
    return result - (void)this + *(unsigned int *)(result + 4);
  }
  return result;
}

BOOL dyld3::MachOAnalyzer::neverUnload(dyld3::MachOAnalyzer *this)
{
  BOOL v10 = 0;
  if (dyld3::MachOAnalyzer::hasSwiftOrObjC(this, &v10) && (v10 || !dyld3::MachOFile::isBundle(this))
    || (dyld3::MachOFile::hasThreadLocalVariables(this) & 1) != 0)
  {
    return 1LL;
  }

  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  char v9 = 0;
  Diagnostics::Diagnostics((Diagnostics *)&v5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke;
  void v4[3] = &unk_189622510;
  v4[4] = &v6;
  dyld3::MachOFile::forEachDOFSection(this, (uint64_t)&v5, (uint64_t)v4);
  BOOL v2 = Diagnostics::noError((Diagnostics *)&v5) && *((_BYTE *)v7 + 24);
  mach_o::Error::~Error(&v5);
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t ___ZNK5dyld313MachOAnalyzer11neverUnloadEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t dyld3::MachOAnalyzer::chainedFixupsHeader(dyld3::MachOAnalyzer *this)
{
  uint64_t LinkEditContent = 0LL;
  if (!Diagnostics::hasError((Diagnostics *)&v7) && v5) {
    uint64_t LinkEditContent = dyld3::MachOLoaded::getLinkEditContent((uint64_t)this, (uint64_t)&v6, *(_DWORD *)(v5 + 8));
  }
  mach_o::Error::~Error(&v7);
  return LinkEditContent;
}

uint64_t dyld3::MachOAnalyzer::ObjCClassInfo::getReadOnlyDataField(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = a1 + 40;
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 48) + v4);
  if (a3 == 8)
  {
    switch(a2)
    {
      case 0:
        uint64_t v7 = *((void *)v6 + 3);
        goto LABEL_4;
      case 1:
        uint64_t v7 = *((void *)v6 + 5);
        goto LABEL_4;
      case 2:
        uint64_t v7 = *((void *)v6 + 4);
        goto LABEL_4;
      case 3:
        uint64_t v7 = *((void *)v6 + 8);
        goto LABEL_4;
      case 4:
        goto LABEL_7;
      default:
        return result;
    }
  }

  else
  {
    switch(a2)
    {
      case 0:
        uint64_t v7 = v6[4];
        goto LABEL_4;
      case 1:
        uint64_t v7 = v6[6];
        goto LABEL_4;
      case 2:
        uint64_t v7 = v6[5];
        goto LABEL_4;
      case 3:
        uint64_t v7 = v6[9];
LABEL_4:
        uint64_t result = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(result, v7);
        break;
      case 4:
LABEL_7:
        uint64_t result = *v6;
        break;
      default:
        return result;
    }
  }

  return result;
}

void dyld3::MachOAnalyzer::forEachObjCClass( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (dyld3::MachOFile::pointerSize(a1) == 8)
  {
    uint64_t v20 = 0LL;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x2000000000LL;
    char v23 = 0;
    if (a3)
    {
      uint64_t v10 = a3 - 1;
      do
      {
        uint64_t v11 = v10;
        uint64_t v12 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(void *)((char *)a1 + a2));
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 0x40000000LL;
        v19[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke;
        v19[3] = &unk_189622560;
        v19[6] = a5;
        v19[7] = v12;
        v19[4] = &v20;
        v19[5] = a1;
        void v19[8] = a4;
        memset(&v19[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v12, v13, (uint64_t)v19);
        if (*((_BYTE *)v21 + 24)) {
          break;
        }
        uint64_t v10 = v11 - 1;
        a2 += 8LL;
      }

      while (v11);
    }
  }

  else
  {
    uint64_t v20 = 0LL;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x2000000000LL;
    char v23 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *(unsigned int *)((char *)a1 + a2));
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000LL;
        v18[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3;
        uint64_t v18[3] = &unk_1896225B0;
        v18[6] = a5;
        v18[7] = v16;
        v18[4] = &v20;
        void v18[5] = a1;
        void v18[8] = a4;
        memset(&v18[9], 0, 24);
        dyld3::MachOAnalyzer::parseObjCClass(a1, a4, v16, v17, (uint64_t)v18);
        if (*((_BYTE *)v21 + 24)) {
          break;
        }
        uint64_t v14 = v15 - 1;
        a2 += 4LL;
      }

      while (v15);
    }
  }

  _Block_object_dispose(&v20, 8);
}

uint64_t dyld3::MachOAnalyzer::parseObjCClass( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = dyld3::MachOFile::pointerSize(a1);
  memset(v21, 0, sizeof(v21));
  uint64_t v10 = (unsigned int *)(dyld3::MachOLoaded::getSlide(a1) + a3);
  if (v9 != 8)
  {
    uint64_t v11 = a3 + 4;
    uint64_t v12 = a3 + 16;
    *(void *)uint64_t v21 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, *v10);
    *(void *)&void v21[8] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[1]);
    uint64_t v15 = v10[3];
    if ((_DWORD)v15) {
      uint64_t v16 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v15);
    }
    else {
      uint64_t v16 = 0LL;
    }
    *(void *)&v21[16] = v16;
    *(void *)&v21[24] = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a2, v10[4]) & 0xFFFFFFFCLL;
    *(_OWORD *)uint64_t v22 = *(_OWORD *)a2;
    *(_DWORD *)&v22[15] = *(_DWORD *)(a2 + 15);
    unsigned int v19 = v10[4];
    v21[36] = v19 & 1;
    v21[37] = (v19 & 2) != 0;
    if ((v19 & 3) != 0)
    {
      unsigned int v18 = v10[5];
      goto LABEL_13;
    }

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))();
  uint64_t v9 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(*(void *)(v9 + 8) + 24LL))
  {
    uint64_t v10 = *a4;
    uint64_t v11 = *(void *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000LL;
    v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2;
    void v12[3] = &unk_189622538;
    void v12[5] = *(void *)(a1 + 48);
    void v12[6] = v10;
    void v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 40)
                                                                                                + 16LL))( **(void **)(a1 + 40),  *(void *)(a1 + 48),  a2,  a3,  a4,  1LL,  *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(dyld3::MachOFile **)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))();
  uint64_t v9 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(*(void *)(v9 + 8) + 24LL))
  {
    uint64_t v10 = *a4;
    uint64_t v11 = *(void *)(a1 + 64);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000LL;
    v12[2] = ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4;
    void v12[3] = &unk_189622588;
    void v12[5] = *(void *)(a1 + 48);
    void v12[6] = v10;
    void v12[4] = v9;
    return dyld3::MachOAnalyzer::parseObjCClass(v6, v11, v10, v8, (uint64_t)v12);
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer16forEachObjCClassEyyRKNS0_15VMAddrConverterERU13block_pointerFvyyyRKNS0_13ObjCClassInfoEbRbE_block_invoke_4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 40)
                                                                                                + 16LL))( **(void **)(a1 + 40),  *(void *)(a1 + 48),  a2,  a3,  a4,  1LL,  *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

BOOL dyld3::MachOAnalyzer::isSwiftClass(dyld3::MachOAnalyzer *this, _BYTE *a2)
{
  else {
    char v3 = a2[16];
  }
  return (v3 & 3) != 0;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCCategory( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = dyld3::MachOFile::pointerSize(a1);
  uint64_t result = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v12 = result;
  uint64_t v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    char v28 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = *v13++;
        uint64_t v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16LL))();
        if (v28) {
          break;
        }
        uint64_t v14 = v15 - 1;
      }

      while (v15);
    }
  }

  else
  {
    char v28 = 0;
    if (a3)
    {
      uint64_t v18 = a3 - 1;
      do
      {
        uint64_t v19 = v18;
        unsigned int v20 = *(_DWORD *)v13;
        uint64_t v13 = (uint64_t *)((char *)v13 + 4);
        uint64_t v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16LL))();
        if (v28) {
          break;
        }
        uint64_t v18 = v19 - 1;
      }

      while (v19);
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachObjCProtocol( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = dyld3::MachOFile::pointerSize(a1);
  uint64_t result = dyld3::MachOLoaded::getSlide(a1);
  uint64_t v12 = result;
  uint64_t v13 = (uint64_t *)((char *)a1 + a2);
  if (v10 == 8)
  {
    char v29 = 0;
    if (a3)
    {
      uint64_t v14 = a3 - 1;
      do
      {
        uint64_t v15 = v14;
        uint64_t v16 = *v13++;
        uint64_t v17 = (uint64_t *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v16) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v17);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[5]);
        uint64_t v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v17[6]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16LL))();
        if (v29) {
          break;
        }
        uint64_t v14 = v15 - 1;
      }

      while (v15);
    }
  }

  else
  {
    char v29 = 0;
    if (a3)
    {
      uint64_t v18 = a3 - 1;
      do
      {
        uint64_t v19 = v18;
        unsigned int v20 = *(_DWORD *)v13;
        uint64_t v13 = (uint64_t *)((char *)v13 + 4);
        uint64_t v21 = (unsigned int *)(dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v20) + v12);
        uint64_t v22 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, *v21);
        uint64_t v23 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[1]);
        uint64_t v24 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[2]);
        uint64_t v25 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[3]);
        uint64_t v26 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[4]);
        uint64_t v27 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[5]);
        uint64_t v28 = dyld3::MachOAnalyzer::VMAddrConverter::convertToVMAddr(a4, v21[6]);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16LL))();
        if (v29) {
          break;
        }
        uint64_t v18 = v19 - 1;
      }

      while (v19);
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::objcMethodListIsRelative(dyld3::MachOAnalyzer *this, uint64_t a2)
{
  if (a2) {
    return *(_DWORD *)((char *)this + a2) >> 31;
  }
  else {
    return 0LL;
  }
}

uint64_t dyld3::MachOAnalyzer::forEachObjCDuplicateClassToIgnore(dyld3::MachOFile *a1, uint64_t a2)
{
  unsigned int v4 = dyld3::MachOFile::pointerSize(a1);
  unint64_t v9 = 0LL;
  uint64_t result = dyld3::MachOLoaded::findSectionContent(a1, "__DATA", "__objc_dupclass", &v9);
  if (result)
  {
    if (v9 % v4) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v9 == 0;
    }
    if (!v6)
    {
      uint64_t v7 = result;
      uint64_t v8 = 0LL;
      do
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, *(void *)(v7 + v8) + 8LL);
        v8 += v4;
      }

      while (v8 != v9);
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariable(dyld3::MachOFile *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0LL;
  int v10 = &v9;
  uint64_t v11 = 0x3802000000LL;
  uint64_t v12 = __Block_byref_object_copy__248;
  uint64_t v13 = __Block_byref_object_dispose__249;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  if (dyld3::MachOFile::hasThreadLocalVariables(a1))
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000LL;
    v8[2] = ___ZNK5dyld313MachOAnalyzer26forEachThreadLocalVariableER11DiagnosticsU13block_pointerFvPPFPvPNS0_9TLV_ThunkEEPmE_block_invoke;
    void v8[3] = &unk_1896225D8;
    void v8[6] = a1;
    void v8[7] = a2;
    void v8[4] = a3;
    void v8[5] = &v9;
    void v8[8] = dyld3::MachOFile::preferredLoadAddress(a1);
    dyld3::MachOFile::forEachSection(a1, (uint64_t)v8);
  }

  uint64_t v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

__n128 __Block_byref_object_copy__248(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

void *___ZNK5dyld313MachOAnalyzer26forEachThreadLocalVariableER11DiagnosticsU13block_pointerFvPPFPvPNS0_9TLV_ThunkEEPmE_block_invoke( void *result, uint64_t a2)
{
  char v3 = result;
  int v4 = *(unsigned __int8 *)(a2 + 92);
  if ((v4 - 17) >= 2)
  {
    if (v4 == 19)
    {
      uint64_t v8 = (dyld3::MachOFile *)result[6];
      BOOL v9 = dyld3::MachOFile::is64(v8);
      uint64_t v10 = v3[7];
      uint64_t v11 = v3[4];
      if (v9) {
        return (void *)dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<long long>(v8, v10, a2, v11);
      }
      else {
        return (void *)dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<int>(v8, v10, a2, v11);
      }
    }
  }

  else
  {
    uint64_t v5 = *(void *)(result[5] + 8LL);
    uint64_t v6 = *(void *)(v5 + 40);
    uint64_t v7 = *(void *)(a2 + 64);
    if (v6)
    {
      *(void *)(v5 + 48) = v7 + *(void *)(a2 + 72) - result[8] - v6;
    }

    else
    {
      *(void *)(v5 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v7 - result[8];
      *(void *)(*(void *)(result[5] + 8LL) + 48LL) = *(void *)(a2 + 72);
    }
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<long long>( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = dyld3::MachOFile::preferredLoadAddress(a1);
  int v8 = *(void *)(a3 + 72) / 0x18uLL;
  if (v8)
  {
    BOOL v9 = (char *)a1 + *(void *)(a3 + 64) - result;
    uint64_t v10 = &v9[24 * v8];
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 8);
      v9 += 24;
    }

    while (v9 < v10);
  }

  return result;
}

uint64_t dyld3::MachOAnalyzer::forEachThreadLocalVariableInSection<int>( dyld3::MachOFile *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = dyld3::MachOFile::preferredLoadAddress(a1);
  int v8 = *(void *)(a3 + 72) / 0xCuLL;
  if (v8)
  {
    BOOL v9 = (char *)a1 + *(void *)(a3 + 64) - result;
    uint64_t v10 = &v9[12 * v8];
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, v9, v9 + 4);
      v9 += 12;
    }

    while (v9 < v10);
  }

  return result;
}

void dyld3::MachOAnalyzer::forEachBindTarget( dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  if (!dyld3::MachOFile::isPreload(a1))
  {
    if (dyld3::MachOFile::hasChainedFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups(a1, a2, a4);
    }

    else if (dyld3::MachOFile::hasOpcodeFixups(a1))
    {
      dyld3::MachOAnalyzer::forEachBindTarget_Opcodes(a1, a2, a3, a4, a5);
    }
  }

void dyld3::MachOAnalyzer::forEachBindTarget_ChainedFixups( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  v8[0] = 0LL;
  v8[1] = v8;
  v8[2] = 0x2000000000LL;
  int v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  void v7[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke;
  void v7[3] = &unk_1896226E0;
  v7[4] = a3;
  void v7[5] = v8;
  dyld3::MachOAnalyzer::forEachChainedFixupTarget(a1, a2, (uint64_t)v7);
  if (Diagnostics::noError((Diagnostics *)a2)
    && dyld3::MachOFile::isMainExecutable(a1)
    && dyld3::MachOFile::hasWeakDefs(a1))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    void v6[2] = ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2;
    void v6[3] = &unk_189622708;
    void v6[4] = a3;
    void v6[5] = v8;
    dyld3::MachOFile::forEachTreatAsWeakDef((uint64_t)v6);
  }

  _Block_object_dispose(v8, 8);
}

void dyld3::MachOAnalyzer::forEachBindTarget_Opcodes( dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  v9[0] = 0LL;
  v9[1] = v9;
  v9[2] = 0x2000000000LL;
  int v10 = -1;
  v7[0] = 0LL;
  v7[1] = v7;
  void v7[2] = 0x2000000000LL;
  int v8 = -1;
  void v5[5] = v7;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  void v6[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke;
  void v6[3] = &unk_189622690;
  void v6[4] = a4;
  void v6[5] = v9;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2;
  void v5[3] = &unk_1896226B8;
  v5[4] = a5;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, a3, (uint64_t)v6, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(v9, 8);
}

void dyld3::MachOAnalyzer::forEachBindUnified_Opcodes( dyld3::MachOFile *a1, vm_address_t *a2, char a3, uint64_t a4, uint64_t a5)
{
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (!hasError)
  {
    __chkstk_darwin(hasError, v11, v12, v13, v14, v15, v16, v17, (uint64_t)&v21);
    uint64_t v19 = (uint64_t (*)())&v22[-8 * v18 - 1];
    uint64_t v39 = _NSConcreteStackBlock;
    uint64_t v40 = 0x40000000LL;
    uint64_t v41 = (uint64_t)___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
    uint64_t v42 = (__n128 (*)(uint64_t, uint64_t))&__block_descriptor_tmp_58_0;
    uint64_t v43 = v19;
    dyld3::MachOFile::forEachSegment(a1, (uint64_t)&v39);
    if (!Diagnostics::hasError((Diagnostics *)a2))
    {
      uint64_t v44 = 0LL;
      int v45 = &v44;
      uint64_t v46 = 0x2000000000LL;
      int v47 = 0;
      uint64_t v39 = 0LL;
      uint64_t v40 = (uint64_t)&v39;
      uint64_t v41 = 0x4802000000LL;
      uint64_t v42 = __Block_byref_object_copy__251;
      uint64_t v43 = __Block_byref_object_dispose__252;
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 0x40000000LL;
      v30[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke;
      v30[3] = &unk_189622600;
      __int128 v33 = v50;
      __int128 v32 = v49;
      __int128 v31 = v48;
      __int128 v37 = v54;
      __int128 v36 = v53;
      __int128 v35 = v52;
      __int128 v34 = v51;
      v30[5] = &v39;
      v30[6] = &v44;
      char v38 = a3;
      v30[4] = a4;
      if (!dyld3::MachOAnalyzer::forEachBind_OpcodesRegular( a1,  (Diagnostics *)a2,  (uint64_t)&v48,  (uint64_t)v19,  (uint64_t)v30))
      {
        BOOL v20 = dyld3::MachOAnalyzer::forEachBind_OpcodesLazy( a1,  (Diagnostics *)a2,  (uint64_t)&v48,  (uint64_t)v19,  (uint64_t)v30);
        _Block_object_dispose(&v39, 8);
        _Block_object_dispose(&v44, 8);
        if (v20) {
          return;
        }
        uint64_t v44 = 0LL;
        int v45 = &v44;
        uint64_t v46 = 0x2000000000LL;
        int v47 = 0;
        uint64_t v39 = 0LL;
        uint64_t v40 = (uint64_t)&v39;
        uint64_t v41 = 0x4802000000LL;
        uint64_t v42 = __Block_byref_object_copy__251;
        uint64_t v43 = __Block_byref_object_dispose__252;
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000LL;
        v22[2] = ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2;
        v22[3] = &unk_189622628;
        __int128 v24 = v49;
        __int128 v23 = v48;
        __int128 v29 = v54;
        __int128 v28 = v53;
        __int128 v27 = v52;
        __int128 v25 = v50;
        __int128 v26 = v51;
        v22[6] = &v44;
        void v22[7] = v19;
        v22[4] = a5;
        v22[5] = &v39;
        dyld3::MachOAnalyzer::forEachBind_OpcodesWeak( a1,  (Diagnostics *)a2,  (uint64_t)&v48,  (uint64_t)v19,  (uint64_t)v22,  (uint64_t)&__block_literal_global_257);
      }

      _Block_object_dispose(&v39, 8);
      _Block_object_dispose(&v44, 8);
    }
  }

__n128 __Block_byref_object_copy__251(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, unsigned __int8 a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18)
{
  uint64_t v18 = *(void *)(a4 + ((unint64_t)a10 << 6) + 16);
  uint64_t v19 = *(void *)(a1 + 136);
  if (a17)
  {
    uint64_t v20 = *(void *)(*(void *)(a1 + 48) + 8LL);
    int v21 = *(_DWORD *)(v20 + 24);
    *(_DWORD *)(v20 + 24) = v21 + 1;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 4dyld4::halt((char *)__format, 0LL) = v21;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 44LL) = a8;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL) = a13;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL) = a16;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 64LL) = a14;
    if (a15) {
      BOOL v22 = *(_BYTE *)(a1 + 168) != 0;
    }
    else {
      BOOL v22 = 0;
    }
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 65LL) = v22;
  }

  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  v18 + a11 - v19,  *(void *)(*(void *)(a1 + 40) + 8LL) + 40LL,  a18);
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesRegular( dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 20LL)) {
    return 0LL;
  }
  unsigned int v9 = dyld3::MachOFile::pointerSize(a1);
  char v44 = 0;
  unsigned int v37 = dyld3::MachOFile::dependentDylibCount(a1, 0LL);
  uint64_t v39 = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v10 = 0LL;
  char v38 = 0LL;
  uint64_t v41 = 0LL;
  char v11 = 0;
  char v12 = 0;
  char v13 = 0;
  uint64_t v14 = 0LL;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  a3 + 72,  *(_DWORD *)(*(void *)a3 + 16LL));
  __int128 v36 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 20LL));
  uint64_t v15 = v9;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v17 = LinkEditContent;
    uint64_t v18 = (unsigned __int8 *)LinkEditContent + 1;
    unsigned int v19 = *(unsigned __int8 *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    int v20 = v19 & 0xF;
    char v11 = 1;
    switch(v19 >> 4)
    {
      case 0u:
        break;
      case 1u:
        char v11 = 0;
        char v13 = 1;
        uint64_t v14 = v19 & 0xF;
        break;
      case 2u:
        uint64_t v14 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v11 = 0;
        goto LABEL_13;
      case 3u:
        char v11 = 0;
        if ((v19 & 0xF) != 0) {
          uint64_t v14 = v19 | 0xFFFFFFF0;
        }
        else {
          uint64_t v14 = 0LL;
        }
LABEL_13:
        char v13 = 1;
        break;
      case 4u:
        if (*v18)
        {
          int v21 = (const unsigned __int8 **)((char *)v17 + 2);
          do
          {
            uint64_t LinkEditContent = v21;
            int v22 = *(unsigned __int8 *)v21;
            int v21 = (const unsigned __int8 **)((char *)v21 + 1);
          }

          while (v22);
          uint64_t v17 = (const unsigned __int8 **)((char *)v21 - 2);
        }

        char v11 = 0;
        LOBYTE(v39) = v19 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v17 + 2);
        char v12 = 1;
        char v38 = v18;
        break;
      case 5u:
        char v11 = 0;
        BYTE4(v4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v19 & 0xF;
        break;
      case 6u:
        uint64_t v41 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v11 = 0;
        char v12 = 1;
        break;
      case 7u:
        uint64_t v10 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        char v11 = 0;
        BYTE4(v39) = v20;
        LOBYTE(v4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
        break;
      case 8u:
        char v11 = 0;
        v10 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        break;
      case 9u:
        LOBYTE(v34) = v12;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = BYTE4(v39);
        LODWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND",  a3,  a4,  v40 & 1,  v13 & 1,  v37,  v14,  v31,  v10,  v32,  v38,  v33,  v41,  v34,  &v44);
        char v12 = 0;
        char v11 = 0;
        v10 += v15;
        break;
      case 0xAu:
        LOBYTE(v34) = v12;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = BYTE4(v39);
        LODWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  a3,  a4,  v40 & 1,  v13 & 1,  v37,  v14,  v31,  v10,  v32,  v38,  v33,  v41,  v34,  &v44);
        char v12 = 0;
        char v11 = 0;
        v10 += v15
             + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v23);
        break;
      case 0xBu:
        LOBYTE(v34) = v12;
        LOWORD(v33) = v39 & 1;
        LOBYTE(v32) = BYTE4(v40);
        BYTE4(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = BYTE4(v39);
        LODWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v15;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  a3,  a4,  v40 & 1,  v13 & 1,  v37,  v14,  v31,  v10,  v32,  v38,  v33,  v41,  v34,  &v44);
        char v12 = 0;
        char v11 = 0;
        v10 += (v15 + v15 * v20);
        break;
      case 0xCu:
        unint64_t v24 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v16);
        uint64_t v26 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v36, v25);
        if (!v24) {
          goto LABEL_31;
        }
        __int128 v35 = a2;
        uint64_t v27 = v26 + v15;
        unsigned int v28 = 1;
        do
        {
          LOBYTE(v34) = v12;
          LOWORD(v33) = v39 & 1;
          LOBYTE(v32) = BYTE4(v40);
          BYTE4(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = BYTE4(v39);
          LODWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v15;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t, uint64_t, int, unsigned __int8 *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  a3,  a4,  v40 & 1,  v13 & 1,  v37,  v14,  v31,  v10,  v32,  v38,  v33,  v41,  v34,  &v44);
          char v12 = 0;
          v10 += v27;
          if (v44) {
            break;
          }
          unint64_t v29 = v28++;
        }

        while (v24 > v29);
        char v11 = 0;
        a2 = v35;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X", *v18);
LABEL_31:
        char v11 = 0;
        break;
    }
  }

  while (!v44);
  return v44 != 0;
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesLazy( dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 36LL)) {
    return 0LL;
  }
  unsigned int v9 = dyld3::MachOFile::pointerSize(a1);
  char v33 = 0;
  unsigned int v27 = dyld3::MachOFile::dependentDylibCount(a1, 0LL);
  char v29 = 0;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  char v10 = 0;
  uint64_t v11 = 0LL;
  char v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  a3 + 72,  *(_DWORD *)(*(void *)a3 + 32LL));
  uint64_t v14 = (const unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 36LL));
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    uint64_t v16 = LinkEditContent;
    if (LinkEditContent >= v14) {
      break;
    }
    uint64_t v17 = (char *)LinkEditContent + 1;
    unsigned __int8 v18 = *(_BYTE *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    char v19 = v18 & 0xF;
    switch(v18 >> 4)
    {
      case 0:
        break;
      case 1:
        char v10 = 1;
        uint64_t v11 = v18 & 0xF;
        break;
      case 2:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        goto LABEL_12;
      case 3:
        if ((v18 & 0xF) != 0) {
          uint64_t v11 = *(_DWORD *)&v18 | 0xFFFFFFF0;
        }
        else {
          uint64_t v11 = 0LL;
        }
LABEL_12:
        char v10 = 1;
        break;
      case 4:
        if (*v17)
        {
          int v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            uint64_t LinkEditContent = v20;
            int v21 = *(unsigned __int8 *)v20;
            int v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }

          while (v21);
          uint64_t v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }

        char v29 = v18 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v16 + 2);
        char v12 = v17;
        break;
      case 6:
        uint64_t v31 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        break;
      case 7:
        uint64_t v13 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, v14, v15);
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v19;
        BYTE4(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
        break;
      case 9:
        LOBYTE(v26) = 1;
        BYTE1(v25) = 1;
        LOBYTE(v25) = v29 & 1;
        LOBYTE(v24) = 1;
        BYTE4(v23) = v30;
        LODWORD(v23) = v9;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, void, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND",  a3,  a4,  BYTE4(v30) & 1,  v10 & 1,  v27,  v11,  v23,  v13,  v24,  v12,  v25,  v31,  v26,  &v33);
        v13 += v9;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad lazy bind opcode 0x%02X", v18 & 0xF0);
        break;
    }
  }

  while (!v33);
  return v33 != 0;
}

uint64_t ___ZNK5dyld313MachOAnalyzer26forEachBindUnified_OpcodesER11DiagnosticsbU13block_pointerFvyRKNS0_14BindTargetInfoERbES8__block_invoke_2( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = *(void *)(a1[5] + 8LL);
  if (*(void *)(v14 + 48) != a12 || *(void *)(v14 + 56) != a14)
  {
    uint64_t v15 = *(void *)(a1[6] + 8LL);
    int v16 = *(_DWORD *)(v15 + 24);
    *(_DWORD *)(v15 + 24) = v16 + 1;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 4dyld4::halt((char *)__format, 0LL) = v16;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 44LL) = -3;
    *(void *)(*(void *)(a1[5] + 8LL) + 48LL) = a12;
    *(void *)(*(void *)(a1[5] + 8LL) + 56LL) = a14;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 64LL) = 0;
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 65LL) = 0;
  }

  return (*(uint64_t (**)(void))(a1[4] + 16LL))();
}

BOOL dyld3::MachOAnalyzer::forEachBind_OpcodesWeak( dyld3::MachOFile *a1, Diagnostics *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(void *)a3 || !*(_DWORD *)(*(void *)a3 + 28LL)) {
    return 0LL;
  }
  unsigned int v10 = dyld3::MachOFile::pointerSize(a1);
  char v42 = 0;
  unsigned int v35 = dyld3::MachOFile::dependentDylibCount(a1, 0LL);
  uint64_t v11 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v39 = 0LL;
  LOBYTE(v12) = 0;
  uint64_t v13 = 0LL;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  a3 + 72,  *(_DWORD *)(*(void *)a3 + 24LL));
  int v34 = (unsigned __int8 **)((char *)LinkEditContent + *(unsigned int *)(*(void *)a3 + 28LL));
  char v36 = 0;
  char v37 = 1;
  char v14 = 1;
  do
  {
    if (!Diagnostics::noError(a2)) {
      break;
    }
    int v16 = LinkEditContent;
    unsigned __int8 v18 = (char *)LinkEditContent + 1;
    unsigned int v17 = *(unsigned __int8 *)LinkEditContent;
    uint64_t LinkEditContent = (const unsigned __int8 **)((char *)LinkEditContent + 1);
    unsigned int v19 = v17 & 0xF;
    unsigned int v12 = 1;
    switch(v17 >> 4)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 3u:
        Diagnostics::error((vm_address_t *)a2, "unexpected dylib ordinal in weak_bind");
        goto LABEL_17;
      case 4u:
        if (*v18)
        {
          int v20 = (const unsigned __int8 **)((char *)v16 + 2);
          do
          {
            uint64_t LinkEditContent = v20;
            int v21 = *(unsigned __int8 *)v20;
            int v20 = (const unsigned __int8 **)((char *)v20 + 1);
          }

          while (v21);
          int v16 = (const unsigned __int8 **)((char *)v20 - 2);
        }

        char v36 = v17 & 1;
        uint64_t LinkEditContent = (const unsigned __int8 **)((char *)v16 + 2);
        if (v19 >= 8) {
          (*(void (**)(uint64_t, _BYTE *))(a6 + 16))(a6, v18);
        }
        LOBYTE(v12) = 0;
        char v14 = 1;
        uint64_t v13 = v18;
        break;
      case 5u:
        LOBYTE(v12) = 0;
        char v37 = v17 & 0xF;
        break;
      case 6u:
        uint64_t v39 = dyld3::MachOFile::read_sleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v15);
        LOBYTE(v12) = 0;
        char v14 = 1;
        break;
      case 7u:
        uint64_t v11 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v15);
        LOBYTE(v12) = 0;
        LOBYTE(v38) = v19;
        BYTE4(v38) = 1;
        break;
      case 8u:
        LOBYTE(v12) = 0;
        v11 += dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v15);
        break;
      case 9u:
        LOBYTE(v32) = v14;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v36 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v37;
        BYTE4(v29) = v38;
        LODWORD(v29) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND",  a3,  a4,  BYTE4(v38) & 1,  1LL,  v35,  4294967293LL,  v29,  v11,  v30,  v13,  v31,  v39,  v32,  &v42);
        char v14 = 0;
        LOBYTE(v12) = 0;
        v11 += v10;
        break;
      case 0xAu:
        LOBYTE(v32) = v14;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v36 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v37;
        BYTE4(v29) = v38;
        LODWORD(v29) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB",  a3,  a4,  BYTE4(v38) & 1,  1LL,  v35,  4294967293LL,  v29,  v11,  v30,  v13,  v31,  v39,  v32,  &v42);
        char v14 = 0;
        LOBYTE(v12) = 0;
        v11 += v10
             + dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v22);
        break;
      case 0xBu:
        LOBYTE(v32) = v14;
        LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v36 & 1;
        LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v37;
        BYTE4(v29) = v38;
        LODWORD(v29) = v10;
        (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED",  a3,  a4,  BYTE4(v38) & 1,  1LL,  v35,  4294967293LL,  v29,  v11,  v30,  v13,  v31,  v39,  v32,  &v42);
        char v14 = 0;
        LOBYTE(v12) = 0;
        v11 += v10 + v10 * v19;
        break;
      case 0xCu:
        unint64_t v23 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v15);
        uint64_t v25 = dyld3::MachOFile::read_uleb128((vm_address_t *)a2, &LinkEditContent, (const unsigned __int8 **)v34, v24);
        if (!v23) {
          goto LABEL_17;
        }
        uint64_t v26 = v25 + v10;
        do
        {
          LOBYTE(v32) = v14;
          LOWORD(v3dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v36 & 1;
          LOBYTE(v3dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v37;
          BYTE4(v29) = v38;
          LODWORD(v29) = v10;
          (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t, int, _BYTE *, int, uint64_t, int, char *))(a5 + 16))( a5,  "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB",  a3,  a4,  BYTE4(v38) & 1,  1LL,  v35,  4294967293LL,  v29,  v11,  v30,  v13,  v31,  v39,  v32,  &v42);
          char v14 = 0;
          v11 += v26;
          if (v42) {
            break;
          }
          unint64_t v27 = v12++;
        }

        while (v23 > v27);
        LOBYTE(v12) = 0;
        break;
      default:
        Diagnostics::error((vm_address_t *)a2, "bad bind opcode 0x%02X");
LABEL_17:
        LOBYTE(v12) = 0;
        break;
    }
  }

  while (!v42);
  return v42 != 0;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke( uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) != *a3)
  {
    uint64_t v4 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
    *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *a3;
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer25forEachBindTarget_OpcodesER11DiagnosticsbU13block_pointerFvRKNS0_14BindTargetInfoERbES8__block_invoke_2( uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) != *a3)
  {
    uint64_t v4 = result;
    __n128 result = (*(uint64_t (**)(void))(*(void *)(result + 32) + 16LL))();
    *(_DWORD *)(*(void *)(*(void *)(v4 + 40) + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *a3;
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke( uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v8 = a1 + 32;
  uint64_t v7 = *(void *)(a1 + 32);
  v10[0] = *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 8LL) + 24LL);
  v10[1] = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  char v13 = a5;
  char v14 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(v7 + 16))(v7, v10, a6, a4);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer31forEachBindTarget_ChainedFixupsER11DiagnosticsU13block_pointerFvRKNS0_14BindTargetInfoERbE_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(*(void *)(*(void *)(v4 + 8) + 8LL) + 24LL);
  int v8 = -3;
  uint64_t v9 = a2;
  uint64_t v10 = 0LL;
  __int16 v11 = 0;
  char v6 = 0;
  uint64_t result = (*(uint64_t (**)(void))(v3 + 16))();
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  return result;
}

void dyld3::MachOAnalyzer::forEachBindLocation_Opcodes( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4)
{
  v4[4] = a4;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke;
  void v5[3] = &unk_189622730;
  v5[4] = a3;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2;
  void v4[3] = &unk_189622758;
  dyld3::MachOAnalyzer::forEachBindUnified_Opcodes(a1, a2, 0, (uint64_t)v5, (uint64_t)v4);
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZNK5dyld313MachOAnalyzer27forEachBindLocation_OpcodesER11DiagnosticsU13block_pointerFvyjRbES5__block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t dyld3::MachOAnalyzer::forEachRebaseLocation_Opcodes( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3)
{
  BOOL hasError = Diagnostics::hasError((Diagnostics *)a2);
  if (hasError) {
    return 0LL;
  }
  __chkstk_darwin(hasError, v7, v8, v9, v10, v11, v12, v13, v17);
  int v16 = &v18[-8 * v15 - 1];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 0x40000000LL;
  _OWORD v27[2] = ___ZNK5dyld313MachOAnalyzer19getAllSegmentsInfosER11DiagnosticsPNS_9MachOFile11SegmentInfoE_block_invoke;
  v27[3] = &__block_descriptor_tmp_58_0;
  v27[4] = v16;
  dyld3::MachOFile::forEachSegment(a1, (uint64_t)v27);
  if (Diagnostics::hasError((Diagnostics *)a2)) {
    return 0LL;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000LL;
  v18[2] = ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke;
  uint64_t v18[3] = &unk_189622780;
  __int128 v22 = v26[3];
  __int128 v23 = v26[4];
  __int128 v24 = v26[5];
  __int128 v25 = v26[6];
  __int128 v19 = v26[0];
  __int128 v20 = v26[1];
  __int128 v21 = v26[2];
  v18[4] = a3;
  return dyld3::MachOAnalyzer::forEachRebase_Opcodes(a1, a2, (uint64_t)v26, (uint64_t)v16, (uint64_t)v18);
}

uint64_t dyld3::MachOAnalyzer::forEachRebase_Opcodes( dyld3::MachOFile *a1, vm_address_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (dyld3::MachOFile::is64(a1)) {
    int v10 = 2;
  }
  else {
    int v10 = 1;
  }
  int v44 = v10;
  if (!*(void *)a3) {
    dyld3::MachOAnalyzer::forEachRebase_Opcodes();
  }
  uint64_t v47 = a5;
  uint64_t v48 = a4;
  uint64_t LinkEditContent = (const unsigned __int8 **)dyld3::MachOLoaded::getLinkEditContent( (uint64_t)a1,  a3 + 72,  *(_DWORD *)(*(void *)a3 + 8LL));
  uint64_t v46 = a3;
  uint64_t v42 = *(unsigned int *)(*(void *)a3 + 12LL);
  int v43 = (int)LinkEditContent;
  uint64_t v12 = (const unsigned __int8 **)((char *)LinkEditContent + v42);
  __int128 v52 = LinkEditContent;
  int v13 = 0;
  unsigned __int8 v14 = 0;
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  unsigned __int8 v51 = 0;
  uint64_t v17 = dyld3::MachOFile::pointerSize(a1);
  unsigned __int8 v18 = a2;
  __int128 v19 = v12;
  int v45 = v18;
  while (2)
  {
    if (Diagnostics::noError((Diagnostics *)v18))
    {
      __int128 v21 = v52;
      if (v52 < v19)
      {
        unsigned __int8 v22 = *(_BYTE *)v52;
        __int128 v52 = (const unsigned __int8 **)((char *)v52 + 1);
        unsigned int v23 = v22 & 0xF;
        switch(v22 >> 4)
        {
          case 0:
            uint64_t v41 = (char *)v21 + 1;
            return 1;
          case 1:
            switch(v23)
            {
              case 1u:
                int v13 = v44;
                break;
              case 3u:
                int v13 = 3;
                break;
              case 2u:
                int v13 = 4;
                break;
              default:
                int v13 = 0;
                break;
            }

            goto LABEL_46;
          case 2:
            uint64_t v16 = dyld3::MachOFile::read_uleb128(v18, &v52, v19, v20);
            uint64_t v15 = 1LL;
            unsigned __int8 v14 = v23;
            goto LABEL_46;
          case 3:
            v16 += dyld3::MachOFile::read_uleb128(v18, &v52, v19, v20);
            goto LABEL_46;
          case 4:
            v16 += v17 * v23;
            goto LABEL_46;
          case 5:
            if ((v22 & 0xF) == 0) {
              goto LABEL_46;
            }
            unsigned int v24 = 1;
            do
            {
              (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *))(v47 + 16))( v47,  "REBASE_OPCODE_DO_REBASE_IMM_TIMES",  v46,  v48,  v15 & 1,  v17,  v14,  v16,  v13,  &v51);
              v16 += v17;
              if (v51) {
                BOOL v25 = 1;
              }
              else {
                BOOL v25 = v24 >= v23;
              }
              ++v24;
            }

            while (!v25);
            __int128 v19 = v12;
            unsigned __int8 v18 = v45;
            if (v51) {
              return v51;
            }
            continue;
          case 6:
            uint64_t v26 = dyld3::MachOFile::read_uleb128(v18, &v52, v19, v20);
            if (v26)
            {
              unint64_t v27 = v26;
              int v49 = v13;
              uint64_t v28 = v15;
              unsigned int v29 = 1;
              do
              {
                (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *))(v47 + 16))( v47,  "REBASE_OPCODE_DO_REBASE_ULEB_TIMES",  v46,  v48,  v28 & 1,  v17,  v14,  v16,  v49,  &v51);
                v16 += v17;
                unint64_t v30 = v29++;
                if (v51) {
                  BOOL v31 = 0;
                }
                else {
                  BOOL v31 = v27 > v30;
                }
              }

              while (v31);
              uint64_t v15 = v28;
              int v13 = v49;
              __int128 v19 = v12;
              unsigned __int8 v18 = v45;
            }

            goto LABEL_46;
          case 7:
            (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, int, unsigned __int8 *))(v47 + 16))( v47,  "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB",  v46,  v48,  v15 & 1,  v17,  v14,  v16,  v13,  &v51);
            v16 += v17 + dyld3::MachOFile::read_uleb128(v18, &v52, v19, v32);
            goto LABEL_46;
          case 8:
            unint64_t v33 = dyld3::MachOFile::read_uleb128(v18, &v52, v19, v20);
            if (!Diagnostics::hasError((Diagnostics *)v18))
            {
              uint64_t v35 = dyld3::MachOFile::read_uleb128(v18, &v52, v19, v34);
              if (v33)
              {
                unsigned int v50 = v15;
                uint64_t v36 = v35 + v17;
                unsigned int v37 = 1;
                do
                {
                  (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, void, uint64_t, void, uint64_t, int, unsigned __int8 *))(v47 + 16))( v47,  "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB",  v46,  v48,  v50 & 1,  v17,  v14,  v16,  v13,  &v51);
                  unint64_t v38 = v37++;
                  v16 += v36;
                  if (v51) {
                    BOOL v39 = 0;
                  }
                  else {
                    BOOL v39 = v33 > v38;
                  }
                }

                while (v39);
                __int128 v19 = v12;
                uint64_t v15 = v50;
                unsigned __int8 v18 = v45;
              }
            }

            goto LABEL_46;
          default:
            Diagnostics::error(v18, "unknown rebase opcode 0x%02X", v22 & 0xF0);
LABEL_46:
            if (v51) {
              return v51;
            }
            continue;
        }
      }
    }

    return v51;
  }

uint64_t ___ZNK5dyld313MachOAnalyzer29forEachRebaseLocation_OpcodesER11DiagnosticsU13block_pointerFvyRbE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

double ___ZNK5dyld313MachOAnalyzer17getLinkeditLayoutER11DiagnosticsyPKhRN6mach_o14LinkeditLayoutE_block_invoke( uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)a2;
  if (*(int *)a2 > 10)
  {
    switch(v4)
    {
      case 29:
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v11 = *(void **)(a1 + 48);
        uint64_t v12 = *(unsigned int *)(a2 + 8);
        int v13 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v10 + 552) = v12;
        *(void *)(v10 + 56dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = **(void **)(a1 + 56) - *v11 + v12;
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)(v14 + 568) = v13;
        *(_DWORD *)(v14 + 576) = 0;
        *(_BYTE *)(v14 + 58dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
        break;
      case 30:
        uint64_t v56 = *(void *)(a1 + 40);
        int v57 = *(void **)(a1 + 48);
        uint64_t v58 = *(unsigned int *)(a2 + 8);
        int v59 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v56 + 456) = v58;
        *(void *)(v56 + 464) = **(void **)(a1 + 56) - *v57 + v58;
        uint64_t v60 = *(void *)(a1 + 40);
        *(_DWORD *)(v60 + 472) = v59;
        *(_DWORD *)(v60 + 48dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
        *(_BYTE *)(v60 + 484) = 1;
        break;
      case 31:
      case 32:
      case 33:
      case 35:
      case 36:
      case 37:
        return result;
      case 34:
        goto LABEL_14;
      case 38:
        uint64_t v61 = *(void *)(a1 + 40);
        int v62 = *(void **)(a1 + 48);
        uint64_t v63 = *(unsigned int *)(a2 + 8);
        int v64 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(v61 + 488) = v63;
        *(void *)(v61 + 496) = **(void **)(a1 + 56) - *v62 + v63;
        uint64_t v65 = *(void *)(a1 + 40);
        *(_DWORD *)(v65 + 504) = v64;
        *(_DWORD *)(v65 + 512) = 0;
        *(_BYTE *)(v65 + 516) = 1;
        break;
      default:
        if (v4 == 11)
        {
          uint64_t v66 = *(void *)(a1 + 40);
          uint64_t v67 = *(uint64_t **)(a1 + 48);
          *(_BYTE *)(v66 + 589) = 1;
          uint64_t v68 = *(unsigned int *)(a2 + 72);
          *(_DWORD *)uint64_t v66 = v68;
          uint64_t v69 = *v67;
          uint64_t v70 = *(void **)(a1 + 56);
          *(void *)(v66 + 8) = *v70 - v69 + v68;
          uint64_t v71 = *(void *)(a1 + 40);
          *(void *)(v71 + 16) = 0LL;
          *(_DWORD *)(v71 + 24) = *(_DWORD *)(a2 + 76);
          *(_BYTE *)(v71 + 28) = 1;
          uint64_t v72 = *(unsigned int *)(a2 + 64);
          *(_DWORD *)(v71 + 32) = v72;
          *(void *)(v71 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *v70 - v69 + v72;
          uint64_t v73 = *(void *)(a1 + 40);
          *(void *)(v73 + 48) = 0LL;
          *(_DWORD *)(v73 + 56) = *(_DWORD *)(a2 + 68);
          *(_BYTE *)(v73 + 6dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
          uint64_t v74 = *(unsigned int *)(a2 + 56);
          *(_DWORD *)(v73 + 64) = v74;
          *(void *)(v73 + 72) = *v70 - v69 + v74;
          uint64_t v75 = *(void *)(a1 + 40);
          *(void *)(v75 + 8dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0LL;
          *(_DWORD *)(v75 + 88) = *(_DWORD *)(a2 + 60);
          *(_BYTE *)(v75 + 92) = 1;
          *(_DWORD *)(v75 + 96) = 0;
          *(void *)(v75 + 104) = 0LL;
          uint64_t v76 = *(void *)(a1 + 40);
          *(_DWORD *)(v76 + 112) = 0;
          *(void *)(v76 + 116) = *(void *)(a2 + 8);
          *(_BYTE *)(v76 + 124) = 1;
          *(_DWORD *)(v76 + 128) = 0;
          *(void *)(v76 + 136) = 0LL;
          uint64_t v77 = *(void *)(a1 + 40);
          *(_DWORD *)(v77 + 144) = 0;
          *(void *)(v77 + 148) = *(void *)(a2 + 16);
          *(_BYTE *)(v77 + 156) = 1;
          *(_DWORD *)(v77 + 16dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 0;
          *(void *)(v77 + 168) = 0LL;
          uint64_t v78 = *(void *)(a1 + 40);
          *(_DWORD *)(v78 + 176) = 0;
          double result = *(double *)(a2 + 24);
          *(double *)(v78 + 18dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = result;
          *(_BYTE *)(v78 + 188) = 1;
        }

        else if (v4 == 41)
        {
          uint64_t v46 = *(void *)(a1 + 40);
          uint64_t v47 = *(void **)(a1 + 48);
          uint64_t v48 = *(unsigned int *)(a2 + 8);
          int v49 = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v46 + 52dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v48;
          *(void *)(v46 + 528) = **(void **)(a1 + 56) - *v47 + v48;
          uint64_t v50 = *(void *)(a1 + 40);
          *(_DWORD *)(v50 + 536) = v49;
          *(_DWORD *)(v50 + 544) = 0;
          *(_BYTE *)(v50 + 548) = 1;
        }

        break;
    }
  }

  else if (v4 > -2147483597)
  {
    if (v4 == -2147483596)
    {
      uint64_t v51 = *(void *)(a1 + 40);
      uint64_t v52 = **(void **)(a1 + 56) - **(void **)(a1 + 48);
      uint64_t v53 = *(unsigned int *)(a2 + 8);
      int v54 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v51 + 384) = v53;
      *(void *)(v51 + 392) = v52 + v53;
      uint64_t v55 = *(void *)(a1 + 40);
      *(_DWORD *)(v55 + 40dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v54;
      *(_DWORD *)(v55 + 408) = 0;
      *(_BYTE *)(v55 + 412) = 1;
      *(void *)(v55 + 416) = a2;
    }

    else if (v4 == 2)
    {
      uint64_t v15 = *(dyld3::MachOFile **)(a1 + 32);
      *(_BYTE *)(*(void *)(a1 + 40) + 588LL) = 1;
      if (dyld3::MachOFile::is64(v15)) {
        int v17 = 16;
      }
      else {
        int v17 = 12;
      }
      uint64_t v18 = *(void *)(a1 + 40);
      __int128 v19 = *(uint64_t **)(a1 + 48);
      uint64_t v20 = *(unsigned int *)(a2 + 8);
      int v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v18 + 192) = v20;
      uint64_t v22 = *v19;
      unsigned int v23 = *(void **)(a1 + 56);
      *(void *)(v18 + 20dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *v23 - v22 + v20;
      uint64_t v24 = *(void *)(a1 + 40);
      *(_DWORD *)(v24 + 208) = v21 * v17;
      *(_DWORD *)(v24 + 216) = v21;
      *(_BYTE *)(v24 + 22dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
      uint64_t v25 = *(unsigned int *)(a2 + 16);
      LODWORD(v2dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v24 + 224) = v25;
      *(void *)(v24 + 232) = *v23 - v22 + v25;
      uint64_t v26 = *(void *)(a1 + 40);
      *(_DWORD *)(v26 + 24dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v20;
      *(_BYTE *)(v26 + 252) = 1;
    }
  }

  else
  {
    if (v4 == -2147483614)
    {
LABEL_14:
      uint64_t v27 = *(void *)(a1 + 40);
      uint64_t v28 = *(uint64_t **)(a1 + 48);
      *(_DWORD *)(v27 + 584) = v4;
      uint64_t v29 = *(unsigned int *)(a2 + 8);
      int v30 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v27 + 256) = v29;
      uint64_t v31 = *v28;
      int v32 = *(void **)(a1 + 56);
      *(void *)(v27 + 264) = *v32 - v31 + v29;
      uint64_t v33 = *(void *)(a1 + 40);
      *(_DWORD *)(v33 + 272) = v30;
      *(_BYTE *)(v33 + 284) = 1;
      uint64_t v34 = *(unsigned int *)(a2 + 16);
      int v35 = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v33 + 288) = v34;
      *(void *)(v33 + 296) = *v32 - v31 + v34;
      uint64_t v36 = *(void *)(a1 + 40);
      *(_DWORD *)(v36 + 304) = v35;
      *(_BYTE *)(v36 + 316) = 1;
      uint64_t v37 = *(unsigned int *)(a2 + 32);
      int v38 = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(v36 + 352) = v37;
      *(void *)(v36 + 36dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = *v32 - v31 + v37;
      uint64_t v39 = *(void *)(a1 + 40);
      *(_DWORD *)(v39 + 368) = v38;
      uint64_t v40 = *(unsigned int *)(a2 + 24);
      int v41 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(v39 + 32dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v40;
      uint64_t v42 = *v32 - v31;
      *(_BYTE *)(v39 + 38dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = 1;
      *(void *)(v39 + 328) = v42 + v40;
      uint64_t v43 = *(void *)(a1 + 40);
      *(_DWORD *)(v43 + 336) = v41;
      *(_BYTE *)(v43 + 348) = 1;
      uint64_t v44 = *(unsigned int *)(a2 + 40);
      int v45 = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(v43 + 424) = v44;
      *(void *)(v43 + 432) = *v32 - v31 + v44;
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)(v9 + 44dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v45;
    }

    else
    {
      if (v4 != -2147483597) {
        return result;
      }
      uint64_t v5 = *(void *)(a1 + 40);
      char v6 = *(void **)(a1 + 48);
      uint64_t v7 = *(unsigned int *)(a2 + 8);
      int v8 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v5 + 424) = v7;
      *(void *)(v5 + 432) = **(void **)(a1 + 56) - *v6 + v7;
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)(v9 + 44dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v8;
      *(_DWORD *)(v9 + 448) = 0;
    }

    *(_BYTE *)(v9 + 452) = 1;
  }

  return result;
}

uint64_t ___ZNK5dyld313MachOAnalyzer12withVMLayoutER11DiagnosticsU13block_pointerFvRKN6mach_o6LayoutEE_block_invoke( void *a1, uint64_t *a2)
{
  uint64_t v4 = a2[2];
  uint64_t v5 = a2[3];
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = a1[6] + v4;
  int v9 = *((_DWORD *)a2 + 13);
  uint64_t v10 = (const char *)a2[5];
  uint64_t result = _platform_strcmp(v10, "__TEXT");
  if ((_DWORD)result)
  {
    uint64_t result = _platform_strcmp(v10, "__LINKEDIT");
    if ((_DWORD)result)
    {
      int v12 = 0;
    }

    else
    {
      *(void *)(*(void *)(a1[4] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6;
      *(void *)(*(void *)(a1[5] + 8LL) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v8;
      int v12 = 2;
    }
  }

  else
  {
    int v12 = 1;
  }

  uint64_t v13 = a1[7] + 48LL * ((unsigned __int16)*((_DWORD *)a2 + 14) >> 4);
  *(void *)uint64_t v13 = v4;
  *(void *)(v13 + 8) = v5;
  *(void *)(v13 + 16) = v6;
  *(void *)(v13 + 24) = v7;
  *(void *)(v13 + 32) = v8;
  *(_DWORD *)(v13 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v9;
  *(_DWORD *)(v13 + 44) = v12;
  return result;
}

void *dyld3::OverflowSafeArray<dyld3::SegmentRanges::SegmentRange,4294967295ull>::verifySpace( void *result, uint64_t a2)
{
  unint64_t v2 = result[1];
  unint64_t v3 = result[2] + a2;
  if (v3 > v2)
  {
    uint64_t v4 = (const void **)result;
    vm_address_t v5 = result[3];
    vm_size_t v6 = result[4];
    unint64_t v7 = 2 * v2;
    if (v7 > v3) {
      unint64_t v3 = v7;
    }
    vm_size_t v8 = (vm_page_size + 24 * v3 - 1) & -(uint64_t)vm_page_size;
    result[4] = v8;
    if (vm_allocate(mach_task_self_, result + 3, v8, 1006632961)) {
      ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1();
    }
    uint64_t result = memmove((void *)v4[3], *v4, 24LL * (void)v4[2]);
    unint64_t v9 = (unint64_t)v4[4] / 0x18;
    Diagnostics *v4 = v4[3];
    v4[1] = (const void *)v9;
    if (v5) {
      return (void *)vm_deallocate(mach_task_self_, v5, v6);
    }
  }

  return result;
}

void *metadata_visitor::ResolvedValue::ResolvedValue(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

uint64_t metadata_visitor::ResolvedValue::vmAddress(metadata_visitor::ResolvedValue *this)
{
  return *((void *)this + 1);
}

metadata_visitor::Visitor *metadata_visitor::Visitor::Visitor( metadata_visitor::Visitor *this, const dyld3::MachOAnalyzer *a2)
{
  *(_DWORD *)this = 0;
  *((void *)this + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = a2;
  *((void *)this + 2) = dyld3::MachOFile::preferredLoadAddress(a2);
  *((_BYTE *)this + 24) = 1;
  *(_DWORD *)this = dyld3::MachOFile::pointerSize(a2);
  return this;
}

uint64_t metadata_visitor::Visitor::getField@<X0>(uint64_t this@<X0>, char *a2@<X2>, void *a3@<X8>)
{
  if (!*(_BYTE *)(this + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v4 = &a2[*(void *)(this + 16) - *(void *)(this + 8)];
  *a3 = a2;
  a3[1] = v4;
  a3[2] = 1LL;
  return this;
}

uint64_t metadata_visitor::Visitor::getValueFor@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (!(_BYTE)a3 || !*(_BYTE *)(result + 24)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  *a4 = *(void *)(result + 8) + a2 - *(void *)(result + 16);
  a4[1] = a2;
  a4[2] = a3;
  return result;
}

uint64_t metadata_visitor::Visitor::resolveRebase@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = **a2;
  if (v3)
  {
    if (!*(_BYTE *)(this + 24)) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v4 = v3 - *(void *)(this + 8) + *(void *)(this + 16);
    *a3 = v3;
    a3[1] = v4;
    a3[2] = 1LL;
  }

  else
  {
    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
  }

  return this;
}

uint64_t metadata_visitor::Visitor::resolveBindOrRebase@<X0>( uint64_t this@<X0>, uint64_t **a2@<X1>, BOOL *x2_0@<X2>, void *a3@<X8>)
{
  *x2_0 = 0;
  return metadata_visitor::Visitor::resolveRebase(this, a2, a3);
}

uint64_t metadata_visitor::Visitor::resolveOptionalRebase@<X0>( uint64_t this@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = **a2;
  if (v3)
  {
    if (!*(_BYTE *)(this + 24)) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v4 = v3 - *(void *)(this + 8) + *(void *)(this + 16);
    *(void *)a3 = v3;
    *(void *)(a3 + 8) = v4;
    LOBYTE(dyld4::RemoteNotificationResponder::sendMessage((uint64_t)this, 12288, 0x18u, v3) = 1;
    *(void *)(a3 + 16) = 1LL;
  }

  else
  {
    *(_BYTE *)a3 = 0;
  }

  *(_BYTE *)(a3 + 24) = v3;
  return this;
}

void Diagnostics::Diagnostics(Diagnostics *this)
{
  *(void *)this = 0LL;
}

vm_address_t *Diagnostics::clearError(vm_address_t **this)
{
  uint64_t result = *this;
  if (result) {
    uint64_t result = _simple_sfree(result);
  }
  *this = 0LL;
  return result;
}

uint64_t Diagnostics::error(vm_address_t *this, char *a2, ...)
{
  return Diagnostics::error(this, a2, va);
}

uint64_t Diagnostics::error(vm_address_t *this, char *__s, char *a3)
{
  vm_address_t v6 = *this;
  if (!v6)
  {
    vm_address_t v6 = _simple_salloc();
    *this = v6;
  }

  return _simple_vsprintf(v6, __s, (int *)a3);
}

uint64_t Diagnostics::appendError(vm_address_t *this, char *__s, ...)
{
  uint64_t v4 = *this;
  if (v4) {
    _simple_sresize(v4);
  }
  return Diagnostics::error(this, __s, va);
}

BOOL Diagnostics::hasError(Diagnostics *this)
{
  return *(void *)this != 0LL;
}

BOOL Diagnostics::noError(Diagnostics *this)
{
  return *(void *)this == 0LL;
}

Diagnostics *Diagnostics::assertNoError(Diagnostics *this)
{
  if (*(void *)this) {
    Diagnostics::assertNoError(this);
  }
  return this;
}

void *Diagnostics::errorMessage(Diagnostics *this)
{
  vm_address_t v1 = *(_BYTE ***)this;
  if (v1) {
    return (void *)_simple_string(v1);
  }
  else {
    return &unk_1800BA999;
  }
}

void *mach_o::Platform::Platform(void *this, int a2)
{
  uint64_t v2 = 0LL;
  *this = 0LL;
  while (1)
  {
    uint64_t v3 = mach_o::PlatformInfo::knownPlatformInfos[v2];
    int v4 = *((_DWORD *)v3 + 2);
    if (!v4) {
      mach_o::Platform::Platform();
    }
    if (v4 == a2) {
      break;
    }
    if (++v2 == 31) {
      return this;
    }
  }

  *this = v3;
  return this;
}

BOOL mach_o::Platform::isExclaveKit(mach_o::Platform *this)
{
  return *(void *)this && *(_BYTE *)(*(void *)this + 50LL) != 0;
}

void mach_o::PlatformAndVersions::zip(uint64_t *a1@<X0>, uint64_t *a2@<X1>, mach_o::Error *a3@<X8>)
{
  if (!*a1)
  {
    *a1 = *a2;
LABEL_11:
    __int128 v8 = *(_OWORD *)(a2 + 1);
LABEL_12:
    *(_OWORD *)(a1 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v8;
LABEL_13:
    *(void *)a3 = 0LL;
    return;
  }

  if (*a2)
  {
    int v12 = 0LL;
  }

  else
  {
    mach_o::Error::Error((mach_o::Error *)&v12, "unknown platform");
    if (v12)
    {
      mach_o::Error::Error(a3, "can't zip with invalid platform");
      mach_o::Error::~Error(&v12);
      return;
    }
  }

  mach_o::Error::~Error(&v12);
  uint64_t v6 = *a1;
  uint64_t v7 = *a2;
  if (*a1 == *a2) {
    goto LABEL_11;
  }
  if ((_UNKNOWN **)v6 == &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((_UNKNOWN **)v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
    {
      *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
      goto LABEL_18;
    }

    goto LABEL_22;
  }

  if ((_UNKNOWN **)v7 != &mach_o::PlatformInfo_macOS::singleton)
  {
    if ((_UNKNOWN **)v6 == &mach_o::PlatformInfo_zippered::singleton)
    {
      if ((_UNKNOWN **)v7 == &mach_o::PlatformInfo_macCatalyst::singleton)
      {
        *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_18:
        a1[2] = a2[1];
        goto LABEL_13;
      }

      goto LABEL_22;
    }

    goto LABEL_21;
  }

  if ((_UNKNOWN **)v6 == &mach_o::PlatformInfo_macCatalyst::singleton)
  {
    __int128 v8 = *(_OWORD *)(a2 + 1);
    uint64_t v11 = a1[1];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
LABEL_30:
    *((void *)&v8 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
    goto LABEL_12;
  }

  if ((_UNKNOWN **)v6 == &mach_o::PlatformInfo_zippered::singleton)
  {
    __int128 v8 = *(_OWORD *)(a2 + 1);
    uint64_t v11 = a1[2];
    *a1 = (uint64_t)&mach_o::PlatformInfo_zippered::singleton;
    goto LABEL_30;
  }

uint64_t mach_o::PlatformInfo_macOS::versionForYear( mach_o::PlatformInfo_macOS *this, unsigned int a2, int a3)
{
  if (a2 == 2020) {
    char v3 = a3;
  }
  else {
    char v3 = 1;
  }
  if (a2 <= 0x7E4 && (v3 & 1) != 0)
  {
    if (a3) {
      int v4 = 655364;
    }
    else {
      int v4 = 655360;
    }
    return ((((_WORD)a2 - (_WORD)a3) << 8) + 11264) & 0xFF00 | v4;
  }

  else
  {
    unsigned int v6 = a2 - *((unsigned __int16 *)this + 27);
    if (a3) {
      int v7 = (*(unsigned __int8 (**)(mach_o::PlatformInfo_macOS *, void))(*(void *)this + 16LL))( this,  (unsigned __int16)--v6) << 8;
    }
    else {
      int v7 = 0;
    }
    return v7 | (v6 << 16);
  }

_WORD *mach_o::PlatformInfo_macOS::yearForVersion(_WORD *result, unsigned int a2, _WORD *a3, BOOL *a4)
{
  if (a2 < 0xB0000)
  {
    unsigned int v8 = (a2 + 16121856) >> 8;
    *a3 = v8 + 2004;
    *a4 = (a2 & 0xFC) != 0;
    if ((a2 & 0xFC) == 0) {
      return result;
    }
    __int16 v7 = v8 + 2003;
  }

  else
  {
    *a3 = result[27] + HIWORD(a2);
    unsigned int v6 = BYTE1(a2);
    uint64_t result = (_WORD *)(*(uint64_t (**)(_WORD *, void))(*(void *)result + 16LL))(result, HIWORD(a2));
    *a4 = v6 >= result;
    __int16 v7 = *a3 + 1;
  }

  *a3 = v7;
  return result;
}

uint64_t mach_o::PlatformInfo_macOS::minorVersionForSpring(mach_o::PlatformInfo_macOS *this, unsigned int a2)
{
  if (a2 < 0xE) {
    return 3LL;
  }
  else {
    return 4LL;
  }
}

uint64_t mach_o::PlatformInfo::versionForYear(mach_o::PlatformInfo *this, int a2, int a3)
{
  int v3 = a2 - *((unsigned __int16 *)this + 27);
  if (a3) {
    int v4 = (*(unsigned __int8 (**)(mach_o::PlatformInfo *, void))(*(void *)this + 16LL))( this,  (unsigned __int16)--v3) << 8;
  }
  else {
    int v4 = 0;
  }
  return v4 | (v3 << 16);
}

uint64_t mach_o::PlatformInfo::yearForVersion(_WORD *a1, int a2, _WORD *a3, BOOL *a4)
{
  *a3 = a1[27] + HIWORD(a2);
  unsigned int v6 = BYTE1(a2);
  uint64_t result = (*(uint64_t (**)(_WORD *, void))(*(void *)a1 + 16LL))(a1, HIWORD(a2));
  *a4 = v6 >= result;
  return result;
}

uint64_t mach_o::PlatformInfo::minorVersionForSpring(mach_o::PlatformInfo *this)
{
  return 4LL;
}

uint64_t mach_o::PlatformInfo_bridgeOS::minorVersionForSpring( mach_o::PlatformInfo_bridgeOS *this, unsigned int a2)
{
  if (a2 < 9) {
    return 3LL;
  }
  else {
    return 4LL;
  }
}

uint64_t mach_o::PlatformInfo_firmware::versionForYear(mach_o::PlatformInfo_firmware *this)
{
  return 0x10000LL;
}

void mach_o::PlatformInfo_firmware::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, _BYTE *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_sepOS::versionForYear(mach_o::PlatformInfo_sepOS *this)
{
  return 0x10000LL;
}

void mach_o::PlatformInfo_sepOS::yearForVersion(uint64_t a1, uint64_t a2, _WORD *a3, _BYTE *a4)
{
  *a3 = 2020;
  *a4 = 0;
}

uint64_t mach_o::PlatformInfo_visionOS::minorVersionForSpring(mach_o::PlatformInfo_visionOS *this, int a2)
{
  if (a2 == 1) {
    return 1LL;
  }
  else {
    return 4LL;
  }
}

uint64_t amfi_check_dyld_policy_self( uint64_t a1, unint64_t *a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!a2) {
    return 22LL;
  }
  *a2 = 0LL;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  v11[0] = a1;
  v11[1] = &v10;
  uint64_t result = __sandbox_ms("AMFI", (void *)0x5A, v11, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    uint64_t result = *__error();
  }
  *a2 = v10;
  return result;
}

uint32_t arc4random(void)
{
  int v0 = arc4_count;
  if (arc4_count > 0) {
    char v1 = rs_stired;
  }
  else {
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    arc4_stir();
    int v0 = arc4_count;
  }

  char v2 = rs;
  uint64_t v3 = (rs + 1);
  unsigned __int8 v4 = byte_18C509622[v3];
  char v5 = byte_18C509621 + v4;
  uint64_t v6 = (byte_18C509621 + v4);
  unsigned __int8 v7 = byte_18C509622[v6];
  byte_18C509622[v3] = v7;
  byte_18C509622[v6] = v4;
  int v8 = byte_18C509622[(v7 + v4)];
  uint64_t v9 = (v2 + 2);
  unsigned __int8 v10 = byte_18C509622[v9];
  unsigned __int8 v11 = v10 + v5;
  unsigned __int8 v12 = byte_18C509622[v11];
  byte_18C509622[v9] = v12;
  byte_18C509622[v11] = v10;
  int v13 = byte_18C509622[(v12 + v10)];
  uint64_t v14 = (v2 + 3);
  unsigned __int8 v15 = byte_18C509622[v14];
  unsigned __int8 v16 = v15 + v11;
  unsigned __int8 v17 = byte_18C509622[v16];
  byte_18C509622[v14] = v17;
  byte_18C509622[v16] = v15;
  int v18 = byte_18C509622[(v17 + v15)];
  rs = v2 + 4;
  uint64_t v19 = (v2 + 4);
  LOBYTE(v14) = byte_18C509622[v19];
  byte_18C509621 = v14 + v16;
  uint64_t v20 = (v14 + v16);
  unsigned __int8 v21 = byte_18C509622[v20];
  byte_18C509622[v19] = v21;
  byte_18C509622[v20] = v14;
  int v22 = byte_18C509622[(v21 + v14)];
  arc4_count = v0 - 4;
  os_unfair_lock_unlock(&arc4_lock);
  if ((v1 & 1) == 0)
  {
    arc4_fetch();
    rs_data_available = 1;
    __dmb(0xBu);
  }

  return (v8 << 24) | (v13 << 16) | (v18 << 8) | v22;
}

uint64_t arc4_fetch()
{
  uint64_t result = getentropy(&rdat, 0x80uLL);
  if ((_DWORD)result)
  {
    int v1 = open("/dev/random", 0, 0LL);
    if (v1 == -1 || (v2 = v1, unint64_t v3 = read(v1, &rdat, 0x80uLL), v3 == -1LL)) {
LABEL_8:
    }
      abort();
    unsigned __int8 v4 = (char *)&rdat;
    size_t v5 = 128LL;
    while (1)
    {
      BOOL v6 = v5 > v3;
      v5 -= v3;
      if (!v6) {
        return close(v2);
      }
      v4 += v3;
      unint64_t v3 = read(v2, v4, v5);
      if (v3 == -1LL) {
        goto LABEL_8;
      }
    }
  }

  return result;
}

uint64_t arc4_stir()
{
  if (!rs_data_available) {
    uint64_t result = arc4_fetch();
  }
  int v1 = 0;
  rs_data_available = 0;
  __dmb(0xBu);
  unsigned __int8 v2 = rs - 1;
  int v3 = byte_18C509621;
  do
  {
    int v4 = byte_18C509622[++v2];
    v3 += v4 + rdat[v1 & 0x7F];
    byte_18C509622[v2] = byte_18C509622[v3];
    byte_18C509622[v3] = v4;
    ++v1;
  }

  while (v1 != 256);
  int v5 = 1024;
  unsigned __int8 v6 = v2;
  do
  {
    unsigned __int8 v7 = byte_18C509622[++v6];
    v2 += v7;
    byte_18C509622[v6] = byte_18C509622[v2];
    byte_18C509622[v2] = v7;
    --v5;
  }

  while (v5);
  rs = v6;
  byte_18C509621 = v2;
  arc4_count = 1600000;
  rs_stired = 1;
  return result;
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  uint64_t v14 = 0x300000000LL;
  size_t v12 = 56LL;
  size_t v10 = _platform_strlen(a1);
  int result = __sysctl((int *)&v14, 2u, v13, &v12, (void *)a1, v10);
  if ((result & 0x80000000) == 0) {
    return __sysctl(v13, v12 >> 2, a2, a3, a4, a5);
  }
  return result;
}

char *__cdecl strrchr(const char *__s, int __c)
{
  int result = 0LL;
  int v4 = __s;
  do
  {
    int v6 = *v4++;
    int v5 = v6;
    __int128 __s = v4;
  }

  while (v5);
  return result;
}

const char *_subsystem_init(const char **a1)
{
  int result = _simple_getenv(a1, "subsystem_root_path");
  if (result) {
    subsystem_root_path = (uint64_t)result;
  }
  return result;
}

uint64_t open_with_subsystem(const char *a1, int a2)
{
  if ((a2 & 0x200) != 0)
  {
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v4 = open(a1, a2);
    if ((v4 & 0x80000000) != 0)
    {
      int v5 = __error();
      int v6 = (char *)subsystem_root_path;
      if (*v5 == 2 && subsystem_root_path != 0)
      {
        while (1)
        {
          next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
          if (strlcat(__dst, a1, 0x400uLL) > 0x3FF) {
            break;
          }
          uint64_t v4 = open(__dst, a2);
          if ((v4 & 0x80000000) == 0) {
            return v4;
          }
          __error();
          if (!next_subsystem_root_path) {
            return v4;
          }
          int v6 = next_subsystem_root_path;
        }

        *__error() = 63;
      }
    }
  }

  return v4;
}

_BYTE *extract_next_subsystem_root_path(void *a1, char *__s)
{
  size_t v4 = _platform_strlen(__s);
  int v5 = _platform_memchr(__s, 58, v4);
  if (v5) {
    size_t v4 = v5 - __s;
  }
  if (v4 > 0x3FF) {
    return 0LL;
  }
  unsigned __int8 v7 = v5;
  memmove(a1, __s, v4);
  *((_BYTE *)a1 + v4) = 0;
  if (v7) {
    return v7 + 1;
  }
  else {
    return 0LL;
  }
}

uint64_t stat_with_subsystem(const char *a1, stat *a2)
{
  uint64_t v4 = stat64(a1, a2);
  if ((v4 & 0x80000000) != 0)
  {
    int v5 = __error();
    int v6 = (char *)subsystem_root_path;
    if (*v5 == 2 && subsystem_root_path != 0)
    {
      while (1)
      {
        next_subsystem_root_path = extract_next_subsystem_root_path(__dst, v6);
        if (strlcat(__dst, a1, 0x400uLL) > 0x3FF) {
          break;
        }
        uint64_t v4 = stat64(__dst, a2);
        if ((v4 & 0x80000000) == 0) {
          return v4;
        }
        __error();
        if (!next_subsystem_root_path) {
          return v4;
        }
        int v6 = next_subsystem_root_path;
      }

      *__error() = 63;
    }
  }

  return v4;
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  size_t v4 = _platform_strlen(__s1);
  size_t v5 = _platform_strlen(__s2);
  memmove(&__s1[v4], __s2, v5 + 1);
  return __s1;
}

uint64_t _hello_payload_check()
{
  return 0LL;
}

uint64_t _hello_fire( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  pid_t v8 = getpid();
  getpid();
  dlog(-1, "libignition: %d: %12s: hello from %s.%d\n", v9, v10, v11, v12, v13, v14, v8);
  return 0LL;
}

uint64_t _open_console()
{
  uint64_t v0 = dword_18C435F00;
  if (dword_18C435F00 < 0 && getpid() == 1)
  {
    uint64_t v0 = open("/dev/console", 131073);
    dword_18C435F00 = v0;
  }

  return v0;
}

ssize_t dlog( int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return vdlog(a1, a2, &a9, a4, a5, a6, a7, a8);
}

ssize_t vdlog(int a1, char *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!__g) {
    dyld_halt("logging not yet initialized", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
  }
  ssize_t result = getpid();
  if ((int)result <= 1)
  {
    if (a1 < 0)
    {
      a1 = dword_18C435F04;
      if (dword_18C435F04 < 0) {
        a1 = _open_console();
      }
    }

    return _simple_vdprintf(a1, a2, a3);
  }

  return result;
}

int *log_destroy()
{
  return closefd_optional(&dword_18C435F00, (int)"console");
}

uint64_t closefd(int *a1, int a2)
{
  uint64_t result = close(*a1);
  if ((_DWORD)result)
  {
    unsafe = boot_get_unsafe();
    int v6 = (*unsafe)[1];
    unint64_t v7 = (unint64_t)(*unsafe)[2];
    int v8 = *__error();
    __error();
    ignition_halt(v6, v8, v7, "failed to close %s: fd = %d: %d", v9, v10, v11, v12, a2);
  }

  *a1 = -1;
  return result;
}

void ignition_halt( void *a1, int a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  unsafe = boot_get_unsafe();
  uint64_t v14 = configuration_unsafe();
  vm_address_t v15 = _simple_salloc();
  if (v15)
  {
    unsigned __int8 v17 = (_BYTE **)v15;
    _simple_vsprintf(v15, a4, &a9);
    unsigned __int8 v16 = (char *)_simple_string(v17);
  }

  else
  {
    unsigned __int8 v16 = "panic: [failed to allocate panic message]";
  }

  if (v14[7032])
  {
    int v18 = open("/dev/console", 1);
    if ((v18 & 0x80000000) == 0) {
      fsync(v18);
    }
    ignition_write_BRA_blob((const char ***)unsafe, v19, v16, a2);
  }

  abort_with_reason((void *)0x23, a1, v16, a3);
}

int *closefd_optional(int *result, int a2)
{
  if ((*result & 0x80000000) == 0)
  {
    int v3 = result;
    uint64_t result = (int *)close(*result);
    if ((_DWORD)result)
    {
      unsafe = boot_get_unsafe();
      size_t v5 = (*unsafe)[1];
      unint64_t v6 = (unint64_t)(*unsafe)[2];
      int v7 = *__error();
      __error();
      ignition_halt(v5, v7, v6, "failed to close %s [optional]: fd = %d: %d", v8, v9, v10, v11, a2);
    }

    *int v3 = -1;
  }

  return result;
}

ssize_t ignition_write_BRA_blob(const char ***a1, uint64_t a2, const char *a3, uint64_t a4)
{
  __int128 v16 = 0u;
  memset(v15, 0, sizeof(v15));
  HIBYTE(v16) = -86;
  strlcpy((char *)v15 + 2, **a1, 0x18uLL);
  strlcpy((char *)&v15[1] + 10, *a1[1], 0x18uLL);
  *(void *)((char *)&v15[3] + 2) = a4;
  strlcpy((char *)&v15[3] + 10, "AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE", 0x25uLL);
  strlcpy((char *)&v15[5] + 15, a3, 0x40uLL);
  ssize_t result = sysctlbyname("security.mac.img4.ignition_failure_blob", 0LL, 0LL, v15, 0xA0uLL);
  if ((_DWORD)result)
  {
    uint64_t v8 = __error();
    return _simple_dprintf(2, "failed to write BRA failure blob: %d\n", v9, v10, v11, v12, v13, v14, *v8);
  }

  return result;
}

uint64_t ignite()
{
  uint64_t v8 = 0LL;
  if (getpid() == 1)
  {
    close(0);
    close(1);
    close(2);
  }

  boot_destroy(&v8, v0, v1, v2, v3, v4, v5, v6);
  log_destroy();
  return 8LL;
}

int **jettison( int **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *result;
  if (*result)
  {
    uint64_t v9 = result;
    switch(*v8)
    {
      case 0:
        goto LABEL_7;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_5;
      case 3:
        goto LABEL_4;
      case 4:
        closefd_optional(v8 + 7, (int)"prereboot os graft point");
LABEL_4:
        closefd_optional(v8 + 6, (int)"group dir");
LABEL_5:
        closefd_optional(v8 + 4, (int)"os graft point");
        closefd_optional(v8 + 5, (int)"app graft point");
LABEL_6:
        closefd_optional(v8 + 3, (int)"xART");
LABEL_7:
        closefd_optional(v8 + 1, (int)"preboot");
        ssize_t result = (int **)closefd(v8 + 2, (int)"shared cache");
        const char *v9 = 0LL;
        break;
      default:
        dyld_halt("unsupported payload version: 0x%x", a2, a3, a4, a5, a6, a7, a8, *v8);
    }
  }

  return result;
}

char ***boot_get_unsafe()
{
  return __boot;
}

void *boot_destroy( void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *result;
  if (*result)
  {
    uint64_t v9 = result;
    for (uint64_t i = 0LL; i != 9; ++i)
    {
      uint64_t v11 = __roots[i];
      unint64_t v12 = (unint64_t)v11[2];
      if ((v12 & 0x8000000000000000LL) != 0) {
        dyld_halt("invalid offset: %lld", a2, a3, a4, a5, a6, a7, a8, (int)v11[2]);
      }
      closefd_optional((int *)(v8 + v12), (int)*v11);
    }

    ssize_t result = (void *)ignition_test_BRA(4LL);
    void *v9 = 0LL;
  }

  return result;
}

uint64_t configuration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _config;
  if (!_config) {
    dyld_halt("configuration not initialized", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return result;
}

void *configuration_unsafe()
{
  return &__config;
}

void dyld_halt( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  vm_address_t v10 = _simple_salloc();
  if (v10)
  {
    unint64_t v12 = (_BYTE **)v10;
    _simple_vsprintf(v10, a1, &a9);
    uint64_t v11 = (const char *)_simple_string(v12);
  }

  else
  {
    uint64_t v11 = "panic: [failed to allocate panic message]";
  }

  if (getpid() == 1) {
    syscall(55, 3072LL, v11);
  }
  qword_18C509748 = (uint64_t)v11;
  __break(1u);
}

uint64_t os_log_simple_type_from_asl(int a1)
{
  unsigned int v1 = a1 & ~(a1 >> 31);
  if (v1 >= 7) {
    unsigned int v1 = 7;
  }
  return os_log_simple_type_from_asl__level2ostype[v1];
}

uint64_t __os_log_simple_offset( uint64_t a1, char *a2, const void *a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = 0LL;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v25 = 0u;
  v24[0] = a6;
  v24[1] = a7;
  _OWORD v24[2] = a8;
  v24[3] = mach_continuous_time();
  pid_t v13 = getpid();
  *(void *)&__int128 v25 = v13;
  if (proc_pidinfo(v13, 17, 0LL, buffer, 56) == 56)
  {
    *((void *)&v25 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v32;
    *(void *)&__int128 v26 = v33;
    memmove((char *)&v28 + 8, buffer, 0x10uLL);
  }

  if (a1)
  {
    else {
      uint64_t v14 = a4;
    }
    *(void *)&__int128 v27 = a5 - v14;
    vm_address_t v15 = a2;
  }

  else
  {
    vm_address_t v15 = (char *)&v28 + 8;
  }

  memmove((char *)&v27 + 8, v15, 0x10uLL);
  memmove((char *)&v29 + 8, a3, 0x10uLL);
  return _os_log_simple_send((uint64_t)v24, v16, v17, v18, v19, v20, v21, v22);
}

uint64_t _os_log_simple_send( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  int fd = _simple_asl_get_fd(a1, a2, a3, a4, a5, a6, a7, a8);
  if (fd < 0) {
    return 9LL;
  }
  if ((MEMORY[0xFFFFFC105] & 4) != 0) {
    return 0LL;
  }
  int v10 = fd;
  size_t v11 = _platform_strlen(*(const char **)(a1 + 16)) + 1;
  unint64_t v12 = *(const char **)(a1 + 8);
  if (v12) {
    size_t v13 = _platform_strlen(v12) + 1;
  }
  else {
    size_t v13 = 0LL;
  }
  size_t v15 = v13 + v11 + 104;
  BOOL v16 = __CFADD__(v13, v11 + 104);
  uint64_t result = 84LL;
  if (v11 < 0xFFFFFFFFFFFFFF98LL && !v16)
  {
    if (v15 <= 0x800)
    {
      v18[0] = v11;
      v18[1] = v13;
      char v19 = *(_BYTE *)a1;
      __int128 v20 = *(_OWORD *)(a1 + 24);
      __int128 v21 = *(_OWORD *)(a1 + 40);
      __int128 v22 = *(_OWORD *)(a1 + 56);
      memmove(&v23, (const void *)(a1 + 72), 0x10uLL);
      memmove(&v24, (const void *)(a1 + 88), 0x10uLL);
      memmove(&v25, (const void *)(a1 + 104), 0x10uLL);
      _platform_strlcpy(v26, *(char **)(a1 + 16), v11);
      if (v13) {
        _platform_strlcpy(&v26[v11], *(char **)(a1 + 8), v13);
      }
      unint64_t v17 = sendto(v10, v18, v15, 0, 0LL, 0);
      if ((v17 & 0x8000000000000000LL) != 0)
      {
        return *__error();
      }

      else if (v17 >= v15)
      {
        return 0LL;
      }

      else
      {
        return 40LL;
      }
    }

    else
    {
      return 7LL;
    }
  }

  return result;
}

uint64_t _os_log_simple_shim(unsigned __int8 a1, uint64_t a2, uint64_t a3)
{
  return __os_log_simple_offset(0LL, UUID_NULL, UUID_NULL, 0LL, 0LL, a1, a2, a3);
}

const char *_simple_getenv(const char **a1, char *__s)
{
  size_t v4 = _platform_strlen(__s);
  if (!a1) {
    return 0LL;
  }
  size_t v5 = v4;
  uint64_t result = *a1;
  if (!*a1) {
    return result;
  }
  while (1)
  {
    if (_platform_strlen(result) >= v5)
    {
      int v7 = *a1;
      if (v5)
      {
        size_t v8 = v5;
        uint64_t v9 = *a1;
        int v10 = __s;
        while (*(unsigned __int8 *)v9 == *v10)
        {
          ++v10;
          ++v9;
          if (!--v8) {
            goto LABEL_8;
          }
        }

        goto LABEL_9;
      }

uint64_t _simple_asl_connect()
{
  uint64_t v0 = socket(1, 2, 0);
  uint64_t v1 = v0;
  if ((_DWORD)v0 != -1)
  {
    fcntl(v0, 2, 1LL);
    v5.sa_family = 1;
    size_t v2 = _platform_strlen("/var/run/syslog");
    if (v2 + 1 < 0x68) {
      size_t v3 = v2 + 1;
    }
    else {
      size_t v3 = 104LL;
    }
    memmove(v5.sa_data, "/var/run/syslog", v3);
    if (connect(v1, &v5, 0x6Au) == -1)
    {
      close(v1);
      return 0xFFFFFFFFLL;
    }
  }

  return v1;
}

uint64_t _simple_asl_get_fd( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_18C509B80 == -1) {
    unint64_t v8 = qword_18C509B88;
  }
  else {
    unint64_t v8 = _os_alloc_once( (unint64_t *)&qword_18C509B80,  32LL,  (uint64_t)_simple_asl_init_context,  a4,  a5,  a6,  a7,  a8);
  }
  if (!*(_BYTE *)v8) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v8 + 24) != -1LL) {
    _os_once( (unint64_t *)(v8 + 24),  0LL,  (uint64_t (*)(uint64_t))_simple_asl_connect_once,  a4,  a5,  a6,  a7,  a8);
  }
  return *(unsigned int *)(v8 + 16);
}

void _simple_asl_connect_once( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_18C509B80 == -1) {
    unint64_t v8 = qword_18C509B88;
  }
  else {
    unint64_t v8 = _os_alloc_once( (unint64_t *)&qword_18C509B80,  32LL,  (uint64_t)_simple_asl_init_context,  a4,  a5,  a6,  a7,  a8);
  }
  if (*(_DWORD *)(v8 + 16) == -1) {
    *(_DWORD *)(v8 + 16) = _simple_asl_connect();
  }
}

uint64_t _simple_asl_log(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  if (qword_18C509B80 != -1) {
    _os_alloc_once((unint64_t *)&qword_18C509B80, 32LL, (uint64_t)_simple_asl_init_context, a4, a5, a6, a7, a8);
  }
  unsigned __int8 v11 = os_log_simple_type_from_asl(a1);
  return _os_log_simple_shim(v11, a2, a3);
}

uint64_t _simple_asl_init_context(uint64_t result)
{
  *(void *)(result + 8) = "unknown";
  *(_DWORD *)(result + 16) = -1;
  return result;
}

ssize_t _simple_vdprintf(int a1, char *__s, int *a3)
{
  int v6 = a1;
  v5[0] = v4;
  v5[1] = v4;
  v5[2] = v5;
  int v7 = _flush_reset;
  __simple_bprintf((uint64_t)v5, 0LL, __s, a3);
  return _flush((ssize_t)v5);
}

ssize_t _flush_reset(void *a1)
{
  ssize_t result = _flush((ssize_t)a1);
  a1[1] = *a1;
  return result;
}

uint64_t __simple_bprintf(uint64_t result, uint64_t (*a2)(uint64_t), char *__s, int *a4)
{
  if (!*__s) {
    return result;
  }
  size_t v4 = __s;
  uint64_t v6 = result;
  do
  {
    ssize_t result = (uint64_t)_platform_strchr(v4, 37);
    if (!result)
    {
      while (1)
      {
        char v85 = *v4;
        if (!*v4) {
          break;
        }
        if (a2 && (ssize_t result = a2(*(unsigned __int8 *)v4)) != 0)
        {
          char v80 = *(_BYTE *)result;
          if (*(_BYTE *)result)
          {
            uint64_t v81 = (unsigned __int8 *)(result + 1);
            do
            {
              uint64_t v82 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v82 >= *(void *)(v6 + 16))
              {
                ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                uint64_t v82 = *(_BYTE **)(v6 + 8);
              }

              *(void *)(v6 + 8) = v82 + 1;
              _BYTE *v82 = v80;
              int v83 = *v81++;
              char v80 = v83;
            }

            while (v83);
          }
        }

        else
        {
          uint64_t v84 = *(char **)(v6 + 8);
          if ((unint64_t)v84 >= *(void *)(v6 + 16))
          {
            ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            uint64_t v84 = *(char **)(v6 + 8);
          }

          *(void *)(v6 + 8) = v84 + 1;
          char *v84 = v85;
        }

        ++v4;
      }

      return result;
    }

    uint64_t v7 = result;
    uint64_t v8 = result - (void)v4;
    if (result - (uint64_t)v4 >= 1)
    {
      do
      {
        unsigned int v10 = *(unsigned __int8 *)v4++;
        uint64_t v9 = v10;
        if (a2 && (ssize_t result = a2(v9)) != 0)
        {
          char v11 = *(_BYTE *)result;
          if (*(_BYTE *)result)
          {
            unint64_t v12 = (unsigned __int8 *)(result + 1);
            do
            {
              size_t v13 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v13 >= *(void *)(v6 + 16))
              {
                ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                size_t v13 = *(_BYTE **)(v6 + 8);
              }

              *(void *)(v6 + 8) = v13 + 1;
              _BYTE *v13 = v11;
              int v14 = *v12++;
              char v11 = v14;
            }

            while (v14);
          }
        }

        else
        {
          size_t v15 = *(_BYTE **)(v6 + 8);
          if ((unint64_t)v15 >= *(void *)(v6 + 16))
          {
            ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
            size_t v15 = *(_BYTE **)(v6 + 8);
          }

          *(void *)(v6 + 8) = v15 + 1;
          *size_t v15 = v9;
        }

        BOOL v16 = v8-- <= 1;
      }

      while (!v16);
    }

    unint64_t v17 = (const char *)(v7 + 1);
    if (*(_BYTE *)(v7 + 1) == 37)
    {
      if (a2 && (ssize_t result = a2(37LL)) != 0)
      {
        char v18 = *(_BYTE *)result;
        if (*(_BYTE *)result)
        {
          char v19 = (unsigned __int8 *)(result + 1);
          do
          {
            __int128 v20 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v20 >= *(void *)(v6 + 16))
            {
              ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              __int128 v20 = *(_BYTE **)(v6 + 8);
            }

            *(void *)(v6 + 8) = v20 + 1;
            _BYTE *v20 = v18;
            int v21 = *v19++;
            char v18 = v21;
          }

          while (v21);
        }
      }

      else
      {
        uint64_t v30 = *(_BYTE **)(v6 + 8);
        if ((unint64_t)v30 >= *(void *)(v6 + 16))
        {
          ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
          uint64_t v30 = *(_BYTE **)(v6 + 8);
        }

        *(void *)(v6 + 8) = v30 + 1;
        _BYTE *v30 = 37;
      }

      size_t v4 = (const char *)(v7 + 2);
      continue;
    }

    ssize_t result = _platform_strncmp((const char *)(v7 + 1), ".*s", 3uLL);
    if (!(_DWORD)result)
    {
LABEL_44:
      uint64_t v31 = a4;
      int v32 = *a4;
      a4 += 4;
      if (v32 >= 1)
      {
        int v33 = (unsigned __int8 *)*((void *)v31 + 1);
        do
        {
          unsigned int v35 = *v33++;
          uint64_t v34 = v35;
          if (a2 && (ssize_t result = a2(v34)) != 0)
          {
            char v36 = *(_BYTE *)result;
            if (*(_BYTE *)result)
            {
              uint64_t v37 = (unsigned __int8 *)(result + 1);
              do
              {
                int v38 = *(_BYTE **)(v6 + 8);
                if ((unint64_t)v38 >= *(void *)(v6 + 16))
                {
                  ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  int v38 = *(_BYTE **)(v6 + 8);
                }

                *(void *)(v6 + 8) = v38 + 1;
                *int v38 = v36;
                int v39 = *v37++;
                char v36 = v39;
              }

              while (v39);
            }
          }

          else
          {
            uint64_t v40 = *(_BYTE **)(v6 + 8);
            if ((unint64_t)v40 >= *(void *)(v6 + 16))
            {
              ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
              uint64_t v40 = *(_BYTE **)(v6 + 8);
            }

            *(void *)(v6 + 8) = v40 + 1;
            *uint64_t v40 = v34;
          }

          BOOL v16 = v32-- <= 1;
        }

        while (!v16);
      }

      v17 += 2;
      goto LABEL_148;
    }

    int v22 = 0;
    int v23 = 0;
    int v24 = 0;
    while (1)
    {
      int v25 = *v17;
      int v26 = *(unsigned __int8 *)v17;
      if (v25 > 98)
      {
        switch(*v17)
        {
          case 'c':
            if (v24 >= 2)
            {
              if (v23) {
                uint64_t v42 = 48LL;
              }
              else {
                uint64_t v42 = 32LL;
              }
              do
              {
                if (a2 && (ssize_t result = a2(v42)) != 0)
                {
                  char v43 = *(_BYTE *)result;
                  if (*(_BYTE *)result)
                  {
                    uint64_t v44 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      int v45 = *(_BYTE **)(v6 + 8);
                      if ((unint64_t)v45 >= *(void *)(v6 + 16))
                      {
                        ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        int v45 = *(_BYTE **)(v6 + 8);
                      }

                      *(void *)(v6 + 8) = v45 + 1;
                      _BYTE *v45 = v43;
                      int v46 = *v44++;
                      char v43 = v46;
                    }

                    while (v46);
                  }
                }

                else
                {
                  uint64_t v47 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v47 >= *(void *)(v6 + 16))
                  {
                    ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    uint64_t v47 = *(_BYTE **)(v6 + 8);
                  }

                  *(void *)(v6 + 8) = v47 + 1;
                  *uint64_t v47 = v42;
                }

                BOOL v16 = v24-- <= 2;
              }

              while (!v16);
            }

            uint64_t v48 = a4;
            a4 += 2;
            int v49 = *v48;
            if (a2 && (ssize_t result = a2(*v48)) != 0)
            {
              char v50 = *(_BYTE *)result;
              if (*(_BYTE *)result)
              {
                uint64_t v51 = (unsigned __int8 *)(result + 1);
                do
                {
                  uint64_t v52 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v52 >= *(void *)(v6 + 16))
                  {
                    ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    uint64_t v52 = *(_BYTE **)(v6 + 8);
                  }

                  *(void *)(v6 + 8) = v52 + 1;
                  *uint64_t v52 = v50;
                  int v53 = *v51++;
                  char v50 = v53;
                }

                while (v53);
              }
            }

            else
            {
              uint64_t v78 = *(_BYTE **)(v6 + 8);
              if ((unint64_t)v78 >= *(void *)(v6 + 16))
              {
                ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                uint64_t v78 = *(_BYTE **)(v6 + 8);
              }

              *(void *)(v6 + 8) = v78 + 1;
              _BYTE *v78 = v49;
            }

            break;
          case 'd':
          case 'i':
            a4 += 2;
            ssize_t result = (uint64_t)dec((std::ios_base *)v6);
            break;
          case 'l':
            ++v22;
            ++v17;
            goto LABEL_32;
          case 'o':
            a4 += 2;
            ssize_t result = (uint64_t)oct((std::ios_base *)v6);
            break;
          case 'p':
            a4 += 2;
            int v41 = (std::ios_base *)v6;
            goto LABEL_90;
          case 's':
            int v54 = (const char **)a4;
            a4 += 2;
            uint64_t v55 = *v54;
            if (v55) {
              uint64_t v56 = v55;
            }
            else {
              uint64_t v56 = "(null)";
            }
            ssize_t result = _platform_strlen(v56);
            int v57 = v24 - result;
            if (v24 - (int)result >= 1)
            {
              if (v23) {
                uint64_t v58 = 48LL;
              }
              else {
                uint64_t v58 = 32LL;
              }
              do
              {
                if (a2 && (ssize_t result = a2(v58)) != 0)
                {
                  char v59 = *(_BYTE *)result;
                  if (*(_BYTE *)result)
                  {
                    uint64_t v60 = (unsigned __int8 *)(result + 1);
                    do
                    {
                      uint64_t v61 = *(_BYTE **)(v6 + 8);
                      if ((unint64_t)v61 >= *(void *)(v6 + 16))
                      {
                        ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                        uint64_t v61 = *(_BYTE **)(v6 + 8);
                      }

                      *(void *)(v6 + 8) = v61 + 1;
                      *uint64_t v61 = v59;
                      int v62 = *v60++;
                      char v59 = v62;
                    }

                    while (v62);
                  }
                }

                else
                {
                  uint64_t v63 = *(_BYTE **)(v6 + 8);
                  if ((unint64_t)v63 >= *(void *)(v6 + 16))
                  {
                    ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                    uint64_t v63 = *(_BYTE **)(v6 + 8);
                  }

                  *(void *)(v6 + 8) = v63 + 1;
                  _BYTE *v63 = v58;
                }

                BOOL v16 = v57-- <= 1;
              }

              while (!v16);
            }

            while (1)
            {
              char v69 = *v56;
              if (!*v56) {
                break;
              }
              if (a2 && (ssize_t result = a2(*(unsigned __int8 *)v56)) != 0)
              {
                char v64 = *(_BYTE *)result;
                if (*(_BYTE *)result)
                {
                  uint64_t v65 = (unsigned __int8 *)(result + 1);
                  do
                  {
                    uint64_t v66 = *(_BYTE **)(v6 + 8);
                    if ((unint64_t)v66 >= *(void *)(v6 + 16))
                    {
                      ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                      uint64_t v66 = *(_BYTE **)(v6 + 8);
                    }

                    *(void *)(v6 + 8) = v66 + 1;
                    *uint64_t v66 = v64;
                    int v67 = *v65++;
                    char v64 = v67;
                  }

                  while (v67);
                }
              }

              else
              {
                uint64_t v68 = *(char **)(v6 + 8);
                if ((unint64_t)v68 >= *(void *)(v6 + 16))
                {
                  ssize_t result = (*(uint64_t (**)(uint64_t))(v6 + 32))(v6);
                  uint64_t v68 = *(char **)(v6 + 8);
                }

                *(void *)(v6 + 8) = v68 + 1;
                char *v68 = v69;
              }

              ++v56;
            }

            break;
          case 'u':
            uint64_t v70 = (unint64_t *)a4;
            a4 += 2;
            if (v22) {
              unint64_t v71 = *v70;
            }
            else {
              unint64_t v71 = *(unsigned int *)v70;
            }
            ssize_t result = (uint64_t)udec(v6, a2, v71, v24, v23);
            break;
          case 'x':
            goto LABEL_62;
          case 'y':
            uint64_t v72 = (unint64_t *)a4;
            a4 += 2;
            if (v22) {
              unint64_t v73 = *v72;
            }
            else {
              unint64_t v73 = *(unsigned int *)v72;
            }
            ssize_t result = (uint64_t)ydec(v6, a2, v73, v24, v23);
            break;
          default:
            goto LABEL_130;
        }

        goto LABEL_148;
      }

LABEL_148:
    size_t v4 = v17 + 1;
  }

  while (*v4);
  return result;
}

ssize_t _flush(ssize_t result)
{
  uint64_t v1 = *(char **)result;
  int64_t v2 = *(void *)(result + 8) - *(void *)result;
  if (v2 >= 1)
  {
    ssize_t v3 = result;
    while (1)
    {
      while (1)
      {
        ssize_t result = write(*(_DWORD *)(v3 + 24), v1, v2);
        if (result < 0) {
          break;
        }
        BOOL v4 = v2 <= result;
        v2 -= result;
        v1 += v2;
        if (v4) {
          return result;
        }
      }

      if (*__error() != 4)
      {
        ssize_t result = (ssize_t)__error();
        if (*(_DWORD *)result != 35) {
          break;
        }
      }
    }
  }

  return result;
}

ssize_t _simple_dprintf( int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  return _simple_vdprintf(a1, a2, &a9);
}

vm_address_t _simple_salloc()
{
  if (vm_allocate(mach_task_self_, &address, vm_page_size, 1)) {
    return 0LL;
  }
  vm_address_t v1 = address + 40;
  *(void *)vm_address_t address = address + 40;
  vm_address_t result = address;
  vm_address_t v2 = address + vm_page_size - 1;
  *(void *)(address + 8) = v1;
  *(void *)(result + 16) = v2;
  *(void *)(result + 32) = _enlarge;
  return result;
}

void *_enlarge(uint64_t a1)
{
  kern_return_t v6;
  vm_size_t v7;
  vm_address_t v8;
  vm_size_t v9;
  vm_address_t address;
  vm_address_t v2 = (vm_size_t *)(a1 + 16);
  vm_address_t address = *(void *)(a1 + 16) + 1LL;
  vm_address_t result = (void *)vm_allocate(mach_task_self_, &address, vm_page_size, 0);
  if ((_DWORD)result)
  {
    size_t v4 = *(void *)(a1 + 16) - *(void *)a1 + 1LL;
    vm_size_t v5 = (v4 + vm_page_size) & -(uint64_t)vm_page_size;
    uint64_t v6 = vm_allocate(mach_task_self_, &address, v5, 1);
    if (v6) {
      _enlarge_cold_1(v6);
    }
    uint64_t v7 = address - *(void *)a1;
    vm_address_t result = memmove((void *)address, *(const void **)a1, v4);
    uint64_t v8 = *(void *)a1;
    if (((vm_page_size - 1) & *(void *)a1) != 0)
    {
      v4 &= -(uint64_t)vm_page_size;
      uint64_t v8 = (v8 + vm_page_size) & -(uint64_t)vm_page_size;
      *(void *)a1 = v8;
      uint64_t v9 = v5 + address - 1;
    }

    else
    {
      uint64_t v9 = *v2 + vm_page_size + v7;
    }

    vm_size_t *v2 = v9;
    if (v4) {
      vm_address_t result = (void *)vm_deallocate(mach_task_self_, v8, v4);
    }
    *(void *)a1 = address;
    vm_address_t v2 = (vm_size_t *)(a1 + 8);
  }

  else
  {
    uint64_t v7 = vm_page_size;
  }

  *v2 += v7;
  return result;
}

uint64_t _simple_vsprintf(uint64_t a1, char *__s, int *a3)
{
  return 0LL;
}

uint64_t _simple_string(_BYTE **a1)
{
  *a1[1] = 0;
  return (uint64_t)*a1;
}

size_t _simple_sresize(uint64_t a1)
{
  vm_address_t v2 = *(const char **)a1;
  size_t result = _platform_strlen(*(const char **)a1);
  *(void *)(a1 + 8) = &v2[result];
  return result;
}

vm_address_t *_simple_sfree(vm_address_t *address)
{
  if (address)
  {
    vm_address_t v1 = (vm_address_t)address;
    if (((vm_page_size - 1) & *address) != 0)
    {
      uint64_t v2 = address[2] - (void)address + 1;
    }

    else
    {
      vm_deallocate(mach_task_self_, *address, address[2] - *address + 1);
      uint64_t v2 = vm_page_size;
    }

    return (vm_address_t *)vm_deallocate(mach_task_self_, v1, v2);
  }

  return address;
}

std::ios_base *__cdecl dec(std::ios_base *__str)
{
  vm_size_t v5 = v1;
  int v7 = (v2 >> 63) + v3;
  unint64_t v8 = (unint64_t)v2 >> 63;
  char v39 = 0;
  if (v2)
  {
    uint64_t v9 = &v39;
    if (v2 >= 0) {
      unint64_t v10 = v2;
    }
    else {
      unint64_t v10 = -v2;
    }
    do
    {
      *--uint64_t v9 = (v10 % 0xA) | 0x30;
      BOOL v11 = v10 >= 0xA;
      v10 /= 0xAuLL;
    }

    while (v11);
    BOOL v12 = v4 != 0;
    if (v2 < 0 && v4)
    {
      if (v1 && (size_t v13 = (_BYTE *)v1(45LL)) != 0LL)
      {
        LODWORD(v8) = *v13;
        if (*v13)
        {
          int v14 = v13 + 1;
          do
          {
            size_t v15 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v15 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              size_t v15 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v15 + 1;
            *size_t v15 = v8;
            int v16 = *v14++;
            LODWORD(v8) = v16;
          }

          while (v16);
        }
      }

      else
      {
        unint64_t v17 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v17 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          unint64_t v17 = *(_BYTE **)&__str->__fmtflags_;
        }

        LODWORD(v8) = 0;
        *(void *)&__str->__fmtflags_ = v17 + 1;
        *unint64_t v17 = 45;
      }

      BOOL v12 = 1;
    }
  }

  else
  {
    uint64_t v9 = &v38;
    char v38 = 48;
    BOOL v12 = v4 != 0;
  }

  size_t result = (std::ios_base *)_platform_strlen(v9);
  uint64_t v19 = v7 - (void)result;
  if (v19 >= 1)
  {
    if (v12) {
      uint64_t v20 = 48LL;
    }
    else {
      uint64_t v20 = 32LL;
    }
    do
    {
      if (v5 && (size_t result = (std::ios_base *)v5(v20)) != 0LL)
      {
        char v21 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          int v22 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            int v23 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v23 >= __str->__precision_)
            {
              size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              int v23 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v23 + 1;
            _BYTE *v23 = v21;
            int v24 = *v22++;
            char v21 = v24;
          }

          while (v24);
        }
      }

      else
      {
        int v25 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v25 >= __str->__precision_)
        {
          size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          int v25 = *(_BYTE **)&__str->__fmtflags_;
        }

        *(void *)&__str->__fmtflags_ = v25 + 1;
        *int v25 = v20;
      }
    }

    while (v19-- > 1);
  }

  if ((_DWORD)v8)
  {
    if (v5 && (size_t result = (std::ios_base *)v5(45LL)) != 0LL)
    {
      char v27 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        int v28 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          int v29 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v29 >= __str->__precision_)
          {
            size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            int v29 = *(_BYTE **)&__str->__fmtflags_;
          }

          *(void *)&__str->__fmtflags_ = v29 + 1;
          _BYTE *v29 = v27;
          int v30 = *v28++;
          char v27 = v30;
        }

        while (v30);
      }
    }

    else
    {
      uint64_t v31 = *(_BYTE **)&__str->__fmtflags_;
      if ((unint64_t)v31 >= __str->__precision_)
      {
        size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        uint64_t v31 = *(_BYTE **)&__str->__fmtflags_;
      }

      *(void *)&__str->__fmtflags_ = v31 + 1;
      _BYTE *v31 = 45;
    }
  }

  while (1)
  {
    char v37 = *v9;
    if (!*v9) {
      break;
    }
    if (v5 && (size_t result = (std::ios_base *)v5(*(unsigned __int8 *)v9)) != 0LL)
    {
      char v32 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        int v33 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          uint64_t v34 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v34 >= __str->__precision_)
          {
            size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            uint64_t v34 = *(_BYTE **)&__str->__fmtflags_;
          }

          *(void *)&__str->__fmtflags_ = v34 + 1;
          *uint64_t v34 = v32;
          int v35 = *v33++;
          char v32 = v35;
        }

        while (v35);
      }
    }

    else
    {
      char v36 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v36 >= __str->__precision_)
      {
        size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        char v36 = *(char **)&__str->__fmtflags_;
      }

      *(void *)&__str->__fmtflags_ = v36 + 1;
      *char v36 = v37;
    }

    ++v9;
  }

  return result;
}

std::ios_base *__cdecl oct(std::ios_base *__str)
{
  int v5 = v4;
  uint64_t v6 = v1;
  char v27 = 0;
  if (v2)
  {
    unint64_t v8 = &v27;
    do
    {
      *--unint64_t v8 = v2 & 7 | 0x30;
      BOOL v9 = v2 >= 8;
      v2 >>= 3;
    }

    while (v9);
  }

  else
  {
    unint64_t v8 = &v26;
    char v26 = 48;
  }

  uint64_t v10 = v3;
  size_t result = (std::ios_base *)_platform_strlen(v8);
  uint64_t v12 = v10 - (void)result;
  if (v12 >= 1)
  {
    if (v5) {
      uint64_t v13 = 48LL;
    }
    else {
      uint64_t v13 = 32LL;
    }
    do
    {
      if (v6 && (size_t result = (std::ios_base *)v6(v13)) != 0LL)
      {
        char v14 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          size_t v15 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            int v16 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v16 >= __str->__precision_)
            {
              size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              int v16 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v16 + 1;
            _BYTE *v16 = v14;
            int v17 = *v15++;
            char v14 = v17;
          }

          while (v17);
        }
      }

      else
      {
        char v18 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v18 >= __str->__precision_)
        {
          size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          char v18 = *(_BYTE **)&__str->__fmtflags_;
        }

        *(void *)&__str->__fmtflags_ = v18 + 1;
        *char v18 = v13;
      }
    }

    while (v12-- > 1);
  }

  while (1)
  {
    char v25 = *v8;
    if (!*v8) {
      break;
    }
    if (v6 && (size_t result = (std::ios_base *)v6(*(unsigned __int8 *)v8)) != 0LL)
    {
      char v20 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        char v21 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          int v22 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v22 >= __str->__precision_)
          {
            size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            int v22 = *(_BYTE **)&__str->__fmtflags_;
          }

          *(void *)&__str->__fmtflags_ = v22 + 1;
          _BYTE *v22 = v20;
          int v23 = *v21++;
          char v20 = v23;
        }

        while (v23);
      }
    }

    else
    {
      int v24 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v24 >= __str->__precision_)
      {
        size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        int v24 = *(char **)&__str->__fmtflags_;
      }

      *(void *)&__str->__fmtflags_ = v24 + 1;
      char *v24 = v25;
    }

    ++v8;
  }

  return result;
}

std::ios_base *__cdecl hex(std::ios_base *__str)
{
  int v7 = v4;
  int v8 = v3;
  BOOL v9 = v1;
  BOOL v11 = "0123456789ABCDEF";
  if (!v5) {
    BOOL v11 = "0123456789abcdef";
  }
  char v48 = 0;
  if (v2)
  {
    uint64_t v12 = &v48;
    do
    {
      *--uint64_t v12 = v11[v2 & 0xF];
      BOOL v13 = v2 >= 0x10;
      v2 >>= 4;
    }

    while (v13);
    if (!v6) {
      goto LABEL_23;
    }
  }

  else
  {
    uint64_t v12 = &v47;
    char v47 = 48;
    if (!v6)
    {
LABEL_23:
      char v23 = 1;
      goto LABEL_25;
    }
  }

  int v8 = v3 - 2;
  if (v4)
  {
    char v14 = (char *)&_0x;
    unsigned __int8 v15 = 48;
    do
    {
      if (v9 && (int v16 = (_BYTE *)v9(v15)) != 0LL)
      {
        char v17 = *v16;
        if (*v16)
        {
          char v18 = v16 + 1;
          do
          {
            uint64_t v19 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v19 >= __str->__precision_)
            {
              (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
              uint64_t v19 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v19 + 1;
            _BYTE *v19 = v17;
            int v20 = *v18++;
            char v17 = v20;
          }

          while (v20);
        }
      }

      else
      {
        char v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v21 >= __str->__precision_)
        {
          (*(void (**)(std::ios_base *))&__str->__rdstate_)(__str);
          char v21 = *(unsigned __int8 **)&__str->__fmtflags_;
        }

        *(void *)&__str->__fmtflags_ = v21 + 1;
        unsigned __int8 *v21 = v15;
      }

      unsigned __int8 v22 = *++v14;
      unsigned __int8 v15 = v22;
    }

    while (v14 != (char *)&unk_1800B916E);
    goto LABEL_23;
  }

  char v23 = 0;
LABEL_25:
  size_t result = (std::ios_base *)_platform_strlen(v12);
  int v25 = v8 - (_DWORD)result;
  if (v25 >= 1)
  {
    if (v7) {
      uint64_t v26 = 48LL;
    }
    else {
      uint64_t v26 = 32LL;
    }
    do
    {
      if (v9 && (size_t result = (std::ios_base *)v9(v26)) != 0LL)
      {
        char v27 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          int v28 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            int v29 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v29 >= __str->__precision_)
            {
              size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              int v29 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v29 + 1;
            _BYTE *v29 = v27;
            int v30 = *v28++;
            char v27 = v30;
          }

          while (v30);
        }
      }

      else
      {
        uint64_t v31 = *(_BYTE **)&__str->__fmtflags_;
        if ((unint64_t)v31 >= __str->__precision_)
        {
          size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          uint64_t v31 = *(_BYTE **)&__str->__fmtflags_;
        }

        *(void *)&__str->__fmtflags_ = v31 + 1;
        _BYTE *v31 = v26;
      }
    }

    while (v25-- > 1);
  }

  if ((v23 & 1) == 0)
  {
    int v33 = (char *)&_0x;
    unsigned __int8 v34 = 48;
    do
    {
      if (v9 && (size_t result = (std::ios_base *)v9(v34)) != 0LL)
      {
        char v35 = (char)result->__vftable;
        if (LOBYTE(result->__vftable))
        {
          char v36 = (unsigned __int8 *)&result->__vftable + 1;
          do
          {
            char v37 = *(_BYTE **)&__str->__fmtflags_;
            if ((unint64_t)v37 >= __str->__precision_)
            {
              size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
              char v37 = *(_BYTE **)&__str->__fmtflags_;
            }

            *(void *)&__str->__fmtflags_ = v37 + 1;
            *char v37 = v35;
            int v38 = *v36++;
            char v35 = v38;
          }

          while (v38);
        }
      }

      else
      {
        char v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        if ((unint64_t)v39 >= __str->__precision_)
        {
          size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
          char v39 = *(unsigned __int8 **)&__str->__fmtflags_;
        }

        *(void *)&__str->__fmtflags_ = v39 + 1;
        *char v39 = v34;
      }

      unsigned __int8 v40 = *++v33;
      unsigned __int8 v34 = v40;
    }

    while (v33 != (char *)&unk_1800B916E);
  }

  while (1)
  {
    char v46 = *v12;
    if (!*v12) {
      break;
    }
    if (v9 && (size_t result = (std::ios_base *)v9(*(unsigned __int8 *)v12)) != 0LL)
    {
      char v41 = (char)result->__vftable;
      if (LOBYTE(result->__vftable))
      {
        uint64_t v42 = (unsigned __int8 *)&result->__vftable + 1;
        do
        {
          char v43 = *(_BYTE **)&__str->__fmtflags_;
          if ((unint64_t)v43 >= __str->__precision_)
          {
            size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
            char v43 = *(_BYTE **)&__str->__fmtflags_;
          }

          *(void *)&__str->__fmtflags_ = v43 + 1;
          _BYTE *v43 = v41;
          int v44 = *v42++;
          char v41 = v44;
        }

        while (v44);
      }
    }

    else
    {
      int v45 = *(char **)&__str->__fmtflags_;
      if ((unint64_t)v45 >= __str->__precision_)
      {
        size_t result = (std::ios_base *)(*(uint64_t (**)(std::ios_base *))&__str->__rdstate_)(__str);
        int v45 = *(char **)&__str->__fmtflags_;
      }

      *(void *)&__str->__fmtflags_ = v45 + 1;
      char *v45 = v46;
    }

    ++v12;
  }

  return result;
}

_BYTE *udec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  char v27 = 0;
  if (a3)
  {
    int v8 = &v27;
    do
    {
      *--int v8 = (a3 % 0xA) | 0x30;
      BOOL v9 = a3 >= 0xA;
      a3 /= 0xAuLL;
    }

    while (v9);
  }

  else
  {
    int v8 = &v26;
    char v26 = 48;
  }

  uint64_t v10 = a4;
  size_t result = (_BYTE *)_platform_strlen(v8);
  uint64_t v12 = v10 - (void)result;
  if (v12 >= 1)
  {
    if (a5) {
      uint64_t v13 = 48LL;
    }
    else {
      uint64_t v13 = 32LL;
    }
    do
    {
      if (a2 && (size_t result = (_BYTE *)a2(v13)) != 0LL)
      {
        char v14 = *result;
        if (*result)
        {
          unsigned __int8 v15 = result + 1;
          do
          {
            int v16 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v16 >= *(void *)(a1 + 16))
            {
              size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              int v16 = *(_BYTE **)(a1 + 8);
            }

            *(void *)(a1 + 8) = v16 + 1;
            _BYTE *v16 = v14;
            int v17 = *v15++;
            char v14 = v17;
          }

          while (v17);
        }
      }

      else
      {
        char v18 = *(_BYTE **)(a1 + 8);
        if ((unint64_t)v18 >= *(void *)(a1 + 16))
        {
          size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          char v18 = *(_BYTE **)(a1 + 8);
        }

        *(void *)(a1 + 8) = v18 + 1;
        *char v18 = v13;
      }
    }

    while (v12-- > 1);
  }

  while (1)
  {
    char v25 = *v8;
    if (!*v8) {
      break;
    }
    if (a2 && (size_t result = (_BYTE *)a2(*(unsigned __int8 *)v8)) != 0LL)
    {
      char v20 = *result;
      if (*result)
      {
        char v21 = result + 1;
        do
        {
          unsigned __int8 v22 = *(_BYTE **)(a1 + 8);
          if ((unint64_t)v22 >= *(void *)(a1 + 16))
          {
            size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            unsigned __int8 v22 = *(_BYTE **)(a1 + 8);
          }

          *(void *)(a1 + 8) = v22 + 1;
          _BYTE *v22 = v20;
          int v23 = *v21++;
          char v20 = v23;
        }

        while (v23);
      }
    }

    else
    {
      int v24 = *(char **)(a1 + 8);
      if ((unint64_t)v24 >= *(void *)(a1 + 16))
      {
        size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
        int v24 = *(char **)(a1 + 8);
      }

      *(void *)(a1 + 8) = v24 + 1;
      char *v24 = v25;
    }

    ++v8;
  }

  return result;
}

_BYTE *ydec(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t a3, int a4, int a5)
{
  if (a3 < 0xA00000)
  {
    if (a3 >> 11 < 5)
    {
      size_t result = udec(a1, a2, a3, a4, a5);
      if (a2 && (size_t result = (_BYTE *)a2(98LL)) != 0LL)
      {
        char v24 = *result;
        if (*result)
        {
          char v25 = result + 1;
          do
          {
            char v26 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v26 >= *(void *)(a1 + 16))
            {
              size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              char v26 = *(_BYTE **)(a1 + 8);
            }

            *(void *)(a1 + 8) = v26 + 1;
            _BYTE *v26 = v24;
            int v27 = *v25++;
            char v24 = v27;
          }

          while (v27);
        }
      }

      else
      {
        int v28 = *(_BYTE **)(a1 + 8);
        if ((unint64_t)v28 >= *(void *)(a1 + 16))
        {
          size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          int v28 = *(_BYTE **)(a1 + 8);
        }

        *(void *)(a1 + 8) = v28 + 1;
        _BYTE *v28 = 98;
      }
    }

    else
    {
      size_t result = udec(a1, a2, (a3 + 512) >> 10, a4, a5);
      int v16 = "KB";
      unsigned __int8 v17 = 75;
      do
      {
        if (a2 && (size_t result = (_BYTE *)a2(v17)) != 0LL)
        {
          char v18 = *result;
          if (*result)
          {
            uint64_t v19 = result + 1;
            do
            {
              char v20 = *(_BYTE **)(a1 + 8);
              if ((unint64_t)v20 >= *(void *)(a1 + 16))
              {
                size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
                char v20 = *(_BYTE **)(a1 + 8);
              }

              *(void *)(a1 + 8) = v20 + 1;
              _BYTE *v20 = v18;
              int v21 = *v19++;
              char v18 = v21;
            }

            while (v21);
          }
        }

        else
        {
          unsigned __int8 v22 = *(unsigned __int8 **)(a1 + 8);
          if ((unint64_t)v22 >= *(void *)(a1 + 16))
          {
            size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
            unsigned __int8 v22 = *(unsigned __int8 **)(a1 + 8);
          }

          *(void *)(a1 + 8) = v22 + 1;
          unsigned __int8 *v22 = v17;
        }

        unsigned __int8 v23 = *++v16;
        unsigned __int8 v17 = v23;
      }

      while (v16 != "");
    }
  }

  else
  {
    size_t result = udec(a1, a2, (a3 + 0x80000) >> 20, a4, a5);
    int v8 = "MB";
    unsigned __int8 v9 = 77;
    do
    {
      if (a2 && (size_t result = (_BYTE *)a2(v9)) != 0LL)
      {
        char v10 = *result;
        if (*result)
        {
          BOOL v11 = result + 1;
          do
          {
            uint64_t v12 = *(_BYTE **)(a1 + 8);
            if ((unint64_t)v12 >= *(void *)(a1 + 16))
            {
              size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
              uint64_t v12 = *(_BYTE **)(a1 + 8);
            }

            *(void *)(a1 + 8) = v12 + 1;
            _BYTE *v12 = v10;
            int v13 = *v11++;
            char v10 = v13;
          }

          while (v13);
        }
      }

      else
      {
        char v14 = *(unsigned __int8 **)(a1 + 8);
        if ((unint64_t)v14 >= *(void *)(a1 + 16))
        {
          size_t result = (_BYTE *)(*(uint64_t (**)(uint64_t))(a1 + 32))(a1);
          char v14 = *(unsigned __int8 **)(a1 + 8);
        }

        *(void *)(a1 + 8) = v14 + 1;
        unsigned __int8 *v14 = v9;
      }

      unsigned __int8 v15 = *++v8;
      unsigned __int8 v9 = v15;
    }

    while (v8 != "");
  }

  return result;
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  unsigned int v5 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(&lock->_os_unfair_lock_opaque))
  {
    if (!__stxr(v5, &lock->_os_unfair_lock_opaque)) {
      return;
    }
  }

  __clrex();
  _os_unfair_lock_lock_slow(&lock->_os_unfair_lock_opaque, 0, 0LL, v5, v1, v2, v3, v4);
}

uint64_t _os_unfair_lock_lock_slow( unsigned int *a1, int a2, void *a3, unsigned int a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  if ((a2 & 0xFCFAFFFF) != 0)
  {
    qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Invalid options";
    qword_18C509778 = a2 & 0xFEFFFFFF;
    __break(1u);
LABEL_34:
    _os_unfair_lock_recursive_abort(v8);
  }

  unsigned int v8 = a4;
  int v12 = 0;
  do
  {
    while (1)
    {
      while (1)
      {
LABEL_3:
        unsigned int v13 = *a1;
        if (!*a1)
        {
          while (1)
          {
            unsigned int v13 = __ldaxr(a1);
            if (v13) {
              break;
            }
            if (!__stxr(v8 & ~v12, a1)) {
              return 1LL;
            }
          }

          __clrex();
        }

        int v14 = v13 | 1;
        BOOL v16 = (a2 & 0x1000000) == 0 || v14 != -1;
        if (v14 == v8 && v16) {
          goto LABEL_34;
        }
        if (v13 == (v13 & 0xFFFFFFFE)) {
          goto LABEL_23;
        }
        do
        {
          unsigned int v18 = __ldxr(a1);
          if (v18 != v13)
          {
            __clrex();
            goto LABEL_3;
          }
        }

        while (__stxr(v13 & 0xFFFFFFFE, a1));
        v13 &= ~1u;
LABEL_23:
        uint64_t result = __ulock_wait2((void *)(a2 | 0x1000002u), a1, (void *)v13, a3, 0LL, a6, a7, a8);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if ((_DWORD)result) {
          int v12 = 1;
        }
      }

      uint64_t v19 = -(int)result;
      if ((_DWORD)v19 != 4) {
        goto LABEL_38;
      }
    }
  }

  while ((_DWORD)v19 == 14);
  uint64_t result = 0LL;
  if ((_DWORD)v19 != 60)
  {
    if ((_DWORD)v19 == 105) {
      _os_unfair_lock_corruption_abort(v13);
    }
LABEL_38:
    qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait2 failure";
    qword_18C509778 = v19;
    __break(1u);
  }

  return result;
}

unsigned int *os_unfair_lock_lock_with_options( unsigned int *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unsigned int v8 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  while (!__ldaxr(result))
  {
    if (!__stxr(v8, result)) {
      return result;
    }
  }

  __clrex();
  return (unsigned int *)_os_unfair_lock_lock_slow(result, a2, 0LL, v8, a5, a6, a7, a8);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  int v6 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  do
    unsigned int v7 = __ldxr(&lock->_os_unfair_lock_opaque);
  while (__stlxr(0, &lock->_os_unfair_lock_opaque));
  if (v7 != v6) {
    _os_unfair_lock_unlock_slow(lock, v6, v7, v1, v2, v3, v4, v5);
  }
}

uint64_t _os_unfair_lock_unlock_slow( void *a1, int a2, unsigned int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = a3 | 1;
  if ((_DWORD)result != a2) {
    _os_unfair_lock_unowned_abort(result);
  }
  if ((a3 & 1) != 0)
  {
    uint64_t v10 = a3;
    qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_18C509778 = a3;
    __break(1u);
LABEL_9:
    qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_18C509778 = v10;
    __break(1u);
  }

  else
  {
    while (1)
    {
      uint64_t result = __ulock_wake((void *)0x1000002, a1, 0LL, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if ((_DWORD)result != -4)
      {
        uint64_t v10 = -(int)result;
        if ((_DWORD)v10 != 2) {
          goto LABEL_9;
        }
        return result;
      }
    }
  }

  return result;
}

void os_unfair_lock_assert_owner(os_unfair_lock_t lock)
{
  int v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  uint32_t os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) != v1) {
    os_unfair_lock_assert_owner_cold_1(os_unfair_lock_opaque);
  }
}

void os_unfair_lock_assert_not_owner(os_unfair_lock_t lock)
{
  int v1 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
  uint32_t os_unfair_lock_opaque = lock->_os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque | 1) == v1) {
    os_unfair_lock_assert_not_owner_cold_1(os_unfair_lock_opaque);
  }
}

uint64_t _os_once_gate_broadcast( void *a1, unsigned int a2, int a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = a2 | 1;
  if ((_DWORD)result != a3) {
    _os_once_gate_unowned_abort(result);
  }
  if ((a2 & 1) != 0)
  {
    uint64_t v10 = a2;
    qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: unlock_slow with no waiters";
    qword_18C509778 = a2;
    __break(1u);
LABEL_9:
    qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wake failure";
    qword_18C509778 = v10;
    __break(1u);
  }

  else
  {
    while (1)
    {
      uint64_t result = __ulock_wake((void *)0x1000102, a1, 0LL, a4, a5, a6, a7, a8);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if ((_DWORD)result != -4)
      {
        uint64_t v10 = -(int)result;
        if ((_DWORD)v10 != 2) {
          goto LABEL_9;
        }
        return result;
      }
    }
  }

  return result;
}

unint64_t *_os_once( unint64_t *result, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8 = atomic_load(result);
  if ((v8 & 3) == 1)
  {
    if (4LL * MEMORY[0xFFFFFC180] - v8 - 15 <= 0xFFFFFFFFFFFFFFEFLL) {
      *uint64_t result = -1LL;
    }
  }

  else
  {
    uint64_t v9 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 24);
    while (!__ldaxr(result))
    {
    }

    __clrex();
    return (unint64_t *)_os_once_gate_wait((uint64_t)result, a2, a3, v9, a5, a6, a7, a8);
  }

  return result;
}

uint64_t _os_once_callout(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t), int a4)
{
  uint64_t result = a3(a2);
  unint64_t v12 = (4LL * MEMORY[0xFFFFFC180]) | 1;
  do
    unsigned int v13 = __ldxr(a1);
  while (__stlxr(v12, a1));
  if (v13 != a4) {
    return _os_once_gate_broadcast(a1, v13, a4, v7, v8, v9, v10, v11);
  }
  return result;
}

uint64_t _os_once_gate_wait( uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4, void *a5, void *a6, void *a7, void *a8)
{
  unint64_t v8 = __ldxr((unint64_t *)result);
  if (v8 == -1LL)
  {
LABEL_19:
    __clrex();
    return result;
  }

  unint64_t v12 = (unint64_t *)result;
  unint64_t v13 = a4;
  while ((v8 & 3) != 1)
  {
    if (v8)
    {
      if ((v8 & 0xFFFFFFFFFFFFFFFELL) == v8)
      {
        __clrex();
      }

      else if (__stxr(v8 & 0xFFFFFFFFFFFFFFFELL, v12))
      {
        goto LABEL_12;
      }

      uint64_t result = __ulock_wait((void *)0x1000002, v12, (void *)(v8 & 0xFFFFFFFE), 0LL, a5, a6, a7, a8);
      if ((result & 0x80000000) != 0 && (_DWORD)result != -4 && -(int)result != 14)
      {
        qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: ulock_wait failure";
        qword_18C509778 = -(int)result;
        __break(1u);
        return result;
      }
    }

    else if (!__stxr(v13, v12))
    {
      __dmb(9u);
      return _os_once_callout(v12, a2, a3, a4);
    }

unint64_t _os_alloc_once( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8)
{
  v10[0] = a1;
  v10[1] = a2;
  _DWORD v10[2] = a3;
  _os_once(a1, (uint64_t)v10, _os_alloc, a4, a5, a6, a7, a8);
  return a1[1];
}

uint64_t _os_alloc(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0;
  if (v1 - 1 >= 2 * vm_page_size - 16) {
    _os_alloc_cold_1((*(_DWORD *)(a1 + 8) + 15) & 0xFFFFFFF0);
  }
  int v3 = (unint64_t *)_os_alloc_heap[0];
  if (!_os_alloc_heap[0]) {
    goto LABEL_5;
  }
  do
    unint64_t v4 = __ldxr(v3);
  while (__stxr(v4 + v1, v3));
  if (v4 + v1 <= 2 * vm_page_size - 16) {
    uint64_t result = (uint64_t)v3 + v4 + 16;
  }
  else {
LABEL_5:
  }
    uint64_t result = _os_alloc_slow(v3, v1);
  *(void *)(*(void *)a1 + 8LL) = result;
  int v6 = *(uint64_t (**)(void))(a1 + 16);
  if (v6) {
    return v6();
  }
  return result;
}

uint64_t _os_alloc_slow(unint64_t *a1, uint64_t a2)
{
  mach_vm_address_t v4 = vm_page_size;
  while (1)
  {
    mach_vm_address_t address = v4;
    uint64_t result = mach_vm_map(mach_task_self_, &address, 2 * v4, 0LL, 1224736769, 0, 0LL, 0, 3, 7, 1u);
    if ((_DWORD)result) {
      break;
    }
    mach_vm_address_t v6 = address;
    while (1)
    {
      unint64_t v7 = __ldxr(_os_alloc_heap);
      if (!__stxr(v6, _os_alloc_heap))
      {
        *(void *)(v6 + 8) = a1;
        a1 = (unint64_t *)v6;
        goto LABEL_8;
      }
    }

    __clrex();
    mach_vm_deallocate(mach_task_self_, v6, 2 * vm_page_size);
    a1 = (unint64_t *)_os_alloc_heap[0];
    if (!_os_alloc_heap[0])
    {
      mach_vm_address_t v4 = vm_page_size;
      continue;
    }

    do
LABEL_8:
      unint64_t v8 = __ldxr(a1);
    while (__stxr(v8 + a2, a1));
    mach_vm_address_t v4 = vm_page_size;
    if (v8 + a2 <= 2 * vm_page_size - 16) {
      return (uint64_t)a1 + v8 + 16;
    }
  }

  qword_18C509748 = (uint64_t)"BUG IN LIBPLATFORM: Failed to allocate in os_alloc_once";
  qword_18C509778 = (int)result;
  __break(1u);
  return result;
}

uint64_t _os_semaphore_dispose(semaphore_t semaphore)
{
  uint64_t result = semaphore_destroy(mach_task_self_, semaphore);
  if ((_DWORD)result) {
    _os_semaphore_dispose_cold_1(result);
  }
  return result;
}

const char *_platform_strstr(const char *a1, char *__s)
{
  unint64_t v2 = a1;
  int v3 = __s + 1;
  int v4 = *__s;
  if (!*__s) {
    return a1;
  }
  size_t v5 = _platform_strlen(__s + 1);
  while (1)
  {
    int v6 = *(unsigned __int8 *)v2;
    if (!*v2) {
      break;
    }
    unint64_t v7 = v2++;
    if (v6 == v4 && !_platform_strncmp(v2, v3, v5)) {
      return v7;
    }
  }

  return 0LL;
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  size_t v4 = _platform_strlen(__src);
  memmove(__dst, __src, v4 + 1);
  return __dst;
}

size_t _platform_strlcpy(void *a1, char *__s, size_t a3)
{
  size_t v6 = _platform_strlen(__s);
  size_t v7 = v6;
  if (v6 >= a3)
  {
    if (a3)
    {
      size_t v8 = a3 - 1;
      memmove(a1, __s, v8);
      *((_BYTE *)a1 + v8) = 0;
    }
  }

  else
  {
    memmove(a1, __s, v6 + 1);
  }

  return v7;
}

char *_platform_strncpy(char *a1, char *__s1, size_t __n)
{
  size_t v6 = _platform_strnlen(__s1, __n);
  size_t v7 = __n - v6;
  if (__n <= v6)
  {
    memmove(a1, __s1, __n);
  }

  else
  {
    size_t v8 = v6;
    memmove(a1, __s1, v6);
    _platform_memset(&a1[v8], 0, v7);
  }

  return a1;
}

size_t _platform_strlcat(const char *a1, char *__s, size_t a3)
{
  size_t v6 = _platform_strlen(__s);
  size_t v7 = _platform_strnlen(a1, a3);
  size_t v8 = a3 - v7;
  if (a3 == v7)
  {
    size_t v9 = a3;
  }

  else
  {
    size_t v9 = v7;
    uint64_t v10 = (char *)&a1[v7];
    if (v6 >= v8)
    {
      memmove(v10, __s, v8 - 1);
      a1[a3 - 1] = 0;
    }

    else
    {
      memmove(v10, __s, v6 + 1);
    }
  }

  return v9 + v6;
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __n)
{
  if ((_BYTE *)__dst - (_BYTE *)__src < __n)
  {
    if (__dst != __src)
    {
      char v46 = (char *)__dst + __n;
      char v47 = (char *)__src + __n;
      if (__n < 0x40)
      {
        while (1)
        {
          BOOL v43 = __n >= 8;
          __n -= 8LL;
          if (!v43) {
            break;
          }
          uint64_t v70 = *((void *)v47 - 1);
          v47 -= 8;
          *((void *)v46 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v70;
          v46 -= 8;
        }

        for (size_t i = __n + 8; i; --i)
        {
          char v72 = *--v47;
          *--char v46 = v72;
        }
      }

      else
      {
        if (__n < 0x4000)
        {
          uint64_t v65 = *((void *)v47 - 2);
          uint64_t v66 = *((void *)v47 - 1);
          uint64_t v67 = *((void *)v47 - 4);
          uint64_t v68 = *((void *)v47 - 3);
          unint64_t v52 = (unint64_t)(v46 - 1) & 0xFFFFFFFFFFFFFFE0LL;
          uint64_t v69 = v47 - &v46[-v52];
          uint64_t v54 = *(void *)(v69 - 16);
          uint64_t v55 = *(void *)(v69 - 8);
          uint64_t v56 = *(void *)(v69 - 32);
          uint64_t v57 = *(void *)(v69 - 24);
          *((void *)v46 - 2) = v65;
          *((void *)v46 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v66;
          *((void *)v46 - 4) = v67;
          *((void *)v46 - 3) = v68;
          uint64_t v58 = v69 - 32;
          unint64_t v59 = v52 - (void)__dst - 64;
          if (v52 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(void *)(v52 - 16) = v54;
              *(void *)(v52 - 8) = v55;
              *(void *)(v52 - 32) = v56;
              *(void *)(v52 - 24) = v57;
              v52 -= 32LL;
              uint64_t v54 = *(void *)(v58 - 16);
              uint64_t v55 = *(void *)(v58 - 8);
              uint64_t v56 = *(void *)(v58 - 32);
              uint64_t v57 = *(void *)(v58 - 24);
              v58 -= 32LL;
              BOOL v16 = v59 > 0x20;
              v59 -= 32LL;
            }

            while (v16);
          }
        }

        else
        {
          uint64_t v48 = *((void *)v47 - 2);
          uint64_t v49 = *((void *)v47 - 1);
          uint64_t v50 = *((void *)v47 - 4);
          uint64_t v51 = *((void *)v47 - 3);
          unint64_t v52 = (unint64_t)(v46 - 1) & 0xFFFFFFFFFFFFFFE0LL;
          uint64_t v53 = v47 - &v46[-v52];
          uint64_t v54 = *(void *)(v53 - 16);
          uint64_t v55 = *(void *)(v53 - 8);
          uint64_t v56 = *(void *)(v53 - 32);
          uint64_t v57 = *(void *)(v53 - 24);
          *((void *)v46 - 2) = v48;
          *((void *)v46 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v49;
          *((void *)v46 - 4) = v50;
          *((void *)v46 - 3) = v51;
          uint64_t v58 = v53 - 32;
          unint64_t v59 = v52 - (void)__dst - 64;
          if (v52 - (unint64_t)__dst > 0x40)
          {
            do
            {
              *(void *)(v52 - 16) = v54;
              *(void *)(v52 - 8) = v55;
              *(void *)(v52 - 32) = v56;
              *(void *)(v52 - 24) = v57;
              v52 -= 32LL;
              uint64_t v54 = *(void *)(v58 - 16);
              uint64_t v55 = *(void *)(v58 - 8);
              uint64_t v56 = *(void *)(v58 - 32);
              uint64_t v57 = *(void *)(v58 - 24);
              v58 -= 32LL;
              BOOL v16 = v59 > 0x20;
              v59 -= 32LL;
            }

            while (v16);
          }
        }

        uint64_t v60 = v58 - v59;
        uint64_t v61 = *(void *)(v60 - 16);
        uint64_t v62 = *(void *)(v60 - 8);
        uint64_t v63 = *(void *)(v60 - 32);
        uint64_t v64 = *(void *)(v60 - 24);
        *(void *)(v52 - 16) = v54;
        *(void *)(v52 - 8) = v55;
        *(void *)(v52 - 32) = v56;
        *(void *)(v52 - 24) = v57;
        *((void *)__dst + 2) = v61;
        *((void *)__dst + 3) = v62;
        *(void *)uint64_t __dst = v63;
        *((void *)__dst + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v64;
      }
    }
  }

  else
  {
    int v3 = __dst;
    if (__n < 0x40)
    {
      while (1)
      {
        BOOL v43 = __n >= 8;
        __n -= 8LL;
        if (!v43) {
          break;
        }
        uint64_t v42 = *(void *)__src;
        __src = (char *)__src + 8;
        *v3++ = v42;
      }

      for (size_t j = __n + 8; j; --j)
      {
        char v45 = *(_BYTE *)__src;
        __src = (char *)__src + 1;
        *(_BYTE *)int v3 = v45;
        int v3 = (void *)((char *)v3 + 1);
      }
    }

    else
    {
      if ((_BYTE *)__src - (_BYTE *)__dst < __n)
      {
        if (__n < 0x4000)
        {
          size_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0LL);
          uint64_t v30 = *(void *)__src;
          uint64_t v31 = *((void *)__src + 1);
          uint64_t v32 = *((void *)__src + 2);
          uint64_t v33 = *((void *)__src + 3);
          unsigned __int8 v34 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
          uint64_t v10 = *v34;
          uint64_t v11 = v34[1];
          uint64_t v12 = v34[2];
          uint64_t v13 = v34[3];
          int v14 = v34 + 4;
          size_t v35 = __n - (v4 - (_BYTE *)__dst);
          *(void *)uint64_t __dst = v30;
          *((void *)__dst + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v31;
          *((void *)__dst + 2) = v32;
          *((void *)__dst + 3) = v33;
          BOOL v16 = v35 > 0x40;
          for (unint64_t k = v35 - 64; v16; k -= 32LL)
          {
            *(void *)size_t v4 = v10;
            *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
            *((void *)v4 + 2) = v12;
            *((void *)v4 + 3) = v13;
            v4 += 32;
            uint64_t v10 = *v14;
            uint64_t v11 = v14[1];
            uint64_t v12 = v14[2];
            uint64_t v13 = v14[3];
            v14 += 4;
            BOOL v16 = k > 0x20;
          }
        }

        else
        {
          size_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0LL);
          uint64_t v24 = *(void *)__src;
          uint64_t v25 = *((void *)__src + 1);
          uint64_t v26 = *((void *)__src + 2);
          uint64_t v27 = *((void *)__src + 3);
          int v28 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
          uint64_t v10 = *v28;
          uint64_t v11 = v28[1];
          uint64_t v12 = v28[2];
          uint64_t v13 = v28[3];
          int v14 = v28 + 4;
          size_t v29 = __n - (v4 - (_BYTE *)__dst);
          *(void *)uint64_t __dst = v24;
          *((void *)__dst + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v25;
          *((void *)__dst + 2) = v26;
          *((void *)__dst + 3) = v27;
          BOOL v16 = v29 > 0x40;
          for (unint64_t k = v29 - 64; v16; k -= 32LL)
          {
            *(void *)size_t v4 = v10;
            *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
            *((void *)v4 + 2) = v12;
            *((void *)v4 + 3) = v13;
            v4 += 32;
            uint64_t v10 = *v14;
            uint64_t v11 = v14[1];
            uint64_t v12 = v14[2];
            uint64_t v13 = v14[3];
            v14 += 4;
            BOOL v16 = k > 0x20;
          }
        }
      }

      else if (__n < 0x4000)
      {
        size_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0LL);
        uint64_t v18 = *(void *)__src;
        uint64_t v19 = *((void *)__src + 1);
        uint64_t v20 = *((void *)__src + 2);
        uint64_t v21 = *((void *)__src + 3);
        unsigned __int8 v22 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
        uint64_t v10 = *v22;
        uint64_t v11 = v22[1];
        uint64_t v12 = v22[2];
        uint64_t v13 = v22[3];
        int v14 = v22 + 4;
        size_t v23 = __n - (v4 - (_BYTE *)__dst);
        *(void *)uint64_t __dst = v18;
        *((void *)__dst + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v19;
        *((void *)__dst + 2) = v20;
        *((void *)__dst + 3) = v21;
        BOOL v16 = v23 > 0x40;
        for (unint64_t k = v23 - 64; v16; k -= 32LL)
        {
          *(void *)size_t v4 = v10;
          *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
          *((void *)v4 + 2) = v12;
          *((void *)v4 + 3) = v13;
          v4 += 32;
          uint64_t v10 = *v14;
          uint64_t v11 = v14[1];
          uint64_t v12 = v14[2];
          uint64_t v13 = v14[3];
          v14 += 4;
          BOOL v16 = k > 0x20;
        }
      }

      else
      {
        size_t v4 = (char *)(((unint64_t)__dst + 32) & 0xFFFFFFFFFFFFFFE0LL);
        uint64_t v5 = *(void *)__src;
        uint64_t v6 = *((void *)__src + 1);
        uint64_t v7 = *((void *)__src + 2);
        uint64_t v8 = *((void *)__src + 3);
        size_t v9 = (uint64_t *)((char *)__src + v4 - (_BYTE *)__dst);
        uint64_t v10 = *v9;
        uint64_t v11 = v9[1];
        uint64_t v12 = v9[2];
        uint64_t v13 = v9[3];
        int v14 = v9 + 4;
        size_t v15 = __n - (v4 - (_BYTE *)__dst);
        *(void *)uint64_t __dst = v5;
        *((void *)__dst + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v6;
        *((void *)__dst + 2) = v7;
        *((void *)__dst + 3) = v8;
        BOOL v16 = v15 > 0x40;
        for (unint64_t k = v15 - 64; v16; k -= 32LL)
        {
          *(void *)size_t v4 = v10;
          *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
          *((void *)v4 + 2) = v12;
          *((void *)v4 + 3) = v13;
          v4 += 32;
          uint64_t v10 = *v14;
          uint64_t v11 = v14[1];
          uint64_t v12 = v14[2];
          uint64_t v13 = v14[3];
          v14 += 4;
          BOOL v16 = k > 0x20;
        }
      }

      char v36 = (uint64_t *)((char *)v14 + k);
      uint64_t v37 = *v36;
      uint64_t v38 = v36[1];
      uint64_t v39 = v36[2];
      uint64_t v40 = v36[3];
      *(void *)size_t v4 = v10;
      *((void *)v4 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v11;
      *((void *)v4 + 2) = v12;
      *((void *)v4 + 3) = v13;
      char v41 = &v4[k];
      *((void *)v41 + 4) = v37;
      *((void *)v41 + 5) = v38;
      *((void *)v41 + 6) = v39;
      *((void *)v41 + 7) = v40;
    }
  }

  return __dst;
}

int _platform_strcmp(const char *__s1, const char *__s2)
{
  while ((__s1 & 0xF) != 0)
  {
    unsigned int v3 = *(unsigned __int8 *)__s1++;
    uint64_t v2 = v3;
    int v4 = *(unsigned __int8 *)__s2++;
    int v5 = v2 - v4;
    if (v2 != v4 || (_DWORD)v2 == 0) {
      return v5;
    }
  }

  if ((__s2 & 0xF) != 0)
  {
    uint64_t v8 = -(uint64_t)__s2 & 0xFF0;
    if (!v8) {
      goto LABEL_12;
    }
LABEL_10:
    while (1)
    {
      int8x16_t v9 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v10 = v9;
      int8x16_t v11 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v13 = vceqq_s8(v10, v11);
      uint8x16_t v12 = (uint8x16_t)vandq_s8(v10, v13);
      v13.i8[0] = vminvq_u8(v12);
      if (!v13.i32[0]) {
        break;
      }
      v8 -= 16LL;
      if (!v8)
      {
LABEL_12:
        while (1)
        {
          unsigned int v15 = *(unsigned __int8 *)__s1++;
          uint64_t v14 = v15;
          int v16 = *(unsigned __int8 *)__s2++;
          int v5 = v14 - v16;
          if (v14 != v16 || (_DWORD)v14 == 0) {
            return v5;
          }
          if ((__s1 & 0xF) == 0)
          {
            uint64_t v8 = 4080LL;
            goto LABEL_10;
          }
        }
      }
    }
  }

  else
  {
    do
    {
      int8x16_t v18 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v19 = v18;
      int8x16_t v20 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v13 = vceqq_s8(v19, v20);
      uint8x16_t v12 = (uint8x16_t)vandq_s8(v19, v13);
      v13.i8[0] = vminvq_u8(v12);
    }

    while (v13.i32[0]);
  }

  uint8x16_t v21 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v12, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1800AEAA0);
  v21.i8[0] = vminvq_u8(v21);
  return __s1[v21.u32[0] - 16] - __s2[v21.u32[0] - 16];
}

void *__cdecl _platform_memchr(const void *__s, int __c, size_t __n)
{
  if (!__n) {
    return 0LL;
  }
  if ((__n & 0x8000000000000000LL) != 0LL)
  {
    int8x16_t v13 = vdupq_n_s8(__c);
    uint64_t v14 = __s & 0xF;
    unint64_t v15 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0LL;
    int8x16_t v16 = *(int8x16_t *)&algn_1800AEBB0[-v14];
    for (uint8x16_t i = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v15, v13), v16); ; uint8x16_t i = (uint8x16_t)vsubq_s8(v18, v13))
    {
      v16.i8[0] = vminvq_u8(i);
      if (!v16.i32[0]) {
        break;
      }
      int8x16_t v18 = *(int8x16_t *)(v15 + 16);
      v15 += 16LL;
    }

    uint8x16_t v19 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v13, v13)), (int8x16_t)xmmword_1800AEBA0);
    v19.i8[0] = vminvq_u8(v19);
    return (void *)(v15 + v19.u32[0]);
  }

  else
  {
    int8x16_t v3 = vdupq_n_s8(__c);
    uint64_t v4 = __s & 0xF;
    unint64_t v5 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0LL;
    int8x16_t v6 = *(int8x16_t *)&algn_1800AEBB0[-v4];
    uint8x16_t v7 = (uint8x16_t)vorrq_s8(vsubq_s8(*(int8x16_t *)v5, v3), v6);
    unint64_t v8 = __n + v4;
    while (1)
    {
      v6.i8[0] = vminvq_u8(v7);
      if (!v6.i32[0]) {
        break;
      }
      BOOL v10 = v8 > 0x10;
      v8 -= 16LL;
      if (!v10) {
        return 0LL;
      }
      int8x16_t v9 = *(int8x16_t *)(v5 + 16);
      v5 += 16LL;
      uint8x16_t v7 = (uint8x16_t)vsubq_s8(v9, v3);
    }

    uint8x16_t v12 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v7, (uint8x16_t)veorq_s8(v3, v3)), (int8x16_t)xmmword_1800AEBA0);
    v12.i8[0] = vminvq_u8(v12);
    uint64_t result = (void *)(v5 + v12.u32[0]);
    if (v12.u32[0] >= v8) {
      return 0LL;
    }
  }

  return result;
}

int _platform_memcmp(const void *__s1, const void *__s2, size_t __n)
{
  BOOL v3 = __n >= 0x10;
  size_t v4 = __n - 16;
  if (!v3)
  {
    BOOL v3 = __CFADD__(v4, 8LL);
    size_t v17 = v4 + 8;
    if (v3)
    {
      unint64_t v19 = *(void *)__s1;
      __s1 = (char *)__s1 + 8;
      unint64_t v18 = v19;
      unint64_t v21 = *(void *)__s2;
      __s2 = (char *)__s2 + 8;
      unint64_t v20 = v21;
      unint64_t v22 = v18 - v21;
      if (v18 != v21) {
        goto LABEL_18;
      }
      v17 -= 8LL;
    }

    BOOL v3 = __CFADD__(v17, 4LL);
    size_t v23 = v17 + 4;
    if (!v3)
    {
      v23 += 4LL;
      LODWORD(v22) = 0;
      goto LABEL_20;
    }

    unsigned int v24 = *(_DWORD *)__s1;
    __s1 = (char *)__s1 + 4;
    unint64_t v18 = v24;
    unsigned int v25 = *(_DWORD *)__s2;
    __s2 = (char *)__s2 + 4;
    unint64_t v20 = v25;
    unint64_t v22 = v18 - v25;
    if (v18 == v25)
    {
      do
      {
LABEL_20:
        BOOL v3 = v23-- != 0;
        if (!v3) {
          break;
        }
        unsigned int v28 = *(unsigned __int8 *)__s1;
        __s1 = (char *)__s1 + 1;
        uint64_t v27 = v28;
        int v29 = *(unsigned __int8 *)__s2;
        __s2 = (char *)__s2 + 1;
        LODWORD(v22) = v27 - v29;
      }

      while (v27 == v29);
      return v22;
    }

size_t _platform_strnlen(const char *__s1, size_t __n)
{
  if ((__n & 0x8000000000000000LL) != 0LL) {
    return _platform_strlen(__s1);
  }
  if (!__n) {
    return 0LL;
  }
  unint64_t v3 = (unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0LL;
  size_t v4 = (int8x16_t *)&algn_1800AEE10[-(__s1 & 0xF)];
  int8x16_t v5 = *v4;
  uint8x16_t v6 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s1 & 0xFFFFFFFFFFFFFFF0LL), *v4);
  size_t v7 = __n + (__s1 & 0xF);
  while (1)
  {
    v5.i8[0] = vminvq_u8(v6);
    if (!v5.i32[0]) {
      break;
    }
    BOOL v9 = v7 > 0x10;
    v7 -= 16LL;
    if (!v9) {
      return v3 - (void)__s1 + v7 + 16;
    }
    uint8x16_t v8 = *(uint8x16_t *)(v3 + 16);
    v3 += 16LL;
    uint8x16_t v6 = v8;
  }

  uint8x16_t v10 = (uint8x16_t)veorq_s8(v5, v5);
  v10.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v6, v10), (int8x16_t)xmmword_1800AEE00));
  unint64_t v11 = v3 - (void)__s1;
  if (v7 >= v10.u32[0]) {
    size_t v7 = v10.u32[0];
  }
  return v11 + v7;
}

size_t _platform_strlen(const char *__s)
{
  unint64_t v1 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0LL;
  uint64_t v2 = (int8x16_t *)&algn_1800AEE10[-(__s & 0xF)];
  int8x16_t v3 = *v2;
  for (uint8x16_t i = (uint8x16_t)vorrq_s8(*(int8x16_t *)((unint64_t)__s & 0xFFFFFFFFFFFFFFF0LL), *v2); ; uint8x16_t i = v5)
  {
    v3.i8[0] = vminvq_u8(i);
    if (!v3.i32[0]) {
      break;
    }
    uint8x16_t v5 = *(uint8x16_t *)(v1 + 16);
    v1 += 16LL;
  }

  uint8x16_t v6 = (uint8x16_t)veorq_s8(v3, v3);
  v6.i8[0] = vminvq_u8((uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, v6), (int8x16_t)xmmword_1800AEE00));
  return v1 - (void)__s + v6.u32[0];
}

int _platform_strncmp(const char *__s1, const char *__s2, size_t __n)
{
  int v3 = 0;
  if (!__n) {
    return v3;
  }
  while ((__s1 & 0xF) != 0)
  {
    unsigned int v5 = *(unsigned __int8 *)__s1++;
    uint64_t v4 = v5;
    int v6 = *(unsigned __int8 *)__s2++;
    int v3 = v4 - v6;
    if (v4 == v6 && (_DWORD)v4 != 0)
    {
      if (--__n) {
        continue;
      }
    }

    return v3;
  }

  unint64_t v9 = -(uint64_t)__s2 & 0xFF0;
  if (!v9) {
    goto LABEL_16;
  }
LABEL_11:
  if (__n > v9)
  {
    size_t v10 = __n - v9;
    while (1)
    {
      int8x16_t v11 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v12 = v11;
      int8x16_t v13 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v15 = vceqq_s8(v12, v13);
      uint8x16_t v14 = (uint8x16_t)vandq_s8(v12, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0]) {
        break;
      }
      v9 -= 16LL;
      if (!v9)
      {
        __n = v10;
LABEL_16:
        while (1)
        {
          unsigned int v17 = *(unsigned __int8 *)__s1++;
          uint64_t v16 = v17;
          int v18 = *(unsigned __int8 *)__s2++;
          int v3 = v16 - v18;
          if (v16 != v18 || (_DWORD)v16 == 0) {
            return v3;
          }
          if (!--__n) {
            return v3;
          }
          if ((__s1 & 0xF) == 0)
          {
            unint64_t v9 = 4080LL;
            goto LABEL_11;
          }
        }
      }
    }
  }

  else
  {
LABEL_30:
    while (1)
    {
      int8x16_t v20 = *(int8x16_t *)__s1;
      __s1 += 16;
      int8x16_t v21 = v20;
      int8x16_t v22 = *(int8x16_t *)__s2;
      __s2 += 16;
      int8x16_t v15 = vceqq_s8(v21, v22);
      uint8x16_t v14 = (uint8x16_t)vandq_s8(v21, v15);
      v15.i8[0] = vminvq_u8(v14);
      if (!v15.i32[0]) {
        break;
      }
      BOOL v23 = __n > 0x10;
      __n -= 16LL;
      if (!v23) {
        return 0;
      }
    }
  }

  uint8x16_t v24 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(v14, (uint8x16_t)veorq_s8(v15, v15)), (int8x16_t)xmmword_1800AEF20);
  v24.i8[0] = vminvq_u8(v24);
  if (v24.u32[0] >= __n) {
    return 0;
  }
  else {
    return __s1[v24.u32[0] - 16] - __s2[v24.u32[0] - 16];
  }
}

void bzero(void *a1, size_t a2)
{
  if (a2 < 0x40) {
    JUMPOUT(0x1800AF190LL);
  }
  if (a2 < 0x8000) {
    JUMPOUT(0x1800AF130LL);
  }
  *(void *)a1 = 0LL;
  *((void *)a1 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
  *((void *)a1 + 2) = 0LL;
  *((void *)a1 + 3) = 0LL;
  *((void *)a1 + 4) = 0LL;
  *((void *)a1 + 5) = 0LL;
  *((void *)a1 + 6) = 0LL;
  *((void *)a1 + 7) = 0LL;
  unint64_t v2 = ((unint64_t)a1 + 64) & 0xFFFFFFFFFFFFFFC0LL;
  int v3 = (char *)a1 + a2 - v2 - 64;
  if ((unint64_t)a1 + a2 > v2 + 64)
  {
    do
    {
      __asm { DC              ZVA, X3 }

      v2 += 64LL;
      BOOL v8 = (unint64_t)v3 > 0x40;
      v3 -= 64;
    }

    while (v8);
  }

  unint64_t v9 = &v3[v2];
  *(void *)unint64_t v9 = 0LL;
  *((void *)v9 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 0LL;
  *((void *)v9 + 2) = 0LL;
  *((void *)v9 + 3) = 0LL;
  *((void *)v9 + 4) = 0LL;
  *((void *)v9 + 5) = 0LL;
  *((void *)v9 + 6) = 0LL;
  *((void *)v9 + 7) = 0LL;
}

void *__cdecl _platform_memset(void *__b, int __c, size_t __len)
{
  uint64_t v3 = 0x101010101010101LL * __c;
  uint64_t v4 = (uint64_t *)__b;
  if (__len < 0x40)
  {
    while (1)
    {
      BOOL v11 = __len >= 8;
      __len -= 8LL;
      if (!v11) {
        break;
      }
      *v4++ = v3;
    }

    for (size_t i = __len + 8; i; --i)
    {
      *(_BYTE *)uint64_t v4 = v3;
      uint64_t v4 = (uint64_t *)((char *)v4 + 1);
    }
  }

  else
  {
    if (__len < 0x8000)
    {
      *(void *)__b = v3;
      *((void *)__b + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v3;
      *((void *)__b + 2) = v3;
      *((void *)__b + 3) = v3;
      *((void *)__b + 4) = v3;
      *((void *)__b + 5) = v3;
      *((void *)__b + 6) = v3;
      *((void *)__b + 7) = v3;
      unsigned int v5 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0LL);
      size_t v10 = (char *)__b + __len;
      BOOL v7 = v10 > v5 + 64;
      for (unint64_t j = v10 - (v5 + 64); v7; j -= 64LL)
      {
        *(void *)unsigned int v5 = v3;
        *((void *)v5 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v3;
        *((void *)v5 + 2) = v3;
        *((void *)v5 + 3) = v3;
        *((void *)v5 + 4) = v3;
        *((void *)v5 + 5) = v3;
        *((void *)v5 + 6) = v3;
        *((void *)v5 + 7) = v3;
        v5 += 64;
        BOOL v7 = j > 0x40;
      }
    }

    else
    {
      if (!v3) {
        JUMPOUT(0x1800AF05CLL);
      }
      *(void *)__b = v3;
      *((void *)__b + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v3;
      *((void *)__b + 2) = v3;
      *((void *)__b + 3) = v3;
      *((void *)__b + 4) = v3;
      *((void *)__b + 5) = v3;
      *((void *)__b + 6) = v3;
      *((void *)__b + 7) = v3;
      unsigned int v5 = (char *)(((unint64_t)__b + 64) & 0xFFFFFFFFFFFFFFC0LL);
      int v6 = (char *)__b + __len;
      BOOL v7 = v6 > v5 + 64;
      for (unint64_t j = v6 - (v5 + 64); v7; j -= 64LL)
      {
        *(void *)unsigned int v5 = v3;
        *((void *)v5 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v3;
        *((void *)v5 + 2) = v3;
        *((void *)v5 + 3) = v3;
        *((void *)v5 + 4) = v3;
        *((void *)v5 + 5) = v3;
        *((void *)v5 + 6) = v3;
        *((void *)v5 + 7) = v3;
        v5 += 64;
        BOOL v7 = j > 0x40;
      }
    }

    unint64_t v9 = (uint64_t *)&v5[j];
    uint64_t *v9 = v3;
    v9[1] = v3;
    v9[2] = v3;
    void v9[3] = v3;
    void v9[4] = v3;
    void v9[5] = v3;
    void v9[6] = v3;
    void v9[7] = v3;
  }

  return __b;
}

char *__cdecl _platform_strchr(const char *__s, int __c)
{
  int8x16_t v2 = vdupq_n_s8(__c);
  uint64_t v3 = __s & 0xF;
  unint64_t v4 = (unint64_t)__s & 0xFFFFFFFFFFFFFFF0LL;
  int8x16_t v5 = *(int8x16_t *)&algn_1800AF1D0[-v3];
  for (uint8x16_t i = (uint8x16_t)vorrq_s8(vbicq_s8(*(int8x16_t *)v4, vceqq_s8(*(int8x16_t *)v4, v2)), v5);
        ;
        uint8x16_t i = (uint8x16_t)vbicq_s8(v7, v5))
  {
    v5.i8[0] = vminvq_u8(i);
    if (!v5.i32[0]) {
      break;
    }
    int8x16_t v7 = *(int8x16_t *)(v4 + 16);
    v4 += 16LL;
    int8x16_t v5 = vceqq_s8(v7, v2);
  }

  uint8x16_t v8 = (uint8x16_t)vorrq_s8((int8x16_t)vcgtq_u8(i, (uint8x16_t)veorq_s8(v5, v5)), (int8x16_t)xmmword_1800AF1C0);
  v8.i8[0] = vminvq_u8(v8);
  uint64_t result = (char *)(v4 + v8.u32[0]);
  return result;
}

unint64_t timingsafe_enable_if_supported()
{
  uint64_t v0 = MEMORY[0xFFFFFC010];
  if ((MEMORY[0xFFFFFC010] & 0x200000000000000LL) != 0)
  {
    unint64_t v1 = (_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 5)) >> 24) & 1;
    __asm { MSR             DIT, #1 }

    if ((v0 & 0x200000000000LL) != 0) {
      goto LABEL_3;
    }
LABEL_5:
    __dsb(0xFu);
    __isb(0xFu);
    return v1;
  }

  unint64_t v1 = 0LL;
  if ((MEMORY[0xFFFFFC010] & 0x200000000000LL) == 0) {
    goto LABEL_5;
  }
LABEL_3:
  sb();
  return v1;
}

uint64_t timingsafe_restore_if_supported(uint64_t result)
{
  if ((result & 1) == 0 && (MEMORY[0xFFFFFC010] & 0x200000000000000LL) != 0) {
    __asm { MSR             DIT, #0 }
  }

  return result;
}

void sb()
{
  __asm { SB }

void _pthread_exit( unint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  for (uint64_t i = *(void *)(a1 + 8); i; *(void *)(a1 + 8) = i)
  {
    (*(void (**)(void))i)(*(void *)(i + 8));
    uint64_t i = *(void *)(i + 16);
  }

  ignition_test_BRA(a1);
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v18 = *(void *)(StatusReg + 72);
  *(void *)(StatusReg + 72) = 0LL;
  if (v18) {
    goto LABEL_5;
  }
  while (1)
  {
    LODWORD(v18) = _pthread_terminate_invoke(a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16);
LABEL_5:
    _os_semaphore_dispose(v18);
  }

uint64_t _pthread_joiner_wake( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint8x16_t v8 = (void *)(a1 + 52);
  do
    uint64_t result = __ulock_wake((void *)0x1000002, v8, 0LL, a4, a5, a6, a7, a8);
  while ((_DWORD)result == -4);
  if ((_DWORD)result != -2)
  {
    if ((_DWORD)result) {
      _pthread_joiner_wake_cold_1(result);
    }
  }

  return result;
}

void pthread_exit(void *a1)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  if ((*(_WORD *)(StatusReg - 146) & 0x400) != 0)
  {
    qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPTHREAD: pthread_exit() called from a thread not created by pthread_create()";
    __break(1u);
  }

  else if ((_pthread_ptr_munge_token ^ *(void *)(StatusReg - 224)) == StatusReg - 224)
  {
    _pthread_exit(StatusReg - 224, a1, v1, v2, v3, v4, v5, v6);
  }

  abort_with_reason((void *)0x12, (void *)4, "pthread_t was corrupted", 0LL);
}

uint64_t _pthread_set_self(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!a1) {
    return _pthread_set_self_dyld(0LL, a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
  a1[27] = result;
  if (result != -1) {
    return _thread_set_tsd_base(a1 + 28);
  }
  qword_18C509748 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
  __break(1u);
  return result;
}

uint64_t _pthread_set_self_dyld( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = __thread_selfid(a1, a2, a3, a4, a5, a6, a7, a8);
  qword_18C437C58 = result;
  if (result == -1)
  {
    qword_18C509748 = (uint64_t)"BUG IN LIBPTHREAD: failed to set thread_id";
    __break(1u);
  }

  else
  {
    qword_18C437C60 = (uint64_t)&_main_thread;
    unk_18C437C68 = &unk_18C437C2C;
    return _thread_set_tsd_base(&qword_18C437C60);
  }

  return result;
}

uint64_t _pthread_terminate_invoke( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unint64_t v8 = _pthread_terminate(a1, a2, a3, a4, a5, a6, a7, a8);
  return _pthread_terminate(v8, v9, v10, v11, v12, v13, v14, v15);
}

uint64_t _pthread_terminate( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  unint64_t v10 = *(void *)(a1 + 192);
  uint64_t v11 = *(char **)(a1 + 200);
  if (v10 < a1 && (unint64_t)&v11[v10] > a1)
  {
    uint8x16_t v14 = (char *)((a1 - v10) & -(uint64_t)vm_page_size);
    *(void *)(a1 + 192) = &v14[v10];
    *(void *)(a1 + 20dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = v11 - v14;
  }

  else if ((_UNKNOWN *)a1 == &_main_thread)
  {
    uint64_t v13 = qword_18C437C30 - unk_18C437C38;
    if (qword_18C437C30 == unk_18C437C38) {
      uint64_t v13 = 0x80000LL;
    }
    unint64_t v10 = qword_18C437C30 - v13;
    uint8x16_t v14 = (char *)(((unint64_t)_pthread_current_stack_address() & -(uint64_t)vm_page_size) - v10);
  }

  else
  {
    uint8x16_t v14 = 0LL;
  }

  int8x16_t v15 = (void *)*(unsigned int *)(a1 + 248);
  mach_port_name_t v16 = *(_DWORD *)(a1 + 288);
  if (v16)
  {
    *(_DWORD *)(a1 + 288) = 0;
    thread_destruct_special_reply_port(v16, 0);
  }

  mach_port_t v17 = *(_DWORD *)(a1 + 240);
  if (v17) {
    mig_dealloc_reply_port(v17);
  }
  os_unfair_lock_lock_with_options((unsigned int *)&_pthread_list_lock, 327680, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(a1 + 52) = -1;
  *(void *)(a1 + 4dyld4::Loader::Loader((uint64_t)this, (const dyld4::Loader::InitialOptions *)v4, 1, 0, 0, 0) = a2;
  int v18 = _pthread_count--;
  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    int8x16_t v20 = (void *)_pthread_joiner_prepost_wake(a1);
  }
  else {
    int8x16_t v20 = 0LL;
  }
  char v21 = *(_BYTE *)(a1 + 49);
  char v22 = v21 & 1;
  if ((v21 & 1) != 0)
  {
    *(_BYTE *)(a1 + 49) = v21 | 2;
  }

  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    uint8x16_t v24 = *(void **)(a1 + 24);
    if (v23)
    {
      *(void *)(v23 + 24) = v24;
      uint8x16_t v24 = *(void **)(a1 + 24);
    }

    else
    {
      qword_18C509730 = *(void *)(a1 + 24);
    }

    void *v24 = v23;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  if (v19)
  {
    _pthread_joiner_wake(a1, v25, v26, v27, v28, v29, v30, v31);
    os_unfair_lock_lock_with_options((unsigned int *)&_pthread_list_lock, 327680, v32, v33, v34, v35, v36, v37);
    if (*(void *)(a1 + 32))
    {
      *(_BYTE *)(a1 + 49) |= 2u;
      char v22 = 1;
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&_pthread_list_lock);
  }

  if ((_UNKNOWN *)a1 != &_main_thread && (v22 & 1) == 0)
  {
    uint8x16_t v14 = v11;
  }

  if (v18 <= 1) {
    _exit(0);
  }
  if (v14) {
    uint64_t v38 = (void *)v10;
  }
  else {
    uint64_t v38 = 0LL;
  }
  uint64_t result = __bsdthread_terminate(v38, v14, v15, v20, v28, v29, v30, v31);
  qword_18C509748 = (uint64_t)"BUG IN LIBPTHREAD: thread didn't terminate";
  qword_18C509778 = a1;
  __break(1u);
  return result;
}

char *_pthread_current_stack_address()
{
  return &v1;
}

uint64_t _pthread_introspection_hook_callout_thread_terminate(uint64_t a1)
{
  if ((_UNKNOWN *)a1 == &_main_thread)
  {
    uint64_t v2 = qword_18C437C30 - unk_18C437C38 + qword_18C437C50;
    uint64_t v1 = unk_18C437C38 - qword_18C437C50;
  }

  else
  {
    uint64_t v1 = *(void *)(a1 + 192);
    uint64_t v2 = *(void *)(a1 + 200) - (~(_DWORD)vm_page_mask & (vm_page_mask + 4320));
  }

  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  __int16 v4 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 3;
  uint64_t result = _pthread_introspection_hook(3LL, a1, v1, v2);
  *(_WORD *)(StatusReg - 174) = v4;
  return result;
}

uint64_t _pthread_introspection_hook_callout_thread_destroy(uint64_t a1)
{
  vm_size_t v1 = ~(_DWORD)vm_page_mask & (vm_page_mask + 4320);
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  __int16 v3 = *(_WORD *)(StatusReg - 174);
  *(_WORD *)(StatusReg - 174) = 4;
  uint64_t result = _pthread_introspection_hook(4LL, a1, a1, v1);
  *(_WORD *)(StatusReg - 174) = v3;
  return result;
}

void _pthread_joiner_wake_cold_1(int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN LIBPTHREAD: pthread_join() wake failure";
  qword_18C509778 = -a1;
  __break(1u);
}

uint64_t _pthread_setcancelstate_exit(uint64_t result)
{
  vm_size_t v1 = (unsigned __int16 *)(result + 166);
  do
    unsigned __int16 v2 = __ldxr(v1);
  while (__stxr(v2 & 0xFFDC | 0x22, v1));
  return result;
}

uint64_t _pthread_exit_if_canceled( uint64_t result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (result == 4)
  {
    int v8 = result;
    uint64_t result = __pthread_canceled(0LL, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      uint64_t v12 = *(void *)(StatusReg - 224);
      unint64_t v11 = StatusReg - 224;
      if ((_pthread_ptr_munge_token ^ v12) == v11)
      {
        *(_DWORD *)(v11 + 168) = v8;
        *(_BYTE *)(v11 + 165) = 1;
        pthread_exit((void *)1);
      }

      _pthread_exit_if_canceled_cold_1(result, v9);
    }
  }

  return result;
}

uint64_t _pthread_joiner_prepost_wake(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(_BYTE *)(a1 + 49);
  if ((v3 & 1) != 0)
  {
    uint64_t result = *(unsigned int *)(v2 + 20);
    *(_BYTE *)(a1 + 49) = v3 & 0xFE;
  }

  else
  {
    uint64_t result = 0LL;
    *(_BYTE *)(v2 + 24) = 1;
    *(void *)(a1 + 32) = 0LL;
  }

  if (*(void *)(v2 + 8))
  {
    int v5 = atomic_load((unsigned __int16 *)(a1 + 166));
    if ((~v5 & 0x11) != 0) {
      uint64_t v6 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v6 = 1LL;
    }
    **(void **)(v2 + 8) = v6;
  }

  return result;
}

void OUTLINED_FUNCTION_0_2(uint64_t a1, uint64_t a2, void *a3)
{
}

void _pthread_exit_if_canceled_cold_1(uint64_t a1, uint64_t a2)
{
}

uint64_t mutex_seq_atomic_cmpxchgv_relaxed(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  while (1)
  {
    unint64_t v5 = __ldxr(a1);
    if (v5 != v3) {
      break;
    }
    if (!__stxr(v4, a1))
    {
      uint64_t result = 1LL;
      goto LABEL_6;
    }
  }

  uint64_t result = 0LL;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t mutex_seq_atomic_cmpxchgv_acquire(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  while (1)
  {
    unint64_t v5 = __ldaxr(a1);
    if (v5 != v3) {
      break;
    }
    if (!__stxr(v4, a1))
    {
      uint64_t result = 1LL;
      goto LABEL_6;
    }
  }

  uint64_t result = 0LL;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t mutex_seq_atomic_cmpxchgv_release(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  while (1)
  {
    unint64_t v5 = __ldxr(a1);
    if (v5 != v3) {
      break;
    }
    if (!__stlxr(v4, a1))
    {
      uint64_t result = 1LL;
      goto LABEL_6;
    }
  }

  uint64_t result = 0LL;
  __clrex();
LABEL_6:
  *a2 = v5;
  return result;
}

vm_address_t *sandbox_warn( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  unint64_t v10 = (vm_address_t *)_simple_salloc();
  _simple_vsprintf((uint64_t)v10, a1, &a9);
  uint64_t v11 = _simple_string((_BYTE **)v10);
  _simple_asl_log(2, (uint64_t)"com.apple.libsystem.sandbox", v11, v12, v13, v14, v15, v16);
  int v17 = _simple_string((_BYTE **)v10);
  _simple_dprintf(2, "%s\n", v18, v19, v20, v21, v22, v23, v17);
  return _simple_sfree(v10);
}

uint64_t sandbox_check( int a1, vm_address_t *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v27 = a2;
  sandbox_operation_fixup(&v27);
  v17[0] = 0LL;
  __int128 v18 = 0u;
  uint64_t v25 = 0LL;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  v17[1] = a1;
  *(void *)&__int128 v18 = v27;
  uint64_t v26 = &a9;
  return sandbox_check_common(v17, a3, &a9, v11, v12, v13, v14, v15);
}

vm_address_t *sandbox_operation_fixup(vm_address_t **a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = (vm_address_t *)_platform_strcmp((const char *)result, "iokit-open");
    if (!(_DWORD)result)
    {
      uint64_t result = sandbox_warn( "sandbox operation %s is obsolete; replace with %s",
                 v3,
                 v4,
                 v5,
                 v6,
                 v7,
                 v8,
                 v9,
                 (int)"iokit-open");
      *a1 = (vm_address_t *)"iokit-open-user-client";
    }
  }

  return result;
}

uint64_t sandbox_check_common( void *a1, int a2, unsigned int *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  __int128 v23 = a3;
  *a1 = &v18;
  if ((a2 & 0x40000000) != 0)
  {
    a1[5] |= 1uLL;
    if ((a2 & 0x20000000) == 0)
    {
LABEL_3:
      if ((a2 & 0x10000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }

  else if ((a2 & 0x20000000) == 0)
  {
    goto LABEL_3;
  }

  a1[5] |= 2uLL;
  if ((a2 & 0x10000000) == 0)
  {
LABEL_4:
    if ((a2 & 0x8000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }

uint64_t mach_absolute_time(void)
{
  if (!MEMORY[0xFFFFFC090]) {
    return mach_absolute_time_kernel();
  }
  if (MEMORY[0xFFFFFC090] == 2LL)
  {
    do
    {
      uint64_t v3 = MEMORY[0xFFFFFC088];
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }

    while (v3 != MEMORY[0xFFFFFC088]);
    return StatusReg + v3;
  }

  else if (MEMORY[0xFFFFFC090] == 3LL)
  {
    do
    {
      uint64_t v5 = MEMORY[0xFFFFFC088];
      unint64_t v6 = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }

    while (v5 != MEMORY[0xFFFFFC088]);
    return v6 + v5;
  }

  else
  {
    __isb(0xFu);
    do
    {
      uint64_t v1 = MEMORY[0xFFFFFC088];
      unint64_t v2 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }

    while (v1 != MEMORY[0xFFFFFC088]);
    return v2 + v1;
  }

uint64_t mach_absolute_time_kernel()
{
  return mac_syscall(MACH_ABSOLUTE_TIME_TRAP);
}

int64_t mach_continuous_time_kernel( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-4, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t _kernelrpc_mach_vm_allocate_trap( mach_port_name_t target, mach_vm_offset_t *addr, mach_vm_size_t size, int flags)
{
  return mac_syscall(KERNELRPC_MACH_VM_ALLOCATE_TRAP, target, addr, size, flags);
}

kern_return_t _kernelrpc_mach_vm_purgable_control_trap( mach_port_name_t target, mach_vm_offset_t address, vm_purgable_t control, int *state)
{
  return mac_syscall(-11, *(void **)&target, (void *)address, *(void **)&control, state, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_deallocate_trap( mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return mac_syscall(KERNELRPC_MACH_VM_DEALLOCATE_TRAP, target, address, size);
}

kern_return_t task_dyld_process_info_notify_get(mach_port_name_array_t names_addr, natural_t *names_count_addr)
{
  return mac_syscall(-13, names_addr, names_count_addr, v2, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_vm_protect_trap( mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_PROTECT_TRAP, target, address, size, set_maximum, new_protection);
}

kern_return_t _kernelrpc_mach_vm_map_trap( mach_port_name_t target, mach_vm_offset_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_prot_t cur_protection)
{
  return mac_syscall(KERNELRPC_MACH_VM_MAP_TRAP, target, address, size, (mach_vm_offset_t *)mask, flags, cur_protection);
}

kern_return_t _kernelrpc_mach_port_allocate_trap( mach_port_name_t target, mach_port_right_t right, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_ALLOCATE_TRAP, target, right, name);
}

kern_return_t _kernelrpc_mach_port_deallocate_trap(mach_port_name_t target, mach_port_name_t name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DEALLOCATE_TRAP, target, name);
}

kern_return_t _kernelrpc_mach_port_mod_refs_trap( mach_port_name_t target, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOD_REFS_TRAP, target, name, right, delta);
}

kern_return_t _kernelrpc_mach_port_move_member_trap( mach_port_name_t target, mach_port_name_t member, mach_port_name_t after)
{
  return mac_syscall(KERNELRPC_MACH_PORT_MOVE_MEMBER_TRAP, target, member, after);
}

kern_return_t _kernelrpc_mach_port_insert_right_trap( mach_port_name_t target, mach_port_name_t name, mach_port_name_t poly, mach_msg_type_name_t polyPoly)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_RIGHT_TRAP, target, name, poly, polyPoly);
}

kern_return_t _kernelrpc_mach_port_insert_member_trap( mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_INSERT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_extract_member_trap( mach_port_name_t target, mach_port_name_t name, mach_port_name_t pset)
{
  return mac_syscall(KERNELRPC_MACH_PORT_EXTRACT_MEMBER_TRAP, target, name, pset);
}

kern_return_t _kernelrpc_mach_port_construct_trap( mach_port_name_t target, mach_port_options_t *options, uint64_t context, mach_port_name_t *name)
{
  return mac_syscall(KERNELRPC_MACH_PORT_CONSTRUCT_TRAP, target, options, context, name);
}

kern_return_t _kernelrpc_mach_port_destruct_trap( mach_port_name_t target, mach_port_name_t name, mach_port_delta_t srdelta, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_DESTRUCT_TRAP, target, name, srdelta, guard);
}

mach_port_name_t mach_reply_port()
{
  return mac_syscall(MACH_REPLY_PORT_TRAP);
}

mach_port_name_t thread_self_trap()
{
  return mac_syscall(THREAD_SELF_TRAP);
}

mach_port_name_t task_self_trap(void)
{
  return mac_syscall(TASK_SELF_TRAP);
}

mach_port_name_t host_self_trap()
{
  return mac_syscall(HOST_SELF_TRAP);
}

mach_msg_return_t mach_msg_trap( mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7)
{
  return mac_syscall(MACH_MSG_TRAP, a1, a2, a3, a4, a5, a6, a7);
}

mach_msg_return_t mach_msg_overwrite_trap( mach_msg_header_t *a1, mach_msg_option_t a2, mach_msg_size_t a3, mach_msg_size_t a4, mach_port_name_t a5, mach_msg_timeout_t a6, mach_port_name_t a7, mach_msg_header_t *a8)
{
  return mac_syscall(MACH_MSG_OVERWRITE_TRAP, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t semaphore_signal_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_TRAP, a1);
}

kern_return_t semaphore_signal_all_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_SIGNAL_ALL_TRAP, a1);
}

kern_return_t semaphore_signal_thread_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_SIGNAL_THREAD_TRAP, a1, a2);
}

kern_return_t semaphore_wait_trap(mach_port_name_t a1)
{
  return mac_syscall(SEMAPHORE_WAIT_TRAP, a1);
}

kern_return_t semaphore_wait_signal_trap(mach_port_name_t a1, mach_port_name_t a2)
{
  return mac_syscall(SEMAPHORE_WAIT_SIGNAL_TRAP, a1, a2);
}

kern_return_t semaphore_timedwait_trap(mach_port_name_t a1, unsigned int a2, clock_res_t a3)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_TRAP, a1, a2, a3);
}

kern_return_t semaphore_timedwait_signal_trap( mach_port_name_t a1, mach_port_name_t a2, unsigned int a3, clock_res_t a4)
{
  return mac_syscall(SEMAPHORE_TIMEDWAIT_SIGNAL_TRAP, a1, a2, a3, a4);
}

kern_return_t _kernelrpc_mach_port_get_attributes_trap( mach_port_name_t target, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return mac_syscall( -40,  *(void **)&target,  *(void **)&name,  *(void **)&flavor,  port_info_out,  port_info_outCnt,  v5,  v6,  v7);
}

kern_return_t _kernelrpc_mach_port_guard_trap( mach_port_name_t target, mach_port_name_t name, uint64_t guard, BOOLean_t strict)
{
  return mac_syscall(KERNELRPC_MACH_PORT_GUARD_TRAP, target, name, guard, strict);
}

kern_return_t _kernelrpc_mach_port_unguard_trap(mach_port_name_t target, mach_port_name_t name, uint64_t guard)
{
  return mac_syscall(KERNELRPC_MACH_PORT_UNGUARD_TRAP, target, name, guard);
}

kern_return_t mach_generate_activity_id(mach_port_name_t target, int count, uint64_t *activity_id)
{
  return mac_syscall(MAP_FD_TRAP, target, *(vm_offset_t *)&count, activity_id, v3, v4);
}

kern_return_t task_name_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *tn)
{
  return mac_syscall(TASK_NAME_FOR_PID_TRAP, target_tport, pid, tn);
}

kern_return_t task_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return mac_syscall(TASK_FOR_PID_TRAP, target_tport, pid, t);
}

kern_return_t pid_for_task(mach_port_name_t t, int *x)
{
  return mac_syscall(PID_FOR_TASK_TRAP, t, x);
}

int64_t mach_msg2_trap( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-47, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_swapon(uint64_t filename, int flags, int size, int priority)
{
  return mac_syscall(MACX_SWAPON_TRAP, filename, flags, size, priority);
}

kern_return_t macx_swapoff(uint64_t filename, int flags)
{
  return mac_syscall(MACX_SWAPOFF_TRAP, filename, flags);
}

int64_t thread_get_special_reply_port( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-50, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t macx_triggers(int hi_water, int low_water, int flags, mach_port_t alert_port)
{
  return mac_syscall(MACX_TRIGGERS_TRAP, hi_water, low_water, flags, alert_port);
}

kern_return_t macx_backing_store_suspend(BOOLean_t suspend)
{
  return mac_syscall(MACX_BACKING_STORE_SUSPEND_TRAP, suspend);
}

kern_return_t macx_backing_store_recovery(int pid)
{
  return mac_syscall(MACX_BACKING_STORE_RECOVERY_TRAP, pid);
}

BOOLean_t swtch_pri(int pri)
{
  return mac_syscall(SWTCH_PRI_TRAP, pri);
}

BOOLean_t swtch(void)
{
  return mac_syscall(SWTCH_TRAP);
}

kern_return_t syscall_thread_switch(mach_port_name_t a1, int a2, mach_msg_timeout_t a3)
{
  return mac_syscall(THREAD_SWITCH_TRAP, a1, a2, a3);
}

kern_return_t clock_sleep_trap( mach_port_name_t clock_name, sleep_type_t sleep_type, int sleep_sec, int sleep_nsec, mach_timespec_t *wakeup_time)
{
  return mac_syscall(CLOCK_SLEEP_TRAP, clock_name, sleep_type, sleep_sec, sleep_nsec, (mach_timespec_t)wakeup_time);
}

kern_return_t host_create_mach_voucher_trap( mach_port_name_t host, mach_voucher_attr_raw_recipe_array_t recipes, int recipes_size, mach_port_name_t *voucher)
{
  return mac_syscall(-70, *(void **)&host, recipes, *(void **)&recipes_size, voucher, v4, v5, v6, v7);
}

kern_return_t mach_voucher_extract_attr_recipe_trap( mach_port_name_t voucher_name, mach_voucher_attr_key_t key, mach_voucher_attr_raw_recipe_t recipe, mach_msg_type_number_t *recipe_size)
{
  return mac_syscall(-72, *(void **)&voucher_name, *(void **)&key, recipe, recipe_size, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_type_trap(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return mac_syscall(-76, *(void **)&task, *(void **)&name, ptype, v3, v4, v5, v6, v7);
}

kern_return_t _kernelrpc_mach_port_request_notification_trap( ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_name_t notify, mach_msg_type_name_t notifyPoly, mach_port_name_t *previous)
{
  return mac_syscall( -77,  *(void **)&task,  *(void **)&name,  *(void **)&msgid,  *(void **)&sync,  *(void **)&notify,  *(void **)&notifyPoly,  previous,  v7);
}

int64_t _exclaves_ctl_trap( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-88, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t mach_timebase_info_trap(mach_timebase_info *a1)
{
  return mac_syscall(MACH_TIMEBASE_INFO_TRAP, a1);
}

kern_return_t mach_wait_until(uint64_t deadline)
{
  return mac_syscall(MACH_WAIT_UNTIL_TRAP, deadline);
}

mach_port_name_t mk_timer_create()
{
  return mac_syscall(MK_TIMER_CREATE_TRAP);
}

kern_return_t mk_timer_destroy(mach_port_name_t a1)
{
  return mac_syscall(MK_TIMER_DESTROY_TRAP, a1);
}

kern_return_t mk_timer_arm(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_ARM_TRAP, a1, a2);
}

kern_return_t mk_timer_cancel(mach_port_name_t a1, uint64_t a2)
{
  return mac_syscall(MK_TIMER_CANCEL_TRAP, a1, a2);
}

int64_t mk_timer_arm_leeway( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  return mac_syscall(-95, a1, a2, a3, a4, a5, a6, a7, a8);
}

kern_return_t debug_control_port_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *t)
{
  return mac_syscall(-96, *(void **)&target_tport, *(void **)&pid, t, v3, v4, v5, v6, v7);
}

uint64_t __abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_abort_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_create(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_create, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_ctl(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_register(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_register, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __bsdthread_terminate( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_bsdthread_terminate, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __chmod(const char *a1, mode_t a2)
{
  int result = mac_syscall(SYS_chmod, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  LODWORD(v9) = mac_syscall(SYS_connect, a1, a2, a3);
  if (v3) {
    LODWORD(v9) = cerror(v9, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  }
  return v9;
}

uint64_t __disable_threadsignal( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___disable_threadsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __execve(const char *a1, char *const *a2, char *const *a3)
{
  int result = mac_syscall(SYS_execve, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

void _exit(int a1)
{
  if (v1) {
    cerror_nocancel(v2);
  }
}

int __fchmod(int a1, mode_t a2)
{
  int result = mac_syscall(SYS_fchmod, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __fcntl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_fcntl, a1, (int)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  int result = mac_syscall(SYS_getattrlist, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __getdirentries64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_getdirentries64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

pid_t getpid(void)
{
  pid_t result = _current_pid;
  if (_current_pid <= 0) {
    return cerror_nocancel(mac_syscall(SYS_getpid));
  }
  return result;
}

int __gettimeofday_with_mach(timeval *a1, void *a2)
{
  int result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __gettimeofday(timeval *a1, void *a2)
{
  int result = mac_syscall(SYS_gettimeofday, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __ioctl(int a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_ioctl, a1, (unint64_t)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __kdebug_trace64(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kdebug_trace64, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int64_t __kdebug_trace_string( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int64_t result = mac_syscall(SYS_kdebug_trace_string, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t __kdebug_typefilter(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kdebug_typefilter, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __kqueue_workloop_ctl( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_kqueue_workloop_ctl, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  off_t result = mac_syscall(SYS_lseek, a1, a2, a3);
  if (v3) {
    return cerror(result, (void *)a2, *(void **)&a3, v4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t __sandbox_ms(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___mac_syscall, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __map_with_linking_np( const mwl_region regions[], uint32_t regionCount, const mwl_info_hdr *blob, uint32_t blobSize)
{
  int64_t v9 = mac_syscall(550, (void *)regions, *(void **)&regionCount, (void *)blob, *(void **)&blobSize, v5, v6, v7, v8);
  if (v4) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

void *__mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  uint64_t result = mac_syscall(SYS_mmap, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return (void *)cerror_nocancel((int)result);
  }
  return result;
}

int mprotect(void *a1, size_t a2, int a3)
{
  int result = mac_syscall(SYS_mprotect, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int __munmap(void *a1, size_t a2)
{
  int result = mac_syscall(SYS_munmap, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int __open(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_open, a1, (int)a2, a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

int __open_dprotected_np(const char *a1, int a2, int a3, int a4)
{
  int result = mac_syscall(SYS_open_dprotected_np, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int __openat(int a1, char *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_openat, a1, a2, (int)a3);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __openat_dprotected_np( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(218, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __posix_spawn( pid_t *a1, char *a2, posix_spawn_file_actions_t *a3, posix_spawnattr_t *a4, char **a5, char **a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_posix_spawn, a1, a2, a3, a4, a5, a6);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __proc_info(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_proc_info, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __proc_info_extended_id( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(545, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __process_policy(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_process_policy, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvbroad(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvbroad, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvclrprepost( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvclrprepost, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvsignal(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvsignal, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_cvwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_cvwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_mutexdrop(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_mutexdrop, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __psynch_mutexwait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_psynch_mutexwait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __pthread_canceled(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___pthread_canceled, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __pthread_kill(_opaque_pthread_t *a1, int a2)
{
  int result = mac_syscall(SYS___pthread_kill, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __pthread_markcancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___pthread_markcancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  int result = mac_syscall(SYS___pthread_sigmask, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

void __rename( const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  LODWORD(v9) = mac_syscall(SYS_rename, (const char *)__from, (const char *)__to);
  if (v3) {
    cerror(v9, (void *)__to, __ec, v4, v5, v6, v7, v8);
  }
}

uint64_t __semwait_signal_nocancel( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS___semwait_signal_nocancel, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  ssize_t result = mac_syscall(SYS_sendto, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return cerror(result, (void *)a2, (void *)a3, *(void **)&a4, (void *)a5, *(void **)&a6, v7, v8);
  }
  return result;
}

int __shared_region_check_np(uint64_t *a1)
{
  int result = mac_syscall(SYS_shared_region_check_np, a1);
  if (v1) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __shared_region_map_and_slide_2_np( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(536, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __sigwait(const sigset_t *a1, int *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS___sigwait, a1, a2);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

int syscall(int a1, ...)
{
  char v4 = va_arg(va, void *);
  char v5 = va_arg(va, void *);
  char v6 = va_arg(va, void *);
  uint64_t v7 = va_arg(va, void *);
  char v8 = va_arg(va, void *);
  uint64_t v9 = va_arg(va, void *);
  unint64_t v10 = va_arg(va, void *);
  LODWORD(v2) = mac_syscall(SYS_syscall, a1, v4, v5, v6, v7, v8, v9, v10);
  if (v1) {
    LODWORD(v2) = cerror(v2, v4, v5, v6, v7, v8, v9, v10);
  }
  return v2;
}

int __sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  int result = mac_syscall(SYS_sysctl, a1, a2, a3, a4, a5, a6);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __terminate_with_payload( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_terminate_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int64_t __thread_selfid( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int64_t result = mac_syscall(SYS_thread_selfid, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t __ulock_wait(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_ulock_wait, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __ulock_wait2(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(544, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __ulock_wake(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_ulock_wake, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int __unlink(const char *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  LODWORD(v9) = mac_syscall(SYS_unlink, a1);
  if (v8) {
    LODWORD(v9) = cerror(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  return v9;
}

uint64_t __workq_kernreturn(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_workq_kernreturn, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t __workq_open(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_workq_open, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int close(int a1)
{
  LODWORD(v9) = mac_syscall(SYS_close, a1);
  if (v1) {
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

int dup(int a1)
{
  int result = mac_syscall(SYS_dup, a1);
  if (v1) {
    return cerror_nocancel(result);
  }
  return result;
}

int dup2(int a1, int a2)
{
  int result = mac_syscall(SYS_dup2, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int fgetattrlist(int a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  int result = mac_syscall(SYS_fgetattrlist, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  ssize_t result = mac_syscall(SYS_fgetxattr, fd, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

int fmount(const char *a1, int a2, int a3, void *a4)
{
  int result = mac_syscall(SYS_fmount, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  int result = mac_syscall(SYS_fsctl, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  int result = mac_syscall(SYS_fsetxattr, fd, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t fsgetpath(char *a1, size_t a2, fsid_t *a3, uint64_t a4)
{
  ssize_t result = mac_syscall(SYS_fsgetpath, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

int fstat64(int a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_fstat64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int fstatat64(int a1, const char *a2, stat *a3, int a4)
{
  int64_t v9 = mac_syscall(SYS_fstatat64, *(void **)&a1, (void *)a2, a3, *(void **)&a4, v5, v6, v7, v8);
  if (v4) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int fstatfs64(int a1, statfs *a2)
{
  int64_t v9 = mac_syscall(SYS_fstatfs64, *(void **)&a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int fsync(int a1)
{
  LODWORD(v9) = mac_syscall(SYS_fsync, a1);
  if (v1) {
    LODWORD(v9) = cerror(v9, v2, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

int ftruncate(int a1, off_t a2)
{
  int result = mac_syscall(SYS_ftruncate, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int getattrlistbulk(int a1, void *a2, void *a3, size_t a4, uint64_t a5)
{
  int result = mac_syscall(SYS_getattrlistbulk, a1, a2, a3, a4, a5);
  if (v5) {
    return cerror_nocancel(result);
  }
  return result;
}

int getentropy(void *buffer, size_t size)
{
  int result = mac_syscall(SYS_getentropy, buffer, size);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int getfsstat64(statfs *a1, int a2, int a3)
{
  int64_t v9 = mac_syscall(SYS_getfsstat64, a1, *(void **)&a2, *(void **)&a3, v4, v5, v6, v7, v8);
  if (v3) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

gid_t getgid(void)
{
  gid_t result = mac_syscall(SYS_getgid);
  if (v0) {
    return cerror_nocancel(result);
  }
  return result;
}

uid_t getuid(void)
{
  uid_t result = mac_syscall(SYS_getuid);
  if (v0) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  ssize_t result = mac_syscall(SYS_getxattr, path, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t graftdmg(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(549, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

int lstat64(const char *a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_lstat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int mkdir(const char *a1, mode_t a2)
{
  int result = mac_syscall(SYS_mkdir, a1, a2);
  if (v2) {
    return cerror_nocancel(result);
  }
  return result;
}

int mount(const char *a1, const char *a2, int a3, void *a4)
{
  int result = mac_syscall(SYS_mount, a1, a2, a3, a4);
  if (v4) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t mremap_encrypted(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_mremap_encrypted, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t openbyid_np(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_openbyid_np, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

uint64_t os_fault_with_payload( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_os_fault_with_payload, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  ssize_t result = mac_syscall(SYS_pread, __fd, __buf, __nbyte, a4);
  if (v4) {
    return cerror(result, __buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t proc_rlimit_control(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = mac_syscall(SYS_proc_rlimit_control, a1, a2, a3, a4, a5, a6, a7, a8);
  if (v8) {
    return cerror_nocancel(result);
  }
  return result;
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  ssize_t result = mac_syscall(SYS_pwrite, __fd, __buf, __nbyte, a4);
  if (v4) {
    return cerror(result, (void *)__buf, (void *)__nbyte, (void *)a4, v5, v6, v7, v8);
  }
  return result;
}

ssize_t read(int a1, void *a2, size_t a3)
{
  ssize_t result = mac_syscall(SYS_read, a1, a2, a3);
  if (v3) {
    return cerror(result, a2, (void *)a3, v4, v5, v6, v7, v8);
  }
  return result;
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  ssize_t result = mac_syscall(SYS_readlink, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int setxattr( const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  int result = mac_syscall(SYS_setxattr, path, name, value, size, position, options);
  if (v6) {
    return cerror_nocancel(result);
  }
  return result;
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  int result = mac_syscall(SYS_sigprocmask, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int socket(int a1, int a2, int a3)
{
  int result = mac_syscall(SYS_socket, a1, a2, a3);
  if (v3) {
    return cerror_nocancel(result);
  }
  return result;
}

int stat64(const char *a1, stat *a2)
{
  int64_t v9 = mac_syscall(SYS_stat64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

int statfs64(const char *a1, statfs *a2)
{
  int64_t v9 = mac_syscall(SYS_statfs64, (void *)a1, a2, v3, v4, v5, v6, v7, v8);
  if (v2) {
    LODWORD(v9) = cerror_nocancel(v9);
  }
  return v9;
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  ssize_t result = mac_syscall(SYS_write, __fd, __buf, __nbyte);
  if (v3) {
    return cerror(result, (void *)__buf, (void *)__nbyte, v4, v5, v6, v7, v8);
  }
  return result;
}

int64_t _thread_set_tsd_base(void *a1)
{
  return mac_syscall(MACHDEP_SYSCALL_TRAP, 2LL, a1);
}

uint64_t ccdigest_final_64be(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  size_t v9 = (v7 + v6 + 19) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = (uint64_t *)((char *)&v20 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v10, v9);
  memmove(v10, a2, v7 + v6 + 12);
  uint64_t v11 = (char *)v10 + v7;
  uint64_t v12 = (uint64_t)v10 + v7 + 8;
  uint64_t v13 = (char *)(v12 + v6);
  uint64_t v14 = *(unsigned int *)(v12 + v6);
  *v10 += (8 * v14);
  *(_DWORD *)(v12 + v6) = v14 + 1;
  *(_BYTE *)(v12 + v14) = 0x80;
  unint64_t v15 = *(unsigned int *)(v12 + v6);
  if (v15 < 0x39)
  {
    if (v15 == 56) {
      goto LABEL_9;
    }
  }

  else
  {
    if (v15 <= 0x3F)
    {
      do
      {
        *(_DWORD *)uint64_t v13 = v15 + 1;
        *(_BYTE *)(v12 + v15) = 0;
        unint64_t v15 = *(unsigned int *)v13;
      }

      while (v15 < 0x40);
    }

    (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
    unint64_t v15 = 0LL;
    uint64_t v11 = (char *)v10 + *(void *)(a1 + 8);
    uint64_t v12 = (uint64_t)(v11 + 8);
    uint64_t v13 = &v11[*(void *)(a1 + 16) + 8];
    *(_DWORD *)uint64_t v13 = 0;
  }

  do
  {
    *(_DWORD *)uint64_t v13 = v15 + 1;
    *(_BYTE *)(v12 + v15) = 0;
    unint64_t v15 = *(unsigned int *)v13;
  }

  while (v15 < 0x38);
LABEL_9:
  *((void *)v11 + 8) = bswap64(*v10);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v10 + 1, 1LL);
  if (*(void *)a1 >= 4uLL)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0LL;
    unsigned int v18 = 1;
    do
    {
      *(_DWORD *)(a3 + v16) = bswap32(*((_DWORD *)v10 + v17 + 2));
      unint64_t v17 = v18++;
      v16 += 4;
    }

    while (v17 < *(void *)a1 >> 2);
  }

  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v10);
}

uint64_t ccdigest_init(uint64_t a1, void *a2)
{
  unsigned int v5 = timingsafe_enable_if_supported();
  memmove(a2 + 1, *(const void **)(a1 + 40), *(void *)(a1 + 8));
  *a2 = 0LL;
  *(_DWORD *)((char *)a2 + *(void *)(a1 + 8) + *(void *)(a1 + 16) + 8) = 0;
  return cc_disable_dit_with_sb(&v5);
}

unint64_t *ccdigest_update_internal(unint64_t *result, void *a2, size_t a3, char *__src)
{
  size_t v5 = a3;
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (uint64_t)a2 + result[1] + 8;
  if (a3)
  {
    unint64_t v10 = a2 + 1;
    do
    {
      size_t v11 = v7[2];
      uint64_t v12 = (char *)v10 + v7[1];
      uint64_t v13 = *(unsigned int *)&v12[v11];
      if (v5 > v11 && (_DWORD)v13 == 0)
      {
        if (v11 == 128)
        {
          size_t v22 = v5 >> 7;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFF80LL;
        }

        else if (v11 == 64)
        {
          size_t v22 = v5 >> 6;
          size_t v16 = v5 & 0xFFFFFFFFFFFFFFC0LL;
        }

        else
        {
          size_t v22 = v5 / v11;
          size_t v16 = v5 / v11 * v11;
        }

        ssize_t result = (unint64_t *)((uint64_t (*)(void *, size_t, char *))v7[6])(a2 + 1, v22, __src);
        *a2 += 8 * v16;
      }

      else
      {
        size_t v15 = v11 - v13;
        if (v15 >= v5) {
          size_t v16 = v5;
        }
        else {
          size_t v16 = v15;
        }
        ssize_t result = (unint64_t *)memmove(&v12[v13], __src, v16);
        unint64_t v17 = v7[2];
        unsigned int v18 = (char *)v10 + v7[1];
        uint64_t v19 = (*(_DWORD *)&v18[v17] + v16);
        *(_DWORD *)&v18[v17] = v19;
        if (v17 == v19)
        {
          ssize_t result = (unint64_t *)((uint64_t (*)(void *, uint64_t))v7[6])(a2 + 1, 1LL);
          unint64_t v20 = v7[2];
          uint64_t v21 = (char *)v10 + v7[1];
          *a2 += (8 * *(_DWORD *)&v21[v20]);
          *(_DWORD *)&v21[v20] = 0;
        }
      }

      __src += v16;
      v5 -= v16;
    }

    while (v5);
  }

  return result;
}

uint64_t ccdigest_update(unint64_t *a1, void *a2, size_t a3, char *a4)
{
  unsigned int v9 = timingsafe_enable_if_supported();
  ccdigest_update_internal(a1, a2, a3, a4);
  return cc_disable_dit_with_sb(&v9);
}

int32x4_t *AccelerateCrypto_SHA256_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    int8x16_t v5 = a3[1];
    int8x16_t v6 = a3[2];
    int8x16_t v7 = a3[3];
    char v3 = a3 + 4;
    _Q1 = (int32x4_t)vrev32q_s8(v5);
    int32x4_t v9 = *result;
    _Q2 = (int32x4_t)vrev32q_s8(v6);
    _Q17 = result[1];
    _Q3 = (int32x4_t)vrev32q_s8(v7);
    _Q18 = *result;
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v4), (int32x4_t)K256);
    _Q5 = vaddq_s32(_Q1, (int32x4_t)xmmword_1800B14A0);
    _Q19 = _Q17;
    _Q6 = vaddq_s32(_Q2, (int32x4_t)xmmword_1800B14B0);
    _Q7 = vaddq_s32(_Q3, (int32x4_t)xmmword_1800B14C0);
    uint64_t v19 = &xmmword_1800B14D0;
    int v20 = 3;
    do
    {
      _Q20 = _Q18;
      int32x4_t v22 = (int32x4_t)*v19;
      __asm { SHA256SU0       V0.4S, V1.4S }

      int32x4_t v28 = (int32x4_t)v19[1];
      __asm { SHA256H         Q18, Q19, V4.4S }

      int32x4_t v30 = (int32x4_t)v19[2];
      __asm { SHA256SU1       V0.4S, V2.4S, V3.4S }

      int32x4_t v32 = (int32x4_t)v19[3];
      __asm { SHA256H2        Q19, Q20, V4.4S }

      v19 += 4;
      _Q4 = vaddq_s32(_Q0, v22);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V1.4S, V2.4S
        SHA256H         Q18, Q19, V5.4S
        SHA256SU1       V1.4S, V3.4S, V0.4S
        SHA256H2        Q19, Q20, V5.4S
      }

      _Q5 = vaddq_s32(_Q1, v28);
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V2.4S, V3.4S
        SHA256H         Q18, Q19, V6.4S
        SHA256SU1       V2.4S, V0.4S, V1.4S
        SHA256H2        Q19, Q20, V6.4S
      }

      _Q6 = vaddq_s32(_Q2, v30);
      --v20;
      _Q20 = _Q18;
      __asm
      {
        SHA256SU0       V3.4S, V0.4S
        SHA256H         Q18, Q19, V7.4S
        SHA256SU1       V3.4S, V1.4S, V2.4S
        SHA256H2        Q19, Q20, V7.4S
      }

      _Q7 = vaddq_s32(_Q3, v32);
    }

    while (!(_NF ^ _VF | _ZF));
    BOOL v44 = a2 <= 1;
    uint64_t v45 = a2 - 1;
    if (!v44)
    {
      char v46 = (int32x4_t *)(v19 - 16);
      do
      {
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V4.4S }

        int8x16_t v49 = v3[1];
        int8x16_t v50 = v3[2];
        __asm { SHA256H2        Q19, Q20, V4.4S }

        int8x16_t v52 = v3[3];
        _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(*v3), *v46);
        _Q20 = _Q18;
        v3 += 4;
        __asm { SHA256H         Q18, Q19, V5.4S }

        _Q1 = (int32x4_t)vrev32q_s8(v49);
        __asm { SHA256H2        Q19, Q20, V5.4S }

        _Q5 = vaddq_s32(_Q1, v46[1]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V6.4S }

        _Q2 = (int32x4_t)vrev32q_s8(v50);
        __asm { SHA256H2        Q19, Q20, V6.4S }

        _Q6 = vaddq_s32(_Q2, v46[2]);
        _Q20 = _Q18;
        __asm { SHA256H         Q18, Q19, V7.4S }

        _Q3 = (int32x4_t)vrev32q_s8(v52);
        __asm { SHA256H2        Q19, Q20, V7.4S }

        _Q7 = vaddq_s32(_Q3, v46[3]);
        int32x4_t v9 = vaddq_s32(v9, _Q18);
        _Q17 = vaddq_s32(_Q17, _Q19);
        _Q20 = v9;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[4]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[5]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[6]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[7]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[8]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[9]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[10]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[11]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V0.4S, V1.4S
          SHA256H         Q18, Q19, V4.4S
          SHA256SU1       V0.4S, V2.4S, V3.4S
          SHA256H2        Q19, Q20, V4.4S
        }

        _Q4 = vaddq_s32(_Q0, v46[12]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V1.4S, V2.4S
          SHA256H         Q18, Q19, V5.4S
          SHA256SU1       V1.4S, V3.4S, V0.4S
          SHA256H2        Q19, Q20, V5.4S
        }

        _Q5 = vaddq_s32(_Q1, v46[13]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V2.4S, V3.4S
          SHA256H         Q18, Q19, V6.4S
          SHA256SU1       V2.4S, V0.4S, V1.4S
          SHA256H2        Q19, Q20, V6.4S
        }

        _Q6 = vaddq_s32(_Q2, v46[14]);
        _Q20 = _Q18;
        __asm
        {
          SHA256SU0       V3.4S, V0.4S
          SHA256H         Q18, Q19, V7.4S
          SHA256SU1       V3.4S, V1.4S, V2.4S
          SHA256H2        Q19, Q20, V7.4S
        }

        _Q7 = vaddq_s32(_Q3, v46[15]);
        BOOL v44 = v45-- <= 1;
      }

      while (!v44);
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V4.4S
      SHA256H2        Q19, Q20, V4.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V5.4S
      SHA256H2        Q19, Q20, V5.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V6.4S
      SHA256H2        Q19, Q20, V6.4S
    }

    _Q20 = _Q18;
    __asm
    {
      SHA256H         Q18, Q19, V7.4S
      SHA256H2        Q19, Q20, V7.4S
    }

    *ssize_t result = vaddq_s32(v9, _Q18);
    result[1] = vaddq_s32(_Q17, _Q19);
  }

  return result;
}

uint64_t *AccelerateCrypto_SHA512_compress(uint64_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v4 = *a3;
    char v3 = a3 + 8;
    int64x2_t v5 = (int64x2_t)vrev64q_s8(v4);
    int64x2_t v6 = (int64x2_t)vrev64q_s8(v3[-7]);
    int64x2_t v7 = (int64x2_t)vrev64q_s8(v3[-6]);
    int64x2_t v8 = (int64x2_t)vrev64q_s8(v3[-5]);
    int64x2_t v9 = (int64x2_t)vrev64q_s8(v3[-4]);
    int64x2_t v10 = (int64x2_t)vrev64q_s8(v3[-3]);
    int64x2_t v11 = (int64x2_t)vrev64q_s8(v3[-2]);
    int64x2_t v12 = (int64x2_t)vrev64q_s8(v3[-1]);
    i8 = &xmmword_1800B9530;
    int64x2_t v240 = vaddq_s64((int64x2_t)sha512_K, v5);
    int64x2_t v241 = vaddq_s64(unk_1800B94C0, v6);
    int64x2_t v242 = vaddq_s64(unk_1800B94D0, v7);
    int64x2_t v243 = vaddq_s64(unk_1800B94E0, v8);
    int64x2_t v244 = vaddq_s64((int64x2_t)xmmword_1800B94F0, v9);
    int64x2_t v245 = vaddq_s64(unk_1800B9500, v10);
    int64x2_t v246 = vaddq_s64(unk_1800B9510, v11);
    int64x2_t v247 = vaddq_s64(unk_1800B9520, v12);
    while (1)
    {
      uint64_t v14 = *result;
      uint64_t v15 = result[1];
      uint64_t v16 = result[2];
      uint64_t v17 = result[3];
      uint64_t v18 = result[4];
      uint64_t v19 = result[5];
      uint64_t v20 = result[6];
      uint64_t v21 = result[7];
      int v22 = 4;
      do
      {
        int64x2_t v23 = (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
        int8x16_t v24 = (int8x16_t)vshrq_n_u64((uint64x2_t)v12, 0x13uLL);
        int64x2_t v25 = vshlq_n_s64(v12, 3uLL);
        uint64_t v26 = v21
            + v240.i64[0]
            + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
            + ((v19 ^ v20) & v18 ^ v20);
        int8x16_t v27 = (int8x16_t)vshrq_n_u64((uint64x2_t)v23, 1uLL);
        int64x2_t v28 = vshlq_n_s64(v23, 0x38uLL);
        uint64_t v29 = v17 + v26;
        uint64_t v30 = v26 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
        int8x16_t v31 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v12, 6uLL), v24), (int8x16_t)v25),  (int8x16_t)vshrq_n_u64((uint64x2_t)v24, 0x2AuLL));
        int64x2_t v32 = (int64x2_t)*i8;
        uint64_t v33 = (int64x2_t *)(i8 + 1);
        int64x2_t v5 = vaddq_s64( vaddq_s64( vaddq_s64(v5, (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL)),  (int64x2_t)veorq_s8(v31, (int8x16_t)vshlq_n_s64(v25, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v23, 7uLL), v27), (int8x16_t)v28),  (int8x16_t)vshrq_n_u64((uint64x2_t)v27, 7uLL)),  (int8x16_t)vshlq_n_s64(v28, 7uLL)));
        uint64_t v34 = v20
            + v240.i64[1]
            + (__ROR8__(v29, 14) ^ __ROR8__(v29, 18) ^ __ROR8__(v29, 41))
            + ((v18 ^ v19) & v29 ^ v19);
        uint64_t v35 = v16 + v34;
        uint64_t v36 = v34 + (__ROR8__(v30, 28) ^ __ROR8__(v30, 34) ^ __ROR8__(v30, 39)) + ((v14 ^ v15) & v30 ^ v14 & v15);
        int64x2_t v240 = vaddq_s64(v32, v5);
        int64x2_t v37 = (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL);
        int8x16_t v38 = (int8x16_t)vshrq_n_u64((uint64x2_t)v5, 0x13uLL);
        int64x2_t v39 = vshlq_n_s64(v5, 3uLL);
        uint64_t v40 = v19
            + v241.i64[0]
            + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41))
            + ((v29 ^ v18) & v35 ^ v18);
        int8x16_t v41 = (int8x16_t)vshrq_n_u64((uint64x2_t)v37, 1uLL);
        int64x2_t v42 = vshlq_n_s64(v37, 0x38uLL);
        uint64_t v43 = v15 + v40;
        uint64_t v44 = v40 + (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + ((v30 ^ v14) & v36 ^ v30 & v14);
        int8x16_t v45 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v5, 6uLL), v38), (int8x16_t)v39),  (int8x16_t)vshrq_n_u64((uint64x2_t)v38, 0x2AuLL));
        int64x2_t v46 = *v33++;
        int64x2_t v6 = vaddq_s64( vaddq_s64( vaddq_s64(v6, (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL)),  (int64x2_t)veorq_s8(v45, (int8x16_t)vshlq_n_s64(v39, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v37, 7uLL), v41), (int8x16_t)v42),  (int8x16_t)vshrq_n_u64((uint64x2_t)v41, 7uLL)),  (int8x16_t)vshlq_n_s64(v42, 7uLL)));
        uint64_t v47 = v18
            + v241.i64[1]
            + (__ROR8__(v43, 14) ^ __ROR8__(v43, 18) ^ __ROR8__(v43, 41))
            + ((v35 ^ v29) & v43 ^ v29);
        uint64_t v48 = v14 + v47;
        uint64_t v49 = v47 + (__ROR8__(v44, 28) ^ __ROR8__(v44, 34) ^ __ROR8__(v44, 39)) + ((v36 ^ v30) & v44 ^ v36 & v30);
        int64x2_t v241 = vaddq_s64(v46, v6);
        int64x2_t v50 = (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL);
        int8x16_t v51 = (int8x16_t)vshrq_n_u64((uint64x2_t)v6, 0x13uLL);
        int64x2_t v52 = vshlq_n_s64(v6, 3uLL);
        uint64_t v53 = v29
            + v242.i64[0]
            + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41))
            + ((v43 ^ v35) & v48 ^ v35);
        int8x16_t v54 = (int8x16_t)vshrq_n_u64((uint64x2_t)v50, 1uLL);
        int64x2_t v55 = vshlq_n_s64(v50, 0x38uLL);
        uint64_t v56 = v30 + v53;
        uint64_t v57 = v53 + (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + ((v44 ^ v36) & v49 ^ v44 & v36);
        int8x16_t v58 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v6, 6uLL), v51), (int8x16_t)v52),  (int8x16_t)vshrq_n_u64((uint64x2_t)v51, 0x2AuLL));
        int64x2_t v59 = *v33++;
        int64x2_t v7 = vaddq_s64( vaddq_s64( vaddq_s64(v7, (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL)),  (int64x2_t)veorq_s8(v58, (int8x16_t)vshlq_n_s64(v52, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v50, 7uLL), v54), (int8x16_t)v55),  (int8x16_t)vshrq_n_u64((uint64x2_t)v54, 7uLL)),  (int8x16_t)vshlq_n_s64(v55, 7uLL)));
        uint64_t v60 = v35
            + v242.i64[1]
            + (__ROR8__(v56, 14) ^ __ROR8__(v56, 18) ^ __ROR8__(v56, 41))
            + ((v48 ^ v43) & v56 ^ v43);
        uint64_t v61 = v36 + v60;
        uint64_t v62 = v60 + (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + ((v49 ^ v44) & v57 ^ v49 & v44);
        int64x2_t v242 = vaddq_s64(v59, v7);
        int64x2_t v63 = (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL);
        int8x16_t v64 = (int8x16_t)vshrq_n_u64((uint64x2_t)v7, 0x13uLL);
        int64x2_t v65 = vshlq_n_s64(v7, 3uLL);
        uint64_t v66 = v43
            + v243.i64[0]
            + (__ROR8__(v61, 14) ^ __ROR8__(v61, 18) ^ __ROR8__(v61, 41))
            + ((v56 ^ v48) & v61 ^ v48);
        int8x16_t v67 = (int8x16_t)vshrq_n_u64((uint64x2_t)v63, 1uLL);
        int64x2_t v68 = vshlq_n_s64(v63, 0x38uLL);
        uint64_t v69 = v44 + v66;
        uint64_t v70 = v66 + (__ROR8__(v62, 28) ^ __ROR8__(v62, 34) ^ __ROR8__(v62, 39)) + ((v57 ^ v49) & v62 ^ v57 & v49);
        int8x16_t v71 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v7, 6uLL), v64), (int8x16_t)v65),  (int8x16_t)vshrq_n_u64((uint64x2_t)v64, 0x2AuLL));
        int64x2_t v72 = *v33++;
        int64x2_t v8 = vaddq_s64( vaddq_s64( vaddq_s64(v8, (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL)),  (int64x2_t)veorq_s8(v71, (int8x16_t)vshlq_n_s64(v65, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v63, 7uLL), v67), (int8x16_t)v68),  (int8x16_t)vshrq_n_u64((uint64x2_t)v67, 7uLL)),  (int8x16_t)vshlq_n_s64(v68, 7uLL)));
        uint64_t v73 = v48
            + v243.i64[1]
            + (__ROR8__(v69, 14) ^ __ROR8__(v69, 18) ^ __ROR8__(v69, 41))
            + ((v61 ^ v56) & v69 ^ v56);
        uint64_t v74 = v49 + v73;
        uint64_t v75 = v73 + (__ROR8__(v70, 28) ^ __ROR8__(v70, 34) ^ __ROR8__(v70, 39)) + ((v62 ^ v57) & v70 ^ v62 & v57);
        int64x2_t v243 = vaddq_s64(v72, v8);
        int64x2_t v76 = (int64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v10, 8uLL);
        int8x16_t v77 = (int8x16_t)vshrq_n_u64((uint64x2_t)v8, 0x13uLL);
        int64x2_t v78 = vshlq_n_s64(v8, 3uLL);
        uint64_t v79 = v56
            + v244.i64[0]
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41))
            + ((v69 ^ v61) & v74 ^ v61);
        int8x16_t v80 = (int8x16_t)vshrq_n_u64((uint64x2_t)v76, 1uLL);
        int64x2_t v81 = vshlq_n_s64(v76, 0x38uLL);
        uint64_t v82 = v57 + v79;
        uint64_t v83 = v79 + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39)) + ((v70 ^ v62) & v75 ^ v70 & v62);
        int8x16_t v84 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v8, 6uLL), v77), (int8x16_t)v78),  (int8x16_t)vshrq_n_u64((uint64x2_t)v77, 0x2AuLL));
        int64x2_t v85 = *v33++;
        int64x2_t v9 = vaddq_s64( vaddq_s64( vaddq_s64(v9, (int64x2_t)vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL)),  (int64x2_t)veorq_s8(v84, (int8x16_t)vshlq_n_s64(v78, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v76, 7uLL), v80), (int8x16_t)v81),  (int8x16_t)vshrq_n_u64((uint64x2_t)v80, 7uLL)),  (int8x16_t)vshlq_n_s64(v81, 7uLL)));
        uint64_t v86 = v61
            + v244.i64[1]
            + (__ROR8__(v82, 14) ^ __ROR8__(v82, 18) ^ __ROR8__(v82, 41))
            + ((v74 ^ v69) & v82 ^ v69);
        uint64_t v87 = v62 + v86;
        uint64_t v88 = v86 + (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39)) + ((v75 ^ v70) & v83 ^ v75 & v70);
        int64x2_t v244 = vaddq_s64(v85, v9);
        int64x2_t v89 = (int64x2_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL);
        int8x16_t v90 = (int8x16_t)vshrq_n_u64((uint64x2_t)v9, 0x13uLL);
        int64x2_t v91 = vshlq_n_s64(v9, 3uLL);
        uint64_t v92 = v69
            + v245.i64[0]
            + (__ROR8__(v87, 14) ^ __ROR8__(v87, 18) ^ __ROR8__(v87, 41))
            + ((v82 ^ v74) & v87 ^ v74);
        int8x16_t v93 = (int8x16_t)vshrq_n_u64((uint64x2_t)v89, 1uLL);
        int64x2_t v94 = vshlq_n_s64(v89, 0x38uLL);
        uint64_t v95 = v70 + v92;
        uint64_t v96 = v92 + (__ROR8__(v88, 28) ^ __ROR8__(v88, 34) ^ __ROR8__(v88, 39)) + ((v83 ^ v75) & v88 ^ v83 & v75);
        int8x16_t v97 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v9, 6uLL), v90), (int8x16_t)v91),  (int8x16_t)vshrq_n_u64((uint64x2_t)v90, 0x2AuLL));
        int64x2_t v98 = *v33++;
        int64x2_t v10 = vaddq_s64( vaddq_s64( vaddq_s64(v10, (int64x2_t)vextq_s8((int8x16_t)v6, (int8x16_t)v7, 8uLL)),  (int64x2_t)veorq_s8(v97, (int8x16_t)vshlq_n_s64(v91, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v89, 7uLL), v93), (int8x16_t)v94),  (int8x16_t)vshrq_n_u64((uint64x2_t)v93, 7uLL)),  (int8x16_t)vshlq_n_s64(v94, 7uLL)));
        uint64_t v99 = v74
            + v245.i64[1]
            + (__ROR8__(v95, 14) ^ __ROR8__(v95, 18) ^ __ROR8__(v95, 41))
            + ((v87 ^ v82) & v95 ^ v82);
        uint64_t v100 = v75 + v99;
        uint64_t v101 = v99 + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + ((v88 ^ v83) & v96 ^ v88 & v83);
        int64x2_t v245 = vaddq_s64(v98, v10);
        int64x2_t v102 = (int64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v12, 8uLL);
        int8x16_t v103 = (int8x16_t)vshrq_n_u64((uint64x2_t)v10, 0x13uLL);
        int64x2_t v104 = vshlq_n_s64(v10, 3uLL);
        uint64_t v105 = v82
             + v246.i64[0]
             + (__ROR8__(v100, 14) ^ __ROR8__(v100, 18) ^ __ROR8__(v100, 41))
             + ((v95 ^ v87) & v100 ^ v87);
        int8x16_t v106 = (int8x16_t)vshrq_n_u64((uint64x2_t)v102, 1uLL);
        int64x2_t v107 = vshlq_n_s64(v102, 0x38uLL);
        uint64_t v21 = v83 + v105;
        uint64_t v17 = v105 + (__ROR8__(v101, 28) ^ __ROR8__(v101, 34) ^ __ROR8__(v101, 39)) + ((v96 ^ v88) & v101 ^ v96 & v88);
        int8x16_t v108 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v10, 6uLL), v103), (int8x16_t)v104),  (int8x16_t)vshrq_n_u64((uint64x2_t)v103, 0x2AuLL));
        int64x2_t v109 = *v33++;
        int64x2_t v11 = vaddq_s64( vaddq_s64( vaddq_s64(v11, (int64x2_t)vextq_s8((int8x16_t)v7, (int8x16_t)v8, 8uLL)),  (int64x2_t)veorq_s8(v108, (int8x16_t)vshlq_n_s64(v104, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v102, 7uLL), v106), (int8x16_t)v107),  (int8x16_t)vshrq_n_u64((uint64x2_t)v106, 7uLL)),  (int8x16_t)vshlq_n_s64(v107, 7uLL)));
        uint64_t v110 = v87
             + v246.i64[1]
             + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41))
             + ((v100 ^ v95) & v21 ^ v95);
        uint64_t v20 = v88 + v110;
        uint64_t v16 = v110 + (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + ((v101 ^ v96) & v17 ^ v101 & v96);
        int64x2_t v246 = vaddq_s64(v109, v11);
        int64x2_t v111 = (int64x2_t)vextq_s8((int8x16_t)v12, (int8x16_t)v5, 8uLL);
        int8x16_t v112 = (int8x16_t)vshrq_n_u64((uint64x2_t)v11, 0x13uLL);
        int64x2_t v113 = vshlq_n_s64(v11, 3uLL);
        uint64_t v114 = v95
             + v247.i64[0]
             + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41))
             + ((v21 ^ v100) & v20 ^ v100);
        int8x16_t v115 = (int8x16_t)vshrq_n_u64((uint64x2_t)v111, 1uLL);
        int64x2_t v116 = vshlq_n_s64(v111, 0x38uLL);
        uint64_t v19 = v96 + v114;
        uint64_t v15 = v114 + (__ROR8__(v16, 28) ^ __ROR8__(v16, 34) ^ __ROR8__(v16, 39)) + ((v17 ^ v101) & v16 ^ v17 & v101);
        int8x16_t v117 = veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v11, 6uLL), v112), (int8x16_t)v113),  (int8x16_t)vshrq_n_u64((uint64x2_t)v112, 0x2AuLL));
        int64x2_t v118 = *v33;
        i8 = (__int128 *)v33[1].i8;
        int64x2_t v12 = vaddq_s64( vaddq_s64( vaddq_s64(v12, (int64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v9, 8uLL)),  (int64x2_t)veorq_s8(v117, (int8x16_t)vshlq_n_s64(v113, 0x2AuLL))),  (int64x2_t)veorq_s8( veorq_s8( veorq_s8(veorq_s8((int8x16_t)vshrq_n_u64((uint64x2_t)v111, 7uLL), v115), (int8x16_t)v116),  (int8x16_t)vshrq_n_u64((uint64x2_t)v115, 7uLL)),  (int8x16_t)vshlq_n_s64(v116, 7uLL)));
        uint64_t v119 = v100
             + v247.i64[1]
             + (__ROR8__(v19, 14) ^ __ROR8__(v19, 18) ^ __ROR8__(v19, 41))
             + ((v20 ^ v21) & v19 ^ v21);
        uint64_t v18 = v101 + v119;
        uint64_t v14 = v119 + (__ROR8__(v15, 28) ^ __ROR8__(v15, 34) ^ __ROR8__(v15, 39)) + ((v16 ^ v17) & v15 ^ v16 & v17);
        int64x2_t v247 = vaddq_s64(v118, v12);
        BOOL v120 = __OFSUB__(v22--, 1);
      }

      while (!((v22 < 0) ^ v120 | (v22 == 0)));
      uint64_t v121 = i8 - 40;
      if (!--a2) {
        break;
      }
      int8x16_t v123 = *v3;
      __int128 v122 = v3 + 1;
      uint64_t v124 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
      int64x2_t v126 = (int64x2_t)*v121;
      __int128 v125 = (int64x2_t *)(v121 + 1);
      uint64_t v127 = v17 + v124;
      uint64_t v128 = v124 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
      int64x2_t v5 = (int64x2_t)vrev64q_s8(v123);
      uint64_t v129 = v20
           + v240.i64[1]
           + (__ROR8__(v127, 14) ^ __ROR8__(v127, 18) ^ __ROR8__(v127, 41))
           + ((v18 ^ v19) & v127 ^ v19);
      uint64_t v130 = v16 + v129;
      int64x2_t v240 = vaddq_s64(v126, v5);
      uint64_t v131 = v129 + (__ROR8__(v128, 28) ^ __ROR8__(v128, 34) ^ __ROR8__(v128, 39)) + ((v14 ^ v15) & v128 ^ v14 & v15);
      int8x16_t v132 = *v122++;
      uint64_t v133 = v19
           + v241.i64[0]
           + (__ROR8__(v130, 14) ^ __ROR8__(v130, 18) ^ __ROR8__(v130, 41))
           + ((v127 ^ v18) & v130 ^ v18);
      int64x2_t v134 = *v125++;
      uint64_t v135 = v15 + v133;
      uint64_t v136 = v133 + (__ROR8__(v131, 28) ^ __ROR8__(v131, 34) ^ __ROR8__(v131, 39)) + ((v128 ^ v14) & v131 ^ v128 & v14);
      int64x2_t v6 = (int64x2_t)vrev64q_s8(v132);
      uint64_t v137 = v18
           + v241.i64[1]
           + (__ROR8__(v135, 14) ^ __ROR8__(v135, 18) ^ __ROR8__(v135, 41))
           + ((v130 ^ v127) & v135 ^ v127);
      uint64_t v138 = v14 + v137;
      int64x2_t v241 = vaddq_s64(v134, v6);
      uint64_t v139 = v137
           + (__ROR8__(v136, 28) ^ __ROR8__(v136, 34) ^ __ROR8__(v136, 39))
           + ((v131 ^ v128) & v136 ^ v131 & v128);
      int8x16_t v140 = *v122++;
      uint64_t v141 = v127
           + v242.i64[0]
           + (__ROR8__(v138, 14) ^ __ROR8__(v138, 18) ^ __ROR8__(v138, 41))
           + ((v135 ^ v130) & v138 ^ v130);
      int64x2_t v142 = *v125++;
      uint64_t v143 = v128 + v141;
      uint64_t v144 = v141
           + (__ROR8__(v139, 28) ^ __ROR8__(v139, 34) ^ __ROR8__(v139, 39))
           + ((v136 ^ v131) & v139 ^ v136 & v131);
      int64x2_t v7 = (int64x2_t)vrev64q_s8(v140);
      uint64_t v145 = v130
           + v242.i64[1]
           + (__ROR8__(v143, 14) ^ __ROR8__(v143, 18) ^ __ROR8__(v143, 41))
           + ((v138 ^ v135) & v143 ^ v135);
      uint64_t v146 = v131 + v145;
      int64x2_t v242 = vaddq_s64(v142, v7);
      uint64_t v147 = v145
           + (__ROR8__(v144, 28) ^ __ROR8__(v144, 34) ^ __ROR8__(v144, 39))
           + ((v139 ^ v136) & v144 ^ v139 & v136);
      int8x16_t v148 = *v122++;
      uint64_t v149 = v135
           + v243.i64[0]
           + (__ROR8__(v146, 14) ^ __ROR8__(v146, 18) ^ __ROR8__(v146, 41))
           + ((v143 ^ v138) & v146 ^ v138);
      int64x2_t v150 = *v125++;
      uint64_t v151 = v136 + v149;
      uint64_t v152 = v149
           + (__ROR8__(v147, 28) ^ __ROR8__(v147, 34) ^ __ROR8__(v147, 39))
           + ((v144 ^ v139) & v147 ^ v144 & v139);
      int64x2_t v8 = (int64x2_t)vrev64q_s8(v148);
      uint64_t v153 = v138
           + v243.i64[1]
           + (__ROR8__(v151, 14) ^ __ROR8__(v151, 18) ^ __ROR8__(v151, 41))
           + ((v146 ^ v143) & v151 ^ v143);
      uint64_t v154 = v139 + v153;
      int64x2_t v243 = vaddq_s64(v150, v8);
      uint64_t v155 = v153
           + (__ROR8__(v152, 28) ^ __ROR8__(v152, 34) ^ __ROR8__(v152, 39))
           + ((v147 ^ v144) & v152 ^ v147 & v144);
      int8x16_t v156 = *v122++;
      uint64_t v157 = v143
           + v244.i64[0]
           + (__ROR8__(v154, 14) ^ __ROR8__(v154, 18) ^ __ROR8__(v154, 41))
           + ((v151 ^ v146) & v154 ^ v146);
      int64x2_t v158 = *v125++;
      uint64_t v159 = v144 + v157;
      uint64_t v160 = v157
           + (__ROR8__(v155, 28) ^ __ROR8__(v155, 34) ^ __ROR8__(v155, 39))
           + ((v152 ^ v147) & v155 ^ v152 & v147);
      int64x2_t v9 = (int64x2_t)vrev64q_s8(v156);
      uint64_t v161 = v146
           + v244.i64[1]
           + (__ROR8__(v159, 14) ^ __ROR8__(v159, 18) ^ __ROR8__(v159, 41))
           + ((v154 ^ v151) & v159 ^ v151);
      uint64_t v162 = v147 + v161;
      int64x2_t v244 = vaddq_s64(v158, v9);
      uint64_t v163 = v161
           + (__ROR8__(v160, 28) ^ __ROR8__(v160, 34) ^ __ROR8__(v160, 39))
           + ((v155 ^ v152) & v160 ^ v155 & v152);
      int8x16_t v164 = *v122++;
      uint64_t v165 = v151
           + v245.i64[0]
           + (__ROR8__(v162, 14) ^ __ROR8__(v162, 18) ^ __ROR8__(v162, 41))
           + ((v159 ^ v154) & v162 ^ v154);
      int64x2_t v166 = *v125++;
      uint64_t v167 = v152 + v165;
      uint64_t v168 = v165
           + (__ROR8__(v163, 28) ^ __ROR8__(v163, 34) ^ __ROR8__(v163, 39))
           + ((v160 ^ v155) & v163 ^ v160 & v155);
      int64x2_t v10 = (int64x2_t)vrev64q_s8(v164);
      uint64_t v169 = v154
           + v245.i64[1]
           + (__ROR8__(v167, 14) ^ __ROR8__(v167, 18) ^ __ROR8__(v167, 41))
           + ((v162 ^ v159) & v167 ^ v159);
      uint64_t v170 = v155 + v169;
      int64x2_t v245 = vaddq_s64(v166, v10);
      uint64_t v171 = v169
           + (__ROR8__(v168, 28) ^ __ROR8__(v168, 34) ^ __ROR8__(v168, 39))
           + ((v163 ^ v160) & v168 ^ v163 & v160);
      int8x16_t v172 = *v122++;
      uint64_t v173 = v159
           + v246.i64[0]
           + (__ROR8__(v170, 14) ^ __ROR8__(v170, 18) ^ __ROR8__(v170, 41))
           + ((v167 ^ v162) & v170 ^ v162);
      int64x2_t v174 = *v125++;
      uint64_t v175 = v160 + v173;
      uint64_t v176 = v173
           + (__ROR8__(v171, 28) ^ __ROR8__(v171, 34) ^ __ROR8__(v171, 39))
           + ((v168 ^ v163) & v171 ^ v168 & v163);
      int64x2_t v11 = (int64x2_t)vrev64q_s8(v172);
      uint64_t v177 = v162
           + v246.i64[1]
           + (__ROR8__(v175, 14) ^ __ROR8__(v175, 18) ^ __ROR8__(v175, 41))
           + ((v170 ^ v167) & v175 ^ v167);
      uint64_t v178 = v163 + v177;
      int64x2_t v246 = vaddq_s64(v174, v11);
      uint64_t v179 = v177
           + (__ROR8__(v176, 28) ^ __ROR8__(v176, 34) ^ __ROR8__(v176, 39))
           + ((v171 ^ v168) & v176 ^ v171 & v168);
      int8x16_t v180 = *v122;
      char v3 = v122 + 1;
      uint64_t v181 = v167
           + v247.i64[0]
           + (__ROR8__(v178, 14) ^ __ROR8__(v178, 18) ^ __ROR8__(v178, 41))
           + ((v175 ^ v170) & v178 ^ v170);
      int64x2_t v182 = *v125;
      i8 = (__int128 *)v125[1].i8;
      uint64_t v183 = v168 + v181;
      uint64_t v184 = v181
           + (__ROR8__(v179, 28) ^ __ROR8__(v179, 34) ^ __ROR8__(v179, 39))
           + ((v176 ^ v171) & v179 ^ v176 & v171);
      int64x2_t v12 = (int64x2_t)vrev64q_s8(v180);
      uint64_t v185 = v170
           + v247.i64[1]
           + (__ROR8__(v183, 14) ^ __ROR8__(v183, 18) ^ __ROR8__(v183, 41))
           + ((v178 ^ v175) & v183 ^ v175);
      int64x2_t v247 = vaddq_s64(v182, v12);
      uint64_t v186 = result[1] + v184;
      *result += v185
               + (__ROR8__(v184, 28) ^ __ROR8__(v184, 34) ^ __ROR8__(v184, 39))
               + ((v179 ^ v176) & v184 ^ v179 & v176);
      result[1] = v186;
      uint64_t v187 = result[3] + v176;
      result[2] += v179;
      result[3] = v187;
      uint64_t v188 = result[5] + v183;
      result[4] += v171 + v185;
      result[5] = v188;
      uint64_t v189 = result[7] + v175;
      result[6] += v178;
      result[7] = v189;
    }

    uint64_t v190 = v21 + v240.i64[0] + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41)) + ((v19 ^ v20) & v18 ^ v20);
    uint64_t v191 = v17 + v190;
    uint64_t v192 = v190 + (__ROR8__(v14, 28) ^ __ROR8__(v14, 34) ^ __ROR8__(v14, 39)) + ((v15 ^ v16) & v14 ^ v15 & v16);
    uint64_t v193 = v20
         + v240.i64[1]
         + (__ROR8__(v191, 14) ^ __ROR8__(v191, 18) ^ __ROR8__(v191, 41))
         + ((v18 ^ v19) & v191 ^ v19);
    uint64_t v194 = v16 + v193;
    uint64_t v195 = v193 + (__ROR8__(v192, 28) ^ __ROR8__(v192, 34) ^ __ROR8__(v192, 39)) + ((v14 ^ v15) & v192 ^ v14 & v15);
    uint64_t v196 = v19
         + v241.i64[0]
         + (__ROR8__(v194, 14) ^ __ROR8__(v194, 18) ^ __ROR8__(v194, 41))
         + ((v191 ^ v18) & v194 ^ v18);
    uint64_t v197 = v15 + v196;
    uint64_t v198 = v196 + (__ROR8__(v195, 28) ^ __ROR8__(v195, 34) ^ __ROR8__(v195, 39)) + ((v192 ^ v14) & v195 ^ v192 & v14);
    uint64_t v199 = v18
         + v241.i64[1]
         + (__ROR8__(v197, 14) ^ __ROR8__(v197, 18) ^ __ROR8__(v197, 41))
         + ((v194 ^ v191) & v197 ^ v191);
    uint64_t v200 = v14 + v199;
    uint64_t v201 = v199 + (__ROR8__(v198, 28) ^ __ROR8__(v198, 34) ^ __ROR8__(v198, 39)) + ((v195 ^ v192) & v198 ^ v195 & v192);
    uint64_t v202 = v191
         + v242.i64[0]
         + (__ROR8__(v200, 14) ^ __ROR8__(v200, 18) ^ __ROR8__(v200, 41))
         + ((v197 ^ v194) & v200 ^ v194);
    uint64_t v203 = v192 + v202;
    uint64_t v204 = v202 + (__ROR8__(v201, 28) ^ __ROR8__(v201, 34) ^ __ROR8__(v201, 39)) + ((v198 ^ v195) & v201 ^ v198 & v195);
    uint64_t v205 = v194
         + v242.i64[1]
         + (__ROR8__(v203, 14) ^ __ROR8__(v203, 18) ^ __ROR8__(v203, 41))
         + ((v200 ^ v197) & v203 ^ v197);
    uint64_t v206 = v195 + v205;
    uint64_t v207 = v205 + (__ROR8__(v204, 28) ^ __ROR8__(v204, 34) ^ __ROR8__(v204, 39)) + ((v201 ^ v198) & v204 ^ v201 & v198);
    uint64_t v208 = v197
         + v243.i64[0]
         + (__ROR8__(v206, 14) ^ __ROR8__(v206, 18) ^ __ROR8__(v206, 41))
         + ((v203 ^ v200) & v206 ^ v200);
    uint64_t v209 = v198 + v208;
    uint64_t v210 = v208 + (__ROR8__(v207, 28) ^ __ROR8__(v207, 34) ^ __ROR8__(v207, 39)) + ((v204 ^ v201) & v207 ^ v204 & v201);
    uint64_t v211 = v200
         + v243.i64[1]
         + (__ROR8__(v209, 14) ^ __ROR8__(v209, 18) ^ __ROR8__(v209, 41))
         + ((v206 ^ v203) & v209 ^ v203);
    uint64_t v212 = v201 + v211;
    uint64_t v213 = v211 + (__ROR8__(v210, 28) ^ __ROR8__(v210, 34) ^ __ROR8__(v210, 39)) + ((v207 ^ v204) & v210 ^ v207 & v204);
    uint64_t v214 = v203
         + v244.i64[0]
         + (__ROR8__(v212, 14) ^ __ROR8__(v212, 18) ^ __ROR8__(v212, 41))
         + ((v209 ^ v206) & v212 ^ v206);
    uint64_t v215 = v204 + v214;
    uint64_t v216 = v214 + (__ROR8__(v213, 28) ^ __ROR8__(v213, 34) ^ __ROR8__(v213, 39)) + ((v210 ^ v207) & v213 ^ v210 & v207);
    uint64_t v217 = v206
         + v244.i64[1]
         + (__ROR8__(v215, 14) ^ __ROR8__(v215, 18) ^ __ROR8__(v215, 41))
         + ((v212 ^ v209) & v215 ^ v209);
    uint64_t v218 = v207 + v217;
    uint64_t v219 = v217 + (__ROR8__(v216, 28) ^ __ROR8__(v216, 34) ^ __ROR8__(v216, 39)) + ((v213 ^ v210) & v216 ^ v213 & v210);
    uint64_t v220 = v209
         + v245.i64[0]
         + (__ROR8__(v218, 14) ^ __ROR8__(v218, 18) ^ __ROR8__(v218, 41))
         + ((v215 ^ v212) & v218 ^ v212);
    uint64_t v221 = v210 + v220;
    uint64_t v222 = v220 + (__ROR8__(v219, 28) ^ __ROR8__(v219, 34) ^ __ROR8__(v219, 39)) + ((v216 ^ v213) & v219 ^ v216 & v213);
    uint64_t v223 = v212
         + v245.i64[1]
         + (__ROR8__(v221, 14) ^ __ROR8__(v221, 18) ^ __ROR8__(v221, 41))
         + ((v218 ^ v215) & v221 ^ v215);
    uint64_t v224 = v213 + v223;
    uint64_t v225 = v223 + (__ROR8__(v222, 28) ^ __ROR8__(v222, 34) ^ __ROR8__(v222, 39)) + ((v219 ^ v216) & v222 ^ v219 & v216);
    uint64_t v226 = v215
         + v246.i64[0]
         + (__ROR8__(v224, 14) ^ __ROR8__(v224, 18) ^ __ROR8__(v224, 41))
         + ((v221 ^ v218) & v224 ^ v218);
    uint64_t v227 = v216 + v226;
    uint64_t v228 = v226 + (__ROR8__(v225, 28) ^ __ROR8__(v225, 34) ^ __ROR8__(v225, 39)) + ((v222 ^ v219) & v225 ^ v222 & v219);
    uint64_t v229 = v218
         + v246.i64[1]
         + (__ROR8__(v227, 14) ^ __ROR8__(v227, 18) ^ __ROR8__(v227, 41))
         + ((v224 ^ v221) & v227 ^ v221);
    uint64_t v230 = v219 + v229;
    uint64_t v231 = v229 + (__ROR8__(v228, 28) ^ __ROR8__(v228, 34) ^ __ROR8__(v228, 39)) + ((v225 ^ v222) & v228 ^ v225 & v222);
    uint64_t v232 = v221
         + v247.i64[0]
         + (__ROR8__(v230, 14) ^ __ROR8__(v230, 18) ^ __ROR8__(v230, 41))
         + ((v227 ^ v224) & v230 ^ v224);
    uint64_t v233 = v222 + v232;
    uint64_t v234 = v232 + (__ROR8__(v231, 28) ^ __ROR8__(v231, 34) ^ __ROR8__(v231, 39)) + ((v228 ^ v225) & v231 ^ v228 & v225);
    uint64_t v235 = v224
         + v247.i64[1]
         + (__ROR8__(v233, 14) ^ __ROR8__(v233, 18) ^ __ROR8__(v233, 41))
         + ((v230 ^ v227) & v233 ^ v227);
    uint64_t v236 = result[1] + v234;
    *result += v235
             + (__ROR8__(v234, 28) ^ __ROR8__(v234, 34) ^ __ROR8__(v234, 39))
             + ((v231 ^ v228) & v234 ^ v231 & v228);
    result[1] = v236;
    uint64_t v237 = result[3] + v228;
    result[2] += v231;
    result[3] = v237;
    uint64_t v238 = result[5] + v233;
    result[4] += v225 + v235;
    result[5] = v238;
    uint64_t v239 = result[7] + v227;
    result[6] += v230;
    result[7] = v239;
  }

  return result;
}

void *ccsha1_di()
{
  return &ccsha1_vng_arm_di;
}

int64x2_t *AccelerateCrypto_SHA512_compress_hwassist(int64x2_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int64x2_t v3 = *result;
    int64x2_t v4 = result[1];
    int64x2_t v5 = result[2];
    int64x2_t v6 = result[3];
    do
    {
      _Q24 = v3;
      _Q25 = v4;
      _Q0 = vrev64q_s8(*a3);
      _Q1 = vrev64q_s8(a3[1]);
      _Q2 = vrev64q_s8(a3[2]);
      _Q3 = vrev64q_s8(a3[3]);
      _Q4 = vrev64q_s8(a3[4]);
      _Q5 = vrev64q_s8(a3[5]);
      _Q6 = vrev64q_s8(a3[6]);
      _Q7 = vrev64q_s8(a3[7]);
      a3 += 8;
      _Q29 = vextq_s8((int8x16_t)v5, (int8x16_t)v6, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v26 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v29 = (int8x16_t)vaddq_s64(v4, v26);
      _Q29 = vextq_s8(v29, (int8x16_t)v5, 8uLL);
      _Q28 = vextq_s8((int8x16_t)v3, v29, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v35 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v38 = (int8x16_t)vaddq_s64(v3, v35);
      _Q29 = vextq_s8(v38, v29, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v38, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v44 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v47 = (int8x16_t)vaddq_s64(_Q27, v44);
      _Q29 = vextq_s8(v47, v38, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v47, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v53 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v56 = (int8x16_t)vaddq_s64(_Q26, v53);
      _Q29 = vextq_s8(v56, v47, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v56, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v62 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v65 = (int8x16_t)vaddq_s64(_Q25, v62);
      _Q29 = vextq_s8(v65, v56, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v65, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v71 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v74 = (int8x16_t)vaddq_s64(_Q24, v71);
      _Q29 = vextq_s8(v74, v65, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v74, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v80 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v83 = (int8x16_t)vaddq_s64(_Q27, v80);
      _Q29 = vextq_s8(v83, v74, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v83, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v89 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v92 = (int8x16_t)vaddq_s64(_Q26, v89);
      _Q29 = vextq_s8(v92, v83, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v92, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v98 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v101 = (int8x16_t)vaddq_s64(_Q25, v98);
      _Q29 = vextq_s8(v101, v92, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v101, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v107 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v110 = (int8x16_t)vaddq_s64(_Q24, v107);
      _Q29 = vextq_s8(v110, v101, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v110, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v116 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v119 = (int8x16_t)vaddq_s64(_Q27, v116);
      _Q29 = vextq_s8(v119, v110, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v119, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v125 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v128 = (int8x16_t)vaddq_s64(_Q26, v125);
      _Q29 = vextq_s8(v128, v119, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v128, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v134 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v137 = (int8x16_t)vaddq_s64(_Q25, v134);
      _Q29 = vextq_s8(v137, v128, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v137, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v143 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v146 = (int8x16_t)vaddq_s64(_Q24, v143);
      _Q29 = vextq_s8(v146, v137, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v146, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v152 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v155 = (int8x16_t)vaddq_s64(_Q27, v152);
      _Q29 = vextq_s8(v155, v146, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v155, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v161 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v164 = (int8x16_t)vaddq_s64(_Q26, v161);
      _Q29 = vextq_s8(v164, v155, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v164, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v170 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v173 = (int8x16_t)vaddq_s64(_Q25, v170);
      _Q29 = vextq_s8(v173, v164, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v173, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v179 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v182 = (int8x16_t)vaddq_s64(_Q24, v179);
      _Q29 = vextq_s8(v182, v173, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v182, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v188 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v191 = (int8x16_t)vaddq_s64(_Q27, v188);
      _Q29 = vextq_s8(v191, v182, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v191, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v197 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v200 = (int8x16_t)vaddq_s64(_Q26, v197);
      _Q29 = vextq_s8(v200, v191, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v200, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v206 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v209 = (int8x16_t)vaddq_s64(_Q25, v206);
      _Q29 = vextq_s8(v209, v200, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v209, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v215 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v218 = (int8x16_t)vaddq_s64(_Q24, v215);
      _Q29 = vextq_s8(v218, v209, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v218, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v224 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v227 = (int8x16_t)vaddq_s64(_Q27, v224);
      _Q29 = vextq_s8(v227, v218, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v227, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v233 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v236 = (int8x16_t)vaddq_s64(_Q26, v233);
      _Q29 = vextq_s8(v236, v227, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v236, 8uLL);
      _Q31 = vextq_s8(_Q4, _Q5, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V0.2D, V1.2D
      }

      int64x2_t v242 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V0.2D, V7.2D, V31.2D
      }

      int8x16_t v245 = (int8x16_t)vaddq_s64(_Q25, v242);
      _Q29 = vextq_s8(v245, v236, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v245, 8uLL);
      _Q31 = vextq_s8(_Q5, _Q6, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V1.2D, V2.2D
      }

      int64x2_t v251 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V1.2D, V0.2D, V31.2D
      }

      int8x16_t v254 = (int8x16_t)vaddq_s64(_Q24, v251);
      _Q29 = vextq_s8(v254, v245, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v254, 8uLL);
      _Q31 = vextq_s8(_Q6, _Q7, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V2.2D, V3.2D
      }

      int64x2_t v260 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V2.2D, V1.2D, V31.2D
      }

      int8x16_t v263 = (int8x16_t)vaddq_s64(_Q27, v260);
      _Q29 = vextq_s8(v263, v254, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v263, 8uLL);
      _Q31 = vextq_s8(_Q7, _Q0, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V3.2D, V4.2D
      }

      int64x2_t v269 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V3.2D, V2.2D, V31.2D
      }

      int8x16_t v272 = (int8x16_t)vaddq_s64(_Q26, v269);
      _Q29 = vextq_s8(v272, v263, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v272, 8uLL);
      _Q31 = vextq_s8(_Q0, _Q1, 8uLL);
      __asm
      {
        SHA512H         Q27, Q29, V28.2D
        SHA512SU0       V4.2D, V5.2D
      }

      int64x2_t v278 = _Q27;
      __asm
      {
        SHA512H2        Q27, Q25, V24.2D
        SHA512SU1       V4.2D, V3.2D, V31.2D
      }

      int8x16_t v281 = (int8x16_t)vaddq_s64(_Q25, v278);
      _Q29 = vextq_s8(v281, v272, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v281, 8uLL);
      _Q31 = vextq_s8(_Q1, _Q2, 8uLL);
      __asm
      {
        SHA512H         Q26, Q29, V28.2D
        SHA512SU0       V5.2D, V6.2D
      }

      int64x2_t v287 = _Q26;
      __asm
      {
        SHA512H2        Q26, Q24, V27.2D
        SHA512SU1       V5.2D, V4.2D, V31.2D
      }

      int8x16_t v290 = (int8x16_t)vaddq_s64(_Q24, v287);
      _Q29 = vextq_s8(v290, v281, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v290, 8uLL);
      _Q31 = vextq_s8(_Q2, _Q3, 8uLL);
      __asm
      {
        SHA512H         Q25, Q29, V28.2D
        SHA512SU0       V6.2D, V7.2D
      }

      int64x2_t v296 = _Q25;
      __asm
      {
        SHA512H2        Q25, Q27, V26.2D
        SHA512SU1       V6.2D, V5.2D, V31.2D
      }

      int8x16_t v299 = (int8x16_t)vaddq_s64(_Q27, v296);
      _Q29 = vextq_s8(v299, v290, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v299, 8uLL);
      _Q31 = vextq_s8(_Q3, _Q4, 8uLL);
      __asm
      {
        SHA512H         Q24, Q29, V28.2D
        SHA512SU0       V7.2D, V0.2D
      }

      int64x2_t v305 = _Q24;
      __asm
      {
        SHA512H2        Q24, Q26, V25.2D
        SHA512SU1       V7.2D, V6.2D, V31.2D
      }

      int8x16_t v308 = (int8x16_t)vaddq_s64(_Q26, v305);
      _Q29 = vextq_s8(v308, v299, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v308, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }

      int8x16_t v313 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v313, v308, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v313, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }

      int8x16_t v318 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v318, v313, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v318, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }

      int8x16_t v323 = (int8x16_t)vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8(v323, v318, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, v323, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }

      int8x16_t v328 = (int8x16_t)vaddq_s64(_Q26, _Q30);
      _Q29 = vextq_s8(v328, v323, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q25, v328, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q27, Q25, V24.2D
      }

      int8x16_t v333 = (int8x16_t)vaddq_s64(_Q25, _Q30);
      _Q29 = vextq_s8(v333, v328, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q24, v333, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q26, Q24, V27.2D
      }

      int8x16_t v338 = (int8x16_t)vaddq_s64(_Q24, _Q30);
      _Q29 = vextq_s8(v338, v333, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q27, v338, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q25, Q27, V26.2D
      }

      int64x2_t v343 = vaddq_s64(_Q27, _Q30);
      _Q29 = vextq_s8((int8x16_t)v343, v338, 8uLL);
      _Q28 = vextq_s8((int8x16_t)_Q26, (int8x16_t)v343, 8uLL);
      __asm
      {
        SHA512H         Q30, Q29, V28.2D
        SHA512H2        Q24, Q26, V25.2D
      }

      int64x2_t v3 = vaddq_s64(v3, _Q24);
      int64x2_t v4 = vaddq_s64(v4, _Q25);
      int64x2_t v5 = vaddq_s64(v5, vaddq_s64(_Q26, _Q30));
      int64x2_t v6 = vaddq_s64(v6, v343);
    }

    while (a2-- > 1);
    *ssize_t result = v3;
    result[1] = v4;
    result[2] = v5;
    result[3] = v6;
  }

  return result;
}

int32x4_t *AccelerateCrypto_SHA1_compress(int32x4_t *result, uint64_t a2, int8x16_t *a3)
{
  if (a2)
  {
    int8x16_t v5 = *a3;
    int8x16_t v6 = a3[1];
    int8x16_t v7 = a3[2];
    int8x16_t v8 = a3[3];
    int64x2_t v4 = a3 + 4;
    int32x4_t v10 = *result;
    int64x2_t v9 = result + 1;
    int32x4_t v11 = v10;
    v10.i32[0] = v9->i32[0];
    int64x2_t v12 = v9 - 1;
    v3.i32[0] = v10.i32[0];
    _Q1 = (int32x4_t)vrev32q_s8(v6);
    _Q2 = (int32x4_t)vrev32q_s8(v7);
    _Q3 = (int32x4_t)vrev32q_s8(v8);
    _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v5), *(int32x4_t *)K_XMM_AR);
    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
    _Q19 = v3;
    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = v11.i32[0];
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1C           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, loc_1800B35B0);
    __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V4.4S
      SHA1H           S19, S20
      SHA1SU1         V0.4S, V3.4S
    }

    _Q4 = vaddq_s32(_Q0, loc_1800B35B0);
    __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V5.4S
      SHA1H           S19, S20
      SHA1SU1         V1.4S, V0.4S
    }

    _Q5 = vaddq_s32(_Q1, loc_1800B35B0);
    __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1M           Q18, S19, V6.4S
      SHA1H           S19, S20
      SHA1SU1         V2.4S, V1.4S
    }

    _Q6 = vaddq_s32(_Q2, loc_1800B35B0);
    __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
      SHA1SU1         V3.4S, V2.4S
    }

    _Q7 = vaddq_s32(_Q3, loc_1800B35B0);
    BOOL v105 = a2 <= 1;
    for (uint64_t i = a2 - 1; !v105; --i)
    {
      int8x16_t v107 = *v4;
      int8x16_t v108 = v4[1];
      int8x16_t v109 = v4[2];
      int8x16_t v110 = v4[3];
      v4 += 4;
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
      }

      _Q4 = vaddq_s32((int32x4_t)vrev32q_s8(v107), *(int32x4_t *)K_XMM_AR);
      _Q1 = (int32x4_t)vrev32q_s8(v108);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)K_XMM_AR);
      _Q2 = (int32x4_t)vrev32q_s8(v109);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)K_XMM_AR);
      _Q3 = (int32x4_t)vrev32q_s8(v110);
      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)K_XMM_AR);
      _Q19 = vaddq_s32(v3, _Q19);
      int32x4_t v11 = vaddq_s32(v11, _Q18);
      int32x4_t v3 = _Q19;
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = v11.i32[0];
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)K_XMM_AR);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1C           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[2]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, *(int32x4_t *)&K_XMM_AR[4]);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, loc_1800B35B0);
      __asm { SHA1SU0         V0.4S, V1.4S, V2.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V4.4S
        SHA1H           S19, S20
        SHA1SU1         V0.4S, V3.4S
      }

      _Q4 = vaddq_s32(_Q0, loc_1800B35B0);
      __asm { SHA1SU0         V1.4S, V2.4S, V3.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V5.4S
        SHA1H           S19, S20
        SHA1SU1         V1.4S, V0.4S
      }

      _Q5 = vaddq_s32(_Q1, loc_1800B35B0);
      __asm { SHA1SU0         V2.4S, V3.4S, V0.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1M           Q18, S19, V6.4S
        SHA1H           S19, S20
        SHA1SU1         V2.4S, V1.4S
      }

      _Q6 = vaddq_s32(_Q2, loc_1800B35B0);
      __asm { SHA1SU0         V3.4S, V0.4S, V1.4S }

      _S20 = _Q18;
      __asm
      {
        SHA1P           Q18, S19, V7.4S
        SHA1H           S19, S20
        SHA1SU1         V3.4S, V2.4S
      }

      _Q7 = vaddq_s32(_Q3, loc_1800B35B0);
      BOOL v105 = i <= 1;
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V4.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V5.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V6.4S
      SHA1H           S19, S20
    }

    _S20 = _Q18;
    __asm
    {
      SHA1P           Q18, S19, V7.4S
      SHA1H           S19, S20
    }

    int32x4_t *v12 = vaddq_s32(v11, _Q18);
    ssize_t result = v12 + 1;
    result->i32[0] = vaddq_s32(v3, _Q19).u32[0];
  }

  return result;
}

uint64_t ccsha512_final(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = (uint64_t)a2 + v7 + 8;
  unint64_t v9 = v7 + 8 + v6;
  size_t v10 = (v9 + 11) & 0xFFFFFFFFFFFFFFF8LL;
  int32x4_t v11 = (uint64_t *)((char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  bzero(v11, v10);
  memmove(v11, a2, v9 + 4);
  int64x2_t v12 = (char *)v11 + v7 + 8;
  uint64_t v13 = *(unsigned int *)&v12[v6];
  *v11 += (8 * v13);
  *(_DWORD *)&v12[v6] = v13 + 1;
  v12[v13] = 0x80;
  unint64_t v14 = *(unsigned int *)&v12[v6];
  if (v6 - 16 < v14)
  {
    while (v6 > v14)
    {
      *(_DWORD *)&v12[v6] = v14 + 1;
      v12[v14] = 0;
      unint64_t v14 = *(unsigned int *)&v12[v6];
    }

    (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1LL);
    LODWORD(v14) = 0;
    uint64_t v7 = *(void *)(a1 + 8);
    unint64_t v6 = *(void *)(a1 + 16);
    *(_DWORD *)((char *)v11 + v7 + v6 + 8) = 0;
  }

  uint64_t v15 = (uint64_t)v11 + v7 + 8;
  uint64_t v16 = (_DWORD *)(v15 + v6);
  if (v6 - 8 > v14)
  {
    unint64_t v17 = v14;
    do
    {
      _DWORD *v16 = v14 + 1;
      *(_BYTE *)(v15 + v17) = 0;
      unint64_t v17 = *v16;
      LODWORD(v14) = *v16;
    }

    while (v6 - 8 > v17);
  }

  *((void *)v16 - dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = bswap64(*v11);
  (*(void (**)(void *, uint64_t))(a1 + 48))(v11 + 1, 1LL);
  if (*(void *)a1 >= 8uLL)
  {
    unsigned int v18 = 0;
    unint64_t v19 = 0LL;
    unsigned int v20 = 1;
    do
    {
      *(void *)(a3 + v18) = bswap64(v11[v19 + 1]);
      unint64_t v19 = v20++;
      v18 += 8;
    }

    while (v19 < *(void *)a1 >> 3);
  }

  return cc_clear(*(void *)(a1 + 8) + *(void *)(a1 + 16) + 12LL, v11);
}

uint64_t cc_clear(rsize_t __n, void *__s)
{
  return memset_s(__s, __n, 0, __n);
}

void *ccsha256_di()
{
  return &ccsha256_vng_arm_di;
}

void *ccsha384_di()
{
  if (MEMORY[0xFFFFFC010] < 0) {
    return &ccsha384_vng_arm_hw_di;
  }
  else {
    return &ccsha384_vng_arm_di;
  }
}

uint64_t cc_disable_dit_with_sb(unsigned int *a1)
{
  return timingsafe_restore_if_supported(*a1);
}

void __chkstk_darwin( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (___chkstk_darwin) {
    ___chkstk_darwin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else {
    __chkstk_darwin_probe(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

void __chkstk_darwin_probe( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  size_t v10 = &a9;
  if (v9 >= 0x1000)
  {
    do
    {
      v10 -= 512;
      v9 -= 4096LL;
    }

    while (v9 > 0x1000);
  }

void ___chkstk_darwin( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t mach_continuous_time(void)
{
  if (MEMORY[0xFFFFFC091])
  {
    if (MEMORY[0xFFFFFC090] == 3)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }

    else if (MEMORY[0xFFFFFC090] == 2)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
    }

    else
    {
      __isb(0xFu);
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }

    uint64_t v1 = MEMORY[0xFFFFFC0A8];
  }

  else
  {
    do
    {
      uint64_t v4 = MEMORY[0xFFFFFC098];
      uint64_t v3 = mach_absolute_time();
    }

    while (v4 != MEMORY[0xFFFFFC098]);
    unint64_t StatusReg = v3;
    uint64_t v1 = v4;
  }

  return v1 + StatusReg;
}

uint64_t mach_init()
{
  if ((mach_init_mach_init_inited & 1) == 0)
  {
    mach_task_self_ = task_self_trap();
    _task_reply_port = mach_reply_port();
    if (!vm_kernel_page_shift) {
      vm_kernel_page_shift = MEMORY[0xFFFFF4037];
    }
    if (!vm_page_shift)
    {
      vm_page_shift = MEMORY[0xFFFFF4025];
      vm_page_vm_size_t size = 1 << MEMORY[0xFFFFF4025];
      vm_page_masunint64_t k = vm_page_size - 1;
    }

    _pthread_set_self(0LL, v0, v1, v2, v3, v4, v5, v6);
    mach_init_mach_init_inited = 1;
  }

  return 0LL;
}

int64_t mach_msg2_internal( void *a1, unint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t v16 = (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL);
  int64_t result = mach_msg2_trap(a1, (void *)(a2 & 0xFFFFFFFFFFFFFBBFLL), a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    if ((a2 & 0x40) == 0)
    {
      while ((_DWORD)result == 268435463)
        int64_t result = mach_msg2_trap(a1, v16, a3, a4, a5, a6, a7, a8);
    }

    if ((a2 & 0x400) == 0 && (_DWORD)result == 268451845)
    {
      if ((~(_BYTE)a2 & 3) != 0) {
        unint64_t v18 = a2;
      }
      else {
        unint64_t v18 = a2 & 0xFFFFFFFFFFFFBBBELL;
      }
      unint64_t v19 = (void *)(v18 & 0xFFFFFFFFFFFFFBBELL);
      do
        int64_t result = mach_msg2_trap(a1, v19, (void *)a3, a4, a5, a6, a7, a8);
      while ((_DWORD)result == 268451845);
    }
  }

  return result;
}

mach_msg_return_t mach_msg_overwrite( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
{
  if (rcv_msg != 0LL && (option & 2LL) != 0) {
    uint64_t v9 = option | 0x100000000LL;
  }
  else {
    uint64_t v9 = option;
  }
  if ((v9 & 0x100000000LL) != 0)
  {
    v27[0] = msg;
    v27[1] = rcv_msg;
    mach_msg_size_t v28 = send_size;
    mach_msg_size_t v29 = rcv_size;
    uint64_t v30 = &v26;
    uint64_t v31 = 0LL;
    uint64_t v32 = 0x8000000000LL;
  }

  if ((v9 & 1) != 0) {
    uint64_t v10 = notify;
  }
  else {
    uint64_t v10 = 0LL;
  }
  if ((v9 & 0x4003) == 0x4002) {
    msg->msgh_remote_port = notify;
  }
  unint64_t v11 = v9 | 0x400000000LL;
  int64x2_t v12 = (void *)timeout;
  uint64_t msgh_bits = msg->msgh_bits;
  unint64_t v14 = *(void **)&msg->msgh_remote_port;
  uint64_t msgh_voucher_port = msg->msgh_voucher_port;
  uint64_t msgh_id = msg->msgh_id;
  BOOL v18 = (v9 & 1) == 0 || (int)msgh_bits >= 0;
  if ((v9 & 0x100000000LL) != 0)
  {
    if (v18) {
      uint64_t v20 = 0LL;
    }
    else {
      uint64_t v20 = msg[1].msgh_bits;
    }
    uint64_t v21 = (void *)(msgh_bits | 0x200000000LL);
    uint64_t v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    int64x2_t v23 = (void *)(v20 | (*(void *)&rcv_name << 32));
    int8x16_t v24 = (void *)((v10 << 32) | 2);
    msg = (mach_msg_header_t *)v27;
  }

  else
  {
    if (v18) {
      uint64_t v19 = 0LL;
    }
    else {
      uint64_t v19 = msg[1].msgh_bits;
    }
    uint64_t v21 = (void *)(msgh_bits | (*(void *)&send_size << 32));
    uint64_t v22 = (void *)(msgh_voucher_port | (msgh_id << 32));
    int64x2_t v23 = (void *)(v19 | (*(void *)&rcv_name << 32));
    int8x16_t v24 = (void *)(rcv_size | (unint64_t)(v10 << 32));
  }

  return mach_msg2_internal(msg, v11, v21, v14, v22, v23, v24, v12);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  mach_msg_bits_t msgh_bits = a1->msgh_bits;
  mach_msg_destroy_port(a1->msgh_remote_port, a1->msgh_bits & 0x1F);
  mach_msg_destroy_port(a1->msgh_voucher_port, HIWORD(msgh_bits) & 0x1F);
  if ((msgh_bits & 0x80000000) != 0)
  {
    mach_msg_bits_t v3 = a1[1].msgh_bits;
    if (v3)
    {
      int v4 = 0;
      p_msgh_vm_size_t size = &a1[1].msgh_size;
      do
      {
        mach_msg_size_t v6 = p_msgh_size[2];
        switch(HIBYTE(v6))
        {
          case 0u:
            mach_msg_size_t v7 = *p_msgh_size;
            p_msgh_size += 3;
            mach_msg_destroy_port(v7, BYTE2(v6));
            break;
          case 1u:
            if (p_msgh_size[2])
            {
              mach_vm_size_t v8 = p_msgh_size[3];
              if ((_DWORD)v8) {
                goto LABEL_17;
              }
            }

            goto LABEL_31;
          case 2u:
            if (p_msgh_size[3])
            {
              uint64_t v9 = 0LL;
              mach_vm_address_t v10 = *(void *)p_msgh_size;
              do
              {
                mach_msg_destroy_port(*(unsigned int *)(v10 + 4 * v9), *((unsigned __int8 *)p_msgh_size + 10));
                unint64_t v11 = p_msgh_size[3];
                ++v9;
              }

              while (v11 > v9);
              if (p_msgh_size[3] && *((_BYTE *)p_msgh_size + 8) != 0)
              {
                mach_vm_size_t v8 = 4 * v11;
LABEL_17:
                mach_vm_deallocate(mach_task_self_, *(void *)p_msgh_size, v8);
              }
            }

            goto LABEL_31;
          case 3u:
            goto LABEL_31;
          case 4u:
            if ((v6 & 2) == 0)
            {
              mach_port_t v13 = mach_task_self_;
              mach_port_name_t v14 = p_msgh_size[3];
              mach_vm_address_t v15 = *(void *)p_msgh_size;
              if (_kernelrpc_mach_port_unguard_trap(mach_task_self_, v14, *(void *)p_msgh_size) == 268435459)
              {
                uint64_t v19 = 0x100000000LL;
                mach_port_name_t v20 = v14;
                mach_vm_address_t v21 = v15;
                uint64_t reply_port = mig_get_reply_port();
                *(void *)&v18.mach_msg_bits_t msgh_bits = 0x2C00001513LL;
                *(void *)&v18.msgh_remote_port = __PAIR64__(reply_port, v13);
                *(void *)&v18.uint64_t msgh_voucher_port = 0xCA200000000LL;
                int v17 = mach_msg2_internal( &v18,  0x200000003uLL,  (void *)0x2C00001513LL,  (void *)__PAIR64__(reply_port, v13),  (void *)0xCA200000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
                if ((v17 - 268435458) > 0xE || ((1 << (v17 - 2)) & 0x4003) == 0)
                {
                  if (v17)
                  {
                    mig_dealloc_reply_port(v18.msgh_local_port);
                  }

                  else if (v18.msgh_id != 3334 {
                         || (v18.msgh_bits & 0x80000000) != 0
                  }
                         || *(void *)&v18.msgh_size != 36LL
                         || v20)
                  {
                    mach_msg_destroy(&v18);
                  }
                }
              }

              mach_msg_size_t v6 = p_msgh_size[2];
            }

            mach_msg_destroy_port(p_msgh_size[3], BYTE2(v6));
LABEL_31:
            p_msgh_size += 4;
            break;
          default:
            break;
        }

        ++v4;
      }

      while (v4 != v3);
    }
  }

uint64_t mach_msg_destroy_port(uint64_t name, int a2)
{
  if ((name - 1) <= 0xFFFFFFFD)
  {
    mach_port_name_t v2 = name;
    switch(a2)
    {
      case 16:
        mach_port_name_t name = mach_port_mod_refs(mach_task_self_, name, 1u, -1);
        break;
      case 17:
      case 18:
        mach_port_t v3 = mach_task_self_;
        goto LABEL_31;
      case 20:
        mach_port_t v4 = mach_task_self_;
        if (_kernelrpc_mach_port_insert_right_trap(mach_task_self_, name, name, 0x14u) == 268435459)
        {
          LODWORD(v1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = 1;
          HIDWORD(v1dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = v2;
          unsigned int v13 = 1310720;
          uint64_t v14 = 0x100000000LL;
          mach_port_name_t v15 = v2;
          uint64_t reply_port = mig_get_reply_port();
          *(void *)&v10.mach_msg_bits_t msgh_bits = 0x3480001513LL;
          *(void *)&v10.msgh_remote_port = __PAIR64__(reply_port, v4);
          *(void *)&v10.uint64_t msgh_voucher_port = 0xC8E00000000LL;
          int v6 = mach_msg2_internal( &v10,  0x200000003uLL,  (void *)0x3480001513LL,  (void *)__PAIR64__(reply_port, v4),  (void *)0xC8E00000000LL,  (void *)((reply_port << 32) | 1),  (void *)0x2C,  0LL);
          if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
          {
            if (v6)
            {
              mig_dealloc_reply_port(v10.msgh_local_port);
            }

            else if (v10.msgh_id != 3314 {
                   || (v10.msgh_bits & 0x80000000) != 0
            }
                   || v10.msgh_size != 36
                   || v10.msgh_remote_port
                   || v12)
            {
              mach_msg_destroy(&v10);
            }
          }
        }

        mach_port_t v3 = mach_task_self_;
LABEL_31:
        mach_port_name_t name = mach_port_deallocate(v3, v2);
        break;
      case 21:
        mach_port_t v7 = mach_task_self_;
        uint64_t v11 = 0x100000000LL;
        int v12 = name;
        unsigned int v13 = 21;
        uint64_t v8 = mig_get_reply_port();
        *(void *)&v10.mach_msg_bits_t msgh_bits = 0x2800001513LL;
        *(void *)&v10.msgh_remote_port = __PAIR64__(v8, v7);
        *(void *)&v10.uint64_t msgh_voucher_port = 0xC8F00000000LL;
        int v9 = mach_msg2_internal( &v10,  0x200000003uLL,  (void *)0x2800001513LL,  (void *)__PAIR64__(v8, v7),  (void *)0xC8F00000000LL,  (void *)(v8 << 32),  (void *)0x30,  0LL);
        if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
        {
          if (v9)
          {
            mig_dealloc_reply_port(v10.msgh_local_port);
          }

          else if (v10.msgh_id == 3315 {
                 && (v10.msgh_bits & 0x80000000) != 0
          }
                 && (_DWORD)v11 == 1
                 && v10.msgh_size == 40
                 && !v10.msgh_remote_port
                 && !HIBYTE(v13))
          {
            mach_port_name_t v2 = HIDWORD(v11);
          }

          else
          {
            mach_msg_destroy(&v10);
          }
        }

        mach_port_name_t name = mach_port_deallocate(mach_task_self_, v2);
        break;
      default:
        return name;
    }
  }

  return name;
}

mach_port_t mig_get_reply_port(void)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  mach_port_t result = *(_DWORD *)(StatusReg + 16);
  mach_port_name_t name = result;
  if (!result)
  {
    v2.reserved[1] = 0LL;
    *(_OWORD *)&v2.flags = xmmword_1800B9850;
    mach_port_t result = mach_port_construct(mach_task_self_, &v2, 0LL, &name);
    if (result)
    {
      qword_18C509748 = (uint64_t)"mach_port_construct for mig_get_reply_port failed";
      qword_18C509778 = (int)result;
      __break(1u);
    }

    else
    {
      mach_port_t result = name;
      *(void *)(StatusReg + 16) = name;
    }
  }

  return result;
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  mach_port_name_t v2 = *(_DWORD *)(StatusReg + 16);
  if (v2 && _task_reply_port != v2)
  {
    *(void *)(StatusReg + 16) = _task_reply_port;
    mach_port_mod_refs(mach_task_self_, v2, 1u, -1);
    if (v2 != reply_port) {
      mach_port_deallocate(mach_task_self_, reply_port);
    }
    *(void *)(StatusReg + 16) = 0LL;
  }

int *__error(void)
{
  char v0 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v0) {
    return v0;
  }
  else {
    return &errno;
  }
}

uint64_t cerror_nocancel(int a1)
{
  errno = a1;
  uint64_t v1 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v1) {
    *uint64_t v1 = a1;
  }
  return -1LL;
}

uint64_t cerror(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int v8 = a1;
  _pthread_exit_if_canceled(a1, a2, a3, a4, a5, a6, a7, a8);
  cerror_nocancel(v8);
  return -1LL;
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  int result = __proc_info((void *)2, *(void **)&pid, *(void **)&flavor, (void *)arg, buffer, *(void **)&buffersize, v5, v6);
  if (result == -1) {
    return 0;
  }
  return result;
}

uint64_t proc_set_dyld_all_image_info(void *a1, void *a2)
{
  mach_port_t v4 = (void *)getpid();
  return __proc_info((void *)0xF, v4, 0LL, 0LL, a1, a2, v5, v6);
}

int chmod(const char *a1, mode_t a2)
{
  int result = __chmod(a1, a2);
  if (result < 0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v6 = *(int **)(StatusReg + 8);
    if (!v6) {
      int v6 = &errno;
    }
    int v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0) {
        goto LABEL_22;
      }
      int result = __chmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        int v9 = *(int **)(StatusReg + 8);
        if (!v9) {
          int v9 = &errno;
        }
        if (*v9 == 1)
        {
LABEL_22:
          if ((a2 & 0x800) == 0) {
            goto LABEL_12;
          }
          int result = __chmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            mach_msg_header_t v10 = *(int **)(StatusReg + 8);
            if (!v10) {
              mach_msg_header_t v10 = &errno;
            }
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072) {
                return __chmod(a1, a2 ^ 0xC00);
              }
            }
          }
        }
      }
    }
  }

  return result;
}

int fchmod(int a1, mode_t a2)
{
  int result = __fchmod(a1, a2);
  if (result < 0)
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v6 = *(int **)(StatusReg + 8);
    if (!v6) {
      int v6 = &errno;
    }
    int v7 = a2 & 0xC00;
    if (*v6 == 1 && v7 != 0)
    {
      if ((a2 & 0x400) == 0) {
        goto LABEL_22;
      }
      int result = __fchmod(a1, a2 ^ 0x400);
      if (result < 0)
      {
        int v9 = *(int **)(StatusReg + 8);
        if (!v9) {
          int v9 = &errno;
        }
        if (*v9 == 1)
        {
LABEL_22:
          if ((a2 & 0x800) == 0) {
            goto LABEL_12;
          }
          int result = __fchmod(a1, a2 ^ 0x800);
          if (result < 0)
          {
            mach_msg_header_t v10 = *(int **)(StatusReg + 8);
            if (!v10) {
              mach_msg_header_t v10 = &errno;
            }
            if (*v10 == 1)
            {
LABEL_12:
              if (v7 == 3072) {
                return __fchmod(a1, a2 ^ 0xC00);
              }
            }
          }
        }
      }
    }
  }

  return result;
}

int fcntl(int a1, int a2, ...)
{
  int v9 = va_arg(va, void *);
  switch(a2)
  {
    case '*':
    case '+':
    case ',':
    case '1':
    case '2':
    case '4':
    case '8':
    case '9':
    case ';':
    case '=':
    case 'A':
    case 'B':
    case 'G':
    case 'H':
    case 'K':
    case 'N':
    case 'S':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'l':
    case 'o':
    case 'q':
      goto LABEL_2;
    case '-':
    case '.':
    case '/':
    case '0':
    case '3':
    case '5':
    case '6':
    case '7':
    case ':':
    case '<':
    case '>':
    case '?':
    case '@':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'I':
    case 'J':
    case 'L':
    case 'M':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case '_':
    case 'j':
    case 'k':
    case 'm':
    case 'n':
    case 'p':
      goto LABEL_5;
    default:
      if ((a2 - 7) < 4) {
LABEL_2:
      }
        int v7 = v9;
      else {
LABEL_5:
      }
        int v7 = (void *)(int)v9;
      return __fcntl(a1, *(void **)&a2, v7, v2, v3, v4, v5, v6);
  }

int ioctl(int a1, unint64_t a2, ...)
{
  int v8 = va_arg(va, void *);
  return __ioctl(a1, (void *)a2, v8, v2, v3, v4, v5, v6);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  if ((a4 & 2) != 0)
  {
    if (a2) {
      return __mmap(a1, a2, a3, a4 | 0x40000u, a5, a6);
    }
  }

  else if (a2 && (a4 & 1) != 0)
  {
    return __mmap(a1, a2, a3, a4 | 0x40000u, a5, a6);
  }

  cerror_nocancel(22);
  return (void *)-1LL;
}

BOOL kdebug_is_enabled( unsigned int a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  if (!MEMORY[0xFFFFFC100]) {
    return 0LL;
  }
  if ((MEMORY[0xFFFFFC100] & 2) == 0) {
    return 1LL;
  }
  uint64_t v9 = kdebug_typefilter_typefilter;
  if (!kdebug_typefilter_typefilter)
  {
    uint64_t v13 = 0LL;
    mach_vm_address_t address = 0LL;
    if (!__kdebug_typefilter(&address, &v13, a3, a4, a5, a6, a7, a8))
    {
      mach_vm_address_t v11 = address;
      if (address)
      {
        while (!__ldaxr((unint64_t *)&kdebug_typefilter_typefilter))
        {
        }

        __clrex();
        mach_vm_deallocate(mach_task_self_, address, 0x2000uLL);
      }
    }

uint64_t kdebug_trace(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  uint64_t result = kdebug_is_enabled(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    return __kdebug_trace64(a1, a2, a3, a4, a5, v14, v15, v16);
  }
  return result;
}

int64_t kdebug_trace_string( void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  int v17 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (!v17) {
    int v17 = &errno;
  }
  *int v17 = 22;
  return -1LL;
}

int unlink(const char *a1)
{
  int result = __unlink(a1, v1, v2, v3, v4, v5, v6, v7);
  if (!result)
  {
    do
      unsigned int v9 = __ldaxr(&__remove_counter);
    while (__stlxr(v9 + 1, &__remove_counter));
  }

  return result;
}

int open(const char *a1, int a2, ...)
{
  uint64_t v9 = va_arg(va, void);
  if ((a2 & 0x200) != 0) {
    unsigned __int16 v7 = v9;
  }
  else {
    unsigned __int16 v7 = 0;
  }
  return __open(a1, *(void **)&a2, (void *)v7, v2, v3, v4, v5, v6);
}

int openat(int a1, const char *a2, int a3, ...)
{
  uint64_t v9 = va_arg(va, void);
  if ((a3 & 0x200) != 0) {
    unsigned __int16 v7 = v9;
  }
  else {
    unsigned __int16 v7 = 0;
  }
  return __openat(a1, (char *)a2, *(void **)&a3, (void *)v7, v3, v4, v5, v6);
}

int rename(const char *__old, const char *__new)
{
  if (!result)
  {
    do
      unsigned int v4 = __ldaxr(&__remove_counter);
    while (__stlxr(v4 + 1, &__remove_counter));
  }

  return result;
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  if ((a4 & 4) == 0) {
    return __open_dprotected_np(a1, a2, a3, a4);
  }
  unsigned int v4 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (!v4) {
    unsigned int v4 = &errno;
  }
  int *v4 = 22;
  return -1;
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  kern_return_t v4;
  uint64_t reply_port;
  kern_return_t v6;
  mach_msg_header_t v9;
  uint64_t v10;
  mach_port_name_t v11;
  unsigned int v4 = _kernelrpc_mach_port_deallocate_trap(task, name);
  if (v4 == 268435459)
  {
    mach_msg_header_t v10 = 0x100000000LL;
    mach_vm_address_t v11 = name;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v9.mach_msg_bits_t msgh_bits = 0x2400001513LL;
    *(void *)&v9.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v9.uint64_t msgh_voucher_port = 0xC8600000000LL;
    int v6 = mach_msg2_internal( &v9,  0x200000003uLL,  (void *)0x2400001513LL,  (void *)__PAIR64__(reply_port, task),  (void *)0xC8600000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
    unsigned int v4 = v6;
    if ((v6 - 268435458) > 0xE || ((1 << (v6 - 2)) & 0x4003) == 0)
    {
      if (v6)
      {
        mig_dealloc_reply_port(v9.msgh_local_port);
        return v4;
      }

      if (v9.msgh_id == 71)
      {
        unsigned int v4 = -308;
      }

      else if (v9.msgh_id == 3306)
      {
        unsigned int v4 = -300;
        if ((v9.msgh_bits & 0x80000000) == 0 && *(void *)&v9.msgh_size == 36LL)
        {
          unsigned int v4 = v11;
          if (!v11) {
            return v4;
          }
        }
      }

      else
      {
        unsigned int v4 = -301;
      }

      mach_msg_destroy(&v9);
    }
  }

  return v4;
}

kern_return_t mach_port_mod_refs( ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_right_t v16;
  mach_port_delta_t v17;
  int v8 = _kernelrpc_mach_port_mod_refs_trap(task, name, right, delta);
  if (v8 == 268435459)
  {
    uint64_t v14 = 0x100000000LL;
    mach_port_name_t v15 = name;
    uint64_t v16 = right;
    int v17 = delta;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v13.mach_msg_bits_t msgh_bits = 0x2C00001513LL;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.uint64_t msgh_voucher_port = 0xC8800000000LL;
    mach_msg_header_t v10 = mach_msg2_internal( &v13,  0x200000003uLL,  (void *)0x2C00001513LL,  (void *)__PAIR64__(reply_port, task),  (void *)0xC8800000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
    int v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }

      if (v13.msgh_id == 71)
      {
        int v8 = -308;
      }

      else if (v13.msgh_id == 3308)
      {
        int v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(void *)&v13.msgh_size == 36LL)
        {
          int v8 = v15;
          if (!v15) {
            return v8;
          }
        }
      }

      else
      {
        int v8 = -301;
      }

      mach_msg_destroy(&v13);
    }
  }

  return v8;
}

kern_return_t mach_port_destruct( ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  mach_msg_header_t v13;
  uint64_t v14;
  mach_port_name_t v15;
  mach_port_delta_t v16;
  mach_port_context_t v17;
  int v8 = _kernelrpc_mach_port_destruct_trap(task, name, srdelta, guard);
  if (v8 == 268435459)
  {
    uint64_t v14 = 0x100000000LL;
    mach_port_name_t v15 = name;
    uint64_t v16 = srdelta;
    int v17 = guard;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v13.mach_msg_bits_t msgh_bits = 0x3000001513LL;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.uint64_t msgh_voucher_port = 0xCA000000000LL;
    mach_msg_header_t v10 = mach_msg2_internal( &v13,  0x200000003uLL,  (void *)0x3000001513LL,  (void *)__PAIR64__(reply_port, task),  (void *)0xCA000000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
    int v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (v10)
      {
        mig_dealloc_reply_port(v13.msgh_local_port);
        return v8;
      }

      if (v13.msgh_id == 71)
      {
        int v8 = -308;
      }

      else if (v13.msgh_id == 3332)
      {
        int v8 = -300;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(void *)&v13.msgh_size == 36LL)
        {
          int v8 = v15;
          if (!v15) {
            return v8;
          }
        }
      }

      else
      {
        int v8 = -301;
      }

      mach_msg_destroy(&v13);
    }
  }

  return v8;
}

uint64_t thread_destruct_special_reply_port(mach_port_name_t name, int a2)
{
  switch(a2)
  {
    case 2:
      return mach_port_deallocate(mach_task_self_, name);
    case 1:
      mach_port_t v3 = mach_task_self_;
      mach_port_name_t v4 = name;
      mach_port_delta_t v5 = 0;
      return mach_port_destruct(v3, v4, v5, 0LL);
    case 0:
      mach_port_t v3 = mach_task_self_;
      mach_port_name_t v4 = name;
      mach_port_delta_t v5 = -1;
      return mach_port_destruct(v3, v4, v5, 0LL);
  }

  return 4LL;
}

kern_return_t mach_port_construct( ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  kern_return_t v8;
  uint64_t reply_port;
  kern_return_t v10;
  BOOL v11;
  mach_msg_header_t v13;
  int v14;
  mach_port_options_ptr_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_context_t v18;
  int v8 = _kernelrpc_mach_port_construct_trap(task, options, context, name);
  if (v8 == 268435459)
  {
    uint64_t v14 = 1;
    mach_port_name_t v15 = options;
    uint64_t v16 = 0x1801000100LL;
    int v17 = 0x100000000LL;
    mach_msg_header_t v18 = context;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v13.mach_msg_bits_t msgh_bits = 0x3C80001513LL;
    *(void *)&v13.msgh_remote_port = __PAIR64__(reply_port, task);
    *(void *)&v13.uint64_t msgh_voucher_port = 0xC9F00000000LL;
    mach_msg_header_t v10 = mach_msg2_internal( &v13,  0x200000003uLL,  (void *)0x3C80001513LL,  (void *)__PAIR64__(reply_port, task),  (void *)0xC9F00000000LL,  (void *)((reply_port << 32) | 1),  (void *)0x30,  0LL);
    int v8 = v10;
    if ((v10 - 268435458) > 0xE || ((1 << (v10 - 2)) & 0x4003) == 0)
    {
      if (!v10)
      {
        if (v13.msgh_id == 71)
        {
          int v8 = -308;
        }

        else if (v13.msgh_id == 3331)
        {
          if ((v13.msgh_bits & 0x80000000) == 0)
          {
            if (v13.msgh_size == 40)
            {
              if (!v13.msgh_remote_port)
              {
                int v8 = HIDWORD(v15);
                if (!HIDWORD(v15))
                {
                  *mach_port_name_t name = v16;
                  return v8;
                }

                goto LABEL_21;
              }
            }

            else if (v13.msgh_size == 36)
            {
              if (v13.msgh_remote_port) {
                mach_vm_address_t v11 = 1;
              }
              else {
                mach_vm_address_t v11 = HIDWORD(v15) == 0;
              }
              if (v11) {
                int v8 = -300;
              }
              else {
                int v8 = HIDWORD(v15);
              }
              goto LABEL_21;
            }
          }

          int v8 = -300;
        }

        else
        {
          int v8 = -301;
        }

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  kern_return_t v6;
  uint64_t reply_port;
  kern_return_t v8;
  mach_msg_header_t v11;
  uint64_t v12;
  mach_vm_address_t v13;
  mach_vm_size_t v14;
  int v6 = _kernelrpc_mach_vm_deallocate_trap(target, address, size);
  if (v6 == 268435459)
  {
    int v12 = 0x100000000LL;
    uint64_t v13 = address;
    uint64_t v14 = size;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v11.mach_msg_bits_t msgh_bits = 0x3000001513LL;
    *(void *)&v11.msgh_remote_port = __PAIR64__(reply_port, target);
    *(void *)&v11.uint64_t msgh_voucher_port = 0x12C100000000LL;
    int v8 = mach_msg2_internal( &v11,  0x200000003uLL,  (void *)0x3000001513LL,  (void *)__PAIR64__(reply_port, target),  (void *)0x12C100000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
    int v6 = v8;
    if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
    {
      if (v8)
      {
        mig_dealloc_reply_port(v11.msgh_local_port);
        return v6;
      }

      if (v11.msgh_id == 71)
      {
        int v6 = -308;
      }

      else if (v11.msgh_id == 4901)
      {
        int v6 = -300;
        if ((v11.msgh_bits & 0x80000000) == 0 && *(void *)&v11.msgh_size == 36LL)
        {
          int v6 = v13;
          if (!(_DWORD)v13) {
            return v6;
          }
        }
      }

      else
      {
        int v6 = -301;
      }

      mach_msg_destroy(&v11);
    }
  }

  return v6;
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  kern_return_t v8;
  vm_address_t v9;
  uint64_t reply_port;
  kern_return_t v11;
  kern_return_t v12;
  BOOL v13;
  mach_vm_offset_t v15;
  mach_msg_header_t v16;
  uint64_t v17;
  __int128 v18;
  int v19;
  mach_port_name_t v15 = *address;
  int v8 = _kernelrpc_mach_vm_allocate_trap(target_task, &v15, size, flags);
  uint64_t v9 = v15;
  if (v8 == 268435459)
  {
    int v17 = 0x100000000LL;
    *(void *)&mach_msg_header_t v18 = v15;
    *((void *)&v18 + dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef((dyld4::PrebuiltLoader::BindTargetRef *)&v3, v1 + 1) = size;
    uint64_t v19 = flags;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v16.mach_msg_bits_t msgh_bits = 0x3400001513LL;
    *(void *)&v16.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(void *)&v16.uint64_t msgh_voucher_port = 0x12C000000000LL;
    mach_vm_address_t v11 = mach_msg2_internal( &v16,  0x200000003uLL,  (void *)0x3400001513LL,  (void *)__PAIR64__(reply_port, target_task),  (void *)0x12C000000000LL,  (void *)(reply_port << 32),  (void *)0x34,  0LL);
    int v12 = v11;
    if (v11)
    {
      mig_dealloc_reply_port(v16.msgh_local_port);
LABEL_23:
      uint64_t v9 = v15;
      goto LABEL_24;
    }

    if (v16.msgh_id == 71)
    {
      int v12 = -308;
    }

    else if (v16.msgh_id == 4900)
    {
      if ((v16.msgh_bits & 0x80000000) == 0)
      {
        if (v16.msgh_size == 44)
        {
          if (!v16.msgh_remote_port)
          {
            int v12 = v18;
            if (!(_DWORD)v18)
            {
              mach_port_name_t v15 = *(void *)((char *)&v18 + 4);
              goto LABEL_23;
            }

            goto LABEL_22;
          }
        }

        else if (v16.msgh_size == 36)
        {
          if (v16.msgh_remote_port) {
            uint64_t v13 = 1;
          }
          else {
            uint64_t v13 = (_DWORD)v18 == 0;
          }
          if (v13) {
            int v12 = -300;
          }
          else {
            int v12 = v18;
          }
          goto LABEL_22;
        }
      }

      int v12 = -300;
    }

    else
    {
      int v12 = -301;
    }

kern_return_t vm_protect( vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  kern_return_t v10;
  uint64_t reply_port;
  kern_return_t v12;
  mach_msg_header_t v15;
  uint64_t v16;
  vm_address_t v17;
  vm_size_t v18;
  BOOLean_t v19;
  vm_prot_t v20;
  mach_msg_header_t v10 = _kernelrpc_mach_vm_protect_trap(target_task, address, size, set_maximum, new_protection);
  if (v10 == 268435459)
  {
    uint64_t v16 = 0x100000000LL;
    int v17 = address;
    mach_msg_header_t v18 = size;
    uint64_t v19 = set_maximum;
    mach_port_name_t v20 = new_protection;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v15.mach_msg_bits_t msgh_bits = 0x3800001513LL;
    *(void *)&v15.msgh_remote_port = __PAIR64__(reply_port, target_task);
    *(void *)&v15.uint64_t msgh_voucher_port = 0x12C200000000LL;
    int v12 = mach_msg2_internal( &v15,  0x200000003uLL,  (void *)0x3800001513LL,  (void *)__PAIR64__(reply_port, target_task),  (void *)0x12C200000000LL,  (void *)(reply_port << 32),  (void *)0x2C,  0LL);
    mach_msg_header_t v10 = v12;
    if ((v12 - 268435458) > 0xE || ((1 << (v12 - 2)) & 0x4003) == 0)
    {
      if (v12)
      {
        mig_dealloc_reply_port(v15.msgh_local_port);
        return v10;
      }

      if (v15.msgh_id == 71)
      {
        mach_msg_header_t v10 = -308;
      }

      else if (v15.msgh_id == 4902)
      {
        mach_msg_header_t v10 = -300;
        if ((v15.msgh_bits & 0x80000000) == 0 && v15.msgh_size == 36 && !v15.msgh_remote_port)
        {
          mach_msg_header_t v10 = v17;
          if (!(_DWORD)v17) {
            return v10;
          }
        }
      }

      else
      {
        mach_msg_header_t v10 = -301;
      }

      mach_msg_destroy(&v15);
    }
  }

  return v10;
}

kern_return_t mach_vm_map( vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, mem_entry_name_port_t object, memory_object_offset_t offset, BOOLean_t copy, vm_prot_t cur_protection, vm_prot_t max_protection, vm_inherit_t inheritance)
{
  kern_return_t v20;
  kern_return_t v21;
  mach_vm_address_t *v22;
  mach_vm_address_t v23;
  uint64_t reply_port;
  kern_return_t v25;
  BOOL v26;
  mach_msg_header_t v29;
  int v30;
  mem_entry_name_port_t v31;
  kern_return_t v32;
  _DWORD v33[10];
  memory_object_offset_t v34;
  BOOLean_t v35;
  vm_prot_t v36;
  vm_prot_t v37;
  vm_inherit_t v38;
  vm_map_t v12 = target_task;
  if (object) {
    goto LABEL_9;
  }
  if (max_protection != 7 || inheritance != 1) {
    goto LABEL_9;
  }
  uint64_t v14 = address;
  mach_vm_size_t v15 = size;
  mach_vm_offset_t v16 = mask;
  int v17 = flags;
  BOOLean_t v18 = copy;
  memory_object_offset_t v19 = offset;
  mach_port_name_t v20 = _kernelrpc_mach_vm_map_trap(target_task, address, size, mask, flags, cur_protection);
  vm_size_t size = v15;
  masunint64_t k = v16;
  flags = v17;
  offset = v19;
  vm_map_t v12 = target_task;
  copy = v18;
  mach_vm_address_t address = v14;
  mach_vm_address_t v21 = v20;
  if (v20 == 268435459)
  {
LABEL_9:
    uint64_t v30 = 1;
    uint64_t v31 = object;
    v33[0] = 1245184;
    uint64_t v22 = address;
    int64x2_t v23 = *address;
    *(void *)&v33[1] = 0x100000000LL;
    *(void *)&v33[3] = v23;
    *(void *)&v33[5] = size;
    *(void *)&void v33[7] = mask;
    void v33[9] = flags;
    uint64_t v34 = offset;
    int64x2_t v35 = copy;
    uint64_t v36 = cur_protection;
    int64x2_t v37 = max_protection;
    int8x16_t v38 = inheritance;
    uint64_t reply_port = mig_get_reply_port();
    *(void *)&v29.mach_msg_bits_t msgh_bits = 0x6480001513LL;
    *(void *)&v29.msgh_remote_port = __PAIR64__(reply_port, v12);
    *(void *)&v29.uint64_t msgh_voucher_port = 0x12CB00000000LL;
    int64x2_t v25 = mach_msg2_internal( &v29,  0x200000003uLL,  (void *)0x6480001513LL,  (void *)__PAIR64__(reply_port, v12),  (void *)0x12CB00000000LL,  (void *)((reply_port << 32) | 1),  (void *)0x34,  0LL);
    mach_vm_address_t v21 = v25;
    if ((v25 - 268435458) > 0xE || ((1 << (v25 - 2)) & 0x4003) == 0)
    {
      if (!v25)
      {
        if (v29.msgh_id == 71)
        {
          mach_vm_address_t v21 = -308;
        }

        else if (v29.msgh_id == 4911)
        {
          if ((v29.msgh_bits & 0x80000000) == 0)
          {
            if (v29.msgh_size == 44)
            {
              if (!v29.msgh_remote_port)
              {
                mach_vm_address_t v21 = v32;
                if (!v32)
                {
                  void *v22 = *(void *)v33;
                  return v21;
                }

                goto LABEL_27;
              }
            }

            else if (v29.msgh_size == 36)
            {
              if (v29.msgh_remote_port) {
                uint64_t v26 = 1;
              }
              else {
                uint64_t v26 = v32 == 0;
              }
              if (v26) {
                mach_vm_address_t v21 = -300;
              }
              else {
                mach_vm_address_t v21 = v32;
              }
              goto LABEL_27;
            }
          }

          mach_vm_address_t v21 = -300;
        }

        else
        {
          mach_vm_address_t v21 = -301;
        }

kern_return_t task_info( task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  kern_return_t v9;
  kern_return_t v10;
  BOOL v12;
  mach_msg_type_number_t v15;
  uint64_t v16;
  mach_msg_header_t v17;
  uint64_t v18;
  task_flavor_t v19;
  mach_msg_size_t v20;
  _BYTE v21[384];
  BOOLean_t v18 = 0x100000000LL;
  mach_msg_type_number_t v7 = *task_info_outCnt;
  if (*task_info_outCnt >= 0x5E) {
    mach_msg_type_number_t v7 = 94;
  }
  memory_object_offset_t v19 = flavor;
  mach_port_name_t v20 = v7;
  uint64_t reply_port = mig_get_reply_port();
  *(void *)&v17.mach_msg_bits_t msgh_bits = 0x2800001513LL;
  *(void *)&v17.msgh_remote_port = __PAIR64__(reply_port, target_task);
  *(void *)&v17.uint64_t msgh_voucher_port = 0xD4D00000000LL;
  uint64_t v9 = mach_msg2_internal( &v17,  0x200000003uLL,  (void *)0x2800001513LL,  (void *)__PAIR64__(reply_port, target_task),  (void *)0xD4D00000000LL,  (void *)(reply_port << 32),  (void *)0x1A8,  0LL);
  mach_msg_header_t v10 = v9;
  if ((v9 - 268435458) > 0xE || ((1 << (v9 - 2)) & 0x4003) == 0)
  {
    if (v9)
    {
      mig_dealloc_reply_port(v17.msgh_local_port);
      return v10;
    }

    if (v17.msgh_id == 71)
    {
      mach_msg_header_t v10 = -308;
    }

    else if (v17.msgh_id == 3505)
    {
      if ((v17.msgh_bits & 0x80000000) == 0)
      {
        if (v17.msgh_size - 417 <= 0xFFFFFE86)
        {
          if (v17.msgh_remote_port) {
            vm_map_t v12 = 1;
          }
          else {
            vm_map_t v12 = v19 == 0;
          }
          if (!v12 && v17.msgh_size == 36) {
            mach_msg_header_t v10 = v19;
          }
          else {
            mach_msg_header_t v10 = -300;
          }
          goto LABEL_27;
        }

        if (!v17.msgh_remote_port)
        {
          mach_msg_header_t v10 = v19;
          if (v19) {
            goto LABEL_27;
          }
          mach_vm_size_t v15 = v20;
          if (v20 <= 0x5E && v20 <= (v17.msgh_size - 40) >> 2 && v17.msgh_size == 4 * v20 + 40)
          {
            mach_vm_offset_t v16 = *task_info_outCnt;
            if (v20 <= v16)
            {
              memmove(task_info_out, v21, 4LL * v20);
              mach_msg_header_t v10 = 0;
              *mach_msg_type_number_t task_info_outCnt = v15;
            }

            else
            {
              memmove(task_info_out, v21, 4 * v16);
              *mach_msg_type_number_t task_info_outCnt = v15;
              return -307;
            }

            return v10;
          }
        }
      }

      mach_msg_header_t v10 = -300;
    }

    else
    {
      mach_msg_header_t v10 = -301;
    }

kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)
{
  kern_return_t v4;
  kern_return_t v5;
  mach_msg_header_t v8;
  int v9;
  semaphore_t v10;
  kern_return_t v11;
  int v12;
  uint64_t v9 = 1;
  mach_msg_header_t v10 = semaphore;
  vm_map_t v12 = 1114112;
  uint64_t reply_port = mig_get_reply_port();
  *(void *)&v8.mach_msg_bits_t msgh_bits = 0x2880001513LL;
  *(void *)&v8.msgh_remote_port = __PAIR64__(reply_port, task);
  *(void *)&v8.uint64_t msgh_voucher_port = 0xD5B00000000LL;
  mach_port_name_t v4 = mach_msg2_internal( &v8,  0x200000003uLL,  (void *)0x2880001513LL,  (void *)__PAIR64__(reply_port, task),  (void *)0xD5B00000000LL,  (void *)((reply_port << 32) | 1),  (void *)0x2C,  0LL);
  mach_port_delta_t v5 = v4;
  if ((v4 - 268435458) > 0xE || ((1 << (v4 - 2)) & 0x4003) == 0)
  {
    if (v4)
    {
      mig_dealloc_reply_port(v8.msgh_local_port);
      return v5;
    }

    if (v8.msgh_id == 71)
    {
      mach_port_delta_t v5 = -308;
    }

    else if (v8.msgh_id == 3519)
    {
      mach_port_delta_t v5 = -300;
      if ((v8.msgh_bits & 0x80000000) == 0 && *(void *)&v8.msgh_size == 36LL)
      {
        mach_port_delta_t v5 = v11;
        if (!v11) {
          return v5;
        }
      }
    }

    else
    {
      mach_port_delta_t v5 = -301;
    }

    mach_msg_destroy(&v8);
  }

  return v5;
}

void ___ZN5dyld4L17handleDyldInCacheEPKN5dyld39MachOFileEPKNS_10KernelArgsES3__block_invoke_cold_1()
{
}

void dyld3::OverflowSafeArray<dyld4::Loader *,4294967295ull>::verifySpace( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void dyld4::PseudoDylib::create()
{
}

{
  __assert_rtn("create", "DyldRuntimeState.cpp", 157, "callbacks && callbacks cannot be null");
}

{
  __assert_rtn( "create",  "DyldRuntimeState.cpp",  159,  "identifier > addr && (identifier - size) < addr && identifier is not embedded within image?");
}

void dyld4::PseudoDylib::lookupSymbols()
{
  __assert_rtn( "lookupSymbols",  "DyldRuntimeState.cpp",  195,  "names.size() == flags.size() && array sizes should match");
}

{
  __assert_rtn( "lookupSymbols",  "DyldRuntimeState.cpp",  194,  "names.size() == addrs.size() && array sizes should match");
}

void dyld4::PseudoDylib::findUnwindSections()
{
}

{
  __assert_rtn("findUnwindSections", "DyldRuntimeState.cpp", 212, "info && info cannot be null");
}

void dyld4::RuntimeState::appLoadAddress()
{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 424, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("appLoadAddress", "DyldRuntimeState.cpp", 425, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::setAppLoadAddress()
{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 431, "_processPrebuiltLoaderSet != nullptr");
}

{
  __assert_rtn("setAppLoadAddress", "DyldRuntimeState.cpp", 432, "index < _processPrebuiltLoaderSet->loaderCount()");
}

void dyld4::RuntimeState::cachedDylibLoadAddress()
{
}

void dyld4::RuntimeState::setDyldLoader()
{
  __assert_rtn("setDyldLoader", "DyldRuntimeState.cpp", 674, "result.kind == Loader::ResolvedSymbol::Kind::bindToImage");
}

void dyld4::RuntimeState::appendInterposingTuples(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_57_cold_1()
{
}

void ___ZN5dyld412RuntimeState23appendInterposingTuplesEPKNS_6LoaderEPKhj_block_invoke_2_cold_1( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void dyld4::RuntimeState::findPrebuiltLoader(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void ___ZZN5dyld412RuntimeState10notifyLoadERKNSt3__14spanIPKNS_6LoaderELm18446744073709551615EEEENK3__0clEv_block_invoke_cold_1()
{
}

void ___ZZN5dyld412RuntimeState16setObjCNotifiersEPFvPKcPK11mach_headerEPFvS5_PvS5_PKvEPFvjPK29_dyld_objc_notify_mapped_infoEPFvSF_EPFvjSF_U13block_pointerFvjEEENK3__0clEv_block_invoke_166_cold_1()
{
}

void dyld3::MultiMap<SwiftTypeProtocolConformanceDiskLocationKey,SwiftTypeProtocolConformanceDiskLocation,dyld4::HashTypeConformanceKey,dyld4::EqualTypeConformanceKey>::MultiMap( uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("setInitialStorage", "Array.h", a3, "_usedCount == 0");
}

void dyld3::MultiMap<SwiftForeignTypeProtocolConformanceDiskLocationKey,SwiftForeignTypeProtocolConformanceDiskLocation,dyld4::HashForeignConformanceKey,dyld4::EqualForeignConformanceKey>::insert( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

{
  OUTLINED_FUNCTION_3_0("insert", "Map.h", a3, "tailNode.isDuplicateTail");
}

void dyld3::MultiMapBase<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::forEachEntry<prebuilt_objc::ObjCStringKey>( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void dyld4::Loader::path()
{
  __assert_rtn("path", "Loader.cpp", 137, "this->magic == kMagic");
}

void dyld4::Loader::mf()
{
  __assert_rtn("mf", "Loader.cpp", 169, "this->magic == kMagic");
}

void dyld4::Loader::loadAddress()
{
  __assert_rtn("loadAddress", "Loader.cpp", 186, "this->magic == kMagic");
}

void dyld4::Loader::contains()
{
  __assert_rtn("contains", "Loader.cpp", 204, "this->magic == kMagic");
}

void dyld4::Loader::matchesPath()
{
  __assert_rtn("matchesPath", "Loader.cpp", 221, "this->magic == kMagic");
}

void dyld4::Loader::fileID()
{
  __assert_rtn("fileID", "Loader.cpp", 238, "this->magic == kMagic");
}

void dyld4::Loader::dependentCount()
{
  __assert_rtn("dependentCount", "Loader.cpp", 250, "this->magic == kMagic");
}

void dyld4::Loader::dependent()
{
  __assert_rtn("dependent", "Loader.cpp", 266, "this->magic == kMagic");
}

void dyld4::Loader::loadDependents()
{
  __assert_rtn("loadDependents", "Loader.cpp", 282, "this->magic == kMagic");
}

void dyld4::Loader::getExportsTrie()
{
  __assert_rtn("getExportsTrie", "Loader.cpp", 298, "this->magic == kMagic");
}

void dyld4::Loader::hiddenFromFlat()
{
  __assert_rtn("hiddenFromFlat", "Loader.cpp", 314, "this->magic == kMagic");
}

void dyld4::Loader::representsCachedDylibIndex()
{
  __assert_rtn("representsCachedDylibIndex", "Loader.cpp", 331, "this->magic == kMagic");
}

void dyld4::Loader::overridesDylibInCache()
{
  __assert_rtn("overridesDylibInCache", "Loader.cpp", 342, "this->magic == kMagic");
}

void dyld4::Loader::applyFixups()
{
  __assert_rtn("applyFixups", "Loader.cpp", 357, "this->magic == kMagic");
}

void dyld4::Loader::withLayout()
{
  __assert_rtn("withLayout", "Loader.cpp", 374, "this->magic == kMagic");
}

void dyld4::Loader::dyldDoesObjCFixups()
{
  __assert_rtn("dyldDoesObjCFixups", "Loader.cpp", 390, "this->magic == kMagic");
}

void dyld4::Loader::getSectionLocations()
{
  __assert_rtn("getSectionLocations", "Loader.cpp", 406, "this->magic == kMagic");
}

void dyld4::Loader::unmap()
{
  __assert_rtn("unmap", "Loader.cpp", 418, "this->magic == kMagic");
}

void dyld4::Loader::hasBeenFixedUp()
{
  __assert_rtn("hasBeenFixedUp", "Loader.cpp", 431, "this->magic == kMagic");
}

void dyld4::Loader::beginInitializers()
{
  __assert_rtn("beginInitializers", "Loader.cpp", 448, "this->magic == kMagic");
}

void dyld4::Loader::runInitializers()
{
  __assert_rtn("runInitializers", "Loader.cpp", 465, "this->magic == kMagic");
}

void dyld4::Loader::isDelayInit()
{
  __assert_rtn("isDelayInit", "Loader.cpp", 482, "this->magic == kMagic");
}

void dyld4::Loader::setDelayInit()
{
  __assert_rtn("setDelayInit", "Loader.cpp", 498, "this->magic == kMagic");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_2_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_2", "Loader.cpp", 2369, "targetIndex == info.targetIndex");
}

void ___ZNK5dyld46Loader17forEachBindTargetER11DiagnosticsRNS_12RuntimeStateEU13block_pointerFvjjRKNS0_14ResolvedSymbolEEbU13block_pointerFvS7_RbESC__block_invoke_3_cold_1()
{
  __assert_rtn("forEachBindTarget_block_invoke_3", "Loader.cpp", 2378, "overrideBindTargetIndex == info.targetIndex");
}

void dyld4::Loader::applyCachePatchesToOverride()
{
  __assert_rtn( "applyCachePatchesToOverride",  "Loader.cpp",  3280,  "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

{
  __assert_rtn( "applyCachePatchesToOverride",  "Loader.cpp",  3196,  "(patchVersion == 2) || (patchVersion == 3) || (patchVersion == 4)");
}

void dyld4::Loader::applyCachePatches()
{
  __assert_rtn( "applyCachePatches",  "Loader.cpp",  3398,  "cachePatch->overrideOffsetOfImpl == DylibPatch::endOfPatchTable");
}

void dyld4::dyld_map_with_linking_np()
{
  __assert_rtn("fixupPage", "Loader.cpp", 1920, "segInfo != nullptr");
}

void dyld3::MapBase<char const*,dyld4::WeakDefMapValue,dyld3::HashCString,dyld3::EqualCString>::find<char const*>()
{
}

void dyld4::JustInTimeLoader::makePatchTable()
{
}

void dyld4::JustInTimeLoader::dependentAttrs()
{
}

{
  __assert_rtn("dependentAttrs", "JustInTimeLoader.cpp", 579, "depIndex < this->depCount");
}

void dyld4::JustInTimeLoader::dependent()
{
}

void dyld4::JustInTimeLoader::unmap()
{
}

void dyld3::MapBase<void const*,BOOL,dyld4::HashPointer,dyld4::EqualPointer>::find<unsigned char *>()
{
}

void dyld4::PrebuiltLoader::BindTargetRef::BindTargetRef()
{
  __assert_rtn( "BindTargetRef",  "PrebuiltLoader.cpp",  99,  "(offset() == targetSymbol.targetRuntimeOffset) && large offset not support");
}

{
  __assert_rtn( "BindTargetRef",  "PrebuiltLoader.cpp",  189,  "unpackAbsoluteValue() == absoluteValue && unencodeable absolute symbol value");
}

{
  __assert_rtn( "BindTargetRef",  "PrebuiltLoader.cpp",  202,  "(offset() == bindTarget.runtimeOffset) && large offset not support");
}

void dyld4::PrebuiltLoader::BindTargetRef::loaderRef(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_1("loaderRef", "PrebuiltLoader.cpp", a3, "_regular.kind == 0");
}

void dyld4::PrebuiltLoader::setLoadAddress()
{
}

void dyld4::PrebuiltLoader::dependent()
{
}

void dyld4::PrebuiltLoader::recursiveMarkBeingValidated()
{
}

void dyld4::PrebuiltLoader::beginInitializers()
{
  __assert_rtn("beginInitializers", "PrebuiltLoader.cpp", 843, "ldrState == State::fixedUp");
}

void dyld4::PrebuiltLoader::serialize()
{
}

{
  __assert_rtn( "serialize",  "PrebuiltLoader.cpp",  1306,  "p->bindTargetRefsOffset == off && uint16_t bindTargetRefsOffset overflow");
}

{
  __assert_rtn( "serialize",  "PrebuiltLoader.cpp",  1247,  "p->fileValidationOffset == off && uint16_t fileValidationOffset overflow");
}

void dyld4::BumpAllocator::zeroFill()
{
  __assert_rtn("zeroFill", "PrebuiltLoader.cpp", 2411, "newAllocationAddr != 0");
}

{
  __assert_rtn( "zeroFill",  "PrebuiltLoader.cpp",  2421,  "(uint8_t*)_usageEnd + reqSize <= (uint8_t*)_vmAllocationStart + _vmAllocationSize");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_cold_2()
{
  __assert_rtn( "serialize_block_invoke",  "PrebuiltLoader.cpp",  1257,  "p->regionsOffset == off && uint16_t regionsOffset overflow");
}

void ___ZN5dyld414PrebuiltLoader9serializeER11DiagnosticsRNS_12RuntimeStateERKNS_16JustInTimeLoaderENS_6Loader9LoaderRefEU13block_pointerFvjjRKNS8_14ResolvedSymbolEERNS_12PrebuiltObjCERKNS_13PrebuiltSwiftERNS_13BumpAllocatorE_block_invoke_51_cold_1()
{
  __assert_rtn( "serialize_block_invoke",  "PrebuiltLoader.cpp",  1317,  "p->bindTargetRefsCount != 0 && bindTargetRefsCount overflow");
}

void dyld4::SyscallDelegate::getFileAttribute()
{
  __assert_rtn("resize", "Array.h", 77, "count <= _allocCount");
}

void dyld4::FileManager::uuidForFileSystem()
{
  __assert_rtn("operator()", "FileManager.cpp", 161, "i != _fsUUIDMap->end()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::operator++( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::insert()
{
  __assert_rtn("insert", "BTree.h", 140, "size() != capacity()");
}

{
  __assert_rtn("insert", "BTree.h", 141, "index != capacity()");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::const_iterator::prepareForInsertion()
{
  __assert_rtn( "prepareForInsertion",  "BTree.h",  573,  "_depth == _btree->_depth && prepareForInsertion only works on iterators leaf nodes");
}

void lsl::BTree<std::pair<unsigned long long,lsl::UUID>,lsl::OrderedMap<unsigned long long,lsl::UUID,std::less<unsigned long long>>::value_compare,false>::NodeCore<10u,7u>::splitChild()
{
}

{
  __assert_rtn( "splitChild",  "BTree.h",  194,  "!newChild->full() && !child->full() && After split the child nodes should be full");
}

{
  __assert_rtn("splitChild", "BTree.h", 160, "children()[index]->full() && The child being split must be full");
}

{
  __assert_rtn( "splitChild",  "BTree.h",  159,  "size() < capacity() && There must be room in this node for an additional child");
}

void lsl::Lock::lock()
{
  __assert_rtn("lock", "Allocator.cpp", 100, "_runtimeState != nullptr");
}

void lsl::Lock::unlock()
{
  __assert_rtn("unlock", "Allocator.cpp", 110, "_runtimeState != nullptr");
}

void lsl::MemoryManager::vm_allocate_bytes(char *a1, uint64_t a2, uint64_t *a3, __int32 a4)
{
  size_t appended = lsl::appendHexToString<unsigned long long>(a1, a2);
  size_t v8 = OUTLINED_FUNCTION_0_1(appended, "\n\tRequested size: 0x");
  size_t v9 = OUTLINED_FUNCTION_1_1(v8, a3[6]);
  size_t v10 = OUTLINED_FUNCTION_0_1(v9, "\n\tRequested allgnment: 0x");
  size_t v11 = OUTLINED_FUNCTION_1_1(v10, a3[5]);
  size_t v12 = OUTLINED_FUNCTION_0_1(v11, "\n\tRequested target size: 0x");
  size_t v13 = OUTLINED_FUNCTION_1_1(v12, a3[8]);
  size_t v14 = OUTLINED_FUNCTION_0_1(v13, "\n\tRequested target allgnment: 0x");
  size_t v15 = OUTLINED_FUNCTION_1_1(v14, a3[7]);
  OUTLINED_FUNCTION_0_1(v15, "\n\tkern return: 0x");
  lsl::appendHexToString<int>(a1, a4, v16);
  qword_18C509760 = (uint64_t)a1;
  __assert_rtn("vm_allocate_bytes", "Allocator.cpp", 342, "0 && vm_allocate failed");
}

void lsl::AllocatorLayout::init()
{
  __assert_rtn("consumeSpace", "Allocator.cpp", 426, "consumedSpace <= size");
}

void lsl::Allocator::stackAllocatorInternal()
{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 471, "buffer != nullptr");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 472, "size != 0");
}

{
  __assert_rtn("stackAllocatorInternal", "Allocator.cpp", 475, "0");
}

void lsl::Allocator::aligned_alloc()
{
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 499, "std::popcount(alignment) == 1");
}

void lsl::Allocator::Pool::aligned_alloc_best_fit()
{
  __assert_rtn("aligned_alloc_best_fit", "Allocator.cpp", 754, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("markAllocated", "Allocator.cpp", 1025, "!allocated()");
}

void lsl::Allocator::Pool::aligned_alloc()
{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 705, "(uint64_t)result != (uint64_t)this");
}

{
  __assert_rtn("aligned_alloc", "Allocator.cpp", 674, "_lastFreeMetadata->pool() == this");
}

void lsl::Allocator::AllocationMetadata::deallocate()
{
}

void lsl::Allocator::Pool::Pool()
{
}

void lsl::Allocator::AllocationMetadata::reserve()
{
}

void lsl::Allocator::AllocationMetadata::AllocationMetadata()
{
}

void lsl::Allocator::AllocationMetadata::setPoolHint()
{
}

void dyld4::APIs::dlopen_from(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_1("handleFromLoader", "DyldAPIs.cpp", a3, "(((uintptr_t)ldr) & 1) == 0");
}

void objc::objc_headeropt_rw_t<unsigned long>::isLoaded()
{
}

void dyld4::objc_headeropt_rw_t::isLoaded()
{
}

void dyld4::EqualTypeConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 209, "state != nullptr");
}

void dyld4::EqualMetadataConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 216, "state != nullptr");
}

void dyld4::EqualForeignConformanceLookupKey::equal()
{
  __assert_rtn("equal", "DyldRuntimeState.h", 223, "state != nullptr");
}

void dyld4::APIs::_dyld_pseudodylib_register()
{
  __assert_rtn( "_dyld_pseudodylib_register",  "DyldAPIs.cpp",  3213,  "result == nullptr && Existing pseudo-dylib, but result set anyway?");
}

void ___ZNK6mach_o6Header19platformAndVersionsEv_block_invoke_cold_1()
{
}

void mach_o::Header::loadCommandToDylibKind()
{
}

void dyld4::generateClassOrProtocolHashTable()
{
  __assert_rtn( "generateClassOrProtocolHashTable",  "PrebuiltObjC.cpp",  773,  "protocolIndexIt != image.protocolIndexMap.end()");
}

void dyld4::PrebuiltObjC::generatePerImageFixups()
{
}

void dyld4::PrebuiltObjC::forEachSelectorReferenceToUnique()
{
}

void dyld4::PrebuiltObjC::make()
{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 884, "headerInfoRO != nullptr");
}

{
  __assert_rtn("getPreoptimizedHeaderROIndex", "OptimizerObjC.h", 885, "headerInfoRW != nullptr");
}

{
  __assert_rtn( "getPreoptimizedHeaderROIndex",  "OptimizerObjC.h",  895,  "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

{
  __assert_rtn( "getPreoptimizedHeaderROIndex",  "OptimizerObjC.h",  906,  "hinfoRW->entsize == sizeof(header_info_rw<PointerType>)");
}

void dyld4::PrebuiltObjC::serializeFixups()
{
}

{
  __assert_rtn( "serializeFixups",  "PrebuiltObjC.cpp",  1340,  "fixups.protocolISAFixups.count() == fixups.binaryInfo.protocolListCount");
}

void dyld3::MultiMap<prebuilt_objc::ObjCStringKey,prebuilt_objc::ObjCObjectLocation,prebuilt_objc::HashObjCStringKey,prebuilt_objc::EqualObjCStringKey>::insert()
{
}

void objc::objc_headeropt_ro_t<unsigned long long>::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void objc::objc_headeropt_ro_t<unsigned long long>::index()
{
  __assert_rtn("index", "OptimizerObjC.h", 792, "hi >= begin && hi < end");
}

void abort_report_np(char *__format, ...)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  if (!a1) {
    abort_report_np("Assertion failed: (%s), file %s, line %d.\n", a4, a2, a3);
  }
  abort_report_np("Assertion failed: (%s), function %s, file %s, line %d.\n", a4, a1, a2, a3);
}

void abort(void)
{
}

void dyld4::Atlas::Mapper::~Mapper()
{
  __assert_rtn("~Mapper", "ProcessAtlas.cpp", 493, "_flatMapping == nullptr");
}

void dyld4::Atlas::Mapper::map()
{
  __assert_rtn("map", "ProcessAtlas.cpp", 521, "((uint64_t)addr + size) <= mapping.address + mapping.size");
}

void dyld4::Atlas::SharedCache::SharedCache()
{
}

void dyld4::Atlas::ProcessSnapshot::addSharedCacheImage()
{
  __assert_rtn("addSharedCacheImage", "ProcessAtlas.cpp", 1750, "i != images.end()");
}

void dyld4::Atlas::ProcessSnapshot::Serializer::emitMappedFileInfo()
{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1899, "i != _volumeUUIDs.end()");
}

{
  __assert_rtn("emitMappedFileInfo", "ProcessAtlas.cpp", 1900, "*i == file.volume()");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::insert( uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_7("insert", "BTree.h", a3, "size() != capacity()");
}

{
  OUTLINED_FUNCTION_6("insert", "BTree.h", a3, "index != capacity()");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::const_iterator::prepareForInsertion( uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5( "prepareForInsertion",  "BTree.h",  a3,  "_depth == _btree->_depth && prepareForInsertion only works on iterators leaf nodes");
}

void lsl::BTree<char const*,lsl::ConstCharStarCompare,false>::NodeCore<31u,15u>::splitChild( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

{
  OUTLINED_FUNCTION_3_2( "splitChild",  "BTree.h",  a3,  "!newChild->full() && !child->full() && After split the child nodes should be full");
}

{
  OUTLINED_FUNCTION_2_2( "splitChild",  "BTree.h",  a3,  "children()[index]->full() && The child being split must be full");
}

{
  OUTLINED_FUNCTION_1_2( "splitChild",  "BTree.h",  a3,  "size() < capacity() && There must be room in this node for an additional child");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::erase()
{
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::erase()
{
}

{
  __assert_rtn("erase", "BTree.h", 150, "leaf()");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::const_iterator::rebalanceFromErasure()
{
  __assert_rtn("rebalanceFromErasure", "BTree.h", 651, "_indexes[0] == 0");
}

{
  __assert_rtn( "rebalanceFromErasure",  "BTree.h",  610,  "_depth == _btree->_depth && rebalanceFromErasure only works on iterators to leaf nodes");
}

void lsl::BTree<lsl::UniquePtr<dyld4::Atlas::Image>,std::less<lsl::UniquePtr<dyld4::Atlas::Image>>,false>::NodeCore<31u,15u>::merge()
{
}

{
  __assert_rtn("merge", "BTree.h", 247, "index < size() && A node must have a successor node to merge with");
}

void DyldSharedCache::forEachPatchableUseOfExportInImage()
{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1403, "userDylib != nullptr");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1404, "userDylibImageIndex != ~0U");
}

{
  __assert_rtn("forEachPatchableUseOfExportInImage", "DyldSharedCache.cpp", 1405, "!dataRanges.empty()");
}

void ___ZNK15DyldSharedCache34forEachPatchableUseOfExportInImageEjjjU13block_pointerFvjN5dyld39MachOFile15PointerMetaDataEybE_block_invoke_2_cold_1()
{
}

void objc_visitor::MethodList::numMethods()
{
  __assert_rtn("numMethods", "ObjCVisitor.cpp", 904, "methodList != nullptr");
}

void objc_visitor::MethodList::usesRelativeOffsets()
{
  __assert_rtn("usesRelativeOffsets", "ObjCVisitor.cpp", 945, "methodList != nullptr");
}

void objc_visitor::MethodList::getMethod()
{
}

{
  __assert_rtn("getMethod", "ObjCVisitor.cpp", 1053, "methodList != nullptr");
}

void objc_visitor::Method::getNameField()
{
}

{
  __assert_rtn("getNameField", "ObjCVisitor.cpp", 1099, "0");
}

void objc_visitor::Method::getName()
{
}

void objc_visitor::Method::getNameVMAddr()
{
}

void objc_visitor::Method::getNameSelRefVMAddr()
{
}

{
  __assert_rtn("getNameSelRefVMAddr", "ObjCVisitor.cpp", 1316, "0");
}

void objc_visitor::ProtocolList::numProtocols()
{
  __assert_rtn("numProtocols", "ObjCVisitor.cpp", 1541, "protocolList != nullptr");
}

void objc_visitor::ProtocolList::getProtocolField()
{
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1557, "protocolList != nullptr");
}

{
  __assert_rtn("getProtocolField", "ObjCVisitor.cpp", 1553, "i < this->numProtocols(objcVisitor)");
}

void objc_visitor::Visitor::forEachClass()
{
  __assert_rtn("forEachClass", "ObjCVisitor.cpp", 1797, "(classListSection.sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachCategory()
{
  __assert_rtn("forEachCategory", "ObjCVisitor.cpp", 1879, "(categoryListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachProtocol()
{
  __assert_rtn("forEachProtocol", "ObjCVisitor.cpp", 1905, "(protocolListSection->sectSize % pointerSize) == 0");
}

void objc_visitor::Visitor::forEachSelectorReference()
{
  __assert_rtn("forEachSelectorReference", "ObjCVisitor.cpp", 1930, "(selRefsSection->sectSize % pointerSize) == 0");
}

void metadata_visitor::SwiftVisitor::getSwiftConformances()
{
  __assert_rtn("getSwiftConformances", "SwiftVisitor.cpp", 64, "(protoListSection->sectSize % 4) == 0");
}

void metadata_visitor::SwiftConformance::SwiftTypeRefPointer::getClassName()
{
  __assert_rtn( "getClassName",  "SwiftVisitor.cpp",  408,  "this->kind == SwiftProtocolConformanceFlags::TypeReferenceKind::directObjCClassName");
}

void dyld3::MachOFile::entryAddrFromThreadCmd()
{
  __assert_rtn("entryAddrFromThreadCmd", "MachOFile.cpp", 1543, "cmd->cmd == LC_UNIXTHREAD");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::unpackTarget()
{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1970, "this->authBind.auth == 0");
}

{
  __assert_rtn("unpackTarget", "MachOLayout.cpp", 1969, "this->authBind.bind == 0");
}

void mach_o::ChainedFixupPointerOnDisk::Arm64e::signExtendedAddend()
{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1976, "this->authBind.bind == 1");
}

{
  __assert_rtn("signExtendedAddend", "MachOLayout.cpp", 1977, "this->authBind.auth == 0");
}

void mach_o::ChainedFixupPointerOnDisk::isRebase()
{
}

void mach_o::ChainedFixupPointerOnDisk::isBind()
{
}

void mach_o::ChainedFixupPointerOnDisk::strideSize()
{
}

void dyld3::MachOAnalyzer::chainedPointerFormat()
{
  __assert_rtn( "chainedPointerFormat",  "MachOAnalyzer.cpp",  3257,  "this->cputype == CPU_TYPE_ARM64 && (this->maskedCpuSubtype() == CPU_SUBTYPE_ARM64E) && chainedPointerFormat() call ed on non-chained binary");
}

void dyld3::MachOAnalyzer::forEachRebase_Opcodes()
{
  __assert_rtn("forEachRebase_Opcodes", "MachOAnalyzer.cpp", 5226, "leInfo.dyldInfo != nullptr");
}

void Diagnostics::assertNoError(Diagnostics *a1)
{
  uint64_t v1 = (const char *)Diagnostics::errorMessageCStr(a1);
  abort_report_np("%s", v1);
}

void mach_o::Platform::Platform()
{
  __assert_rtn( "Platform",  "Platform.cpp",  745,  "p->value != 0 && PlatformInfo value uninitialized, this might be a problem with C++ static initializers order");
}

void _enlarge_cold_1(int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Failed to allocate memory for buffer";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_unfair_lock_recursive_abort(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_unfair_lock";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_unfair_lock_unowned_abort(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_unfair_lock not owned by current thread";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_unfair_lock_corruption_abort(unsigned int a1)
{
  if (a1 - 512 <= 0x3FE00)
  {
    qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt, or owner thread exited without unlocking";
    qword_18C509778 = a1;
    __break(1u);
  }

  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_unfair_lock is corrupt";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_once_gate_recursive_abort(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_once_t";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_once_gate_unowned_abort(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Unlock of an os_once_t not owned by current thread";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_once_gate_corruption_abort(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: os_once_t is corrupt";
  qword_18C509778 = a1;
  __break(1u);
}

void os_unfair_lock_assert_owner_cold_1(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly not owned by current thread";
  qword_18C509778 = a1;
  __break(1u);
}

void os_unfair_lock_assert_not_owner_cold_1(unsigned int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Assertion failed: Lock unexpectedly owned by current thread";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_alloc_cold_1(uint64_t a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Requested allocation size is invalid";
  qword_18C509778 = a1;
  __break(1u);
}

void _os_semaphore_dispose_cold_1(int a1)
{
  qword_18C509748 = (uint64_t)"BUG IN CLIENT OF LIBPLATFORM: Destroying semaphore failed";
  qword_18C509778 = a1;
  __break(1u);
}

void abort_with_reason(void *a1, void *a2, void *a3, unint64_t a4)
{
}

void abort_with_payload_wrapper_internal( void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
  sigset_t v15 = 32;
  sigprocmask(2, &v15, 0LL);
  __abort_with_payload(a1, a2, a3, a4, a5, (void *)a6, v12, v13);
  uint64_t v14 = getpid();
  terminate_with_payload(v14, a1, a2, a3, a4, a5, a6 | 0x200);
  __break(1u);
}

void abort_with_payload(void *a1, void *a2, void *a3, void *a4, void *a5, unint64_t a6)
{
}