uint64_t tcp_ledbat_init(uint64_t a1)
{
  unsigned int v1;
  do
    v1 = __ldaxr(dword_18C4CE860);
  while (__stlxr(v1 + 1, dword_18C4CE860));
  **(_DWORD **)(a1 + 840) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 4LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 12LL) = 0;
  return 0LL;
}

uint64_t tcp_ledbat_cleanup()
{
  do
    unsigned int v0 = __ldaxr(dword_18C4CE860);
  while (__stlxr(v0 - 1, dword_18C4CE860));
  return 0LL;
}

_DWORD *tcp_ledbat_cwnd_init(_DWORD *result)
{
  result[36] = *(_DWORD *)(sysctls + 16) * result[49];
  result[184] = result[37];
  return result;
}

_DWORD *tcp_ledbat_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300)) {
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  }
  unsigned int v3 = result[72] + v2;
  result[72] = v3;
  unsigned int v4 = result[36];
  BOOL v5 = v3 >= v4;
  unsigned int v6 = v3 - v4;
  if (v6 != 0 && v5)
  {
    result[72] = v6;
    int v7 = result[49];
    if (v4 < result[35] && v7 != 0) {
      return (_DWORD *)update_cwnd((uint64_t)result, v7, 1);
    }
  }

  return result;
}

_DWORD *tcp_ledbat_ack_rcvd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8) - result[23];
  if (*(_DWORD *)(sysctls + 300)) {
    return (_DWORD *)ledbat_pp_ack_rcvd((uint64_t)result, v2);
  }
  unsigned int v3 = result[36];
  unsigned int v4 = result[49];
  unsigned int v5 = result[72] + v2;
  result[72] = v5;
  if (v3 >= result[184])
  {
    if (v5 >= v3) {
      unsigned int v2 = v4;
    }
    else {
      unsigned int v2 = 0;
    }
    BOOL v7 = v5 >= v3;
    unsigned int v8 = v5 - v3;
    if (!v7) {
      goto LABEL_14;
    }
  }

  else
  {
    unsigned int v6 = v4 << (result[25] == result[24]);
    if (v2 >= v6) {
      unsigned int v2 = v6;
    }
    BOOL v7 = v5 >= v3;
    unsigned int v8 = v5 - v3;
    if (!v7) {
      goto LABEL_14;
    }
  }

  result[72] = v8;
LABEL_14:
  if (v2) {
    return (_DWORD *)update_cwnd((uint64_t)result, v2, 1);
  }
  return result;
}

uint64_t tcp_ledbat_pre_fr(uint64_t result)
{
  if ((*(_BYTE *)(result + 742) & 0x10) != 0)
  {
    unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    unsigned int v2 = *(_DWORD *)(result + 980);
    if (v2 <= v1) {
      unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    }
  }

  else
  {
    unsigned int v1 = 0;
    unsigned int v2 = *(_DWORD *)(result + 140);
    if (v2 >= *(_DWORD *)(result + 144)) {
      unsigned int v2 = *(_DWORD *)(result + 144);
    }
  }

  *(_DWORD *)(result + 984) = v1;
  unsigned int v3 = *(_DWORD *)(result + 196);
  unsigned int v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
  unsigned int v5 = 2 * v3;
  if (v4 > v5) {
    unsigned int v5 = v4;
  }
  *(_DWORD *)(result + 148) = v5;
  if (*(_DWORD *)(result + 736) > v5) {
    *(_DWORD *)(result + 736) = v5;
  }
  unsigned int v6 = *(_DWORD **)(*(void *)(result + 80) + 224LL);
  if (v6[97] > v5)
  {
    int v7 = v6[108];
    if ((v7 & 0x400) != 0)
    {
      if (v6[109] > v5)
      {
        if (v5 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v5 = *(_DWORD *)(sysctls + 120);
        }
        v6[109] = v5;
      }

      v6[108] = v7 | 0x800;
    }
  }

  return result;
}

uint64_t tcp_ledbat_post_fr(uint64_t result, uint64_t a2)
{
  unsigned int v2 = (_DWORD *)(result + 92);
  if (a2) {
    unsigned int v2 = (_DWORD *)(a2 + 8);
  }
  int v3 = *(_DWORD *)(result + 96) - *v2;
  int v4 = *(_DWORD *)(result + 148);
  if (v3 < v4)
  {
    uint64_t v5 = *(unsigned int *)(result + 196);
    if (v3 <= v5) {
      int v3 = *(_DWORD *)(result + 196);
    }
    int v4 = v3 + v5;
  }

  *(_DWORD *)(result + 144) = v4;
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  return result;
}

uint64_t tcp_ledbat_after_idle(uint64_t result)
{
  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 4LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 8LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  *(_DWORD *)(result + 144) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  *(_DWORD *)(result + 288) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  return result;
}

uint64_t tcp_ledbat_after_timeout(uint64_t result)
{
  if (*(int *)(result + 12) >= 4)
  {
    **(_DWORD **)(result + 840) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 4LL) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 8LL) = 0;
    *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
    if ((*(_BYTE *)(result + 742) & 0x10) != 0)
    {
      unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
      unsigned int v2 = *(_DWORD *)(result + 980);
      if (v2 <= v1) {
        unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
      }
    }

    else
    {
      unsigned int v1 = 0;
      unsigned int v2 = *(_DWORD *)(result + 140);
      if (v2 >= *(_DWORD *)(result + 144)) {
        unsigned int v2 = *(_DWORD *)(result + 144);
      }
    }

    *(_DWORD *)(result + 984) = v1;
    unsigned int v3 = *(_DWORD *)(result + 196);
    unsigned int v4 = ((v3 >> 1) + (v2 >> 1)) / v3 * v3;
    if (v4 <= 2 * v3) {
      unsigned int v4 = 2 * v3;
    }
    *(_DWORD *)(result + 148) = v4;
    if (*(_DWORD *)(result + 736) > v4) {
      *(_DWORD *)(result + 736) = v4;
    }
    uint64_t v5 = *(_DWORD **)(*(void *)(result + 80) + 224LL);
    if (v5[97] > v4)
    {
      int v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (v4 >= *(_DWORD *)(sysctls + 120)) {
            unsigned int v4 = *(_DWORD *)(sysctls + 120);
          }
          v5[109] = v4;
        }

        v5[108] = v6 | 0x800;
      }
    }

    *(_DWORD *)(result + 144) = v3;
  }

  return result;
}

uint64_t tcp_ledbat_delay_ack(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(sysctls + 288) == 1) {
    return tcp_cc_delay_ack(a1, a2);
  }
  return (*(_BYTE *)(a1 + 90) & 4) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1;
}

uint64_t tcp_ledbat_switch_cc(uint64_t result)
{
  **(_DWORD **)(result + 840) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 4LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 8LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  unsigned int v1 = *(_DWORD *)(result + 736);
  unsigned int v2 = *(_DWORD *)(result + 148);
  if (v1 - 1 >= v2)
  {
    *(_DWORD *)(result + 736) = v2;
    unsigned int v1 = v2;
  }

  unsigned int v3 = *(_DWORD *)(result + 140);
  unsigned int v4 = *(_DWORD *)(result + 144);
  if (v3 >= v4) {
    unsigned int v3 = *(_DWORD *)(result + 144);
  }
  if (v4 <= v1) {
    v3 >>= 1;
  }
  unsigned int v5 = *(_DWORD *)(result + 196);
  unsigned int v6 = v3 / v5;
  if (v6 <= *(_DWORD *)(sysctls + 16)) {
    unsigned int v6 = *(_DWORD *)(sysctls + 16);
  }
  *(_DWORD *)(result + 144) = v6 * v5;
  *(_DWORD *)(result + 288) = 0;
  do
    unsigned int v7 = __ldaxr(dword_18C4CE860);
  while (__stlxr(v7 + 1, dword_18C4CE860));
  return result;
}

uint64_t ledbat_pp_ack_rcvd(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 496);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 1488)) != 0) {
    unsigned int v7 = *(_DWORD *)(v6 + 40);
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v8 = 1908LL;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v8 = 236LL;
  }
  unsigned int v9 = *(_DWORD *)(a1 + v8);
  int v10 = 3 * *(_DWORD *)(sysctls + 4);
  if (v10 >= 0) {
    int v11 = 3 * *(_DWORD *)(sysctls + 4);
  }
  else {
    int v11 = v10 + 3;
  }
  uint64_t result = nw_tcp_access_globals(*(void *)(v4 + 224));
  v13 = *(_DWORD **)(a1 + 840);
  unsigned int v14 = v13[1];
  if (!v14) {
    goto LABEL_20;
  }
  unsigned int v15 = *(_DWORD *)(result + 316);
  if (v15 < v14)
  {
    unsigned int v14 = 1;
    goto LABEL_20;
  }

  if (!v13[2])
  {
    v13[2] = v15;
    ++**(_DWORD **)(a1 + 840);
    unsigned int v15 = *(_DWORD *)(result + 316);
    v13 = *(_DWORD **)(a1 + 840);
    unsigned int v14 = v13[1];
  }

  if (v15 >= v14 + 2 * (*(int *)(a1 + 200) >> 5))
  {
LABEL_20:
    if (v9) {
      BOOL v18 = v7 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18)
    {
      if (10 * *(_DWORD *)(a1 + 196) >= a2) {
        int v19 = a2;
      }
      else {
        int v19 = 10 * *(_DWORD *)(a1 + 196);
      }
      return update_cwnd(a1, v19, 1);
    }

    unsigned int v20 = *(_DWORD *)(a1 + 144);
    unsigned int v21 = *(_DWORD *)(a1 + 736);
    if (v20 < v21)
    {
      int v22 = v11 >> 2;
      if (*v13)
      {
        int v23 = *(_DWORD *)(sysctls + 4);
        unsigned int v24 = v22 + v7;
        BOOL v25 = v9 > v23 + v7 && v9 > v24;
        if (!v25) {
          goto LABEL_56;
        }
      }

      else if (v9 <= v22 + v7)
      {
        int v23 = *(_DWORD *)(sysctls + 4);
LABEL_56:
        unsigned int v39 = *(_DWORD *)(a1 + 288) + a2;
        *(_DWORD *)(a1 + 288) = v39;
        double v40 = (double)(2 * v23) / (double)v7;
        double v41 = trunc(v40);
        BOOL v25 = v40 <= v41;
        double v42 = 0.0;
        if (!v25) {
          double v42 = 1.0;
        }
        unsigned int v43 = (v42 + v41);
        if (v43 >= 0x10) {
          unsigned int v43 = 16;
        }
        int v44 = *(_DWORD *)(a1 + 196);
        if (v39 >= v44 * v43)
        {
          if (v39 / v43 >= 10 * v44) {
            int v45 = 10 * v44;
          }
          else {
            int v45 = v39 / v43;
          }
          *(_DWORD *)(a1 + 288) = 0;
          uint64_t result = update_cwnd(a1, v45, 1);
          v13 = *(_DWORD **)(a1 + 840);
        }

        if (v13[1]) {
          v13[1] = 0;
        }
        return result;
      }
    }

    int v26 = *(_DWORD *)(result + 316);
    if (v14)
    {
LABEL_45:
      uint64_t v28 = sysctls;
      if (*(_DWORD *)(sysctls + 4) + v7 < v9)
      {
        *(_DWORD *)(*(void *)(a1 + 840) + 12LL) += a2;
        uint64_t v29 = *(void *)(a1 + 840);
        unsigned int v30 = *(_DWORD *)(v29 + 12);
        unsigned int v31 = *(_DWORD *)(a1 + 144);
        BOOL v32 = v30 >= v31;
        unsigned int v33 = v30 - v31;
        if (v32)
        {
          unsigned int v34 = v9 - v7;
          if (v9 < v7) {
            unsigned int v34 = 0;
          }
          int v35 = (fmin((double)v34 / (double)*(int *)(v28 + 4) + -1.0, 0.5) * (double)v31);
          *(_DWORD *)(v29 + 12) = v33;
          uint64_t result = update_cwnd(a1, v35, 0);
          uint64_t v36 = *(void *)(a1 + 840);
          if (*(_DWORD *)(v36 + 4)) {
            *(_DWORD *)(v36 + 4) = v26 + 30000;
          }
        }

        return result;
      }

      unsigned int v37 = *(_DWORD *)(a1 + 288) + a2;
      *(_DWORD *)(a1 + 288) = v37;
      BOOL v32 = v37 >= v20;
      unsigned int v38 = v37 - v20;
      if (!v32) {
        return result;
      }
      int v19 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = v38;
      return update_cwnd(a1, v19, 1);
    }

    if (*v13)
    {
      int v27 = (v26 - v13[2]) << (v20 < v21);
      v13[1] = 9 * v27 + v26;
      if (v27) {
        goto LABEL_43;
      }
    }

    else
    {
      v13[1] = v26;
    }

    *(_DWORD *)(*(void *)(a1 + 840) + 4LL) += 2 * (*(int *)(a1 + 200) >> 5);
LABEL_43:
    *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = 0;
    unsigned int v20 = *(_DWORD *)(a1 + 144);
    if (*(_DWORD *)(a1 + 736) > v20) {
      *(_DWORD *)(a1 + 736) = v20;
    }
    goto LABEL_45;
  }

  unsigned int v16 = *(_DWORD *)(a1 + 144);
  unsigned int v17 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
  if (v16 > v17)
  {
    if (*(_DWORD *)(a1 + 736) < v16) {
      *(_DWORD *)(a1 + 736) = v16;
    }
    *(_DWORD *)(a1 + 144) = v17;
    *(_DWORD *)(a1 + 288) = 0;
  }

  return result;
}

uint64_t update_cwnd(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 80) + 496LL);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 1488)) != 0) {
    int v5 = *(_DWORD *)(v4 + 40);
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = (_DWORD *)sysctls;
  uint64_t v7 = 1908LL;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v7 = 236LL;
  }
  if (v5 && (unsigned int v8 = *(_DWORD *)(result + v7)) != 0)
  {
    if (v8 <= *(_DWORD *)(sysctls + 4) + v5)
    {
      unsigned int v11 = *(_DWORD *)(result + 144);
      if (*(_DWORD *)(result + 736) < v11) {
        *(_DWORD *)(result + 736) = v11;
      }
      unsigned int v10 = (v11 + a2 + (*(_DWORD *)(result + 196) >> 1)) / *(_DWORD *)(result + 196) * *(_DWORD *)(result + 196);
    }

    else
    {
      if (*(_DWORD *)(sysctls + 300))
      {
        if (a3)
        {
          int v19 = a2;
          uint64_t v18 = result;
          unsigned int v16 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
          unsigned int v17 = (void *)_os_log_send_and_compose_impl();
          uint64_t result = __nwlog_abort();
          if ((_DWORD)result)
          {
            __break(1u);
            return result;
          }

          free(v17);
          uint64_t v6 = (_DWORD *)sysctls;
          uint64_t result = v18;
          a2 = v19;
        }

        unsigned int v9 = *(_DWORD *)(result + 144) - a2;
      }

      else
      {
        unsigned int v9 = *(_DWORD *)(result + 144) - (*(_DWORD *)(result + 144) >> 3);
      }

      unsigned int v12 = *(_DWORD *)(result + 196);
      if (v9 <= v12 * v6[4]) {
        unsigned int v9 = v12 * v6[4];
      }
      unsigned int v10 = (v9 + (v12 >> 1)) / v12 * v12;
      if (*(_DWORD *)(result + 736) > v10) {
        *(_DWORD *)(result + 736) = v10;
      }
    }
  }

  else
  {
    unsigned int v10 = *(_DWORD *)(result + 144) + a2;
  }

  if (v6[75])
  {
    char v13 = *(_BYTE *)(result + 260);
    uint64_t v14 = 0xFFFFLL << v13;
    unsigned int v15 = 0xFFFF << v13;
    if (v14 > v10) {
      unsigned int v15 = v10;
    }
  }

  else
  {
    unsigned int v15 = ((*(_DWORD *)(result + 96) - *(_DWORD *)(result + 92)) << v6[3]) + *(_DWORD *)(result + 196) * v6[2];
    if (v10 < v15) {
      unsigned int v15 = v10;
    }
  }

  *(_DWORD *)(result + 144) = v15;
  return result;
}

uint64_t in_pcbbind(uint64_t a1, _BYTE *a2)
{
  if (*(_WORD *)(a1 + 2226) || *(_DWORD *)(a1 + 492) || a2 && *a2 != 16) {
    return 22LL;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 2136) + 8LL))(*(void *)(a1 + 224));
  if (!(_DWORD)result)
  {
    uint64_t result = 0LL;
    *(_WORD *)(a1 + 2226) = 0;
  }

  return result;
}

void in_pcbdetach(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 224);
  if (in_pcb_checkstate(a1, 0xFFFFLL, 1) == 0xFFFF)
  {
    if ((*(_BYTE *)(v2 + 364) & 4) != 0) {
      return;
    }
    uint64_t v3 = *(void *)(a1 + 496);
    if (v3)
    {
      if (*(_BYTE *)(v3 + 1496))
      {
        uint64_t v4 = *(void **)(v3 + 1488);
        if (v4)
        {
          free(v4);
          uint64_t v3 = *(void *)(a1 + 496);
          *(void *)(v3 + 1488) = 0LL;
        }

        *(_BYTE *)(v3 + 1496) = 0;
      }

      *(void *)(a1 + 496) = 0LL;
    }

    sofreelastref(v2);
    *(_DWORD *)(a1 + 232) = 3;
    *(_DWORD *)(v2 + 364) |= 4u;
    uint64_t v5 = nw_tcp_access_globals(v2);
    uint64_t v6 = *(void *)(a1 + 16);
    *(_BYTE *)(v5 + 328) |= 2u;
    uint64_t v7 = (unsigned int *)(v6 + 44);
    do
      unsigned int v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
    char v9 = *(_BYTE *)(v5 + 328);
    if ((v9 & 1) != 0)
    {
      if ((*(_BYTE *)(v5 + 328) & 8) != 0) {
        return;
      }
      char v10 = v9 | 8;
    }

    else
    {
      if ((*(_BYTE *)(v5 + 328) & 6) == 0) {
        return;
      }
      char v10 = v9 | 9;
    }

    *(_BYTE *)(v5 + 328) = v10;
    nw_protocol_timer_run_inner(v5, 1000000000LL);
  }

  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v11 = **(__int16 **)(v2 + 8);
    if (v2) {
      unsigned int v12 = (const char *)(v2 + 604);
    }
    else {
      unsigned int v12 = "";
    }
    *(_DWORD *)buf = 136446978;
    unsigned int v17 = "in_pcbdetach";
    __int16 v18 = 2082;
    int v19 = v12;
    __int16 v20 = 2048;
    uint64_t v21 = v2;
    __int16 v22 = 1024;
    int v23 = v11;
    char v13 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v14 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v15 = **(__int16 **)(v2 + 8);
        *(_DWORD *)buf = 136446978;
        unsigned int v17 = "in_pcbdetach";
        __int16 v18 = 2082;
        int v19 = v12;
        __int16 v20 = 2048;
        uint64_t v21 = v2;
        __int16 v22 = 1024;
        int v23 = v15;
        _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s so=%p proto=%d couldn't set to STOPUSING, backtrace limit exceeded",  buf,  0x26u);
      }
    }

    if (v13) {
      free(v13);
    }
  }
}

uint64_t in_pcb_checkstate(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (unsigned int *)(a1 + 456);
  if ((_DWORD)a2 == 0xFFFF)
  {
    if (!a3) {
      (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8LL) + 16LL))();
    }
    *(_DWORD *)(a1 + 232) = 3;
    goto LABEL_28;
  }

  uint64_t v7 = a2;
  if ((_DWORD)a2 == 2)
  {
    if (!a3) {
      (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8LL) + 16LL))();
    }
LABEL_14:
    unsigned int v10 = *v6;
    if ((unsigned __int16)*v6 == 0xFFFF)
    {
      if (!a3) {
        (*(void (**)(void))(*(void *)(*(void *)(a1 + 224) + 8LL) + 24LL))();
      }
      return 0xFFFFLL;
    }

    if (!(unsigned __int16)*v6)
    {
      uint64_t v35 = *(void *)(a1 + 224);
      if (!v35 || (*(_BYTE *)(v35 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        *(_DWORD *)buf = 136446722;
        unsigned int v43 = "in_pcb_checkstate";
        if (v35) {
          uint64_t v36 = (const char *)(v35 + 604);
        }
        else {
          uint64_t v36 = "";
        }
        __int16 v44 = 2082;
        int v45 = v36;
        __int16 v46 = 2048;
        uint64_t v47 = a1;
        uint64_t v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          double v41 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            unsigned int v43 = "in_pcb_checkstate";
            __int16 v44 = 2082;
            int v45 = v36;
            __int16 v46 = 2048;
            uint64_t v47 = a1;
            unsigned int v34 = "%{public}s %{public}s pcb=%p release with zero count, backtrace limit exceeded";
            unsigned int v38 = v41;
            uint32_t v39 = 32;
            goto LABEL_72;
          }
        }

        goto LABEL_73;
      }

      return 0xFFFFLL;
    }

    do
    {
      unsigned int v11 = __ldxr(v6);
      if (v11 != v10)
      {
        __clrex();
        goto LABEL_14;
      }
    }

    while (__stxr(v10 - 1, v6));
    if (*(_DWORD *)(a1 + 232) != 3)
    {
      uint64_t v27 = *(void *)(a1 + 224);
      if ((*(_DWORD *)(v27 + 360) & 0x80000000) == 0)
      {
        if (!a3) {
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v27 + 8) + 24LL))( *(void *)(a1 + 224),  1LL,  v3);
        }
        return 2LL;
      }

      if ((*(_BYTE *)(v27 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        unsigned int v30 = (const char *)(v27 + 604);
        uint64_t v31 = *(void *)(a1 + 224);
        *(_DWORD *)buf = 136446978;
        unsigned int v43 = "in_pcb_checkstate";
        __int16 v44 = 2082;
        int v45 = (const char *)(v27 + 604);
        __int16 v46 = 2048;
        uint64_t v47 = a1;
        __int16 v48 = 2048;
        uint64_t v49 = v31;
        uint64_t v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          BOOL v32 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = *(void *)(a1 + 224);
            *(_DWORD *)buf = 136446978;
            unsigned int v43 = "in_pcb_checkstate";
            __int16 v44 = 2082;
            int v45 = v30;
            __int16 v46 = 2048;
            uint64_t v47 = a1;
            __int16 v48 = 2048;
            uint64_t v49 = v37;
            unsigned int v34 = "%{public}s %{public}s RELEASE pcb=%p so=%p usecount is negative, backtrace limit exceeded";
            goto LABEL_71;
          }
        }

LABEL_73:
        if (v24) {
          free(v24);
        }
      }

      return 0xFFFFLL;
    }

LABEL_28:
    uint64_t v16 = *(void *)(a1 + 224);
    if ((*(_DWORD *)(v16 + 360) & 0x80000000) == 0)
    {
      if (!a3)
      {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v16 + 8) + 24LL))(*(void *)(a1 + 224), 1LL, v3);
        uint64_t v16 = *(void *)(a1 + 224);
      }

      uint64_t v17 = nw_tcp_access_globals(v16);
      uint64_t v18 = *(void *)(a1 + 16);
      *(_BYTE *)(v17 + 328) |= 2u;
      int v19 = (unsigned int *)(v18 + 44);
      do
        unsigned int v20 = __ldaxr(v19);
      while (__stlxr(v20 + 1, v19));
      if ((*(_BYTE *)(v17 + 328) & 1) != 0)
      {
        if ((*(_BYTE *)(v17 + 328) & 8) != 0) {
          goto LABEL_42;
        }
        char v21 = 8;
      }

      else
      {
        if ((*(_BYTE *)(v17 + 328) & 6) == 0) {
          goto LABEL_42;
        }
        char v21 = 9;
      }

      *(_BYTE *)(v17 + 328) |= v21;
      nw_protocol_timer_run_inner(v17, 1000000000LL);
LABEL_42:
      unsigned int v25 = *v6;
      if (!(unsigned __int16)*v6)
      {
        while (1)
        {
          unsigned int v26 = __ldxr(v6);
          if (v26 != v25) {
            break;
          }
          uint64_t v7 = 0xFFFFLL;
          if (!__stxr(0xFFFFu, v6)) {
            return v7;
          }
        }

        __clrex();
      }

      return 0xFFFFLL;
    }

    if ((*(_BYTE *)(v16 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v22 = v16 + 604;
      uint64_t v23 = *(void *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      unsigned int v43 = "in_pcb_checkstate";
      __int16 v44 = 2082;
      int v45 = (const char *)(v16 + 604);
      __int16 v46 = 2048;
      uint64_t v47 = a1;
      __int16 v48 = 2048;
      uint64_t v49 = v23;
      uint64_t v24 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        BOOL v32 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          uint64_t v33 = *(void *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          unsigned int v43 = "in_pcb_checkstate";
          __int16 v44 = 2082;
          int v45 = (const char *)v22;
          __int16 v46 = 2048;
          uint64_t v47 = a1;
          __int16 v48 = 2048;
          uint64_t v49 = v33;
          unsigned int v34 = "%{public}s %{public}s pcb=%p so=%p usecount is negative, backtrace limit exceeded";
LABEL_71:
          unsigned int v38 = v32;
          uint32_t v39 = 42;
LABEL_72:
          _os_log_impl(&dword_1879E5000, v38, OS_LOG_TYPE_ERROR, v34, buf, v39);
          goto LABEL_73;
        }
      }

      goto LABEL_73;
    }

    return 0xFFFFLL;
  }

  if ((_DWORD)a2 == 1)
  {
    while (1)
    {
      unsigned int v8 = *v6;
      uint64_t v7 = 0xFFFFLL;
      if (*(_WORD *)v6 == 0xFFFF) {
        break;
      }
      while (1)
      {
        unsigned int v9 = __ldxr(v6);
        if (v9 != v8) {
          break;
        }
        if (!__stxr(v8 + 1, v6)) {
          return 1LL;
        }
      }

      __clrex();
    }
  }

  else
  {
    uint64_t v12 = *(void *)(a1 + 224);
    if (!v12 || (*(_BYTE *)(v12 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v13 = *(void *)(a1 + 224);
      *(_DWORD *)buf = 136446978;
      __int16 v44 = 2082;
      unsigned int v43 = "in_pcb_checkstate";
      if (v12) {
        uint64_t v14 = (const char *)(v12 + 604);
      }
      else {
        uint64_t v14 = "";
      }
      int v45 = v14;
      __int16 v46 = 2048;
      uint64_t v47 = v13;
      __int16 v48 = 1024;
      LODWORD(v49) = v7;
      int v15 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v28 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = *(void *)(a1 + 224);
          *(_DWORD *)buf = 136446978;
          unsigned int v43 = "in_pcb_checkstate";
          __int16 v44 = 2082;
          int v45 = v14;
          __int16 v46 = 2048;
          uint64_t v47 = v29;
          __int16 v48 = 1024;
          LODWORD(v49) = v7;
          _os_log_impl( &dword_1879E5000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s so=%p not a valid state =%x, backtrace limit exceeded",  buf,  0x26u);
        }
      }

      if (v15) {
        free(v15);
      }
    }
  }

  return v7;
}

  uint64_t v13 = *(_DWORD *)(result + 148);
  if (v6 < v13)
  {
    uint64_t v14 = *(_DWORD *)(result + 196);
    if (v6 <= v14) {
      uint64_t v6 = *(_DWORD *)(result + 196);
    }
    uint64_t v13 = v6 + v14;
  }

  *(_DWORD *)(result + 144) = v13;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 16LL) = 0;
  return result;
}

uint64_t inp_reset_fc_state(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 224);
  int v3 = *(_DWORD *)(a1 + 2228);
  if ((v3 & 0x10000000) != 0)
  {
    *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
    *(_DWORD *)(result + 364) &= ~0x20000u;
    if ((v3 & 0x50000000) == 0) {
      return result;
    }
    goto LABEL_7;
  }

  int v4 = *(_DWORD *)(result + 364);
  *(_DWORD *)(a1 + 2228) = v3 & 0xAFFFFFFF;
  if ((v4 & 0x20000) != 0) {
    *(_DWORD *)(result + 364) = v4 & 0xFFFDFFFF;
  }
  if ((v3 & 0x50000000) != 0)
  {
LABEL_7:
    uint64_t v5 = *(uint64_t (***)(void))(result + 32);
    if (v5)
    {
      if (*v5) {
        return (*v5)();
      }
    }
  }

  return result;
}

uint64_t nw_protocol_tcp_get_frames(uint64_t a1, signed int a2, uint64_t a3, int a4, int *a5, char a6)
{
  uint64_t v6 = a5;
  unsigned int v7 = a4;
  uint64_t v10 = a1;
  uint64_t v197 = *MEMORY[0x1895F89C0];
  if ((a6 & 1) == 0)
  {
    if (!g_use_slab_allocator) {
      return nw_protocol_tcp_get_malloc_frame(a1, a2, a3, a4, a5);
    }
    uint64_t v178 = 0LL;
    v179 = &v178;
    uint64_t v180 = 0x2800000000LL;
    unsigned int v177 = 0;
    if (a3)
    {
      if (a4)
      {
        if (a2 < 1) {
          goto LABEL_248;
        }
        if (a5) {
          *a5 = 0;
        }
        if (a1)
        {
          unsigned int v17 = a2;
          if (*(void *)(a1 + 40))
          {
LABEL_17:
            uint64_t v18 = (void *)nw_tcp_access_globals(v10);
            int v19 = v179;
            v179[3] = 0LL;
            v19[4] = (uint64_t)(v19 + 3);
            unsigned int v20 = nw_context_2k_buffer_length();
            unsigned int frame_count = nw_protocol_tcp_get_frame_count(v17, v20, (int *)&v177);
            if (frame_count > v7 || (unsigned int v22 = frame_count, frame_count - 3 < 0xFFFFFFFE))
            {
              unsigned int v40 = nw_context_8k_buffer_length();
              if (nw_protocol_tcp_get_frame_count(v17, v40, (int *)&v177) == 1)
              {
                uint64_t v23 = nw_context_8k_buffer_manager();
                unsigned int v22 = 1;
                int v24 = nw_context_8k_buffer_length();
              }

              else
              {
                unsigned int v45 = nw_context_16k_buffer_length();
                unsigned int v46 = nw_protocol_tcp_get_frame_count(v17, v45, (int *)&v177);
                if (v46 > v7 || (unsigned int v22 = v46, v46 - 3 < 0xFFFFFFFE))
                {
                  unsigned int v47 = nw_context_64k_buffer_length();
                  if (nw_protocol_tcp_get_frame_count(v17, v47, (int *)&v177) == 1)
                  {
                    uint64_t v23 = nw_context_64k_buffer_manager();
                    unsigned int v22 = 1;
                    int v24 = nw_context_64k_buffer_length();
                  }

                  else
                  {
                    unsigned int v48 = nw_context_128k_buffer_length();
                    unsigned int v22 = nw_protocol_tcp_get_frame_count(v17, v48, (int *)&v177);
                    uint64_t v23 = nw_context_128k_buffer_manager();
                    int v24 = nw_context_128k_buffer_length();
                  }
                }

                else
                {
                  uint64_t v23 = nw_context_16k_buffer_manager();
                  int v24 = nw_context_16k_buffer_length();
                }
              }
            }

            else
            {
              uint64_t v23 = nw_context_2k_buffer_manager();
              int v24 = nw_context_2k_buffer_length();
            }

            int v49 = v24;
            if (v23)
            {
              if (v22 > v7)
              {
                *(_DWORD *)type = 0;
                unsigned int v50 = a2;
                if (nw_protocol_tcp_get_malloc_frame(v10, a2, (uint64_t)(v179 + 3), 1, type))
                {
                  v51 = v179;
                  v52 = v179 + 3;
                  uint64_t v53 = v179[3];
                  if (v53)
                  {
                    **(void **)(a3 + 8) = v53;
                    *(void *)(v51[3] + 40) = *(void *)(a3 + 8);
                    *(void *)(a3 + 8) = v51[4];
                    v51[3] = 0LL;
                    v51[4] = (uint64_t)v52;
                  }

                  if (v6) {
                    *uint64_t v6 = *(_DWORD *)type;
                  }
                  goto LABEL_171;
                }

                v109 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v188 = 136446722;
                  v189 = "nw_protocol_tcp_get_slab_frame";
                  __int16 v190 = 1024;
                  *(_DWORD *)v191 = v22;
                  *(_WORD *)&v191[4] = 1024;
                  *(_DWORD *)&v191[6] = v7;
                  _os_log_impl( &dword_1879E5000,  v109,  OS_LOG_TYPE_ERROR,  "%{public}s requested frame count %u larger than max frame count %u",  v188,  0x18u);
                }

                _Block_object_dispose(&v178, 8);
                uint64_t v110 = a3;
                return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
              }

              uint64_t v171 = v10;
              unsigned int v170 = v7;
              int v54 = 0;
              while (1)
              {
                uint64_t v57 = nw_mem_buffer_allocate();
                if (!v57)
                {
                  uint64_t v10 = v171;
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    v111 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)v188 = 136446466;
                      v189 = "nw_protocol_tcp_get_slab_frame";
                      __int16 v190 = 1024;
                      *(_DWORD *)v191 = v49;
                      _os_log_impl( &dword_1879E5000,  v111,  OS_LOG_TYPE_DEBUG,  "%{public}s failed to allocate slab buffer of size %u",  v188,  0x12u);
                    }
                  }

LABEL_165:
                  unsigned int v50 = a2;
                  unsigned int v124 = a2 - v54;
                  if (a2 == v54)
                  {
                    v161 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v161, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v188 = 136446210;
                    v189 = "nw_protocol_tcp_get_slab_frame";
                    v162 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if ((_DWORD)result) {
                      goto LABEL_275;
                    }
                    free(v162);
                    uint64_t v6 = a5;
                    unsigned int v50 = a2;
                    uint64_t v10 = v171;
                  }

                  *(_DWORD *)type = 0;
                  int malloc_frame = nw_protocol_tcp_get_malloc_frame(v10, v124, (uint64_t)(v179 + 3), 1, type);
                  char v126 = malloc_frame;
                  unsigned int v7 = v170;
                  if (malloc_frame)
                  {
                    v127 = v179;
                    v128 = v179 + 3;
                    uint64_t v129 = v179[3];
                    uint64_t v110 = a3;
                    if (v129)
                    {
                      **(void **)(a3 + 8) = v129;
                      *(void *)(v127[3] + 40) = *(void *)(a3 + 8);
                      *(void *)(a3 + 8) = v127[4];
                      v127[3] = 0LL;
                      v127[4] = (uint64_t)v128;
                    }

                    if (v6)
                    {
                      int v130 = *v6 + *(_DWORD *)type;
                      goto LABEL_180;
                    }

LABEL_171:
                    _Block_object_dispose(&v178, 8);
                    return 1LL;
                  }

                  v131 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v188 = 136446466;
                    v189 = "nw_protocol_tcp_get_slab_frame";
                    __int16 v190 = 1024;
                    *(_DWORD *)v191 = v124;
                    _os_log_impl( &dword_1879E5000,  v131,  OS_LOG_TYPE_ERROR,  "%{public}s tcp get malloc failed for %u bytes",  v188,  0x12u);
                  }

                  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
                  *((void *)&buf + 1) = 0x40000000LL;
                  v183 = __nw_protocol_tcp_get_slab_frame_block_invoke;
                  v184 = &unk_18A0EE768;
                  v185 = &v178;
                  uint64_t v186 = v23;
                  v187 = v18;
                  uint64_t v132 = v179[3];
                  do
                  {
                    if (!v132) {
                      break;
                    }
                    uint64_t v133 = *(void *)(v132 + 32);
                    char v134 = ((uint64_t (*)(__int128 *))v183)(&buf);
                    uint64_t v132 = v133;
                  }

                  while ((v134 & 1) != 0);
                  uint64_t v110 = a3;
                  unsigned int v50 = a2;
                  if (v179[3])
                  {
                    v165 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v165, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v188 = 136446210;
                    v189 = "nw_protocol_tcp_get_slab_frame";
                    v166 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if ((_DWORD)result) {
                      goto LABEL_275;
                    }
                    free(v166);
                    uint64_t v6 = a5;
                    uint64_t v110 = a3;
                    unsigned int v50 = a2;
                    unsigned int v7 = v170;
                    uint64_t v10 = v171;
                    if (a5) {
                      goto LABEL_179;
                    }
                  }

                  else if (v6)
                  {
LABEL_179:
                    int v130 = 0;
LABEL_180:
                    *uint64_t v6 = v130;
                  }

                  _Block_object_dispose(&v178, 8);
                  if ((v126 & 1) == 0) {
                    return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
                  }
                  return 1LL;
                }

                uint64_t v58 = v57;
                uint64_t v59 = v18[26];
                if (v59)
                {
                  uint64_t v61 = *(void *)(v59 + 16);
                  v62 = *(void **)(v59 + 24);
                  v60 = (void *)(v59 + 16);
                  if (v61)
                  {
                    *(void *)(v61 + 24) = v62;
                    v62 = *(void **)(v59 + 24);
                  }

                  else
                  {
                    v18[27] = v62;
                  }

                  void *v62 = v61;
                  void *v60 = 0LL;
                  *(void *)(v59 + 24) = 0LL;
                  v66 = (uint64_t *)v18[29];
                  *(void *)(v59 + 24) = v66;
                  uint64_t *v66 = v59;
                  v18[29] = v60;
                  uint64_t v67 = v18[3];
                  if (v67 <= 0)
                  {
                    v107 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)v188 = 136446210;
                    v189 = "nw_protocol_tcp_get_slab_frame";
                    v108 = (void *)_os_log_send_and_compose_impl();
                    uint64_t result = __nwlog_abort();
                    if ((_DWORD)result) {
                      goto LABEL_275;
                    }
                    free(v108);
                    uint64_t v67 = v18[3];
                  }

                  v18[3] = v67 - 1;
                  int v68 = *(unsigned __int16 *)(v59 + 204);
                  *(void *)(v59 + 80) = nw_frame_tcp_finalize;
                  *(void *)(v59 + 88) = v18;
                  *(void *)(v59 + 112) = v58;
                  *(void *)(v59 + 104) = 0LL;
                  *(_WORD *)(v59 + 196) = 0;
                  *(_DWORD *)(v59 + 48) = v49;
                  *(_DWORD *)(v59 + 52) = v49;
                  *(void *)(v59 + 56) = 0LL;
                  *(_DWORD *)(v59 + 192) = 0;
                  *(_BYTE *)(v59 + 200) = 0;
                  unsigned int v69 = v68 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v59 + 206) << 16);
                  *(_WORD *)(v59 + 204) = v69;
                  *(_BYTE *)(v59 + 206) = BYTE2(v69);
                  v70 = *(void **)(v59 + 64);
                  if (v70)
                  {
                    do
                    {
                      v71 = (void *)*v70;
                      v72 = (void *)v70[6];
                      v73 = (void *)*v70;
                      if (v72)
                      {
                        nw_release(v72);
                        v70[6] = 0LL;
                        v73 = (void *)*v70;
                      }

                      v74 = (void *)v70[1];
                      if (v73)
                      {
                        v73[1] = v74;
                        v74 = (void *)v70[1];
                      }

                      else
                      {
                        *(void *)(v59 + 72) = v74;
                      }

                      void *v74 = v73;
                      if (v70 != (void *)(v59 + 120)) {
                        free(v70);
                      }
                      v70 = v71;
                    }

                    while (v71);
                  }

                  *(void *)(v59 + 64) = 0LL;
                  *(void *)(v59 + 72) = v59 + 64;
                  v75 = *(void **)(v59 + 168);
                  if (v75) {
                    nw_release(v75);
                  }
                  __int16 v76 = *(_WORD *)(v59 + 204);
                  *(void *)(v59 + 184) = 0LL;
                  *(_OWORD *)(v59 + 168) = 0u;
                  *(_OWORD *)(v59 + 152) = 0u;
                  *(_OWORD *)(v59 + 136) = 0u;
                  *(_OWORD *)(v59 + 120) = 0u;
                  *(_WORD *)(v59 + 204) = v76 & 0x213F;
                  *(_BYTE *)(v59 + 203) = 0;
                  *(_WORD *)(v59 + 198) = 0;
                  *(void *)(v59 + 104) = v23;
                  uint64_t v6 = a5;
                }

                else
                {
                  uint64_t v63 = nw_frame_create();
                  if (!v63)
                  {
                    __nwlog_obj();
                    *(_DWORD *)v188 = 136446210;
                    v189 = "nw_protocol_tcp_get_slab_frame";
                    v115 = (void *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    char v181 = 0;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v116 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v117 = type[0];
                      if (os_log_type_enabled(v116, type[0]))
                      {
                        *(_DWORD *)v188 = 136446210;
                        v189 = "nw_protocol_tcp_get_slab_frame";
                        v118 = "%{public}s nw_frame_create failed";
                        goto LABEL_160;
                      }

                      goto LABEL_162;
                    }

                    if (v181)
                    {
                      backtrace_string = (void *)__nw_create_backtrace_string();
                      v120 = (os_log_s *)__nwlog_obj();
                      BOOL v121 = os_log_type_enabled(v120, type[0]);
                      if (backtrace_string)
                      {
                        if (v121)
                        {
                          *(_DWORD *)v188 = 136446466;
                          v189 = "nw_protocol_tcp_get_slab_frame";
                          __int16 v190 = 2082;
                          *(void *)v191 = backtrace_string;
                          _os_log_impl( &dword_1879E5000,  v120,  type[0],  "%{public}s nw_frame_create failed, dumping backtrace:%{public}s",  v188,  0x16u);
                        }

                        free(backtrace_string);
                        goto LABEL_162;
                      }

                      if (!v121)
                      {
LABEL_162:
                        if (v115) {
                          free(v115);
                        }
                        nw_mem_buffer_free();
                        uint64_t v10 = v171;
                        goto LABEL_165;
                      }

                      *(_DWORD *)v188 = 136446210;
                      v189 = "nw_protocol_tcp_get_slab_frame";
                      v118 = "%{public}s nw_frame_create failed, no backtrace";
                      v122 = v120;
                      os_log_type_t v123 = type[0];
                    }

                    else
                    {
                      v116 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v117 = type[0];
                      if (!os_log_type_enabled(v116, type[0])) {
                        goto LABEL_162;
                      }
                      *(_DWORD *)v188 = 136446210;
                      v189 = "nw_protocol_tcp_get_slab_frame";
                      v118 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
LABEL_160:
                      v122 = v116;
                      os_log_type_t v123 = v117;
                    }

                    _os_log_impl(&dword_1879E5000, v122, v123, v118, v188, 0xCu);
                    goto LABEL_162;
                  }

                  uint64_t v59 = v63;
                  v64 = (*(_WORD *)(v63 + 204) & 4) != 0 ? (_BYTE *)(v63 + 208) : 0LL;
                  *v64 |= 1u;
                  *(void *)(v63 + 104) = v23;
                  *(void *)(v63 + 16) = 0LL;
                  v65 = (uint64_t *)v18[29];
                  *(void *)(v63 + 24) = v65;
                  uint64_t *v65 = v63;
                  v18[29] = v63 + 16;
                }

                int v77 = v49;
                if (v22 == 1)
                {
                  int v78 = v177;
                  int v77 = v49;
                  if (v177) {
                    break;
                  }
                }

LABEL_133:
                if (v6) {
                  ++*v6;
                }
                v54 += v77;
                *(void *)(v59 + 32) = 0LL;
                v55 = v179;
                v56 = (uint64_t *)v179[4];
                *(void *)(v59 + 40) = v56;
                uint64_t *v56 = v59;
                v55[4] = v59 + 32;
                if (!--v22)
                {
                  v112 = v179;
                  v113 = v179 + 3;
                  uint64_t v114 = v179[3];
                  if (v114)
                  {
                    **(void **)(a3 + 8) = v114;
                    *(void *)(v112[3] + 40) = *(void *)(a3 + 8);
                    *(void *)(a3 + 8) = v112[4];
                    v112[3] = 0LL;
                    v112[4] = (uint64_t)v113;
                  }

                  goto LABEL_171;
                }
              }

              if ((*(_WORD *)(v59 + 204) & 0x80) != 0) {
                *(_WORD *)(v59 + 196) -= v177;
              }
              int v79 = *(_DWORD *)(v59 + 52);
              unsigned int v80 = *(_DWORD *)(v59 + 56) + v78;
              int v81 = *(_DWORD *)(v59 + 60);
              if (v80 <= v79 - v81)
              {
                *(_DWORD *)(v59 + 56) = v80;
                uint64_t v6 = a5;
                if (!v79)
                {
LABEL_126:
                  unsigned int v102 = v177;
                  if ((*(_WORD *)(v59 + 204) & 0x80) != 0) {
                    *(_WORD *)(v59 + 196) += v177;
                  }
                  unsigned int v103 = *(_DWORD *)(v59 + 56);
                  BOOL v89 = v103 >= v102;
                  unsigned int v104 = v103 - v102;
                  if (v89)
                  {
                    *(_DWORD *)(v59 + 56) = v104;
                  }

                  else
                  {
                    v105 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                    {
                      int v106 = *(_DWORD *)(v59 + 56);
                      *(_DWORD *)v188 = 136446722;
                      v189 = "__nw_frame_unclaim_internal";
                      __int16 v190 = 1024;
                      *(_DWORD *)v191 = v102;
                      *(_WORD *)&v191[4] = 1024;
                      *(_DWORD *)&v191[6] = v106;
                      _os_log_impl( &dword_1879E5000,  v105,  OS_LOG_TYPE_ERROR,  "%{public}s Frame cannot unclaim %u start bytes (has %u left)",  v188,  0x18u);
                    }
                  }

                  int v77 = v177;
                  goto LABEL_133;
                }
              }

              else
              {
                v82 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                {
                  int v83 = *(_DWORD *)(v59 + 52);
                  *(_DWORD *)v188 = 136446978;
                  v189 = "__nw_frame_claim_internal";
                  __int16 v190 = 1024;
                  *(_DWORD *)v191 = v80;
                  *(_WORD *)&v191[4] = 1024;
                  *(_DWORD *)&v191[6] = v83;
                  LOWORD(v192) = 1024;
                  *(_DWORD *)((char *)&v192 + 2) = v81;
                  _os_log_impl( &dword_1879E5000,  v82,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  v188,  0x1Eu);
                }

                int v79 = *(_DWORD *)(v59 + 52);
                uint64_t v6 = a5;
                if (!v79) {
                  goto LABEL_126;
                }
              }

              uint64_t v85 = *(unsigned int *)(v59 + 56);
              size_t v84 = *(unsigned int *)(v59 + 60);
              uint64_t v86 = (v79 - (v84 + v85));
              if (v79 == (_DWORD)v84 + (_DWORD)v85) {
                goto LABEL_126;
              }
              if ((_DWORD)v84)
              {
                uint64_t v87 = *(void *)(v59 + 112);
                if (v87)
                {
                  memmove((void *)(v87 + v85), (const void *)(v87 + v85 + v86), v84);
                  int v79 = *(_DWORD *)(v59 + 52);
                }
              }

              *(_DWORD *)(v59 + 52) = v79 - v86;
              if ((*(_WORD *)(v59 + 204) & 0x80) == 0) {
                goto LABEL_126;
              }
              unsigned int v88 = *(unsigned __int16 *)(v59 + 196);
              BOOL v89 = v88 >= v86;
              unsigned int v90 = v88 - v86;
              *(_WORD *)(v59 + 196) = v90;
              if (v89 && v90 < 0x10000) {
                goto LABEL_126;
              }
              __nwlog_obj();
              uint64_t v91 = *(unsigned __int16 *)(v59 + 196);
              *(_DWORD *)v188 = 136446978;
              v189 = "__nw_frame_collapse";
              __int16 v190 = 2082;
              *(void *)v191 = "frame->aggregate_buffer_length";
              *(_WORD *)&v191[8] = 2048;
              uint64_t v192 = v86;
              __int16 v193 = 2048;
              uint64_t v194 = v91;
              v92 = (void *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              char v181 = 0;
              if (__nwlog_fault())
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v168 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    uint64_t v93 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v188 = 136446978;
                    v189 = "__nw_frame_collapse";
                    __int16 v190 = 2082;
                    *(void *)v191 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v191[8] = 2048;
                    uint64_t v192 = v86;
                    __int16 v193 = 2048;
                    uint64_t v194 = v93;
                    v94 = v168;
                    os_log_type_t v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_122:
                    _os_log_impl(&dword_1879E5000, v94, v95, v96, v188, 0x2Au);
                  }
                }

                else if (v181)
                {
                  v97 = (void *)__nw_create_backtrace_string();
                  log = (os_log_s *)__nwlog_obj();
                  BOOL v98 = os_log_type_enabled(log, type[0]);
                  if (v97)
                  {
                    if (v98)
                    {
                      uint64_t v99 = *(unsigned __int16 *)(v59 + 196);
                      *(_DWORD *)v188 = 136447234;
                      v189 = "__nw_frame_collapse";
                      __int16 v190 = 2082;
                      *(void *)v191 = "frame->aggregate_buffer_length";
                      *(_WORD *)&v191[8] = 2048;
                      uint64_t v192 = v86;
                      __int16 v193 = 2048;
                      uint64_t v194 = v99;
                      __int16 v195 = 2082;
                      v196 = v97;
                      _os_log_impl( &dword_1879E5000,  log,  type[0],  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  v188,  0x34u);
                    }

                    free(v97);
                    goto LABEL_123;
                  }

                  if (v98)
                  {
                    uint64_t v101 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v188 = 136446978;
                    v189 = "__nw_frame_collapse";
                    __int16 v190 = 2082;
                    *(void *)v191 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v191[8] = 2048;
                    uint64_t v192 = v86;
                    __int16 v193 = 2048;
                    uint64_t v194 = v101;
                    v94 = log;
                    os_log_type_t v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                    goto LABEL_122;
                  }
                }

                else
                {
                  v169 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v169, type[0]))
                  {
                    uint64_t v100 = *(unsigned __int16 *)(v59 + 196);
                    *(_DWORD *)v188 = 136446978;
                    v189 = "__nw_frame_collapse";
                    __int16 v190 = 2082;
                    *(void *)v191 = "frame->aggregate_buffer_length";
                    *(_WORD *)&v191[8] = 2048;
                    uint64_t v192 = v86;
                    __int16 v193 = 2048;
                    uint64_t v194 = v100;
                    v94 = v169;
                    os_log_type_t v95 = type[0];
                    v96 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_122;
                  }
                }
              }

                      unsigned int v69 = *(_DWORD *)(v7 + 4LL * v44 + 16) + v41;
                      if (v69 <= 1) {
                        unsigned int v69 = 1;
                      }
                      *(_DWORD *)(v7 + 68) = v69;
LABEL_136:
                      if (!v43)
                      {
LABEL_156:
                        if (v44 > 7)
                        {
LABEL_37:
                          unsigned int v25 = 0;
                          unsigned int v26 = 0;
                          goto LABEL_55;
                        }

                        unsigned int v26 = *(_DWORD *)(v7 + 4LL * v44 + 16);
                        unsigned int v25 = *(unsigned __int16 *)(v7 + 74);
LABEL_55:
                        if (*(_WORD *)(v7 + 72) == 8)
                        {
                          BOOL v32 = nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224LL));
                          (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224LL)
                                                                             + 8LL)
                                                                 + 32LL))( *(void *)(*(void *)(v7 + 80) + 224LL),  0LL);
                          unsigned int v33 = *(_DWORD *)(v7 + 88);
                          if ((v33 & 0x40000000) != 0)
                          {
                            unsigned int v34 = *(uint64_t **)(v32 + 264);
                            uint64_t v35 = (uint64_t *)(v7 + 48);
                            if (v34) {
                              uint64_t v36 = v34 == v35;
                            }
                            else {
                              uint64_t v36 = 0;
                            }
                            if (v36) {
                              *(void *)(v32 + 264) = *v34;
                            }
                            uint64_t v37 = *v35;
                            if (*v35) {
                              *(void *)(v37 + 8) = *(void *)(v7 + 56);
                            }
                            unsigned int v26 = 0;
                            **(void **)(v7 + 56) = v37;
                            *(_DWORD *)(v7 + 88) = v33 & 0xBFFFFFFF;
                            --*(_DWORD *)(v32 + 280);
                            *uint64_t v35 = 0LL;
                            *(void *)(v7 + 56) = 0LL;
                          }

                          else
                          {
                            unsigned int v26 = 0;
                          }
                        }

                        goto LABEL_67;
                      }

                      uint64_t v87 = v65;
                      v70 = v57;
                      if ((v46 & 1) != 0)
                      {
                        v71 = v52;
                      }

                      else
                      {
                        v71 = v52;
                        *(_DWORD *)(v7 + 16) = 0;
                        v72 = v49;
                        v73 = tcp_timers(v7, 0);
                        int v49 = v72;
                        unsigned int v7 = v73;
                        if (!v73)
                        {
LABEL_158:
                          unsigned int v25 = 0;
                          unsigned int v26 = 0;
LABEL_67:
                          (*(void (**)(uint64_t, uint64_t))(*(void *)(v21 + 8) + 24LL))(v21, 1LL);
                          if (v26)
                          {
                            if (v25)
                            {
                              int v4 = v25 | v4;
                              if (v3 - 1 >= v26) {
                                int v3 = v26;
                              }
                            }
                          }

                          unsigned int v1 = a1;
                          continue;
                        }
                      }

                      if ((v49 & 1) != 0 || (*(_DWORD *)(v7 + 20) = 0, (unsigned int v7 = tcp_timers(v7, 1)) != 0))
                      {
                        if ((v71 & 1) == 0)
                        {
                          *(_DWORD *)(v7 + 24) = 0;
                          nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224LL));
                          if ((*(_DWORD *)(v7 + 740) & 0x20400020) == 0x20000020) {
                            tcp_rack_reordering_timeout(v7);
                          }
                        }

                        if ((v88 & 1) != 0 || (*(_DWORD *)(v7 + 28) = 0, (unsigned int v7 = tcp_timers(v7, 3)) != 0))
                        {
                          if ((v70 & 1) != 0 || (*(_DWORD *)(v7 + 32) = 0, (unsigned int v7 = tcp_timers(v7, 4)) != 0))
                          {
                            if ((v60 & 1) != 0 || (*(_DWORD *)(v7 + 36) = 0, (unsigned int v7 = tcp_timers(v7, 5)) != 0))
                            {
                              if ((v63 & 1) != 0 || (*(_DWORD *)(v7 + 40) = 0, (unsigned int v7 = tcp_timers(v7, 6)) != 0))
                              {
                                if (v87 || (*(_DWORD *)(v7 + 44) = 0, (unsigned int v7 = tcp_timers(v7, 7)) != 0))
                                {
                                  tcp_set_lotimer_index(v7);
                                  __int16 v44 = *(unsigned __int16 *)(v7 + 72);
                                  goto LABEL_156;
                                }
                              }
                            }
                          }
                        }
                      }

                      goto LABEL_158;
                    }

                    ++v43;
                  }

                  *(_DWORD *)(v7 + 64) = v41;
                  *(_WORD *)(v7 + 72) = v44;
                  int v4 = v11;
                  if (v44 == 8) {
                    goto LABEL_136;
                  }
                  if (!v45)
                  {
                    uint64_t v86 = v65;
                    int v83 = v57;
                    size_t v84 = v52;
                    uint64_t v85 = v49;
                    uint64_t v67 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)__int128 buf = 136446210;
                    uint64_t v91 = "tcp_run_conn_timer";
                    int v68 = (void *)_os_log_send_and_compose_impl();
                    if (__nwlog_abort())
                    {
                      __break(1u);
                      return;
                    }

                    free(v68);
                    __int16 v44 = *(unsigned __int16 *)(v7 + 72);
                    if (v44 == 8)
                    {
                      int v4 = v11;
                      v52 = v84;
                      int v49 = v85;
                      uint64_t v57 = v83;
                      v65 = v86;
                      goto LABEL_136;
                    }

                    double v41 = *(_DWORD *)(v7 + 64);
                    int v4 = v11;
                    v52 = v84;
                    int v49 = v85;
                    uint64_t v57 = v83;
                    v65 = v86;
                  }

                  goto LABEL_133;
                }

LABEL_123:
              if (v92) {
                free(v92);
              }
              *(_WORD *)(v59 + 196) = 0;
              goto LABEL_126;
            }

      if (!v7) {
        return;
      }
      int v54 = (void *)v7;
      goto LABEL_125;
    }

    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    numer = type.numer;
    if (!os_log_type_enabled(v8, type.numer)) {
      goto LABEL_123;
    }
LABEL_100:
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    v60 = 2048;
    *(void *)uint64_t v61 = a1;
    uint64_t v10 = "%{public}s %{public}s soclose: usecount is zero so=%p, backtrace limit exceeded";
    goto LABEL_122;
  }

  if (*(void *)a1)
  {
    if ((*(_BYTE *)(a1 + 364) & 4) == 0)
    {
      unsigned int v30 = *(void *)(a1 + 8);
      if (v30)
      {
        int v31 = *(void *)(v30 + 40);
        if (v31)
        {
          BOOL v32 = *(void (**)(uint64_t))(v31 + 32);
          if (v32)
          {
            v32(a1);
            uint64_t v29 = *(_DWORD *)(a1 + 360);
          }
        }
      }
    }
  }

  if (v29 <= 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    v60 = 2048;
    *(void *)uint64_t v61 = a1;
    unsigned int v7 = _os_log_send_and_compose_impl();
    LOBYTE(type.numer) = 16;
    if (LOBYTE(type.numer) == 17)
    {
      unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
      numer = type.numer;
      if (os_log_type_enabled(v8, type.numer)) {
        goto LABEL_82;
      }
      goto LABEL_123;
    }

    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    numer = type.numer;
    if (!os_log_type_enabled(v8, type.numer)) {
      goto LABEL_123;
    }
    goto LABEL_100;
  }

  unsigned int v33 = *(_DWORD *)(a1 + 364);
  if (!*(void *)a1) {
    goto LABEL_76;
  }
  unsigned int v34 = *(_WORD *)(a1 + 376);
  if ((v33 & 0x1000000) != 0)
  {
    *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_90:
    *(_DWORD *)(a1 + 364) = v33 & 0xFEFFFFFF;
    goto LABEL_91;
  }

  if ((v34 & 1) != 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    unsigned int v40 = a1 + 604;
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    double v41 = _os_log_send_and_compose_impl();
    LOBYTE(type.numer) = 16;
    if (LOBYTE(type.numer) == 17)
    {
      double v42 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v43 = type.numer;
      if (os_log_type_enabled(v42, type.numer))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v40;
        __int16 v44 = "%{public}s %{public}s soclose: NOFDREF";
LABEL_129:
        _os_log_impl(&dword_1879E5000, v42, v43, v44, buf, 0x16u);
      }
    }

    else
    {
      double v42 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v43 = type.numer;
      if (os_log_type_enabled(v42, type.numer))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v40;
        __int16 v44 = "%{public}s %{public}s soclose: NOFDREF, backtrace limit exceeded";
        goto LABEL_129;
      }
    }

LABEL_248:
            _Block_object_dispose(&v178, 8);
            uint64_t v110 = a3;
            unsigned int v50 = a2;
            return nw_protocol_tcp_get_malloc_frame(v10, v50, v110, v7, v6);
          }

          unsigned int v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_tcp_access_context";
          v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          char v181 = 0;
          if (__nwlog_fault())
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v144 = (os_log_s *)__nwlog_obj();
              os_log_type_t v145 = type[0];
              if (!os_log_type_enabled(v144, type[0])) {
                goto LABEL_264;
              }
              *(_DWORD *)v188 = 136446210;
              v189 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp";
              goto LABEL_262;
            }

            if (!v181)
            {
              v144 = (os_log_s *)__nwlog_obj();
              os_log_type_t v145 = type[0];
              if (!os_log_type_enabled(v144, type[0])) {
                goto LABEL_264;
              }
              *(_DWORD *)v188 = 136446210;
              v189 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp, backtrace limit exceeded";
              goto LABEL_262;
            }

            v157 = (void *)__nw_create_backtrace_string();
            v154 = (os_log_s *)__nwlog_obj();
            os_log_type_t v155 = type[0];
            BOOL v158 = os_log_type_enabled(v154, type[0]);
            if (v157)
            {
              if (v158)
              {
                *(_DWORD *)v188 = 136446466;
                v189 = "nw_tcp_access_context";
                __int16 v190 = 2082;
                *(void *)v191 = v157;
                _os_log_impl( &dword_1879E5000,  v154,  type[0],  "%{public}s called with null tcp, dumping backtrace:%{public}s",  v188,  0x16u);
              }

              free(v157);
              if (!v143) {
                goto LABEL_266;
              }
              goto LABEL_265;
            }

            if (v158)
            {
              *(_DWORD *)v188 = 136446210;
              v189 = "nw_tcp_access_context";
              v146 = "%{public}s called with null tcp, no backtrace";
              goto LABEL_274;
            }
          }
        }

        else
        {
          unsigned int v142 = a4;
          __nwlog_obj();
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_tcp_access_context";
          v143 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          char v181 = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v144 = (os_log_s *)__nwlog_obj();
            os_log_type_t v145 = type[0];
            if (!os_log_type_enabled(v144, type[0])) {
              goto LABEL_264;
            }
            *(_DWORD *)v188 = 136446210;
            v189 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so";
LABEL_262:
            v163 = v144;
            os_log_type_t v164 = v145;
LABEL_263:
            _os_log_impl(&dword_1879E5000, v163, v164, v146, v188, 0xCu);
            goto LABEL_264;
          }

          if (!v181)
          {
            v144 = (os_log_s *)__nwlog_obj();
            os_log_type_t v145 = type[0];
            if (!os_log_type_enabled(v144, type[0])) {
              goto LABEL_264;
            }
            *(_DWORD *)v188 = 136446210;
            v189 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so, backtrace limit exceeded";
            goto LABEL_262;
          }

          v153 = (void *)__nw_create_backtrace_string();
          v154 = (os_log_s *)__nwlog_obj();
          os_log_type_t v155 = type[0];
          BOOL v156 = os_log_type_enabled(v154, type[0]);
          if (v153)
          {
            if (v156)
            {
              *(_DWORD *)v188 = 136446466;
              v189 = "nw_tcp_access_context";
              __int16 v190 = 2082;
              *(void *)v191 = v153;
              _os_log_impl( &dword_1879E5000,  v154,  type[0],  "%{public}s called with null so, dumping backtrace:%{public}s",  v188,  0x16u);
            }

            free(v153);
          }

          else if (v156)
          {
            *(_DWORD *)v188 = 136446210;
            v189 = "nw_tcp_access_context";
            v146 = "%{public}s called with null so, no backtrace";
LABEL_274:
            v163 = v154;
            os_log_type_t v164 = v155;
            goto LABEL_263;
          }
        }

LABEL_264:
        if (!v143)
        {
LABEL_266:
          uint64_t v6 = a5;
          unsigned int v17 = a2;
          unsigned int v7 = v142;
          goto LABEL_17;
        }

LABEL_265:
        free(v143);
        goto LABEL_266;
      }

      uint64_t v172 = a1;
      unsigned int v135 = 0;
      __nwlog_obj();
      *(_DWORD *)v188 = 136446210;
      v189 = "nw_protocol_tcp_get_slab_frame";
      v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v181 = 0;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v137 = (os_log_s *)__nwlog_obj();
          os_log_type_t v138 = type[0];
          if (!os_log_type_enabled(v137, type[0])) {
            goto LABEL_245;
          }
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0)";
          goto LABEL_243;
        }

        if (!v181)
        {
          v137 = (os_log_s *)__nwlog_obj();
          os_log_type_t v138 = type[0];
          uint64_t v6 = a5;
          if (!os_log_type_enabled(v137, type[0])) {
            goto LABEL_245;
          }
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
          goto LABEL_243;
        }

        v151 = (void *)__nw_create_backtrace_string();
        v148 = (os_log_s *)__nwlog_obj();
        os_log_type_t v149 = type[0];
        BOOL v152 = os_log_type_enabled(v148, type[0]);
        if (v151)
        {
          if (v152)
          {
            *(_DWORD *)v188 = 136446466;
            v189 = "nw_protocol_tcp_get_slab_frame";
            __int16 v190 = 2082;
            *(void *)v191 = v151;
            _os_log_impl( &dword_1879E5000,  v148,  type[0],  "%{public}s called with null (max_frame_count > 0), dumping backtrace:%{public}s",  v188,  0x16u);
          }

          free(v151);
          uint64_t v6 = a5;
          if (!v136) {
            goto LABEL_247;
          }
          goto LABEL_246;
        }

        uint64_t v6 = a5;
        if (v152)
        {
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null (max_frame_count > 0), no backtrace";
          goto LABEL_257;
        }
      }
    }

    else
    {
      uint64_t v172 = a1;
      unsigned int v135 = a4;
      __nwlog_obj();
      *(_DWORD *)v188 = 136446210;
      v189 = "nw_protocol_tcp_get_slab_frame";
      v136 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v181 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v137 = (os_log_s *)__nwlog_obj();
        os_log_type_t v138 = type[0];
        if (!os_log_type_enabled(v137, type[0])) {
          goto LABEL_245;
        }
        *(_DWORD *)v188 = 136446210;
        v189 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array";
LABEL_243:
        v159 = v137;
        os_log_type_t v160 = v138;
LABEL_244:
        _os_log_impl(&dword_1879E5000, v159, v160, v139, v188, 0xCu);
        goto LABEL_245;
      }

      if (!v181)
      {
        v137 = (os_log_s *)__nwlog_obj();
        os_log_type_t v138 = type[0];
        uint64_t v6 = a5;
        if (!os_log_type_enabled(v137, type[0])) {
          goto LABEL_245;
        }
        *(_DWORD *)v188 = 136446210;
        v189 = "nw_protocol_tcp_get_slab_frame";
        v139 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
        goto LABEL_243;
      }

      v147 = (void *)__nw_create_backtrace_string();
      v148 = (os_log_s *)__nwlog_obj();
      os_log_type_t v149 = type[0];
      BOOL v150 = os_log_type_enabled(v148, type[0]);
      if (v147)
      {
        if (v150)
        {
          *(_DWORD *)v188 = 136446466;
          v189 = "nw_protocol_tcp_get_slab_frame";
          __int16 v190 = 2082;
          *(void *)v191 = v147;
          _os_log_impl( &dword_1879E5000,  v148,  type[0],  "%{public}s called with null ret_frame_array, dumping backtrace:%{public}s",  v188,  0x16u);
        }

        free(v147);
        uint64_t v6 = a5;
      }

      else
      {
        uint64_t v6 = a5;
        if (v150)
        {
          *(_DWORD *)v188 = 136446210;
          v189 = "nw_protocol_tcp_get_slab_frame";
          v139 = "%{public}s called with null ret_frame_array, no backtrace";
LABEL_257:
          v159 = v148;
          os_log_type_t v160 = v149;
          goto LABEL_244;
        }
      }
    }

LABEL_245:
    if (!v136)
    {
LABEL_247:
      unsigned int v7 = v135;
      uint64_t v10 = v172;
      goto LABEL_248;
    }

LABEL_246:
    free(v136);
    goto LABEL_247;
  }

  if (!a3)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    double v41 = (void *)_os_log_send_and_compose_impl();
    v188[0] = 16;
    LOBYTE(v178) = 0;
    if (v188[0] == 17)
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v188[0])) {
        goto LABEL_150;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      __int16 v44 = "%{public}s called with null ret_frame_array";
    }

    else
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v188[0])) {
        goto LABEL_150;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      __int16 v44 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    }

    goto LABEL_149;
  }

  if (!a4)
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    double v41 = (void *)_os_log_send_and_compose_impl();
    v188[0] = 16;
    LOBYTE(v178) = 0;
    if (v188[0] == 17)
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v188[0])) {
        goto LABEL_150;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      __int16 v44 = "%{public}s called with null (max_frame_count > 0)";
    }

    else
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v188[0])) {
        goto LABEL_150;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
      __int16 v44 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
    }

    goto LABEL_149;
  }

  unsigned int v11 = (void *)nw_tcp_access_globals(a1);
  uint64_t v12 = v11;
  if (v6) {
    *uint64_t v6 = 0;
  }
  uint64_t v13 = v11[22];
  if (!v13)
  {
    uint64_t external = nw_frame_create_external();
    if (external)
    {
      if ((*(_WORD *)(external + 204) & 4) != 0) {
        uint64_t v27 = (_BYTE *)(external + 208);
      }
      else {
        uint64_t v27 = 0LL;
      }
      *v27 |= 2u;
      *(void *)(external + 16) = 0LL;
      uint64_t v28 = (uint64_t *)v12[25];
      *(void *)(external + 24) = v28;
      *uint64_t v28 = external;
      v12[25] = external + 16;
      *(void *)(external + 32) = 0LL;
      uint64_t v29 = *(uint64_t **)(a3 + 8);
      *(void *)(external + 40) = v29;
      *uint64_t v29 = external;
      *(void *)(a3 + 8) = external + 32;
      uint64_t result = 1LL;
      if (v6) {
        *uint64_t v6 = 1;
      }
      return result;
    }

    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    double v41 = (void *)_os_log_send_and_compose_impl();
    v188[0] = 16;
    LOBYTE(v178) = 0;
    if (v188[0] == 17)
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v188[0]))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        __int16 v44 = "%{public}s nw_frame_create_external failed";
LABEL_149:
        _os_log_impl(&dword_1879E5000, v42, v43, v44, (uint8_t *)&buf, 0xCu);
      }
    }

    else
    {
      double v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v188[0];
      if (os_log_type_enabled(v42, (os_log_type_t)v188[0]))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
        __int16 v44 = "%{public}s nw_frame_create_external failed, backtrace limit exceeded";
        goto LABEL_149;
      }
    }

  if (v94) {
    free(v94);
  }
LABEL_248:
  *(_DWORD *)v112 = nw_tcp_options_get_connection_timeout();
  if (!*(_DWORD *)v112) {
    goto LABEL_259;
  }
  BOOL v98 = tcp_setsockopt(a1, 6, 32, (int *)v112);
  if (!v98) {
    goto LABEL_259;
  }
  uint64_t v99 = v98;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  os_log_type_t v117 = 2082;
  *(void *)v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v99;
  uint64_t v100 = (void *)_os_log_send_and_compose_impl();
  v110[0] = OS_LOG_TYPE_ERROR;
  v111 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v101 = (os_log_s *)__nwlog_obj();
      unsigned int v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0])) {
        goto LABEL_257;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v99;
      unsigned int v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d";
    }

    else
    {
      uint64_t v101 = (os_log_s *)__nwlog_obj();
      unsigned int v102 = v110[0];
      if (!os_log_type_enabled(v101, v110[0])) {
        goto LABEL_257;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v99;
      unsigned int v103 = "%{public}s %{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v101, v102, v103, buf, 0x1Cu);
  }

LABEL_150:
    if (v41) {
      free(v41);
    }
    return 0LL;
  }

  uint64_t v15 = *(void *)(v13 + 16);
  uint64_t v16 = *(void **)(v13 + 24);
  uint64_t v14 = (void *)(v13 + 16);
  if (v15)
  {
    *(void *)(v15 + 24) = v16;
    uint64_t v16 = *(void **)(v13 + 24);
  }

  else
  {
    v11[23] = v16;
  }

  *uint64_t v16 = v15;
  *uint64_t v14 = 0LL;
  *(void *)(v13 + 24) = 0LL;
  unsigned int v30 = (void *)v11[25];
  *(void *)(v13 + 24) = v30;
  *unsigned int v30 = v13;
  v11[25] = v14;
  --v11[2];
  LODWORD(v30) = *(unsigned __int16 *)(v13 + 204);
  int v31 = v30 | (*(unsigned __int8 *)(v13 + 206) << 16);
  if ((v30 & 2) == 0)
  {
    v140 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v140, OS_LOG_TYPE_ERROR);
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_get_external_frame";
    v141 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result)
    {
LABEL_275:
      __break(1u);
      return result;
    }

    free(v141);
    int v31 = *(unsigned __int16 *)(v13 + 204) | (*(unsigned __int8 *)(v13 + 206) << 16);
  }

  BOOL v32 = *(void **)(v13 + 64);
  *(void *)(v13 + 80) = nw_frame_tcp_finalize;
  *(void *)(v13 + 88) = v12;
  *(void *)(v13 + 104) = 0LL;
  *(void *)(v13 + 112) = 0LL;
  *(_WORD *)(v13 + 196) = 0;
  *(_DWORD *)(v13 + 48) = a2;
  *(_DWORD *)(v13 + 52) = a2;
  *(void *)(v13 + 56) = 0LL;
  *(_DWORD *)(v13 + 192) = 0;
  *(_BYTE *)(v13 + 200) = 0;
  unsigned int v33 = v31 & 0xFFFFFFC7;
  *(_WORD *)(v13 + 204) = v33;
  *(_BYTE *)(v13 + 206) = BYTE2(v33);
  if (v32)
  {
    do
    {
      unsigned int v34 = (void *)*v32;
      uint64_t v35 = (void *)v32[6];
      uint64_t v36 = (void *)*v32;
      if (v35)
      {
        nw_release(v35);
        v32[6] = 0LL;
        uint64_t v36 = (void *)*v32;
      }

      uint64_t v37 = (void *)v32[1];
      if (v36)
      {
        v36[1] = v37;
        uint64_t v37 = (void *)v32[1];
      }

      else
      {
        *(void *)(v13 + 72) = v37;
      }

      *uint64_t v37 = v36;
      if (v32 != (void *)(v13 + 120)) {
        free(v32);
      }
      BOOL v32 = v34;
    }

    while (v34);
  }

  *(void *)(v13 + 64) = 0LL;
  *(void *)(v13 + 72) = v13 + 64;
  unsigned int v38 = *(void **)(v13 + 168);
  if (v38) {
    nw_release(v38);
  }
  *(void *)(v13 + 184) = 0LL;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 136) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_WORD *)(v13 + 204) &= 0x213Fu;
  *(_BYTE *)(v13 + 203) = 0;
  *(void *)(v13 + 32) = 0LL;
  *(_WORD *)(v13 + 198) = 0;
  uint32_t v39 = *(void **)(a3 + 8);
  *(void *)(v13 + 40) = v39;
  *uint32_t v39 = v13;
  *(void *)(a3 + 8) = v13 + 32;
  uint64_t result = 1LL;
  if (a5) {
    *a5 = 1;
  }
  return result;
}

uint64_t nw_protocol_tcp_get_frame_count(unsigned int a1, unsigned int a2, int *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t result = (a1 + a2 - 1) / a2;
    if (a3) {
      *a3 = a1 % a2;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v8 = "nw_protocol_tcp_get_frame_count";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v8 = "nw_protocol_tcp_get_frame_count";
        _os_log_impl( &dword_1879E5000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s called with null (buffer_size > 0), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  return result;
}

uint64_t nw_protocol_tcp_get_malloc_frame(uint64_t a1, unsigned int a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
    uint64_t v60 = _os_log_send_and_compose_impl();
    v73 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
    v74 = "%{public}s called with null ret_frame_array, backtrace limit exceeded";
    goto LABEL_102;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
    uint64_t v60 = _os_log_send_and_compose_impl();
    v73 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
    v74 = "%{public}s called with null (max_frame_count > 0), backtrace limit exceeded";
LABEL_102:
    _os_log_impl(&dword_1879E5000, v73, OS_LOG_TYPE_ERROR, v74, buf, 0xCu);
LABEL_103:
    if (!v60) {
      return 0LL;
    }
    v72 = (void *)v60;
    goto LABEL_96;
  }

  unsigned int v8 = (void *)nw_tcp_access_globals(a1);
  uint64_t v9 = v8;
  if (a5) {
    *a5 = 0;
  }
  uint64_t v10 = v8[18];
  if (!v10) {
    goto LABEL_16;
  }
  uint64_t v12 = *(void *)(v10 + 16);
  uint64_t v13 = *(void **)(v10 + 24);
  unsigned int v11 = (void *)(v10 + 16);
  if (v12)
  {
    *(void *)(v12 + 24) = v13;
    uint64_t v13 = *(void **)(v10 + 24);
  }

  else
  {
    v8[19] = v13;
  }

  void *v13 = v12;
  *unsigned int v11 = 0LL;
  *(void *)(v10 + 24) = 0LL;
  uint64_t v14 = (uint64_t *)v8[21];
  *(void *)(v10 + 24) = v14;
  *uint64_t v14 = v10;
  v8[21] = v11;
  uint64_t v15 = v8[1];
  if (v15 <= 0)
  {
    uint64_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
    v62 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result) {
      goto LABEL_105;
    }
    free(v62);
    uint64_t v15 = v9[1];
  }

  if ((v9[1] = v15 - 1, (*(_WORD *)(v10 + 204) & 0x100) != 0)
    && *MEMORY[0x189608EF8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v10, *(void *)(v10 + 88))
    || (uint64_t v16 = *(void **)(v10 + 112)) == 0LL)
  {
LABEL_16:
    uint64_t v18 = malloc(a2);
    if (v18)
    {
      if (v10)
      {
LABEL_19:
        int v19 = *(unsigned __int16 *)(v10 + 204);
        *(void *)(v10 + 80) = nw_frame_tcp_finalize;
        *(void *)(v10 + 88) = v9;
        *(void *)(v10 + 112) = v18;
        *(void *)(v10 + 104) = 0LL;
        *(_WORD *)(v10 + 196) = 0;
        *(_DWORD *)(v10 + 48) = a2;
        *(_DWORD *)(v10 + 52) = a2;
        *(void *)(v10 + 56) = 0LL;
        *(_DWORD *)(v10 + 192) = 0;
        *(_BYTE *)(v10 + 200) = 0;
        unsigned int v20 = v19 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
        *(_WORD *)(v10 + 204) = v19 & 0xFFC7;
        *(_BYTE *)(v10 + 206) = BYTE2(v20);
        char v21 = *(void **)(v10 + 64);
        if (v21)
        {
          do
          {
            unsigned int v22 = (void *)*v21;
            uint64_t v23 = (void *)v21[6];
            int v24 = (void *)*v21;
            if (v23)
            {
              nw_release(v23);
              v21[6] = 0LL;
              int v24 = (void *)*v21;
            }

            unsigned int v25 = (void *)v21[1];
            if (v24)
            {
              v24[1] = v25;
              unsigned int v25 = (void *)v21[1];
            }

            else
            {
              *(void *)(v10 + 72) = v25;
            }

            *unsigned int v25 = v24;
            if (v21 != (void *)(v10 + 120)) {
              free(v21);
            }
            char v21 = v22;
          }

          while (v22);
        }

        *(void *)(v10 + 64) = 0LL;
        *(void *)(v10 + 72) = v10 + 64;
        unsigned int v26 = *(void **)(v10 + 168);
        if (v26) {
          nw_release(v26);
        }
        __int16 v27 = *(_WORD *)(v10 + 204);
        *(void *)(v10 + 184) = 0LL;
        *(_OWORD *)(v10 + 168) = 0u;
        *(_OWORD *)(v10 + 152) = 0u;
        *(_OWORD *)(v10 + 136) = 0u;
        *(_OWORD *)(v10 + 120) = 0u;
        *(_BYTE *)(v10 + 203) = 0;
        *(_WORD *)(v10 + 198) = 0;
        *(_WORD *)(v10 + 204) = v27 & 0x213E | 1;
LABEL_86:
        *(void *)(v10 + 32) = 0LL;
        unsigned int v69 = *(uint64_t **)(a3 + 8);
        *(void *)(v10 + 40) = v69;
        *unsigned int v69 = v10;
        *(void *)(a3 + 8) = v10 + 32;
        uint64_t result = 1LL;
        if (!a5) {
          return result;
        }
        goto LABEL_87;
      }

      goto LABEL_81;
    }

    uint64_t v63 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v76 = "strict_malloc";
    __int16 v77 = 2048;
    *(void *)int v78 = a2;
    v64 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (!(_DWORD)result)
    {
      free(v64);
LABEL_80:
      uint64_t v18 = 0LL;
      if (v10) {
        goto LABEL_19;
      }
LABEL_81:
      uint64_t v65 = nw_frame_create();
      if (v65)
      {
        uint64_t v10 = v65;
        __int16 v66 = *(_WORD *)(v65 + 204);
        if ((v66 & 4) != 0) {
          uint64_t v67 = (_BYTE *)(v65 + 208);
        }
        else {
          uint64_t v67 = 0LL;
        }
        *v67 |= 4u;
        *(_WORD *)(v65 + 204) = v66 | 1;
        *(void *)(v65 + 16) = 0LL;
        int v68 = (uint64_t *)v9[21];
        *(void *)(v65 + 24) = v68;
        *int v68 = v65;
        v9[21] = v65 + 16;
        goto LABEL_86;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
      v70 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v71 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v76 = "nw_protocol_tcp_get_malloc_frame";
          _os_log_impl( &dword_1879E5000,  v71,  OS_LOG_TYPE_ERROR,  "%{public}s nw_frame_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v70) {
        free(v70);
      }
      if (!v18) {
        return 0LL;
      }
      v72 = v18;
LABEL_96:
      free(v72);
      return 0LL;
    }

LABEL_105:
    __break(1u);
    return result;
  }

  unsigned int v17 = *(_DWORD *)(v10 + 48);
  if (v17 < a2)
  {
    free(v16);
    goto LABEL_16;
  }

  int v28 = *(unsigned __int16 *)(v10 + 204);
  *(void *)(v10 + 80) = nw_frame_tcp_finalize;
  *(void *)(v10 + 88) = v9;
  *(void *)(v10 + 112) = v16;
  *(void *)(v10 + 104) = 0LL;
  *(_WORD *)(v10 + 196) = 0;
  *(_DWORD *)(v10 + 48) = v17;
  *(_DWORD *)(v10 + 52) = v17;
  *(void *)(v10 + 56) = 0LL;
  *(_DWORD *)(v10 + 192) = 0;
  *(_BYTE *)(v10 + 200) = 0;
  unsigned int v29 = v28 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v10 + 206) << 16);
  *(_WORD *)(v10 + 204) = v28 & 0xFFC7;
  *(_BYTE *)(v10 + 206) = BYTE2(v29);
  unsigned int v30 = *(void **)(v10 + 64);
  if (v30)
  {
    do
    {
      int v31 = (void *)*v30;
      BOOL v32 = (void *)v30[6];
      unsigned int v33 = (void *)*v30;
      if (v32)
      {
        nw_release(v32);
        v30[6] = 0LL;
        unsigned int v33 = (void *)*v30;
      }

      unsigned int v34 = (void *)v30[1];
      if (v33)
      {
        v33[1] = v34;
        unsigned int v34 = (void *)v30[1];
      }

      else
      {
        *(void *)(v10 + 72) = v34;
      }

      *unsigned int v34 = v33;
      if (v30 != (void *)(v10 + 120)) {
        free(v30);
      }
      unsigned int v30 = v31;
    }

    while (v31);
  }

  *(void *)(v10 + 64) = 0LL;
  *(void *)(v10 + 72) = v10 + 64;
  uint64_t v35 = *(void **)(v10 + 168);
  if (v35) {
    nw_release(v35);
  }
  __int16 v36 = *(_WORD *)(v10 + 204);
  *(void *)(v10 + 184) = 0LL;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_WORD *)(v10 + 204) = v36 & 0x213F;
  *(_BYTE *)(v10 + 203) = 0;
  *(_WORD *)(v10 + 198) = 0;
  int v37 = *(_DWORD *)(v10 + 52);
  unsigned int v38 = *(_DWORD *)(v10 + 56) + a2;
  int v39 = *(_DWORD *)(v10 + 60);
  if (v38 <= v37 - v39)
  {
    *(_DWORD *)(v10 + 56) = v38;
    if (!v37) {
      goto LABEL_64;
    }
    goto LABEL_50;
  }

  unsigned int v40 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    int v41 = *(_DWORD *)(v10 + 52);
    *(_DWORD *)__int128 buf = 136446978;
    __int16 v76 = "__nw_frame_claim_internal";
    __int16 v77 = 1024;
    *(_DWORD *)int v78 = v38;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v41;
    LOWORD(v79) = 1024;
    *(_DWORD *)((char *)&v79 + 2) = v39;
    _os_log_impl( &dword_1879E5000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
  }

  int v37 = *(_DWORD *)(v10 + 52);
  if (v37)
  {
LABEL_50:
    uint64_t v43 = *(unsigned int *)(v10 + 56);
    size_t v42 = *(unsigned int *)(v10 + 60);
    uint64_t v44 = (v37 - (v42 + v43));
    if (v37 != (_DWORD)v42 + (_DWORD)v43)
    {
      if ((_DWORD)v42)
      {
        uint64_t v45 = *(void *)(v10 + 112);
        if (v45)
        {
          memmove((void *)(v45 + v43), (const void *)(v45 + v43 + v44), v42);
          int v37 = *(_DWORD *)(v10 + 52);
        }
      }

      *(_DWORD *)(v10 + 52) = v37 - v44;
      if ((*(_WORD *)(v10 + 204) & 0x80) != 0)
      {
        unsigned int v46 = *(unsigned __int16 *)(v10 + 196);
        BOOL v47 = v46 >= v44;
        unsigned int v48 = v46 - v44;
        *(_WORD *)(v10 + 196) = v48;
        if (!v47 || v48 >= 0x10000)
        {
          __nwlog_obj();
          uint64_t v49 = *(unsigned __int16 *)(v10 + 196);
          *(_DWORD *)__int128 buf = 136446978;
          __int16 v76 = "__nw_frame_collapse";
          __int16 v77 = 2082;
          *(void *)int v78 = "frame->aggregate_buffer_length";
          *(_WORD *)&v78[8] = 2048;
          uint64_t v79 = v44;
          __int16 v80 = 2048;
          uint64_t v81 = v49;
          unsigned int v50 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            v51 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              uint64_t v52 = *(unsigned __int16 *)(v10 + 196);
              *(_DWORD *)__int128 buf = 136446978;
              __int16 v76 = "__nw_frame_collapse";
              __int16 v77 = 2082;
              *(void *)int v78 = "frame->aggregate_buffer_length";
              *(_WORD *)&v78[8] = 2048;
              uint64_t v79 = v44;
              __int16 v80 = 2048;
              uint64_t v81 = v52;
              _os_log_impl( &dword_1879E5000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded",  buf,  0x2Au);
            }
          }

          if (v50) {
            free(v50);
          }
          *(_WORD *)(v10 + 196) = 0;
        }
      }
    }
  }

              *(_DWORD *)(v42 + 156) = v46;
              uint64_t v43 = v46;
              goto LABEL_106;
            }

            if (v43 < 0x201) {
              goto LABEL_106;
            }
            unsigned int v46 = 512;
          }

          *(_WORD *)(v42 + 734) = v43;
          goto LABEL_105;
        }
      }

      else
      {
        BOOL v47 = v18[17];
        if (v47)
        {
          int v39 = v47 / 0x3E;
          *(_DWORD *)(a1 + 208) = v47 / 0x3E;
          goto LABEL_91;
        }
      }

      int v39 = v35 / 0x3E;
      *(_DWORD *)(a1 + 208) = v39;
      goto LABEL_91;
    }
  }

  uint64_t v14 = 152LL;
  if ((v6 & 2) == 0) {
    uint64_t v14 = 148LL;
  }
  uint64_t v15 = *(_DWORD *)(sysctls + v14);
  *(_DWORD *)(a1 + 196) = v15;
  *(_DWORD *)(a1 + 156) = v15;
}

LABEL_64:
  if ((*(_WORD *)(v10 + 204) & 0x80) != 0) {
    *(_WORD *)(v10 + 196) += a2;
  }
  unsigned int v53 = *(_DWORD *)(v10 + 56);
  BOOL v47 = v53 >= a2;
  unsigned int v54 = v53 - a2;
  if (v47)
  {
    *(_DWORD *)(v10 + 56) = v54;
  }

  else
  {
    v55 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      int v56 = *(_DWORD *)(v10 + 56);
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v76 = "__nw_frame_unclaim_internal";
      __int16 v77 = 1024;
      *(_DWORD *)int v78 = a2;
      *(_WORD *)&v78[4] = 1024;
      *(_DWORD *)&v78[6] = v56;
      _os_log_impl( &dword_1879E5000,  v55,  OS_LOG_TYPE_ERROR,  "%{public}s Frame cannot unclaim %u start bytes (has %u left)",  buf,  0x18u);
    }
  }

  __int16 v57 = *(_WORD *)(v10 + 204) | 1;
  *(void *)(v10 + 32) = 0LL;
  *(_WORD *)(v10 + 204) = v57;
  uint64_t v58 = *(uint64_t **)(a3 + 8);
  *(void *)(v10 + 40) = v58;
  *uint64_t v58 = v10;
  *(void *)(a3 + 8) = v10 + 32;
  uint64_t result = 1LL;
  if (a5) {
LABEL_87:
  }
    *a5 = 1;
  return result;
}

  if (v12) {
    free(v12);
  }
  return 0LL;
}

    if (v25) {
      free(v25);
    }
    goto LABEL_66;
  }

  __break(1u);
  return result;
}

    unsigned int v17 = 55LL;
    goto LABEL_66;
  }

  unsigned int v17 = 0LL;
  if ((*(_BYTE *)(*(void *)(v10 + 224) + 366LL) & 2) != 0 && (v72 & 0x10000000) == 0) {
    goto LABEL_64;
  }
LABEL_66:
  unsigned int v33 = *(unsigned __int8 *)(v10 + 2238);
  *(_BYTE *)(v10 + 2238) = v33 - 1;
  if (v33)
  {
    if (!v11) {
      goto LABEL_71;
    }
    goto LABEL_68;
  }

  uint64_t v59 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_ip_output_send";
  uint64_t v60 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v60);
    if (!v11) {
      goto LABEL_71;
    }
LABEL_68:
    unsigned int v34 = *(void *)(v11 + 216);
    if (v34 != *(void *)(v10 + 448) && *(_DWORD *)(a1 + 384))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1864));
      *(void *)(v10 + 448) = v34;
      os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1864));
    }

void nw_frame_tcp_finalize(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) == 0)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446466;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 2048;
      *(void *)v71 = 0LL;
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      free(v6);
    }

    if (!a3)
    {
      unsigned int v7 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446466;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 2048;
      *(void *)v71 = 0LL;
      unsigned int v8 = (void *)_os_log_send_and_compose_impl();
      free(v8);
    }

    unsigned int v9 = *(unsigned __int8 *)(a1 + 208);
    int v10 = v9 & 1;
    if ((~v9 & 6) == 0 || (v9 & 5) == 5 || (v9 & 3) == 3)
    {
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446978;
      unsigned int v69 = "nw_frame_tcp_finalize";
      __int16 v70 = 1024;
      *(_DWORD *)v71 = v9 & 1;
      *(_WORD *)&v71[4] = 1024;
      *(_DWORD *)&v71[6] = (v9 >> 1) & 1;
      __int16 v72 = 1024;
      int v73 = (v9 >> 2) & 1;
      uint64_t v12 = (void *)_os_log_send_and_compose_impl();
      free(v12);
    }

    unsigned int v13 = v9 & 4;
    unsigned int v14 = v9 & 2;
    if (v14)
    {
      if ((*(_WORD *)(a1 + 204) & 2) != 0)
      {
        unsigned int v33 = *(void **)(a1 + 96);
        if (v33)
        {
          nw_release(v33);
          *(void *)(a1 + 96) = 0LL;
        }

        *(_DWORD *)(a1 + 52) = 0;
        *(_DWORD *)(a1 + 56) = 0;
        *(_WORD *)(a1 + 196) = 0;
      }

      else
      {
        uint64_t v23 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v69 = "__nw_frame_set_external_data";
          _os_log_impl( &dword_1879E5000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s Frame does not use external data",  buf,  0xCu);
        }
      }

      unsigned int v34 = a3 + 22;
      uint64_t v35 = a3 + 24;
      __int16 v36 = a3 + 2;
      goto LABEL_61;
    }

    if (!v10)
    {
      if (!v13)
      {
LABEL_56:
        unsigned int v34 = a3 + 18;
        uint64_t v35 = a3 + 20;
        __int16 v36 = a3 + 1;
LABEL_61:
        uint64_t v40 = *(void *)(a1 + 16);
        int v41 = *(void **)(a1 + 24);
        int v39 = (void *)(a1 + 16);
        if (v40)
        {
          *(void *)(v40 + 24) = v41;
          int v41 = *(void **)(a1 + 24);
        }

        else
        {
          v35[1] = v41;
        }

        *int v41 = v40;
        *int v39 = 0LL;
        *(void *)(a1 + 24) = 0LL;
        size_t v42 = (void *)v34[1];
        *(void *)(a1 + 24) = v42;
        *size_t v42 = a1;
        v34[1] = v39;
        uint64_t v43 = *v36;
        if ((*v36 & 0x8000000000000000LL) == 0)
        {
LABEL_65:
          *__int16 v36 = v43 + 1;
          if (v43 >= 100)
          {
            v58[0] = MEMORY[0x1895F87A8];
            v58[1] = 0x40000000LL;
            uint64_t v59 = __nw_frame_tcp_finalize_block_invoke;
            uint64_t v60 = &__block_descriptor_tmp_2;
            uint64_t v61 = v36;
            v62 = v34;
            char v63 = v14 >> 1;
            char v64 = v13 >> 2;
            char v65 = v10;
            uint64_t v44 = *v34;
            do
            {
              if (!v44) {
                break;
              }
              uint64_t v45 = *(void *)(v44 + 16);
              char v46 = ((uint64_t (*)(void *))v59)(v58);
              uint64_t v44 = v45;
            }

            while ((v46 & 1) != 0);
          }

          return;
        }

        v51 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v69 = "nw_frame_tcp_finalize";
        uint64_t v52 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_abort())
        {
          free(v52);
          uint64_t v43 = *v36;
          goto LABEL_65;
        }

LABEL_86:
        __break(1u);
      }

      if ((*(_WORD *)(a1 + 204) & 0x100) == 0
        || !*MEMORY[0x189608EF8]
        || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a1, *(void *)(a1 + 88)))
      {
        uint64_t v15 = *(void **)(a1 + 112);
        if (v15) {
          free(v15);
        }
      }

      int v16 = *(unsigned __int16 *)(a1 + 204);
      *(_WORD *)(a1 + 196) = 0;
      *(_DWORD *)(a1 + 192) = 0;
      *(_BYTE *)(a1 + 200) = 0;
      *(void *)(a1 + 56) = 0LL;
      *(void *)(a1 + 48) = 0LL;
      *(void *)(a1 + 88) = 0LL;
      *(void *)(a1 + 80) = 0LL;
      *(void *)(a1 + 112) = 0LL;
      *(void *)(a1 + 104) = 0LL;
      unsigned int v17 = v16 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
      *(_WORD *)(a1 + 204) = v17;
      *(_BYTE *)(a1 + 206) = BYTE2(v17);
      uint64_t v18 = *(void **)(a1 + 64);
      if (v18)
      {
        do
        {
          int v19 = (void *)*v18;
          unsigned int v20 = (void *)v18[6];
          char v21 = (void *)*v18;
          if (v20)
          {
            nw_release(v20);
            v18[6] = 0LL;
            char v21 = (void *)*v18;
          }

          unsigned int v22 = (void *)v18[1];
          if (v21)
          {
            v21[1] = v22;
            unsigned int v22 = (void *)v18[1];
          }

          else
          {
            *(void *)(a1 + 72) = v22;
          }

          *unsigned int v22 = v21;
          if (v18 != (void *)(a1 + 120)) {
            free(v18);
          }
          uint64_t v18 = v19;
        }

        while (v19);
      }

      *(void *)(a1 + 64) = 0LL;
      *(void *)(a1 + 72) = a1 + 64;
      int v37 = *(void **)(a1 + 168);
      if (!v37) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }

    uint64_t v24 = *(void *)(a1 + 104);
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && !((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a1, *(void *)(a1 + 88)))
    {
      if (!v24) {
        goto LABEL_60;
      }
    }

    else
    {
      uint64_t v25 = *(void *)(a1 + 112);
      if (!v24)
      {
        if (v25)
        {
          int v56 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v69 = "nw_frame_tcp_finalize";
          __int16 v57 = (void *)_os_log_send_and_compose_impl();
          free(v57);
        }

        goto LABEL_60;
      }

      if (v25)
      {
LABEL_39:
        nw_mem_buffer_free();
        int v26 = *(unsigned __int16 *)(a1 + 204);
        *(_WORD *)(a1 + 196) = 0;
        *(_DWORD *)(a1 + 192) = 0;
        *(_BYTE *)(a1 + 200) = 0;
        *(void *)(a1 + 56) = 0LL;
        *(void *)(a1 + 48) = 0LL;
        *(void *)(a1 + 88) = 0LL;
        *(void *)(a1 + 80) = 0LL;
        *(void *)(a1 + 104) = 0LL;
        *(void *)(a1 + 112) = 0LL;
        unsigned int v27 = v26 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
        *(_WORD *)(a1 + 204) = v27;
        *(_BYTE *)(a1 + 206) = BYTE2(v27);
        int v28 = *(void **)(a1 + 64);
        if (v28)
        {
          do
          {
            unsigned int v29 = (void *)*v28;
            unsigned int v30 = (void *)v28[6];
            int v31 = (void *)*v28;
            if (v30)
            {
              nw_release(v30);
              v28[6] = 0LL;
              int v31 = (void *)*v28;
            }

            BOOL v32 = (void *)v28[1];
            if (v31)
            {
              v31[1] = v32;
              BOOL v32 = (void *)v28[1];
            }

            else
            {
              *(void *)(a1 + 72) = v32;
            }

            *BOOL v32 = v31;
            if (v28 != (void *)(a1 + 120)) {
              free(v28);
            }
            int v28 = v29;
          }

          while (v29);
        }

        *(void *)(a1 + 64) = 0LL;
        *(void *)(a1 + 72) = a1 + 64;
        int v37 = *(void **)(a1 + 168);
        if (!v37)
        {
LABEL_55:
          __int16 v38 = *(_WORD *)(a1 + 204);
          *(void *)(a1 + 184) = 0LL;
          *(_OWORD *)(a1 + 168) = 0u;
          *(_OWORD *)(a1 + 152) = 0u;
          *(_OWORD *)(a1 + 136) = 0u;
          *(_OWORD *)(a1 + 120) = 0u;
          *(_WORD *)(a1 + 204) = v38 & 0x213F;
          *(_BYTE *)(a1 + 203) = 0;
          *(_WORD *)(a1 + 198) = 0;
          if (!v10) {
            goto LABEL_56;
          }
LABEL_60:
          unsigned int v34 = a3 + 26;
          uint64_t v35 = a3 + 28;
          __int16 v36 = a3 + 3;
          goto LABEL_61;
        }

LABEL_54:
        nw_release(v37);
        goto LABEL_55;
      }
    }

    int v53 = v10;
    unsigned int v54 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v69 = "nw_frame_tcp_finalize";
    v55 = (void *)_os_log_send_and_compose_impl();
    free(v55);
    int v10 = v53;
    goto LABEL_39;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  unsigned int v69 = "nw_frame_tcp_finalize";
  BOOL v47 = (void *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v66 = 0;
  if (__nwlog_fault())
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v48 = (os_log_s *)__nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v69 = "nw_frame_tcp_finalize";
      unsigned int v50 = "%{public}s called with null frame";
    }

    else
    {
      unsigned int v48 = (os_log_s *)__nwlog_obj();
      os_log_type_t v49 = type;
      if (!os_log_type_enabled(v48, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v69 = "nw_frame_tcp_finalize";
      unsigned int v50 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v48, v49, v50, buf, 0xCu);
  }

  os_log_type_t v49 = v40 - (v38 + *(_DWORD *)(v13 + 60));
  if (v49 <= 19) {
    goto LABEL_55;
  }
  char v64 = ((unint64_t)*(unsigned __int8 *)(v39 + 12) >> 2) & 0x3C;
  char v65 = v64 >= 0x14 && v49 >= v64;
  v846 = ((unint64_t)*(unsigned __int8 *)(v39 + 12) >> 2) & 0x3C;
  if (!v65)
  {
    char v66 = *(void *)(v14 + 1056);
    if (v66)
    {
      ++*(void *)(v66 + 152);
      ++*(void *)(v66 + 360);
    }

    in_pcb_checkstate(a3, 2LL, 1);
    size_t v42 = v890;
    uint64_t v43 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0) {
      goto LABEL_65;
    }
    uint64_t v67 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)) {
      goto LABEL_65;
    }
    int v68 = (const char *)(v15 + 604);
    v900 = "tcp_input";
    *(_DWORD *)__int128 buf = 136446722;
    if (!v15) {
      int v68 = "";
    }
    v901 = 2082;
    *(void *)v902 = v68;
    *(_WORD *)&v902[8] = 1024;
    *(_DWORD *)v903 = v846;
    char v46 = "%{public}s %{public}s offset does not make any sense: %u";
    BOOL v47 = v67;
    unsigned int v48 = OS_LOG_TYPE_ERROR;
    int v53 = 28;
    goto LABEL_64;
  }

  v829 = v64 - 20;
  v824 = v16;
  v835 = v24;
  v828 = v39;
  __memcpy_chk();
  if ((*(_WORD *)(v13 + 204) & 0x100) != 0
    && *v29
    && (((uint64_t (*)(uint64_t, void))*v29)(v13, *(void *)(v13 + 88)) & 1) == 0)
  {
    uint64_t v43 = a1;
    uint64_t v110 = *(void *)(v14 + 1056);
    if (v110) {
      ++*(void *)(v110 + 152);
    }
    in_pcb_checkstate(a3, 2LL, 1);
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      v111 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
      {
        v112 = "";
        if (v15) {
          v112 = (const char *)(v15 + 604);
        }
        *(_DWORD *)__int128 buf = 136446466;
        v900 = "tcp_input";
        v901 = 2082;
        *(void *)v902 = v112;
        _os_log_impl( &dword_1879E5000,  v111,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s buffer no longer valid",  buf,  0x16u);
      }
    }

    unsigned int v54 = 0;
    *(void *)(v14 + 1056) = 0LL;
    size_t v42 = v890;
    goto LABEL_66;
  }

  unsigned int v69 = *a1;
  v837 = v14;
  v826 = a5;
  v827 = a2;
  if (!*a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v900 = "__nw_frame_is_single_ip_aggregate";
    v113 = (void *)_os_log_send_and_compose_impl();
    v897[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (v897[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v114 = (os_log_s *)__nwlog_obj();
      v115 = v897[0];
      if (!os_log_type_enabled(v114, v897[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v900 = "__nw_frame_is_single_ip_aggregate";
      v116 = "%{public}s called with null frame";
    }

    else
    {
      uint64_t v114 = (os_log_s *)__nwlog_obj();
      v115 = v897[0];
      if (!os_log_type_enabled(v114, v897[0])) {
        goto LABEL_225;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v900 = "__nw_frame_is_single_ip_aggregate";
      v116 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v114, v115, v116, buf, 0xCu);
LABEL_225:
    if (v113) {
      free(v113);
    }
    v847 = 0;
    __int16 v72 = 0;
    v71 = 0LL;
LABEL_228:
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        v206 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
        {
          v900 = "tcp_compute_segment_length";
          v901 = 2082;
          v207 = "";
          *(_DWORD *)__int128 buf = 136447234;
          if (v15) {
            v207 = (const char *)(v15 + 604);
          }
          *(void *)v902 = v207;
          *(_WORD *)&v902[8] = 1024;
          *(_DWORD *)v903 = v846;
          *(_WORD *)&v903[4] = 1024;
          *(_DWORD *)&v903[6] = v71;
          v904 = 1024;
          *(_DWORD *)v905 = v72;
          _os_log_impl( &dword_1879E5000,  v206,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers",  buf,  0x28u);
        }
      }
    }

    *(_DWORD *)v897 = v71;
    goto LABEL_232;
  }

  __int16 v70 = *(_WORD *)(v69 + 204);
  if ((*(_WORD *)(v69 + 204) & 0x80) != 0)
  {
    v71 = *(unsigned __int16 *)(v69 + 196);
    *(_DWORD *)v897 = *(unsigned __int16 *)(v69 + 196);
    if ((v70 & 0x40) == 0)
    {
      __int16 v72 = *(unsigned __int8 *)(v69 + 200);
      if (*(_BYTE *)(v69 + 200))
      {
LABEL_183:
        if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
        {
          size_t v42 = v890;
          if (!__nwlog_is_datapath_logging_enabled())
          {
            v847 = 0;
            goto LABEL_233;
          }

          os_log_type_t v117 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
          {
            v900 = "tcp_compute_segment_length";
            v901 = 2082;
            v118 = "";
            *(_DWORD *)__int128 buf = 136447234;
            if (v15) {
              v118 = (const char *)(v15 + 604);
            }
            *(void *)v902 = v118;
            *(_WORD *)&v902[8] = 1024;
            *(_DWORD *)v903 = v846;
            *(_WORD *)&v903[4] = 1024;
            *(_DWORD *)&v903[6] = v71;
            v904 = 1024;
            *(_DWORD *)v905 = v72;
            _os_log_impl( &dword_1879E5000,  v117,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s TCP hlen %d segment length %d on %d buffers",  buf,  0x28u);
          }
        }

        v847 = 0;
LABEL_232:
        size_t v42 = v890;
LABEL_233:
        v119 = 0x18C4CE000uLL;
        if (*(_DWORD *)(sysctls + 288)) {
          v120 = v72;
        }
        else {
          v120 = 1;
        }
        BOOL v121 = v837;
        v122 = *(void *)(v837 + 1056);
        if (v122) {
          *(void *)(v122 + 152) += v120;
        }
        if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
        {
          if ((tcp_validate_cksum(v13, v71, v837) & 1) != 0) {
            goto LABEL_242;
          }
        }

        else
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v173 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
            {
              v174 = (const char *)(v15 + 604);
              if (!v15) {
                v174 = "";
              }
              v175 = *(_DWORD *)(v837 + 12);
              v176 = *(_DWORD *)(v837 + 120);
              unsigned int v177 = *(_DWORD *)(v837 + 92);
              *(_DWORD *)__int128 buf = 136449026;
              v900 = "tcp_input";
              v901 = 2082;
              *(void *)v902 = v174;
              *(_WORD *)&v902[8] = 1024;
              *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
              *(_WORD *)&v903[4] = 1024;
              *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
              v904 = 1024;
              *(_DWORD *)v905 = v71;
              *(_WORD *)&v905[4] = 1024;
              *(_DWORD *)&v905[6] = BYTE13(v920);
              v906 = 1024;
              v907 = bswap32(DWORD1(v920));
              v908 = 1024;
              v909 = bswap32(DWORD2(v920));
              v910 = 1024;
              v911 = bswap32(HIWORD(v920)) >> 16;
              v912 = 1024;
              v913 = v175;
              v914 = 1024;
              v915 = v176;
              v916 = 1024;
              v917 = v177;
              _os_log_impl( &dword_1879E5000,  v173,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s processing an input-frame, %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack= %u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u",  buf,  0x52u);
              LODWORD(v71) = *(_DWORD *)v897;
            }

            size_t v42 = v890;
          }

          if ((validate_tcp_cksum() & 1) != 0)
          {
LABEL_242:
            v843 = v71 - v846;
            *(_DWORD *)v897 = v71 - v846;
            if (v846 < 0x15)
            {
              unsigned int v124 = 0;
              os_log_type_t v123 = 0LL;
              v125 = v835;
            }

            else
            {
              os_log_type_t v123 = (unsigned __int8 *)&v922;
              unsigned int v124 = v829;
              v125 = v835;
              if ((v829 == 12 || v846 >= 0x21 && !v924) && v922 == 168296705 && (BYTE13(v920) & 2) == 0)
              {
                unsigned int v124 = 0;
                os_log_type_t v123 = 0LL;
                LODWORD(v894[0]) |= 1u;
                *(int8x8_t *)((char *)v894 + 4) = vrev32_s8(v923);
              }
            }

            v881 = BYTE13(v920);
            if ((~BYTE13(v920) & 3) == 0) {
              goto LABEL_262;
            }
            uint64_t v129 = v123;
            v830 = v124;
            calculate_tcp_clock(v125);
            if (v827) {
              v838 = *(unsigned __int16 *)(v827 + 1072);
            }
            else {
              v838 = 0;
            }
            v823 = v120;
            if ((BYTE13(v920) & 0x24) != 0)
            {
              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                v208 = (os_log_s *)__nwlog_tcp_log();
                if (os_log_type_enabled(v208, OS_LOG_TYPE_ERROR))
                {
                  v209 = (const char *)(v15 + 604);
                  if (!v15) {
                    v209 = "";
                  }
                  v210 = *(_DWORD *)(v837 + 12);
                  v211 = *(_DWORD *)(v837 + 120);
                  v212 = *(_DWORD *)(v837 + 92);
                  *(_DWORD *)__int128 buf = 136448258;
                  v900 = "tcp_input";
                  v901 = 2082;
                  *(void *)v902 = v209;
                  *(_WORD *)&v902[8] = 1024;
                  *(_DWORD *)v903 = BYTE13(v920);
                  *(_WORD *)&v903[4] = 1024;
                  *(_DWORD *)&v903[6] = bswap32(DWORD1(v920));
                  v904 = 1024;
                  *(_DWORD *)v905 = bswap32(DWORD2(v920));
                  *(_WORD *)&v905[4] = 1024;
                  *(_DWORD *)&v905[6] = bswap32(HIWORD(v920)) >> 16;
                  v906 = 1024;
                  v907 = v210;
                  v908 = 1024;
                  v909 = v211;
                  v910 = 1024;
                  v911 = v212;
                  v213 = v208;
                  v214 = OS_LOG_TYPE_ERROR;
                  goto LABEL_550;
                }
              }
            }

            else if ((BYTE13(v920) & 3) != 0 && (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0))
            {
              v215 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
              {
                v216 = (const char *)(v15 + 604);
                if (!v15) {
                  v216 = "";
                }
                v217 = *(_DWORD *)(v837 + 12);
                v218 = *(_DWORD *)(v837 + 120);
                v219 = *(_DWORD *)(v837 + 92);
                *(_DWORD *)__int128 buf = 136448258;
                v900 = "tcp_input";
                v901 = 2082;
                *(void *)v902 = v216;
                *(_WORD *)&v902[8] = 1024;
                *(_DWORD *)v903 = BYTE13(v920);
                *(_WORD *)&v903[4] = 1024;
                *(_DWORD *)&v903[6] = bswap32(DWORD1(v920));
                v904 = 1024;
                *(_DWORD *)v905 = bswap32(DWORD2(v920));
                *(_WORD *)&v905[4] = 1024;
                *(_DWORD *)&v905[6] = bswap32(HIWORD(v920)) >> 16;
                v906 = 1024;
                v907 = v217;
                v908 = 1024;
                v909 = v218;
                v910 = 1024;
                v911 = v219;
                v213 = v215;
                v214 = OS_LOG_TYPE_DEFAULT;
LABEL_550:
                _os_log_impl( &dword_1879E5000,  v213,  v214,  "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x r cv_nxt=%u, snd_una=%u",  buf,  0x40u);
              }
            }

            tcp_log_packet(v837);
            if ((*(_WORD *)(v13 + 204) & 0x100) != 0
              && *MEMORY[0x189608EF8]
              && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v13, *(void *)(v13 + 88)) & 1) == 0)
            {
              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                v804 = (os_log_s *)__nwlog_tcp_log();
                if (os_log_type_enabled(v804, OS_LOG_TYPE_INFO))
                {
                  v805 = "";
                  if (v15) {
                    v805 = (const char *)(v15 + 604);
                  }
                  *(_DWORD *)__int128 buf = 136446466;
                  v900 = "tcp_input";
                  v901 = 2082;
                  *(void *)v902 = v805;
                  _os_log_impl( &dword_1879E5000,  v804,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping tcp input frame since frame is no longer valid",  buf,  0x16u);
                }
              }

              *(void *)(v837 + 1056) = 0LL;
              in_pcb_checkstate(a3, 2LL, 1);
              uint64_t v43 = a1;
              size_t v42 = v890;
              unsigned int v54 = v847;
              goto LABEL_66;
            }

            *(int8x8_t *)((char *)&v920 + 4) = vrev32_s8(*(int8x8_t *)((char *)&v920 + 4));
            HIWORD(v920) = bswap32(HIWORD(v920)) >> 16;
            v921 = bswap32(v921) >> 16;
            if (&v920 != (__int128 *)v828)
            {
              *(int8x8_t *)(v828 + 4) = vrev32_s8(*(int8x8_t *)(v828 + 4));
              *(_WORD *)(v828 + 14) = bswap32(*(unsigned __int16 *)(v828 + 14)) >> 16;
              *(_WORD *)(v828 + 18) = bswap32(*(unsigned __int16 *)(v828 + 18)) >> 16;
            }

            LODWORD(v130) = v881;
            if ((*(_BYTE *)(a3 + 2229) & 0x40) != 0) {
              v838 = *(unsigned __int16 *)(*(void *)(a3 + 440) + 1072LL);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 + 8) + 16LL))(v15, 1LL, v6);
            if (in_pcb_checkstate(a3, 2LL, 1) == 0xFFFF)
            {
              v131 = 0;
              uint64_t v43 = a1;
LABEL_277:
              size_t v42 = v890;
              goto LABEL_278;
            }

            if ((v894[0] & 1) != 0) {
              DWORD2(v894[0]) -= *(_DWORD *)(v837 + 1888);
            }
            if ((v881 & 0x17) == 0 || !*(_DWORD *)(v837 + 12))
            {
              uint64_t v43 = a1;
              unsigned int v54 = v847;
              size_t v42 = v890;
LABEL_1330:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))(v15, 1LL, v6);
              goto LABEL_66;
            }

            if (*(void *)(v15 + 24))
            {
              all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats) {
                ++*(void *)(all_stats + 16);
              }
              if (*(void *)(v15 + 24))
              {
                os_log_type_t v138 = nw_protocol_tcp_get_all_stats();
                if (v138) {
                  *(void *)(v138 + 24) += v843;
                }
              }
            }

            LODWORD(v896) = DWORD2(v920);
            v139 = HIWORD(v920);
            if ((v881 & 2) == 0) {
              v139 = HIWORD(v920) << *(_BYTE *)(v837 + 260);
            }
            v820 = v139;
            v140 = *(_DWORD *)(v15 + 372);
            if ((v140 & 2) != 0)
            {
              *(_DWORD *)(v15 + 372) = v140 & 0xFFFFFFFD;
              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
              {
                if (__nwlog_is_datapath_logging_enabled())
                {
                  v588 = (os_log_s *)__nwlog_tcp_log();
                  if (os_log_type_enabled(v588, OS_LOG_TYPE_DEBUG))
                  {
                    v589 = "";
                    v900 = "tcp_input";
                    v590 = *(_DWORD *)(v837 + 12);
                    *(_DWORD *)__int128 buf = 136446722;
                    if (v15) {
                      v589 = (const char *)(v15 + 604);
                    }
                    v901 = 2082;
                    *(void *)v902 = v589;
                    *(_WORD *)&v902[8] = 1024;
                    *(_DWORD *)v903 = v590;
                    _os_log_impl( &dword_1879E5000,  v588,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{network:tcp_state}d",  buf,  0x1Cu);
                  }
                }
              }

              if (*(void *)(v15 + 24))
              {
                os_log_type_t v149 = nw_protocol_tcp_get_all_stats();
                if (v149) {
                  *(_DWORD *)(v149 + 136) = 1;
                }
              }

              BOOL v121 = v837;
              tcp_set_max_rwinscale(v837, v15);
              v822 = 1;
              LODWORD(v130) = v881;
            }

            else
            {
              v822 = 0;
            }

            (*(void (**)(uint64_t, void))(*(void *)(v15 + 8) + 32LL))(v15, 0LL);
            BOOL v150 = v846;
            if (*(_DWORD *)(v121 + 12) == 4 && v843 >= 1)
            {
              if ((*(_BYTE *)(v121 + 740) & 2) != 0) {
                *(_WORD *)(v121 + 344) += v823;
              }
              v151 = tcp_stretch_ack_enable(v121, v130);
              BOOL v152 = *(_DWORD *)(v121 + 88);
              if (v151)
              {
                v153 = v152 | 0x80000000;
                *(_DWORD *)(v121 + 740) &= ~2u;
                *(_WORD *)(v121 + 344) = 0;
              }

              else
              {
                v153 = v152 & 0x7FFFFFFF;
              }

              *(_DWORD *)(v121 + 88) = v153;
              v154 = *(_DWORD *)(v835 + 316);
              BOOL v150 = v846;
              if (*(_DWORD *)(v121 + 324) - v154 - 50 < 1)
              {
                *(_DWORD *)(v121 + 324) = v154 + 100;
                *(_DWORD *)(v121 + 328) = v71 + *(_DWORD *)(v121 + 332);
                *(_DWORD *)(v121 + 332) = v71;
              }

              else
              {
                *(int32x2_t *)(v121 + 328) = vadd_s32(*(int32x2_t *)(v121 + 328), vdup_n_s32(v71));
              }
            }

            os_log_type_t v155 = *(_DWORD *)(v121 + 740);
            if ((v155 & 0x10000000) == 0
              && ((v155 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
              && ((v155 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)
              && (~*(_DWORD *)(v121 + 348) & 0x300000) == 0)
            {
              *(_BYTE *)(v121 + 428) &= ~1u;
            }

            if (*(_DWORD *)(v121 + 12) == 4)
            {
              BOOL v156 = *(_DWORD *)(v121 + 92);
              if (DWORD2(v920) != v156)
              {
                v157 = *(void (**)(uint64_t, void))(tcp_cc_algo_list[*(unsigned __int8 *)(v121 + 264)] + 112);
                if (v157)
                {
                  v157(v121, (DWORD2(v920) - v156));
                  BOOL v150 = v846;
                }

                if ((*(_BYTE *)(v121 + 348) & 4) != 0)
                {
                  BOOL v158 = *(_DWORD *)(v121 + 196);
                  v159 = (DWORD2(v920) - *(_DWORD *)(v121 + 92) + (v158 >> 1)) / v158;
                  if (v158 > v159 * v158) {
                    os_log_type_t v160 = 1LL;
                  }
                  else {
                    os_log_type_t v160 = v159;
                  }
                  *(void *)(v121 + 376) += v160;
                }
              }
            }

            v161 = *(_DWORD *)(v121 + 740);
            if ((v161 & 0x10000000) == 0
              && ((v161 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
            {
              if ((v130 & 0x80) != 0)
              {
                v162 = *(_DWORD *)(v121 + 348);
                if ((v162 & 0x300000) != 0x300000) {
                  goto LABEL_362;
                }
              }
            }

            else if ((v130 & 0x80) != 0)
            {
              v162 = *(_DWORD *)(v121 + 348);
LABEL_362:
              *(_DWORD *)(v121 + 348) = v162 & 0xFFFFFFEF;
              ++*(_DWORD *)(v121 + 356);
            }

            if ((SBYTE13(v920) & 0x80u) == 0) {
              v163 = (BYTE13(v920) & 0x40) != 0;
            }
            else {
              v163 = (BYTE13(v920) >> 6) | 2;
            }
            v819 = v163 & 0xFFFFFFFB | (4 * (BYTE12(v920) & 1));
            os_log_type_t v164 = v835;
            if ((v161 & 0x10000000) != 0
              || (v161 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
              || (~*(_DWORD *)(v121 + 348) & 0x300000) != 0
              || *(_DWORD *)(v121 + 12) != 4)
            {
              if (log == 3)
              {
                v166 = *(_DWORD *)(v121 + 12);
                if (v166 != 4) {
                  goto LABEL_416;
                }
                v167 = *(_DWORD *)(v121 + 348);
                if ((~v167 & 3) == 0 && v843 >= 1)
                {
                  v168 = *(_DWORD *)(v121 + 284);
                  if (DWORD1(v920) - v168 >= 0 && DWORD1(v920) - (v168 + *(_DWORD *)(v121 + 128)) < 0)
                  {
                    ++*(_DWORD *)(v121 + 352);
                    v169 = *(void *)(v121 + 1056);
                    if (v169) {
                      ++*(void *)(v169 + 856);
                    }
                    unsigned int v170 = *(void *)(a3 + 448);
                    if (v170)
                    {
                      uint64_t v171 = 568LL;
                      if ((*(_BYTE *)(a3 + 2236) & 2) == 0) {
                        uint64_t v171 = 184LL;
                      }
                      ++*(void *)(v170 + v171);
                    }

                    *(_DWORD *)(v121 + 348) = v167 | 0x50;
                    os_log_type_t v164 = v835;
                    LOBYTE(v130) = v881;
                  }
                }
              }

LABEL_82:
  if (v47) {
    free(v47);
  }
}

uint64_t __nw_protocol_tcp_get_slab_frame_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = *(void *)(a2 + 40);
    uint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    uint64_t v5 = *(void **)(a2 + 40);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 32LL) = v5;
  }

  *uint64_t v5 = v4;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  if (((*(_WORD *)(a2 + 204) & 0x100) == 0
     || !*MEMORY[0x189608EF8]
     || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88)))
    && *(void *)(a2 + 112))
  {
    nw_mem_buffer_free();
  }

  uint64_t v6 = (void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7)
  {
    *(void *)(v7 + 24) = *(void *)(a2 + 24);
    unsigned int v8 = *(void **)(a2 + 24);
  }

  else
  {
    unsigned int v8 = *(void **)(a2 + 24);
    *(void *)(*(void *)(a1 + 48) + 232LL) = v8;
  }

  *unsigned int v8 = v7;
  *uint64_t v6 = 0LL;
  *(void *)(a2 + 24) = 0LL;
  uint64_t v9 = *(void *)(a1 + 48);
  int v10 = *(void **)(v9 + 216);
  *(void *)(a2 + 24) = v10;
  *int v10 = a2;
  *(void *)(v9 + 216) = v6;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(v11 + 24);
  if ((v12 & 0x8000000000000000LL) == 0) {
    goto LABEL_13;
  }
  unsigned int v14 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v15);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(v11 + 24);
LABEL_13:
    *(void *)(v11 + 24) = v12 + 1;
    return 1LL;
  }

  __break(1u);
  return result;
}

uint64_t __nw_frame_tcp_finalize_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v2 = **(void **)(a1 + 32);
  if (v2 < 21) {
    return v2 > 20;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    *(void *)(v4 + 24) = *(void *)(a2 + 24);
    uint64_t v5 = *(void **)(a2 + 24);
  }

  else
  {
    uint64_t v5 = *(void **)(a2 + 24);
    *(void *)(*(void *)(a1 + 40) + 8LL) = v5;
  }

  *uint64_t v5 = v4;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 0LL;
  --**(void **)(a1 + 32);
  if (*(_BYTE *)(a1 + 48))
  {
    if ((*(_WORD *)(a2 + 204) & 2) != 0)
    {
      unsigned int v8 = *(void **)(a2 + 96);
      if (v8)
      {
        nw_release(v8);
        *(void *)(a2 + 96) = 0LL;
      }
    }

    else
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v22 = "__nw_frame_set_external_data";
        _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
      }
    }

    goto LABEL_22;
  }

  if (*(_BYTE *)(a1 + 49))
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && !((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88)))
    {
      goto LABEL_22;
    }

    uint64_t v7 = *(void **)(a2 + 112);
    if (!v7) {
      goto LABEL_22;
    }
    goto LABEL_14;
  }

  if (!*(_BYTE *)(a1 + 50)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x189608EF8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88))
    || !*(void *)(a2 + 112))
  {
    goto LABEL_22;
  }

  int v19 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  unsigned int v22 = "nw_frame_tcp_finalize_block_invoke";
  uint64_t v20 = _os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    uint64_t v7 = (void *)v20;
LABEL_14:
    free(v7);
LABEL_22:
    int v9 = *(unsigned __int16 *)(a2 + 204);
    *(_WORD *)(a2 + 196) = 0;
    *(_DWORD *)(a2 + 192) = 0;
    *(_BYTE *)(a2 + 200) = 0;
    *(void *)(a2 + 56) = 0LL;
    *(void *)(a2 + 48) = 0LL;
    *(void *)(a2 + 88) = 0LL;
    *(void *)(a2 + 80) = 0LL;
    *(void *)(a2 + 112) = 0LL;
    *(void *)(a2 + 104) = 0LL;
    unsigned int v10 = v9 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
    *(_WORD *)(a2 + 204) = v10;
    *(_BYTE *)(a2 + 206) = BYTE2(v10);
    uint64_t v11 = *(void **)(a2 + 64);
    if (v11)
    {
      do
      {
        uint64_t v12 = (void *)*v11;
        unsigned int v13 = (void *)v11[6];
        unsigned int v14 = (void *)*v11;
        if (v13)
        {
          nw_release(v13);
          v11[6] = 0LL;
          unsigned int v14 = (void *)*v11;
        }

        uint64_t v15 = (void *)v11[1];
        if (v14)
        {
          v14[1] = v15;
          uint64_t v15 = (void *)v11[1];
        }

        else
        {
          *(void *)(a2 + 72) = v15;
        }

        *uint64_t v15 = v14;
        if (v11 != (void *)(a2 + 120)) {
          free(v11);
        }
        uint64_t v11 = v12;
      }

      while (v12);
    }

    *(void *)(a2 + 64) = 0LL;
    *(void *)(a2 + 72) = a2 + 64;
    int v16 = *(void **)(a2 + 168);
    if (v16) {
      nw_release(v16);
    }
    *(void *)(a2 + 184) = 0LL;
    *(_OWORD *)(a2 + 168) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    __int16 v17 = *(_WORD *)(a2 + 204);
    *(_OWORD *)(a2 + 120) = 0u;
    *(_WORD *)(a2 + 204) = v17 & 0x213F;
    *(_BYTE *)(a2 + 203) = 0;
    *(_WORD *)(a2 + 198) = 0;
    nw_release((void *)a2);
    return v2 > 20;
  }

  __break(1u);
  return result;
}

BOOL nw_protocol_tcp_copy_frame_to_buffer(uint64_t a1, int a2, int a3, char *__dst)
{
  int v5 = a3;
  uint64_t v6 = a1;
  for (i = *MEMORY[0x1895F89C0]; a2 >= 1 && v6; uint64_t v6 = *(void *)(v6 + 32))
  {
    int v7 = *(_DWORD *)(v6 + 52);
    if (v7)
    {
      int v8 = *(_DWORD *)(v6 + 56);
      int v9 = *(_DWORD *)(v6 + 60);
      int v10 = v7 - (v8 + v9);
      if (a2 < v10) {
        goto LABEL_13;
      }
      int v11 = v8 - v7 + v9;
    }

    else
    {
      int v11 = 0;
    }

    a2 += v11;
  }

  if ((a2 & 0x80000000) == 0)
  {
    if (!v6)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v37 = "__nw_frame_unclaimed_length";
      unsigned int v34 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v35 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v37 = "__nw_frame_unclaimed_length";
          _os_log_impl( &dword_1879E5000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v34) {
        free(v34);
      }
      goto LABEL_14;
    }

    int v10 = *(_DWORD *)(v6 + 52);
    if (v10) {
      v10 -= *(_DWORD *)(v6 + 56) + *(_DWORD *)(v6 + 60);
    }
LABEL_13:
    if (v10 < a2)
    {
LABEL_14:
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      uint64_t v12 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v26 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          unsigned int v27 = "%{public}s invalid source frame, backtrace limit exceeded";
LABEL_63:
          _os_log_impl(&dword_1879E5000, v26, OS_LOG_TYPE_ERROR, v27, buf, 0xCu);
          goto LABEL_64;
        }
      }

      goto LABEL_64;
    }

    if (a3 < 1) {
      return v5 == 0;
    }
    uint64_t v13 = a2;
    else {
      size_t v14 = (v10 - a2);
    }
    if (!(_DWORD)v14)
    {
LABEL_54:
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      BOOL result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
      if (!(_DWORD)result) {
        return result;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      goto LABEL_62;
    }

    if ((*(_WORD *)(v6 + 204) & 2) == 0)
    {
      uint64_t v15 = *(void *)(v6 + 112);
      if (!v15
        || (*(_WORD *)(v6 + 204) & 0x100) != 0
        && *MEMORY[0x189608EF8]
        && (!((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v6, *(void *)(v6 + 88))
         || (uint64_t v15 = *(void *)(v6 + 112)) == 0))
      {
LABEL_60:
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        BOOL result = os_log_type_enabled(v24, OS_LOG_TYPE_INFO);
        if (!(_DWORD)result) {
          return result;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
LABEL_62:
        _os_log_impl(&dword_1879E5000, v24, OS_LOG_TYPE_INFO, "%{public}s source buffer is no longer valid", buf, 0xCu);
        return 0LL;
      }

      memcpy(__dst, (const void *)(v15 + v13 + *(unsigned int *)(v6 + 56)), v14);
LABEL_32:
      v5 -= v14;
      uint64_t v17 = *(void *)(v6 + 32);
      if (v17)
      {
        unsigned int v18 = *(_DWORD *)(v17 + 52);
        if (v18) {
          v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
        }
        if (v5 >= 1)
        {
          int v19 = &__dst[v14];
          uint64_t v20 = (unsigned int (**)(uint64_t, void))MEMORY[0x189608EF8];
          while (1)
          {
            size_t v21 = v18 >= v5 ? v5 : v18;
            if (!(_DWORD)v21) {
              goto LABEL_54;
            }
            if ((*(_WORD *)(v17 + 204) & 2) != 0)
            {
              if (!*(void *)(v17 + 96)) {
                goto LABEL_67;
              }
              uint64_t v23 = nw_dispatch_data_copyout_from_offset();
              if (v23 != v21)
              {
                uint64_t v29 = v23;
                LODWORD(v14) = v21;
                goto LABEL_70;
              }
            }

            else
            {
              uint64_t v22 = *(void *)(v17 + 112);
              if (!v22) {
                goto LABEL_60;
              }
              if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
              {
                if (*v20)
                {
                  if (!(*v20)(v17, *(void *)(v17 + 88))) {
                    goto LABEL_60;
                  }
                  uint64_t v22 = *(void *)(v17 + 112);
                  if (!v22) {
                    goto LABEL_60;
                  }
                }
              }

              memcpy(v19, (const void *)(v22 + *(unsigned int *)(v17 + 56)), v21);
            }

            v5 -= v21;
            uint64_t v17 = *(void *)(v17 + 32);
            if (v17)
            {
              unsigned int v18 = *(_DWORD *)(v17 + 52);
              if (v18) {
                v18 -= *(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60);
              }
              v19 += v21;
              if (v5 > 0) {
                continue;
              }
            }

            return v5 == 0;
          }
        }
      }

      return v5 == 0;
    }

    if (*(void *)(v6 + 96))
    {
      uint64_t v16 = nw_dispatch_data_copyout_from_offset();
      if (v16 == v14) {
        goto LABEL_32;
      }
      uint64_t v29 = v16;
LABEL_70:
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446722;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      __int16 v38 = 2048;
      uint64_t v39 = v29;
      __int16 v40 = 1024;
      int v41 = v14;
      uint64_t v30 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        BOOL v32 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446722;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          __int16 v38 = 2048;
          uint64_t v39 = v29;
          __int16 v40 = 1024;
          int v41 = v14;
          _os_log_impl( &dword_1879E5000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s Copied %zu out of expected %u bytes, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }

      if (!v30) {
        return v5 == 0;
      }
      unsigned int v33 = (void *)v30;
    }

    else
    {
LABEL_67:
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      uint64_t v28 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v31 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
          _os_log_impl( &dword_1879E5000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to extract data from frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (!v28) {
        return v5 == 0;
      }
      unsigned int v33 = (void *)v28;
    }

    free(v33);
    return v5 == 0;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
  uint64_t v12 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    int v26 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v37 = "nw_protocol_tcp_copy_frame_to_buffer";
      unsigned int v27 = "%{public}s source_offset < 0, backtrace limit exceeded";
      goto LABEL_63;
    }
  }

BOOL nw_protocol_tcp_copy_frame_to_frame(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v8 = "__nw_frame_unclaimed_bytes";
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    int v5 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v8 = "__nw_frame_unclaimed_bytes";
      _os_log_impl( &dword_1879E5000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v4) {
    free(v4);
  }
  return nw_protocol_tcp_copy_frame_to_buffer(a1, 0, a2, 0LL);
}

uint64_t nw_protocol_tcp_copy_frame(uint64_t a1, uint64_t a2, signed int a3)
{
  *(void *)&v46[13] = *MEMORY[0x1895F89C0];
  v40[0] = 0LL;
  v40[1] = v40;
  if (a3 <= 0)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v44 = "nw_protocol_tcp_copy_frame";
    __int16 v45 = 1024;
    *(_DWORD *)char v46 = a3;
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)char v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d";
    }

    else if (v41)
    {
      backtrace_string = (void *)__nw_create_backtrace_string();
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v44 = "nw_protocol_tcp_copy_frame";
          __int16 v45 = 1024;
          *(_DWORD *)char v46 = a3;
          v46[2] = 2082;
          *(void *)&v46[3] = backtrace_string;
          _os_log_impl( &dword_1879E5000,  v10,  v11,  "%{public}s called with null invalid len %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(backtrace_string);
        goto LABEL_37;
      }

      if (!v15) {
        goto LABEL_37;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)char v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d, no backtrace";
    }

    else
    {
      int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      __int16 v45 = 1024;
      *(_DWORD *)char v46 = a3;
      uint64_t v12 = "%{public}s called with null invalid len %d, backtrace limit exceeded";
    }

    int v19 = v10;
    os_log_type_t v20 = v11;
    uint32_t v21 = 18;
LABEL_36:
    _os_log_impl(&dword_1879E5000, v19, v20, v12, buf, v21);
    goto LABEL_37;
  }

  if ((nw_protocol_tcp_get_frames(a1, a3, (uint64_t)v40, 1, 0LL, 0) & 1) == 0)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v44 = "nw_protocol_tcp_copy_frame";
      _os_log_impl(&dword_1879E5000, v13, OS_LOG_TYPE_ERROR, "%{public}s failed to get tcp frame array", buf, 0xCu);
    }

    return 0LL;
  }

  uint64_t v5 = v40[0];
  uint64_t v6 = (void *)MEMORY[0x189608EF8];
  if (v40[0])
  {
    uint64_t v7 = *(void *)(v40[0] + 112LL);
    if (v7)
    {
      if ((*(_WORD *)(v40[0] + 204LL) & 0x100) == 0 || !*MEMORY[0x189608EF8]) {
        goto LABEL_9;
      }
      if (((unsigned int (*)(void, void))*MEMORY[0x189608EF8])(v40[0], *(void *)(v40[0] + 88LL)))
      {
        uint64_t v7 = *(void *)(v5 + 112);
LABEL_9:
        int v8 = (char *)(v7 + *(unsigned int *)(v5 + 56));
        goto LABEL_22;
      }
    }

    int v8 = 0LL;
LABEL_22:
    if (!nw_protocol_tcp_copy_frame_to_buffer(a2, 0, a3, v8)) {
      goto LABEL_67;
    }
    goto LABEL_23;
  }

  uint64_t v22 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v44 = "nw_protocol_tcp_copy_frame";
  uint64_t v23 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v23);
    if (!nw_protocol_tcp_copy_frame_to_frame(a2, a3)) {
      goto LABEL_71;
    }
LABEL_23:
    if (a2)
    {
      int v16 = *(unsigned __int16 *)(a2 + 204);
      int v17 = v16 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v16 & 0x100) == 0 || !*v6)
      {
LABEL_28:
        if ((v17 & 0x4000) == 0) {
          return v5;
        }
        unsigned int v18 = v17 & 0xFFFFBFFF;
        *(_WORD *)(a2 + 204) = v18;
        *(_BYTE *)(a2 + 206) = BYTE2(v18);
        if (v5)
        {
          *(_WORD *)(v5 + 204) |= 0x4000u;
          return v5;
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = "__nw_frame_set_is_wake_packet";
        uint64_t v9 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v41 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v31 = (os_log_s *)__nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame";
LABEL_101:
            int v19 = v31;
            os_log_type_t v20 = v32;
            uint32_t v21 = 12;
            goto LABEL_36;
          }

          goto LABEL_37;
        }

        if (!v41)
        {
          int v31 = (os_log_s *)__nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_101;
          }

          goto LABEL_37;
        }

        unsigned int v33 = (void *)__nw_create_backtrace_string();
        int v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v34 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v34)
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_set_is_wake_packet";
            uint64_t v12 = "%{public}s called with null frame, no backtrace";
            goto LABEL_101;
          }

          goto LABEL_37;
        }

        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v44 = "__nw_frame_set_is_wake_packet";
          __int16 v45 = 2082;
          *(void *)char v46 = v33;
          uint64_t v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_87:
          _os_log_impl(&dword_1879E5000, v31, v32, v35, buf, 0x16u);
          goto LABEL_88;
        }

        goto LABEL_88;
      }

      if (((unsigned int (*)(uint64_t, void))*v6)(a2, *(void *)(a2 + 88)))
      {
        int v17 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        goto LABEL_28;
      }

LABEL_66:
      if (v5)
      {
LABEL_67:
        __int16 v36 = *(void (**)(uint64_t, void, uint64_t))(v5 + 80);
        if (v36)
        {
          uint64_t v37 = *(void *)(v5 + 88);
          *(void *)(v5 + 80) = 0LL;
          *(void *)(v5 + 88) = 0LL;
          v36(v5, 0LL, v37);
          return 0LL;
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = "__nw_frame_finalize";
        uint64_t v9 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v41 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v31 = (os_log_s *)__nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer";
            goto LABEL_101;
          }

          goto LABEL_37;
        }

        if (!v41)
        {
          int v31 = (os_log_s *)__nwlog_obj();
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_101;
          }

          goto LABEL_37;
        }

        unsigned int v33 = (void *)__nw_create_backtrace_string();
        int v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v39 = os_log_type_enabled(v31, type);
        if (!v33)
        {
          if (v39)
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v44 = "__nw_frame_finalize";
            uint64_t v12 = "%{public}s called with null frame->finalizer, no backtrace";
            goto LABEL_101;
          }

          goto LABEL_37;
        }

        if (v39)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v44 = "__nw_frame_finalize";
          __int16 v45 = 2082;
          *(void *)char v46 = v33;
          uint64_t v35 = "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s";
          goto LABEL_87;
        }

        goto LABEL_88;
      }

    if (v13)
    {
      uint64_t v37 = (void *)v13;
LABEL_79:
      free(v37);
    }

    return 0LL;
  }

  os_log_type_t v20 = v19;
  *(void *)(v3 + 5216) = nw_path_copy_flow_registration();
  *(void *)(v3 + 5200) = v20;
  uint32_t v21 = nw_protocol_copy_tcp_definition();
  *(void *)(v3 + 5240) = nw_context_get_globals_for_protocol();
  else {
    uint64_t v22 = 0;
  }
  *(_BYTE *)(*(void *)(v3 + 5240) + 328LL) = v22 & 0x80 | *(_BYTE *)(*(void *)(v3 + 5240) + 328LL) & 0x7F;
  if (v21) {
    nw_release(v21);
  }
  *(void *)(v3 + 24) = a1;
  *(void *)(v3 + 40) = v3;
  sa_family = v9->sa_family;
  if (sa_family == 2)
  {
    uint64_t v24 = &inetsw;
  }

  else
  {
    if (sa_family != 30)
    {
      int v26 = 22;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
LABEL_45:
      **(_DWORD **)(StatusReg + 8) = v26;
      uint64_t v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v43 = "nw_protocol_tcp_initialize";
      uint64_t v44 = 2082;
      __int16 v45 = v3 + 604;
      char v46 = 1024;
      LODWORD(v47) = v28;
      uint64_t v29 = _os_log_send_and_compose_impl();
      if (!__nwlog_fault()
        || (unsigned int v33 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)))
      {
LABEL_77:
        if (v29)
        {
          uint64_t v37 = (void *)v29;
          goto LABEL_79;
        }

        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v43 = "nw_protocol_tcp_initialize";
      uint64_t v44 = 2082;
      __int16 v45 = v16;
      char v46 = 1024;
      LODWORD(v47) = v28;
      BOOL v34 = "%{public}s %{public}s setup state failed %{darwin.errno}d, backtrace limit exceeded";
      uint64_t v35 = v33;
      __int16 v36 = 28;
LABEL_76:
      _os_log_impl(&dword_1879E5000, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
      goto LABEL_77;
    }

    uint64_t v24 = &inet6sw;
  }

  *(void *)(v3 + 304) = 0LL;
  *(void *)(v3 + 312) = v3 + 304;
  *(void *)(v3 + 320) = 0LL;
  *(void *)(v3 + 328) = v3 + 320;
  *(void *)(v3 + 400) = 0LL;
  *(void *)(v3 + 408) = v3 + 400;
  *(void *)(v3 + 504) = 0LL;
  *(void *)(v3 + 512) = v3 + 504;
  *(void *)(v3 + 416) = 0LL;
  *(void *)(v3 + 424) = v3 + 416;
  *(void *)(v3 + 444) = 0LL;
  *(void *)(v3 + 520) = 0LL;
  *(void *)(v3 + 528) = v3 + 520;
  *(void *)(v3 + 548) = 0LL;
  *(_DWORD *)(v3 + 360) = 1;
  *(_DWORD *)(v3 + 536) |= 0x1004u;
  *(_DWORD *)(v3 + 432) |= 0x1000u;
  *(_WORD *)(v3 + 376) |= 0x100u;
  *(void *)(v3 + 456) = v3;
  *(void *)(v3 + 560) = v3;
  *(void *)int v3 = v3 + 832;
  *(void *)(v3 + 8) = v24;
  uint64_t v25 = (*(uint64_t (**)(uint64_t))(v24[5] + 8LL))(v3);
  if (v25)
  {
    int v26 = v25;
    *(_WORD *)(v3 + 376) |= 1u;
    --*(_DWORD *)(v3 + 360);
    sofreelastref(v3);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    goto LABEL_45;
  }

  *(void *)(v3 + 32) = &nw_proto_north;
  os_log_type_t v32 = *(void **)v3;
  v32[267] = &nw_proto_south;
  v32[268] = v3;
  v32[269] = v3;
  *(_DWORD *)(v3 + 824) = networkd_settings_get_int64_with_default();
  if ((*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v40 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        char v41 = *(_DWORD *)(v3 + 824);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v43 = "nw_protocol_tcp_initialize";
        uint64_t v44 = 2082;
        __int16 v45 = v3 + 604;
        char v46 = 1024;
        LODWORD(v47) = v41;
        _os_log_impl( &dword_1879E5000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s tcp_input_max_aggregate %u",  buf,  0x1Cu);
      }
    }
  }

  if ((nw_protocol_tcp_apply_parameters(v3) & 1) == 0)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
      return 0LL;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v44 = 2082;
    __int16 v45 = v3 + 604;
    uint64_t v29 = _os_log_send_and_compose_impl();
    BOOL v39 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v44 = 2082;
    __int16 v45 = v16;
    BOOL v34 = "%{public}s %{public}s apply socket parameters failed, backtrace limit exceeded";
    goto LABEL_75;
  }

  if ((*(unsigned int (**)(uint64_t, const sockaddr *))(*(void *)(*(void *)(v3 + 8) + 40LL) + 16LL))( v3,  v9))
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
      return 0LL;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v44 = 2082;
    __int16 v45 = v3 + 604;
    uint64_t v29 = _os_log_send_and_compose_impl();
    BOOL v39 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_tcp_initialize";
    uint64_t v44 = 2082;
    __int16 v45 = v16;
    BOOL v34 = "%{public}s %{public}s tcp_bind failed, backtrace limit exceeded";
LABEL_75:
    uint64_t v35 = v39;
    __int16 v36 = 22;
    goto LABEL_76;
  }

  if ((*(_BYTE *)(v3 + 372) & 2) == 0 || (uint64_t result = nw_protocol_tcp_initialize_inbound(v3, v7)))
  {
    uint64_t result = 1LL;
    *(_DWORD *)(v3 + 5224) = 1;
    *(_DWORD *)(v3 + 5308) |= 0x40000u;
  }

  return result;
}

LABEL_71:
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v44 = "__nw_frame_finalize";
      uint64_t v9 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v41 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame";
          goto LABEL_101;
        }

    if (*(_WORD *)(a2 + 226)) {
      return v17;
    }
    uint64_t v35 = *(void *)(a2 + 80);
    __int16 v36 = *(void *)(v35 + 496);
    if (!v36) {
      return v17;
    }
    uint64_t v37 = *(void *)(v36 + 1488);
    if (!v37) {
      goto LABEL_120;
    }
    BOOL v38 = *(_DWORD *)(v37 + 64);
    if (!v38 || *(_DWORD *)(a2 + 1872) == 1) {
      goto LABEL_120;
    }
    *(_DWORD *)(a2 + 228) = 30;
    BOOL v39 = v38 / 0x1F;
    *(_DWORD *)(a2 + 200) = v38 / 0x1F;
    __int16 v40 = *(void *)(a2 + 1056);
    if (v40)
    {
      ++*(void *)(v40 + 1280);
      char v41 = *(_DWORD *)(v37 + 68);
      if (v41)
      {
        size_t v42 = v41 / 0x3E;
        *(_DWORD *)(a2 + 208) = v41 / 0x3E;
        ++*(void *)(v40 + 1288);
LABEL_116:
        unsigned int v54 = (v42 + (v39 >> 3)) >> 2;
        if (v54 <= 30) {
          unsigned int v54 = 30;
        }
        *(_DWORD *)(a2 + 192) = v54;
LABEL_120:
        *(_DWORD *)(a2 + 28) = *(_DWORD *)(a2 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(v35 + 224)) + 316)
                             - *(_DWORD *)(a2 + 64);
        return v17;
      }
    }

    else
    {
      int v53 = *(_DWORD *)(v37 + 68);
      if (v53)
      {
        size_t v42 = v53 / 0x3E;
        *(_DWORD *)(a2 + 208) = v53 / 0x3E;
        goto LABEL_116;
      }
    }

    size_t v42 = v38 / 0x3E;
    *(_DWORD *)(a2 + 208) = v42;
    goto LABEL_116;
  }

  __break(1u);
  return result;
}

LABEL_37:
        if (v9) {
          free(v9);
        }
        return 0LL;
      }

      if (!v41)
      {
        int v31 = (os_log_s *)__nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_101;
        }

        goto LABEL_37;
      }

      unsigned int v33 = (void *)__nw_create_backtrace_string();
      int v31 = (os_log_s *)__nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v38 = os_log_type_enabled(v31, type);
      if (!v33)
      {
        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v44 = "__nw_frame_finalize";
          uint64_t v12 = "%{public}s called with null frame, no backtrace";
          goto LABEL_101;
        }

        goto LABEL_37;
      }

      if (v38)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v44 = "__nw_frame_finalize";
        __int16 v45 = 2082;
        *(void *)char v46 = v33;
        uint64_t v35 = "%{public}s called with null frame, dumping backtrace:%{public}s";
        goto LABEL_87;
      }

  os_log_type_t v20 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  if (!v20 || (*(_BYTE *)(v20 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v25 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        int v26 = (const char *)(v20 + 604);
        BOOL v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
        *(_DWORD *)__int128 buf = 136446722;
        if (!v20) {
          int v26 = "";
        }
        int v31 = 2082;
        os_log_type_t v32 = v26;
        unsigned int v33 = 1024;
        BOOL v34 = v5;
        _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s dropping frame of length %u",  buf,  0x1Cu);
      }
    }
  }

  if (a2)
  {
    uint32_t v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 80);
    if (v21)
    {
      uint64_t v22 = *(void *)(a2 + 88);
      *(void *)(a2 + 80) = 0LL;
      *(void *)(a2 + 88) = 0LL;
      v21(a2, 1LL, v22);
      return 1LL;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "__nw_frame_finalize";
    uint64_t v24 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t v27 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "__nw_frame_finalize";
    uint64_t v28 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_56;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v30 = "__nw_frame_finalize";
  uint64_t v24 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    os_log_type_t v27 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v30 = "__nw_frame_finalize";
      uint64_t v28 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_56:
      _os_log_impl(&dword_1879E5000, v27, OS_LOG_TYPE_ERROR, v28, buf, 0xCu);
    }
  }

        v29 -= 2;
      }

      while (v29 >= v72);
    }

    return;
  }

  if (*(void *)(a1 + 544))
  {
    __int16 v45 = *(_DWORD *)(a1 + 560);
  }

  else
  {
    if (*(_DWORD *)(a1 + 92) - a3 <= 0) {
      __int16 v45 = a3;
    }
    else {
      __int16 v45 = *(_DWORD *)(a1 + 92);
    }
    *(_DWORD *)(a1 + 560) = v45;
  }

  char v46 = v11 - 1LL;
  BOOL v47 = &v72[2 * v46];
  if (v45 - *v47 < 0)
  {
    if (tcp_sackhole_insert(a1, v45, *v47, 0LL))
    {
      os_log_type_t v49 = v72[2 * v46 + 1];
      *(_DWORD *)(a1 + 560) = v49;
      unsigned int v50 = *v47;
      v47 -= 2;
      *a4 += v49 - v50;
    }

    else if (v11 >= 1)
    {
      char v66 = *(_DWORD *)(a1 + 560);
      while (v66 - *v47 < 0)
      {
        v47 -= 2;
        if (v47 < v72) {
          goto LABEL_81;
        }
      }

      uint64_t v67 = v47[1];
      if (v66 - v67 < 0)
      {
        *a4 += v67 - v66;
        *(_DWORD *)(a1 + 560) = v67;
      }
    }
  }

  else
  {
    unsigned int v48 = v47[1];
    if (v45 - v48 < 0)
    {
      *a4 += v48 - v45;
      *(_DWORD *)(a1 + 560) = v48;
    }
  }

LABEL_88:
      free(v33);
      goto LABEL_37;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v44 = "__nw_frame_check_validity";
    uint64_t v25 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault())
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_64;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        uint64_t v28 = "%{public}s called with null frame";
        goto LABEL_63;
      }

      if (!v41)
      {
        int v26 = (os_log_s *)__nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_64;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        uint64_t v28 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_63;
      }

      uint64_t v29 = (void *)__nw_create_backtrace_string();
      int v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v30 = os_log_type_enabled(v26, type);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v44 = "__nw_frame_check_validity";
          __int16 v45 = 2082;
          *(void *)char v46 = v29;
          _os_log_impl( &dword_1879E5000,  v26,  v27,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v29);
        goto LABEL_64;
      }

      if (v30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v44 = "__nw_frame_check_validity";
        uint64_t v28 = "%{public}s called with null frame, no backtrace";
LABEL_63:
        _os_log_impl(&dword_1879E5000, v26, v27, v28, buf, 0xCu);
      }
    }

uint64_t tcp_newreno_init()
{
  do
    unsigned int v0 = __ldaxr(dword_18C6E9108);
  while (__stlxr(v0 + 1, dword_18C6E9108));
  return 0LL;
}

uint64_t tcp_newreno_cleanup()
{
  do
    unsigned int v0 = __ldaxr(dword_18C6E9108);
  while (__stlxr(v0 - 1, dword_18C6E9108));
  return 0LL;
}

uint64_t tcp_newreno_cwnd_init_or_reset(uint64_t result)
{
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v1 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v1 = 10;
    }
    *(_DWORD *)(result + 144) = *(_DWORD *)(result + 196) * v1;
  }

  else
  {
    uint64_t v2 = *(unsigned int *)(result + 196);
    LODWORD(v3) = 2 * v2;
    else {
      unint64_t v3 = v3;
    }
    if (v3 <= 4 * v2) {
      int v4 = v3;
    }
    else {
      int v4 = 4 * v2;
    }
    *(_DWORD *)(result + 144) = v4;
  }

  return result;
}

_DWORD *tcp_newreno_congestion_avd(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = result[36];
  if (v2 < result[35])
  {
    unsigned int v3 = result[72] + *(_DWORD *)(a2 + 8) - result[23];
    result[72] = v3;
    BOOL v4 = v3 >= v2;
    unsigned int v5 = v3 - v2;
    if (v5 != 0 && v4)
    {
      result[72] = v5;
      result[36] = result[49] + v2;
    }
  }

  return result;
}

uint64_t tcp_newreno_ack_rcvd(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 196);
  unsigned int v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
  uint64_t v4 = *(unsigned int *)(result + 144);
  if (v4 >= *(_DWORD *)(result + 148))
  {
    unsigned int v5 = *(_DWORD *)(result + 288) + v3;
    *(_DWORD *)(result + 288) = v5;
    else {
      unsigned int v2 = 0;
    }
  }

  else
  {
    v2 <<= *(_DWORD *)(result + 100) == *(_DWORD *)(result + 96);
    if (v3 < v2) {
      unsigned int v2 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(result + 92);
    }
  }

  uint64_t v6 = v4 + v2;
  char v7 = *(_BYTE *)(result + 260);
  int v8 = v2 + v4;
  if (v6 >= 0xFFFFLL << v7) {
    int v8 = 0xFFFF << v7;
  }
  *(_DWORD *)(result + 144) = v8;
  return result;
}

uint64_t tcp_newreno_pre_fr(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 140);
  if (v1 >= *(_DWORD *)(result + 144)) {
    unsigned int v1 = *(_DWORD *)(result + 144);
  }
  unsigned int v2 = *(_DWORD *)(result + 196);
  unsigned int v3 = (v1 >> 1) / v2;
  if (v3 <= 2) {
    unsigned int v3 = 2;
  }
  unsigned int v4 = v3 * v2;
  *(_DWORD *)(result + 148) = v4;
  unsigned int v5 = *(_DWORD **)(*(void *)(result + 80) + 224LL);
  if (v5[97] > v4)
  {
    int v6 = v5[108];
    if ((v6 & 0x400) != 0)
    {
      if (v5[109] > v4)
      {
        if (v4 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v4 = *(_DWORD *)(sysctls + 120);
        }
        v5[109] = v4;
      }

      v5[108] = v6 | 0x800;
    }
  }

  return result;
}

_DWORD *tcp_newreno_post_fr(_DWORD *result, uint64_t a2)
{
  unsigned int v2 = result + 23;
  if (a2) {
    unsigned int v2 = (_DWORD *)(a2 + 8);
  }
  int v3 = result[24] - *v2;
  int v4 = result[37];
  if (v3 < v4)
  {
    uint64_t v5 = result[49];
    if (v3 <= v5) {
      int v3 = result[49];
    }
    int v4 = v3 + v5;
  }

  result[36] = v4;
  result[72] = 0;
  return result;
}

uint64_t tcp_newreno_after_timeout(uint64_t result)
{
  if (*(int *)(result + 12) >= 4)
  {
    unsigned int v1 = *(_DWORD *)(result + 140);
    if (v1 >= *(_DWORD *)(result + 144)) {
      unsigned int v1 = *(_DWORD *)(result + 144);
    }
    unsigned int v2 = *(_DWORD *)(result + 196);
    unsigned int v3 = (v1 >> 1) / v2;
    if (v3 <= 2) {
      unsigned int v3 = 2;
    }
    unsigned int v4 = v3 * v2;
    *(_DWORD *)(result + 144) = v2;
    *(_DWORD *)(result + 148) = v3 * v2;
    uint64_t v5 = *(_DWORD **)(*(void *)(result + 80) + 224LL);
    if (v5[97] > v4)
    {
      int v6 = v5[108];
      if ((v6 & 0x400) != 0)
      {
        if (v5[109] > v4)
        {
          if (v4 >= *(_DWORD *)(sysctls + 120)) {
            unsigned int v4 = *(_DWORD *)(sysctls + 120);
          }
          v5[109] = v4;
        }

        v5[108] = v6 | 0x800;
      }
    }
  }

  return result;
}

_DWORD *tcp_newreno_switch_cc(_DWORD *result)
{
  unsigned int v1 = result[36];
  if (result[35] >= v1) {
    unsigned int v2 = result[36];
  }
  else {
    unsigned int v2 = result[35];
  }
  if (v1 < result[37]) {
    v2 >>= 1;
  }
  unsigned int v3 = result[49];
  unsigned int v4 = v2 / v3;
  if (*(_DWORD *)(sysctls + 304))
  {
    unint64_t v5 = v3 * *(_DWORD *)(sysctls + 16);
    goto LABEL_14;
  }

  if (*(_DWORD *)(sysctls + 276))
  {
    unint64_t v5 = 10 * v3;
    goto LABEL_14;
  }

  if ((v3 * (unint64_t)v4) >> 2 >= 0x447)
  {
LABEL_14:
    LODWORD(v5) = v3 * v4;
    goto LABEL_15;
  }

  LODWORD(v5) = 4380;
LABEL_15:
  result[36] = v5;
  result[72] = 0;
  do
    unsigned int v6 = __ldaxr(dword_18C6E9108);
  while (__stlxr(v6 + 1, dword_18C6E9108));
  return result;
}

double tcp_rledbat_init(uint64_t a1)
{
  do
    unsigned int v1 = __ldaxr((unsigned int *)&unk_18C4CE810);
  while (__stlxr(v1 + 1, (unsigned int *)&unk_18C4CE810));
  *(_DWORD *)(a1 + 1932) = 0;
  *(void *)(a1 + 1924) = 0LL;
  *(void *)(a1 + 1940) = 0LL;
  *(_DWORD *)(a1 + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(a1 + 196);
  *(void *)&double result = 1073725440LL;
  *(void *)(a1 + 1952) = 1073725440LL;
  return result;
}

void tcp_rledbat_cleanup()
{
  do
    unsigned int v0 = __ldaxr((unsigned int *)&unk_18C4CE810);
  while (__stlxr(v0 - 1, (unsigned int *)&unk_18C4CE810));
}

_DWORD *tcp_rledbat_rwnd_init(_DWORD *result)
{
  result[487] = *(_DWORD *)(sysctls + 16) * result[49];
  if (!result[488]) {
    result[488] = 1073725440;
  }
  return result;
}

uint64_t tcp_rledbat_data_rcvd(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = *(void *)(v8 + 496);
  if (v9 && (uint64_t v10 = *(void *)(v9 + 1488)) != 0) {
    unsigned int v11 = *(_DWORD *)(v10 + 40);
  }
  else {
    unsigned int v11 = 0;
  }
  uint64_t v12 = 1908LL;
  if (!*(_DWORD *)(sysctls + 312)) {
    uint64_t v12 = 236LL;
  }
  unsigned int v13 = *(_DWORD *)(a1 + v12);
  int v14 = *(_DWORD *)(a1 + 1968) >> 5;
  int v15 = 3 * *(_DWORD *)(sysctls + 4);
  if (v15 >= 0) {
    int v16 = 3 * *(_DWORD *)(sysctls + 4);
  }
  else {
    int v16 = v15 + 3;
  }
  *(_DWORD *)(a1 + 1956) += a4;
  uint64_t result = nw_tcp_access_globals(*(void *)(v8 + 224));
  unsigned int v18 = *(_DWORD *)(a1 + 1928);
  if (v18)
  {
    unsigned int v19 = *(_DWORD *)(result + 316);
    if (v19 >= v18)
    {
      if (!*(_DWORD *)(a1 + 1932))
      {
        *(_DWORD *)(a1 + 1932) = v19;
        ++*(_DWORD *)(a1 + 1924);
      }

      if (v19 < v18 + 2 * v14)
      {
        unsigned int v20 = *(_DWORD *)(a1 + 1948);
        unsigned int v21 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
        if (v20 > v21)
        {
          if (*(_DWORD *)(a1 + 1952) < v20) {
            *(_DWORD *)(a1 + 1952) = v20;
          }
          *(_DWORD *)(a1 + 1948) = v21;
          *(_DWORD *)(a1 + 1940) = 0;
        }

        return result;
      }
    }
  }

  if ((int)(*(_DWORD *)(a2 + 4) + a4 - *(_DWORD *)(a1 + 1916)) < 0 && *(_DWORD *)(a3 + 4) - *(_DWORD *)(a1 + 1920) >= 0)
  {
    unsigned int v35 = *(_DWORD *)(result + 316);
    if (v35 >= *(_DWORD *)(a1 + 1936))
    {
      unsigned int v36 = *(_DWORD *)(a1 + 196);
      unsigned int v37 = ((v36 >> 1) + (*(_DWORD *)(a1 + 1948) >> 1)) / v36 * v36;
      unsigned int v38 = 2 * v36;
      if (v37 <= v38) {
        unsigned int v37 = v38;
      }
      *(_DWORD *)(a1 + 1952) = v37;
      *(_DWORD *)(a1 + 1948) = v37;
      *(void *)(a1 + 1940) = 0LL;
      *(_DWORD *)(a1 + 1936) = v35 + 2 * v14;
      if (v18)
      {
        unsigned int v39 = v35 + 60000;
LABEL_66:
        *(_DWORD *)(a1 + 1928) = v39;
        return result;
      }
    }

    return result;
  }

  if (v13) {
    BOOL v22 = v11 == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22)
  {
    unsigned int v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v23 >= a4) {
      unsigned int v23 = a4;
    }
    uint64_t v24 = v23 + *(_DWORD *)(a1 + 1948);
LABEL_28:
    char v25 = *(_BYTE *)(a1 + 261);
    uint64_t v26 = 0xFFFFLL << v25;
    int v27 = 0xFFFF << v25;
    if (v26 <= v24) {
      LODWORD(v24) = v27;
    }
    *(_DWORD *)(a1 + 1948) = v24;
    return result;
  }

  unsigned int v28 = *(_DWORD *)(a1 + 1948);
  unsigned int v29 = *(_DWORD *)(a1 + 1952);
  if (v28 < v29)
  {
    int v30 = v16 >> 2;
    if (*(_DWORD *)(a1 + 1924))
    {
      int v31 = *(_DWORD *)(sysctls + 4);
      int v32 = 2 * v31;
      unsigned int v33 = v30 + v11;
      if (v13 <= 2 * v31 + v11 || v13 <= v33) {
        goto LABEL_72;
      }
    }

    else if (v13 <= v30 + v11)
    {
      int v31 = *(_DWORD *)(sysctls + 4);
      int v32 = 2 * v31;
LABEL_72:
      unsigned int v56 = *(_DWORD *)(a1 + 1940) + a4;
      *(_DWORD *)(a1 + 1940) = v56;
      double v57 = (double)v32 / (double)v11;
      double v58 = trunc(v57);
      if (v57 <= v58) {
        double v59 = 0.0;
      }
      else {
        double v59 = 1.0;
      }
      if ((v59 + v58) <= 0x10)
      {
        double v61 = (double)(2 * v31) / (double)v11;
        double v62 = trunc(v61);
        if (v61 <= v62) {
          double v63 = 0.0;
        }
        else {
          double v63 = 1.0;
        }
        unsigned int v60 = (v63 + v62);
      }

      else
      {
        unsigned int v60 = 16;
      }

      unsigned int v64 = *(_DWORD *)(a1 + 196);
      if (v56 >= v64 * v60)
      {
        unsigned int v65 = v56 / v60;
        if (v65 >= 10 * v64) {
          unsigned int v65 = 10 * v64;
        }
        *(_DWORD *)(a1 + 1940) = 0;
        uint64_t v66 = (v28 + v65 + (v64 >> 1)) / v64 * v64;
        char v67 = *(_BYTE *)(a1 + 261);
        uint64_t v68 = 0xFFFFLL << v67;
        int v69 = 0xFFFF << v67;
        if (v68 <= v66) {
          LODWORD(v66) = v69;
        }
        *(_DWORD *)(a1 + 1948) = v66;
      }

      if (v18) {
        *(_DWORD *)(a1 + 1928) = 0;
      }
      return result;
    }
  }

  unsigned int v40 = *(_DWORD *)(result + 316);
  if (!v18)
  {
    int v41 = v28 >= v29 ? 60000 : 120000;
    int v42 = *(_DWORD *)(a1 + 1924) ? v41 : 60000;
    unsigned int v18 = v42 + v40;
    *(void *)(a1 + 1928) = v18;
    if (v28 < v29)
    {
      *(_DWORD *)(a1 + 1952) = v28;
      unsigned int v29 = v28;
    }
  }

  uint64_t v43 = sysctls;
  int v44 = *(_DWORD *)(sysctls + 4);
  if (v44 + v11 >= v13)
  {
    unsigned int v53 = *(_DWORD *)(a1 + 1940) + a4;
    *(_DWORD *)(a1 + 1940) = v53;
    unsigned int v54 = v53 - v28;
    if (v53 < v28) {
      return result;
    }
    unsigned int v55 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a1 + 1940) = v54;
    if (v29 < v28) {
      *(_DWORD *)(a1 + 1952) = v28;
    }
    uint64_t v24 = (v55 + v28 + (v55 >> 1)) / v55 * v55;
    goto LABEL_28;
  }

  if (*(_DWORD *)(a1 + 1936) <= v40)
  {
    unsigned int v45 = *(_DWORD *)(a1 + 1944) + a4;
    *(_DWORD *)(a1 + 1944) = v45;
    BOOL v46 = v45 >= v28;
    unsigned int v47 = v45 - v28;
    if (v46)
    {
      unsigned int v48 = v13 - v11;
      if (v13 < v11) {
        unsigned int v48 = 0;
      }
      *(_DWORD *)(a1 + 1944) = v47;
      unsigned int v49 = v28 - (fmin((double)v48 / (double)v44 + -1.0, 0.5) * (double)v28);
      unsigned int v50 = *(_DWORD *)(a1 + 196);
      unsigned int v51 = v50 * *(_DWORD *)(v43 + 16);
      if (v49 <= v51) {
        unsigned int v49 = v51;
      }
      unsigned int v52 = (v49 + (v50 >> 1)) / v50 * v50;
      *(_DWORD *)(a1 + 1948) = v52;
      if (v29 > v52) {
        *(_DWORD *)(a1 + 1952) = v52;
      }
      if (v18)
      {
        unsigned int v39 = v40 + 60000;
        goto LABEL_66;
      }
    }
  }

  return result;
}

uint64_t tcp_rledbat_get_rlwin(uint64_t a1)
{
  LODWORD(v1) = *(_DWORD *)(a1 + 1948);
  unsigned int v2 = *(_DWORD *)(a1 + 1960);
  unsigned int v3 = v2 - v1;
  if (v2 >= v1)
  {
    int v4 = v2 <= v1 ? 0 : *(_DWORD *)(a1 + 1956);
    int v5 = v2 - v4;
    if (v3 >= *(_DWORD *)(a1 + 1956)) {
      LODWORD(v1) = v5;
    }
  }

  *(_DWORD *)(a1 + 1956) = 0;
  char v6 = *(_BYTE *)(a1 + 261);
  unsigned int v7 = ((1 << v6) + v1) & -(1 << v6);
  if (*(_BYTE *)(a1 + 261)) {
    uint64_t v1 = v7;
  }
  else {
    uint64_t v1 = v1;
  }
  *(_DWORD *)(a1 + 1960) = v1;
  return v1;
}

uint64_t tcp_rledbat_after_idle(uint64_t result)
{
  *(_DWORD *)(result + 1932) = 0;
  *(void *)(result + 1924) = 0LL;
  *(void *)(result + 1940) = 0LL;
  *(_DWORD *)(result + 1956) = 0;
  *(_DWORD *)(result + 1948) = *(_DWORD *)(sysctls + 16) * *(_DWORD *)(result + 196);
  return result;
}

uint64_t tcp_rledbat_switch_to(uint64_t result)
{
  uint64_t v1 = (_DWORD *)result;
  *(_DWORD *)(result + 1932) = 0;
  *(void *)(result + 1924) = 0LL;
  *(void *)(result + 1940) = 0LL;
  *(_DWORD *)(result + 1956) = 0;
  unsigned int v2 = *(_DWORD *)(result + 1948);
  if (v2)
  {
    if (v2 >> 17) {
      int v3 = v2 >> 1;
    }
    else {
      int v3 = 0xFFFF;
    }
  }

  else
  {
    uint64_t result = tcp_sbspace(result);
    int v4 = v1[31] - v1[30];
    int v3 = (v4 & ~(v4 >> 31)) >> 1;
  }

  unsigned int v5 = v1[49];
  unsigned int v6 = (v3 + (v5 >> 1)) / v5 * v5;
  unsigned int v7 = v5 * *(_DWORD *)(sysctls + 16);
  if (v6 <= v7) {
    unsigned int v6 = v7;
  }
  v1[487] = v6;
  unsigned int v8 = v1[488];
  if (v8 >= 0x3FFFC000) {
    int v9 = 1073725440;
  }
  else {
    int v9 = v1[488];
  }
  if (v8) {
    int v10 = v9;
  }
  else {
    int v10 = 1073725440;
  }
  v1[488] = v10;
  return result;
}

void user_north_signal_error(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2)
    {
      if ((*(_WORD *)(a1 + 376) & 1) != 0)
      {
        if ((*(_BYTE *)(a1 + 828) & 2) == 0)
        {
          int v4 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            int v5 = 136446722;
            unsigned int v6 = "user_north_signal_error";
            __int16 v7 = 2082;
            uint64_t v8 = a1 + 604;
            __int16 v9 = 2048;
            uint64_t v10 = a1;
            _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s skipping so %p SS_NOFDREF",  (uint8_t *)&v5,  0x20u);
          }
        }
      }

      else
      {
        int v3 = *(void (**)(uint64_t, void))(v2 + 120);
        if (v3) {
          v3(a1, *(unsigned __int16 *)(a1 + 378));
        }
      }

      *(_WORD *)(a1 + 378) = 0;
    }
  }

void microuptime(uint64_t a1)
{
  kern_return_t v2;
  kern_return_t v3;
  os_log_s *v4;
  uint64_t v5;
  mach_timebase_info info;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  kern_return_t v10;
  uint64_t v11;
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v2 = mach_timebase_info(&info);
  if (v2)
  {
    int v3 = v2;
    int v4 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v8 = "microuptime";
      __int16 v9 = 1024;
      uint64_t v10 = v3;
      _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_ERROR, "%{public}s mach_timebase_info returned %u", buf, 0x12u);
    }
  }

  else
  {
    int v5 = mach_absolute_time() * info.numer / info.denom;
    *(void *)a1 = v5 / 0x3B9ACA00;
    *(_DWORD *)(a1 + 8) = v5 % 0x3B9ACA00 / 0x3E8;
  }

void nw_protocol_timer_run_inner(uint64_t a1, int64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a2 != -1 && dispatch_time(0x8000000000000000LL, a2) == -1LL)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v5 = "nw_protocol_timer_run_inner";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v3 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v5 = "nw_protocol_timer_run_inner";
        _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s dispatch_time: Integer overflow failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v2) {
      free(v2);
    }
  }

  else
  {
    nw_queue_set_timer_values();
  }

uint64_t nw_tcp_access_globals(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1) {
      return *(void *)(v1 + 5240);
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v7 = "nw_tcp_access_globals";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v7 = "nw_tcp_access_globals";
        int v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v7 = "nw_tcp_access_globals";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v7 = "nw_tcp_access_globals";
        int v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

void nw_tcp_init_globals(uint64_t a1, uint64_t a2)
{
  int v4 = calloc(1uLL, 0x48uLL);
  if (!v4)
  {
    __int16 v7 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    free(v8);
  }

  *(void *)(a1 + 72) = v4;
  sysctls = nw_path_get_sysctls_region();
  tcp_init(a1);
  xmmword_18C4CEAB0 = 0u;
  unk_18C4CEAC0 = 0u;
  xmmword_18C4CEA90 = 0u;
  unk_18C4CEAA0 = 0u;
  xmmword_18C4CEA70 = 0u;
  unk_18C4CEA80 = 0u;
  tcp_cc_algo_none = 0u;
  unk_18C4CEA60 = 0u;
  tcp_cc_algo_list[0] = (uint64_t)&tcp_cc_algo_none;
  *(void *)algn_18C4CEA08 = tcp_cc_newreno;
  qword_18C4CEA10 = (uint64_t)tcp_cc_ledbat;
  unk_18C4CEA18 = tcp_cc_cubic;
  qword_18C4CEA20 = (uint64_t)tcp_cc_prague;
  int v5 = calloc(0x64uLL, 8uLL);
  if (v5)
  {
LABEL_3:
    *(void *)(a1 + 32) = v5;
    *(_DWORD *)(a1 + 312) = arc4random();
    nw_protocol_tcp_timer_init(a1, a2, 1);
    nw_protocol_tcp_timer_init(a1, a2, 0);
    *(void *)(a1 + 144) = 0LL;
    uint64_t v6 = (void *)(a1 + 144);
    v6[1] = v6;
    v6[2] = 0LL;
    v6[3] = v6 + 2;
    v6[4] = 0LL;
    v6[5] = v6 + 4;
    v6[6] = 0LL;
    v6[7] = v6 + 6;
    v6[8] = 0LL;
    v6[9] = v6 + 8;
    v6[10] = 0LL;
    v6[11] = v6 + 10;
    return;
  }

  __int16 v9 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  uint64_t v10 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort())
  {
    free(v10);
    goto LABEL_3;
  }

LABEL_8:
  __break(1u);
}

  if ((v6 & 0x100) != 0)
  {
    *(_DWORD *)(a1 + 88) |= 0x200u;
    if ((v6 & 0x20) == 0) {
      return;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFFDF;
    if ((v6 & 0x20) == 0) {
      return;
    }
  }

void nw_protocol_tcp_timer_init(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a3) {
    uint64_t v4 = 88LL;
  }
  else {
    uint64_t v4 = 96LL;
  }
  uint64_t source = nw_queue_context_create_source();
  *(void *)(a1 + v4) = source;
  if (source)
  {
    if ((networkd_settings_get_BOOL() & 1) == 0) {
      nw_queue_source_set_qos_class_fallback();
    }
    nw_queue_activate_source();
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v9 = "nw_protocol_tcp_timer_init";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v9 = "nw_protocol_tcp_timer_init";
        _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v6) {
      free(v6);
    }
  }

void __nw_protocol_tcp_timer_init_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 40))
  {
    char v12 = *(_BYTE *)(v1 + 328);
    *(_BYTE *)(v1 + 328) = v12 & 0xF9;
    if ((v12 & 6) != 0)
    {
      unsigned int v13 = *(uint64_t **)(v1 + 112);
      if (v13)
      {
        if ((v12 & 2) != 0)
        {
          if ((v12 & 4) != 0)
          {
            int v15 = 0;
            int v14 = 0;
            __int128 v16 = 0uLL;
            __int128 v38 = 0u;
            do
            {
              __int128 v41 = v16;
              if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
              {
                *((_DWORD *)v13 + 12) = 0;
                v13[5] = 0LL;
                unsigned int v29 = (void (*)(uint64_t, uint64_t *))v13[2];
                if (v29)
                {
                  v29(v1, v13);
                  *((void *)&v30 + 1) = *((void *)&v38 + 1);
                  *(int32x2_t *)&__int128 v30 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v38);
                  __int128 v38 = v30;
                  __int128 v16 = v41;
                  v14 += *((_DWORD *)v13 + 12);
                }
              }

              if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
              {
                *((_DWORD *)v13 + 15) = 0;
                *(uint64_t *)((char *)v13 + 52) = 0LL;
                int v31 = (void (*)(uint64_t, uint64_t *))v13[3];
                if (v31)
                {
                  v31(v1, v13);
                  *((void *)&v32 + 1) = *((void *)&v41 + 1);
                  *(int32x2_t *)&__int128 v32 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v41);
                  __int128 v16 = v32;
                  v15 += *((_DWORD *)v13 + 15);
                }
              }

              unsigned int v13 = (uint64_t *)*v13;
            }

            while (v13);
          }

          else
          {
            int v14 = 0;
            __int128 v16 = 0uLL;
            do
            {
              if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
              {
                *((_DWORD *)v13 + 12) = 0;
                v13[5] = 0LL;
                char v25 = (void (*)(uint64_t, uint64_t *))v13[2];
                if (v25)
                {
                  __int128 v39 = v16;
                  v25(v1, v13);
                  *((void *)&v26 + 1) = *((void *)&v39 + 1);
                  *(int32x2_t *)&__int128 v26 = vadd_s32((int32x2_t)v13[5], *(int32x2_t *)&v39);
                  __int128 v16 = v26;
                  v14 += *((_DWORD *)v13 + 12);
                }
              }

              if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
              {
                *((_DWORD *)v13 + 15) = 0;
                *(uint64_t *)((char *)v13 + 52) = 0LL;
              }

              unsigned int v13 = (uint64_t *)*v13;
            }

            while (v13);
            *(void *)&__int128 v38 = v16;
            int v15 = 0;
            *(void *)&__int128 v16 = 0LL;
          }

LABEL_23:
          char v17 = *(_BYTE *)(v1 + 328);
          if ((void)v38) {
            char v18 = 2;
          }
          else {
            char v18 = 2 * (v14 != 0);
          }
          char v19 = v17 & 0xFD | v18;
          if ((*(_BYTE *)(v1 + 328) & 2) == 0) {
            char v17 = v19;
          }
          if ((void)v16) {
            char v20 = 4;
          }
          else {
            char v20 = 4 * (v15 != 0);
          }
          char v21 = v17 & 0xFB | v20;
          if ((v17 & 4) == 0) {
            char v17 = v21;
          }
          *(_BYTE *)(v1 + 328) = v17 & 0xFE;
          if (v14 | v15)
          {
            if ((v17 & 6) == 0) {
              return;
            }
          }

          else
          {
            if (vadd_s32(*(int32x2_t *)&v16, *(int32x2_t *)&v38).u32[1] <= 5)
            {
              if ((v17 & 6) == 0) {
                return;
              }
              char v24 = v17 & 0xF6 | 1;
LABEL_48:
              *(_BYTE *)(v1 + 328) = v24;
              nw_protocol_timer_run_inner(v1, 1000000000LL);
              return;
            }

            if ((v17 & 6) == 0) {
              return;
            }
          }

          char v24 = v17 | 9;
          goto LABEL_48;
        }

        if ((v12 & 4) != 0)
        {
          int v15 = 0;
          __int128 v16 = 0uLL;
          do
          {
            if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
            {
              *((_DWORD *)v13 + 12) = 0;
              v13[5] = 0LL;
            }

            if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
            {
              *((_DWORD *)v13 + 15) = 0;
              *(uint64_t *)((char *)v13 + 52) = 0LL;
              int v27 = (void (*)(uint64_t, uint64_t *))v13[3];
              if (v27)
              {
                __int128 v40 = v16;
                v27(v1, v13);
                *((void *)&v28 + 1) = *((void *)&v40 + 1);
                *(int32x2_t *)&__int128 v28 = vadd_s32(*(int32x2_t *)((char *)v13 + 52), *(int32x2_t *)&v40);
                __int128 v16 = v28;
                v15 += *((_DWORD *)v13 + 15);
              }
            }

            unsigned int v13 = (uint64_t *)*v13;
          }

          while (v13);
          int v14 = 0;
          goto LABEL_22;
        }

        do
        {
          if (*((_DWORD *)v13 + 10) || *((_DWORD *)v13 + 11) || *((_DWORD *)v13 + 12))
          {
            *((_DWORD *)v13 + 12) = 0;
            v13[5] = 0LL;
          }

          if (*((_DWORD *)v13 + 13) || *((_DWORD *)v13 + 14) || *((_DWORD *)v13 + 15))
          {
            *((_DWORD *)v13 + 15) = 0;
            *(uint64_t *)((char *)v13 + 52) = 0LL;
          }

          unsigned int v13 = (uint64_t *)*v13;
        }

        while (v13);
      }
    }

    int v14 = 0;
    int v15 = 0;
    *(void *)&__int128 v16 = 0LL;
LABEL_22:
    *(void *)&__int128 v38 = 0LL;
    goto LABEL_23;
  }

  calculate_tcp_clock(*(void *)(a1 + 32));
  *(_BYTE *)(v1 + 310) &= ~2u;
  int v2 = *(_DWORD *)(v1 + 272);
  unsigned int v3 = *(_DWORD *)(v1 + 316) - v2;
  if (*(void *)(v1 + 256))
  {
    int v4 = v2 - *(_DWORD *)(v1 + 276);
    if ((int)v3 < 11)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v33 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          int v34 = *(_DWORD *)(v1 + 292);
          int v35 = *(_DWORD *)(v1 + 276);
          int v36 = *(_DWORD *)(v1 + 272);
          int v37 = *(_DWORD *)(v1 + 316);
          *(_DWORD *)__int128 buf = 136447746;
          uint64_t v43 = "tcp_run_timerlist";
          __int16 v44 = 1024;
          int v45 = v34;
          __int16 v46 = 1024;
          int v47 = v35;
          __int16 v48 = 1024;
          int v49 = v36;
          __int16 v50 = 1024;
          int v51 = v37;
          __int16 v52 = 1024;
          unsigned int v53 = v3;
          __int16 v54 = 1024;
          int v55 = v4;
          uint64_t v10 = v33;
          os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
          goto LABEL_7;
        }
      }
    }

    else if ((*(char *)(v1 + 328) & 0x80000000) == 0)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        int v6 = *(_DWORD *)(v1 + 292);
        int v7 = *(_DWORD *)(v1 + 276);
        int v8 = *(_DWORD *)(v1 + 272);
        int v9 = *(_DWORD *)(v1 + 316);
        *(_DWORD *)__int128 buf = 136447746;
        uint64_t v43 = "tcp_run_timerlist";
        __int16 v44 = 1024;
        int v45 = v6;
        __int16 v46 = 1024;
        int v47 = v7;
        __int16 v48 = 1024;
        int v49 = v8;
        __int16 v50 = 1024;
        int v51 = v9;
        __int16 v52 = 1024;
        unsigned int v53 = v3;
        __int16 v54 = 1024;
        int v55 = v4;
        uint64_t v10 = v5;
        os_log_type_t v11 = OS_LOG_TYPE_INFO;
LABEL_7:
        _os_log_impl( &dword_1879E5000,  v10,  v11,  "%{public}s mode %d schedtime %u runtime %u tcp_now %u drift %d / offset %d",  buf,  0x30u);
      }
    }
  }

  tcp_process_timerlist(v1);
  uint64_t v22 = *(void *)(v1 + 256);
  if (v22)
  {
    unsigned int v23 = *(void **)(v22 + 1008);
    if (v23)
    {
      if ((int)v3 > 1)
      {
        if (v3 > 0xA)
        {
          if (v3 > 0x14)
          {
            if (v3 > 0x32)
            {
              if (v3 > 0x64)
              {
                if (v3 > 0xC8)
                {
                  if (v3 > 0x1F4)
                  {
                    if (v3 > 0x3E8) {
                      ++v23[159];
                    }
                    else {
                      ++v23[158];
                    }
                  }

                  else
                  {
                    ++v23[157];
                  }
                }

                else
                {
                  ++v23[156];
                }
              }

              else
              {
                ++v23[155];
              }
            }

            else
            {
              ++v23[154];
            }
          }

          else
          {
            ++v23[153];
          }
        }

        else
        {
          ++v23[152];
        }
      }

      else
      {
        ++v23[151];
      }
    }
  }

uint64_t nw_tcp_destroy_globals(void *a1)
{
  int v2 = (void **)a1[4];
  unsigned int v3 = *v2;
  if (!*v2) {
    goto LABEL_8;
  }
  do
  {
    int v5 = *v2;
    for (i = v2; v5 != v3; int v5 = (void *)*v5)
      uint64_t i = v5;
    int v4 = (void *)*v3;
    *uint64_t i = *v3;
    free(v3);
    unsigned int v3 = v4;
  }

  while (v4);
  int v2 = (void **)a1[4];
  if (v2)
  {
LABEL_8:
    free(v2);
    a1[4] = 0LL;
  }

  if (a1[11])
  {
    nw_queue_cancel_source();
    a1[11] = 0LL;
  }

  if (a1[12])
  {
    nw_queue_cancel_source();
    a1[12] = 0LL;
  }

  int v7 = (void *)a1[9];
  if (v7)
  {
    free(v7);
    a1[9] = 0LL;
  }

  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  nw_tcp_release_frame_array();
  uint64_t result = nw_tcp_release_frame_array();
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  return result;
}

uint64_t nw_tcp_release_frame_array()
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  unsigned int v0 = (void *)MEMORY[0x189608EF8];
  while (1)
  {
    uint64_t result = nw_frame_array_is_empty();
    if ((result & 1) != 0) {
      return result;
    }
    uint64_t v2 = nw_frame_array_first();
    nw_frame_array_remove();
    if (v2)
    {
      unsigned int v3 = (void *)(v2 + 104);
      __int16 v4 = *(_WORD *)(v2 + 204);
      if ((v4 & 2) != 0)
      {
        unsigned int v13 = *(void **)(v2 + 96);
        if (v13)
        {
          nw_release(v13);
          *(void *)(v2 + 96) = 0LL;
        }

        *(_DWORD *)(v2 + 52) = 0;
        *(_DWORD *)(v2 + 56) = 0;
        *(_WORD *)(v2 + 196) = 0;
      }

      else
      {
        if (*(void *)(v2 + 104))
        {
          if (((*(_WORD *)(v2 + 204) & 0x100) == 0
             || !*v0
             || ((unsigned int (*)(uint64_t, void))*v0)(v2, *(void *)(v2 + 88)))
            && *(void *)(v2 + 112))
          {
            nw_mem_buffer_free();
          }

          int v5 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(_BYTE *)(v2 + 200) = 0;
          *(void *)(v2 + 56) = 0LL;
          *(void *)(v2 + 48) = 0LL;
          *(void *)(v2 + 88) = 0LL;
          *(void *)(v2 + 80) = 0LL;
          *unsigned int v3 = 0LL;
          *(void *)(v2 + 112) = 0LL;
          unsigned int v6 = v5 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v6;
          *(_BYTE *)(v2 + 206) = BYTE2(v6);
          uint64_t v8 = v2 + 64;
          int v7 = *(void **)(v2 + 64);
          if (v7)
          {
            do
            {
              int v9 = (void *)*v7;
              uint64_t v10 = (void *)v7[6];
              os_log_type_t v11 = (void *)*v7;
              if (v10)
              {
                nw_release(v10);
                v7[6] = 0LL;
                os_log_type_t v11 = (void *)*v7;
              }

              char v12 = (void *)v7[1];
              if (v11)
              {
                v11[1] = v12;
                char v12 = (void *)v7[1];
              }

              else
              {
                *(void *)(v2 + 72) = v12;
              }

              *char v12 = v11;
              if (v7 != (void *)(v2 + 120)) {
                free(v7);
              }
              int v7 = v9;
            }

            while (v9);
          }
        }

        else
        {
          if ((v4 & 1) == 0) {
            goto LABEL_3;
          }
          if ((*(_WORD *)(v2 + 204) & 0x100) == 0
            || !*v0
            || ((unsigned int (*)(uint64_t, void))*v0)(v2, *(void *)(v2 + 88)))
          {
            int v14 = *(void **)(v2 + 112);
            if (v14) {
              free(v14);
            }
          }

          int v15 = *(unsigned __int16 *)(v2 + 204);
          *(_WORD *)(v2 + 196) = 0;
          *(_DWORD *)(v2 + 192) = 0;
          *(_BYTE *)(v2 + 200) = 0;
          *(void *)(v2 + 56) = 0LL;
          *(void *)(v2 + 48) = 0LL;
          *(void *)(v2 + 88) = 0LL;
          *(void *)(v2 + 80) = 0LL;
          *unsigned int v3 = 0LL;
          *(void *)(v2 + 112) = 0LL;
          unsigned int v16 = v15 & 0xFFFFFFC7 | (*(unsigned __int8 *)(v2 + 206) << 16);
          *(_WORD *)(v2 + 204) = v16;
          *(_BYTE *)(v2 + 206) = BYTE2(v16);
          uint64_t v8 = v2 + 64;
          char v17 = *(void **)(v2 + 64);
          if (v17)
          {
            do
            {
              char v18 = (void *)*v17;
              char v19 = (void *)v17[6];
              char v20 = (void *)*v17;
              if (v19)
              {
                nw_release(v19);
                v17[6] = 0LL;
                char v20 = (void *)*v17;
              }

              char v21 = (void *)v17[1];
              if (v20)
              {
                v20[1] = v21;
                char v21 = (void *)v17[1];
              }

              else
              {
                *(void *)(v2 + 72) = v21;
              }

              *char v21 = v20;
              if (v17 != (void *)(v2 + 120)) {
                free(v17);
              }
              char v17 = v18;
            }

            while (v18);
          }
        }

        *(void *)(v2 + 64) = 0LL;
        *(void *)(v2 + 72) = v8;
        uint64_t v22 = *(void **)(v2 + 168);
        if (v22) {
          nw_release(v22);
        }
        __int16 v23 = *(_WORD *)(v2 + 204);
        *(void *)(v2 + 184) = 0LL;
        *(_OWORD *)(v2 + 168) = 0u;
        *(_OWORD *)(v2 + 152) = 0u;
        *(_OWORD *)(v2 + 136) = 0u;
        *(_OWORD *)(v2 + 120) = 0u;
        *(_WORD *)(v2 + 204) = v23 & 0x213F;
        *(_BYTE *)(v2 + 203) = 0;
        *(_WORD *)(v2 + 198) = 0;
      }

LABEL_3:
      nw_release((void *)v2);
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v31 = "__nw_frame_buffer_get_manager";
      char v24 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        char v25 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v31 = "__nw_frame_buffer_get_manager";
          _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v24) {
        free(v24);
      }
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v31 = "__nw_frame_uses_external_data";
      __int128 v26 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v27 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v31 = "__nw_frame_uses_external_data";
          _os_log_impl( &dword_1879E5000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v26) {
        free(v26);
      }
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v31 = "__nw_frame_buffer_used_malloc";
      __int128 v28 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        unsigned int v29 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v31 = "__nw_frame_buffer_used_malloc";
          _os_log_impl( &dword_1879E5000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v28) {
        free(v28);
      }
    }
  }

void nw_protocol_tcp_update_metadata(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v6 = "nw_protocol_tcp_update_metadata";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    unsigned int v3 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v6 = "nw_protocol_tcp_update_metadata";
    __int16 v4 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_13;
  }

  uint64_t v1 = (_DWORD *)nw_protocol_downcast();
  if (v1)
  {
    v1[1322] = v1[96];
    v1[1323] = v1[122];
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  unsigned int v6 = "nw_protocol_tcp_update_metadata";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v3 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v6 = "nw_protocol_tcp_update_metadata";
      __int16 v4 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_13:
      _os_log_impl(&dword_1879E5000, v3, OS_LOG_TYPE_ERROR, v4, buf, 0xCu);
    }
  }

LABEL_14:
  if (v2) {
    free(v2);
  }
}

    if (v8) {
      free(v8);
    }
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
  unsigned int v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      int v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        unsigned int v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_1879E5000, v14, v15, v16, buf, 0xCu);
      }
    }

    else
    {
      int v14 = (os_log_s *)__nwlog_obj();
      int v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        unsigned int v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }

  if (v13) {
    free(v13);
  }
  return 22LL;
}

    if (v8) {
      free(v8);
    }
LABEL_16:
    os_unfair_lock_unlock(v5);
    return v6;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
  unsigned int v13 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      int v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        unsigned int v16 = "%{public}s called with null handle";
LABEL_24:
        _os_log_impl(&dword_1879E5000, v14, v15, v16, buf, 0xCu);
      }
    }

    else
    {
      int v14 = (os_log_s *)__nwlog_obj();
      int v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        unsigned int v16 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }

  if (v13) {
    free(v13);
  }
  return 22LL;
}

  uint64_t v8 = a2 + 204;
  if ((*(_WORD *)(a2 + 204) & 8) == 0)
  {
LABEL_15:
    int v9 = *(void **)(a2 + 168);
    if (v9)
    {
      nw_release(v9);
      *(void *)(a2 + 168) = 0LL;
    }

    uint64_t v10 = a2 + 120;
    if (v3)
    {
      *(void *)(a2 + 168) = nw_retain(v3);
      os_log_type_t v11 = *(unsigned __int16 *)(a2 + 204);
      char v12 = v11 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v11 & 0x20) == 0)
      {
        nw_protocol_metadata_copy_identifier();
        char v12 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      }

      *(_BYTE *)(v8 + 2) = BYTE2(v12);
      *(_WORD *)uint64_t v8 = v12 | 8;
    }

    unsigned int v13 = *(void *)(a2 + 64);
    if (v4) {
      int v14 = 64;
    }
    else {
      int v14 = 0;
    }
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xBF | v14;
    if (!v13)
    {
      *(void *)(a2 + 64) = v10;
      *(void *)(a2 + 72) = v10;
      *(void *)(a2 + 120) = 0LL;
      *(void *)(a2 + 128) = a2 + 64;
      return 1LL;
    }

    if (v13 == v10) {
      return 1LL;
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446722;
    __int16 v44 = "__nw_frame_set_metadata";
    int v45 = 2048;
    __int16 v46 = v13;
    int v47 = 2048;
    __int16 v48 = a2 + 120;
    int v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v16 = (os_log_s *)__nwlog_obj();
      char v17 = type[0];
      if (!os_log_type_enabled(v16, type[0])) {
        goto LABEL_60;
      }
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v44 = "__nw_frame_set_metadata";
      int v45 = 2048;
      __int16 v46 = v13;
      int v47 = 2048;
      __int16 v48 = v10;
      char v18 = "%{public}s Existing metadata %p doesn't match expected %p";
    }

    else
    {
      unsigned int v16 = (os_log_s *)__nwlog_obj();
      char v17 = type[0];
      if (!os_log_type_enabled(v16, type[0])) {
        goto LABEL_60;
      }
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v44 = "__nw_frame_set_metadata";
      int v45 = 2048;
      __int16 v46 = v13;
      int v47 = 2048;
      __int16 v48 = v10;
      char v18 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
    }

    __int128 v30 = v16;
    int v31 = v17;
    uint64_t v32 = 32;
    goto LABEL_59;
  }

  nw_protocol_metadata_copy_identifier();
  char v19 = *(const unsigned __int8 **)(a2 + 64);
  if (!v19) {
    goto LABEL_47;
  }
  char v20 = 0;
  if (v4) {
    char v21 = 64;
  }
  else {
    char v21 = 0;
  }
  do
  {
    uint64_t v22 = nw_protocol_metadata_copy_definition(v3);
    __int16 v23 = (nw_protocol_metadata *)*((void *)v19 + 6);
    if (!v23) {
      goto LABEL_40;
    }
    char v24 = nw_protocol_metadata_copy_definition(v23);
    if (!MEMORY[0x1895B109C](v22, v24) || uuid_compare((const unsigned __int8 *)type, v19 + 16))
    {
      if (!v24) {
        goto LABEL_40;
      }
LABEL_39:
      nw_release(v24);
      goto LABEL_40;
    }

    nw_retain(v3);
    char v25 = (void *)*((void *)v19 + 6);
    if (v25) {
      nw_release(v25);
    }
    *((void *)v19 + 6) = v3;
    *((_BYTE *)v19 + 66) = v19[66] & 0xBF | v21;
    char v20 = 1;
    if (v24) {
      goto LABEL_39;
    }
LABEL_40:
    if (v22) {
      nw_release(v22);
    }
    char v19 = *(const unsigned __int8 **)v19;
  }

  while (v19);
  if ((v20 & 1) != 0) {
    return 1LL;
  }
LABEL_47:
  __int128 v26 = calloc(1uLL, 0x48uLL);
  if (v26) {
    goto LABEL_48;
  }
  __int128 v40 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446722;
  __int16 v44 = "strict_calloc";
  int v45 = 2048;
  __int16 v46 = 1LL;
  int v47 = 2048;
  __int16 v48 = 72LL;
  __int128 v41 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if ((_DWORD)result)
  {
    __break(1u);
  }

  else
  {
    free(v41);
LABEL_48:
    v26[6] = nw_retain(v3);
    *((_OWORD *)v26 + 1) = *(_OWORD *)type;
    if (v4) {
      int v27 = 64;
    }
    else {
      int v27 = 0;
    }
    *((_BYTE *)v26 + 66) = *((_BYTE *)v26 + 66) & 0xBF | v27;
    __int128 v28 = *(void *)(a2 + 64);
    *__int128 v26 = v28;
    if (v28) {
      unsigned int v29 = (void *)(v28 + 8);
    }
    else {
      unsigned int v29 = (void *)(a2 + 72);
    }
    *unsigned int v29 = v26;
    *(void *)(a2 + 64) = v26;
    v26[1] = a2 + 64;
    return 1LL;
  }

  return result;
}

uint64_t nw_protocol_tcp_get_all_stats()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t v0 = nw_protocol_downcast();
  if (v0)
  {
    if (*(void *)(v0 + 5216)) {
      return nw_path_flow_registration_get_stats_area();
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v5 = "nw_protocol_tcp_get_all_stats";
    uint64_t v2 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v3 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v5 = "nw_protocol_tcp_get_all_stats";
        _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s called with null tcp, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v2) {
      free(v2);
    }
  }

  return 0LL;
}

int *nw_protocol_tcp_identifier()
{
  if (nw_protocol_tcp_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  }
  return &nw_protocol_tcp_identifier_identifier;
}

uint64_t __nw_protocol_tcp_identifier_block_invoke()
{
  unk_18C4CE9BC = 0LL;
  unk_18C4CE9B4 = 0LL;
  dword_18C4CE9CC = 0;
  unk_18C4CE9C4 = 0LL;
  nw_protocol_tcp_identifier_identifier = 7365492;
  qword_18C4CE9D0 = 0x100000003LL;
  return nw_protocol_register_extended();
}

uint64_t nw_protocol_tcp_create()
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (nw_protocol_tcp_identifier_onceToken != -1) {
    dispatch_once(&nw_protocol_tcp_identifier_onceToken, &__block_literal_global);
  }
  if (nw_protocol_tcp_callbacks_onceToken[0] != -1) {
    dispatch_once(nw_protocol_tcp_callbacks_onceToken, &__block_literal_global_9);
  }
  uint64_t v0 = nw_protocol_new();
  if (v0)
  {
    uint64_t v1 = v0;
    if (nw_protocol_tcp_initialize_globals_onceToken != -1) {
      dispatch_once(&nw_protocol_tcp_initialize_globals_onceToken, &__block_literal_global_32);
    }
    *(_DWORD *)(v1 + 5264) = 0;
    MEMORY[0x1895B14A4](v1 + 5184);
    *(void *)(v1 + 5232) = nw_tcp_create_metadata();
    *(void *)&__int128 buf = nw_protocol_tcp_get_receive_buffer_size;
    *((void *)&buf + 1) = nw_protocol_tcp_get_send_buffer_size;
    uint64_t v6 = nw_protocol_tcp_reset_keepalives;
    uint64_t v7 = nw_protocol_tcp_set_no_delay;
    uint64_t v8 = nw_protocol_tcp_set_no_push;
    int v9 = nw_protocol_tcp_set_no_wake_from_sleep;
    nw_tcp_set_callbacks();
    return nw_protocol_upcast();
  }

  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
    unsigned int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      __int16 v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "__nw_protocol_tcp_create";
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s nw_protocol_tcp_obj_alloc failed, backtrace limit exceeded",  (uint8_t *)&buf,  0xCu);
      }
    }

    if (v3) {
      free(v3);
    }
    return 0LL;
  }

uint64_t nw_protocol_tcp_get_receive_buffer_size(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(unsigned int *)(a1 + 5292);
  }
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v5 = "nw_protocol_tcp_get_receive_buffer_size";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v3 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v5 = "nw_protocol_tcp_get_receive_buffer_size";
      _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s called with null handle, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v2) {
    free(v2);
  }
  return 0LL;
}

uint64_t nw_protocol_tcp_get_send_buffer_size(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(unsigned int *)(a1 + 5288);
  }
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v5 = "nw_protocol_tcp_get_send_buffer_size";
  uint64_t v2 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v3 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v5 = "nw_protocol_tcp_get_send_buffer_size";
      _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s called with null handle, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v2) {
    free(v2);
  }
  return 0LL;
}

uint64_t nw_protocol_tcp_reset_keepalives(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    os_log_type_t v11 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v5);
    if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v5);
      __nwlog_obj();
      uint64_t v12 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
      __int16 v33 = 2082;
      *(void *)int v34 = a1 + 604;
      *(_WORD *)&v34[8] = 1024;
      LODWORD(v35) = 22;
      unsigned int v13 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v14 = (os_log_s *)__nwlog_obj();
          os_log_type_t v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
            __int16 v33 = 2082;
            *(void *)int v34 = v12;
            *(_WORD *)&v34[8] = 1024;
            LODWORD(v35) = 22;
            unsigned int v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
LABEL_45:
            _os_log_impl(&dword_1879E5000, v14, v15, v16, buf, 0x1Cu);
          }
        }

        else
        {
          int v14 = (os_log_s *)__nwlog_obj();
          os_log_type_t v15 = type[0];
          if (os_log_type_enabled(v14, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
            __int16 v33 = 2082;
            *(void *)int v34 = v12;
            *(_WORD *)&v34[8] = 1024;
            LODWORD(v35) = 22;
            unsigned int v16 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_45;
          }
        }
      }

      if (v13) {
        free(v13);
      }
      uint64_t v18 = 22LL;
LABEL_54:
      os_unfair_lock_unlock(v11);
      return v18;
    }

    if (a2) {
      int v17 = 8;
    }
    else {
      int v17 = 0;
    }
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | v17;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v5);
    *(_DWORD *)os_log_type_t type = a4;
    *(_DWORD *)&buf[8] = 16;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v34[2] = type;
    uint64_t v35 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v5);
    else {
      uint64_t v18 = 22LL;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v5);
    if ((_DWORD)v18)
    {
      __nwlog_obj();
      uint64_t v19 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
      __int16 v33 = 2082;
      *(void *)int v34 = a1 + 604;
      *(_WORD *)&v34[8] = 1024;
      LODWORD(v35) = v18;
      char v20 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        char v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_52;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int16 v33 = 2082;
        *(void *)int v34 = v19;
        *(_WORD *)&v34[8] = 1024;
        LODWORD(v35) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
      }

      else
      {
        char v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_52;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int16 v33 = 2082;
        *(void *)int v34 = v19;
        *(_WORD *)&v34[8] = 1024;
        LODWORD(v35) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }

    else
    {
      *(_DWORD *)os_log_type_t type = a5;
      *(_DWORD *)&buf[8] = 257;
      *(void *)__int128 buf = 0x600000001LL;
      *(void *)&v34[2] = type;
      uint64_t v35 = 4LL;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v5);
      else {
        uint64_t v18 = 22LL;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v5);
      if ((_DWORD)v18)
      {
        __nwlog_obj();
        uint64_t v24 = a1 + 604;
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int16 v33 = 2082;
        *(void *)int v34 = a1 + 604;
        *(_WORD *)&v34[8] = 1024;
        LODWORD(v35) = v18;
        char v20 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          char v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_52;
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
          __int16 v33 = 2082;
          *(void *)int v34 = v24;
          *(_WORD *)&v34[8] = 1024;
          LODWORD(v35) = v18;
          __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d";
        }

        else
        {
          char v21 = (os_log_s *)__nwlog_obj();
          os_log_type_t v22 = type[0];
          if (!os_log_type_enabled(v21, type[0])) {
            goto LABEL_52;
          }
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
          __int16 v33 = 2082;
          *(void *)int v34 = v24;
          *(_WORD *)&v34[8] = 1024;
          LODWORD(v35) = v18;
          __int16 v23 = "%{public}s %{public}s tcp_set_keepalive_interval failed %{darwin.errno}d, backtrace limit exceeded";
        }
      }

      else
      {
        *(_DWORD *)os_log_type_t type = a3;
        *(void *)__int128 buf = 0x600000001LL;
        *(_DWORD *)&buf[8] = 258;
        *(void *)&v34[2] = type;
        uint64_t v35 = 4LL;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v5);
        else {
          uint64_t v18 = 22LL;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v5);
        if (!(_DWORD)v18) {
          goto LABEL_54;
        }
        __nwlog_obj();
        uint64_t v25 = a1 + 604;
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int16 v33 = 2082;
        *(void *)int v34 = a1 + 604;
        *(_WORD *)&v34[8] = 1024;
        LODWORD(v35) = v18;
        char v20 = (void *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault()
          || (char v21 = (os_log_s *)__nwlog_obj(), v22 = OS_LOG_TYPE_ERROR, !os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)))
        {
LABEL_52:
          if (v20) {
            free(v20);
          }
          goto LABEL_54;
        }

        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int16 v33 = 2082;
        *(void *)int v34 = v25;
        *(_WORD *)&v34[8] = 1024;
        LODWORD(v35) = v18;
        __int16 v23 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }
    }

    _os_log_impl(&dword_1879E5000, v21, v22, v23, buf, 0x1Cu);
    goto LABEL_52;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
  int v27 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int128 v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int128 v30 = "%{public}s called with null handle";
LABEL_62:
        _os_log_impl(&dword_1879E5000, v28, v29, v30, buf, 0xCu);
      }
    }

    else
    {
      __int128 v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_reset_keepalives";
        __int128 v30 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_62;
      }
    }
  }

  if (v27) {
    free(v27);
  }
  return 22LL;
}

uint64_t nw_protocol_tcp_set_no_delay(uint64_t a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)os_log_type_t type = a2;
    *(_DWORD *)&buf[8] = 1;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v20[2] = type;
    uint64_t v21 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v2);
    else {
      uint64_t v6 = 22LL;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
    if (!(_DWORD)v6) {
      goto LABEL_16;
    }
    __nwlog_obj();
    uint64_t v7 = a1 + 604;
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
    __int16 v19 = 2082;
    *(void *)char v20 = a1 + 604;
    *(_WORD *)&v20[8] = 1024;
    LODWORD(v21) = v6;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        __int16 v19 = 2082;
        *(void *)char v20 = v7;
        *(_WORD *)&v20[8] = 1024;
        LODWORD(v21) = v6;
        os_log_type_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
      }

      else
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_delay";
        __int16 v19 = 2082;
        *(void *)char v20 = v7;
        *(_WORD *)&v20[8] = 1024;
        LODWORD(v21) = v6;
        os_log_type_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v9, v10, v11, buf, 0x1Cu);
    }

uint64_t nw_protocol_tcp_set_no_push(uint64_t a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 5264);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 5264));
    *(_DWORD *)os_log_type_t type = a2;
    *(_DWORD *)&buf[8] = 4;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v20[2] = type;
    uint64_t v21 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v2);
    else {
      uint64_t v6 = 22LL;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
    if (!(_DWORD)v6) {
      goto LABEL_16;
    }
    __nwlog_obj();
    uint64_t v7 = a1 + 604;
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
    __int16 v19 = 2082;
    *(void *)char v20 = a1 + 604;
    *(_WORD *)&v20[8] = 1024;
    LODWORD(v21) = v6;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        __int16 v19 = 2082;
        *(void *)char v20 = v7;
        *(_WORD *)&v20[8] = 1024;
        LODWORD(v21) = v6;
        os_log_type_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
      }

      else
      {
        int v9 = (os_log_s *)__nwlog_obj();
        os_log_type_t v10 = type[0];
        if (!os_log_type_enabled(v9, type[0])) {
          goto LABEL_14;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_push";
        __int16 v19 = 2082;
        *(void *)char v20 = v7;
        *(_WORD *)&v20[8] = 1024;
        LODWORD(v21) = v6;
        os_log_type_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v9, v10, v11, buf, 0x1Cu);
    }

uint64_t nw_protocol_tcp_set_no_wake_from_sleep(os_unfair_lock_s *a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = a1 + 1316;
    os_unfair_lock_lock(a1 + 1316);
    *(_OWORD *)__int128 buf = 0uLL;
    uint64_t v2 = 0LL;
    if (nw_path_flow_registration_get_nexus_instance())
    {
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      uint64_t v2 = os_nexus_flow_set_wake_from_sleep();
    }

    os_unfair_lock_unlock(v1);
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
    __int16 v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_no_wake_from_sleep";
        _os_log_impl( &dword_1879E5000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s called with null handle, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v4) {
      free(v4);
    }
    return 22LL;
  }

  return v2;
}

uint64_t __nw_protocol_tcp_initialize_globals_block_invoke()
{
  tcp_input_batch_size = networkd_settings_get_int64_with_default();
  tcp_batch_ack_max = networkd_settings_get_int64_with_default();
  tcp_perf_measurement = networkd_settings_get_BOOL();
  g_use_slab_allocator = networkd_settings_get_int64_with_default() == 0;
  uint64_t result = networkd_settings_get_int64_with_default();
  tcp_timerlist_max_offset = result;
  return result;
}

uint64_t __nw_protocol_tcp_callbacks_block_invoke()
{
  nw_protocol_tcp_callbacks_callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler();
  nw_protocol_callbacks_set_replace_input_handler();
  nw_protocol_callbacks_set_remove_input_handler();
  nw_protocol_callbacks_set_input_available();
  nw_protocol_callbacks_set_input_flush();
  nw_protocol_callbacks_set_output_available();
  nw_protocol_callbacks_set_get_input_frames();
  nw_protocol_callbacks_set_get_output_frames();
  nw_protocol_callbacks_set_finalize_output_frames();
  nw_protocol_callbacks_set_link_state();
  nw_protocol_callbacks_set_disconnect();
  nw_protocol_callbacks_set_connect();
  nw_protocol_callbacks_set_connected();
  nw_protocol_callbacks_set_reset();
  nw_protocol_callbacks_set_disconnected();
  nw_protocol_callbacks_set_waiting_for_output();
  nw_protocol_callbacks_set_output_finished();
  nw_protocol_callbacks_set_updated_path();
  nw_protocol_callbacks_set_copy_info();
  nw_protocol_callbacks_set_register_notification();
  nw_protocol_callbacks_set_unregister_notification();
  nw_protocol_callbacks_set_get_message_properties();
  return nw_protocol_callbacks_set_error();
}

BOOL nw_protocol_tcp_add_input_handler(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v10 = "nw_protocol_tcp_add_input_handler";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v10 = "nw_protocol_tcp_add_input_handler";
        uint64_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }

LABEL_20:
    if (v6) {
      free(v6);
    }
    return 0LL;
  }

  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v10 = "nw_protocol_tcp_add_input_handler";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v10 = "nw_protocol_tcp_add_input_handler";
        uint64_t v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_19;
      }
    }

    goto LABEL_20;
  }

  uint64_t v3 = v2;
  if (*(_DWORD *)(v2 + 5224)) {
    return 0LL;
  }
  nw_protocol_set_input_handler();
  nw_protocol_set_flow_id_from_protocol();
  if (!nw_protocol_get_output_handler()) {
    nw_protocol_set_output_handler();
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFEFFF | v5;
  return nw_protocol_tcp_initialize(a1);
}

  uint64_t v21 = 0;
  while (1)
  {
    uint64_t v22 = *(_DWORD *)(v20 + 52);
    __int16 v23 = *(_DWORD *)(v20 + 56);
    uint64_t v24 = *(_DWORD *)(v20 + 60);
    uint64_t v25 = v22 - (v23 + v24);
    if (v25 >= a5 - v21) {
      uint64_t v25 = a5 - v21;
    }
    __int128 v26 = v22 ? v25 : 0;
    int v27 = v23 + v26;
    if (v23 + v26 <= v22 - v24)
    {
      *(_DWORD *)(v20 + 56) = v27;
    }

    else
    {
      __int128 v28 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v29 = *(_DWORD *)(v20 + 52);
        *(_DWORD *)__int128 buf = 136446978;
        __int16 v195 = "__nw_frame_claim_internal";
        v196 = 1024;
        *(_DWORD *)uint64_t v197 = v27;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = v29;
        *(_WORD *)v198 = 1024;
        *(_DWORD *)&v198[2] = v24;
        _os_log_impl( &dword_1879E5000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
      }
    }

    v21 += v26;
    if (v21 == a5) {
      break;
    }
    if (v21 < a5)
    {
      char v20 = *(void *)(v20 + 32);
      if (v20) {
        continue;
      }
    }

    goto LABEL_44;
  }

    __break(1u);
    return result;
  }

  if ((a1[156] & 0x80000000) != 0) {
    goto LABEL_18;
  }
LABEL_3:
  uint64_t v2 = a1[25];
  uint64_t v3 = a1[23];
  if ((a1[185] & 0x20400020) != 0x20000020) {
    return (v2 - (v3 + a1[157])) & ~((v2 - (v3 + a1[157])) >> 31);
  }
  if (a1[24] - v2 > 0) {
    uint64_t v2 = a1[24];
  }
  __int16 v4 = a1[519];
  int v5 = v2 - (a1[520] + v3 + a1[518]);
  uint64_t v6 = (v5 + v4);
  if (v5 + v4 < 0)
  {
    __nwlog_obj();
    uint64_t v8 = a1[24];
    uint64_t v7 = a1[25];
    int v9 = a1[23];
    os_log_type_t v10 = a1[520];
    uint64_t v11 = a1[518];
    uint64_t v12 = a1[519];
    *(_DWORD *)__int128 buf = 136448002;
    int v27 = "tcp_flight_size";
    __int128 v28 = 1024;
    os_log_type_t v29 = v6;
    __int128 v30 = 1024;
    int v31 = v7;
    uint64_t v32 = 1024;
    __int16 v33 = v8;
    int v34 = 1024;
    uint64_t v35 = v9;
    uint64_t v36 = 1024;
    int v37 = v10;
    __int128 v38 = 1024;
    __int128 v39 = v11;
    __int128 v40 = 1024;
    __int128 v41 = v12;
    unsigned int v13 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v14 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        unsigned int v16 = a1[24];
        os_log_type_t v15 = a1[25];
        int v17 = a1[23];
        uint64_t v18 = a1[520];
        __int16 v19 = a1[518];
        char v20 = a1[519];
        *(_DWORD *)__int128 buf = 136448002;
        int v27 = "tcp_flight_size";
        __int128 v28 = 1024;
        os_log_type_t v29 = v6;
        __int128 v30 = 1024;
        int v31 = v15;
        uint64_t v32 = 1024;
        __int16 v33 = v16;
        int v34 = 1024;
        uint64_t v35 = v17;
        uint64_t v36 = 1024;
        int v37 = v18;
        __int128 v38 = 1024;
        __int128 v39 = v19;
        __int128 v40 = 1024;
        __int128 v41 = v20;
        _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s flight_size (%d) can't be negative (snd_nxt:%u snd_max:%u, snd_una:%u, sacked:%u lost:%u retransmit ted:%u), backtrace limit exceeded",  buf,  0x36u);
      }
    }

    if (v13) {
      free(v13);
    }
    return 0LL;
  }

  return v6;
}

uint64_t nw_protocol_tcp_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    unsigned int v13 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    int v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_37;
  }

  uint64_t v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    unsigned int v13 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    int v14 = "%{public}s called with null tcp, backtrace limit exceeded";
    goto LABEL_37;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    unsigned int v13 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    int v14 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
    goto LABEL_37;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    uint64_t v12 = _os_log_send_and_compose_impl();
    unsigned int v13 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    int v14 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
LABEL_37:
    _os_log_impl(&dword_1879E5000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
LABEL_38:
    if (!v12) {
      return 0LL;
    }
    uint64_t v11 = (void *)v12;
LABEL_19:
    free(v11);
    return 0LL;
  }

  uint64_t v6 = v5;
  if (nw_protocol_get_input_handler() != a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446722;
    unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
    __int16 v17 = 2048;
    uint64_t input_handler = nw_protocol_get_input_handler();
    __int16 v19 = 2048;
    uint64_t v20 = a2;
    uint64_t v7 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      os_log_type_t v10 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v16 = "nw_protocol_tcp_replace_input_handler";
        __int16 v17 = 2048;
        uint64_t input_handler = nw_protocol_get_input_handler();
        __int16 v19 = 2048;
        uint64_t v20 = a2;
        _os_log_impl( &dword_1879E5000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded",  buf,  0x20u);
      }
    }

    if (!v7) {
      return 0LL;
    }
    uint64_t v11 = (void *)v7;
    goto LABEL_19;
  }

  nw_protocol_set_input_handler();
  if (!nw_protocol_get_output_handler()) {
    nw_protocol_set_output_handler();
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 5308) & 0xFFFFEFFF;
  }
  *(_DWORD *)(v6 + 5308) = v8;
  return 1LL;
}

uint64_t nw_protocol_tcp_remove_input_handler(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
    unsigned int v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v19 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_41:
        _os_log_impl(&dword_1879E5000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      }
    }

LABEL_42:
    if (v16) {
      free(v16);
    }
    return 0LL;
  }

  uint64_t v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
    unsigned int v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v19 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_41;
      }
    }

    goto LABEL_42;
  }

  uint64_t v8 = v7;
  if ((*(_BYTE *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v17 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v23 = 2082;
        uint64_t v24 = v8 + 604;
        _os_log_impl( &dword_1879E5000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s protocol upper layer initiated remove_input_handler",  buf,  0x16u);
      }
    }
  }

  if (nw_protocol_get_output_handler() == a1) {
    nw_protocol_set_output_handler();
  }
  if (nw_protocol_get_input_handler() != a2)
  {
    if ((*(_BYTE *)(v8 + 828) & 2) == 0)
    {
      int v9 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
        __int16 v23 = 2082;
        uint64_t v24 = v8 + 604;
        _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s default_input_handler is different from the input_protocol",  buf,  0x16u);
        return 0LL;
      }
    }

    return 0LL;
  }

  nw_protocol_set_input_handler();
  if (!a3) {
    return 1LL;
  }
  int v11 = *(_DWORD *)(v8 + 5308);
  if ((v11 & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
        _os_log_impl( &dword_1879E5000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s tcp->release_is_delayed already set, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v12) {
      free(v12);
    }
    int v11 = *(_DWORD *)(v8 + 5308);
  }

  *(_DWORD *)(v8 + 5308) = v11 | 1;
  int v14 = *(_DWORD *)(v8 + 5224);
  if ((v14 - 1) >= 2)
  {
    if (!v14 || v14 == 4) {
      nw_protocol_tcp_release(v8);
    }
    return 1LL;
  }

  *(_DWORD *)(v8 + 5308) = v11 | 3;
  *(_DWORD *)(v8 + 5224) = 3;
  if ((*(_BYTE *)(v8 + 828) & 2) == 0)
  {
    os_log_type_t v15 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v22 = "nw_protocol_tcp_remove_input_handler";
      __int16 v23 = 2082;
      uint64_t v24 = v8 + 604;
      _os_log_impl(&dword_1879E5000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
    }
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 16LL))(v8, 1LL, v3);
  if ((~*(unsigned __int16 *)(v8 + 376) & 0x30) != 0 || (*(_BYTE *)(v8 + 365) & 0x20) != 0)
  {
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 372) |= 0x80u;
  }

  uint64_t v10 = 1LL;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 24LL))(v8, 1LL, v3);
  tcp_close_locked(v8);
  return v10;
}

void nw_protocol_tcp_input_available(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
    double v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      double v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      double v61 = "%{public}s called with null protocol";
    }

    else
    {
      double v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      double v61 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_127;
  }

  uint64_t v1 = nw_protocol_downcast();
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
    double v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    HIBYTE(v68) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      double v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      double v61 = "%{public}s called with null tcp";
    }

    else
    {
      double v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_128;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
      double v61 = "%{public}s called with null tcp, backtrace limit exceeded";
    }

LABEL_127:
    _os_log_impl(&dword_1879E5000, v59, v60, v61, buf, 0xCu);
LABEL_128:
    if (v58) {
      free(v58);
    }
    return;
  }

  uint64_t v2 = v1;
  if (*(_DWORD *)(v1 + 5224))
  {
    uint64_t v3 = (dispatch_once_t *)MEMORY[0x189608EE0];
    if (*MEMORY[0x189608EE0] != -1LL) {
      dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
    }
    unsigned int v64 = (int *)(v2 + 488);
    uint64_t v63 = v2 + 604;
    *(void *)os_log_type_t type = 0LL;
    uint64_t v66 = type;
    while (1)
    {
LABEL_11:
      nw_protocol_get_output_handler();
      unsigned int input_frames = nw_protocol_get_input_frames();
      if (!input_frames) {
        return;
      }
      unsigned int v5 = input_frames;
      if (*v3 != -1) {
        dispatch_once(v3, &__block_literal_global_16);
      }
      if (*MEMORY[0x189608ED8] && kdebug_is_enabled())
      {
        nw_frame_array_unclaimed_length();
        kdebug_trace();
      }

      if (v5 > tcp_input_batch_size)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          double v57 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v63;
            __int16 v70 = 1024;
            *(_DWORD *)v71 = tcp_input_batch_size;
            *(_WORD *)&v71[4] = 1024;
            *(_DWORD *)&v71[6] = v5;
            unsigned int v53 = "%{public}s %{public}s we asked for maximum %u frames, but got %u";
            __int16 v54 = v57;
            os_log_type_t v55 = OS_LOG_TYPE_ERROR;
            uint32_t v56 = 34;
LABEL_111:
            _os_log_impl(&dword_1879E5000, v54, v55, v53, buf, v56);
          }
        }

        return;
      }

      if ((*(_BYTE *)(v2 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v45 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            __int16 v70 = 1024;
            *(_DWORD *)v71 = v5;
            _os_log_impl( &dword_1879E5000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s input available and we got %d frames",  buf,  0x1Cu);
          }
        }
      }

      uint64_t v6 = *(uint64_t **)v2;
      if (!*(void *)v2)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v21 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_input_available";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v2 + 604;
              _os_log_impl( &dword_1879E5000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s inp == NULL || so->so_pcb == NULL",  buf,  0x16u);
            }
          }
        }

LABEL_51:
        for (uint64_t i = *(void **)type; ; uint64_t i = v24)
        {
LABEL_52:
          if (!i) {
            goto LABEL_11;
          }
          __int16 v23 = (void (*)(void *, void, uint64_t))i[10];
          uint64_t v24 = (void *)i[4];
          if (!v23) {
            break;
          }
          uint64_t v25 = i[11];
          i[10] = 0LL;
          i[11] = 0LL;
          v23(i, 0LL, v25);
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        __int128 v26 = (void *)_os_log_send_and_compose_impl();
        __int16 v68 = 4096;
        if (HIBYTE(v68) == 17)
        {
          int v27 = (os_log_s *)__nwlog_obj();
          os_log_type_t v28 = HIBYTE(v68);
          if (os_log_type_enabled(v27, HIBYTE(v68)))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            os_log_type_t v29 = v27;
            os_log_type_t v30 = v28;
            int v31 = "%{public}s called with null frame->finalizer";
            goto LABEL_68;
          }

          goto LABEL_69;
        }

        if ((_BYTE)v68)
        {
          backtrace_string = (void *)__nw_create_backtrace_string();
          __int16 v33 = (os_log_s *)__nwlog_obj();
          os_log_type_t v34 = HIBYTE(v68);
          log = v33;
          BOOL v35 = os_log_type_enabled(v33, HIBYTE(v68));
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_1879E5000,  log,  v34,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_69;
          }

          if (!v35)
          {
LABEL_69:
            if (v26) {
              free(v26);
            }
            uint64_t i = v24;
            goto LABEL_52;
          }

          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          os_log_type_t v29 = log;
          os_log_type_t v30 = v34;
          int v31 = "%{public}s called with null frame->finalizer, no backtrace";
        }

        else
        {
          uint64_t v36 = (os_log_s *)__nwlog_obj();
          os_log_type_t v37 = HIBYTE(v68);
          if (!os_log_type_enabled(v36, HIBYTE(v68))) {
            goto LABEL_69;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          os_log_type_t v29 = v36;
          os_log_type_t v30 = v37;
          int v31 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }

LABEL_68:
        _os_log_impl(&dword_1879E5000, v29, v30, v31, buf, 0xCu);
        goto LABEL_69;
      }

      char v7 = *(_BYTE *)(v2 + 828);
      if ((*(_BYTE *)(v2 + 364) & 8) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            int v51 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "tcp_input_available";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v2 + 604;
              __int16 v70 = 1024;
              *(_DWORD *)v71 = 57;
              _os_log_impl( &dword_1879E5000,  v51,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s defunct socket error (%d)",  buf,  0x1Cu);
            }
          }
        }

        goto LABEL_51;
      }

      uint64_t v8 = v3;
      if ((*(_BYTE *)(v2 + 828) & 1) == 0)
      {
        uint64_t v9 = nw_tcp_access_globals(v2);
        ++*(_DWORD *)(v9 + 288);
        uint64_t v10 = v6[28];
        if (*(void *)(v10 + 520))
        {
          if ((*(_BYTE *)(v10 + 828) & 2) == 0)
          {
            int v11 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_input_aggregate_begin";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v10 + 604;
              _os_log_impl( &dword_1879E5000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s tcp_input_aggregate_begin sb_mb_aggregate not empty",  buf,  0x16u);
            }
          }
        }
      }

      uint64_t v12 = v6[30];
      *(void *)(v12 + 656) = 0LL;
      *(void *)(v12 + 664) = v12 + 656;
      *(_DWORD *)(v12 + 672) = 0;
      uint64_t v13 = v6[28];
      if (!v13 || (*(_BYTE *)(v13 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          __int16 v46 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            int v47 = (const char *)(v13 + 604);
            if (!v13) {
              int v47 = "";
            }
            __int16 v48 = "on";
            if ((*(_DWORD *)(v12 + 740) & 0x2000000) == 0) {
              __int16 v48 = "off";
            }
            int v49 = tcpstates[*(int *)(v12 + 12)];
            int v50 = *(_DWORD *)(sysctls + 100);
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "tcp_output_batch_acks_begin";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v47;
            __int16 v70 = 2082;
            *(void *)v71 = v48;
            *(_WORD *)&v71[8] = 2082;
            __int16 v72 = v49;
            __int16 v73 = 1024;
            int v74 = v50;
            _os_log_impl( &dword_1879E5000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s t_state %{public}s tcp_packet_chaining %d",  buf,  0x30u);
          }
        }
      }

      int v14 = *(void **)type;
      if (!*(void *)type)
      {
        tcp_output_batch_acks_end((uint64_t)v6);
        goto LABEL_92;
      }

      char v15 = 0;
      char v16 = 0;
      char v17 = 0;
      do
      {
        *(void *)__int128 buf = 0LL;
        *(void *)&buf[8] = buf;
        do
        {
          uint64_t v18 = v14[4];
          __int16 v19 = (void *)v14[5];
          if (v18)
          {
            *(void *)(v18 + 40) = v19;
            __int16 v19 = (void *)v14[5];
          }

          else
          {
            uint64_t v66 = (os_log_type_t *)v14[5];
          }

          *__int16 v19 = v18;
          uint64_t v20 = *(void **)&buf[8];
          v14[4] = 0LL;
          v14[5] = v20;
          *uint64_t v20 = v14;
          *(void *)&buf[8] = v14 + 4;
          int v14 = *(void **)type;
        }

        while (*(void *)type && (*(_WORD *)(*(void *)type + 204LL) & 0x40) != 0);
        __int16 v68 = 0;
        BOOL v67 = 0;
        tcp_input((uint64_t *)buf, v6[56], (uint64_t)v6, (_BYTE *)&v68 + 1, &v68, &v67);
        v16 |= (_BYTE)v68 != 0;
        v15 |= HIBYTE(v68) != 0;
        v17 |= v67;
        int v14 = *(void **)type;
      }

      while (*(void *)type);
      tcp_output_batch_acks_end((uint64_t)v6);
      if ((v16 & 1) != 0)
      {
        uint64_t v38 = *(void *)(v2 + 32);
        if (v38)
        {
          __int128 v39 = *(void (**)(uint64_t))(v38 + 48);
          if (v39) {
            v39(v2);
          }
        }
      }

      if ((v17 & 1) == 0) {
        goto LABEL_91;
      }
      if ((*(_DWORD *)(v2 + 552) && (uint64_t v40 = v2 + 528, *(void *)(v2 + 520))
         || *v64 && (uint64_t v40 = v2 + 512, *(void *)(v2 + 504)))
        && (uint64_t v41 = **(void **)(*(void *)v40 + 8LL)) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          int v42 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            _os_log_impl( &dword_1879E5000,  v42,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s found data to carry wake packet",  buf,  0x16u);
          }
        }

        *(_WORD *)(v41 + 204) |= 0x4000u;
        if ((v15 & 1) != 0) {
          goto LABEL_10;
        }
LABEL_92:
        uint64_t v3 = v8;
        if ((v7 & 1) == 0)
        {
          uint64_t v44 = nw_tcp_access_globals(v2);
          tcp_coalesce_timer_updates_end(v44);
          tcp_input_aggregate_end(v6[28], v6[30]);
        }
      }

      else
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0)
        {
          uint64_t v43 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_input_carry_wake_packet";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v2 + 604;
            _os_log_impl( &dword_1879E5000,  v43,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s no data to carry wake packet",  buf,  0x16u);
          }
        }

LABEL_91:
        if ((v15 & 1) == 0) {
          goto LABEL_92;
        }
LABEL_10:
        *(_BYTE *)(v2 + 828) |= 1u;
        uint64_t v3 = v8;
      }
    }
  }

  if ((*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v52 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_input_available";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v2 + 604;
        unsigned int v53 = "%{public}s %{public}s skipping";
        __int16 v54 = v52;
        os_log_type_t v55 = OS_LOG_TYPE_DEBUG;
        uint32_t v56 = 22;
        goto LABEL_111;
      }
    }
  }

void nw_protocol_tcp_input_flush(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((*(_BYTE *)(v1 + 828) & 1) != 0)
      {
        uint64_t v3 = *(void *)v1;
        uint64_t v4 = nw_tcp_access_globals(v1);
        tcp_coalesce_timer_updates_end(v4);
        uint64_t v5 = *(void *)(v2 + 32);
        if (v5)
        {
          uint64_t v6 = *(void (**)(uint64_t))(v5 + 24);
          if (v6) {
            v6(v2);
          }
        }

        if (v3) {
          tcp_input_aggregate_end(*(void *)(v3 + 224), *(void *)(v3 + 240));
        }
        *(_BYTE *)(v2 + 828) &= ~1u;
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v11 = "nw_protocol_tcp_input_flush";
    char v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v11 = "nw_protocol_tcp_input_flush";
        uint64_t v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v11 = "nw_protocol_tcp_input_flush";
    char v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v11 = "nw_protocol_tcp_input_flush";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }

  if (v7) {
    free(v7);
  }
}

void nw_protocol_tcp_output_available(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((*(_DWORD *)(v1 + 5224) | 4) == 4 || (*(_BYTE *)(v1 + 5308) & 0x20) != 0)
      {
        if ((*(_BYTE *)(v1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 136446466;
              uint64_t v9 = "nw_protocol_tcp_output_available";
              __int16 v10 = 2082;
              uint64_t v11 = v2 + 604;
              _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
            }
          }
        }
      }

      else if (*(_DWORD *)(*(void *)v1 + 460LL))
      {
        if ((*(_BYTE *)(v1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          char v7 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v9 = "nw_protocol_tcp_output_available";
            __int16 v10 = 2082;
            uint64_t v11 = v2 + 604;
            _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s restarting TCP output on output available",  buf,  0x16u);
          }
        }

        tcp_output(*(void *)(*(void *)v2 + 240LL));
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v9 = "nw_protocol_tcp_output_available";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v9 = "nw_protocol_tcp_output_available";
        uint64_t v6 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v9 = "nw_protocol_tcp_output_available";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v9 = "nw_protocol_tcp_output_available";
        uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_22:
        _os_log_impl(&dword_1879E5000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }

  if (v3) {
    free(v3);
  }
}

uint64_t nw_protocol_tcp_get_input_frames( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, void **a6)
{
  uint64_t v155 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    __int16 v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (BYTE4(v144[0]) == 17)
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null protocol";
    }

    else
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_234;
  }

  uint64_t v12 = nw_protocol_downcast();
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    __int16 v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (BYTE4(v144[0]) == 17)
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null tcp";
    }

    else
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v95, BYTE4(v144[0]))) {
        goto LABEL_143;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      v71 = "%{public}s called with null tcp, backtrace limit exceeded";
    }

LABEL_234:
    int v74 = v95;
    os_log_type_t v75 = v96;
    uint32_t v76 = 12;
    goto LABEL_142;
  }

  uint64_t v13 = v12;
  unsigned int v14 = *(_DWORD *)(v12 + 5224);
  if (v14 <= 1)
  {
    if ((*(_BYTE *)(v12 + 828) & 2) != 0) {
      return 0LL;
    }
    char v15 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    char v16 = "%{public}s %{public}s skipping";
    goto LABEL_8;
  }

  if (v14 != 2)
  {
    if (!*(_DWORD *)(v12 + 488))
    {
      if ((*(_BYTE *)(v12 + 828) & 2) != 0) {
        return 0LL;
      }
      char v15 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        return 0LL;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      char v16 = "%{public}s %{public}s past connected state, skipping";
LABEL_8:
      _os_log_impl(&dword_1879E5000, v15, OS_LOG_TYPE_DEBUG, v16, buf, 0x16u);
      return 0LL;
    }

    if ((*(_BYTE *)(v12 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v103 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          _os_log_impl( &dword_1879E5000,  v103,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s allowing read past connected state",  buf,  0x16u);
        }
      }
    }
  }

  if (*(_DWORD *)(v13 + 492) < a3)
  {
    if ((*(_BYTE *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v101 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
        {
          int v102 = *(_DWORD *)(v13 + 492);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v147 = a3;
          *(_WORD *)&v147[4] = 1024;
          *(_DWORD *)v148 = v102;
          _os_log_impl( &dword_1879E5000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s capping minimum_bytes %u to sb_hiwat %u",  buf,  0x22u);
        }
      }
    }

    a3 = *(_DWORD *)(v13 + 492);
  }

  uint64_t v17 = *(void *)(v13 + 8);
  uint64_t v18 = *(os_log_s **)(*(void *)v13 + 240LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 16))(v13, 1LL, v6);
  if (*(_DWORD *)(v13 + 360) == 1)
  {
    if ((*(_BYTE *)(v13 + 828) & 2) != 0) {
      goto LABEL_126;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    __int16 v19 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (BYTE4(v144[0]) == 17)
    {
      uint64_t v20 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0]))) {
        goto LABEL_54;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      uint64_t v22 = "%{public}s %{public}s no other reference on socket";
    }

    else
    {
      uint64_t v20 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v21 = BYTE4(v144[0]);
      if (!os_log_type_enabled(v20, BYTE4(v144[0]))) {
        goto LABEL_54;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v13 + 604;
      uint64_t v22 = "%{public}s %{public}s no other reference on socket, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v20, v21, v22, buf, 0x16u);
LABEL_54:
    if (v19) {
      free(v19);
    }
    goto LABEL_126;
  }

  __int16 v23 = (unsigned int *)(v13 + 488);
  if ((*(_BYTE *)(v13 + 364) & 8) != 0)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 57;
    if ((*(_BYTE *)(v13 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v104 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v13 + 604;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v147 = 57;
          _os_log_impl( &dword_1879E5000,  v104,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s defunct socket error (%d)",  buf,  0x1Cu);
        }
      }
    }

    goto LABEL_125;
  }

  if ((*(_BYTE *)(v13 + 368) & 0x20) != 0)
  {
    uint64_t v24 = *(uint64_t (**)(uint64_t))(*(void *)(v17 + 40) + 88LL);
    if (v24)
    {
      int v25 = v24(v13);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v25;
      if (v25)
      {
LABEL_125:
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 + 8) + 24LL))(v13, 1LL, v6);
        goto LABEL_126;
      }
    }
  }

  if ((~*(unsigned __int16 *)(v13 + 376) & 0x21) == 0 && (*(_BYTE *)(v13 + 367) & 1) == 0)
  {
    __int128 v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 45;
LABEL_124:
    *__int128 v26 = v27;
    goto LABEL_125;
  }

  unsigned int v28 = *v23;
  if (*v23 < a3 && v28 < *(_DWORD *)(v13 + 496)) {
    goto LABEL_123;
  }
  unsigned int v29 = v28 >= a4 ? a4 : *v23;
  if (!v29) {
    goto LABEL_123;
  }
  os_log_t v130 = v18;
  uint64_t v30 = *(void *)(v13 + 504);
  unsigned int v138 = v29;
  if (!v30)
  {
    int v129 = a5;
    goto LABEL_58;
  }

  int v31 = (uint64_t *)(v13 + 504);
  if (*(_DWORD *)(v13 + 824) != -1)
  {
    int v129 = a5;
    unsigned int v32 = *(_DWORD *)(v13 + 552);
    unsigned int v33 = v28 - v32;
    if (v28 > v32 && v33 <= v29)
    {
      *a6[1] = v30;
      *(void *)(*(void *)(v13 + 504) + 40LL) = a6[1];
      a6[1] = *(void **)(v13 + 512);
      *(void *)(v13 + 504) = 0LL;
      *(void *)(v13 + 512) = v31;
      goto LABEL_50;
    }

    unsigned int v124 = (unsigned int *)(v13 + 488);
    uint64_t v34 = 0LL;
    unsigned int v33 = 0;
    unsigned int v78 = v29;
    while (1)
    {
      unsigned int v79 = *(_DWORD *)(v30 + 52);
      if (v79) {
        v79 -= *(_DWORD *)(v30 + 56) + *(_DWORD *)(v30 + 60);
      }
      signed int v80 = v78 - v79;
      if (v78 < v79) {
        break;
      }
      uint64_t v82 = *(void *)(v30 + 32);
      int v83 = *(void **)(v30 + 40);
      uint64_t v81 = (void *)(v30 + 32);
      if (v82)
      {
        *(void *)(v82 + 40) = v83;
        int v83 = *(void **)(v30 + 40);
      }

      else
      {
        *(void *)(v13 + 512) = v83;
      }

      v33 += v79;
      *int v83 = v82;
      *uint64_t v81 = 0LL;
      *(void *)(v30 + 40) = 0LL;
      size_t v84 = a6[1];
      *(void *)(v30 + 40) = v84;
      *size_t v84 = v30;
      a6[1] = v81;
      uint64_t v34 = (v34 + 1);
      uint64_t v30 = *v31;
      if (*v31)
      {
        unsigned int v78 = v80;
        if (v80) {
          continue;
        }
      }

      goto LABEL_167;
    }

    signed int v80 = v78;
LABEL_167:
    if (!v30 || !v80)
    {
      __int16 v23 = (unsigned int *)(v13 + 488);
      goto LABEL_59;
    }

    os_log_t v126 = (os_log_t)(v13 + 504);
    unsigned int v136 = v33;
    uint64_t v89 = nw_protocol_tcp_copy_frame(v13, v30, v80);
    if (v89)
    {
      uint64_t v90 = v89;
      if ((*(_WORD *)(v30 + 204) & 0x80) != 0) {
        *(_WORD *)(v30 + 196) -= v80;
      }
      unsigned int v91 = *(_DWORD *)(v30 + 56) + v80;
      if (v91 <= *(_DWORD *)(v30 + 52) - *(_DWORD *)(v30 + 60))
      {
        *(_DWORD *)(v30 + 56) = v91;
      }

      else
      {
        int v120 = *(_DWORD *)(v30 + 56) + v80;
        int v123 = *(_DWORD *)(v30 + 60);
        os_log_t v131 = (os_log_t)v89;
        v127 = (os_log_s *)__nwlog_obj();
        BOOL v92 = os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
        uint64_t v90 = (uint64_t)v131;
        if (v92)
        {
          int v93 = *(_DWORD *)(v30 + 52);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v120;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v93;
          *(_WORD *)v147 = 1024;
          *(_DWORD *)&v147[2] = v123;
          _os_log_impl( &dword_1879E5000,  v127,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
          uint64_t v90 = (uint64_t)v131;
        }
      }

      *(void *)(v90 + 32) = 0LL;
      unsigned int v33 = v136 + v80;
      v94 = a6[1];
      *(void *)(v90 + 40) = v94;
      uint64_t *v94 = v90;
      a6[1] = (void *)(v90 + 32);
      uint64_t v34 = (v34 + 1);
LABEL_187:
      __int16 v23 = v124;
      unsigned int v29 = v138;
      goto LABEL_59;
    }

    if (*(void *)v126)
    {
      *a6[1] = *(void *)v126;
      *(void *)(*(void *)(v13 + 504) + 40LL) = a6[1];
      a6[1] = *(void **)(v13 + 512);
      *(void *)(v13 + 504) = 0LL;
      *(void *)(v13 + 512) = v126;
    }

    if (*a6)
    {
      **(void **)(v13 + 512) = *a6;
      (*a6)[5] = *(void *)(v13 + 512);
      *(void *)(v13 + 512) = a6[1];
      *a6 = 0LL;
      a6[1] = a6;
    }

    if ((*(_WORD *)(v30 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v30, *(void *)(v30 + 88)) & 1) == 0)
    {
      *((void *)v130 + 132) = 0LL;
    }

    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 55;
LABEL_126:
    int v66 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v66 == 35)
    {
      nw_protocol_tcp_set_receive_low_water_mark(a1, a3);
      return 0LL;
    }

    __nwlog_obj();
    uint64_t v67 = v13 + 604;
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v13 + 604;
    *(_WORD *)&_BYTE buf[22] = 1024;
    *(_DWORD *)v147 = v66;
    __int16 v68 = (void *)_os_log_send_and_compose_impl();
    BYTE4(v144[0]) = 16;
    LOBYTE(v144[0]) = 0;
    if (__nwlog_fault())
    {
      if (BYTE4(v144[0]) == 17)
      {
        int v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0]))) {
          goto LABEL_143;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d";
        goto LABEL_141;
      }

      if (!LOBYTE(v144[0]))
      {
        int v69 = (os_log_s *)__nwlog_obj();
        os_log_type_t v70 = BYTE4(v144[0]);
        if (!os_log_type_enabled(v69, BYTE4(v144[0]))) {
          goto LABEL_143;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_141;
      }

      backtrace_string = (void *)__nw_create_backtrace_string();
      int v69 = (os_log_s *)__nwlog_obj();
      os_log_type_t v70 = BYTE4(v144[0]);
      BOOL v73 = os_log_type_enabled(v69, BYTE4(v144[0]));
      if (backtrace_string)
      {
        if (v73)
        {
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v67;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v147 = v66;
          *(_WORD *)&v147[4] = 2082;
          *(void *)v148 = backtrace_string;
          _os_log_impl( &dword_1879E5000,  v69,  v70,  "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
        }

        free(backtrace_string);
        goto LABEL_143;
      }

      if (v73)
      {
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v67;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v147 = v66;
        v71 = "%{public}s %{public}s tcp_get_northbound_frame, returned NULL %{darwin.errno}d, no backtrace";
LABEL_141:
        int v74 = v69;
        os_log_type_t v75 = v70;
        uint32_t v76 = 28;
LABEL_142:
        _os_log_impl(&dword_1879E5000, v74, v75, v71, buf, v76);
      }
    }

LABEL_143:
    if (v68) {
      free(v68);
    }
    return 0LL;
  }

  os_log_t v125 = (os_log_t)(v13 + 504);
  *(void *)((char *)v144 + 4) = 0LL;
  *(void *)((char *)&v144[1] + 4) = (char *)v144 + 4;
  if (!nw_protocol_tcp_get_frames(v13, v29, (uint64_t)v144 + 4, 1, 0LL, 0))
  {
    __int128 v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 12;
    goto LABEL_124;
  }

  uint64_t v39 = *(void *)((char *)v144 + 4);
  int v129 = a5;
  if (!*(void *)((char *)v144 + 4))
  {
    unsigned int v124 = (unsigned int *)(v13 + 488);
    int v106 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
    v107 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result)
    {
      __break(1u);
      return result;
    }

    free(v107);
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
    v108 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v144[0]) = 16;
    char v145 = 0;
    if (LOBYTE(v144[0]) == 17)
    {
      v109 = (os_log_s *)__nwlog_obj();
      os_log_type_t v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame";
LABEL_253:
        uint64_t v114 = v109;
LABEL_254:
        _os_log_impl(&dword_1879E5000, v114, v110, v111, buf, 0xCu);
      }
    }

    else if (v145)
    {
      v112 = (void *)__nw_create_backtrace_string();
      os_log_type_t v110 = v144[0];
      uint64_t v133 = (os_log_s *)__nwlog_obj();
      BOOL v113 = os_log_type_enabled(v133, v144[0]);
      if (v112)
      {
        if (v113)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v112;
          _os_log_impl( &dword_1879E5000,  v133,  v144[0],  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v112);
        goto LABEL_255;
      }

      if (v113)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, no backtrace";
        uint64_t v114 = v133;
        goto LABEL_254;
      }
    }

    else
    {
      v109 = (os_log_s *)__nwlog_obj();
      os_log_type_t v110 = v144[0];
      if (os_log_type_enabled(v109, v144[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaimed_bytes";
        v111 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_253;
      }
    }

LABEL_255:
    if (v108) {
      free(v108);
    }
    unsigned int v33 = 0;
    uint64_t v34 = 0LL;
    goto LABEL_187;
  }

  unsigned int v29 = v138;
  if ((*(_WORD *)(*(void *)((char *)v144 + 4) + 204LL) & 0x100) != 0)
  {
    if (*MEMORY[0x189608EF8])
    {
      uint64_t v121 = *(void *)((char *)v144 + 4);
      int v40 = ((uint64_t (*)(void, void))*MEMORY[0x189608EF8])( *(void *)((char *)v144 + 4),  *(void *)(*(void *)((char *)v144 + 4) + 88LL));
      uint64_t v39 = v121;
      unsigned int v29 = v138;
      if (!v40) {
        goto LABEL_58;
      }
    }
  }

  int v41 = *(_DWORD *)(v39 + 52);
  if (!v41)
  {
    unsigned int v33 = 0;
    uint64_t v34 = 0LL;
    if (*(void *)(v39 + 112)) {
      goto LABEL_240;
    }
    goto LABEL_59;
  }

  uint64_t v42 = *(void *)(v39 + 112);
  if (!v42)
  {
LABEL_58:
    unsigned int v33 = 0;
    uint64_t v34 = 0LL;
    goto LABEL_59;
  }

  uint64_t v122 = v39;
  uint64_t v43 = *(unsigned int *)(v39 + 56);
  unsigned int v44 = v41 - (v43 + *(_DWORD *)(v39 + 60));
  if (!v44 || !v130)
  {
    unsigned int v33 = 0;
    __int16 v23 = (unsigned int *)(v13 + 488);
    goto LABEL_239;
  }

  unsigned int v33 = 0;
  uint64_t v119 = v42 + v43;
  while (1)
  {
    unsigned int v134 = v33;
    if (!*(void *)(v30 + 112)) {
      break;
    }
    if ((*(_WORD *)(v30 + 204) & 0x100) != 0)
    {
      if (*MEMORY[0x189608EF8])
      {
        int v45 = ((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v30, *(void *)(v30 + 88));
        unsigned int v29 = v138;
        if (!v45) {
          break;
        }
      }
    }

    int v47 = *(_DWORD *)(v30 + 52);
    uint64_t v46 = *(unsigned int *)(v30 + 56);
    unsigned int v48 = v47 ? v47 - (v46 + *(_DWORD *)(v30 + 60)) : 0;
    uint64_t v49 = *(void *)(v30 + 112);
    if (!v49) {
      break;
    }
    unsigned int v50 = v44 - v48;
    if (v44 < v48) {
      goto LABEL_206;
    }
    unsigned int v51 = v48;
    memcpy((void *)(v119 + v134), (const void *)(v49 + v46), v48);
    uint64_t v52 = *(void *)(v30 + 32);
    unsigned int v53 = *(void **)(v30 + 40);
    if (v52)
    {
      *(void *)(v52 + 40) = v53;
      unsigned int v53 = *(void **)(v30 + 40);
    }

    else
    {
      *(void *)(v13 + 512) = v53;
    }

    *unsigned int v53 = v52;
    __int16 v54 = *(void (**)(uint64_t, uint64_t, uint64_t))(v30 + 80);
    *(void *)(v30 + 32) = 0LL;
    *(void *)(v30 + 40) = 0LL;
    if (!v54)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      uint64_t v56 = _os_log_send_and_compose_impl();
      LOBYTE(v144[0]) = 16;
      char v145 = 0;
      v118 = (void *)v56;
      if (LOBYTE(v144[0]) == 17)
      {
        log = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(log, v144[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          double v57 = log;
          os_log_type_t v58 = v144[0];
          double v59 = "%{public}s called with null frame->finalizer";
          goto LABEL_106;
        }

        goto LABEL_107;
      }

      if (v145)
      {
        os_log_type_t v60 = (void *)__nw_create_backtrace_string();
        loga = (os_log_s *)__nwlog_obj();
        BOOL v61 = os_log_type_enabled(loga, v144[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v60;
            _os_log_impl( &dword_1879E5000,  loga,  v144[0],  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v60);
          goto LABEL_107;
        }

        if (!v61)
        {
LABEL_107:
          if (v118) {
            free(v118);
          }
          goto LABEL_90;
        }

        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        double v57 = loga;
        os_log_type_t v58 = v144[0];
        double v59 = "%{public}s called with null frame->finalizer, no backtrace";
      }

      else
      {
        logb = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(logb, v144[0])) {
          goto LABEL_107;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        double v57 = logb;
        os_log_type_t v58 = v144[0];
        double v59 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }

LABEL_106:
      _os_log_impl(&dword_1879E5000, v57, v58, v59, buf, 0xCu);
      goto LABEL_107;
    }

    uint64_t v55 = *(void *)(v30 + 88);
    *(void *)(v30 + 80) = 0LL;
    *(void *)(v30 + 88) = 0LL;
    v54(v30, 1LL, v55);
LABEL_90:
    unsigned int v33 = v51 + v134;
    uint64_t v30 = *(void *)v125;
    unsigned int v29 = v138;
    if (*(void *)v125)
    {
      unsigned int v44 = v50;
      if (v50) {
        continue;
      }
    }

    goto LABEL_208;
  }

  if ((*(_WORD *)(v30 + 204) & 0x100) == 0)
  {
LABEL_206:
    unsigned int v50 = v44;
    goto LABEL_207;
  }

  if (*MEMORY[0x189608EF8]
    && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v30, *(void *)(v30 + 88)) & 1) == 0)
  {
    *((void *)v130 + 132) = 0LL;
  }

  unsigned int v50 = v44;
  unsigned int v29 = v138;
LABEL_207:
  unsigned int v33 = v134;
LABEL_208:
  if (v30 && v50)
  {
    unsigned int v137 = v33;
    uint64_t v97 = *(void *)(v30 + 112);
    if (v97
      && ((*(_WORD *)(v30 + 204) & 0x100) == 0
       || !*MEMORY[0x189608EF8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v30, *(void *)(v30 + 88))
       && (uint64_t v97 = *(void *)(v30 + 112)) != 0))
    {
      memcpy((void *)(v119 + v137), (const void *)(v97 + *(unsigned int *)(v30 + 56)), v50);
      if ((*(_WORD *)(v30 + 204) & 0x80) != 0) {
        *(_WORD *)(v30 + 196) -= v50;
      }
      unsigned int v132 = v50;
      unsigned int v98 = *(_DWORD *)(v30 + 56) + v50;
      int v99 = *(_DWORD *)(v30 + 60);
      if (v98 <= *(_DWORD *)(v30 + 52) - v99)
      {
        *(_DWORD *)(v30 + 56) = v98;
      }

      else
      {
        v128 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
        {
          int v100 = *(_DWORD *)(v30 + 52);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v98;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v100;
          *(_WORD *)v147 = 1024;
          *(_DWORD *)&v147[2] = v99;
          _os_log_impl( &dword_1879E5000,  v128,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
        }
      }

      unsigned int v33 = v137 + v132;
      __int16 v23 = (unsigned int *)(v13 + 488);
      unsigned int v29 = v138;
    }

    else
    {
      if ((*(_WORD *)(v30 + 204) & 0x100) != 0
        && *MEMORY[0x189608EF8]
        && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v30, *(void *)(v30 + 88)) & 1) == 0)
      {
        *((void *)v130 + 132) = 0LL;
      }

      __int16 v23 = (unsigned int *)(v13 + 488);
      unsigned int v29 = v138;
      unsigned int v33 = v137;
    }
  }

  else
  {
    __int16 v23 = (unsigned int *)(v13 + 488);
  }

          v47 -= 2;
          if (v47 < v72) {
            return;
          }
LABEL_109:
          if (!v51) {
            return;
          }
        }
      }
    }
  }

LABEL_239:
  uint64_t v39 = v122;
LABEL_240:
  *(void *)(v39 + 32) = 0LL;
  v105 = a6[1];
  *(void *)(v39 + 40) = v105;
  void *v105 = v39;
  a6[1] = (void *)(v39 + 32);
LABEL_50:
  uint64_t v34 = 1LL;
LABEL_59:
  BOOL v35 = v29 >= v33;
  unsigned int v36 = v29 - v33;
  if (v36 != 0 && v35)
  {
    unsigned int v37 = v33;
    v144[0] = 0LL;
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    if (tcp_input_get_aggregate_frames(v13, v36, (_DWORD *)v144 + 1, v144, (uint64_t)buf))
    {
      if (*(void *)buf)
      {
        *a6[1] = *(void *)buf;
        uint64_t v38 = *(void **)&buf[8];
        *(void *)(*(void *)buf + 40LL) = a6[1];
        a6[1] = v38;
      }

      unsigned int v33 = HIDWORD(v144[0]) + v37;
      uint64_t v34 = (LODWORD(v144[0]) + v34);
    }

    else
    {
      unsigned int v33 = v37;
    }
  }

  if (!v33)
  {
LABEL_123:
    __int128 v26 = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    int v27 = 35;
    goto LABEL_124;
  }

  unsigned int v135 = v33;
  *(_DWORD *)(v13 + 488) -= v33;
  if (*(void *)(v13 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 92) = *v23;
    }
  }

  uint64_t v63 = v23;
  if (*(void *)v13) {
    (*(void (**)(uint64_t, void))(*(void *)(v17 + 40) + 56LL))(v13, 0LL);
  }
  if (v138 != v135)
  {
    unsigned int v64 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_get_northbound_frames";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v138;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v135;
      _os_log_impl( &dword_1879E5000,  v64,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to copy expected bytes, total_space %u != adj_space %u",  buf,  0x18u);
    }
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v13 + 8) + 24LL))(v13, 1LL, v6);
  if ((v138 & 0x80000000) != 0) {
    goto LABEL_126;
  }
  if (*(void *)(v13 + 5232))
  {
    nw_protocol_tcp_update_metadata(a1);
    BOOL v65 = (*(_WORD *)(v13 + 376) & 0x20) != 0 && *v63 == 0;
    v139[0] = MEMORY[0x1895F87A8];
    v139[1] = 0x40000000LL;
    v140 = __nw_protocol_tcp_get_input_frames_block_invoke;
    v141 = &__block_descriptor_tmp_25;
    uint64_t v142 = v13;
    BOOL v143 = v65;
    uint64_t v85 = (uint64_t)*a6;
    do
    {
      if (!v85) {
        break;
      }
      uint64_t v86 = *(void *)(v85 + 32);
      char v87 = ((uint64_t (*)(void *))v140)(v139);
      uint64_t v85 = v86;
    }

    while ((v87 & 1) != 0);
  }

  nw_protocol_tcp_set_receive_low_water_mark(a1, 1);
  if ((*(_BYTE *)(v13 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unsigned int v88 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136448002;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_input_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v13 + 604;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v147 = a3;
        *(_WORD *)&v147[4] = 1024;
        *(_DWORD *)v148 = a4;
        *(_WORD *)&v148[4] = 1024;
        *(_DWORD *)&v148[6] = v129;
        __int16 v149 = 1024;
        int v150 = v34;
        __int16 v151 = 1024;
        unsigned int v152 = v135;
        __int16 v153 = 1024;
        unsigned int v154 = v138;
        _os_log_impl( &dword_1879E5000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Asked for min %u max %u bytes, max %u frames and got %d frames %u bytes, ret %u",  buf,  0x3Au);
      }
    }
  }

  return v34;
}

uint64_t nw_protocol_tcp_get_output_frames( uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
    unsigned int v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      signed int v80 = (os_log_s *)__nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      int v40 = "%{public}s called with null protocol";
    }

    else
    {
      signed int v80 = (os_log_s *)__nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      int v40 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_178;
  }

  uint64_t v11 = nw_protocol_downcast();
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
    unsigned int v37 = (void *)_os_log_send_and_compose_impl();
    v92[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (v92[0] == OS_LOG_TYPE_FAULT)
    {
      signed int v80 = (os_log_s *)__nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      int v40 = "%{public}s called with null tcp";
    }

    else
    {
      signed int v80 = (os_log_s *)__nwlog_obj();
      os_log_type_t v81 = v92[0];
      if (!os_log_type_enabled(v80, v92[0])) {
        goto LABEL_100;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      int v40 = "%{public}s called with null tcp, backtrace limit exceeded";
    }

LABEL_178:
    double v59 = v80;
    os_log_type_t v60 = v81;
    uint32_t v61 = 12;
    goto LABEL_99;
  }

  uint64_t v12 = v11;
  if (*(_DWORD *)(v11 + 5224) == 2)
  {
    if (a5)
    {
      int v13 = *(_DWORD *)(v11 + 5308);
      if ((v13 & 0xC00) == 0x400)
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 124) |= 0x400u;
        }
        int v13 = *(_DWORD *)(v12 + 5308) | 0x800;
        *(_DWORD *)(v12 + 5308) = v13;
      }

    int v43 = v35;
    int v44 = v36;
    goto LABEL_131;
  }

  if (nw_tcp_options_get_enable_background_traffic_management())
  {
    unsigned int v37 = tcp_set_background_management(a1);
    if (v37)
    {
      uint64_t v38 = v37;
      __nwlog_obj();
      os_log_type_t v39 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v38;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = v39;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v38;
        uint64_t v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d";
      }

      else
      {
        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = v39;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v38;
        uint64_t v11 = "%{public}s %{public}s tcp_set_background_management failed %{darwin.errno}d, backtrace limit exceeded";
      }

      goto LABEL_178;
    }
  }

  if (nw_tcp_options_get_enable_keepalive())
  {
    int v40 = tcp_set_keepalive(a1, 1);
    if (v40)
    {
      int v41 = v40;
      __nwlog_obj();
      BOOL v42 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v41;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = v42;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v41;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d";
      }

      else
      {
        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = v42;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v41;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive failed %{darwin.errno}d, backtrace limit exceeded";
      }

      goto LABEL_178;
    }

    keepalive_idle_time = nw_tcp_options_get_keepalive_idle_time();
    if (keepalive_idle_time)
    {
      unsigned int v47 = tcp_set_keepalive_idle_time(a1, keepalive_idle_time);
      if (v47)
      {
        int v48 = v47;
        __nwlog_obj();
        BOOL v49 = a1 + 604;
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v48;
        uint64_t v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v35 = (os_log_s *)__nwlog_obj();
          int v36 = type[0];
          if (!os_log_type_enabled(v35, type[0])) {
            goto LABEL_132;
          }
          goto LABEL_142;
        }

        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
        goto LABEL_171;
      }
    }

    keepalive_interval = nw_tcp_options_get_keepalive_interval();
    if (keepalive_interval)
    {
      unsigned int v51 = tcp_set_keepalive_interval(a1, keepalive_interval);
      if (v51)
      {
        int v48 = v51;
        __nwlog_obj();
        BOOL v49 = a1 + 604;
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v48;
        uint64_t v8 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v114[0] = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v35 = (os_log_s *)__nwlog_obj();
          int v36 = type[0];
          if (!os_log_type_enabled(v35, type[0])) {
            goto LABEL_132;
          }
LABEL_142:
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
          os_log_type_t v117 = 2082;
          *(void *)v118 = v49;
          *(_WORD *)&v118[8] = 1024;
          LODWORD(v119) = v48;
          uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d";
          goto LABEL_178;
        }

        int v35 = (os_log_s *)__nwlog_obj();
        int v36 = type[0];
        if (!os_log_type_enabled(v35, type[0])) {
          goto LABEL_132;
        }
LABEL_171:
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = v49;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v48;
        uint64_t v11 = "%{public}s %{public}s tcp_set_keepalive_idle_time failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_178;
      }
    }

    *(_DWORD *)os_log_type_t type = nw_tcp_options_get_keepalive_count();
    int v52 = tcp_setsockopt(a1, 6, 258, (int *)type);
    if (v52)
    {
      uint64_t v53 = v52;
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v53;
      uint64_t v54 = (void *)_os_log_send_and_compose_impl();
      v114[0] = OS_LOG_TYPE_ERROR;
      v113[0] = OS_LOG_TYPE_DEFAULT;
      if (v114[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v55 = (os_log_s *)__nwlog_obj();
        int v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0])) {
          goto LABEL_180;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v53;
        int v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
      }

      else
      {
        uint64_t v55 = (os_log_s *)__nwlog_obj();
        int v56 = v114[0];
        if (!os_log_type_enabled(v55, v114[0])) {
          goto LABEL_180;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        os_log_type_t v117 = 2082;
        *(void *)v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v53;
        int v57 = "%{public}s %{public}s tcp_setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v55, v56, v57, buf, 0x1Cu);
LABEL_180:
      if (v54) {
        free(v54);
      }
    }
  }

  *(_DWORD *)os_log_type_t type = 1;
  double v62 = tcp_setsockopt(a1, 6, 259, (int *)type);
  if (!v62) {
    goto LABEL_193;
  }
  uint64_t v63 = v62;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  os_log_type_t v117 = 2082;
  *(void *)v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v63;
  os_log_type_t v64 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v65 = (os_log_s *)__nwlog_obj();
      unsigned int v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0])) {
        goto LABEL_191;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v63;
      uint64_t v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d";
    }

    else
    {
      BOOL v65 = (os_log_s *)__nwlog_obj();
      unsigned int v66 = v114[0];
      if (!os_log_type_enabled(v65, v114[0])) {
        goto LABEL_191;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      os_log_type_t v117 = 2082;
      *(void *)v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v63;
      uint64_t v67 = "%{public}s %{public}s tcp_setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v65, v66, v67, buf, 0x1Cu);
  }

LABEL_15:
      *(_DWORD *)BOOL v92 = 0;
      if ((*(_BYTE *)(v12 + 364) & 8) != 0)
      {
        if ((*(_BYTE *)(v12 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          uint64_t v85 = (os_log_s *)__nwlog_tcp_log();
          int v22 = 32;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)&_BYTE buf[24] = 32;
            _os_log_impl( &dword_1879E5000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s defunct flow error (%d)",  buf,  0x1Cu);
          }

          goto LABEL_28;
        }
      }

      else
      {
        __int16 v21 = *(_WORD *)(v12 + 376);
        if ((v21 & 0x10) == 0)
        {
          int v22 = *(unsigned __int16 *)(v12 + 378);
          if (*(_WORD *)(v12 + 378))
          {
            *(_WORD *)(v12 + 378) = 0;
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)&_BYTE buf[24] = v22;
            __int16 v23 = (void *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v93 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              uint64_t v24 = (os_log_s *)__nwlog_obj();
              os_log_type_t v25 = type;
              if (!os_log_type_enabled(v24, type)) {
                goto LABEL_115;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)&_BYTE buf[24] = v22;
              __int128 v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d";
            }

            else
            {
              uint64_t v24 = (os_log_s *)__nwlog_obj();
              os_log_type_t v25 = type;
              if (!os_log_type_enabled(v24, type)) {
                goto LABEL_115;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)&_BYTE buf[24] = v22;
              __int128 v26 = "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded";
            }

            _os_log_impl(&dword_1879E5000, v24, v25, v26, buf, 0x1Cu);
LABEL_115:
            if (v23) {
              free(v23);
            }
            goto LABEL_28;
          }

          if ((v21 & 2) == 0 && a4 && (*(_WORD *)(v12 + 376) & 0x400) == 0 && (*(_BYTE *)(v12 + 368) & 0x20) == 0)
          {
            int v22 = 57;
            goto LABEL_28;
          }

          int v43 = *(_DWORD *)(v12 + 384);
          int v44 = *(_DWORD *)(v12 + 388) - v43;
          int v45 = *(_DWORD *)(v12 + 484);
          int v46 = v45 - v43;
          if (v46 >= v44) {
            int v46 = v44;
          }
          if (!v45) {
            int v46 = v44;
          }
          unsigned int v47 = v46 & ~(v46 >> 31);
          if (v47 >= a4 || v47 >= *(_DWORD *)(v12 + 392))
          {
            int v48 = **(_DWORD **)(*(void *)(v12 + 8) + 8LL);
            BOOL v49 = v48 == 30 || v48 == 2;
            if (!v49 || (v21 & 2) == 0 || (*(_BYTE *)(*(void *)v12 + 2231LL) & 0x50) == 0)
            {
LABEL_72:
              if (v47 >= a4) {
                unsigned int v50 = a4;
              }
              else {
                unsigned int v50 = v46 & ~(v46 >> 31);
              }
              if (a3 > v50 && v50 < *(_DWORD *)(v12 + 392))
              {
                unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                unsigned int v51 = *(int **)(StatusReg + 8);
                int v52 = 35;
LABEL_113:
                int *v51 = v52;
LABEL_29:
                int v29 = **(_DWORD **)(StatusReg + 8);
                if (v29 != 35)
                {
                  if (v29 == 32)
                  {
                    uint64_t v30 = (os_log_s *)__nwlog_obj();
                    uint64_t result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
                    if (!(_DWORD)result) {
                      return result;
                    }
                    *(_DWORD *)__int128 buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 32;
                    uint64_t v17 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                    uint64_t v18 = v30;
                    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
                    uint32_t v20 = 18;
                    goto LABEL_33;
                  }

                  __nwlog_obj();
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v29;
                  unsigned int v37 = (void *)_os_log_send_and_compose_impl();
                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v93 = 0;
                  if (__nwlog_fault())
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      uint64_t v38 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v39 = type;
                      if (!os_log_type_enabled(v38, type)) {
                        goto LABEL_100;
                      }
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      int v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d";
                      goto LABEL_98;
                    }

                    if (!v93)
                    {
                      uint64_t v38 = (os_log_s *)__nwlog_obj();
                      os_log_type_t v39 = type;
                      if (!os_log_type_enabled(v38, type)) {
                        goto LABEL_100;
                      }
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      int v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_98;
                    }

                    backtrace_string = (void *)__nw_create_backtrace_string();
                    uint64_t v38 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v39 = type;
                    BOOL v42 = os_log_type_enabled(v38, type);
                    if (backtrace_string)
                    {
                      if (v42)
                      {
                        *(_DWORD *)__int128 buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&_BYTE buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v29;
                        *(_WORD *)&buf[18] = 2082;
                        *(void *)&buf[20] = backtrace_string;
                        _os_log_impl( &dword_1879E5000,  v38,  v39,  "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                      }

                      free(backtrace_string);
                      goto LABEL_100;
                    }

                    if (v42)
                    {
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                      *(_WORD *)&_BYTE buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v29;
                      int v40 = "%{public}s tcp_get_southbound_frame failed %{darwin.errno}d, no backtrace";
LABEL_98:
                      double v59 = v38;
                      os_log_type_t v60 = v39;
                      uint32_t v61 = 18;
LABEL_99:
                      _os_log_impl(&dword_1879E5000, v59, v60, v40, buf, v61);
                    }
                  }

  if (*(_DWORD *)(a1 + 456) != 0xFFFF) {
    return 0LL;
  }
  if (v7) {
    return 1LL;
  }
  if ((*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      os_log_type_t v64 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v68 = "tcp_garbage_collect";
        os_log_type_t v69 = 2082;
        os_log_type_t v70 = v4 + 604;
        v71 = 1024;
        LODWORD(v72) = 0;
        _os_log_impl( &dword_1879E5000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{network:tcp_state}d",  buf,  0x1Cu);
      }
    }
  }

  if ((*(_BYTE *)(v5 + 91) & 0x40) != 0)
  {
    __int16 v10 = nw_tcp_access_globals(*(void *)(*(void *)(v5 + 80) + 224LL));
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(v5 + 80) + 224LL) + 8LL) + 32LL))();
    uint64_t v11 = *(_DWORD *)(v5 + 88);
    if ((v11 & 0x40000000) != 0)
    {
      uint64_t v12 = *(uint64_t **)(v10 + 264);
      int v13 = (uint64_t *)(v5 + 48);
      if (v12) {
        unsigned int v14 = v12 == v13;
      }
      else {
        unsigned int v14 = 0;
      }
      if (v14) {
        *(void *)(v10 + 264) = *v12;
      }
      char v15 = *v13;
      if (*v13) {
        *(void *)(v15 + 8) = *(void *)(v5 + 56);
      }
      **(void **)(v5 + 56) = v15;
      *(_DWORD *)(v5 + 88) = v11 & 0xBFFFFFFF;
      --*(_DWORD *)(v10 + 280);
      os_log_s *v13 = 0LL;
      *(void *)(v5 + 56) = 0LL;
    }
  }

  if (*(_DWORD *)(a1 + 232) != 3) {
    in_pcbdetach(a1);
  }
  char v16 = *(void *)(a1 + 224);
  if (v16)
  {
    if (*(_DWORD *)(v16 + 360))
    {
      if ((*(_BYTE *)(v16 + 828) & 2) != 0) {
        return 0LL;
      }
      __nwlog_tcp_log();
      uint64_t v17 = **(_DWORD **)(*(void *)(v16 + 8) + 8LL);
      uint64_t v18 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v68 = "in_pcbdispose";
      os_log_type_t v69 = 2082;
      os_log_type_t v70 = v16 + 604;
      v71 = 2048;
      int v72 = v16;
      int v73 = 1024;
      *(_DWORD *)int v74 = v17;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v18;
      os_log_type_t v19 = _os_log_send_and_compose_impl();
      int v34 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
      int v35 = **(_DWORD **)(*(void *)(v16 + 8) + 8LL);
      int v36 = *(_DWORD *)(v16 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v68 = "in_pcbdispose";
      os_log_type_t v69 = 2082;
      os_log_type_t v70 = v16 + 604;
      v71 = 2048;
      int v72 = v16;
      int v73 = 1024;
      *(_DWORD *)int v74 = v35;
      *(_WORD *)&v74[4] = 1024;
      *(_DWORD *)&v74[6] = v36;
      unsigned int v37 = "%{public}s %{public}s so %p [%d] usecount %d, backtrace limit exceeded";
      unsigned int v51 = v34;
      int v52 = 44;
      goto LABEL_108;
    }

    if (*(_DWORD *)(a1 + 456) != 0xFFFF)
    {
      if ((*(_BYTE *)(v16 + 828) & 2) != 0) {
        return 0LL;
      }
      __nwlog_tcp_log();
      unsigned int v28 = *(_DWORD *)(a1 + 456);
      int v29 = **(_DWORD **)(*(void *)(v16 + 8) + 8LL);
      uint64_t v30 = *(_DWORD *)(v16 + 360);
      int v31 = *(__int16 *)(v16 + 376);
      int v32 = *(_DWORD *)(v16 + 364);
      *(_DWORD *)__int128 buf = 136448258;
      __int16 v68 = "in_pcbdispose";
      os_log_type_t v69 = 2082;
      os_log_type_t v70 = v16 + 604;
      v71 = 2048;
      int v72 = a1;
      int v73 = 1024;
      *(_DWORD *)int v74 = v28;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v16;
      int v75 = 1024;
      int v76 = v29;
      __int16 v77 = 1024;
      unsigned int v78 = v30;
      BOOL v79 = 1024;
      signed int v80 = v31;
      os_log_type_t v81 = 1024;
      uint64_t v82 = v32;
      int v33 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v58 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          double v59 = *(_DWORD *)(a1 + 456);
          os_log_type_t v60 = **(_DWORD **)(*(void *)(v16 + 8) + 8LL);
          uint32_t v61 = *(_DWORD *)(v16 + 360);
          double v62 = *(__int16 *)(v16 + 376);
          uint64_t v63 = *(_DWORD *)(v16 + 364);
          *(_DWORD *)__int128 buf = 136448258;
          __int16 v68 = "in_pcbdispose";
          os_log_type_t v69 = 2082;
          os_log_type_t v70 = v16 + 604;
          v71 = 2048;
          int v72 = a1;
          int v73 = 1024;
          *(_DWORD *)int v74 = v59;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v16;
          int v75 = 1024;
          int v76 = v60;
          __int16 v77 = 1024;
          unsigned int v78 = v61;
          BOOL v79 = 1024;
          signed int v80 = v62;
          os_log_type_t v81 = 1024;
          uint64_t v82 = v63;
          _os_log_impl( &dword_1879E5000,  v58,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s inp %p invalid wantcnt %d, so %p [%d] usecount %d retaincnt state 0x%x flags 0x%x, bac ktrace limit exceeded",  buf,  0x48u);
        }
      }

      if (!v33) {
        return 0LL;
      }
      int v57 = (void *)v33;
      goto LABEL_111;
    }
  }

  else if (*(_DWORD *)(a1 + 456) != 0xFFFF)
  {
    __nwlog_obj();
    __int16 v21 = *(_DWORD *)(a1 + 456);
    *(_DWORD *)__int128 buf = 136446722;
    __int16 v68 = "in_pcbdispose";
    os_log_type_t v69 = 2048;
    os_log_type_t v70 = a1;
    v71 = 1024;
    LODWORD(v72) = v21;
    int v22 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v54 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        uint64_t v55 = *(_DWORD *)(a1 + 456);
        *(_DWORD *)__int128 buf = 136446722;
        __int16 v68 = "in_pcbdispose";
        os_log_type_t v69 = 2048;
        os_log_type_t v70 = a1;
        v71 = 1024;
        LODWORD(v72) = v55;
        _os_log_impl( &dword_1879E5000,  v54,  OS_LOG_TYPE_ERROR,  "%{public}s inp %p invalid wantcnt %d no socket, backtrace limit exceeded",  buf,  0x1Cu);
      }
    }

    if (!v22) {
      return 0LL;
    }
    int v57 = (void *)v22;
    goto LABEL_111;
  }

  __int16 v23 = *(_DWORD *)(a1 + 2232);
  if ((v23 & 1) == 0)
  {
    uint64_t v24 = *(void *)a1;
    if (*(void *)a1) {
      *(void *)(v24 + 8) = *(void *)(a1 + 8);
    }
    **(void **)(a1 + 8) = v24;
    goto LABEL_64;
  }

  os_log_type_t v25 = *(void *)(a1 + 240);
  __int128 v26 = *(void *)(v25 + 824);
  int v27 = *(void *)(v25 + 832);
  if (v26)
  {
    *(void *)(v26 + 832) = v27;
  }

  else
  {
    *(void *)(nw_tcp_access_globals(*(void *)(a1 + 224)) + 136) = v27;
    __int128 v26 = *(void *)(v25 + 824);
    __int16 v23 = *(_DWORD *)(a1 + 2232);
  }

  **(void **)(v25 + 832) = v26;
  *(_DWORD *)(a1 + 2232) = v23 & 0xFFFFFFFE;
  uint64_t v38 = *(void *)(a1 + 16);
  os_log_type_t v39 = *(_DWORD *)(v38 + 64);
  if (v39)
  {
LABEL_62:
    *(_DWORD *)(v38 + 64) = v39 - 1;
    int v40 = *(void *)(*(void *)(a1 + 240) + 1056LL);
    if (v40) {
      --*(void *)(v40 + 1696);
    }
LABEL_64:
    if (!v16) {
      return 0LL;
    }
    sofreelastref(v16);
    if (*(_DWORD *)(v16 + 488) || *(_DWORD *)(v16 + 384))
    {
      sbflush(v16 + 488);
      *(_DWORD *)(v16 + 492) = 0;
      int v41 = *(void *)(*(void *)(v16 + 560) + 24LL);
      if ((*(_BYTE *)(v16 + 536) & 4) != 0)
      {
        if (v41)
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v16 + 492);
          }
        }
      }

      else if (v41)
      {
        BOOL v42 = nw_protocol_tcp_get_all_stats();
        if (v42) {
          *(_DWORD *)(v42 + 100) = *(_DWORD *)(v16 + 492);
        }
      }

      sbflush(v16 + 384);
      *(_DWORD *)(v16 + 388) = 0;
      int v44 = *(void *)(*(void *)(v16 + 456) + 24LL);
      if ((*(_BYTE *)(v16 + 432) & 4) != 0)
      {
        if (v44)
        {
          int v46 = nw_protocol_tcp_get_all_stats();
          if (v46) {
            *(_DWORD *)(v46 + 88) = *(_DWORD *)(v16 + 388);
          }
        }
      }

      else if (v44)
      {
        int v45 = nw_protocol_tcp_get_all_stats();
        if (v45) {
          *(_DWORD *)(v45 + 100) = *(_DWORD *)(v16 + 388);
        }
      }
    }

    if (!*(void *)(v16 + 296))
    {
      *(_DWORD *)(v16 + 364) |= 4u;
      *(void *)char v16 = 0LL;
      *(void *)(a1 + 224) = 0LL;
      unsigned int v47 = *(void *)(a1 + 496);
      if (v47)
      {
        if (*(_BYTE *)(v47 + 1496))
        {
          int v48 = *(void **)(v47 + 1488);
          if (v48)
          {
            free(v48);
            unsigned int v47 = *(void *)(a1 + 496);
            *(void *)(v47 + 1488) = 0LL;
          }

          *(_BYTE *)(v47 + 1496) = 0;
        }

        *(void *)(a1 + 496) = 0LL;
      }

      BOOL v49 = *(void *)(v16 + 32);
      if (v49)
      {
        unsigned int v50 = *(void (**)(uint64_t))(v49 + 64);
        if (v50) {
          v50(v16);
        }
      }

      return 0LL;
    }

    if ((*(_BYTE *)(v16 + 828) & 2) != 0) {
      return 0LL;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446722;
    __int16 v68 = "in_pcbdispose";
    os_log_type_t v69 = 2082;
    os_log_type_t v70 = v16 + 604;
    v71 = 2048;
    int v72 = v16;
    os_log_type_t v19 = _os_log_send_and_compose_impl();
    if (!__nwlog_fault()
      || (int v56 = (os_log_s *)__nwlog_tcp_log(), !os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)))
    {
LABEL_109:
      if (v19)
      {
        int v57 = (void *)v19;
LABEL_111:
        free(v57);
      }

      return 0LL;
    }

    *(_DWORD *)__int128 buf = 136446722;
    __int16 v68 = "in_pcbdispose";
    os_log_type_t v69 = 2082;
    os_log_type_t v70 = v16 + 604;
    v71 = 2048;
    int v72 = v16;
    unsigned int v37 = "%{public}s %{public}s so=%p head still exist, backtrace limit exceeded";
    unsigned int v51 = v56;
    int v52 = 32;
LABEL_108:
    _os_log_impl(&dword_1879E5000, v51, OS_LOG_TYPE_ERROR, v37, buf, v52);
    goto LABEL_109;
  }

  BOOL v65 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v68 = "in_pcbremlists";
  unsigned int v66 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v66);
    uint64_t v38 = *(void *)(a1 + 16);
    os_log_type_t v39 = *(_DWORD *)(v38 + 64);
    goto LABEL_62;
  }

  __break(1u);
  return result;
}

LABEL_100:
                  if (v37) {
                    free(v37);
                  }
                  return 0LL;
                }

                if ((*(_BYTE *)(v12 + 828) & 2) != 0) {
                  return 0LL;
                }
                uint64_t result = __nwlog_is_datapath_logging_enabled();
                if ((_DWORD)result)
                {
                  int v31 = (os_log_s *)__nwlog_tcp_log();
                  uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
                  if ((_DWORD)result)
                  {
                    int v32 = *(_DWORD *)(v12 + 392);
                    int v33 = *(_DWORD *)(v12 + 384);
                    int v34 = *(_DWORD *)(v12 + 388) - v33;
                    int v35 = *(_DWORD *)(v12 + 484);
                    int v36 = v35 - v33;
                    if (v36 >= v34) {
                      int v36 = v34;
                    }
                    if (v35) {
                      int v34 = v36;
                    }
                    *(_DWORD *)__int128 buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v12 + 604;
                    *(_WORD *)&_BYTE buf[22] = 1024;
                    *(_DWORD *)&_BYTE buf[24] = v32;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v34 & ~(v34 >> 31);
                    uint64_t v17 = "%{public}s %{public}s tcp_get_southbound_frame failed, socket is full minimum %u sbspace %u";
                    uint64_t v18 = v31;
                    os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
                    uint32_t v20 = 34;
                    goto LABEL_33;
                  }
                }

                return result;
              }

              *(void *)__int128 buf = 0LL;
              *(void *)&buf[8] = buf;
              if (!nw_protocol_tcp_get_frames( v12,  v50,  (uint64_t)buf,  a5,  (int *)v92,  (v13 & 0x1000) != 0))
              {
                unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                unsigned int v51 = *(int **)(StatusReg + 8);
                int v52 = 55;
                goto LABEL_113;
              }

              if (*(void *)buf)
              {
                **(void **)(a6 + 8) = *(void *)buf;
                uint64_t v53 = *(void *)&buf[8];
                *(void *)(*(void *)buf + 40LL) = *(void *)(a6 + 8);
                *(void *)(a6 + 8) = v53;
              }

              uint64_t v54 = nw_protocol_downcast();
              if (!v54)
              {
                __nwlog_obj();
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                uint64_t v67 = (void *)_os_log_send_and_compose_impl();
                os_log_type_t type = OS_LOG_TYPE_ERROR;
                char v93 = 0;
                if (type == OS_LOG_TYPE_FAULT)
                {
                  uint64_t v86 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v87 = type;
                  if (!os_log_type_enabled(v86, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  os_log_type_t v70 = "%{public}s called with null tcp";
                }

                else if (v93)
                {
                  uint64_t v89 = (void *)__nw_create_backtrace_string();
                  uint64_t v86 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v87 = type;
                  BOOL v90 = os_log_type_enabled(v86, type);
                  if (v89)
                  {
                    if (v90)
                    {
                      *(_DWORD *)__int128 buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v89;
                      _os_log_impl( &dword_1879E5000,  v86,  v87,  "%{public}s called with null tcp, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v89);
                    goto LABEL_163;
                  }

                  if (!v90) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  os_log_type_t v70 = "%{public}s called with null tcp, no backtrace";
                }

                else
                {
                  uint64_t v86 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v87 = type;
                  if (!os_log_type_enabled(v86, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  os_log_type_t v70 = "%{public}s called with null tcp, backtrace limit exceeded";
                }

                uint64_t v82 = v86;
                os_log_type_t v83 = v87;
                uint32_t v84 = 12;
                goto LABEL_162;
              }

              uint64_t v55 = v54;
              if (a3 - v50 <= 1) {
                int v56 = 1;
              }
              else {
                int v56 = a3 - v50;
              }
              if (a3 <= v50) {
                int v57 = 2048;
              }
              else {
                int v57 = v56;
              }
              if (*(_DWORD *)(v54 + 392) == v57) {
                goto LABEL_165;
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v54 + 8) + 16LL))(v54, 1LL, v6);
              if ((~*(unsigned __int16 *)(v55 + 376) & 0x30) != 0)
              {
                if (v57 < 1)
                {
                  int v58 = 1;
                  goto LABEL_127;
                }
              }

              else
              {
                int v58 = 1;
                if ((*(_BYTE *)(v55 + 365) & 0x20) == 0 || v57 < 1) {
                  goto LABEL_127;
                }
              }

              int v58 = 0;
              unsigned int v66 = *(_DWORD *)(v55 + 388) / 3u;
              if (v57 <= *(_DWORD *)(v55 + 388) / 3) {
                unsigned int v66 = v57;
              }
              if (v66 <= 1) {
                unsigned int v66 = 1;
              }
              *(_DWORD *)(v55 + 392) = v66;
LABEL_127:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v55 + 8) + 24LL))(v55, 1LL, v6);
              if (!v58)
              {
                if ((*(_BYTE *)(v55 + 828) & 2) == 0)
                {
                  if (__nwlog_is_datapath_logging_enabled())
                  {
                    v71 = (os_log_s *)__nwlog_tcp_log();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
                    {
                      int v72 = *(_DWORD *)(v55 + 392);
                      int v73 = *(_DWORD *)(v55 + 384);
                      int v74 = *(_DWORD *)(v55 + 388) - v73;
                      int v75 = *(_DWORD *)(v55 + 484);
                      int v76 = v75 - v73;
                      if (v76 >= v74) {
                        int v76 = v74;
                      }
                      if (v75) {
                        int v74 = v76;
                      }
                      *(_DWORD *)__int128 buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v55 + 604;
                      *(_WORD *)&_BYTE buf[22] = 1024;
                      *(_DWORD *)&_BYTE buf[24] = v72;
                      *(_WORD *)&buf[28] = 1024;
                      *(_DWORD *)&buf[30] = v74 & ~(v74 >> 31);
                      _os_log_impl( &dword_1879E5000,  v71,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s so_snd.sb_lowat %u sbspace %u",  buf,  0x22u);
                    }
                  }
                }

                goto LABEL_165;
              }

              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v57;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v58;
              uint64_t v67 = (void *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v93 = 0;
              if (__nwlog_fault())
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  __int16 v68 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v69 = type;
                  if (!os_log_type_enabled(v68, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)__int128 buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  os_log_type_t v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d";
LABEL_160:
                  uint64_t v82 = v68;
LABEL_161:
                  os_log_type_t v83 = v69;
                  uint32_t v84 = 24;
LABEL_162:
                  _os_log_impl(&dword_1879E5000, v82, v83, v70, buf, v84);
                  goto LABEL_163;
                }

                if (!v93)
                {
                  __int16 v68 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v69 = type;
                  if (!os_log_type_enabled(v68, type)) {
                    goto LABEL_163;
                  }
                  *(_DWORD *)__int128 buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  os_log_type_t v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_160;
                }

                __int16 v77 = (void *)__nw_create_backtrace_string();
                unsigned int v78 = (os_log_s *)__nwlog_obj();
                os_log_type_t v69 = type;
                log = v78;
                BOOL v79 = os_log_type_enabled(v78, type);
                if (v77)
                {
                  if (v79)
                  {
                    *(_DWORD *)__int128 buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                    *(_WORD *)&_BYTE buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v57;
                    *(_WORD *)&buf[18] = 1024;
                    *(_DWORD *)&buf[20] = v58;
                    *(_WORD *)&_BYTE buf[24] = 2082;
                    *(void *)&buf[26] = v77;
                    _os_log_impl( &dword_1879E5000,  log,  v69,  "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
                  }

                  free(v77);
                  if (!v67) {
                    goto LABEL_165;
                  }
LABEL_164:
                  free(v67);
LABEL_165:
                  if ((*(_BYTE *)(v12 + 828) & 2) == 0)
                  {
                    if (__nwlog_is_datapath_logging_enabled())
                    {
                      unsigned int v88 = (os_log_s *)__nwlog_tcp_log();
                      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)__int128 buf = 136447746;
                        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
                        *(_WORD *)&_BYTE buf[12] = 2082;
                        *(void *)&buf[14] = v12 + 604;
                        *(_WORD *)&_BYTE buf[22] = 1024;
                        *(_DWORD *)&_BYTE buf[24] = a3;
                        *(_WORD *)&buf[28] = 1024;
                        *(_DWORD *)&buf[30] = a4;
                        __int16 v96 = 1024;
                        int v97 = a5;
                        __int16 v98 = 1024;
                        unsigned int v99 = v50;
                        __int16 v100 = 2048;
                        uint64_t v101 = v12;
                        _os_log_impl( &dword_1879E5000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s asked for min %u max %u bytes, max %u frames and got 1 frame of %u bytes on %p",  buf,  0x38u);
                      }
                    }
                  }

                  return *(unsigned int *)v92;
                }

                if (v79)
                {
                  *(_DWORD *)__int128 buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_set_send_low_water_mark";
                  *(_WORD *)&_BYTE buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v57;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v58;
                  os_log_type_t v70 = "%{public}s setsockopt SO_SNDLOWAT %u failed %{darwin.errno}d, no backtrace";
                  uint64_t v82 = log;
                  goto LABEL_161;
                }
              }

LABEL_163:
              if (!v67) {
                goto LABEL_165;
              }
              goto LABEL_164;
            }
          }

          if ((*(_BYTE *)(v12 + 368) & 0x20) != 0)
          {
            if (v46 < 1) {
              goto LABEL_149;
            }
            if (v47 < *(_DWORD *)(v12 + 392)) {
              goto LABEL_72;
            }
          }

          if ((*(_WORD *)(v12 + 376) & 0x100) == 0 && (*(_BYTE *)(v12 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "sosendcheck";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v12 + 604;
            double v62 = (void *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v93 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              uint64_t v63 = (os_log_s *)__nwlog_tcp_log();
              os_log_type_t v64 = type;
              if (!os_log_type_enabled(v63, type)) {
                goto LABEL_147;
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              BOOL v65 = "%{public}s %{public}s NBIO not set";
            }

            else
            {
              uint64_t v63 = (os_log_s *)__nwlog_tcp_log();
              os_log_type_t v64 = type;
              if (!os_log_type_enabled(v63, type)) {
                goto LABEL_147;
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "sosendcheck";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v12 + 604;
              BOOL v65 = "%{public}s %{public}s NBIO not set, backtrace limit exceeded";
            }

            _os_log_impl(&dword_1879E5000, v63, v64, v65, buf, 0x16u);
LABEL_147:
            if (v62) {
              free(v62);
            }
          }

LABEL_149:
          int v22 = 35;
          goto LABEL_28;
        }
      }

      int v22 = 32;
LABEL_28:
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = v22;
      goto LABEL_29;
    }

    goto LABEL_22;
  }

  int v13 = *(_DWORD *)(v11 + 5308);
  if ((v13 & 0x20) != 0)
  {
    if (a5) {
      goto LABEL_15;
    }
LABEL_22:
    if ((*(_BYTE *)(v11 + 828) & 2) == 0)
    {
      int v27 = (os_log_s *)__nwlog_tcp_log();
      uint64_t result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result) {
        return result;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v12 + 604;
      uint64_t v17 = "%{public}s %{public}s cannot specify 0 as maximum_frame_count on a streaming socket";
      uint64_t v18 = v27;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 22;
      goto LABEL_33;
    }

    return 0LL;
  }

  if ((*(_BYTE *)(v11 + 828) & 2) != 0) {
    return 0LL;
  }
  uint64_t result = __nwlog_is_datapath_logging_enabled();
  if ((_DWORD)result)
  {
    char v16 = (os_log_s *)__nwlog_tcp_log();
    uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_output_frames";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v12 + 604;
      uint64_t v17 = "%{public}s %{public}s skipping";
      uint64_t v18 = v16;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
      uint32_t v20 = 22;
LABEL_33:
      _os_log_impl(&dword_1879E5000, v18, v19, v17, buf, v20);
      return 0LL;
    }
  }

  return result;
}

BOOL nw_protocol_tcp_finalize_output_frames(uint64_t a1, uint64_t *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = nw_protocol_downcast();
    if (v4)
    {
      uint64_t v5 = v4;
      *(void *)&__int128 buf = 0LL;
      *((void *)&buf + 1) = &buf;
      uint64_t v27 = 0x2000000000LL;
      uint64_t v28 = v4;
      *(void *)os_log_type_t type = 0LL;
      int v22 = type;
      uint64_t v23 = 0x2000000000LL;
      char v24 = 1;
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      char v16 = (uint64_t (*)(void *))__nw_protocol_tcp_finalize_output_frames_block_invoke;
      uint64_t v17 = &unk_18A0EEA98;
      uint64_t v18 = type;
      p___int128 buf = &buf;
      uint64_t v20 = a1;
      uint64_t v6 = *a2;
      do
      {
        if (!v6) {
          break;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        char v8 = v16(v15);
        uint64_t v6 = v7;
      }

      while ((v8 & 1) != 0);
      nw_protocol_tcp_update_metadata(a1);
      *(_DWORD *)(v5 + 5308) &= ~0x20u;
      BOOL v9 = *((_BYTE *)v22 + 24) != 0;
      _Block_object_dispose(type, 8);
      _Block_object_dispose(&buf, 8);
      return v9;
    }

    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    uint64_t v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          unsigned int v14 = "%{public}s called with null tcp";
          goto LABEL_22;
        }
      }

      else
      {
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          unsigned int v14 = "%{public}s called with null tcp, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }

  else
  {
    __nwlog_obj();
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
    uint64_t v11 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          unsigned int v14 = "%{public}s called with null protocol";
LABEL_22:
          _os_log_impl(&dword_1879E5000, v12, v13, v14, (uint8_t *)&buf, 0xCu);
        }
      }

      else
      {
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = "nw_protocol_tcp_finalize_output_frames";
          unsigned int v14 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
  }

  if (v11) {
    free(v11);
  }
  return 0LL;
}

void nw_protocol_tcp_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v48 = "nw_protocol_tcp_link_state";
    int v41 = (void *)_os_log_send_and_compose_impl();
    int v43 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_85;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v48 = "nw_protocol_tcp_link_state";
    int v44 = "%{public}s called with null link_info, backtrace limit exceeded";
LABEL_84:
    _os_log_impl(&dword_1879E5000, v43, OS_LOG_TYPE_ERROR, v44, buf, 0xCu);
    goto LABEL_85;
  }

  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v48 = "nw_protocol_tcp_link_state";
    int v41 = (void *)_os_log_send_and_compose_impl();
    int v43 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_85;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v48 = "nw_protocol_tcp_link_state";
    int v44 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_84;
  }

  uint64_t v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v48 = "nw_protocol_tcp_link_state";
    int v41 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v43 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v48 = "nw_protocol_tcp_link_state";
        int v44 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_84;
      }
    }

LABEL_85:
    if (v41) {
      free(v41);
    }
    return;
  }

  uint64_t v5 = v4;
  if (*(_DWORD *)(v4 + 5224) == 2)
  {
    uint64_t v6 = *(void *)v4;
    int flow_control_status = nw_link_get_flow_control_status();
    if (flow_control_status != 1)
    {
      if (flow_control_status) {
        return;
      }
      uint64_t v8 = *(void *)(v6 + 224);
      BOOL v9 = (unsigned int *)(v6 + 456);
LABEL_8:
      unsigned int v10 = *v9;
      if ((unsigned __int16)*v9 != 0xFFFF)
      {
        do
        {
          unsigned int v11 = __ldxr(v9);
          if (v11 != v10)
          {
            __clrex();
            goto LABEL_8;
          }
        }

        while (__stxr(v10 + 1, v9));
        if (v8)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 16LL))(v8, 1LL, v3);
        }

        else
        {
          int v45 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = 136446210;
          int v48 = "inp_fc_feedback";
          int v46 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
          {
            __break(1u);
            return;
          }

          free(v46);
          (*(void (**)(void, uint64_t, uint64_t))(MEMORY[8] + 16LL))(0LL, 1LL, v3);
        }

        if (in_pcb_checkstate(v6, 2LL, 1) == 0xFFFF)
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          int v48 = "inp_fc_feedback";
          os_log_type_t v19 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v40 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              int v48 = "inp_fc_feedback";
              _os_log_impl( &dword_1879E5000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s failed to release inpcb reference, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v19) {
            free(v19);
          }
          goto LABEL_77;
        }

        int v21 = *(_DWORD *)(v6 + 2228);
        if ((v21 & 0x50000000) == 0)
        {
LABEL_77:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 24LL))(v8, 1LL, v3);
          return;
        }

        uint64_t v22 = *(void *)(v6 + 224);
        if ((v21 & 0x10000000) != 0)
        {
          *(_DWORD *)(v6 + 2228) = v21 & 0xAFFFFFFF;
          char v24 = (unsigned int *)(v22 + 364);
          int v23 = *(_DWORD *)(v22 + 364);
        }

        else
        {
          int v23 = *(_DWORD *)(v22 + 364);
          *(_DWORD *)(v6 + 2228) = v21 & 0xAFFFFFFF;
          if ((v23 & 0x20000) == 0) {
            goto LABEL_39;
          }
          char v24 = (unsigned int *)(v22 + 364);
        }

        *char v24 = v23 & 0xFFFDFFFF;
LABEL_39:
        char v25 = *(void (***)(uint64_t, uint64_t))(v22 + 32);
        if (v25)
        {
          __int128 v26 = *v25;
          if (v26) {
            v26(v22, v18);
          }
        }

        uint64_t v27 = *(void *)(v6 + 240);
        uint64_t v28 = *(void *)(v6 + 448);
        uint64_t v29 = tcp_cc_algo_list[*(unsigned __int8 *)(v27 + 264)];
        if (*(_DWORD *)(sysctls + 292))
        {
          uint64_t v30 = *(void (**)(void, void))(v29 + 72);
          if (v30) {
            v30(*(void *)(v6 + 240), 0LL);
          }
          *(_DWORD *)(v27 + 288) = 0;
          if (*(_WORD *)(v27 + 226)
            && v28
            && (*(unsigned __int8 *)(v28 + 1076) == 255 || *(_DWORD *)(v28 + 1024) == 255))
          {
            uint64_t v31 = *(void *)(v6 + 224);
            if (!v31 || (*(_BYTE *)(v31 + 828) & 2) == 0)
            {
              int v32 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
              {
                int v33 = (const char *)(v31 + 604);
                int v34 = *(unsigned __int16 *)(v27 + 226);
                int v48 = "inp_fc_unthrottle_tcp";
                *(_DWORD *)__int128 buf = 136446722;
                if (!v31) {
                  int v33 = "";
                }
                __int16 v49 = 2082;
                unsigned int v50 = v33;
                __int16 v51 = 1024;
                int v52 = v34;
                _os_log_impl( &dword_1879E5000,  v32,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s inp_fc_unthrottle_tcp keep rxmit state t_rxtshift %d",  buf,  0x1Cu);
              }
            }
          }

          else
          {
            *(_WORD *)(v27 + 226) = 0;
            *(_DWORD *)(v27 + 248) = 0;
          }

          *(_DWORD *)(v27 + 740) &= ~0x100000u;
        }

        else
        {
          int v35 = *(void (**)(void))(v29 + 64);
          if (v35) {
            v35(*(void *)(v6 + 240));
          }
          *(_DWORD *)(v27 + 144) = *(_DWORD *)(v27 + 148);
          *(_DWORD *)(v27 + 740) &= ~0x100000u;
          *(_DWORD *)(v27 + 288) = 0;
          if (*(_WORD *)(v27 + 226)
            && v28
            && (*(unsigned __int8 *)(v28 + 1076) == 255 || *(_DWORD *)(v28 + 1024) == 255))
          {
            uint64_t v36 = *(void *)(v6 + 224);
            if (!v36 || (*(_BYTE *)(v36 + 828) & 2) == 0)
            {
              unsigned int v37 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
              {
                uint64_t v38 = (const char *)(v36 + 604);
                int v39 = *(unsigned __int16 *)(v27 + 226);
                int v48 = "inp_fc_unthrottle_tcp";
                *(_DWORD *)__int128 buf = 136446722;
                if (!v36) {
                  uint64_t v38 = "";
                }
                __int16 v49 = 2082;
                unsigned int v50 = v38;
                __int16 v51 = 1024;
                int v52 = v39;
                _os_log_impl( &dword_1879E5000,  v37,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s inp_fc_unthrottle_tcp keep rxmit state t_rxtshift %d",  buf,  0x1Cu);
              }
            }
          }

          else
          {
            *(_WORD *)(v27 + 226) = 0;
            *(_DWORD *)(v27 + 248) = 0;
          }
        }

        tcp_output(v27);
        goto LABEL_77;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v48 = "inp_fc_feedback";
      int v41 = (void *)_os_log_send_and_compose_impl();
      int v43 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_85;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v48 = "inp_fc_feedback";
      int v44 = "%{public}s failed to acquire inpcb reference, backtrace limit exceeded";
      goto LABEL_84;
    }

    uint64_t v13 = *(void *)(*(void *)v5 + 240LL);
    uint64_t v14 = *(void *)(v13 + 80);
    char v15 = (unsigned int *)(v14 + 456);
LABEL_18:
    unsigned int v16 = *v15;
    if ((unsigned __int16)*v15 != 0xFFFF)
    {
      do
      {
        unsigned int v17 = __ldxr(v15);
        if (v17 != v16)
        {
          __clrex();
          goto LABEL_18;
        }
      }

      while (__stxr(v16 + 1, v15));
      if ((*(_WORD *)(v13 + 90) & 0x820) == 0
        && *(_DWORD *)(v13 + 12) == 4
        && *(_DWORD *)(v13 + 96) - *(_DWORD *)(v13 + 92) >= 1)
      {
        int v20 = *(_DWORD *)(v14 + 2228);
        *(_DWORD *)(v14 + 2228) = v20 & 0xAFFFFFFF | 0x40000000;
        if ((v20 & 0x50000000) == 0)
        {
          if (*(_DWORD *)(sysctls + 292))
          {
            BOOL v42 = *(void (**)(void))(tcp_cc_algo_list[*(unsigned __int8 *)(*(void *)(v14 + 240) + 264LL)] + 64);
            if (v42) {
              v42();
            }
          }
        }
      }

      in_pcb_checkstate(v14, 2LL, 0);
    }
  }

  else if ((*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v12 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v48 = "nw_protocol_tcp_link_state";
        __int16 v49 = 2082;
        unsigned int v50 = (const char *)(v5 + 604);
        _os_log_impl(&dword_1879E5000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }

      if (v36) {
        free(v36);
      }
      int v32 = v34;
      if (!v34) {
        goto LABEL_71;
      }
    }
  }

void nw_protocol_tcp_disconnect(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      uint64_t v3 = (void *)MEMORY[0x189608EE0];
      if (*MEMORY[0x189608EE0] != -1LL) {
        dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
      }
      uint64_t v4 = (_BYTE *)MEMORY[0x189608ED8];
      if (*MEMORY[0x189608ED8] && kdebug_is_enabled())
      {
        kdebug_trace();
        if ((*(_BYTE *)(v2 + 828) & 2) != 0) {
          goto LABEL_10;
        }
      }

      else if ((*(_BYTE *)(v2 + 828) & 2) != 0)
      {
        goto LABEL_10;
      }

      uint64_t v5 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v11 = "nw_protocol_tcp_disconnect";
        __int16 v12 = 2082;
        uint64_t v13 = v2 + 604;
        _os_log_impl( &dword_1879E5000,  v5,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s input protocol initiated disconnect",  buf,  0x16u);
      }

LABEL_10:
      __nw_protocol_tcp_disconnect(v2);
      if ((*(_BYTE *)(v2 + 5308) & 2) != 0) {
        return;
      }
      if ((*(_BYTE *)(v2 + 828) & 2) == 0)
      {
        uint64_t v6 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          unsigned int v11 = "nw_protocol_tcp_disconnect";
          __int16 v12 = 2082;
          uint64_t v13 = v2 + 604;
          _os_log_impl( &dword_1879E5000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s send disconnect to input protocol",  buf,  0x16u);
        }
      }

      nw_protocol_get_input_handler();
      if (*v3 == -1LL)
      {
        if (*v4) {
          goto LABEL_17;
        }
      }

      else
      {
        dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
        if (*v4)
        {
LABEL_17:
        }
      }

      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
LABEL_20:
      *(_DWORD *)(v2 + 5308) |= 2u;
      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v11 = "nw_protocol_tcp_disconnect";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v11 = "nw_protocol_tcp_disconnect";
        BOOL v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v11 = "nw_protocol_tcp_disconnect";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v11 = "nw_protocol_tcp_disconnect";
        BOOL v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_34:
        _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }

  if (v7) {
    free(v7);
  }
}

uint64_t nw_protocol_tcp_connect(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v9 = "nw_protocol_tcp_connect";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v9 = "nw_protocol_tcp_connect";
    uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_23;
  }

  uint64_t v1 = nw_protocol_downcast();
  if (v1)
  {
    uint64_t v2 = v1;
    if ((*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v5 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v9 = "nw_protocol_tcp_connect";
          __int16 v10 = 2082;
          uint64_t v11 = v2 + 604;
          _os_log_impl(&dword_1879E5000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got connect event", buf, 0x16u);
        }
      }
    }

    if (*MEMORY[0x189608EE0] != -1LL) {
      dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
    }
    if (*(_DWORD *)(v2 + 5224) == 2)
    {
      nw_protocol_get_input_handler();
      nw_protocol_connected_quiet();
      return 1LL;
    }

    else
    {
      nw_protocol_get_output_handler();
      return nw_protocol_connect_quiet();
    }
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v9 = "nw_protocol_tcp_connect";
  uint64_t v4 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v6 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v9 = "nw_protocol_tcp_connect";
      uint64_t v7 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_23:
      _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
    }
  }

LABEL_24:
  if (v4) {
    free(v4);
  }
  return 0LL;
}

  v893 = 0;
  if (a5) {
    *a5 = 0;
  }
  int v23 = nw_tcp_access_globals(*(void *)(*(void *)(v14 + 80) + 224LL));
  char v24 = v23;
  char v25 = (unsigned int *)(a3 + 456);
  while (1)
  {
    __int128 v26 = *v25;
    while (1)
    {
      uint64_t v27 = __ldxr(v25);
      if (v27 != v26) {
        break;
      }
      if (!__stxr(v26 + 1, v25)) {
        goto LABEL_32;
      }
    }

    __clrex();
  }

    *(_BYTE *)(a2 + 15) = v8 - 1;
    *(void *)(a2 + 16) = v6 + 2;
    uint64_t v18 = *(void *)(a1 + 1056);
    if (v18) {
      ++*(void *)(v18 + 1016);
    }
    ++*(_DWORD *)(a1 + 1024);
    os_log_type_t v19 = *(_DWORD *)(a1 + 932);
    if (v19 && v19 == v9)
    {
      *a4 = 1;
      *(_DWORD *)(a1 + 932) = 0;
    }

    int v20 = *(_DWORD *)(a1 + 740);
    if ((v20 & 0x20400020) == 0x20000020 && !*a4)
    {
      for (uint64_t i = *(void *)(a1 + 1984); i; uint64_t i = *(void *)(i + 16))
      {
      }
    }

    if ((*(_WORD *)(a1 + 226) == 1 && v7 == *(_DWORD *)(a1 + 92)
       || (~v20 & 0x40001000) == 0 && v9 == *(_DWORD *)(a1 + 928))
      && !*(void *)(a1 + 544)
      && *(_DWORD *)(a3 + 8) - *(_DWORD *)(a1 + 92) >= 1)
    {
      if (v18) {
        ++*(void *)(v18 + 1040);
      }
    }

    else
    {
      int v21 = *(int **)(a1 + 952);
      if (v21)
      {
        uint64_t v22 = v9 - 1;
        do
        {
          int v23 = *v21;
          int v21 = (int *)*((void *)v21 + 2);
        }

        while (v21);
      }
    }

    return 1LL;
  }

  return v14;
}

void nw_protocol_tcp_connected(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v35 = "nw_protocol_tcp_connected";
    uint64_t v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v31 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v35 = "nw_protocol_tcp_connected";
        int v32 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_97:
        _os_log_impl(&dword_1879E5000, v31, OS_LOG_TYPE_ERROR, v32, buf, 0xCu);
      }
    }

LABEL_98:
    if (v28) {
      free(v28);
    }
    return;
  }

  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v35 = "nw_protocol_tcp_connected";
    uint64_t v28 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v31 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v35 = "nw_protocol_tcp_connected";
        int v32 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_97;
      }
    }

    goto LABEL_98;
  }

  uint64_t v3 = v2;
  if ((*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v29 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v35 = "nw_protocol_tcp_connected";
        __int16 v36 = 2082;
        uint64_t v37 = v3 + 604;
        _os_log_impl( &dword_1879E5000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s got a connected event from the lower layer",  buf,  0x16u);
      }
    }
  }

  if ((*(_DWORD *)(v3 + 5224) - 1) >= 2)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
      return;
    }
    uint64_t v12 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)__int128 buf = 136446466;
    int v35 = "nw_protocol_tcp_connected";
    __int16 v36 = 2082;
    uint64_t v37 = v3 + 604;
    uint64_t v11 = "%{public}s %{public}s skipping";
    goto LABEL_28;
  }

  if (*(void *)(v3 + 5216))
  {
    nw_protocol_get_identifier();
    uint64_t stats_region = nw_path_flow_registration_get_stats_region();
    *(void *)(v3 + 4128) = stats_region;
    if (stats_region) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  if (!*(void *)(v3 + 4128)) {
LABEL_8:
  }
    *(void *)(v3 + 4128) = &tcpstat;
LABEL_9:
  *(void *)(v3 + 4136) = nw_path_flow_registration_get_advisory_region();
  remote_endpoint = (nw_endpoint *)nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v15 = v3 + 604;
      *(_DWORD *)__int128 buf = 136446466;
      int v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      unsigned int v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v18 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v15;
          os_log_type_t v19 = "%{public}s %{public}s get_remote_endpoint failed, backtrace limit exceeded";
LABEL_52:
          _os_log_impl(&dword_1879E5000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x16u);
        }
      }

      v908 = 0;
      goto LABEL_99;
    }

    uint64_t v39 = *(_DWORD *)(a1 + 144);
    uint64_t v40 = v39 - tcp_flight_size((_DWORD *)a1);
    if (v40 < 1) {
      goto LABEL_99;
    }
    int v41 = *v894;
    if (!*v894) {
      goto LABEL_98;
    }
    do
    {
      BOOL v42 = v41;
      int v41 = *(void *)(v41 + 32);
    }

    while (v41);
    v908 = 0;
    while (1)
    {
      int v43 = *(_DWORD *)(v42 + 4);
      int v44 = *type - v43;
      if ((*(_BYTE *)(v42 + 12) & 1) != 0)
      {
        goto LABEL_99;
      }

      if (v44 < 0)
      {
        v908 += tcp_seg_len((int *)v42);
        int v45 = *(void *)(v42 + 40);
        if (v45)
        {
          do
          {
LABEL_84:
            int v46 = v45;
            int v45 = *(void *)(v45 + 32);
          }

          while (v45);
          goto LABEL_85;
        }
      }

      else
      {
        int v45 = *(void *)(v42 + 40);
        if (v45) {
          goto LABEL_84;
        }
      }

      int v46 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v46 || *(void *)(v46 + 32) != v42) {
        break;
      }
LABEL_85:
      BOOL v42 = v46;
      if (v908 >= v40) {
        goto LABEL_99;
      }
    }

    while (1)
    {
      int v46 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v46) {
        break;
      }
      double v59 = v42 == *(void *)(v46 + 40);
      BOOL v42 = *(void *)(v42 + 48) & 0xFFFFFFFFFFFFFFFELL;
      if (!v59) {
        goto LABEL_85;
      }
    }

LABEL_53:
      if (v16) {
        free(v16);
      }
    }

          if (v85) {
            free(v85);
          }
          *(_WORD *)(v19 + 196) = 0;
          int v33 = v88;
          goto LABEL_56;
        }

        if (((unsigned int (*)(void, void))*MEMORY[0x189608EF8])(v98[0], *(void *)(v98[0] + 88LL)))
        {
          unsigned int v88 = (unsigned int *)(v19 + 56);
          uint64_t v22 = *(void *)(v19 + 112);
          if (v22)
          {
            int v23 = v22 + *(unsigned int *)(v19 + 56);
            goto LABEL_24;
          }
        }
      }

      if ((*(_WORD *)(v19 + 204) & 0x100) != 0
        && *v21
        && (((uint64_t (*)(uint64_t, void))*v21)(v19, *(void *)(v19 + 88)) & 1) == 0)
      {
        *(void *)(a1 + 1056) = 0LL;
      }
    }

    if ((*(_BYTE *)(v14 + 828) & 2) == 0)
    {
      char v24 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v102 = "tcp_respond";
        unsigned int v103 = 2082;
        *(void *)unsigned int v104 = v14 + 604;
        char v25 = "%{public}s %{public}s output frame is no longer valid";
LABEL_22:
        _os_log_impl(&dword_1879E5000, v24, OS_LOG_TYPE_INFO, v25, buf, 0x16u);
      }
    }
  }

  else if ((*(_BYTE *)(v14 + 828) & 2) == 0)
  {
    char v24 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v102 = "tcp_respond";
      unsigned int v103 = 2082;
      *(void *)unsigned int v104 = v14 + 604;
      char v25 = "%{public}s %{public}s failed to get output frames";
      goto LABEL_22;
    }
  }

LABEL_55:
    nw_protocol_get_input_handler();
    nw_protocol_error();
    return;
  }

  address = nw_endpoint_get_address(remote_endpoint);
  if (!address)
  {
    if ((*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v17 = v3 + 604;
      *(_DWORD *)__int128 buf = 136446466;
      int v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      unsigned int v16 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v18 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v17;
          os_log_type_t v19 = "%{public}s %{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
          goto LABEL_52;
        }
      }

      goto LABEL_53;
    }

    goto LABEL_55;
  }

  if ((*(_BYTE *)(v3 + 5310) & 0x20) == 0)
  {
    uint64_t v7 = address;
    microuptime(v3 + 5248);
    __int16 v8 = *(_WORD *)(v3 + 376);
    if ((v8 & 4) == 0)
    {
      int v9 = *(_DWORD *)(v3 + 364);
      if ((*(_BYTE *)(v3 + 372) & 2) != 0)
      {
        if ((v9 & 8) == 0) {
          goto LABEL_47;
        }
      }

      else if ((v9 & 8) == 0)
      {
        if ((v8 & 6) != 0)
        {
LABEL_16:
          *(_DWORD *)(v3 + 5224) = 2;
          nw_protocol_tcp_input_available(a1);
          if (*MEMORY[0x189608EE0] != -1LL) {
            dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
          }
          nw_protocol_get_input_handler();
          nw_protocol_connected();
          if ((*(_BYTE *)(v3 + 828) & 2) == 0)
          {
            __int16 v10 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 136446466;
              int v35 = "nw_protocol_tcp_connected";
              __int16 v36 = 2082;
              uint64_t v37 = v3 + 604;
              uint64_t v11 = "%{public}s %{public}s is already connected";
LABEL_40:
              uint64_t v13 = v10;
              os_log_type_t v14 = OS_LOG_TYPE_INFO;
              goto LABEL_41;
            }
          }

          return;
        }

        int v23 = (*(uint64_t (**)(uint64_t, const sockaddr *))(*(void *)(*(void *)(v3 + 8) + 40LL) + 24LL))( v3,  v7);
        if (v23)
        {
          int v20 = v23;
          *(_WORD *)(v3 + 376) &= ~4u;
          switch(v23)
          {
            case 1:
            case 6:
            case 13:
            case 49:
            case 50:
            case 51:
            case 60:
            case 61:
            case 64:
            case 65:
              char v24 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 136446466;
                int v35 = "nw_protocol_tcp_connected";
                __int16 v36 = 1024;
                LODWORD(v37) = v20;
                _os_log_impl( &dword_1879E5000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_trigger_connect failed %{darwin.errno}d",  buf,  0x12u);
              }

              goto LABEL_55;
            case 37:
              goto LABEL_63;
            case 56:
              goto LABEL_16;
            default:
              goto LABEL_48;
          }
        }

        if ((*(_BYTE *)(v3 + 5308) & 0x20) == 0)
        {
          nw_protocol_tcp_input_available(a1);
          return;
        }

        if (tcp_perf_measurement)
        {
          if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
            goto LABEL_87;
          }
          char v25 = (os_log_s *)__nwlog_tcp_log();
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_87;
          }
          *(_DWORD *)__int128 buf = 136446466;
          int v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          __int128 v26 = v25;
          os_log_type_t v27 = OS_LOG_TYPE_DEBUG;
        }

        else
        {
          if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
            goto LABEL_87;
          }
          uint64_t v30 = (os_log_s *)__nwlog_tcp_log();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_INFO)) {
            goto LABEL_87;
          }
          *(_DWORD *)__int128 buf = 136446466;
          int v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          __int128 v26 = v30;
          os_log_type_t v27 = OS_LOG_TYPE_INFO;
        }

        _os_log_impl(&dword_1879E5000, v26, v27, "%{public}s %{public}s tfo preconnect", buf, 0x16u);
LABEL_87:
        if (*MEMORY[0x189608EE0] != -1LL) {
          dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
        }
        nw_protocol_get_input_handler();
        nw_protocol_connected();
        return;
      }

      if ((*(_BYTE *)(v3 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
      {
        int v33 = (os_log_s *)__nwlog_tcp_log();
        int v20 = 102;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446722;
          int v35 = "tcp_trigger_connect";
          __int16 v36 = 2082;
          uint64_t v37 = v3 + 604;
          __int16 v38 = 1024;
          LODWORD(v39) = 102;
          _os_log_impl( &dword_1879E5000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s defunct flow error (%d)",  buf,  0x1Cu);
        }

        goto LABEL_48;
      }

    if (v68) {
      free(v68);
    }
    goto LABEL_39;
  }

  if (*(_DWORD *)(a2 + 12) == 2) {
    ++*(_BYTE *)(a2 + 1868);
  }
LABEL_57:
  if ((v18 & 1) == 0) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 0LL, v5);
  }
  if ((*(_BYTE *)(v10 + 2231) & 0x10) != 0)
  {
    if ((v72 & 0x10000000) != 0)
    {
      uint64_t v17 = 0LL;
      goto LABEL_66;
    }

LABEL_47:
      int v20 = 102;
LABEL_48:
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446466;
      int v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 1024;
      LODWORD(v37) = v20;
      int v21 = (void *)_os_log_send_and_compose_impl();
      if ((__nwlog_fault() & 1) != 0)
      {
        uint64_t v22 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v35 = "nw_protocol_tcp_connected";
          __int16 v36 = 1024;
          LODWORD(v37) = v20;
          _os_log_impl( &dword_1879E5000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_trigger_connect failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }

      if (v21) {
        free(v21);
      }
      goto LABEL_55;
    }

          int v20 = v16;
          int v21 = v17;
          uint64_t v22 = 28;
          break;
        case 3:
          *(_DWORD *)(v5 + 5308) &= ~0x100u;
          return v7;
        case 4:
        case 5:
          return v7;
        case 14:
          *(_DWORD *)(v5 + 5308) &= ~0x400000u;
          if ((*(_BYTE *)(v5 + 828) & 2) == 0)
          {
            os_log_type_t v14 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
              uint64_t v28 = 2082;
              *(void *)uint64_t v29 = v6 + 604;
              _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s segmentation_offload_notification disabled",  buf,  0x16u);
            }
          }

          return v7;
        default:
          return 0LL;
      }

      goto LABEL_48;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
    __int16 v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v24 = (os_log_s *)__nwlog_obj();
      char v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      uint64_t v11 = "%{public}s called with null tcp";
    }

    else
    {
      char v24 = (os_log_s *)__nwlog_obj();
      char v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      uint64_t v11 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
    __int16 v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v24 = (os_log_s *)__nwlog_obj();
      char v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      uint64_t v11 = "%{public}s called with null protocol";
    }

    else
    {
      char v24 = (os_log_s *)__nwlog_obj();
      char v25 = type[0];
      if (!os_log_type_enabled(v24, type[0])) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
      uint64_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }

  int v20 = v24;
  int v21 = v25;
  uint64_t v22 = 12;
LABEL_48:
  _os_log_impl(&dword_1879E5000, v20, v21, v11, buf, v22);
LABEL_49:
  if (v8) {
    free(v8);
  }
  return 0LL;
}

  if (a3 > 0) {
    return (void *)sbappendstream((int *)(a1 + 488), (uint64_t *)type, a3, a4);
  }
  uint64_t result = *(void **)type;
  if (*(void *)type)
  {
    while (1)
    {
      uint64_t v30 = (void (*)(void *, uint64_t, uint64_t))result[10];
      uint64_t v31 = (void *)result[4];
      if (!v30) {
        break;
      }
      int v32 = result[11];
      result[10] = 0LL;
      result[11] = 0LL;
      v30(result, 1LL, v32);
LABEL_53:
      uint64_t result = v31;
      if (!v31) {
        return result;
      }
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v60 = "__nw_frame_finalize";
    int v33 = _os_log_send_and_compose_impl();
    int v58 = OS_LOG_TYPE_ERROR;
    int v57 = 0;
    uint64_t v54 = (void *)v33;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        __int16 v51 = (os_log_s *)__nwlog_obj();
        log = v58;
        if (!os_log_type_enabled(v51, v58)) {
          goto LABEL_69;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v60 = "__nw_frame_finalize";
        int v34 = v51;
        int v35 = log;
        __int16 v36 = "%{public}s called with null frame->finalizer";
        goto LABEL_68;
      }

      if (!v57)
      {
        uint64_t v53 = (os_log_s *)__nwlog_obj();
        logb = v58;
        if (!os_log_type_enabled(v53, v58)) {
          goto LABEL_69;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v60 = "__nw_frame_finalize";
        int v34 = v53;
        int v35 = logb;
        __int16 v36 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_68;
      }

      int v52 = (void *)__nw_create_backtrace_string();
      loga = (os_log_s *)__nwlog_obj();
      unsigned int v47 = v58;
      uint64_t v37 = os_log_type_enabled(loga, v58);
      __int16 v38 = v52;
      if (v52)
      {
        if (v37)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v60 = "__nw_frame_finalize";
          uint32_t v61 = 2082;
          double v62 = (const char *)v52;
          _os_log_impl( &dword_1879E5000,  loga,  v47,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          __int16 v38 = v52;
        }

        free(v38);
        goto LABEL_69;
      }

      if (v37)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v60 = "__nw_frame_finalize";
        int v34 = loga;
        int v35 = v47;
        __int16 v36 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_68:
        _os_log_impl(&dword_1879E5000, v34, v35, v36, buf, 0xCu);
      }
    }

  int v33 = v190;
  if (!v190)
  {
    __int16 v38 = v192;
    if (v186)
    {
      uint64_t v39 = a7;
      if ((*(_WORD *)(v186 + 204) & 0x100) == 0
        || !*MEMORY[0x189608EF8]
        || (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v186, *(void *)(v186 + 88)) & 1) != 0)
      {
        if (!a7) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v195 = "__nw_frame_check_validity";
      os_log_type_t v160 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        v169 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v195 = "__nw_frame_check_validity";
          _os_log_impl( &dword_1879E5000,  v169,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v160) {
        free(v160);
      }
      __int16 v38 = v192;
      uint64_t v39 = a7;
    }

    *(void *)(a1 + 1056) = 0LL;
    if (!v39)
    {
LABEL_64:
      uint64_t v40 = *(void *)(a1 + 1056);
      if (v40) {
        ++*(void *)(v40 + 232);
      }
      if (!v38 || (*(_BYTE *)(v38 + 828) & 2) == 0)
      {
        int v41 = (os_log_s *)__nwlog_tcp_log();
        uint64_t result = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result) {
          return result;
        }
        int v43 = "";
        if (v38) {
          int v43 = (const char *)(v38 + 604);
        }
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v195 = "tcp_reass";
        v196 = 2082;
        *(void *)uint64_t v197 = v43;
        _os_log_impl( &dword_1879E5000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s unable to copy frame for reassembly",  buf,  0x16u);
      }

      return 0LL;
    }

LABEL_63:
    if ((*(_BYTE *)(v3 + 828) & 2) != 0) {
      return;
    }
    uint64_t v12 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)__int128 buf = 136446466;
    int v35 = "nw_protocol_tcp_connected";
    __int16 v36 = 2082;
    uint64_t v37 = v3 + 604;
    uint64_t v11 = "%{public}s %{public}s is already connecting";
LABEL_28:
    uint64_t v13 = v12;
    os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
LABEL_41:
    _os_log_impl(&dword_1879E5000, v13, v14, v11, buf, 0x16u);
    return;
  }

  if ((*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    __int16 v10 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v35 = "nw_protocol_tcp_connected";
      __int16 v36 = 2082;
      uint64_t v37 = v3 + 604;
      uint64_t v11 = "%{public}s %{public}s is accepting an inbound connection";
      goto LABEL_40;
    }
  }

    *uint64_t v39 = 12;
    goto LABEL_64;
  }

  int v34 = a1;
  if ((*(_WORD *)(v190 + 204) & 0x4000) != 0)
  {
    *(_DWORD *)(a1 + 740) |= 0x4000000u;
    int v35 = *(_WORD *)(v190 + 204) & 0xBFFF | (*(unsigned __int8 *)(v190 + 206) << 16);
    *(_WORD *)(v190 + 204) &= ~0x4000u;
    *(_BYTE *)(v190 + 206) = BYTE2(v35);
  }

  if (*(void *)(v190 + 32) && (!v192 || (*(_BYTE *)(v192 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (v192) {
      __int16 v36 = (const char *)(v192 + 604);
    }
    else {
      __int16 v36 = "";
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v195 = "tcp_reass";
    v196 = 2082;
    *(void *)uint64_t v197 = v36;
    uint64_t v37 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v44 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v195 = "tcp_reass";
        v196 = 2082;
        *(void *)uint64_t v197 = v36;
        _os_log_impl( &dword_1879E5000,  v44,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s new_frame has next, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    if (v37) {
      free(v37);
    }
    int v33 = v190;
  }

  int v45 = *(void *)(v33 + 112);
  if (v45)
  {
    if ((*(_WORD *)(v33 + 204) & 0x100) == 0 || !*MEMORY[0x189608EF8]) {
      goto LABEL_82;
    }
    if (((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v33, *(void *)(v33 + 88)))
    {
      int v45 = *(void *)(v33 + 112);
LABEL_82:
      int v46 = v45 + *(unsigned int *)(v33 + 56);
      goto LABEL_84;
    }
  }

  int v46 = 0LL;
LABEL_84:
  if ((*(_WORD *)(v33 + 204) & 0x80) != 0) {
    *(_WORD *)(v33 + 196) -= a5;
  }
  unsigned int v47 = *(_DWORD *)(v33 + 56) + a5;
  int v48 = *(_DWORD *)(v33 + 60);
  if (v47 > *(_DWORD *)(v33 + 52) - v48)
  {
    __int16 v49 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      unsigned int v50 = *(_DWORD *)(v33 + 52);
      *(_DWORD *)__int128 buf = 136446978;
      __int16 v195 = "__nw_frame_claim_internal";
      v196 = 1024;
      *(_DWORD *)uint64_t v197 = v47;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v50;
      *(_WORD *)v198 = 1024;
      *(_DWORD *)&v198[2] = v48;
      _os_log_impl( &dword_1879E5000,  v49,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
    }

    if (!v192) {
      goto LABEL_93;
    }
LABEL_92:
    if ((*(_BYTE *)(v192 + 828) & 2) != 0) {
      goto LABEL_94;
    }
    goto LABEL_93;
  }

  *(_DWORD *)(v33 + 56) = v47;
  if (v192) {
    goto LABEL_92;
  }
LABEL_93:
  if (__nwlog_is_datapath_logging_enabled())
  {
    v157 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
    {
      BOOL v158 = (const char *)(v192 + 604);
      if (!v192) {
        BOOL v158 = "";
      }
      v159 = *(_DWORD *)(v33 + 52);
      if (v159) {
        v159 -= *(_DWORD *)(v33 + 56) + *(_DWORD *)(v33 + 60);
      }
      *(_DWORD *)__int128 buf = 136446978;
      __int16 v195 = "tcp_reass";
      v196 = 2082;
      *(void *)uint64_t v197 = v158;
      *(_WORD *)&v197[8] = 2048;
      *(void *)v198 = v33;
      *(_WORD *)&v198[8] = 1024;
      *(_DWORD *)v199 = v159;
      _os_log_impl( &dword_1879E5000,  v157,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s queueing frame %p of length %u",  buf,  0x26u);
    }
  }

uint64_t nw_protocol_tcp_reset(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_reset";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    __int16 v8 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_reset";
    int v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_20;
  }

  uint64_t v3 = nw_protocol_downcast();
  if (v3)
  {
    uint64_t v4 = v3;
    if ((*(_DWORD *)(v3 + 5224) - 1) <= 1)
    {
      *(_DWORD *)(v3 + 5308) |= 2u;
      *(_DWORD *)(v3 + 5224) = 3;
      if ((*(_BYTE *)(v3 + 828) & 2) == 0)
      {
        uint64_t v5 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v11 = "nw_protocol_tcp_reset";
          __int16 v12 = 2082;
          uint64_t v13 = v4 + 604;
          _os_log_impl(&dword_1879E5000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s force closing tcp", buf, 0x16u);
        }
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 16LL))(v4, 1LL, v1);
      if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0 || (*(_BYTE *)(v4 + 365) & 0x20) != 0)
      {
        *(_DWORD *)(v4 + 16) = 0;
        *(_DWORD *)(v4 + 372) |= 0x80u;
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 24LL))(v4, 1LL, v1);
      tcp_close_locked(v4);
    }

    *(_DWORD *)(v4 + 5308) &= 0xFFFFFFDD;
    *(_DWORD *)(v4 + 5224) = 0;
    bzero((void *)v4, 0x1440uLL);
    nw_protocol_tcp_initialize(a1);
    return 1LL;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v11 = "nw_protocol_tcp_reset";
  uint64_t v7 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    __int16 v8 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = "nw_protocol_tcp_reset";
      int v9 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_20:
      _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
    }
  }

LABEL_21:
  if (v7) {
    free(v7);
  }
  return 0LL;
}

    if (v5) {
      free(v5);
    }
    return 0LL;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 && *(void *)(v3 + 5208) && *(void *)(v3 + 5216)) {
    return nw_path_flow_registration_get_tfo_cookie();
  }
  return 0LL;
}

    *(_DWORD *)(a1 + 600) = a2;
    set_tcp_stream_priority(a1);
    goto LABEL_22;
  }

  if (a2 > 199)
  {
    if (a2 != 200 && a2 != 300 && a2 != 400) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }

  if (!a2 || a2 == 100) {
    goto LABEL_21;
  }
LABEL_23:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
  return v5;
}

void nw_protocol_tcp_disconnected(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((*(_BYTE *)(v1 + 828) & 2) == 0)
      {
        uint64_t v3 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v10 = "nw_protocol_tcp_disconnected";
          __int16 v11 = 2082;
          uint64_t v12 = v2 + 604;
          _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s output protocol is disconnected",  buf,  0x16u);
        }
      }

      int v4 = *(_DWORD *)(v2 + 5308);
      if ((v4 & 4) != 0)
      {
        if ((*(_BYTE *)(v2 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
        {
          uint64_t v6 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v10 = "nw_protocol_tcp_disconnected";
            __int16 v11 = 2082;
            uint64_t v12 = v2 + 604;
            _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }

      else
      {
        *(_DWORD *)(v2 + 5308) = v4 | 4;
        *(_OWORD *)(v2 + 4128) = 0u;
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v10 = "nw_protocol_tcp_disconnected";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v10 = "nw_protocol_tcp_disconnected";
        __int16 v8 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v10 = "nw_protocol_tcp_disconnected";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v7 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v10 = "nw_protocol_tcp_disconnected";
        __int16 v8 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
  }

  if (v5) {
    free(v5);
  }
}

uint64_t nw_protocol_tcp_waiting_for_output(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1) {
      return (*(unsigned __int8 *)(v1 + 5308) >> 5) & 1;
    }
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
        uint64_t v5 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_12;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v7 = "nw_protocol_tcp_waiting_for_output";
        uint64_t v5 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_12:
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

void nw_protocol_tcp_output_finished(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if (*(_DWORD *)(v1 + 5224) == 2)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v4 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446210;
            int v9 = "nw_protocol_tcp_output_finished";
            _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s ", buf, 0xCu);
          }
        }

        (*(void (**)(uint64_t))(*(void *)(*(void *)(v2 + 8) + 40LL) + 80LL))(v2);
      }

      else if ((*(_BYTE *)(v1 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v5 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v9 = "nw_protocol_tcp_output_finished";
            __int16 v10 = 2082;
            uint64_t v11 = v2 + 604;
            _os_log_impl(&dword_1879E5000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
          }
        }
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_protocol_tcp_output_finished";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v9 = "nw_protocol_tcp_output_finished";
        uint64_t v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_protocol_tcp_output_finished";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v9 = "nw_protocol_tcp_output_finished";
        uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_21:
        _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }

  if (v3) {
    free(v3);
  }
}

uint64_t nw_protocol_tcp_updated_path(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v166 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v135 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (v165[0] != 17)
    {
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      if (os_log_type_enabled(v136, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_341;
      }

      goto LABEL_342;
    }

    unsigned int v136 = (os_log_s *)__nwlog_obj();
    os_log_type_t v137 = v165[0];
    if (!os_log_type_enabled(v136, (os_log_type_t)v165[0])) {
      goto LABEL_342;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v138 = "%{public}s called with null protocol";
LABEL_341:
    _os_log_impl(&dword_1879E5000, v136, v137, v138, buf, 0xCu);
    goto LABEL_342;
  }

  uint64_t v4 = v3;
  uint64_t v7 = nw_protocol_downcast();
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v135 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (v165[0] != 17)
    {
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      if (os_log_type_enabled(v136, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_341;
      }

      goto LABEL_342;
    }

    unsigned int v136 = (os_log_s *)__nwlog_obj();
    os_log_type_t v137 = v165[0];
    if (!os_log_type_enabled(v136, (os_log_type_t)v165[0])) {
      goto LABEL_342;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v138 = "%{public}s called with null tcp";
    goto LABEL_341;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v135 = (void *)_os_log_send_and_compose_impl();
    v165[0] = 16;
    v164[0] = 0;
    if (v165[0] != 17)
    {
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      if (os_log_type_enabled(v136, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_341;
      }

      goto LABEL_342;
    }

    unsigned int v136 = (os_log_s *)__nwlog_obj();
    os_log_type_t v137 = v165[0];
    if (!os_log_type_enabled(v136, (os_log_type_t)v165[0])) {
      goto LABEL_342;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v149 = "nw_protocol_tcp_updated_path";
    unsigned int v138 = "%{public}s called with null path";
    goto LABEL_341;
  }

  uint64_t v8 = (void **)v7;
  uint64_t v9 = *(void *)(v7 + 1280);
  if ((*(_BYTE *)(v7 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      v139 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v139, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        __int16 v150 = 2082;
        *(void *)__int16 v151 = (char *)v8 + 604;
        _os_log_impl(&dword_1879E5000, v139, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ", buf, 0x16u);
      }
    }
  }

  if (v8[651] != a3)
  {
    __int16 v10 = nw_retain(a3);
    uint64_t v11 = v8[651];
    if (v11) {
      nw_release(v11);
    }
    v8[651] = v10;
    else {
      int v12 = 0;
    }
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFDFFF | v12;
  }

  nw_proto_tcp_notify_segmentation_offload(a1);
  uint64_t v13 = (uint64_t)*v8;
  if (*v8)
  {
    uint64_t v14 = *(void *)(v13 + 496);
    if (v14 && *(_BYTE *)(v14 + 1496))
    {
      uint64_t v15 = *(void **)(v14 + 1488);
      if (v15)
      {
        free(v15);
        uint64_t v13 = (uint64_t)*v8;
        *(void *)((*v8)[62] + 1488LL) = 0LL;
        uint64_t v14 = *(void *)(v13 + 496);
      }

      *(_BYTE *)(v14 + 1496) = 0;
    }

    *(void *)(v13 + 496) = 0LL;
    tcp_mtudisc(*v8);
  }

  unsigned int v16 = v8[652];
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    uint64_t v17 = (void *)nw_parameters_copy_context();
    v8[652] = (void *)nw_path_copy_flow_registration();
    if (v17) {
      nw_release(v17);
    }
    if (v16) {
      nw_release(v16);
    }
    int v18 = *((_DWORD *)v8 + 1306);
    if ((v18 - 1) > 1)
    {
LABEL_82:
      if ((v18 | 4) == 4) {
        goto LABEL_287;
      }
      int v48 = v8[652];
      if (!v8[651]) {
        goto LABEL_164;
      }
      if (!v48) {
        goto LABEL_166;
      }
      *(_DWORD *)v165 = 0;
      *(_DWORD *)os_log_type_t v164 = 0;
      if (!nw_path_flow_registration_get_ctl_command())
      {
LABEL_163:
        int v48 = v8[652];
LABEL_164:
LABEL_166:
        if (tcp_perf_measurement)
        {
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              unsigned int v78 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
              {
                BOOL v79 = "defunct";
                signed int v80 = v8[652];
                __int16 v149 = "nw_protocol_tcp_updated_path";
                *(_DWORD *)__int128 buf = 136446722;
                __int16 v150 = 2082;
                if (!v80) {
                  BOOL v79 = "unregistered";
                }
                *(void *)__int16 v151 = (char *)v8 + 604;
                *(_WORD *)&v151[8] = 2082;
                *(void *)unsigned int v152 = v79;
                os_log_type_t v81 = v78;
                os_log_type_t v82 = OS_LOG_TYPE_DEBUG;
LABEL_178:
                _os_log_impl(&dword_1879E5000, v81, v82, "%{public}s %{public}s flow is %{public}s", buf, 0x20u);
              }
            }
          }
        }

        else if ((*((_BYTE *)v8 + 828) & 2) == 0)
        {
          os_log_type_t v83 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
          {
            uint32_t v84 = "defunct";
            uint64_t v85 = v8[652];
            __int16 v149 = "nw_protocol_tcp_updated_path";
            *(_DWORD *)__int128 buf = 136446722;
            __int16 v150 = 2082;
            if (!v85) {
              uint32_t v84 = "unregistered";
            }
            *(void *)__int16 v151 = (char *)v8 + 604;
            *(_WORD *)&v151[8] = 2082;
            *(void *)unsigned int v152 = v84;
            os_log_type_t v81 = v83;
            os_log_type_t v82 = OS_LOG_TYPE_INFO;
            goto LABEL_178;
          }
        }

        ((void (*)(void **, uint64_t, uint64_t))v8[1][2])(v8, 1LL, v3);
        uint64_t v86 = v8 + 61;
        os_log_type_t v87 = v8 + 48;
        int v88 = *((_DWORD *)v8 + 91);
        if ((v88 & 8) == 0)
        {
          if ((v88 & 0x8000) != 0)
          {
            if ((*((_BYTE *)v8 + 828) & 2) == 0)
            {
              if (__nwlog_is_datapath_logging_enabled())
              {
                os_log_type_t v95 = (os_log_s *)__nwlog_tcp_log();
                if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 136446978;
                  __int16 v149 = "sosetdefunct";
                  __int16 v150 = 2082;
                  *(void *)__int16 v151 = (char *)v8 + 604;
                  *(_WORD *)&v151[8] = 2082;
                  *(void *)unsigned int v152 = "process_suspended";
                  *(_WORD *)&v152[8] = 1024;
                  LODWORD(v153) = 102;
                  _os_log_impl( &dword_1879E5000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s level %{public}s flow is not eligible for defunct (%d)",  buf,  0x26u);
                }
              }
            }

            goto LABEL_286;
          }

          *((_DWORD *)v8 + 91) = v88 | 8;
          *((_DWORD *)v8 + 108) |= 0x80u;
          *((_DWORD *)v8 + 134) |= 0x80u;
          if (*((_DWORD *)v8 + 122))
          {
            sbflush((uint64_t)(v8 + 61));
            *((_DWORD *)v8 + 123) = 0;
            uint64_t v89 = v8[70][3];
            if (((_BYTE)v8[67] & 4) != 0)
            {
              if (v89)
              {
                uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                if (all_stats) {
                  *(_DWORD *)(all_stats + 88) = *((_DWORD *)v8 + 123);
                }
              }
            }

            else if (v89)
            {
              uint64_t v90 = nw_protocol_tcp_get_all_stats();
              if (v90) {
                *(_DWORD *)(v90 + 100) = *((_DWORD *)v8 + 123);
              }
            }
          }

          if (*v87)
          {
            sbflush((uint64_t)(v8 + 48));
            *((_DWORD *)v8 + 97) = 0;
            uint64_t v100 = v8[57][3];
            if (((_BYTE)v8[54] & 4) != 0)
            {
              if (v100)
              {
                uint64_t v102 = nw_protocol_tcp_get_all_stats();
                if (v102) {
                  *(_DWORD *)(v102 + 88) = *((_DWORD *)v8 + 97);
                }
              }
            }

            else if (v100)
            {
              uint64_t v101 = nw_protocol_tcp_get_all_stats();
              if (v101) {
                *(_DWORD *)(v101 + 100) = *((_DWORD *)v8 + 97);
              }
            }
          }

LABEL_219:
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            if (__nwlog_is_datapath_logging_enabled())
            {
              v144 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
              {
                char v145 = "is already";
                *(_DWORD *)__int128 buf = 136446978;
                __int16 v149 = "sosetdefunct";
                if ((v88 & 8) == 0) {
                  char v145 = "marked as";
                }
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                *(_WORD *)&v151[8] = 2082;
                *(void *)unsigned int v152 = "process_suspended";
                *(_WORD *)&v152[8] = 2082;
                __int16 v153 = v145;
                _os_log_impl( &dword_1879E5000,  v144,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s level %{public}s flow %{public}s defunct",  buf,  0x2Au);
              }
            }
          }

          if ((*((_BYTE *)v8 + 364) & 8) == 0)
          {
            if ((*((_BYTE *)v8 + 828) & 2) == 0)
            {
              __nwlog_tcp_log();
              *(_DWORD *)__int128 buf = 136446466;
              __int16 v149 = "sodefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              unsigned int v104 = (void *)_os_log_send_and_compose_impl();
              v165[0] = 16;
              v164[0] = 0;
              if (v165[0] == 17)
              {
                v105 = (os_log_s *)__nwlog_tcp_log();
                os_log_type_t v106 = v165[0];
                if (!os_log_type_enabled(v105, (os_log_type_t)v165[0])) {
                  goto LABEL_284;
                }
                *(_DWORD *)__int128 buf = 136446466;
                __int16 v149 = "sodefunct";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                v107 = "%{public}s %{public}s improperly called sodefunct";
              }

              else if (v164[0])
              {
                backtrace_string = (void *)__nw_create_backtrace_string();
                v105 = (os_log_s *)__nwlog_tcp_log();
                os_log_type_t v106 = v165[0];
                BOOL v122 = os_log_type_enabled(v105, (os_log_type_t)v165[0]);
                if (backtrace_string)
                {
                  if (v122)
                  {
                    *(_DWORD *)__int128 buf = 136446722;
                    __int16 v149 = "sodefunct";
                    __int16 v150 = 2082;
                    *(void *)__int16 v151 = (char *)v8 + 604;
                    *(_WORD *)&v151[8] = 2082;
                    *(void *)unsigned int v152 = backtrace_string;
                    _os_log_impl( &dword_1879E5000,  v105,  v106,  "%{public}s %{public}s improperly called sodefunct, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(backtrace_string);
                  goto LABEL_284;
                }

                if (!v122)
                {
LABEL_284:
                  if (v104) {
                    free(v104);
                  }
                  goto LABEL_286;
                }

                *(_DWORD *)__int128 buf = 136446466;
                __int16 v149 = "sodefunct";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                v107 = "%{public}s %{public}s improperly called sodefunct, no backtrace";
              }

              else
              {
                v105 = (os_log_s *)__nwlog_tcp_log();
                os_log_type_t v106 = v165[0];
                if (!os_log_type_enabled(v105, (os_log_type_t)v165[0])) {
                  goto LABEL_284;
                }
                *(_DWORD *)__int128 buf = 136446466;
                __int16 v149 = "sodefunct";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                v107 = "%{public}s %{public}s improperly called sodefunct, backtrace limit exceeded";
              }

              _os_log_impl(&dword_1879E5000, v105, v106, v107, buf, 0x16u);
              goto LABEL_284;
            }

LABEL_286:
            ((void (*)(void **, uint64_t, uint64_t))v8[1][3])(v8, 1LL, v4);
LABEL_287:
            nw_protocol_get_output_handler();
            nw_protocol_get_output_handler();
            return nw_protocol_updated_path();
          }

          uint64_t v108 = (uint64_t)*v8;
          if ((*((_BYTE *)v8 + 828) & 2) == 0)
          {
            v109 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v109, OS_LOG_TYPE_INFO))
            {
              int v110 = *(_DWORD *)v8[1][1];
              if (v110 == 2) {
                v111 = (const void *)(v108 + 492);
              }
              else {
                v111 = (const void *)(v108 + 480);
              }
              v112 = inet_ntop(v110, v111, v165, 0x40u);
              unsigned int v113 = bswap32(*(unsigned __int16 *)(v108 + 2226)) >> 16;
              int v114 = *(_DWORD *)v8[1][1];
              if (v114 == 2) {
                v115 = (const void *)(v108 + 476);
              }
              else {
                v115 = (const void *)(v108 + 464);
              }
              v116 = inet_ntop(v114, v115, v164, 0x40u);
              unsigned int v117 = bswap32(*(unsigned __int16 *)(v108 + 2224)) >> 16;
              int v118 = *((_DWORD *)v8 + 134);
              int v119 = *((_DWORD *)v8 + 108);
              *(_DWORD *)__int128 buf = 136448259;
              __int16 v149 = "sodefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              os_log_type_t v87 = v8 + 48;
              uint64_t v4 = v3;
              *(_WORD *)&v151[8] = 2082;
              *(void *)unsigned int v152 = "process_suspended";
              *(_WORD *)&v152[8] = 2081;
              __int16 v153 = v112;
              __int16 v154 = 1024;
              unsigned int v155 = v113;
              __int16 v156 = 2081;
              v157 = v116;
              __int16 v158 = 1024;
              unsigned int v159 = v117;
              __int16 v160 = 1024;
              int v161 = v118;
              __int16 v162 = 1024;
              int v163 = v119;
              _os_log_impl( &dword_1879E5000,  v109,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s level %{public}s flow [TCP %{private}s:%d -> %{private}s:%d] is now defunct [rcv_f l 0x%x, snd_fl 0x%x]",  buf,  0x4Cu);
            }
          }

          *((_DWORD *)v8 + 92) |= 8u;
          if (((_BYTE)v8[67] & 1) != 0)
          {
            sbunlock((uint64_t)v86);
            if (((_BYTE)v8[54] & 1) == 0)
            {
LABEL_239:
              __int16 v120 = *((_WORD *)v8 + 188);
              if ((v120 & 0x20) == 0) {
                goto LABEL_240;
              }
              goto LABEL_249;
            }
          }

          else if (((_BYTE)v8[54] & 1) == 0)
          {
            goto LABEL_239;
          }

          sbunlock((uint64_t)v87);
          __int16 v120 = *((_WORD *)v8 + 188);
          if ((v120 & 0x20) == 0)
          {
LABEL_240:
            sorflush((uint64_t)v8);
            __int16 v120 = *((_WORD *)v8 + 188);
            if ((v120 & 0x10) == 0)
            {
LABEL_250:
              *((_WORD *)v8 + 188) = v120 | 0x10;
              int v123 = v8[4];
              if (v123)
              {
                unsigned int v124 = (void (*)(void **))v123[2];
                if (v124) {
                  v124(v8);
                }
              }

              uint64_t v125 = *(void *)(v108 + 240);
              *((_WORD *)v8 + 189) = 53;
              user_north_signal_error((uint64_t)v8);
              tcp_close(v125);
              __int16 v120 = *((_WORD *)v8 + 188);
            }

LABEL_254:
            if ((v120 & 0xA) == 2) {
              (*(void (**)(void **))(v8[1][5] + 40LL))(v8);
            }
            if ((*((_BYTE *)v8 + 365) & 0x20) == 0)
            {
              *((_WORD *)v8 + 188) = (_WORD)v8[47] & 0xDFC1 | 0x2030;
              os_log_t v126 = v8[4];
              if (v126)
              {
                v127 = (void (*)(void **))v126[7];
                if (v127) {
                  v127(v8);
                }
              }
            }

            if (!*((_WORD *)v8 + 189)) {
              *((_WORD *)v8 + 189) = 9;
            }
            if (*v86)
            {
              sbflush((uint64_t)v86);
              *((_DWORD *)v8 + 123) = 0;
              uint64_t v128 = v8[70][3];
              if (((_BYTE)v8[67] & 4) != 0)
              {
                if (v128)
                {
                  uint64_t v130 = nw_protocol_tcp_get_all_stats();
                  if (v130) {
                    *(_DWORD *)(v130 + 88) = *((_DWORD *)v8 + 123);
                  }
                }
              }

              else if (v128)
              {
                uint64_t v129 = nw_protocol_tcp_get_all_stats();
                if (v129) {
                  *(_DWORD *)(v129 + 100) = *((_DWORD *)v8 + 123);
                }
              }
            }

            if (*v87)
            {
              sbflush((uint64_t)v87);
              *((_DWORD *)v8 + 97) = 0;
              uint64_t v131 = v8[57][3];
              if (((_BYTE)v8[54] & 4) != 0)
              {
                if (v131)
                {
                  uint64_t v133 = nw_protocol_tcp_get_all_stats();
                  if (v133) {
                    *(_DWORD *)(v133 + 88) = *((_DWORD *)v8 + 97);
                  }
                }
              }

              else if (v131)
              {
                uint64_t v132 = nw_protocol_tcp_get_all_stats();
                if (v132) {
                  *(_DWORD *)(v132 + 100) = *((_DWORD *)v8 + 97);
                }
              }
            }

            *((_WORD *)v8 + 188) |= 0x8000u;
            goto LABEL_286;
          }

LABEL_249:
          if ((v120 & 0x10) == 0) {
            goto LABEL_250;
          }
          goto LABEL_254;
        }

        if (((_DWORD)v8[54] & (_DWORD)v8[67] & 0x80) != 0 || (*((_BYTE *)v8 + 828) & 2) != 0) {
          goto LABEL_219;
        }
        __nwlog_tcp_log();
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v149 = "sosetdefunct";
        __int16 v150 = 2082;
        *(void *)__int16 v151 = (char *)v8 + 604;
        unsigned int v91 = (void *)_os_log_send_and_compose_impl();
        v165[0] = 16;
        v164[0] = 0;
        if (__nwlog_fault())
        {
          if (v165[0] == 17)
          {
            BOOL v92 = (os_log_s *)__nwlog_tcp_log();
            os_log_type_t v93 = v165[0];
            if (os_log_type_enabled(v92, (os_log_type_t)v165[0]))
            {
              *(_DWORD *)__int128 buf = 136446466;
              __int16 v149 = "sosetdefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              v94 = "%{public}s %{public}s SB_DROP not set";
LABEL_214:
              unsigned int v103 = v92;
LABEL_215:
              _os_log_impl(&dword_1879E5000, v103, v93, v94, buf, 0x16u);
            }
          }

          else if (v164[0])
          {
            __int16 v96 = (void *)__nw_create_backtrace_string();
            int v97 = (os_log_s *)__nwlog_tcp_log();
            os_log_type_t v93 = v165[0];
            log = v97;
            BOOL v98 = os_log_type_enabled(v97, (os_log_type_t)v165[0]);
            if (v96)
            {
              if (v98)
              {
                *(_DWORD *)__int128 buf = 136446722;
                __int16 v149 = "sosetdefunct";
                __int16 v150 = 2082;
                *(void *)__int16 v151 = (char *)v8 + 604;
                *(_WORD *)&v151[8] = 2082;
                *(void *)unsigned int v152 = v96;
                _os_log_impl( &dword_1879E5000,  log,  v93,  "%{public}s %{public}s SB_DROP not set, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v96);
              goto LABEL_216;
            }

            if (v98)
            {
              *(_DWORD *)__int128 buf = 136446466;
              __int16 v149 = "sosetdefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              v94 = "%{public}s %{public}s SB_DROP not set, no backtrace";
              unsigned int v103 = log;
              goto LABEL_215;
            }
          }

          else
          {
            BOOL v92 = (os_log_s *)__nwlog_tcp_log();
            os_log_type_t v93 = v165[0];
            if (os_log_type_enabled(v92, (os_log_type_t)v165[0]))
            {
              *(_DWORD *)__int128 buf = 136446466;
              __int16 v149 = "sosetdefunct";
              __int16 v150 = 2082;
              *(void *)__int16 v151 = (char *)v8 + 604;
              v94 = "%{public}s %{public}s SB_DROP not set, backtrace limit exceeded";
              goto LABEL_214;
            }
          }
        }

LABEL_216:
        if (v91) {
          free(v91);
        }
        uint64_t v86 = v8 + 61;
        goto LABEL_219;
      }

      if ((*((_BYTE *)v8 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          v146 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v146, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446978;
            __int16 v149 = "nw_protocol_tcp_updated_path";
            __int16 v150 = 2082;
            *(void *)__int16 v151 = (char *)v8 + 604;
            *(_WORD *)&v151[8] = 1024;
            *(_DWORD *)unsigned int v152 = *(_DWORD *)v165;
            *(_WORD *)&v152[4] = 1024;
            *(_DWORD *)&v152[6] = *(_DWORD *)v164;
            _os_log_impl( &dword_1879E5000,  v146,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Protocol event %d=%d",  buf,  0x22u);
          }
        }
      }

      uint64_t v49 = *(unsigned int *)v165;
      unint64_t v50 = *(unsigned int *)v164;
      __int16 v51 = (unsigned int *)(v8 + 161);
LABEL_89:
      unsigned int v52 = *v51;
      if ((unsigned __int16)*v51 == 0xFFFF)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v72 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446210;
            __int16 v149 = "tcp_ctlinput";
            _os_log_impl( &dword_1879E5000,  v72,  OS_LOG_TYPE_DEBUG,  "%{public}s PCB marked as WNT_STOPUSING, exiting early",  buf,  0xCu);
          }
        }

        goto LABEL_163;
      }

      do
      {
        unsigned int v53 = __ldxr(v51);
        if (v53 != v52)
        {
          __clrex();
          goto LABEL_89;
        }
      }

      while (__stxr(v52 + 1, v51));
      uint64_t v54 = v8[132][1];
      int v55 = **(_DWORD **)(v54 + 8);
      if (v55 == 30)
      {
        if (v8[162] == (void *)*MEMORY[0x1895FB7E8] && v8[163] == *(void **)(MEMORY[0x1895FB7E8] + 8LL))
        {
          int v56 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            __int16 v149 = "tcp_ctlinput";
            int v57 = "%{public}s Protocol event reported for socket with faddr IN6ADDR_ANY";
            goto LABEL_141;
          }

          *(_DWORD *)__int128 buf = v17;
          break;
        case 529:
          uint64_t v17 = (*(_DWORD *)(v2 + 2232) >> 6) & 1;
          goto LABEL_216;
        case 530:
          if (*(void *)(a2 + 24) != 48LL) {
            return 22LL;
          }
          memset(buf, 0, 48);
          tcp_get_notify_ack_count(v8, (int *)buf);
          if (*(_DWORD *)&buf[4])
          {
            tcp_get_notify_ack_ids(v8, (uint64_t)buf);
            uint64_t v64 = *(void *)(a2 + 24);
          }

          else
          {
            uint64_t v64 = 48LL;
          }

          if (v64 >= 48) {
            __int16 v77 = 48LL;
          }
          else {
            __int16 v77 = v64;
          }
          *(void *)(a2 + 24) = v77;
          int v20 = *(void **)(a2 + 16);
          goto LABEL_222;
        case 536:
          uint64_t v17 = HIBYTE(*(_DWORD *)(v8 + 740)) & 1;
          goto LABEL_216;
        case 539:
          uint64_t v17 = (*(_DWORD *)(v8 + 740) >> 27) & 1;
          goto LABEL_216;
        default:
          if (v16 != 4357) {
            return result;
          }
          uint64_t v17 = (*(_DWORD *)(a1 + 368) >> 13) & 1;
          goto LABEL_216;
      }
    }

    else
    {
      switch(v16)
      {
        case 1:
          uint64_t v17 = *(_DWORD *)(v8 + 88) & 4;
          goto LABEL_216;
        case 2:
          uint64_t v17 = *(_DWORD *)(v8 + 196);
          goto LABEL_216;
        case 3:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
          return result;
        case 4:
          uint64_t v17 = *(_DWORD *)(v8 + 88) & 0x1000;
          goto LABEL_216;
        case 8:
          uint64_t v17 = *(_DWORD *)(v8 + 88) & 8;
          goto LABEL_216;
        case 16:
          uint64_t v59 = *(_DWORD *)(v8 + 676);
          if (!v59)
          {
            uint64_t v60 = *(_DWORD *)(sysctls + 192);
LABEL_196:
            uint64_t v17 = v60 / 1000;
            goto LABEL_216;
          }

LABEL_162:
          in_pcb_checkstate((uint64_t)(v8 + 104), 2LL, 0);
          goto LABEL_163;
        }
      }

      else
      {
        if (v55 != 2)
        {
          os_log_type_t v70 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            int v71 = **(_DWORD **)(v8[132][1] + 8LL);
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v149 = "tcp_ctlinput";
            __int16 v150 = 1024;
            *(_DWORD *)__int16 v151 = v71;
            _os_log_impl( &dword_1879E5000,  v70,  OS_LOG_TYPE_ERROR,  "%{public}s Protocol event reported for unknown address family %d",  buf,  0x12u);
          }

          goto LABEL_162;
        }

        if (!*((_DWORD *)v8 + 327))
        {
          int v56 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            __int16 v149 = "tcp_ctlinput";
            int v57 = "%{public}s Protocol event reported for socket with faddr INADDR_ANY";
LABEL_141:
            _os_log_impl(&dword_1879E5000, v56, OS_LOG_TYPE_ERROR, v57, buf, 0xCu);
            goto LABEL_162;
          }

          goto LABEL_162;
        }
      }

      if ((_DWORD)v49 == 5)
      {
        os_log_type_t v69 = (void (*)(uint64_t, int))tcp_mtudisc;
      }

      else if (*(_DWORD *)(sysctls + 168) && ((1 << v49) & 0x240C00) != 0)
      {
        os_log_type_t v69 = tcp_drop_syn_sent;
      }

      else
      {
        if ((_DWORD)v49 == 4 || ((0xFC01FuLL >> v49) & 1) != 0) {
          goto LABEL_162;
        }
        os_log_type_t v69 = tcp_notify;
      }

      (*(void (**)(void))(v54 + 16))();
      int v73 = v8[134];
      if ((int)v73[23] > 0 || -v73[24] >= 1)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v74 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            int v75 = v73[23];
            int v76 = v73[24];
            *(_DWORD *)__int128 buf = 136446978;
            __int16 v149 = "tcp_ctlinput";
            __int16 v150 = 1024;
            *(_DWORD *)__int16 v151 = 0;
            *(_WORD *)&v151[4] = 1024;
            *(_DWORD *)&v151[6] = v75;
            *(_WORD *)unsigned int v152 = 1024;
            *(_DWORD *)&v152[2] = v76;
            _os_log_impl( &dword_1879E5000,  v74,  OS_LOG_TYPE_DEBUG,  "%{public}s ICMP response for ineligible TCP seq num (%d, una %d max %d)",  buf,  0x1Eu);
          }
        }

        goto LABEL_161;
      }

      if ((_DWORD)v49 == 5 && (tcp_handle_msgsize((uint64_t)v8[166], v50), (*((_BYTE *)v8 + 3068) & 2) != 0))
      {
        __int16 v77 = "(@A3A==(A";
      }

      else
      {
        __int16 v77 = (char *)&tcpctlerrmap + v49;
      }

      v69((uint64_t)(v8 + 104), *(unsigned __int8 *)v77);
LABEL_161:
      (*(void (**)(void))(v8[132][1] + 24LL))();
      goto LABEL_162;
    }

    int is_traffic_mgmt_background = nw_path_is_traffic_mgmt_background();
    if (((is_traffic_mgmt_background ^ ((*((_BYTE *)v8 + 5308) & 8) == 0)) & 1) != 0)
    {
LABEL_46:
      int effective_traffic_class = nw_path_get_effective_traffic_class();
      tcp_set_traffic_class((uint64_t)v8, effective_traffic_class);
      int should_probe_connectivity = nw_path_should_probe_connectivity();
      if (((should_probe_connectivity ^ ((*((_BYTE *)v8 + 5308) & 0x10) == 0)) & 1) != 0)
      {
        if (!v9)
        {
LABEL_81:
          int v18 = *((_DWORD *)v8 + 1306);
          goto LABEL_82;
        }

        goto LABEL_78;
      }

      int v33 = should_probe_connectivity;
      if (tcp_perf_measurement)
      {
        if ((*((_BYTE *)v8 + 828) & 2) != 0) {
          goto LABEL_62;
        }
        int v34 = (os_log_s *)__nwlog_tcp_log();
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_62;
        }
        int v35 = "disabled";
        __int16 v149 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)__int16 v151 = (char *)v8 + 604;
        __int16 v150 = 2082;
        if (v33) {
          int v35 = "enabled";
        }
        *(_WORD *)&v151[8] = 2082;
        *(void *)unsigned int v152 = v35;
        __int16 v36 = v34;
        os_log_type_t v37 = OS_LOG_TYPE_DEBUG;
      }

      else
      {
        if ((*((_BYTE *)v8 + 828) & 2) != 0) {
          goto LABEL_62;
        }
        __int16 v38 = (os_log_s *)__nwlog_tcp_log();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
          goto LABEL_62;
        }
        uint64_t v39 = "disabled";
        __int16 v149 = "nw_protocol_tcp_updated_path";
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)__int16 v151 = (char *)v8 + 604;
        __int16 v150 = 2082;
        if (v33) {
          uint64_t v39 = "enabled";
        }
        *(_WORD *)&v151[8] = 2082;
        *(void *)unsigned int v152 = v39;
        __int16 v36 = v38;
        os_log_type_t v37 = OS_LOG_TYPE_INFO;
      }

      _os_log_impl(&dword_1879E5000, v36, v37, "%{public}s %{public}s probe connectivity %{public}s", buf, 0x20u);
LABEL_62:
      if (v33) {
        int v40 = 16;
      }
      else {
        int v40 = 0;
      }
      *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFEF | v40;
      if (!v9) {
        goto LABEL_81;
      }
      if (v33) {
        int v41 = 8;
      }
      else {
        int v41 = 0;
      }
      *(_DWORD *)(v9 + 1052) = *(_DWORD *)(v9 + 1052) & 0xFFFFFFF7 | v41;
      uint64_t v42 = nw_tcp_access_globals((uint64_t)v8[132]);
      v43.n128_f64[0] = calculate_tcp_clock(v42);
      int v44 = (unsigned int *)(v8 + 161);
LABEL_70:
      unsigned int v45 = *v44;
      if ((unsigned __int16)*v44 == 0xFFFF)
      {
LABEL_78:
        if (*(unsigned __int8 *)(v9 + 1076) == 255 || *(_DWORD *)(v9 + 1024) == 255)
        {
          __int16 recommended_mss = nw_path_get_recommended_mss();
          *(_DWORD *)(v9 + 8) |= 0x8000u;
          *(_WORD *)(v9 + 72) = recommended_mss;
        }

        goto LABEL_81;
      }

      do
      {
        unsigned int v46 = __ldxr(v44);
        if (v46 != v45)
        {
          __clrex();
          goto LABEL_70;
        }
      }

      while (__stxr(v45 + 1, v44));
      (*(void (**)(__n128))(v8[132][1] + 16LL))(v43);
      if (!v8[134] || in_pcb_checkstate((uint64_t)(v8 + 104), 2LL, 1) == 0xFFFF)
      {
LABEL_77:
        (*(void (**)(void))(v8[132][1] + 24LL))();
        goto LABEL_78;
      }

      int v58 = v8[134];
      if (!v33)
      {
        if (!*((_BYTE *)v58 + 265) && ((*((_BYTE *)v58 + 740) & 0x80) != 0 || *((_BYTE *)v58 + 311))) {
          tcp_keepalive_reset((uint64_t)v8[134]);
        }
        if (v8[132][3])
        {
          uint64_t v64 = nw_protocol_tcp_get_all_stats();
          if (v64) {
            *(_BYTE *)(v64 + 96) &= ~1u;
          }
        }

        if (v8[132][3])
        {
          uint64_t v65 = nw_protocol_tcp_get_all_stats();
          if (v65) {
            *(_BYTE *)(v65 + 96) &= ~2u;
          }
        }

        if (v8[132][3])
        {
          uint64_t v66 = nw_protocol_tcp_get_all_stats();
          if (v66) {
            *(_BYTE *)(v66 + 96) &= ~4u;
          }
        }

        if (v8[132][3])
        {
          uint64_t v67 = nw_protocol_tcp_get_all_stats();
          if (v67) {
            *(_BYTE *)(v67 + 96) &= ~8u;
          }
        }

        goto LABEL_77;
      }

      uint64_t v59 = nw_tcp_access_globals(*(void *)(v58[10] + 224LL));
      if (*((_DWORD *)v58 + 3) != 4
        || *((_DWORD *)v58 + 24) != *((_DWORD *)v58 + 23)
        || (uint64_t v60 = v58[10], *(void *)(v60 + 448) != v9)
        || (int v61 = *((_DWORD *)v58 + 185), (v61 & 0x80) != 0)
        || *((_BYTE *)v58 + 311))
      {
        char v62 = 0;
        goto LABEL_106;
      }

      uint64_t v140 = v59;
      *((_DWORD *)v58 + 185) = v61 | 0x80;
      *((_BYTE *)v58 + 311) = 0;
      *((_DWORD *)v58 + 10) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(v60 + 224)) + 316)
                            - *((_DWORD *)v58 + 16)
                            + 10;
      if (*((_WORD *)v58 + 36) == 8)
      {
        *((_WORD *)v58 + 36) = 6;
        unsigned int v141 = *(_DWORD *)(v140 + 316) + 10;
      }

      else
      {
        unsigned int v141 = *(_DWORD *)(v140 + 316) + 10;
        if ((int)(*((_DWORD *)v58 + 17) - v141) < 1)
        {
LABEL_326:
          char v62 = 1;
LABEL_106:
          if (v8[132][3])
          {
            uint64_t v63 = nw_protocol_tcp_get_all_stats();
            if (v63) {
              *(_BYTE *)(v63 + 96) |= 1u;
            }
          }

          (*(void (**)(void))(v8[132][1] + 24LL))();
          if ((v62 & 1) != 0)
          {
            if ((*(_BYTE *)(v42 + 310) & 1) != 0)
            {
              *(_DWORD *)(v42 + 296) |= 1u;
            }

            else if ((*(_BYTE *)(v42 + 310) & 2) == 0 || *(_DWORD *)(v42 + 272) - *(_DWORD *)(v42 + 316) - 10 >= 1)
            {
              *(_DWORD *)(v42 + 292) = 1;
              *(_DWORD *)(v42 + 304) = 0;
              tcp_sched_timerlist(v42, 0xAu);
            }
          }

          goto LABEL_78;
        }

        *((_WORD *)v58 + 36) = 6;
        if (v141 <= 1) {
          unsigned int v141 = 1;
        }
      }

      *((_DWORD *)v58 + 17) = v141;
      goto LABEL_326;
    }

    int v20 = is_traffic_mgmt_background;
    if (tcp_perf_measurement)
    {
      if ((*((_BYTE *)v8 + 828) & 2) != 0) {
        goto LABEL_36;
      }
      int v21 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_36;
      }
      int v22 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)__int128 buf = 136446978;
      __int16 v149 = "nw_protocol_tcp_updated_path";
      __int16 v150 = 2082;
      *(void *)__int16 v151 = (char *)v8 + 604;
      *(_WORD *)&v151[8] = 1024;
      *(_DWORD *)unsigned int v152 = v22;
      *(_WORD *)&v152[4] = 1024;
      *(_DWORD *)&v152[6] = v20;
      int v23 = v21;
      os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
    }

    else
    {
      if ((*((_BYTE *)v8 + 828) & 2) != 0) {
        goto LABEL_36;
      }
      char v25 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      int v26 = (*((_DWORD *)v8 + 1327) >> 3) & 1;
      *(_DWORD *)__int128 buf = 136446978;
      __int16 v149 = "nw_protocol_tcp_updated_path";
      __int16 v150 = 2082;
      *(void *)__int16 v151 = (char *)v8 + 604;
      *(_WORD *)&v151[8] = 1024;
      *(_DWORD *)unsigned int v152 = v26;
      *(_WORD *)&v152[4] = 1024;
      *(_DWORD *)&v152[6] = v20;
      int v23 = v25;
      os_log_type_t v24 = OS_LOG_TYPE_INFO;
    }

    _os_log_impl( &dword_1879E5000,  v23,  v24,  "%{public}s %{public}s traffic_mgmt_background current %d new %d",  buf,  0x22u);
LABEL_36:
    if (v20) {
      int v27 = 8;
    }
    else {
      int v27 = 0;
    }
    *((_DWORD *)v8 + 1327) = *((_DWORD *)v8 + 1327) & 0xFFFFFFF7 | v27;
    int v28 = *((_DWORD *)v8 + 92);
    if (v20)
    {
      *((_DWORD *)v8 + 92) = v28 | 0x2000;
      uint64_t v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        unsigned int v30 = *(_DWORD *)(v29 + 128) | 1;
LABEL_44:
        *(_DWORD *)(v29 + 128) = v30;
      }
    }

    else
    {
      *((_DWORD *)v8 + 92) = v28 & 0xFFFFDFFF;
      uint64_t v29 = nw_protocol_tcp_get_all_stats();
      if (v29)
      {
        unsigned int v30 = *(_DWORD *)(v29 + 128) & 0xFFFFFFFE;
        goto LABEL_44;
      }
    }

    set_tcp_stream_priority((uint64_t)v8);
    goto LABEL_46;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v149 = "nw_protocol_tcp_updated_path";
  unsigned int v135 = (void *)_os_log_send_and_compose_impl();
  v165[0] = 16;
  v164[0] = 0;
  if (__nwlog_fault())
  {
    if (v165[0] == 17)
    {
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      if (os_log_type_enabled(v136, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null parameters";
        goto LABEL_341;
      }
    }

    else if (v164[0])
    {
      uint64_t v142 = (void *)__nw_create_backtrace_string();
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      BOOL v143 = os_log_type_enabled(v136, (os_log_type_t)v165[0]);
      if (v142)
      {
        if (v143)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v149 = "nw_protocol_tcp_updated_path";
          __int16 v150 = 2082;
          *(void *)__int16 v151 = v142;
          _os_log_impl( &dword_1879E5000,  v136,  v137,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v142);
        goto LABEL_342;
      }

      if (v143)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_341;
      }
    }

    else
    {
      unsigned int v136 = (os_log_s *)__nwlog_obj();
      os_log_type_t v137 = v165[0];
      if (os_log_type_enabled(v136, (os_log_type_t)v165[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v149 = "nw_protocol_tcp_updated_path";
        unsigned int v138 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_341;
      }
    }
  }

LABEL_342:
  if (v135) {
    free(v135);
  }
  return 0LL;
}

uint64_t nw_protocol_tcp_copy_info(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
    int v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v21 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
        int v22 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_48:
        _os_log_impl(&dword_1879E5000, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
      }
    }

LABEL_49:
    if (v20) {
      free(v20);
    }
    return 0LL;
  }

  uint64_t v5 = nw_protocol_downcast();
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
    int v20 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v21 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
        int v22 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_48;
      }
    }

    goto LABEL_49;
  }

  uint64_t v6 = v5;
  uint64_t v7 = v5 + 832;
  uint64_t v8 = (int32x2_t *)(v5 + 3072);
  if (a2 > 253)
  {
    if (a2 == 254)
    {
      nw_protocol_get_output_handler();
      uint64_t v9 = nw_protocol_copy_info_quiet();
      if (!v9) {
        uint64_t v9 = nw_array_create();
      }
      nw_protocol_definition_t v16 = nw_protocol_copy_tcp_definition();
      uint64_t v17 = (void *)nw_protocol_establishment_report_create();
      if (v16) {
        nw_release(v16);
      }
      uint64_t v49 = 0LL;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      memset(v32, 0, sizeof(v32));
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      memset(buf, 0, sizeof(buf));
      tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
      nw_protocol_establishment_report_set_client_accurate_ecn_state();
      nw_protocol_establishment_report_set_server_accurate_ecn_state();
      nw_array_append();
      if (v17) {
        nw_release(v17);
      }
      return v9;
    }

    if (a2 == 255)
    {
      nw_protocol_get_output_handler();
      uint64_t v9 = nw_protocol_copy_info_quiet();
      if (!v9) {
        uint64_t v9 = nw_array_create();
      }
      nw_array_append();
      return v9;
    }

    goto LABEL_15;
  }

  if (a2 == 1)
  {
    if ((*(_BYTE *)(v5 + 5310) & 4) != 0)
    {
      uint64_t v9 = (uint64_t)malloc(0x198uLL);
      if (v9)
      {
        tcp_fill_info((uint64_t)v8, v7, v6, v9);
        if (!a3) {
          return v9;
        }
      }

      else
      {
        char v25 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "strict_malloc";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = 408LL;
        int v26 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if ((_DWORD)result) {
          goto LABEL_59;
        }
        free(v26);
        tcp_fill_info((uint64_t)v8, v7, v6, 0LL);
        if (!a3) {
          return v9;
        }
      }

      uint64_t v10 = 408LL;
      goto LABEL_38;
    }

    return 0LL;
  }

  if (a2 != 2)
  {
LABEL_15:
    nw_protocol_get_output_handler();
    uint64_t v11 = nw_protocol_copy_info_quiet();
    uint64_t v9 = v11;
    if (a2 != 5)
    {
      if ((*(_BYTE *)(v6 + 828) & 2) == 0)
      {
        int v18 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_info";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v6 + 604;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)&_BYTE buf[24] = a2;
          _os_log_impl( &dword_1879E5000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s unknown protocol info type %d",  buf,  0x1Cu);
        }
      }

      return v9;
    }

    if (!v11)
    {
      uint64_t v9 = (uint64_t)calloc(1uLL, 0xB8uLL);
      if (!v9)
      {
        int v27 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "strict_calloc";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = 1LL;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = 184LL;
        int v28 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if ((_DWORD)result) {
          goto LABEL_59;
        }
        free(v28);
        uint64_t v9 = 0LL;
      }
    }

    tcp_fill_info((uint64_t)v8, v7, v6, (uint64_t)buf);
    *(void *)(v9 + 72) = *(void *)&v32[3];
    *(_OWORD *)(v9 + 48) = *(_OWORD *)&v32[11];
    *(void *)(v9 + 64) = *(void *)&v32[15];
    *(void *)(v9 + 80) = *(void *)&v32[5];
    uint64_t v12 = *(unsigned int *)&buf[20];
    uint64_t v14 = *(unsigned int *)&buf[28];
    uint64_t v13 = v30;
    *(void *)(v9 + 120) = *(unsigned int *)&buf[24];
    *(void *)(v9 + 128) = v13;
    *(void *)(v9 + 136) = v12;
    *(void *)(v9 + 144) = v14;
    v15.i64[0] = DWORD1(v30);
    v15.i64[1] = DWORD2(v30);
    *(int8x16_t *)(v9 + 152) = vextq_s8(v15, v15, 8uLL);
    if (!*(void *)(v9 + 8)) {
      *(void *)(v9 + 8) = *(void *)&v32[9];
    }
    if (!*(void *)(v9 + 40)) {
      *(void *)(v9 + 40) = *(void *)&v32[1];
    }
    *(_OWORD *)(v9 + 88) = v43;
    *(_OWORD *)(v9 + 104) = v44;
    if (!a3) {
      return v9;
    }
    uint64_t v10 = 184LL;
    goto LABEL_38;
  }

  if ((*(_BYTE *)(v5 + 5310) & 4) == 0) {
    return 0LL;
  }
  uint64_t v9 = (uint64_t)malloc(0x70uLL);
  if (v9)
  {
    tcp_connection_fill_info(v8, v7, v6, v9);
    if (a3)
    {
LABEL_9:
      uint64_t v10 = 112LL;
LABEL_38:
      *a3 = v10;
    }

    return v9;
  }

  int v23 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&_BYTE buf[12] = 2048;
  *(void *)&buf[14] = 112LL;
  os_log_type_t v24 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v24);
    tcp_connection_fill_info(v8, v7, v6, 0LL);
    if (!a3) {
      return v9;
    }
    goto LABEL_9;
  }

LABEL_59:
  __break(1u);
  return result;
}

              *(_DWORD *)__int128 v38 = v31;
              goto LABEL_37;
            }

            __int128 v36 = *(void *)(v35 + 40);
            if (!v36) {
              break;
            }
            do
            {
              __int128 v35 = v36;
              __int128 v36 = *(void *)(v36 + 32);
            }

            while (v36);
          }

          __int128 v35 = *(void *)(v35 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }

        while (v35 && *(void *)(v35 + 32) == v38);
        while (1)
        {
          __int128 v35 = *(void *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v35) {
            break;
          }
          __int128 v37 = v38 == *(void *)(v35 + 40);
          __int128 v38 = *(void *)(v38 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v37) {
            goto LABEL_53;
          }
        }

uint64_t nw_protocol_tcp_register_notification(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v9 = nw_protocol_downcast();
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = 1LL;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
          __int16 v32 = 2082;
          *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
          uint64_t v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v13 = (os_log_s *)__nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            __int16 v32 = 2082;
            *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
            int8x16_t v15 = "%{public}s invalid registration notification: %{public}s";
          }

          else
          {
            uint64_t v13 = (os_log_s *)__nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            __int16 v32 = 2082;
            *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
            int8x16_t v15 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }

          goto LABEL_61;
        case 1:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v28 = (os_log_s *)__nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              int8x16_t v15 = "%{public}s called with null val";
            }

            else
            {
              int v28 = (os_log_s *)__nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              int8x16_t v15 = "%{public}s called with null val, backtrace limit exceeded";
            }

            goto LABEL_95;
          }

          if (a5)
          {
            *(_DWORD *)os_log_type_t type = *a4;
            *(_DWORD *)&buf[8] = 517;
            *(void *)__int128 buf = 0x600000001LL;
            *(void *)&v33[2] = type;
            uint64_t v34 = 4LL;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 + 8) + 16LL))(v9, 1LL, v5);
            else {
              int v16 = 22;
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 8) + 24LL))(v10, 1LL, v5);
            if (!v16)
            {
              int v23 = *(_DWORD *)(v10 + 5308) | 0x40;
              goto LABEL_45;
            }

            __nwlog_obj();
            uint64_t v19 = v10 + 604;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            __int16 v32 = 2082;
            *(void *)__int128 v33 = v10 + 604;
            *(_WORD *)&v33[8] = 1024;
            LODWORD(v34) = v16;
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v20 = (os_log_s *)__nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = v19;
              *(_WORD *)&v33[8] = 1024;
              LODWORD(v34) = v16;
              int8x16_t v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
            }

            else
            {
              int v20 = (os_log_s *)__nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = v19;
              *(_WORD *)&v33[8] = 1024;
              LODWORD(v34) = v16;
              int8x16_t v15 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }

            goto LABEL_60;
          }

          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
          __int16 v32 = 2082;
          *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
          uint64_t v12 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v13 = (os_log_s *)__nwlog_obj();
            os_log_type_t v14 = type[0];
            if (!os_log_type_enabled(v13, type[0])) {
              goto LABEL_63;
            }
            goto LABEL_38;
          }

          uint64_t v13 = (os_log_s *)__nwlog_obj();
          os_log_type_t v14 = type[0];
          if (!os_log_type_enabled(v13, type[0])) {
            goto LABEL_63;
          }
          goto LABEL_57;
        case 2:
          if (!a4)
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v28 = (os_log_s *)__nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              int8x16_t v15 = "%{public}s called with null val";
            }

            else
            {
              int v28 = (os_log_s *)__nwlog_obj();
              os_log_type_t v29 = type[0];
              if (!os_log_type_enabled(v28, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              int8x16_t v15 = "%{public}s called with null val, backtrace limit exceeded";
            }

            goto LABEL_95;
          }

          if (a5)
          {
            *(_DWORD *)os_log_type_t type = *a4;
            *(_DWORD *)&buf[8] = 519;
            *(void *)__int128 buf = 0x600000001LL;
            *(void *)&v33[2] = type;
            uint64_t v34 = 4LL;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 + 8) + 16LL))(v9, 1LL, v5);
            else {
              int v17 = 22;
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 + 8) + 24LL))(v10, 1LL, v5);
            if (!v17)
            {
              int v23 = *(_DWORD *)(v10 + 5308) | 0x80;
LABEL_45:
              *(_DWORD *)(v10 + 5308) = v23;
              return 1LL;
            }

            __nwlog_obj();
            uint64_t v22 = v10 + 604;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            __int16 v32 = 2082;
            *(void *)__int128 v33 = v10 + 604;
            *(_WORD *)&v33[8] = 1024;
            LODWORD(v34) = v17;
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              int v20 = (os_log_s *)__nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = v22;
              *(_WORD *)&v33[8] = 1024;
              LODWORD(v34) = v17;
              int8x16_t v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
            }

            else
            {
              int v20 = (os_log_s *)__nwlog_obj();
              os_log_type_t v21 = type[0];
              if (!os_log_type_enabled(v20, type[0])) {
                goto LABEL_63;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = v22;
              *(_WORD *)&v33[8] = 1024;
              LODWORD(v34) = v17;
              int8x16_t v15 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
            }

LABEL_60:
            os_log_type_t v24 = v20;
            os_log_type_t v25 = v21;
            uint32_t v26 = 28;
          }

          else
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
            __int16 v32 = 2082;
            *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
            uint64_t v12 = (void *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              uint64_t v13 = (os_log_s *)__nwlog_obj();
              os_log_type_t v14 = type[0];
              if (!os_log_type_enabled(v13, type[0])) {
                goto LABEL_63;
              }
LABEL_38:
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
              int8x16_t v15 = "%{public}s register notification for %{public}s called with zero length";
            }

            else
            {
              uint64_t v13 = (os_log_s *)__nwlog_obj();
              os_log_type_t v14 = type[0];
              if (!os_log_type_enabled(v13, type[0])) {
                goto LABEL_63;
              }
LABEL_57:
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = nw_protocol_notification_type_to_string();
              int8x16_t v15 = "%{public}s register notification for %{public}s called with zero length, backtrace limit exceeded";
            }

    if (v15) {
      free(v15);
    }
    return 1LL;
  }

  uint64_t v4 = 0;
  if (!v3) {
    goto LABEL_10;
  }
LABEL_3:
  if (nw_protocol_metadata_is_ip(*(nw_protocol_metadata_t *)(*(void *)(a1 + 32) + 5232LL)))
  {
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(v3) & 3;
    dscp_value = nw_ip_metadata_get_dscp_value();
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a2 + 184) = dscp_value;
LABEL_6:
      service_class = nw_ip_metadata_get_service_class(v3);
      if (service_class > nw_service_class_signaling) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = dword_187A439F8[service_class];
      }
      *(_DWORD *)(a2 + 176) = v7;
      *(_DWORD *)(a2 + 180) = nw_ip_metadata_get_fragmentation_value();
      goto LABEL_14;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v44 = "__nw_frame_set_dscp_value";
    __int128 v36 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int128 v37 = (os_log_s *)__nwlog_obj();
        __int128 v38 = type[0];
        if (!os_log_type_enabled(v37, type[0])) {
          goto LABEL_81;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v44 = "__nw_frame_set_dscp_value";
        __int128 v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
      }

      else
      {
        __int128 v37 = (os_log_s *)__nwlog_obj();
        __int128 v38 = type[0];
        if (!os_log_type_enabled(v37, type[0])) {
          goto LABEL_81;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v44 = "__nw_frame_set_dscp_value";
        __int128 v39 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v37, v38, v39, buf, 0xCu);
    }

LABEL_61:
            os_log_type_t v24 = v13;
            os_log_type_t v25 = v14;
            uint32_t v26 = 22;
          }

          break;
        case 3:
          *(_DWORD *)(v9 + 5308) |= 0x100u;
          return v11;
        case 4:
        case 5:
          return v11;
        case 14:
          *(_DWORD *)(v9 + 5308) |= 0x400000u;
          if ((*(_BYTE *)(v9 + 828) & 2) == 0)
          {
            int v18 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
              __int16 v32 = 2082;
              *(void *)__int128 v33 = v10 + 604;
              _os_log_impl( &dword_1879E5000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s segmentation_offload_notification enabled",  buf,  0x16u);
            }
          }

          return v11;
        default:
          return 0LL;
      }

      goto LABEL_62;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      int8x16_t v15 = "%{public}s called with null tcp";
    }

    else
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      int8x16_t v15 = "%{public}s called with null tcp, backtrace limit exceeded";
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      int8x16_t v15 = "%{public}s called with null protocol";
    }

    else
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_register_notification";
      int8x16_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
  }

LABEL_95:
  os_log_type_t v24 = v28;
  os_log_type_t v25 = v29;
  uint32_t v26 = 12;
LABEL_62:
  _os_log_impl(&dword_1879E5000, v24, v25, v15, buf, v26);
LABEL_63:
  if (v12) {
    free(v12);
  }
  return 0LL;
}

      __break(1u);
      return result;
    }
  }

  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a2 + 112);
    if (!v7) {
      goto LABEL_18;
    }
  }

  uint64_t v8 = v7 + v4;
LABEL_20:
  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
  int v16 = (void *)a1[7];
  int v17 = v16[65];
  if (!v17) {
    goto LABEL_77;
  }
  int v18 = 0;
  while (1)
  {
    if (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) >= v6)
    {
LABEL_74:
      if ((v18 & 1) == 0) {
        goto LABEL_77;
      }
      goto LABEL_75;
    }

    uint64_t v19 = *(_DWORD *)(v17 + 52);
    int v20 = v19 ? v19 - (*(_DWORD *)(v17 + 56) + *(_DWORD *)(v17 + 60)) : 0;
    if (*(void *)(*v16 + 240LL))
    {
      os_log_type_t v21 = *(void *)(v17 + 112);
      if (v21
        && ((*(_WORD *)(v17 + 204) & 0x100) == 0
         || !*MEMORY[0x189608EF8]
         || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v17, *(void *)(v17 + 88))
         && (os_log_type_t v21 = *(void *)(v17 + 112)) != 0))
      {
        uint64_t v22 = (const void *)(v21 + *(unsigned int *)(v17 + 56));
      }

      else
      {
        uint64_t v22 = 0LL;
        if ((*(_WORD *)(v17 + 204) & 0x100) != 0)
        {
          if (*MEMORY[0x189608EF8])
          {
            uint64_t v22 = 0LL;
          }
        }
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    v18 |= (unsigned __int16)(*(_WORD *)(v17 + 204) & 0x4000) >> 14;
    if (v20)
    {
      if (v22) {
        break;
      }
    }

    os_log_type_t v29 = a1[7];
    if (!v29 || (*(_BYTE *)(v29 + 828) & 2) == 0)
    {
      __int128 v30 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        __int128 v31 = (const char *)(v29 + 604);
        *(_DWORD *)__int128 buf = 136446978;
        if (!v29) {
          __int128 v31 = "";
        }
        int v58 = "tcp_input_get_aggregate_frames_block_invoke";
        uint64_t v59 = 2082;
        *(void *)uint64_t v60 = v31;
        *(_WORD *)&v60[8] = 1024;
        *(_DWORD *)int v61 = v20;
        *(_WORD *)&v61[4] = 2048;
        char v62 = v22;
        _os_log_impl( &dword_1879E5000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s skipping empty input frame (length %u bytes %p)",  buf,  0x26u);
      }
    }

    uint32_t v26 = a1[7];
    if (*(_DWORD *)(v26 + 552) < v20)
    {
      __int128 v40 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      int v58 = "tcp_input_get_aggregate_frames_block_invoke";
      __int128 v41 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result) {
        goto LABEL_95;
      }
      free(v41);
      uint32_t v26 = a1[7];
    }

    int v27 = *(_DWORD *)(v26 + 488);
    if (v27 < v20)
    {
      __int128 v42 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      int v58 = "tcp_input_get_aggregate_frames_block_invoke";
      __int128 v43 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result) {
        goto LABEL_95;
      }
      free(v43);
      uint32_t v26 = a1[7];
      int v27 = *(_DWORD *)(v26 + 488);
    }

    int v28 = (_DWORD *)(v26 + 488);
    *(_DWORD *)(v26 + 552) -= v20;
LABEL_48:
    *int v28 = v27 - v20;
    __int16 v32 = *(_DWORD *)(v26 + 548);
    if (!v32)
    {
      __int128 v37 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      int v58 = "tcp_input_get_aggregate_frames_block_invoke";
      __int128 v38 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result) {
        goto LABEL_95;
      }
      free(v38);
      uint32_t v26 = a1[7];
      __int16 v32 = *(_DWORD *)(v26 + 548);
    }

    *(_DWORD *)(v26 + 548) = v32 - 1;
    __int128 v33 = *(void *)(v17 + 32);
    uint64_t v34 = *(void **)(v17 + 40);
    if (v33)
    {
      *(void *)(v33 + 40) = v34;
      uint64_t v34 = *(void **)(v17 + 40);
    }

    else
    {
      *(void *)(v26 + 528) = v34;
    }

    *uint64_t v34 = v33;
    uint64_t v35 = *(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 80);
    *(void *)(v17 + 32) = 0LL;
    *(void *)(v17 + 40) = 0LL;
    if (v35)
    {
      __int128 v36 = *(void *)(v17 + 88);
      *(void *)(v17 + 80) = 0LL;
      *(void *)(v17 + 88) = 0LL;
      v35(v17, 1LL, v36);
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v58 = "__nw_frame_finalize";
      __int128 v39 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        __int128 v46 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v58 = "__nw_frame_finalize";
          _os_log_impl( &dword_1879E5000,  v46,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v39) {
        free(v39);
      }
    }

    int v16 = (void *)a1[7];
    int v17 = v16[65];
    if (!v17) {
      goto LABEL_74;
    }
  }

  int v23 = *(unsigned int *)(*(void *)(a1[4] + 8LL) + 24LL);
  os_log_type_t v24 = v6 - v23;
  os_log_type_t v25 = (void *)(v8 + v23);
  if (v6 - v23 >= v20)
  {
    memcpy(v25, v22, v20);
    *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) += v20;
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) += v20;
    uint32_t v26 = a1[7];
    int v27 = *(_DWORD *)(v26 + 552);
    if (v27 < v20)
    {
      __int128 v44 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      int v58 = "tcp_input_get_aggregate_frames_block_invoke";
      __int128 v45 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result) {
        goto LABEL_95;
      }
      free(v45);
      uint32_t v26 = a1[7];
      int v27 = *(_DWORD *)(v26 + 552);
    }

    int v28 = (_DWORD *)(v26 + 552);
    goto LABEL_48;
  }

  memcpy(v25, v22, v6 - v23);
  if ((*(_WORD *)(v17 + 204) & 0x80) != 0) {
    *(_WORD *)(v17 + 196) -= v24;
  }
  __int128 v47 = *(_DWORD *)(v17 + 56) + v24;
  __int128 v48 = *(_DWORD *)(v17 + 60);
  if (v47 <= *(_DWORD *)(v17 + 52) - v48)
  {
    *(_DWORD *)(v17 + 56) = v47;
  }

  else
  {
    uint64_t v49 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      uint64_t v50 = *(_DWORD *)(v17 + 52);
      *(_DWORD *)__int128 buf = 136446978;
      int v58 = "__nw_frame_claim_internal";
      uint64_t v59 = 1024;
      *(_DWORD *)uint64_t v60 = v47;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = v50;
      *(_WORD *)int v61 = 1024;
      *(_DWORD *)&v61[2] = v48;
      _os_log_impl( &dword_1879E5000,  v49,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
    }
  }

  *(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) += v24;
  *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) += v24;
  __int16 v51 = a1[7];
  unsigned int v52 = *(_DWORD *)(v51 + 552);
  if (v52 < v24)
  {
    uint64_t v54 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    int v58 = "tcp_input_get_aggregate_frames_block_invoke";
    int v55 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result) {
      goto LABEL_95;
    }
    free(v55);
    __int16 v51 = a1[7];
    unsigned int v52 = *(_DWORD *)(v51 + 552);
  }

  *(_DWORD *)(v51 + 552) = v52 - v24;
  if ((v18 & 1) == 0) {
    goto LABEL_77;
  }
LABEL_75:
  if (a2)
  {
    *(_WORD *)(a2 + 204) |= 0x4000u;
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v58 = "__nw_frame_set_is_wake_packet";
    unsigned int v53 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v56 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v58 = "__nw_frame_set_is_wake_packet";
        _os_log_impl( &dword_1879E5000,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v53) {
      free(v53);
    }
  }

uint64_t nw_protocol_tcp_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v5 = nw_protocol_downcast();
    if (v5)
    {
      uint64_t v6 = v5;
      if (*(_DWORD *)(v5 + 5224) > 2u) {
        return 1LL;
      }
      uint64_t v7 = 1LL;
      switch(a3)
      {
        case 0:
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          __int16 v28 = 2082;
          *(void *)os_log_type_t v29 = nw_protocol_notification_type_to_string();
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v9 = (os_log_s *)__nwlog_obj();
            os_log_type_t v10 = type[0];
            if (!os_log_type_enabled(v9, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = nw_protocol_notification_type_to_string();
            uint64_t v11 = "%{public}s invalid registration notification: %{public}s";
          }

          else
          {
            uint64_t v9 = (os_log_s *)__nwlog_obj();
            os_log_type_t v10 = type[0];
            if (!os_log_type_enabled(v9, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = nw_protocol_notification_type_to_string();
            uint64_t v11 = "%{public}s invalid registration notification: %{public}s, backtrace limit exceeded";
          }

          int v20 = v9;
          os_log_type_t v21 = v10;
          uint32_t v22 = 22;
          goto LABEL_48;
        case 1:
          *(_DWORD *)os_log_type_t type = 0;
          *(_DWORD *)&buf[8] = 517;
          *(void *)__int128 buf = 0x600000001LL;
          *(void *)&v29[2] = type;
          uint64_t v30 = 4LL;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 16LL))(v5, 1LL, v3);
          else {
            int v12 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 24LL))(v6, 1LL, v3);
          if (!v12)
          {
LABEL_29:
            unsigned int v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFFBF;
            goto LABEL_37;
          }

          __nwlog_obj();
          uint64_t v15 = v6 + 604;
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          __int16 v28 = 2082;
          *(void *)os_log_type_t v29 = v6 + 604;
          *(_WORD *)&v29[8] = 1024;
          LODWORD(v30) = v12;
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            int v16 = (os_log_s *)__nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = v15;
            *(_WORD *)&v29[8] = 1024;
            LODWORD(v30) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d";
          }

          else
          {
            int v16 = (os_log_s *)__nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = v15;
            *(_WORD *)&v29[8] = 1024;
            LODWORD(v30) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_read_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }

          goto LABEL_47;
        case 2:
          *(_DWORD *)os_log_type_t type = 0;
          *(_DWORD *)&buf[8] = 519;
          *(void *)__int128 buf = 0x600000001LL;
          *(void *)&v29[2] = type;
          uint64_t v30 = 4LL;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 16LL))(v5, 1LL, v3);
          else {
            int v13 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 24LL))(v6, 1LL, v3);
          if (!v13)
          {
LABEL_36:
            unsigned int v18 = *(_DWORD *)(v6 + 5308) & 0xFFFFFF7F;
LABEL_37:
            *(_DWORD *)(v6 + 5308) = v18;
            return 1LL;
          }

          __nwlog_obj();
          uint64_t v19 = v6 + 604;
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
          __int16 v28 = 2082;
          *(void *)os_log_type_t v29 = v6 + 604;
          *(_WORD *)&v29[8] = 1024;
          LODWORD(v30) = v13;
          uint64_t v8 = (void *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            int v16 = (os_log_s *)__nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = v19;
            *(_WORD *)&v29[8] = 1024;
            LODWORD(v30) = v13;
            uint64_t v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d";
          }

          else
          {
            int v16 = (os_log_s *)__nwlog_obj();
            os_log_type_t v17 = type[0];
            if (!os_log_type_enabled(v16, type[0])) {
              goto LABEL_49;
            }
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_unregister_notification";
            __int16 v28 = 2082;
            *(void *)os_log_type_t v29 = v19;
            *(_WORD *)&v29[8] = 1024;
            LODWORD(v30) = v13;
            uint64_t v11 = "%{public}s %{public}s tcp_set_write_timeout failed %{darwin.errno}d, backtrace limit exceeded";
          }

void nw_protocol_tcp_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (nw_protocol_downcast())
    {
      if (a3)
      {
        unsigned int v4 = a3[1] & 0xFFFFFFF8 | 4;
        *a3 = -1;
        a3[1] = v4;
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v9 = "nw_protocol_tcp_get_message_properties";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v9 = "nw_protocol_tcp_get_message_properties";
        uint64_t v7 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_14;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v9 = "nw_protocol_tcp_get_message_properties";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v9 = "nw_protocol_tcp_get_message_properties";
        uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_14:
        _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      }
    }
  }

  if (v5) {
    free(v5);
  }
}

void nw_protocol_tcp_error(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = nw_protocol_downcast();
    if (v4)
    {
      uint64_t v5 = v4;
      if ((*(_BYTE *)(v4 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
      {
        uint64_t v7 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v11 = "nw_protocol_tcp_error";
          __int16 v12 = 2082;
          uint64_t v13 = v5 + 604;
          __int16 v14 = 1024;
          int v15 = a3;
          _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called with error: %d",  buf,  0x1Cu);
        }
      }

      nw_protocol_get_input_handler();
      nw_protocol_error_quiet();
      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_error";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_protocol_tcp_error";
        uint64_t v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_protocol_tcp_error";
    uint64_t v6 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_protocol_tcp_error";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_17:
        _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }

  if (v6) {
    free(v6);
  }
}

void nw_proto_tcp_notify_segmentation_offload(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = (_BYTE *)nw_protocol_downcast();
    if (v1)
    {
      uint64_t v2 = v1;
      if ((v1[5310] & 0x40) != 0)
      {
        if (*(void *)v1)
        {
          if ((*(_BYTE *)(*(void *)v1 + 2236LL) & 2) != 0) {
            tso_max_segment_size_uint64_t v6 = nw_path_get_tso_max_segment_size_v6();
          }
          else {
            tso_max_segment_size_uint64_t v6 = nw_path_get_tso_max_segment_size_v4();
          }
          BOOL v5 = tso_max_segment_size_v6 != 0;
        }

        else
        {
          BOOL v5 = 0;
        }

        if ((v2[828] & 2) == 0)
        {
          uint64_t v6 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 136446722;
            uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
            __int16 v12 = 2082;
            uint64_t v13 = v2 + 604;
            __int16 v14 = 1024;
            BOOL v15 = v5;
            _os_log_impl( &dword_1879E5000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s notifying segmentation offload value %d",  buf,  0x1Cu);
          }
        }

        nw_protocol_get_output_handler();
        nw_protocol_notify_quiet();
      }

      else if ((v1[828] & 2) == 0)
      {
        uint64_t v3 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
          __int16 v12 = 2082;
          uint64_t v13 = v2 + 604;
          _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s segmentation offload notification not enabled",  buf,  0x16u);
        }
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
        uint64_t v9 = "%{public}s called with null tcp, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_proto_tcp_notify_segmentation_offload";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_26:
        _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
      }
    }
  }

  if (v7) {
    free(v7);
  }
}

BOOL nw_protocol_tcp_initialize(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v2 = nw_protocol_downcast();
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s called with null tcp, backtrace limit exceeded";
LABEL_65:
    _os_log_impl(&dword_1879E5000, v30, OS_LOG_TYPE_ERROR, v31, buf, 0xCu);
    goto LABEL_66;
  }

  uint64_t v3 = v2;
  _os_feature_enabled_impl();
  nw_protocol_get_input_handler();
  local_endpoint = (nw_endpoint *)nw_protocol_get_local_endpoint();
  if (!local_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s get_local_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }

  BOOL v5 = local_endpoint;
  *(void *)(v3 + 5272) = nw_endpoint_copy_address_string(local_endpoint);
  *(_WORD *)(v3 + 5300) = nw_endpoint_get_port(v5);
  remote_endpoint = (nw_endpoint *)nw_protocol_get_remote_endpoint();
  if (!remote_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s get_remote_endpoint failed, backtrace limit exceeded";
    goto LABEL_65;
  }

  uint64_t v7 = remote_endpoint;
  *(void *)(v3 + 5280) = nw_endpoint_copy_address_string(remote_endpoint);
  *(_WORD *)(v3 + 5302) = nw_endpoint_get_port(v7);
  address = nw_endpoint_get_address(v5);
  if (!address)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded";
    goto LABEL_65;
  }

  uint64_t v9 = address;
  uint64_t v10 = *(void **)(v3 + 5208);
  if (v10)
  {
    nw_release(v10);
    *(void *)(v3 + 5208) = 0LL;
  }

  path = (void *)nw_protocol_get_path();
  *(void *)(v3 + 5208) = path;
  if (path)
  {
    nw_retain(path);
    else {
      int v12 = 0;
    }
    *(_DWORD *)(v3 + 5308) = *(_DWORD *)(v3 + 5308) & 0xFFFFDFFF | v12;
  }

  else
  {
    __int16 v14 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v43 = "nw_protocol_tcp_initialize";
      _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to get path from input protocol, will not be able to get stats",  buf,  0xCu);
    }
  }

  nw_protocol_get_input_handler();
  if (!nw_protocol_get_parameters())
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_66;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v31 = "%{public}s called with null parameters, backtrace limit exceeded";
    goto LABEL_65;
  }

  BOOL v15 = (void *)nw_parameters_copy_protocol_options_legacy();
  uint64_t v16 = v3 + 604;
  if (!nw_protocol_options_get_log_id_str() || !nw_protocol_options_get_log_id_str())
  {
    snprintf((char *)(v3 + 604), 0x54uLL, "tcp[%llu]", ++tcp_flow_gencnt);
    snprintf((char *)(v3 + 4852), 0x54uLL, "tcp[%llu]", tcp_flow_gencnt);
  }

  *(_WORD *)(v3 + 688) = nw_protocol_options_get_log_id_num();
  if (v15) {
    nw_release(v15);
  }
  else {
    char v17 = 0;
  }
  *(_BYTE *)(v3 + 828) = *(_BYTE *)(v3 + 828) & 0xFD | v17;
  else {
    char v18 = 0;
  }
  *(_BYTE *)(v3 + 828) = *(_BYTE *)(v3 + 828) & 0xFB | v18;
  uint64_t v19 = nw_parameters_copy_context();
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v43 = "nw_protocol_tcp_initialize";
    uint64_t v13 = _os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v43 = "nw_protocol_tcp_initialize";
        uint64_t v31 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_65;
      }
    }

uint64_t nw_protocol_tcp_apply_parameters(uint64_t a1)
{
  uint64_t v120 = *MEMORY[0x1895F89C0];
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  uint64_t parameters = nw_protocol_get_parameters();
  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    int v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null parameters";
    }

    else
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null parameters, backtrace limit exceeded";
    }

    goto LABEL_281;
  }

  if (!*(void *)(a1 + 5208))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    int v58 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null path";
    }

    else
    {
      uint64_t v59 = (os_log_s *)__nwlog_obj();
      os_log_type_t v60 = type[0];
      if (!os_log_type_enabled(v59, type[0])) {
        goto LABEL_282;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      int v61 = "%{public}s called with null path, backtrace limit exceeded";
    }

LABEL_281:
    _os_log_impl(&dword_1879E5000, v59, v60, v61, buf, 0xCu);
LABEL_282:
    if (v58) {
      free(v58);
    }
    return 0LL;
  }

  uint64_t v4 = (nw_parameters *)parameters;
  BOOL v5 = (void *)nw_parameters_copy_protocol_options_legacy();
  if (nw_tcp_options_get_no_delay())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(_DWORD *)&buf[8] = 1;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v6 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v6)
    {
      __nwlog_obj();
      uint64_t v7 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v6;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v7;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v6;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d";
LABEL_130:
            __int128 v43 = v9;
            os_log_type_t v44 = v10;
LABEL_131:
            _os_log_impl(&dword_1879E5000, v43, v44, v11, buf, 0x1Cu);
            goto LABEL_132;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v7;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v6;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_delay failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

      goto LABEL_132;
    }
  }

  if (nw_tcp_options_get_no_push())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(_DWORD *)&buf[8] = 4;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v12 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v12)
    {
      __nwlog_obj();
      uint64_t v13 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v12;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v13;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v13;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v12;
            uint64_t v11 = "%{public}s %{public}s tcp_set_no_push failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

LABEL_132:
      if (v8) {
        free(v8);
      }
      if (v5) {
        nw_release(v5);
      }
      return 0LL;
    }
  }

  if (nw_tcp_options_get_reduce_buffering())
  {
    *(_DWORD *)os_log_type_t type = 0x4000;
    *(_DWORD *)&buf[8] = 513;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v14 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v14)
    {
      __nwlog_obj();
      uint64_t v15 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v14;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v15;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v14;
            uint64_t v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v15;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v14;
            uint64_t v11 = "%{public}s %{public}s tcp_set_notsent_lowat failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

      goto LABEL_132;
    }
  }

  if (nw_tcp_options_get_disable_blackhole_detection())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(_DWORD *)&buf[8] = 521;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v16 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v16)
    {
      __nwlog_obj();
      uint64_t v17 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v16;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v17;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v16;
            uint64_t v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d";
            goto LABEL_130;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v17;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v16;
            uint64_t v11 = "%{public}s %{public}s tcp_disable_blackhole_detection(so) %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

      goto LABEL_132;
    }
  }

  int ecn_mode = nw_parameters_get_ecn_mode();
  if (!ecn_mode) {
    goto LABEL_77;
  }
  if (ecn_mode == 1) {
    int v19 = 1;
  }
  else {
    int v19 = 2;
  }
  *(_DWORD *)(a1 + 5304) = v19;
  *(_DWORD *)os_log_type_t type = v19;
  *(_DWORD *)&buf[8] = 528;
  *(void *)__int128 buf = 0x600000001LL;
  *(void *)&v118[2] = type;
  uint64_t v119 = 4LL;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    goto LABEL_56;
  }

  int v20 = tcp_ctloutput(a1, (uint64_t)buf);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
  if (v20)
  {
    if (v20 == 22)
    {
LABEL_56:
      nw_protocol_definition_t v21 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        __int16 v117 = 1024;
        *(_DWORD *)int v118 = 22;
        _os_log_impl( &dword_1879E5000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_77;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    __int16 v117 = 1024;
    *(_DWORD *)int v118 = v20;
    char v22 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type[0];
        if (!os_log_type_enabled(v23, type[0])) {
          goto LABEL_75;
        }
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        __int16 v117 = 1024;
        *(_DWORD *)int v118 = v20;
        int v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d";
      }

      else
      {
        int v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type[0];
        if (!os_log_type_enabled(v23, type[0])) {
          goto LABEL_75;
        }
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        __int16 v117 = 1024;
        *(_DWORD *)int v118 = v20;
        int v25 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v23, v24, v25, buf, 0x12u);
    }

LABEL_75:
    if (v22) {
      free(v22);
    }
  }

LABEL_77:
  int enable_l4s = nw_tcp_options_get_enable_l4s();
  if (enable_l4s != 2)
  {
    *(_DWORD *)os_log_type_t type = enable_l4s == 1;
    *(_DWORD *)&buf[8] = 539;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v27 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v27)
    {
      __nwlog_obj();
      uint64_t v28 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v27;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v28;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v27;
            uint64_t v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v28;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v27;
            uint64_t v11 = "%{public}s %{public}s tcp_set_enable_l4s failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

      goto LABEL_132;
    }
  }

  if (nw_parameters_get_fast_open_enabled(v4)
    || nw_tcp_options_get_enable_fast_open()
    && (nw_protocol_upcast(), nw_protocol_get_input_handler(), (nw_protocol_input_handler_is_connection_flow() & 1) == 0))
  {
    *(_DWORD *)(a1 + 368) |= 0x30u;
    *(_DWORD *)(a1 + 5308) |= 0x8020u;
  }

  if (nw_tcp_options_get_fast_open_force_enable())
  {
    *(_DWORD *)os_log_type_t type = 1;
    *(_DWORD *)&buf[8] = 536;
    *(void *)__int128 buf = 0x600000001LL;
    *(void *)&v118[2] = type;
    uint64_t v119 = 4LL;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v1);
    else {
      int v29 = 22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
    if (v29)
    {
      __nwlog_obj();
      uint64_t v30 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v29;
      uint64_t v8 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v114[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v30;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v29;
            uint64_t v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d";
            goto LABEL_130;
          }
        }

        else
        {
          uint64_t v9 = (os_log_s *)__nwlog_obj();
          os_log_type_t v10 = type[0];
          if (os_log_type_enabled(v9, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
            __int16 v117 = 2082;
            *(void *)int v118 = v30;
            *(_WORD *)&v118[8] = 1024;
            LODWORD(v119) = v29;
            uint64_t v11 = "%{public}s %{public}s tcp_set_fast_open_force_enable failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_130;
          }
        }
      }

      goto LABEL_132;
    }
  }

  int effective_traffic_class = nw_path_get_effective_traffic_class();
  int v32 = tcp_set_traffic_class(a1, effective_traffic_class);
  if (v32)
  {
    int v33 = v32;
    __nwlog_obj();
    uint64_t v34 = a1 + 604;
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
    __int16 v117 = 2082;
    *(void *)int v118 = a1 + 604;
    *(_WORD *)&v118[8] = 1024;
    LODWORD(v119) = v33;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v114[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type[0];
      if (!os_log_type_enabled(v35, type[0])) {
        goto LABEL_132;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = v34;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v33;
      uint64_t v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d";
    }

    else
    {
      uint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type[0];
      if (!os_log_type_enabled(v35, type[0])) {
        goto LABEL_132;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = v34;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v33;
      uint64_t v11 = "%{public}s %{public}s tcp_set_traffic_class failed %{darwin.errno}d, backtrace limit exceeded";
    }

  ++*(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL);
  return 1LL;
}

LABEL_191:
  if (v64) {
    free(v64);
  }
LABEL_193:
  int v68 = tcp_setsockopt(a1, 6, 8, (int *)type);
  if (!v68) {
    goto LABEL_204;
  }
  int v69 = v68;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  __int16 v117 = 2082;
  *(void *)int v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v69;
  os_log_type_t v70 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      int v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0])) {
        goto LABEL_202;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v69;
      int v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d";
    }

    else
    {
      int v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = v114[0];
      if (!os_log_type_enabled(v71, v114[0])) {
        goto LABEL_202;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v69;
      int v73 = "%{public}s %{public}s tcp_setsockopt TCP_NOOPT failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v71, v72, v73, buf, 0x1Cu);
  }

LABEL_202:
  if (v70) {
    free(v70);
  }
LABEL_204:
  int v74 = tcp_setsockopt(a1, 6, 520, (int *)type);
  if (!v74) {
    goto LABEL_215;
  }
  int v75 = v74;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  __int16 v117 = 2082;
  *(void *)int v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v75;
  int v76 = (void *)_os_log_send_and_compose_impl();
  v114[0] = OS_LOG_TYPE_ERROR;
  v113[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v77 = (os_log_s *)__nwlog_obj();
      os_log_type_t v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0])) {
        goto LABEL_213;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v75;
      BOOL v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d";
    }

    else
    {
      __int16 v77 = (os_log_s *)__nwlog_obj();
      os_log_type_t v78 = v114[0];
      if (!os_log_type_enabled(v77, v114[0])) {
        goto LABEL_213;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v75;
      BOOL v79 = "%{public}s %{public}s tcp_setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v77, v78, v79, buf, 0x1Cu);
  }

LABEL_213:
  if (v76) {
    free(v76);
  }
LABEL_215:
  *(_DWORD *)int v114 = nw_tcp_options_get_maximum_segment_size();
  if (!*(_DWORD *)v114) {
    goto LABEL_226;
  }
  int v80 = tcp_setsockopt(a1, 6, 2, (int *)v114);
  if (!v80) {
    goto LABEL_226;
  }
  int v81 = v80;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  __int16 v117 = 2082;
  *(void *)int v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v81;
  os_log_type_t v82 = (void *)_os_log_send_and_compose_impl();
  v113[0] = OS_LOG_TYPE_ERROR;
  v112[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v113[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0])) {
        goto LABEL_224;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v81;
      uint64_t v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d";
    }

    else
    {
      os_log_type_t v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = v113[0];
      if (!os_log_type_enabled(v83, v113[0])) {
        goto LABEL_224;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v81;
      uint64_t v85 = "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v83, v84, v85, buf, 0x1Cu);
  }

LABEL_224:
  if (v82) {
    free(v82);
  }
LABEL_226:
  *(_DWORD *)unsigned int v113 = nw_tcp_options_get_retransmit_connection_drop_time();
  if (!*(_DWORD *)v113) {
    goto LABEL_237;
  }
  int v86 = tcp_setsockopt(a1, 6, 128, (int *)v113);
  if (!v86) {
    goto LABEL_237;
  }
  int v87 = v86;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  __int16 v117 = 2082;
  *(void *)int v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v87;
  int v88 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v89 = (os_log_s *)__nwlog_obj();
      os_log_type_t v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v87;
      unsigned int v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d";
    }

    else
    {
      uint64_t v89 = (os_log_s *)__nwlog_obj();
      os_log_type_t v90 = v112[0];
      if (!os_log_type_enabled(v89, v112[0])) {
        goto LABEL_235;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v87;
      unsigned int v91 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v89, v90, v91, buf, 0x1Cu);
  }

LABEL_235:
  if (v88) {
    free(v88);
  }
LABEL_237:
  int v92 = tcp_setsockopt(a1, 6, 256, (int *)type);
  if (!v92) {
    goto LABEL_248;
  }
  int v93 = v92;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
  __int16 v117 = 2082;
  *(void *)int v118 = a1 + 604;
  *(_WORD *)&v118[8] = 1024;
  LODWORD(v119) = v93;
  v94 = (void *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0])) {
        goto LABEL_246;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v93;
      int v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d";
    }

    else
    {
      os_log_type_t v95 = (os_log_s *)__nwlog_obj();
      os_log_type_t v96 = v112[0];
      if (!os_log_type_enabled(v95, v112[0])) {
        goto LABEL_246;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v93;
      int v97 = "%{public}s %{public}s tcp_setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v95, v96, v97, buf, 0x1Cu);
  }

LABEL_257:
  if (v100) {
    free(v100);
  }
LABEL_259:
  *(_DWORD *)int v110 = nw_tcp_options_get_persist_timeout();
  if (*(_DWORD *)v110)
  {
    int v104 = tcp_setsockopt(a1, 6, 64, (int *)v110);
    if (v104)
    {
      int v105 = v104;
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
      __int16 v117 = 2082;
      *(void *)int v118 = a1 + 604;
      *(_WORD *)&v118[8] = 1024;
      LODWORD(v119) = v105;
      os_log_type_t v106 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t v111 = OS_LOG_TYPE_ERROR;
      if (v111 == OS_LOG_TYPE_FAULT)
      {
        v107 = (os_log_s *)__nwlog_obj();
        os_log_type_t v108 = v111;
        if (!os_log_type_enabled(v107, v111)) {
          goto LABEL_268;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        __int16 v117 = 2082;
        *(void *)int v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v105;
        v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d";
      }

      else
      {
        v107 = (os_log_s *)__nwlog_obj();
        os_log_type_t v108 = v111;
        if (!os_log_type_enabled(v107, v111)) {
          goto LABEL_268;
        }
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_apply_parameters";
        __int16 v117 = 2082;
        *(void *)int v118 = a1 + 604;
        *(_WORD *)&v118[8] = 1024;
        LODWORD(v119) = v105;
        v109 = "%{public}s %{public}s tcp_setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v107, v108, v109, buf, 0x1Cu);
LABEL_268:
      if (v106) {
        free(v106);
      }
    }
  }

  if (nw_parameters_get_server_mode())
  {
    *(_DWORD *)(a1 + 5308) |= 0x200000u;
    *(_DWORD *)(a1 + 372) |= 2u;
  }

  if (v5) {
    nw_release(v5);
  }
  return 1LL;
}

BOOL nw_protocol_tcp_initialize_inbound(uint64_t a1, nw_endpoint_t endpoint)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1 + 832;
  address = nw_endpoint_get_address(endpoint);
  int sa_family = address->sa_family;
  if (sa_family == 2)
  {
    *(_DWORD *)(a1 + 1308) = *(_DWORD *)&address->sa_data[2];
    *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
    *(_DWORD *)(a1 + 3084) = 1;
    uint64_t v7 = tcp_rtlookup(v4, 0LL);
    if (v7) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }

  if (sa_family != 30)
  {
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
    int v12 = "%{public}s Invalid address family";
    goto LABEL_14;
  }

  *(sockaddr *)(a1 + 1296) = *(sockaddr *)&address->sa_data[6];
  *(_WORD *)(a1 + 3056) = *(_WORD *)address->sa_data;
  *(_DWORD *)(a1 + 3084) = 1;
  uint64_t v7 = tcp_rtlookup6(v4, 0LL);
  if (!v7)
  {
LABEL_10:
    os_log_type_t v10 = (os_log_s *)__nwlog_obj();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
    int v12 = "%{public}s tcp_rtlookup[6] failed";
LABEL_14:
    _os_log_impl(&dword_1879E5000, v10, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    return 0LL;
  }

LABEL_4:
  *(void *)(a1 + 1280) = *(void *)(v7 + 216);
  *(_DWORD *)(v7 + 1480) |= 0x2000000u;
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    uint64_t v8 = (void *)nw_parameters_copy_protocol_options_legacy();
    int connection_timeout = nw_tcp_options_get_connection_timeout();
    if (connection_timeout)
    {
      *(void *)__int128 buf = 0x600000001LL;
      *(_DWORD *)&buf[8] = 32;
      *(void *)&v18[2] = &connection_timeout;
      uint64_t v19 = 4LL;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v2);
      else {
        int v9 = 22;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
      if (v9)
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
        __int16 v17 = 1024;
        *(_DWORD *)char v18 = v9;
        uint64_t v13 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          int v14 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_initialize_inbound";
            __int16 v17 = 1024;
            *(_DWORD *)char v18 = v9;
            _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }

        if (v13) {
          free(v13);
        }
      }
    }

    if (v8) {
      nw_release(v8);
    }
  }

  return 1LL;
}

    ;
  }

  *(_DWORD *)(a2 + 68) &= ~1u;
  return result;
}

uint64_t nw_proto_tcp_route_init(uint64_t a1, uint64_t a2)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 1648);
  uint64_t v3 = *(_BYTE **)(a1 + 1656);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = *(void *)(*(void *)v3 + 240LL);
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    int v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      int v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      int v55 = "%{public}s called with null rt";
    }

    else
    {
      int v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      int v55 = "%{public}s called with null rt, backtrace limit exceeded";
    }

    goto LABEL_112;
  }

  if (!*(void *)(a2 + 216))
  {
    __nwlog_obj();
    *(_DWORD *)&__n[1] = 136446210;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    int v52 = (void *)_os_log_send_and_compose_impl();
    __src[0] = OS_LOG_TYPE_ERROR;
    if (__src[0] == OS_LOG_TYPE_FAULT)
    {
      int v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      int v55 = "%{public}s called with null rt->rt_ifp";
    }

    else
    {
      int v53 = (os_log_s *)__nwlog_obj();
      os_log_type_t v54 = __src[0];
      if (!os_log_type_enabled(v53, __src[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)&__n[1] = 136446210;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      int v55 = "%{public}s called with null rt->rt_ifp, backtrace limit exceeded";
    }

LABEL_112:
    _os_log_impl(&dword_1879E5000, v53, v54, v55, &__n[1], 0xCu);
LABEL_113:
    if (v52) {
      free(v52);
    }
    return 0xFFFFFFFFLL;
  }

  int v7 = *(_DWORD *)(v4 + 492);
  nw_protocol_upcast();
  if (!nw_protocol_get_input_handler())
  {
    if ((v3[828] & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    int v14 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)&__n[1] = 136446466;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    __int16 v64 = 2082;
    uint64_t v65 = (uint64_t)(v3 + 604);
    uint64_t v15 = "%{public}s %{public}s no input handler";
    goto LABEL_22;
  }

  if (!*(void *)(v2 + 5208))
  {
    if ((v3[828] & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    int v14 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)&__n[1] = 136446466;
    *(void *)&__n[5] = "nw_proto_tcp_route_init";
    __int16 v64 = 2082;
    uint64_t v65 = (uint64_t)(v3 + 604);
    uint64_t v15 = "%{public}s %{public}s no path from input_handler received";
LABEL_22:
    _os_log_impl(&dword_1879E5000, v14, OS_LOG_TYPE_ERROR, v15, &__n[1], 0x16u);
    return 0xFFFFFFFFLL;
  }

  int mtu = nw_path_get_mtu();
  if (!mtu)
  {
    if ((v3[828] & 2) == 0)
    {
      int v14 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(void *)&__n[5] = "nw_proto_tcp_route_init";
        __int16 v64 = 2082;
        uint64_t v65 = (uint64_t)(v3 + 604);
        uint64_t v15 = "%{public}s %{public}s no mtu received";
        goto LABEL_22;
      }
    }

    return 0xFFFFFFFFLL;
  }

  int v9 = mtu;
  *(_DWORD *)(*(void *)(a2 + 216) + 1044LL) = mtu;
  tso_max_segment_size_uint64_t v4 = nw_path_get_tso_max_segment_size_v4();
  uint64_t v11 = *(void *)(a2 + 216);
  *(_DWORD *)(v11 + 1056) = tso_max_segment_size_v4;
  if (tso_max_segment_size_v4) {
    *(_DWORD *)(v11 + 1048) |= 0x200000u;
  }
  tso_max_segment_size_int v6 = nw_path_get_tso_max_segment_size_v6();
  uint64_t v13 = *(void *)(a2 + 216);
  *(_DWORD *)(v13 + 1060) = tso_max_segment_size_v6;
  if (tso_max_segment_size_v6) {
    *(_DWORD *)(v13 + 1048) |= 0x400000u;
  }
  *(_DWORD *)(*(void *)(a2 + 216) + 1048LL) |= nw_path_get_csum_flags();
  if ((*(_BYTE *)(v4 + 2236) & 2) != 0)
  {
    goto LABEL_24;
  }

  if (nw_path_get_ipv4_network_signature())
  {
LABEL_24:
    memcpy((void *)(*(void *)(a2 + 216) + 1078LL), __src, 0x14uLL);
    *(_BYTE *)(*(void *)(a2 + 216) + 1077LL) = 20;
  }

LABEL_25:
  int interface_index = nw_path_get_interface_index();
  *(_WORD *)(*(void *)(a2 + 216) + 1072LL) = interface_index;
  uint64_t v17 = *(void *)(v4 + 240);
  uint64_t heuristics = tcp_get_heuristics(*(void *)(v17 + 80), 1);
  if (!heuristics)
  {
    int v62 = v9;
    uint64_t v28 = *(void *)(*(void *)(v17 + 80) + 224LL);
    if (!v28 || (*(_BYTE *)(v28 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        int v58 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v59 = "";
          if (v28) {
            uint64_t v59 = (const char *)(v28 + 604);
          }
          *(_DWORD *)&__n[1] = 136446466;
          *(void *)&__n[5] = "tcp_get_route_heuristics";
          __int16 v64 = 2082;
          uint64_t v65 = (uint64_t)v59;
          _os_log_impl( &dword_1879E5000,  v58,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s tcp get heuristics failed",  &__n[1],  0x16u);
        }
      }
    }

    *(void *)(a2 + 1488) = 0LL;
    int v26 = calloc(1uLL, 0x4CuLL);
    if (!v26)
    {
      os_log_type_t v56 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
      *(_DWORD *)&__n[1] = 136446722;
      *(void *)&__n[5] = "strict_calloc";
      __int16 v64 = 2048;
      uint64_t v65 = 1LL;
      __int16 v66 = 2048;
      *(void *)uint64_t v67 = 76LL;
      int v57 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result) {
        goto LABEL_123;
      }
      free(v57);
      int v26 = 0LL;
    }

    int v27 = (void *)(a2 + 1488);
    *(void *)(a2 + 1488) = v26;
    *(_BYTE *)(a2 + 1496) = 1;
    int v9 = v62;
    goto LABEL_39;
  }

  uint64_t v19 = heuristics;
  int v20 = *(_DWORD *)(heuristics + 148);
  *(_DWORD *)(heuristics + 148) = v20 + 1;
  if ((v20 & 0x80000000) == 0) {
    goto LABEL_33;
  }
  uint64_t v21 = *(void *)(*(void *)(v17 + 80) + 224LL);
  if (v21)
  {
    if ((*(_BYTE *)(v21 + 828) & 2) != 0) {
      goto LABEL_33;
    }
  }

  int v61 = v9;
  char v22 = (os_log_s *)__nwlog_tcp_log();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  int v23 = (const char *)(v21 + 604);
  int v24 = *(_DWORD *)(v19 + 148);
  *(_DWORD *)&__n[1] = 136446722;
  *(void *)&__n[5] = "tcp_get_route_heuristics";
  if (!v21) {
    int v23 = "";
  }
  __int16 v64 = 2082;
  uint64_t v65 = (uint64_t)v23;
  __int16 v66 = 1024;
  *(_DWORD *)uint64_t v67 = v24;
  int v25 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if ((_DWORD)result)
  {
LABEL_123:
    __break(1u);
    return result;
  }

  free(v25);
  int v9 = v61;
LABEL_33:
  int v26 = (_DWORD *)(v19 + 68);
  int v27 = (void *)(a2 + 1488);
  *(void *)(a2 + 1488) = v26;
LABEL_39:
  *(_DWORD *)(v5 + 1872) = 1;
  if (*(_DWORD *)(sysctls + 256))
  {
    if (v26[16])
    {
      *(_DWORD *)(v5 + 1872) = 2;
    }

    else
    {
      *(_DWORD *)&__n[1] = 0;
      nw_path_get_rtt_values();
      int v26 = (_DWORD *)*v27;
    }
  }

  if (!v26[12]) {
    v26[12] = v9;
  }
  *(_DWORD *)(a2 + 1328) = 528;
  *(_DWORD *)(a2 + 1332) = v7;
  *(void *)(a2 + 1336) = 0LL;
  uint64_t v29 = *(void *)(a2 + 216);
  int v30 = *(_DWORD *)(v29 + 1048);
  if (((v30 & 0x400020) == 0 && (*(_BYTE *)(v4 + 2236) & 2) != 0
     || (v30 & 0x200002) == 0 && (*(_BYTE *)(v4 + 2236) & 1) != 0)
    && (int partial_checksum_offload = nw_path_flow_registration_get_partial_checksum_offload(),
        uint64_t v29 = *(void *)(a2 + 216),
        int v30 = *(_DWORD *)(v29 + 1048),
        partial_checksum_offload))
  {
    unsigned int v32 = v30 | 0x1000;
  }

  else
  {
    unsigned int v32 = v30 & 0xFFFFEFFF;
  }

  *(_DWORD *)(v29 + 1048) = v32;
  int v33 = (nw_interface *)nw_path_copy_direct_interface();
  if (v33)
  {
    uint64_t v34 = v33;
    switch(nw_interface_get_type(v33))
    {
      case nw_interface_type_other:
        *(_BYTE *)(*(void *)(a2 + 216) + 1076LL) = 1;
        break;
      case nw_interface_type_wifi:
        uint64_t v35 = *(void *)(a2 + 216);
        *(_BYTE *)(v35 + 1076) = 6;
        *(void *)(v35 + 1064) = 0x300000002LL;
        break;
      case nw_interface_type_cellular:
        uint64_t v36 = *(void *)(a2 + 216);
        *(_BYTE *)(v36 + 1076) = -1;
        int v37 = 15;
        goto LABEL_63;
      case nw_interface_type_wired:
        uint64_t v36 = *(void *)(a2 + 216);
        char v38 = 6;
        goto LABEL_62;
      case nw_interface_type_loopback:
        uint64_t v36 = *(void *)(a2 + 216);
        char v38 = 24;
LABEL_62:
        *(_BYTE *)(v36 + 1076) = v38;
        int v37 = 2;
LABEL_63:
        *(_DWORD *)(v36 + 1064) = v37;
        break;
      default:
        break;
    }

    nw_release(v34);
  }

  uint64_t v39 = (nw_interface *)nw_path_copy_delegate_interface();
  if (v39)
  {
    int v40 = v39;
    switch(nw_interface_get_type(v39))
    {
      case nw_interface_type_other:
        *(_DWORD *)(*(void *)(a2 + 216) + 1024LL) = 1;
        break;
      case nw_interface_type_wifi:
        uint64_t v41 = *(void *)(a2 + 216);
        *(_DWORD *)(v41 + 1032) = 3;
        *(void *)(v41 + 1024) = 0x200000006LL;
        break;
      case nw_interface_type_cellular:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0xF000000FFLL;
        goto LABEL_80;
      case nw_interface_type_wired:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0x200000006LL;
        goto LABEL_80;
      case nw_interface_type_loopback:
        uint64_t v42 = *(void *)(a2 + 216);
        uint64_t v43 = 0x200000018LL;
LABEL_80:
        *(void *)(v42 + 1024) = v43;
        break;
      default:
        break;
    }

    nw_release(v40);
  }

  uint64_t v44 = *(void *)(a2 + 216);
  if (v44 && (*(unsigned __int8 *)(v44 + 1076) == 255 || *(_DWORD *)(v44 + 1024) == 255))
  {
    __int16 recommended_mss = nw_path_get_recommended_mss();
    uint64_t v46 = *(void *)(a2 + 216);
    *(_DWORD *)(v46 + 8) |= 0x8000u;
    *(_WORD *)(v46 + 72) = recommended_mss;
  }

  if (nw_path_should_probe_connectivity())
  {
    if ((v3[828] & 2) == 0)
    {
      int v47 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)&__n[1] = 136446466;
        *(void *)&__n[5] = "nw_proto_tcp_route_init";
        __int16 v64 = 2082;
        uint64_t v65 = (uint64_t)(v3 + 604);
        _os_log_impl( &dword_1879E5000,  v47,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s probe connectivity enabled",  &__n[1],  0x16u);
      }
    }

    *(_DWORD *)(v2 + 5308) |= 0x10u;
    *(_DWORD *)(*(void *)(a2 + 216) + 1052LL) |= 8u;
    if (*(void *)(*(void *)(v4 + 224) + 24LL))
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_BYTE *)(all_stats + 96) |= 1u;
      }
    }
  }

  if ((v3[828] & 2) != 0) {
    return 0LL;
  }
  uint64_t result = __nwlog_is_datapath_logging_enabled();
  if ((_DWORD)result)
  {
    uint64_t v49 = (os_log_s *)__nwlog_tcp_log();
    uint64_t result = os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      int v50 = *(_DWORD *)(*(void *)(a2 + 1488) + 48LL);
      int v51 = *(_DWORD *)(*(void *)(a2 + 216) + 1048LL);
      *(_DWORD *)&__n[1] = 136447234;
      *(void *)&__n[5] = "nw_proto_tcp_route_init";
      __int16 v64 = 2082;
      uint64_t v65 = (uint64_t)(v3 + 604);
      __int16 v66 = 1024;
      *(_DWORD *)uint64_t v67 = v50;
      *(_WORD *)&v67[4] = 1024;
      *(_DWORD *)&v67[6] = interface_index;
      __int16 v68 = 1024;
      int v69 = v51;
      _os_log_impl( &dword_1879E5000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s got mtu %d, ifindex %d, offloads %#x",  &__n[1],  0x28u);
      return 0LL;
    }
  }

  return result;
}

uint64_t nw_proto_tcp_bind(uint64_t a1, const void *a2, int a3, void *__dst, size_t __n)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    if (a1 && (*(_BYTE *)(a1 + 828) & 2) != 0) {
      return 0xFFFFFFFFLL;
    }
    __nwlog_tcp_log();
    if (a1) {
      int v7 = (const char *)(a1 + 604);
    }
    else {
      int v7 = "";
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    uint64_t v15 = v7;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t v10 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    uint64_t v15 = v7;
    uint64_t v11 = "%{public}s %{public}s nam is NULL, backtrace limit exceeded";
    goto LABEL_22;
  }

  if (__dst)
  {
    memcpy(__dst, a2, __n);
    return 0LL;
  }

  if (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    if (a1) {
      int v9 = (const char *)(a1 + 604);
    }
    else {
      int v9 = "";
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    uint64_t v15 = v9;
    uint64_t v8 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t v10 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v13 = "nw_proto_tcp_bind";
    __int16 v14 = 2082;
    uint64_t v15 = v9;
    uint64_t v11 = "%{public}s %{public}s outaddr is NULL, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_1879E5000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);
LABEL_23:
    if (v8) {
      free(v8);
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t nw_proto_tcp_ecn_enabled(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1 && *(void *)(v1 + 5208) && *(void *)(v1 + 5216)) {
      return nw_path_flow_registration_ecn_enabled();
    }
    else {
      return 1LL;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v6 = "nw_proto_tcp_ecn_enabled";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v6 = "nw_proto_tcp_ecn_enabled";
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s called with null so, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v3) {
      free(v3);
    }
    return 0LL;
  }

void nw_proto_tcp_ecn_update_cache(uint64_t a1, _BYTE *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      if (v2)
      {
        *(_DWORD *)(v2 + 5308) = *(_DWORD *)(v2 + 5308) & 0xFFFDFFFF | ((*a2 & 1) << 17);
        if (*(void *)(v2 + 5208))
        {
          if (*(void *)(v2 + 5216)) {
            nw_path_flow_registration_set_ecn_cache();
          }
        }
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v7 = "nw_proto_tcp_ecn_update_cache";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v7 = "nw_proto_tcp_ecn_update_cache";
        uint64_t v5 = "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded";
        goto LABEL_15;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v7 = "nw_proto_tcp_ecn_update_cache";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v7 = "nw_proto_tcp_ecn_update_cache";
        uint64_t v5 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_15:
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_ERROR, v5, buf, 0xCu);
      }
    }
  }

  if (v3) {
    free(v3);
  }
}

uint64_t nw_proto_tcp_tfo_enabled(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1 && *(void *)(v1 + 5208) && *(void *)(v1 + 5216)) {
      return nw_path_flow_registration_fast_open_blocked() ^ 1;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v6 = "nw_proto_tcp_tfo_enabled";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v6 = "nw_proto_tcp_tfo_enabled";
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s called with null so, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v3) {
      free(v3);
    }
    return 0LL;
  }

uint64_t nw_proto_tcp_tfo_get_cookie(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    int v6 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v7 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_20:
    _os_log_impl(&dword_1879E5000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
    goto LABEL_21;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    int v6 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v7 = "%{public}s called with null cookie, backtrace limit exceeded";
    goto LABEL_20;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v9 = "nw_proto_tcp_tfo_get_cookie";
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v6 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v9 = "nw_proto_tcp_tfo_get_cookie";
        uint64_t v7 = "%{public}s called with null len, backtrace limit exceeded";
        goto LABEL_20;
      }
    }

uint64_t nw_proto_tcp_tfo_cookie_len(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (v1 && *(void *)(v1 + 5208) && *(void *)(v1 + 5216)) {
      return nw_path_flow_registration_get_tfo_cookie_len();
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v6 = "nw_proto_tcp_tfo_cookie_len";
    uint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v6 = "nw_proto_tcp_tfo_cookie_len";
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s called with null so, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v3) {
      free(v3);
    }
  }

  return 0LL;
}

void nw_proto_tcp_tfo_update_cache(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = *(void *)(a1 + 40);
      if (v2)
      {
        if ((*(_BYTE *)(a2 + 17) & 9) != 0 || !*(_BYTE *)(a2 + 16)) {
          unsigned int v3 = *(_DWORD *)(v2 + 5308) | 0x10000;
        }
        else {
          unsigned int v3 = *(_DWORD *)(v2 + 5308) & 0xFFFEFFFF;
        }
        *(_DWORD *)(v2 + 5308) = v3;
        if (*(void *)(v2 + 5208))
        {
          if (*(void *)(v2 + 5216)) {
            nw_path_flow_registration_set_tfo_cache();
          }
        }
      }

      return;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
        int v6 = "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v8 = "nw_proto_tcp_tfo_update_cache";
        int v6 = "%{public}s called with null so, backtrace limit exceeded";
LABEL_19:
        _os_log_impl(&dword_1879E5000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0xCu);
      }
    }
  }

  if (v4) {
    free(v4);
  }
}

uint64_t nw_protocol_tcp_wake_send()
{
  return nw_queue_context_async();
}

void nw_protocol_tcp_wake_read(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(_DWORD **)(a1 + 40);
  if (v2[1306] == 2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 488);
    if (v3 >= v2[124] || v3 >= *(_DWORD *)(a1 + 496))
    {
      nw_protocol_upcast();
      nw_protocol_get_input_handler();
      if (nw_protocol_input_available_is_valid())
      {
        if ((*(_BYTE *)(a1 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            uint64_t v8 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              int v9 = *(_DWORD *)(a1 + 488);
              int v10 = 136446722;
              uint64_t v11 = "nw_protocol_tcp_wake_read";
              __int16 v12 = 2082;
              uint64_t v13 = a1 + 604;
              __int16 v14 = 1024;
              int v15 = v9;
              _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s waking the input_handler with %d bytes in our queue",  (uint8_t *)&v10,  0x1Cu);
            }
          }
        }

        nw_protocol_get_input_handler();
        nw_protocol_input_available();
      }
    }

    else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        int v5 = v2[124];
        int v6 = v2[122];
        int v10 = 136446978;
        uint64_t v11 = "nw_protocol_tcp_wake_read";
        __int16 v12 = 2082;
        uint64_t v13 = a1 + 604;
        __int16 v14 = 1024;
        int v15 = v5;
        __int16 v16 = 1024;
        int v17 = v6;
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s ignoring wake low_water %u sb_cc %u",  (uint8_t *)&v10,  0x22u);
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v10 = 136446466;
        uint64_t v11 = "nw_protocol_tcp_wake_read";
        __int16 v12 = 2082;
        uint64_t v13 = a1 + 604;
        _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v10, 0x16u);
      }
    }
  }

uint64_t nw_protocol_tcp_wake_read_closed(uint64_t a1)
{
  return nw_queue_context_async();
}

void nw_protocol_tcp_wake_connected(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v3 + 5224) >= 2u)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
        __int16 v22 = 2082;
        *(void *)int v23 = a1 + 604;
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }

    return;
  }

  *(_DWORD *)(v3 + 5224) = 2;
  if (*MEMORY[0x189608EE0] != -1LL) {
    dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
  }
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  microuptime((uint64_t)&v19);
  uint64_t v5 = v19 - *(void *)(v3 + 5248);
  int v6 = v20 - *(_DWORD *)(v3 + 5256);
  LODWORD(v20) = v6;
  if (v6 < 0)
  {
    uint64_t v8 = -1LL;
    int v7 = 1000000;
  }

  else
  {
    int v7 = -1000000;
    uint64_t v8 = 1LL;
  }

  v5 += v8;
  uint64_t v19 = v5;
  v6 += v7;
LABEL_16:
  *(_DWORD *)(v3 + 5296) = v6 + 1000000 * v5;
  nw_protocol_upcast();
  nw_protocol_get_input_handler();
  if (nw_protocol_get_parameters())
  {
    uint64_t v9 = nw_parameters_copy_protocol_options_legacy();
    if (v9)
    {
      int v10 = (void *)v9;
      if (nw_protocol_options_is_tcp())
      {
        int maximum_segment_size = nw_tcp_options_get_maximum_segment_size();
        int v18 = maximum_segment_size;
        if (maximum_segment_size)
        {
          if ((*(_BYTE *)(a1 + 828) & 2) == 0)
          {
            int v12 = maximum_segment_size;
            uint64_t v13 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
              __int16 v22 = 2082;
              *(void *)int v23 = a1 + 604;
              *(_WORD *)&v23[8] = 1024;
              LODWORD(v24) = v12;
              _os_log_impl( &dword_1879E5000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s setting MSS to %d",  buf,  0x1Cu);
            }
          }

          *(void *)__int128 buf = 0x600000001LL;
          *(_DWORD *)&buf[8] = 2;
          *(void *)&v23[2] = &v18;
          uint64_t v24 = 4LL;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16LL))(v3, 1LL, v1);
          else {
            int v14 = 22;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24LL))(v3, 1LL, v1);
          if (v14)
          {
            __nwlog_obj();
            uint64_t v15 = a1 + 604;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
            __int16 v22 = 2082;
            *(void *)int v23 = a1 + 604;
            *(_WORD *)&v23[8] = 1024;
            LODWORD(v24) = v14;
            __int16 v16 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              int v17 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_tcp_wake_connected";
                __int16 v22 = 2082;
                *(void *)int v23 = v15;
                *(_WORD *)&v23[8] = 1024;
                LODWORD(v24) = v14;
                _os_log_impl( &dword_1879E5000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s tcp_setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
              }
            }

            if (v16) {
              free(v16);
            }
          }
        }
      }

      nw_release(v10);
    }
  }

  nw_protocol_get_input_handler();
  nw_protocol_connected_quiet();
}

void nw_protocol_tcp_wake_disconnect(uint64_t a1)
{
}

void nw_protocol_tcp_wake_disconnected(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) == 4)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v3 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v6 = "nw_protocol_tcp_wake_disconnected";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl(&dword_1879E5000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
      }
    }
  }

  else
  {
    *(_DWORD *)(v2 + 5224) = 4;
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v6 = "nw_protocol_tcp_wake_disconnected";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp disconnected", buf, 0x16u);
      }
    }

    if (*MEMORY[0x189608EE0] != -1LL) {
      dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
    }
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }

void nw_protocol_tcp_wake_read_timeout(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (int v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x40) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x100000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v6 = "nw_protocol_tcp_wake_read_timeout";
      __int16 v7 = 2082;
      uint64_t v8 = a1 + 604;
      _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }

void nw_protocol_tcp_wake_write_timeout(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (int v3 = *(_DWORD *)(v2 + 5308), (v3 & 0x80) != 0))
  {
    *(_DWORD *)(v2 + 5308) = v3 | 0x80000;
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v6 = "nw_protocol_tcp_wake_write_timeout";
      __int16 v7 = 2082;
      uint64_t v8 = a1 + 604;
      _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }

void nw_protocol_tcp_wake_keepalive(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 5224) <= 2u && (*(_BYTE *)(v2 + 5309) & 1) != 0)
  {
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    int v3 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v5 = "nw_protocol_tcp_wake_keepalive";
      __int16 v6 = 2082;
      uint64_t v7 = a1 + 604;
      _os_log_impl(&dword_1879E5000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }

uint64_t nw_protocol_tcp_signal_error(uint64_t a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v7 = "nw_protocol_tcp_signal_error";
      __int16 v8 = 2082;
      uint64_t v9 = a1 + 604;
      __int16 v10 = 1024;
      int v11 = a2;
      _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp signal error: %d", buf, 0x1Cu);
    }
  }

  nw_protocol_upcast();
  nw_protocol_retain();
  return nw_queue_context_async();
}

uint64_t __nw_protocol_tcp_signal_error_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 5308LL) & 2) != 0)
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        int v3 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v4 = "";
          if (v1) {
            uint64_t v4 = (const char *)(v1 + 604);
          }
          int v5 = 136446466;
          __int16 v6 = "nw_protocol_tcp_signal_error_block_invoke";
          __int16 v7 = 2082;
          __int16 v8 = v4;
          _os_log_impl(&dword_1879E5000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v5, 0x16u);
        }
      }
    }
  }

  else
  {
    nw_protocol_get_input_handler();
    nw_protocol_error_quiet();
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_keepalive_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __int16 v8 = "";
        if (v2) {
          __int16 v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s keepalive", (uint8_t *)&v9, 0x16u);
      }
    }
  }

  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224LL) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_keepalive_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_write_timeout_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __int16 v8 = "";
        if (v2) {
          __int16 v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s write timeout",  (uint8_t *)&v9,  0x16u);
      }
    }
  }

  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224LL) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_write_timeout_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_read_timeout_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __int16 v8 = "";
        if (v2) {
          __int16 v8 = (const char *)(v2 + 604);
        }
        int v9 = 136446466;
        __int16 v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
        __int16 v11 = 2082;
        uint64_t v12 = v8;
        _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s read timeout",  (uint8_t *)&v9,  0x16u);
      }
    }
  }

  if (*(_DWORD *)(*(void *)(a1 + 40) + 5224LL) < 3u)
  {
    nw_protocol_get_input_handler();
    nw_protocol_notify_quiet();
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = "";
          if (v3) {
            int v5 = (const char *)(v3 + 604);
          }
          int v9 = 136446466;
          __int16 v10 = "nw_protocol_tcp_wake_read_timeout_block_invoke";
          __int16 v11 = 2082;
          uint64_t v12 = v5;
          _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v9, 0x16u);
        }
      }
    }
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_disconnected_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 5308);
  if ((v3 & 4) == 0)
  {
    nw_protocol_get_output_handler();
    nw_protocol_disconnect_quiet();
    uint64_t v2 = *(void *)(a1 + 32);
    int v3 = *(_DWORD *)(v2 + 5308);
  }

  if ((v3 & 1) != 0) {
    nw_protocol_tcp_release(v2);
  }
  return nw_protocol_release();
}

void nw_protocol_tcp_release(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_DWORD *)(a1 + 5308) &= ~1u;
    nw_protocol_upcast();
    nw_protocol_get_output_handler();
    if (nw_protocol_remove_input_handler_is_valid())
    {
      nw_protocol_get_output_handler();
      nw_protocol_remove_input_handler();
    }

    else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      uint64_t v2 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v6 = "nw_protocol_tcp_release";
        __int16 v7 = 2082;
        uint64_t v8 = a1 + 604;
        _os_log_impl( &dword_1879E5000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s remove_input_handler is not valid",  buf,  0x16u);
      }
    }

    nw_protocol_destroy();
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v6 = "nw_protocol_tcp_release";
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v6 = "nw_protocol_tcp_release";
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s called with null tcp, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v3) {
      free(v3);
    }
  }

void __nw_protocol_tcp_release_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_protocol_tcp_dispose";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    __int16 v10 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_protocol_tcp_dispose";
    __int16 v11 = "%{public}s called with null object, backtrace limit exceeded";
    goto LABEL_22;
  }

  if ((*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    uint64_t v2 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v13 = "nw_protocol_tcp_dispose";
      __int16 v14 = 2082;
      uint64_t v15 = v1 + 604;
      _os_log_impl(&dword_1879E5000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}s tcp dispose", buf, 0x16u);
    }
  }

  int v3 = *(void **)(v1 + 5208);
  if (v3)
  {
    nw_release(v3);
    *(void *)(v1 + 5208) = 0LL;
  }

  if (*(void *)(v1 + 5232))
  {
    nw_tcp_set_callbacks();
    uint64_t v4 = *(void **)(v1 + 5232);
    if (v4)
    {
      nw_release(v4);
      *(void *)(v1 + 5232) = 0LL;
    }
  }

  int v5 = *(void **)(v1 + 5216);
  if (v5)
  {
    nw_release(v5);
    *(void *)(v1 + 5216) = 0LL;
  }

  __int16 v6 = *(void **)(v1 + 5200);
  if (v6)
  {
    nw_release(v6);
    *(void *)(v1 + 5200) = 0LL;
  }

  __int16 v7 = *(void **)(v1 + 5272);
  if (v7)
  {
    free(v7);
    *(void *)(v1 + 5272) = 0LL;
  }

  uint64_t v8 = *(void **)(v1 + 5280);
  if (v8)
  {
    free(v8);
    *(void *)(v1 + 5280) = 0LL;
  }

  bzero((void *)v1, 0x1440uLL);
  if ((*(_BYTE *)(v1 + 5308) & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_protocol_tcp_dispose";
    uint64_t v9 = (void *)_os_log_send_and_compose_impl();
    __int16 v10 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_protocol_tcp_dispose";
    __int16 v11 = "%{public}s tcp->release_is_delayed set during dispose, backtrace limit exceeded";
LABEL_22:
    _os_log_impl(&dword_1879E5000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
LABEL_23:
    if (v9) {
      free(v9);
    }
  }

uint64_t ____nw_signpost_is_enabled_block_invoke()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x189608ED8] = result;
  return result;
}

void __nw_protocol_tcp_disconnect(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 5224) < 3u)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      int v3 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v5 = "__nw_protocol_tcp_disconnect";
        __int16 v6 = 2082;
        uint64_t v7 = a1 + 604;
        _os_log_impl(&dword_1879E5000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s disconnect tcp", buf, 0x16u);
      }
    }

    *(_DWORD *)(a1 + 5224) = 3;
    nw_protocol_tcp_log_summary(a1);
    nw_protocol_upcast();
    nw_protocol_retain();
    nw_queue_context_async();
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
  {
    uint64_t v2 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v5 = "__nw_protocol_tcp_disconnect";
      __int16 v6 = 2082;
      uint64_t v7 = a1 + 604;
      _os_log_impl(&dword_1879E5000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", buf, 0x16u);
    }
  }

void nw_protocol_tcp_log_summary(uint64_t a1)
{
  v155[2] = *MEMORY[0x1895F89C0];
  if (*(void *)a1)
  {
    uint64_t v2 = *(void *)(*(void *)a1 + 240LL);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 40);
      if ((*(_BYTE *)(v3 + 5309) & 0x40) != 0) {
        return;
      }
      if ((*(_DWORD *)(v2 + 1872) & 0xFFFFFFFE) != 2)
      {
        *(_DWORD *)(v2 + 204) = *(_DWORD *)(v2 + 200);
        *(_DWORD *)(v2 + 212) = *(_DWORD *)(v2 + 208);
      }

      uint64_t v4 = *(void *)(*(void *)(v2 + 80) + 496LL);
      if (!v4 || (uint64_t v5 = *(void *)(v4 + 1488)) == 0 || (v6 = *(_DWORD *)(v5 + 40)) == 0) {
        int v6 = *(_DWORD *)(v2 + 1964);
      }
      v155[0] = 0LL;
      v155[1] = 0LL;
      nw_protocol_upcast();
      nw_protocol_get_flow_id();
      if ((*(_BYTE *)(a1 + 828) & 4) != 0)
      {
        if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
          goto LABEL_30;
        }
        uint64_t v7 = (os_log_s *)__nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_30;
        }
        uint64_t v74 = a1 + 604;
        unsigned int v11 = *(_DWORD *)(v3 + 5308);
        unsigned int v12 = *(_DWORD *)(v3 + 5296);
        unsigned int v13 = v12 / 0x3E8;
        BOOL v72 = ((v11 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        uint64_t v60 = *(void *)(v3 + 5272);
        int v56 = *(unsigned __int16 *)(v3 + 5300);
        uint64_t v64 = *(void *)(v3 + 5280);
        int v70 = *(unsigned __int16 *)(v3 + 5302);
        unsigned int v66 = v12 % 0x3E8;
        int v68 = (v11 >> 18) & 1;
        int v62 = *(unsigned __int8 *)(v2 + 1868);
        int v58 = *(unsigned __int8 *)(v2 + 266);
        int v52 = *(unsigned __int8 *)(v2 + 265);
        int v54 = (v11 >> 19) & 1;
        int v50 = (v11 >> 20) & 1;
        int v46 = HIWORD(v11) & 1;
        int v48 = (v11 >> 15) & 1;
        int v23 = *(_DWORD *)(v3 + 5304);
        int v44 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        int v24 = (v11 >> 17) & 1;
        uint64_t v25 = nw_connection_client_accurate_ecn_state_to_string();
        uint64_t v26 = nw_connection_server_accurate_ecn_state_to_string();
        unsigned int v27 = *(_DWORD *)(v2 + 88);
        BOOL v28 = (~v27 & 0x180) == 0;
        int v29 = (v27 >> 28) & 1;
        unsigned int v30 = *(_DWORD *)(v2 + 1872) - 1;
        if (v30 > 2) {
          uint64_t v31 = "invalid";
        }
        else {
          uint64_t v31 = off_18A0EEAF8[v30];
        }
        int v37 = *(_DWORD *)(v2 + 200);
        int v38 = *(_DWORD *)(v2 + 204);
        int v39 = *(_DWORD *)(v2 + 208);
        int v40 = *(_DWORD *)(v2 + 212);
        int v114 = v23;
        int v118 = v24;
        uint64_t v120 = v25;
        uint64_t v122 = v26;
        int v126 = v29;
        uint64_t v128 = v31;
        int v130 = *(_DWORD *)(v2 + 240);
        int v134 = ((1000 * v37) >> 5) % 1000;
        int v138 = ((1000 * v39) >> 4) % 1000;
        int v142 = ((1000 * v38) >> 5) % 1000;
        int v146 = ((1000 * v40) >> 4) % 1000;
        int v150 = *(_DWORD *)(v2 + 1884);
        int v154 = *(_DWORD *)(v2 + 724);
        int v76 = "nw_protocol_tcp_log_summary";
        uint64_t v78 = v74;
        __int16 v79 = 1042;
        int v80 = 16;
        __int16 v81 = 2098;
        os_log_type_t v82 = v155;
        uint64_t v84 = v60;
        int v86 = v56;
        __int16 v83 = 2085;
        __int16 v87 = 2085;
        uint64_t v88 = v64;
        __int16 v85 = 1026;
        __int16 v89 = 1026;
        int v90 = v70;
        int v92 = v68;
        unsigned int v94 = v13;
        unsigned int v96 = v66;
        int v98 = v62;
        int v100 = v58;
        int v102 = v54;
        int v104 = v52;
        int v106 = v50;
        int v108 = v48;
        BOOL v110 = v72;
        int v112 = v46;
        int v116 = v44;
        __int16 v119 = 2080;
        __int16 v121 = 2080;
        BOOL v124 = v28;
        __int16 v77 = 2082;
        __int16 v127 = 2082;
        int v132 = v37 >> 5;
        int v136 = v39 >> 4;
        int v140 = v38 >> 5;
        int v144 = v40 >> 4;
        int v148 = v6;
        int v152 = *(_DWORD *)(v2 + 728);
        __int16 v91 = 1024;
        __int16 v93 = 1024;
        __int16 v95 = 1024;
        __int16 v97 = 1024;
        __int16 v99 = 1024;
        __int16 v101 = 1024;
        __int16 v103 = 1024;
        __int16 v105 = 1024;
        __int16 v107 = 1024;
        __int16 v109 = 1024;
        __int16 v111 = 1024;
        __int16 v113 = 1024;
        __int16 v115 = 1024;
        __int16 v117 = 1024;
        __int16 v123 = 1024;
        __int16 v125 = 1024;
        __int16 v129 = 1024;
        __int16 v131 = 1024;
        __int16 v133 = 1024;
        __int16 v135 = 1024;
        __int16 v137 = 1024;
        __int16 v139 = 1024;
        __int16 v141 = 1024;
        __int16 v143 = 1024;
        __int16 v145 = 1024;
        __int16 v147 = 1024;
        __int16 v149 = 1024;
        __int16 v151 = 1024;
        __int16 v153 = 1024;
        *(_DWORD *)__int128 buf = 136456195;
        uint64_t v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{sensitive}s:%{public}d<->%{sensitive}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }

      else
      {
        if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
          goto LABEL_30;
        }
        uint64_t v7 = (os_log_s *)__nwlog_tcp_log();
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_30;
        }
        uint64_t v71 = a1 + 604;
        unsigned int v8 = *(_DWORD *)(v3 + 5308);
        unsigned int v9 = *(_DWORD *)(v3 + 5296);
        unsigned int v10 = v9 / 0x3E8;
        BOOL v73 = ((v8 >> 15) & 1) != 0 && (*(_WORD *)(v2 + 990) & 0x800) == 0;
        uint64_t v47 = *(void *)(v3 + 5272);
        int v45 = *(unsigned __int16 *)(v3 + 5300);
        uint64_t v43 = *(void *)(v3 + 5280);
        int v53 = *(unsigned __int16 *)(v3 + 5302);
        unsigned int v67 = v9 % 0x3E8;
        int v65 = *(unsigned __int8 *)(v2 + 1868);
        int v61 = (v8 >> 19) & 1;
        int v63 = *(unsigned __int8 *)(v2 + 266);
        int v57 = (v8 >> 20) & 1;
        int v59 = *(unsigned __int8 *)(v2 + 265);
        int v55 = (v8 >> 15) & 1;
        int v69 = HIWORD(v8) & 1;
        int v14 = *(_DWORD *)(v3 + 5304);
        int v49 = (*(_DWORD *)(v2 + 348) >> 12) & 1;
        int v51 = (v8 >> 18) & 1;
        int v15 = (v8 >> 17) & 1;
        uint64_t v16 = nw_connection_client_accurate_ecn_state_to_string();
        uint64_t v17 = nw_connection_server_accurate_ecn_state_to_string();
        unsigned int v18 = *(_DWORD *)(v2 + 88);
        BOOL v19 = (~v18 & 0x180) == 0;
        int v20 = (v18 >> 28) & 1;
        unsigned int v21 = *(_DWORD *)(v2 + 1872) - 1;
        if (v21 > 2) {
          __int16 v22 = "invalid";
        }
        else {
          __int16 v22 = off_18A0EEAF8[v21];
        }
        int v32 = *(_DWORD *)(v2 + 200);
        int v33 = *(_DWORD *)(v2 + 204);
        int v34 = *(_DWORD *)(v2 + 208);
        int v35 = *(_DWORD *)(v2 + 212);
        int v114 = v14;
        int v118 = v15;
        uint64_t v120 = v16;
        uint64_t v122 = v17;
        int v126 = v20;
        uint64_t v128 = v22;
        int v130 = *(_DWORD *)(v2 + 240);
        int v134 = ((1000 * v32) >> 5) % 1000;
        int v138 = ((1000 * v34) >> 4) % 1000;
        int v142 = ((1000 * v33) >> 5) % 1000;
        int v146 = ((1000 * v35) >> 4) % 1000;
        int v150 = *(_DWORD *)(v2 + 1884);
        int v154 = *(_DWORD *)(v2 + 724);
        int v76 = "nw_protocol_tcp_log_summary";
        uint64_t v78 = v71;
        __int16 v79 = 1042;
        int v80 = 16;
        __int16 v81 = 2098;
        os_log_type_t v82 = v155;
        uint64_t v84 = v47;
        int v86 = v45;
        uint64_t v88 = v43;
        __int16 v85 = 1026;
        __int16 v89 = 1026;
        int v90 = v53;
        int v92 = v51;
        unsigned int v94 = v10;
        unsigned int v96 = v67;
        int v98 = v65;
        int v100 = v63;
        int v102 = v61;
        int v104 = v59;
        int v106 = v57;
        int v108 = v55;
        BOOL v110 = v73;
        int v112 = v69;
        int v116 = v49;
        __int16 v119 = 2080;
        __int16 v121 = 2080;
        BOOL v124 = v19;
        __int16 v77 = 2082;
        __int16 v83 = 2082;
        __int16 v87 = 2082;
        __int16 v127 = 2082;
        int v132 = v32 >> 5;
        int v136 = v34 >> 4;
        int v140 = v33 >> 5;
        int v144 = v35 >> 4;
        int v148 = v6;
        int v152 = *(_DWORD *)(v2 + 728);
        __int16 v91 = 1024;
        __int16 v93 = 1024;
        __int16 v95 = 1024;
        __int16 v97 = 1024;
        __int16 v99 = 1024;
        __int16 v101 = 1024;
        __int16 v103 = 1024;
        __int16 v105 = 1024;
        __int16 v107 = 1024;
        __int16 v109 = 1024;
        __int16 v111 = 1024;
        __int16 v113 = 1024;
        __int16 v115 = 1024;
        __int16 v117 = 1024;
        __int16 v123 = 1024;
        __int16 v125 = 1024;
        __int16 v129 = 1024;
        __int16 v131 = 1024;
        __int16 v133 = 1024;
        __int16 v135 = 1024;
        __int16 v137 = 1024;
        __int16 v139 = 1024;
        __int16 v141 = 1024;
        __int16 v143 = 1024;
        __int16 v145 = 1024;
        __int16 v147 = 1024;
        __int16 v149 = 1024;
        __int16 v151 = 1024;
        __int16 v153 = 1024;
        *(_DWORD *)__int128 buf = 136456194;
        uint64_t v36 = "%{public}s %{public}s \n"
              "\t[%{public,uuid_t}.16P %{public}s:%{public}d<->%{public}s:%{public}d]\n"
              "\tInit: %d, Conn_Time: %u.%03ums, SYNs: %u, WR_T: %d/%d, RD_T: %d/%d, TFO: %d/%d/%d, ECN: %d/%d/%d, Accura"
              "te ECN (client/server): %s/%s, TS: %d, TSO: %d\n"
              "\trtt_cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rtt_nc: %u.%03ums, rtt_var_nc: %u"
              ".%03ums base rtt: %ums\n"
              "\tACKs-compressed: %u, ACKs delayed: %u delayed ACKs sent: %u";
      }

      _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_DEFAULT, v36, buf, 0x112u);
LABEL_30:
      *(_DWORD *)(v3 + 5308) |= 0x4000u;
      return;
    }

    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      uint64_t v41 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v76 = "nw_protocol_tcp_log_summary";
        __int16 v77 = 2082;
        uint64_t v78 = a1 + 604;
        uint64_t v42 = "%{public}s %{public}s tcp pcb is NULL";
        goto LABEL_38;
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    uint64_t v41 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      int v76 = "nw_protocol_tcp_log_summary";
      __int16 v77 = 2082;
      uint64_t v78 = a1 + 604;
      uint64_t v42 = "%{public}s %{public}s socket inpcb is NULL";
LABEL_38:
      _os_log_impl(&dword_1879E5000, v41, OS_LOG_TYPE_INFO, v42, buf, 0x16u);
    }
  }

uint64_t ____nw_protocol_tcp_disconnect_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(*(void *)(a1 + 32) + 5308LL) & 2) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      uint64_t v3 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = "";
        if (v2) {
          uint64_t v4 = (const char *)(v2 + 604);
        }
        int v6 = 136446466;
        uint64_t v7 = "__nw_protocol_tcp_disconnect_block_invoke";
        __int16 v8 = 2082;
        unsigned int v9 = v4;
        _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s send disconnect to input protocol",  (uint8_t *)&v6,  0x16u);
      }
    }

    nw_protocol_get_input_handler();
    if (nw_protocol_disconnected_is_valid())
    {
      if (*MEMORY[0x189608EE0] != -1LL) {
        dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_16);
      }
      nw_protocol_get_input_handler();
      nw_protocol_disconnected();
    }

    *(_DWORD *)(*(void *)(a1 + 32) + 5308LL) |= 2u;
  }

  tcp_close_locked(*(void *)(a1 + 40));
  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_read_closed_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(_DWORD *)(*(void *)(a1 + 32) + 5224LL) < 3u)
  {
    if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
    {
      uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        uint64_t v5 = "";
        if (v1) {
          uint64_t v5 = (const char *)(v1 + 604);
        }
        int v7 = 136446466;
        __int16 v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        __int16 v9 = 2082;
        uint64_t v10 = v5;
        _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s read closed", (uint8_t *)&v7, 0x16u);
      }
    }

    nw_protocol_get_input_handler();
    nw_protocol_input_finished_quiet();
  }

  else if (!v1 || (*(_BYTE *)(v1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v2 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v3 = "";
        if (v1) {
          uint64_t v3 = (const char *)(v1 + 604);
        }
        int v7 = 136446466;
        __int16 v8 = "nw_protocol_tcp_wake_read_closed_block_invoke";
        __int16 v9 = 2082;
        uint64_t v10 = v3;
        _os_log_impl(&dword_1879E5000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v7, 0x16u);
      }
    }
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_wake_send_block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(*(void *)(a1 + 32) + 5224LL) == 2)
  {
    int v3 = *(_DWORD *)(v2 + 384);
    int v4 = *(_DWORD *)(v2 + 388) - v3;
    int v5 = *(_DWORD *)(v2 + 484);
    int v6 = v5 - v3;
    if (v6 >= v4) {
      int v6 = v4;
    }
    if (v5) {
      int v4 = v6;
    }
    if ((v4 & ~(v4 >> 31)) >= *(_DWORD *)(v2 + 392))
    {
      nw_protocol_get_input_handler();
      nw_protocol_output_available_quiet();
    }

    else if ((*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        int v7 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __int16 v8 = *(_DWORD **)(a1 + 40);
          int v9 = v8[98];
          int v10 = v8[96];
          int v11 = v8[97] - v10;
          int v12 = v8[121];
          int v13 = v12 - v10;
          if (v13 >= v11) {
            int v13 = v11;
          }
          if (v12) {
            int v14 = v13;
          }
          else {
            int v14 = v11;
          }
          int v18 = 136446978;
          BOOL v19 = "nw_protocol_tcp_wake_send_block_invoke";
          __int16 v20 = 2082;
          unsigned int v21 = (const char *)(v2 + 604);
          __int16 v22 = 1024;
          int v23 = v9;
          __int16 v24 = 1024;
          int v25 = v14 & ~(v14 >> 31);
          _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Ignoring wake low_water %u sbpace %u",  (uint8_t *)&v18,  0x22u);
        }
      }
    }
  }

  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v15 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = "";
        if (v2) {
          uint64_t v16 = (const char *)(v2 + 604);
        }
        int v18 = 136446466;
        BOOL v19 = "nw_protocol_tcp_wake_send_block_invoke";
        __int16 v20 = 2082;
        unsigned int v21 = v16;
        _os_log_impl(&dword_1879E5000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipping", (uint8_t *)&v18, 0x16u);
      }
    }
  }

  return nw_protocol_release();
}

uint64_t __nw_protocol_tcp_finalize_output_frames_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v30 = "__nw_frame_unclaimed_length";
    uint64_t v16 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v30 = "__nw_frame_unclaimed_length";
        _os_log_impl( &dword_1879E5000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v16) {
      free(v16);
    }
    goto LABEL_36;
  }

  int v4 = *(_DWORD *)(a2 + 52);
  if (!v4)
  {
LABEL_36:
    unsigned int v5 = 0;
    goto LABEL_37;
  }

  unsigned int v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    BOOL v6 = v4 == *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int v7 = *(char *)(a2 + 186);
    uint64_t v8 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    unsigned int v9 = (*(uint64_t (**)(uint64_t, void, uint64_t, void, void))(*(void *)(*(void *)(v8 + 8) + 40LL)
                                                                             + 72LL))( v8,  0LL,  a2,  0LL,  0LL);
    unsigned int v10 = v9;
    if ((*(_DWORD *)(v8 + 368) & 0x30) != 0) {
      *(_DWORD *)(v8 + 368) &= *(_DWORD *)(v8 + 368) & 0x10 ^ 0xFFFFFFDF;
    }
    if (v9 > 0x23 || ((1LL << v9) & 0x800000011LL) == 0)
    {
      uint64_t v12 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
      if (!v12 || (*(_BYTE *)(v12 + 828) & 2) == 0)
      {
        int v13 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          int v14 = (const char *)(v12 + 604);
          unsigned int v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
          __int16 v31 = 2082;
          *(_DWORD *)__int128 buf = 136446978;
          if (!v12) {
            int v14 = "";
          }
          int v32 = v14;
          __int16 v33 = 1024;
          unsigned int v34 = v10;
          __int16 v35 = 1024;
          unsigned int v36 = v5;
          _os_log_impl( &dword_1879E5000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s tcp_finalize_send error %d for frame of length %u",  buf,  0x22u);
        }
      }

      *(_WORD *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + 378LL) = v10;
      user_north_signal_error(*(void *)(*(void *)(a1[5] + 8LL) + 24LL));
      *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
    }

    if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) && v7 < 0)
    {
      uint64_t v15 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
      if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v18 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            BOOL v19 = "";
            if (v15) {
              BOOL v19 = (const char *)(v15 + 604);
            }
            *(_DWORD *)__int128 buf = 136446466;
            unsigned int v30 = "nw_protocol_tcp_finalize_output_frames_block_invoke";
            __int16 v31 = 2082;
            int v32 = v19;
            _os_log_impl( &dword_1879E5000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s frame marks connection complete, marking output finished",  buf,  0x16u);
          }
        }
      }

      nw_protocol_tcp_output_finished(a1[6]);
    }

    return 1LL;
  }

LABEL_57:
  if (v24) {
    free(v24);
  }
  return 1LL;
}

void nw_protocol_tcp_set_receive_low_water_mark(uint64_t a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v4 = nw_protocol_downcast();
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    uint64_t v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        _os_log_impl( &dword_1879E5000,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s called with null tcp, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v15) {
      free(v15);
    }
    return;
  }

  uint64_t v5 = v4;
  if (*(_DWORD *)(v4 + 496) == a2) {
    return;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 8) + 16LL))(v4, 1LL, v2);
  if ((~*(unsigned __int16 *)(v5 + 376) & 0x30) != 0)
  {
    if (a2 > 0) {
      goto LABEL_8;
    }
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 24LL))(v5, 1LL, v2);
    int v14 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)__int128 buf = 136446722;
    int v18 = "nw_protocol_tcp_set_receive_low_water_mark";
    __int16 v19 = 1024;
    *(_DWORD *)uint64_t v20 = a2;
    *(_WORD *)&v20[4] = 1024;
    *(_DWORD *)&v20[6] = 22;
    unsigned int v10 = "%{public}s setsockopt SO_RCVLOWAT %u failed %{darwin.errno}d";
    int v11 = v14;
    os_log_type_t v12 = OS_LOG_TYPE_ERROR;
    uint32_t v13 = 24;
    goto LABEL_21;
  }

  if ((*(_BYTE *)(v5 + 365) & 0x20) == 0 || a2 < 1) {
    goto LABEL_19;
  }
LABEL_8:
  signed int v6 = *(_DWORD *)(v5 + 492) / 3u;
  if (a2 <= *(_DWORD *)(v5 + 492) / 3) {
    signed int v6 = a2;
  }
  if (v6 >= 0x4000) {
    signed int v6 = 0x4000;
  }
  *(_DWORD *)(v5 + 496) = v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 + 8) + 24LL))(v5, 1LL, v2);
  if ((*(_BYTE *)(v5 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = *(_DWORD *)(v5 + 496);
        int v9 = *(_DWORD *)(v5 + 488);
        *(_DWORD *)__int128 buf = 136446978;
        int v18 = "nw_protocol_tcp_set_receive_low_water_mark";
        __int16 v19 = 2082;
        *(void *)uint64_t v20 = v5 + 604;
        *(_WORD *)&v20[8] = 1024;
        int v21 = v8;
        __int16 v22 = 1024;
        int v23 = v9;
        unsigned int v10 = "%{public}s %{public}s so_rcv.sb_lowat %u sb_cc %u";
        int v11 = v7;
        os_log_type_t v12 = OS_LOG_TYPE_DEBUG;
        uint32_t v13 = 34;
LABEL_21:
        _os_log_impl(&dword_1879E5000, v11, v12, v10, buf, v13);
      }
    }
  }

uint64_t __nw_protocol_tcp_get_input_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  int v3 = *(nw_protocol_metadata **)(*(void *)(a1 + 32) + 5232LL);
  if (*(_BYTE *)(a1 + 40))
  {
    BOOL v4 = *(void *)(a2 + 32) == 0LL;
    if (v3) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v8 = a2 + 204;
    if ((*(_WORD *)(a2 + 204) & 8) != 0) {
      return 1LL;
    }
    goto LABEL_15;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v44 = "__nw_frame_set_metadata";
    uint64_t v15 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v34 = (os_log_s *)__nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = "__nw_frame_set_metadata";
          int v18 = "%{public}s called with null frame";
LABEL_77:
          unsigned int v30 = v34;
          os_log_type_t v31 = v35;
          uint32_t v32 = 12;
LABEL_59:
          _os_log_impl(&dword_1879E5000, v30, v31, v18, buf, v32);
        }
      }

      else
      {
        unsigned int v34 = (os_log_s *)__nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v44 = "__nw_frame_set_metadata";
          int v18 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }

LABEL_81:
    if (v36) {
      free(v36);
    }
    goto LABEL_6;
  }

  if (v47 >= v72)
  {
    int v51 = **(void **)(*(void *)(a1 + 552) + 8LL);
    if (v51)
    {
      while (1)
      {
        int v53 = *v47;
        int v54 = *(_DWORD *)(v51 + 4);
        if (*v47 - v54 >= 0) {
          goto LABEL_106;
        }
        int v55 = v47[1];
        int v56 = *(_DWORD *)v51;
        int v57 = v55 - *(_DWORD *)v51;
        if (v57 <= 0)
        {
          int v52 = **(void **)(*(void *)(v51 + 24) + 8LL);
LABEL_85:
          int v51 = v52;
          if (!v52) {
            return;
          }
        }

        else
        {
          int v58 = v56 - *(_DWORD *)(v51 + 8) + *(_DWORD *)(a1 + 624);
          *(_DWORD *)(a1 + 624) = v58 & ~(v58 >> 31);
          int v59 = v55 - v54;
          if (v53 - v56 > 0)
          {
            if (v59 < 0)
            {
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, v55, v45);
              int v65 = tcp_sackhole_insert(a1, v47[1], *(_DWORD *)(v51 + 4), v51);
              if (v65)
              {
                *a4 += v47[1] - *v47;
                int v63 = *(_DWORD *)(v51 + 8);
                if (v63 - v65[2] >= 1)
                {
                  v65[2] = v63;
                  *(_DWORD *)(a1 + 624) += v63 - *v65;
                  int v63 = *(_DWORD *)(v51 + 8);
                }

                if (v63 - *v47 >= 0) {
                  int v63 = *v47;
                }
                *(_DWORD *)(v51 + 4) = *v47;
                *(_DWORD *)(v51 + 8) = v63;
                v65[3] = *(_DWORD *)(v51 + 12);
              }

              else
              {
                int v63 = *(_DWORD *)(v51 + 8);
              }
            }

            else
            {
              *a4 += v54 - v53;
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
              int v63 = *(_DWORD *)(v51 + 8);
              if (v63 - *v47 >= 0) {
                int v63 = *v47;
              }
              *(_DWORD *)(v51 + 4) = *v47;
              *(_DWORD *)(v51 + 8) = v63;
            }
          }

          else
          {
            if ((v59 & 0x80000000) == 0)
            {
              *a4 += v54 - v56;
              tcp_sack_detect_reordering(a1, (_DWORD *)v51, *(_DWORD *)(v51 + 4), v45);
              int v61 = *(void *)(v51 + 16);
              uint64_t v60 = *(void *)(v51 + 24);
              int v52 = **(void **)(v60 + 8);
              if (*(void *)(a1 + 616) == v51)
              {
                *(void *)(a1 + 616) = v61;
                if (!v61) {
                  goto LABEL_94;
                }
LABEL_92:
                *(void *)(v61 + 24) = v60;
                uint64_t v60 = *(void *)(v51 + 24);
              }

              else
              {
                if (v61) {
                  goto LABEL_92;
                }
LABEL_94:
                *(void *)(a1 + 552) = v60;
              }

              *(void *)uint64_t v60 = v61;
              nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
              free((void *)v51);
              --*(_WORD *)(a1 + 538);
              do
                int v62 = __ldxr((unsigned int *)&tcp_sack_globalholes);
              while (__stxr(v62 - 1, (unsigned int *)&tcp_sack_globalholes));
              goto LABEL_85;
            }

            *a4 += v57;
            tcp_sack_detect_reordering(a1, (_DWORD *)v51, v47[1], v45);
            int v63 = v47[1];
            *(_DWORD *)int v51 = v63;
            if (*(_DWORD *)(v51 + 8) - v63 > 0) {
              int v63 = *(_DWORD *)(v51 + 8);
            }
            *(_DWORD *)(v51 + 8) = v63;
          }

          uint64_t v64 = *(_DWORD *)v51;
          *(_DWORD *)(a1 + 624) += v63 - *(_DWORD *)v51;
          if (*v47 - v64 <= 0)
          {
            int v51 = **(void **)(*(void *)(v51 + 24) + 8LL);
            if (v47 < v72) {
              return;
            }
            goto LABEL_109;
          }

void tcp_tfo_gen_cookie(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  char v3 = *(_BYTE *)(a1 + 2236);
  *(void *)((char *)&dataIn + 4) = 0LL;
  HIDWORD(dataIn) = 0;
  *a2 = 0LL;
  a2[1] = 0LL;
  if ((v3 & 2) != 0) {
    __int128 dataIn = *(_OWORD *)(a1 + 464);
  }
  else {
    LODWORD(dataIn) = *(_DWORD *)(a1 + 476);
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(a1 + 224));
  size_t dataOutMoved = 0LL;
  if (CCCryptorUpdate(*(CCCryptorRef *)(v4 + 80), &dataIn, 0x10uLL, a2, 0x10uLL, &dataOutMoved))
  {
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "aes_encrypt_cbc";
    signed int v6 = "%{public}s CCCryptorUpdate";
    int v7 = v5;
    uint32_t v8 = 12;
    goto LABEL_10;
  }

  if (dataOutMoved != 16)
  {
    int v9 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v13 = "aes_encrypt_cbc";
      __int16 v14 = 2048;
      size_t v15 = dataOutMoved;
      signed int v6 = "%{public}s out_moved is %lu";
      int v7 = v9;
      uint32_t v8 = 22;
LABEL_10:
      _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    }
  }

void tcp_init(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 328) & 0x40) != 0) {
    return;
  }
  *(_BYTE *)(a1 + 328) |= 0x40u;
  uint64_t v2 = sysctls;
  unsigned int v3 = *(_DWORD *)(sysctls + 240);
  *(void *)(a1 + 240) = v3 / 0xF4240uLL;
  *(_DWORD *)(a1 + 248) = v3 % 0xF4240;
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(v2 + 244);
  arc4random_buf(&__buf, 0x10uLL);
  if (CCCryptorCreate(0, 0, 2u, &__buf, 0x10uLL, 0LL, (CCCryptorRef *)(a1 + 80)))
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      char v21 = "aes_encrypt_key128";
      _os_log_impl(&dword_1879E5000, v4, OS_LOG_TYPE_ERROR, "%{public}s CCCryptorCreate", buf, 0xCu);
    }
  }

  uint64_t v5 = *(void **)(a1 + 72);
  v5[3] = tcp_itimer;
  v5[4] = a1 + 104;
  v5[2] = tcp_gc;
  *(void *)(a1 + 112) = 0LL;
  *(_DWORD *)(a1 + 324) = 128;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 120) = a1 + 112;
  signed int v6 = (void *)(a1 + 112);
  do
  {
    signed int v6 = (void *)*v6;
    if (!v6)
    {
      *uint64_t v5 = 0LL;
      v5[1] = a1 + 112;
      *(void *)(a1 + 112) = v5;
      *(void *)(a1 + 120) = v5;
      goto LABEL_18;
    }
  }

  while (v6 != v5);
  __nwlog_obj();
  ____int128 buf = 136446466;
  int v23 = "in_pcbinfo_attach";
  __int16 v24 = 2048;
  int v25 = v5;
  int v7 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      uint32_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0])) {
        goto LABEL_16;
      }
      ____int128 buf = 136446466;
      int v23 = "in_pcbinfo_attach";
      __int16 v24 = 2048;
      int v25 = v5;
      uint64_t v10 = "%{public}s ipi %p already in the list";
    }

    else
    {
      uint32_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = buf[0];
      if (!os_log_type_enabled(v8, (os_log_type_t)buf[0])) {
        goto LABEL_16;
      }
      ____int128 buf = 136446466;
      int v23 = "in_pcbinfo_attach";
      __int16 v24 = 2048;
      int v25 = v5;
      uint64_t v10 = "%{public}s ipi %p already in the list, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v8, v9, v10, (uint8_t *)&__buf, 0x16u);
  }

LABEL_16:
  if (v7) {
    free(v7);
  }
LABEL_18:
  int v11 = malloc(8uLL);
  if (v11) {
    *int v11 = 32LL;
  }
  *(void *)(a1 + 40) = v11;
  int v12 = malloc(8uLL);
  if (v12)
  {
    *int v12 = 48LL;
    *(void *)(a1 + 48) = v12;
    uint64_t v13 = malloc(8uLL);
    if (v13) {
      void *v13 = 24LL;
    }
    *(void *)(a1 + 56) = v13;
    __int16 v14 = malloc(8uLL);
    if (v14) {
      *__int16 v14 = 88LL;
    }
    *(void *)(a1 + 128) = 0LL;
    uint64_t v15 = a1 + 128;
    *(void *)(v15 - 64) = v14;
    *(void *)(v15 + 8) = v15;
    *(_OWORD *)(v15 + 128) = 0u;
    *(_OWORD *)(v15 + 144) = 0u;
    *(_OWORD *)(v15 + 160) = 0u;
    *(void *)(v15 + 176) = 0LL;
    return;
  }

  *(void *)(a1 + 48) = 0LL;
  __nwlog_obj();
  ____int128 buf = 136446210;
  int v23 = "tcp_init";
  uint64_t v16 = (void *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  if (__nwlog_fault())
  {
    if (buf[0] == 17)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0])) {
        goto LABEL_33;
      }
      ____int128 buf = 136446210;
      int v23 = "tcp_init";
      __int16 v19 = "%{public}s failed allocating tcp_reass_zone";
    }

    else
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = buf[0];
      if (!os_log_type_enabled(v17, (os_log_type_t)buf[0])) {
        goto LABEL_33;
      }
      ____int128 buf = 136446210;
      int v23 = "tcp_init";
      __int16 v19 = "%{public}s failed allocating tcp_reass_zone, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v17, v18, v19, (uint8_t *)&__buf, 0xCu);
  }

LABEL_33:
  if (v16) {
    free(v16);
  }
}

    if ((*(void *)(v2 + 48) & 1LL) != 0) {
      __int16 v19 = v5 | 1;
    }
    else {
      __int16 v19 = v5;
    }
    *(void *)(v2 + 48) = v19;
    if (!v5) {
      goto LABEL_37;
    }
    goto LABEL_29;
  }

  if (!v2)
  {
    uint64_t v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    os_log_type_t v17 = a2[6] & 1LL;
    uint64_t v2 = a2[4];
    goto LABEL_33;
  }

  do
  {
    unsigned int v3 = v2;
    uint64_t v2 = *(void *)(v2 + 32);
  }

  while (v2);
  uint64_t v2 = *(void *)(v3 + 40);
  uint64_t v4 = *(void *)(v3 + 48);
  uint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  if (v2)
  {
    if ((*(void *)(v2 + 48) & 1LL) != 0) {
      signed int v6 = v4 | 1;
    }
    else {
      signed int v6 = v4 & 0xFFFFFFFFFFFFFFFELL;
    }
    *(void *)(v2 + 48) = v6;
  }

  int v7 = a1;
  if (v5)
  {
    int v7 = (unint64_t *)(v5 + 32);
    if (*(void *)(v5 + 32) != v3) {
      int v7 = (unint64_t *)(v5 + 40);
    }
  }

  uint32_t v8 = v4 & 1;
  *int v7 = v2;
  if ((void *)(*(void *)(v3 + 48) & 0xFFFFFFFFFFFFFFFELL) == a2) {
    uint64_t v5 = v3;
  }
  os_log_type_t v9 = a2[6];
  *(_OWORD *)(v3 + 32) = *((_OWORD *)a2 + 2);
  *(void *)(v3 + 48) = v9;
  uint64_t v10 = a1;
  int v11 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
  if (v11)
  {
    uint64_t v13 = *(void **)(v11 + 32);
    int v12 = (unint64_t *)(v11 + 32);
    if (v13 == a2) {
      uint64_t v10 = v12;
    }
    else {
      uint64_t v10 = v12 + 1;
    }
  }

  *uint64_t v10 = v3;
  uint64_t v15 = a2[4];
  __int16 v14 = a2[5];
  if ((*(void *)(v15 + 48) & 1LL) != 0) {
    uint64_t v16 = v3 | 1;
  }
  else {
    uint64_t v16 = v3;
  }
  *(void *)(v15 + 48) = v16;
  if (v14)
  {
    if ((*(void *)(v14 + 48) & 1LL) != 0) {
      v3 |= 1uLL;
    }
    *(void *)(v14 + 48) = v3;
  }

  if (v8) {
    return a2;
  }
LABEL_41:
  while (1)
  {
    char v20 = (void *)v2;
    uint64_t v2 = v5;
    if (v20)
    {
      char v21 = v20[6];
      if ((v21 & 1) != 0) {
        break;
      }
    }

    nw_protocol_definition_t v22 = *a1;
    if (v20 == (void *)*a1) {
      goto LABEL_127;
    }
    int v23 = *(void *)(v2 + 32);
    if ((void *)v23 == v20)
    {
      int v23 = *(void *)(v2 + 40);
      unsigned int v30 = *(void *)(v23 + 48);
      if ((v30 & 1) != 0)
      {
        *(void *)(v23 + 48) = v30 & 0xFFFFFFFFFFFFFFFELL;
        os_log_type_t v31 = *(void *)(v2 + 48) | 1LL;
        uint32_t v32 = *(void **)(v23 + 32);
        *(void *)(v2 + 40) = v32;
        *(void *)(v2 + 48) = v31;
        if (v32)
        {
          if ((v32[6] & 1LL) != 0) {
            __int16 v33 = v2 | 1;
          }
          else {
            __int16 v33 = v2;
          }
          v32[6] = v33;
          os_log_type_t v31 = *(void *)(v2 + 48);
        }

        *(void *)(v23 + 48) = v31 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1LL;
        if ((v31 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          unsigned int v34 = *(void *)(v2 + 48);
          os_log_type_t v35 = v34 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(void *)((v34 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(void *)(v35 + 32) = v23;
          }

          else
          {
            *(void *)(v35 + 40) = v23;
            uint32_t v32 = *(void **)(v2 + 40);
          }
        }

        else
        {
          *a1 = v23;
          unsigned int v34 = *(void *)(v2 + 48);
          nw_protocol_definition_t v22 = v23;
        }

        *(void *)(v23 + 32) = v2;
        if ((v34 & 1) != 0) {
          v23 |= 1uLL;
        }
        *(void *)(v2 + 48) = v23;
        int v23 = (unint64_t)v32;
      }

      int v40 = *(void *)(v23 + 32);
      if (v40)
      {
        uint64_t v41 = *(void *)(v40 + 48);
        if ((v41 & 1) != 0)
        {
          uint64_t v42 = *(void *)(v23 + 40);
          if (!v42 || (*(_BYTE *)(v42 + 48) & 1) == 0)
          {
            *(void *)(v40 + 48) = v41 & 0xFFFFFFFFFFFFFFFELL;
            uint64_t v48 = *(void *)(v23 + 48) | 1LL;
            *(void *)(v23 + 48) = v48;
            uint64_t v49 = *(void *)(v40 + 40);
            *(void *)(v23 + 32) = v49;
            if (v49)
            {
              if ((*(void *)(v49 + 48) & 1LL) != 0) {
                int v50 = v23 | 1;
              }
              else {
                int v50 = v23;
              }
              *(void *)(v49 + 48) = v50;
              uint64_t v48 = *(void *)(v23 + 48);
            }

            *(void *)(v40 + 48) = v48 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v40 + 48) & 1LL;
            if ((v48 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              int v51 = *(void *)(v23 + 48);
              int v52 = v51 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(void *)((v51 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
                *(void *)(v52 + 32) = v40;
              }
              else {
                *(void *)(v52 + 40) = v40;
              }
            }

            else
            {
              *a1 = v40;
              int v51 = *(void *)(v23 + 48);
              nw_protocol_definition_t v22 = v40;
            }

            *(void *)(v40 + 40) = v23;
            if ((v51 & 1) != 0) {
              v40 |= 1uLL;
            }
            *(void *)(v23 + 48) = v40;
            int v23 = *(void *)(v2 + 40);
            uint64_t v42 = *(void *)(v23 + 40);
          }

  *(_DWORD *)(v1 + 740) &= ~0x1000u;
  *(_DWORD *)(v1 + 928) = 0;
  *(_DWORD *)(v1 + 936) = 0;
  return result;
}

void tcp_respond( uint64_t a1, __int128 *a2, uint64_t a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7)
{
  char v8 = a6;
  uint64_t v118 = *MEMORY[0x1895F89C0];
  uint64_t v13 = *(void *)(a1 + 80);
  uint64_t v14 = *(void *)(v13 + 224);
  uint64_t v15 = *(void *)(v14 + 24);
  uint64_t v16 = *(void *)(v15 + 32);
  char v93 = *(_BYTE *)(v13 + 2236);
  if ((a6 & 4) != 0)
  {
    int v18 = 0;
  }

  else
  {
    int v17 = tcp_sbspace(a1);
    if (v17 >= 0xFFFF << *(_BYTE *)(a1 + 261)) {
      int v18 = 0xFFFF << *(_BYTE *)(a1 + 261);
    }
    else {
      int v18 = v17;
    }
    uint64_t v15 = *(void *)(v14 + 24);
  }

  v98[0] = 0LL;
  v98[1] = v98;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)(v16 + 24)
                                                                                             + 88LL))( v16,  v15,  20LL,  20LL,  1LL,  v98))
  {
    int v91 = v18;
    uint64_t v19 = v98[0];
    if (v98[0])
    {
      uint64_t v89 = a7;
      uint64_t v20 = *(void *)(v98[0] + 112LL);
      char v21 = (void *)MEMORY[0x189608EF8];
      if (v20)
      {
        unsigned int v86 = a5;
        unsigned int v87 = a4;
        if ((*(_WORD *)(v98[0] + 204LL) & 0x100) == 0 || !*MEMORY[0x189608EF8])
        {
          uint64_t v88 = (unsigned int *)(v98[0] + 56LL);
          uint64_t v23 = v20 + *(unsigned int *)(v98[0] + 56LL);
LABEL_24:
          __int128 v26 = *a2;
          *(_DWORD *)(v23 + 16) = *((_DWORD *)a2 + 4);
          *(_OWORD *)uint64_t v23 = v26;
          if ((*(_WORD *)(v19 + 204) & 0x80) != 0) {
            *(_WORD *)(v19 + 196) -= 20;
          }
          int v27 = *(_DWORD *)(v19 + 52);
          unsigned int v28 = *(_DWORD *)(v19 + 56) + 20;
          int v29 = *(_DWORD *)(v19 + 60);
          if (v28 <= v27 - v29)
          {
            *uint64_t v88 = v28;
            __int16 v33 = v88;
            uint32_t v32 = (void *)MEMORY[0x189608EF8];
            if (!v27) {
              goto LABEL_56;
            }
          }

          else
          {
            unsigned int v30 = (os_log_s *)__nwlog_obj();
            BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
            int v27 = *(_DWORD *)(v19 + 52);
            if (v31)
            {
              *(_DWORD *)__int128 buf = 136446978;
              int v102 = "__nw_frame_claim_internal";
              __int16 v103 = 1024;
              *(_DWORD *)int v104 = v28;
              *(_WORD *)&v104[4] = 1024;
              *(_DWORD *)&v104[6] = v27;
              *(_WORD *)__int16 v105 = 1024;
              *(_DWORD *)&v105[2] = v29;
              _os_log_impl( &dword_1879E5000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
              int v27 = *(_DWORD *)(v19 + 52);
            }

            uint32_t v32 = (void *)MEMORY[0x189608EF8];
            __int16 v33 = v88;
            if (!v27)
            {
LABEL_56:
              if ((*(_WORD *)(v19 + 204) & 0x80) != 0) {
                *(_WORD *)(v19 + 196) += 20;
              }
              if (*v33 > 0x13)
              {
                *v33 -= 20;
              }

              else
              {
                int v52 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                {
                  unsigned int v53 = *v33;
                  *(_DWORD *)__int128 buf = 136446722;
                  int v102 = "__nw_frame_unclaim_internal";
                  __int16 v103 = 1024;
                  *(_DWORD *)int v104 = 20;
                  *(_WORD *)&v104[4] = 1024;
                  *(_DWORD *)&v104[6] = v53;
                  _os_log_impl( &dword_1879E5000,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s Frame cannot unclaim %u start bytes (has %u left)",  buf,  0x18u);
                }
              }

              if (a3)
              {
                HIDWORD(v54) = *(_DWORD *)v23;
                LODWORD(v54) = *(_DWORD *)v23;
                *(_DWORD *)uint64_t v23 = v54 >> 16;
                uint64_t v55 = v89;
                if (!v89) {
                  goto LABEL_68;
                }
              }

              else
              {
                char v8 = 16;
                uint64_t v55 = v89;
                if (!v89) {
                  goto LABEL_68;
                }
              }

              if ((*(_BYTE *)(v55 + 4) & 0x10) != 0) {
                *(_WORD *)(v19 + 204) |= 0x8000u;
              }
LABEL_68:
              *(_DWORD *)(v23 + 4) = bswap32(v86);
              *(_DWORD *)(v23 + 8) = bswap32(v87);
              *(_BYTE *)(v23 + 12) = 80;
              *(_BYTE *)(v23 + 13) = v8;
              *(_WORD *)(v23 + 14) = bswap32(v91 >> *(_BYTE *)(a1 + 261)) >> 16;
              *(_WORD *)(v23 + 18) = 0;
              if ((v93 & 2) != 0) {
                __int16 v56 = in6_pseudo();
              }
              else {
                __int16 v56 = in_pseudo();
              }
              *(_WORD *)(v23 + 16) = v56;
              int v57 = in_finalize_cksum();
              if (v57
                && (*(_WORD *)(v19 + 204) & 0x100) != 0
                && *v32
                && (((uint64_t (*)(uint64_t, void))*v32)(v19, *(void *)(v19 + 88)) & 1) == 0)
              {
                *(void *)(a1 + 1056) = 0LL;
                int v57 = 6;
                if ((*(_BYTE *)(v14 + 828) & 2) == 0)
                {
LABEL_84:
                  int v63 = (os_log_s *)__nwlog_tcp_log();
                  if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
                  {
                    uint64_t v64 = strerror(v57);
                    *(_DWORD *)__int128 buf = 136446722;
                    int v102 = "tcp_respond";
                    __int16 v103 = 2082;
                    *(void *)int v104 = v14 + 604;
                    *(_WORD *)&v104[8] = 2080;
                    *(void *)__int16 v105 = v64;
                    _os_log_impl( &dword_1879E5000,  v63,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s failed to finalize checksum, %s",  buf,  0x20u);
                  }
                }

LABEL_94:
                (*(void (**)(uint64_t, void *))(*(void *)(v16 + 24) + 96LL))(v16, v98);
                return;
              }

              int v58 = *(_DWORD *)(v19 + 52);
              if (v58)
              {
                uint64_t v59 = (v58 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60)));
                uint64_t v60 = *(void *)(a1 + 1056);
                if (!v60) {
                  goto LABEL_82;
                }
              }

              else
              {
                uint64_t v59 = 0LL;
                uint64_t v60 = *(void *)(a1 + 1056);
                if (!v60) {
                  goto LABEL_82;
                }
              }

              uint64_t v61 = 144LL;
              uint64_t v62 = 136LL;
              if ((v93 & 2) == 0) {
                uint64_t v62 = 120LL;
              }
              ++*(void *)(v60 + v62);
              if ((v93 & 2) == 0) {
                uint64_t v61 = 128LL;
              }
              *(void *)(v60 + v61) += v59;
LABEL_82:
              if (v57)
              {
                if ((*(_BYTE *)(v14 + 828) & 2) == 0) {
                  goto LABEL_84;
                }
                goto LABEL_94;
              }

              uint64_t v65 = *(void *)(*(void *)(a1 + 80) + 224LL);
              int v66 = *(_DWORD *)(v65 + 600);
              int v97 = 0;
              set_frame_service_class(v19, v65, v66, (v93 & 2) >> 1, &v97);
              int v67 = v97;
              *(_DWORD *)(v19 + 176) = v97;
              if (!__nwlog_is_datapath_logging_enabled())
              {
LABEL_89:
                if (*MEMORY[0x189608EE0] != -1LL) {
                  dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_83);
                }
                if (*MEMORY[0x189608ED8] && kdebug_is_enabled())
                {
                  nw_frame_array_unclaimed_length();
                  kdebug_trace();
                }

                goto LABEL_94;
              }

              int v69 = *(_DWORD *)(v19 + 52);
              if (v69) {
                int v70 = v69 - (*(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60));
              }
              else {
                int v70 = 0;
              }
              uint64_t v71 = *(void *)(v19 + 112);
              if (v71)
              {
                if ((*(_WORD *)(v19 + 204) & 0x100) == 0 || !*MEMORY[0x189608EF8])
                {
                  uint64_t v72 = *v88;
                  goto LABEL_115;
                }

                if (((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v19, *(void *)(v19 + 88)))
                {
                  uint64_t v71 = *(void *)(v19 + 112);
                  if (v71)
                  {
                    uint64_t v72 = *(unsigned int *)(v19 + 56);
LABEL_115:
                    BOOL v73 = (unsigned __int16 *)(v71 + v72);
                    if ((*(_BYTE *)(v14 + 828) & 2) == 0)
                    {
                      if (__nwlog_is_datapath_logging_enabled())
                      {
                        uint64_t v74 = (os_log_s *)__nwlog_tcp_log();
                        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                        {
                          unsigned int v75 = bswap32(*v73) >> 16;
                          unsigned int v76 = bswap32(v73[1]) >> 16;
                          int v77 = *((unsigned __int8 *)v73 + 13);
                          unsigned int v78 = *((_DWORD *)v73 + 2);
                          unsigned int v79 = bswap32(*((_DWORD *)v73 + 1));
                          unsigned int v90 = bswap32(v78);
                          int v92 = v77;
                          int v94 = *(_DWORD *)(a1 + 120);
                          int v96 = *(_DWORD *)(a1 + 92);
                          int v80 = *(_DWORD *)(a1 + 12);
                          __int16 v81 = packet_service_class_to_str(v67);
                          *(_DWORD *)__int128 buf = 136449026;
                          int v102 = "tcp_respond";
                          __int16 v103 = 2082;
                          *(void *)int v104 = v14 + 604;
                          *(_WORD *)&v104[8] = 1024;
                          *(_DWORD *)__int16 v105 = v75;
                          *(_WORD *)&v105[4] = 1024;
                          *(_DWORD *)&v105[6] = v76;
                          LOWORD(v106) = 1024;
                          *(_DWORD *)((char *)&v106 + 2) = v70;
                          HIWORD(v106) = 1024;
                          *(_DWORD *)__int16 v107 = v92;
                          *(_WORD *)&v107[4] = 1024;
                          *(_DWORD *)&v107[6] = v79;
                          __int16 v108 = 1024;
                          unsigned int v109 = v90;
                          __int16 v110 = 1024;
                          int v111 = v94;
                          __int16 v112 = 1024;
                          int v113 = v96;
                          __int16 v114 = 1024;
                          int v115 = v80;
                          __int16 v116 = 2082;
                          __int16 v117 = v81;
                          _os_log_impl( &dword_1879E5000,  v74,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sending frame, %u:%u tlen %u, flags %#x, seq %u, ack %u, rcv_nxt %u sn d_una %u state %u svc %{public}s",  buf,  0x56u);
                        }
                      }
                    }

                    goto LABEL_89;
                  }
                }
              }

              if ((*(_WORD *)(v19 + 204) & 0x100) != 0
                && *MEMORY[0x189608EF8]
                && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v19, *(void *)(v19 + 88)) & 1) == 0)
              {
                *(void *)(a1 + 1056) = 0LL;
              }

              goto LABEL_89;
            }
          }

          uint64_t v35 = *(unsigned int *)(v19 + 56);
          size_t v34 = *(unsigned int *)(v19 + 60);
          uint64_t v36 = (v27 - (v34 + v35));
          if (v27 == (_DWORD)v34 + (_DWORD)v35) {
            goto LABEL_56;
          }
          if ((_DWORD)v34)
          {
            uint64_t v37 = *(void *)(v19 + 112);
            if (v37)
            {
              memmove((void *)(v37 + v35), (const void *)(v37 + v35 + v36), v34);
              int v27 = *(_DWORD *)(v19 + 52);
            }
          }

          *(_DWORD *)(v19 + 52) = v27 - v36;
          if ((*(_WORD *)(v19 + 204) & 0x80) == 0) {
            goto LABEL_56;
          }
          unsigned int v38 = *(unsigned __int16 *)(v19 + 196);
          BOOL v39 = v38 >= v36;
          unsigned int v40 = v38 - v36;
          *(_WORD *)(v19 + 196) = v40;
          if (v39 && v40 < 0x10000) {
            goto LABEL_56;
          }
          __nwlog_obj();
          uint64_t v41 = *(unsigned __int16 *)(v19 + 196);
          *(_DWORD *)__int128 buf = 136446978;
          int v102 = "__nw_frame_collapse";
          __int16 v103 = 2082;
          *(void *)int v104 = "frame->aggregate_buffer_length";
          *(_WORD *)&v104[8] = 2048;
          *(void *)__int16 v105 = v36;
          *(_WORD *)&v105[8] = 2048;
          uint64_t v106 = v41;
          uint64_t v42 = _os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v99 = 0;
          __int16 v85 = (void *)v42;
          if (__nwlog_fault())
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              uint64_t v43 = (os_log_s *)__nwlog_obj();
              os_log_type_t log = type;
              if (os_log_type_enabled(v43, type))
              {
                uint64_t v44 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)__int128 buf = 136446978;
                int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)__int16 v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v44;
                __int16 v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_51:
                int v50 = v43;
                os_log_type_t v51 = log;
LABEL_52:
                _os_log_impl(&dword_1879E5000, v50, v51, v45, buf, 0x2Au);
              }
            }

            else if (v99)
            {
              backtrace_string = (void *)__nw_create_backtrace_string();
              loga = (os_log_s *)__nwlog_obj();
              os_log_type_t v82 = type;
              BOOL v47 = os_log_type_enabled(loga, type);
              if (backtrace_string)
              {
                if (v47)
                {
                  uint64_t v48 = *(unsigned __int16 *)(v19 + 196);
                  *(_DWORD *)__int128 buf = 136447234;
                  int v102 = "__nw_frame_collapse";
                  __int16 v103 = 2082;
                  *(void *)int v104 = "frame->aggregate_buffer_length";
                  *(_WORD *)&v104[8] = 2048;
                  *(void *)__int16 v105 = v36;
                  *(_WORD *)&v105[8] = 2048;
                  uint64_t v106 = v48;
                  *(_WORD *)__int16 v107 = 2082;
                  *(void *)&v107[2] = backtrace_string;
                  _os_log_impl( &dword_1879E5000,  loga,  v82,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(backtrace_string);
                goto LABEL_53;
              }

              if (v47)
              {
                uint64_t v68 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)__int128 buf = 136446978;
                int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)__int16 v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v68;
                __int16 v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                int v50 = loga;
                os_log_type_t v51 = v82;
                goto LABEL_52;
              }
            }

            else
            {
              uint64_t v43 = (os_log_s *)__nwlog_obj();
              os_log_type_t log = type;
              if (os_log_type_enabled(v43, type))
              {
                uint64_t v49 = *(unsigned __int16 *)(v19 + 196);
                *(_DWORD *)__int128 buf = 136446978;
                int v102 = "__nw_frame_collapse";
                __int16 v103 = 2082;
                *(void *)int v104 = "frame->aggregate_buffer_length";
                *(_WORD *)&v104[8] = 2048;
                *(void *)__int16 v105 = v36;
                *(_WORD *)&v105[8] = 2048;
                uint64_t v106 = v49;
                __int16 v45 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_51;
              }
            }
          }

    if (v41) {
      free(v41);
    }
LABEL_78:
    *(void *)(v39 + 1056) = 0LL;
LABEL_79:
    tcp_drop(v39, 53);
    return 0LL;
  }

  if (v8)
  {
    *(void *)(v8 + 40) = type;
    unsigned int v28 = (os_log_type_t *)a2[1];
    *(void *)os_log_type_t type = v8;
    __int16 v56 = v28;
    *a2 = 0LL;
    a2[1] = (uint64_t)a2;
  }

  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(void *)(a1 + 328) = 0LL;
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 308) = 16;
  if (*(_WORD *)(a1 + 754))
  {
    *(_WORD *)(a1 + 754) = 0;
    *(_DWORD *)(a1 + 744) = 0;
  }

  os_log_type_t v51 = *(_DWORD *)(v46 + 4);
  int v52 = *(_DWORD *)(a1 + 120);
  if (v51 != v52)
  {
    unsigned int v53 = *(_DWORD *)(v192 + 492);
    if (v53 >= 0x19000) {
      unint64_t v54 = v53 >> 10;
    }
    else {
      unint64_t v54 = 100;
    }
    if (v54 >= *(_DWORD *)(sysctls + 72) >> 10) {
      LOWORD(v54) = *(_DWORD *)(sysctls + 72) >> 10;
    }
    uint64_t v55 = (unsigned __int16)v54;
    if (*(unsigned __int16 *)(a1 + 224) + 1 >= (unsigned __int16)v54)
    {
      uint64_t v71 = *(void *)(a1 + 1056);
      if (v71) {
        ++*(void *)(v71 + 232);
      }
      if ((*(_BYTE *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v163 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v164 = (const char *)(v192 + 604);
            v165 = *(_DWORD *)(v46 + 4);
            uint64_t v166 = *(_DWORD *)(a1 + 120);
            if (!v192) {
              os_log_type_t v164 = "";
            }
            v167 = *(unsigned __int16 *)(a1 + 224);
            *(_DWORD *)__int128 buf = 136447490;
            __int16 v195 = "tcp_reass";
            v196 = 2082;
            *(void *)uint64_t v197 = v164;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)v198 = v165;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v166;
            *(_WORD *)v199 = 1024;
            *(_DWORD *)&v199[2] = v167;
            v200 = 1024;
            v201 = v55;
            _os_log_impl( &dword_1879E5000,  v163,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s drop due to limit: seq %u rcv_nxt %u reqssqlen %u qlimit %u",  buf,  0x2Eu);
          }
        }
      }

      uint64_t v72 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
      if (v72)
      {
        BOOL v73 = *(void *)(v33 + 88);
        *(void *)(v33 + 80) = 0LL;
        *(void *)(v33 + 88) = 0LL;
        v72(v33, 1LL, v73);
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v195 = "__nw_frame_finalize";
        v168 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          uint64_t v172 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            __int16 v195 = "__nw_frame_finalize";
            _os_log_impl( &dword_1879E5000,  v172,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        if (v168) {
          free(v168);
        }
      }

      uint64_t result = 0LL;
      *v191 = 0;
      return result;
    }
  }

  __int16 v56 = malloc(**(void **)(v188 + 48));
  if (!v56)
  {
    int v66 = *(void *)(a1 + 1056);
    if (v66) {
      ++*(void *)(v66 + 232);
    }
    if ((*(_BYTE *)(v192 + 828) & 2) == 0)
    {
      int v67 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      {
        uint64_t v68 = "";
        if (v192) {
          uint64_t v68 = (const char *)(v192 + 604);
        }
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v195 = "tcp_reass";
        v196 = 2082;
        *(void *)uint64_t v197 = v68;
        _os_log_impl( &dword_1879E5000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s couldn't allocate memory for tcp_reass_zone",  buf,  0x16u);
      }
    }

    int v69 = *(void (**)(uint64_t, uint64_t, uint64_t))(v33 + 80);
    if (v69)
    {
      int v70 = *(void *)(v33 + 88);
      *(void *)(v33 + 80) = 0LL;
      *(void *)(v33 + 88) = 0LL;
      v69(v33, 1LL, v70);
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v195 = "__nw_frame_finalize";
      __int16 v162 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v171 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v195 = "__nw_frame_finalize";
          _os_log_impl( &dword_1879E5000,  v171,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      if (v162) {
        free(v162);
      }
    }

    return 0LL;
  }

  ++*(_WORD *)(a1 + 224);
  int v57 = *(void **)a1;
  v189 = v56;
  if (!*(void *)a1)
  {
    uint64_t v62 = 0LL;
    int v63 = 0;
    v187 = 1;
    int v58 = v182;
    uint64_t v59 = v185;
    uint64_t v61 = type;
    uint64_t v60 = v184;
    goto LABEL_129;
  }

  int v58 = v182;
  uint64_t v59 = v185;
  uint64_t v61 = type;
  uint64_t v60 = v184;
  if (*(_DWORD *)(v57[3] + 4LL) - v51 > 0)
  {
    uint64_t v62 = 0LL;
    int v63 = 0;
    v187 = 1;
    goto LABEL_129;
  }

  do
  {
    uint64_t v62 = v57;
    int v57 = (void *)*v57;
  }

  while (v57 && *(_DWORD *)(v57[3] + 4LL) - v51 < 1);
  uint64_t v64 = (*((_DWORD *)v62 + 4) + *(_DWORD *)(v62[3] + 4LL) - v51);
  if ((int)v64 < 1)
  {
    v187 = 0;
    int v63 = 0;
    goto LABEL_129;
  }

  if ((_DWORD)v64 == 1)
  {
    int v63 = 0;
    uint64_t v65 = v191;
  }

  else
  {
    *(_DWORD *)(a1 + 940) = v51;
    uint64_t v65 = v191;
    __int16 v105 = *v191;
    if (v64 < v105) {
      LODWORD(v105) = v64;
    }
    *(_DWORD *)(a1 + 944) = v105 + v51;
    int v63 = 1;
  }

  uint64_t v106 = *v65;
  if ((int)v64 >= (int)v106)
  {
    __int16 v112 = *(void *)(a1 + 1056);
    if (v112)
    {
      int v113 = *(void *)(v112 + 216) + v106;
      ++*(void *)(v112 + 208);
      *(void *)(v112 + 216) = v113;
    }

    __int16 v114 = *(void **)(v182 + 248);
    ++*v114;
    int v115 = v56;
    if (v184)
    {
      ++**(void **)(v182 + 256);
      if (!type) {
        goto LABEL_206;
      }
    }

    else if (!type)
    {
LABEL_206:
      if (!v185) {
        goto LABEL_208;
      }
      goto LABEL_207;
    }

    ++**(void **)(v182 + 264);
    if (!v185)
    {
LABEL_208:
      v114[1] += v106;
      if (v184)
      {
        *(void *)(*(void *)(v182 + 256) + 8LL) += v106;
        if (!type) {
          goto LABEL_210;
        }
      }

      else if (!type)
      {
LABEL_210:
        if (!v185) {
          goto LABEL_212;
        }
        goto LABEL_211;
      }

      *(void *)(*(void *)(v182 + 264) + 8LL) += v106;
      if (!v185)
      {
LABEL_212:
        *(_DWORD *)(a1 + 704) += v106;
        if (*(void *)(v192 + 24))
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 48) += *v65;
          }
        }

        if ((*(_BYTE *)(v192 + 828) & 2) == 0)
        {
          if (__nwlog_is_datapath_logging_enabled())
          {
            v173 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
            {
              v174 = (const char *)(v192 + 604);
              v175 = *(_DWORD *)(v62[3] + 4LL);
              if (!v192) {
                v174 = "";
              }
              v176 = *((_DWORD *)v62 + 4);
              unsigned int v177 = *(_DWORD *)(v46 + 4);
              *(_DWORD *)__int128 buf = 136447234;
              __int16 v195 = "tcp_reass";
              v196 = 2082;
              *(void *)uint64_t v197 = v174;
              *(_WORD *)&v197[8] = 1024;
              *(_DWORD *)v198 = v175;
              *(_WORD *)&v198[4] = 1024;
              *(_DWORD *)&v198[6] = v176;
              *(_WORD *)v199 = 1024;
              *(_DWORD *)&v199[2] = v177;
              _os_log_impl( &dword_1879E5000,  v173,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s It's a duplicate segment: tqe_seq %u tqe_len %u th_seq %u",  buf,  0x28u);
            }
          }
        }

        __int16 v117 = *(void (**)(uint64_t, uint64_t, uint64_t))(v190 + 80);
        if (v117)
        {
          uint64_t v118 = *(void *)(v190 + 88);
          *(void *)(v190 + 80) = 0LL;
          *(void *)(v190 + 88) = 0LL;
          v117(v190, 1LL, v118);
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v195 = "__nw_frame_finalize";
          uint64_t v178 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            uint64_t v180 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              __int16 v195 = "__nw_frame_finalize";
              _os_log_impl( &dword_1879E5000,  v180,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v178) {
            free(v178);
          }
          size_t v34 = a1;
          int v115 = v189;
        }

        free(v115);
        --*(_WORD *)(v34 + 224);
        goto LABEL_259;
      }

uint64_t tcp_sbspace(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(*(void *)(a1 + 80) + 224LL);
  unsigned int v3 = v2 + 122;
  int v4 = *(_DWORD *)(a1 + 196);
  unsigned int v5 = v2[123];
  if (*(_DWORD *)(sysctls + 40) != 1
    && (v2[92] & 0x4000) == 0
    && *(_DWORD *)(sysctls + 68) == 1
    && !(*(_DWORD *)(a1 + 88) & 0x80000 | v2[92] & 0x40))
  {
    int v6 = 16 * v4;
    if (v5 - *v3 < 16 * v4)
    {
      unsigned int v7 = *(_DWORD *)(sysctls + 72);
      if (v5 < v7)
      {
        int v8 = v2[135];
        if (v8 && v5 <= v8 + v6)
        {
          if (v5 + v6 >= v7) {
            unsigned int v10 = *(_DWORD *)(sysctls + 72);
          }
          else {
            unsigned int v10 = v5 + v6;
          }
          sbreserve((uint64_t)(v2 + 122), v10);
          unsigned int v5 = v2[123];
          int v4 = *(_DWORD *)(a1 + 196);
        }
      }
    }
  }

  uint64_t result = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
  if ((int)result >= v4 && (*(_BYTE *)(a1 + 90) & 8) != 0)
  {
    int v12 = *(_DWORD *)(sysctls + 48);
    else {
      unsigned int v13 = (v5 - *v3) & ~((int)(v5 - *v3) >> 31);
    }
    if (v12 <= 0) {
      return result;
    }
    else {
      return v13;
    }
  }

  return result;
}

uint64_t ____nw_signpost_is_enabled_block_invoke_84()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x189608ED8] = result;
  return result;
}

double calculate_tcp_clock(uint64_t a1)
{
  uint64_t v2 = (_OWORD *)(a1 + 240);
  uint64_t v3 = *(void *)(a1 + 240);
  int v4 = *(_DWORD *)(a1 + 248);
  __int128 v19 = 0uLL;
  microuptime((uint64_t)&v19);
  unsigned int v6 = v4 + 1000;
  if (v4 >= -1000)
  {
    if (v6 <= 0xF423F) {
      goto LABEL_6;
    }
    int v7 = -1000000;
    uint64_t v8 = 1LL;
  }

  else
  {
    int v7 = 1000000;
    uint64_t v8 = -1LL;
  }

  v3 += v8;
  v6 += v7;
LABEL_6:
  uint64_t v9 = v19;
  BOOL v10 = (uint64_t)v19 <= v3;
  if ((void)v19 == v3) {
    BOOL v10 = SDWORD2(v19) <= (int)v6;
  }
  if (!v10)
  {
    *(void *)a1 = v19;
    uint64_t v11 = *(void *)(a1 + 240);
    BOOL v12 = v11 < v9;
    if (v11 == v9) {
      BOOL v12 = *(_DWORD *)(a1 + 248) < SDWORD2(v19);
    }
    if (v12)
    {
      microuptime((uint64_t)&v19);
      uint64_t v13 = v19 - *(void *)(a1 + 240);
      int v14 = DWORD2(v19) - *(_DWORD *)(a1 + 248);
      if (v14 < 0)
      {
        int v15 = 1000000;
        int v16 = -1;
      }

      else
      {
        if (v14 <= 0xF423F)
        {
LABEL_18:
          int v17 = v14 / 1000 + 1000 * v13;
          unsigned int v18 = v14 % 1000 + *(_DWORD *)(a1 + 320);
          if (v18 >= 0x3E8) {
            v17 += v18 / 0x3E8;
          }
          if (v17)
          {
            double result = *(double *)&v19;
            *uint64_t v2 = v19;
            *(_DWORD *)(a1 + 320) = v18 % 0x3E8;
            *(_DWORD *)(a1 + 316) += v17;
          }

          return result;
        }

        int v15 = -1000000;
        int v16 = 1;
      }

      LODWORD(v13) = v16 + v13;
      v14 += v15;
      goto LABEL_18;
    }
  }

  return result;
}

void tcp_drop(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224LL);
  if (*(int *)(a1 + 12) < 3)
  {
    uint64_t v8 = *(void *)(a1 + 1056);
    if (!v8) {
      goto LABEL_13;
    }
    int v7 = (void *)(v8 + 456);
    goto LABEL_12;
  }

  *(_DWORD *)(a1 + 12) = 0;
  if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      BOOL v10 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = tcpstates[*(int *)(a1 + 12)];
        int v14 = "tcp_drop";
        BOOL v12 = "";
        int v13 = 136446722;
        if (v4) {
          BOOL v12 = (const char *)(v4 + 604);
        }
        __int16 v15 = 2082;
        int v16 = v12;
        __int16 v17 = 2082;
        unsigned int v18 = v11;
        _os_log_impl( &dword_1879E5000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  (uint8_t *)&v13,  0x20u);
      }
    }
  }

  if (*(void *)(v4 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 0;
    }
  }

  tcp_output(a1);
  uint64_t v6 = *(void *)(a1 + 1056);
  if (v6)
  {
    int v7 = (void *)(v6 + 424);
LABEL_12:
    ++*v7;
  }

LABEL_13:
  if (a2 == 60)
  {
    int v9 = *(_DWORD *)(a1 + 256);
    if (!v9) {
      LOWORD(v9) = 60;
    }
    *(_WORD *)(v4 + 378) = v9;
    goto LABEL_18;
  }

  *(_WORD *)(v4 + 378) = a2;
  if (a2) {
LABEL_18:
  }
    user_north_signal_error(v4);
  tcp_close(a1);
}

      *(void *)(v12 + 64) = v13;
      int v13 = *(void **)(v3 + 64);
LABEL_39:
      void *v13 = v12;
      int v29 = *(void *)(v3 + 16);
      unsigned int v30 = *(void **)(v3 + 24);
      if (v29)
      {
        *(void *)(v29 + 24) = v30;
        unsigned int v30 = *(void **)(v3 + 24);
      }

      else
      {
        *(void *)(a1 + 1992) = v30;
      }

      *unsigned int v30 = v29;
      tcp_seg_sent_tree_head_RB_REMOVE(v32, (void *)v3);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(void *)(v3 + 80) = 0LL;
        *(_OWORD *)(v3 + 48) = 0u;
        *(_OWORD *)(v3 + 64) = 0u;
        *(_OWORD *)(v3 + 16) = 0u;
        *(_OWORD *)(v3 + 32) = 0u;
        *(_OWORD *)uint64_t v3 = 0u;
        uint64_t v6 = *(void **)(a1 + 2032);
        *(void *)(v3 + 80) = v6;
        *uint64_t v6 = v3;
        *(void *)(a1 + 2032) = v3 + 72;
        ++*(_DWORD *)(a1 + 2040);
        uint64_t v3 = v7;
        if (!v7) {
          return;
        }
      }

      else
      {
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
        free((void *)v3);
        uint64_t v3 = v7;
        if (!v7) {
          return;
        }
      }
    }
  }

  int v9 = *(void **)(a1 + 952);
  if (v9)
  {
    BOOL v10 = (void *)(a1 + 952);
    do
    {
      BOOL v12 = (void *)*v10;
      int v13 = (void *)(a1 + 952);
      if ((void *)*v10 != v9)
      {
        do
        {
          int v14 = v12;
          BOOL v12 = (void *)v12[2];
        }

        while (v12 != v9);
        int v13 = v14 + 2;
      }

      uint64_t v11 = (void *)v9[2];
      void *v13 = v11;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      free(v9);
      int v9 = v11;
    }

    while (v11);
    __int16 v15 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 960) = v15;
  }

  else
  {
    __int16 v15 = *(_DWORD *)(a1 + 96);
  }

  *(_DWORD *)(a1 + 152) = v15 + ((int)(*(_DWORD *)(a1 + 88) << 27) >> 31);
  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
}

LABEL_14:
    int v7 = 1;
  }

void tcp_close(uint64_t a1)
{
  uint64_t v109 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 80);
  if (!*(void *)(v1 + 240)) {
    return;
  }
  uint64_t v3 = *(void *)(v1 + 224);
  char v4 = *(_BYTE *)(v1 + 2236);
  tcp_canceltimers(a1);
  int v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x8000000) != 0 || *(_BYTE *)(v1 + 2238))
  {
    *(_DWORD *)(a1 + 88) = v5 | 0x8000000;
    return;
  }

  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      unsigned int v86 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v87 = tcpstates[*(int *)(a1 + 12)];
        *(void *)&uint8_t buf[4] = "tcp_close";
        uint64_t v88 = "";
        *(_DWORD *)__int128 buf = 136446722;
        if (v3) {
          uint64_t v88 = (const char *)(v3 + 604);
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v88;
        *(_WORD *)&_BYTE buf[22] = 2082;
        __int16 v105 = v87;
        _os_log_impl(&dword_1879E5000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s state is %{public}s", buf, 0x20u);
      }
    }
  }

  uint64_t v6 = *(void *)(v1 + 496);
  if (!v6)
  {
    if ((v4 & 2) != 0) {
      goto LABEL_62;
    }
    goto LABEL_15;
  }

  if ((v4 & 2) != 0)
  {
    if (!*(_DWORD *)(v6 + 208) && !*(_DWORD *)(v6 + 212) && !*(_DWORD *)(v6 + 216) && !*(_DWORD *)(v6 + 220)) {
      goto LABEL_62;
    }
LABEL_25:
    uint64_t v8 = *(_DWORD **)(v6 + 1488);
    if (!v8) {
      goto LABEL_62;
    }
    if (*(_BYTE *)(v6 + 1496))
    {
      free(v8);
      *(void *)(v6 + 1488) = 0LL;
      *(_BYTE *)(v6 + 1496) = 0;
      goto LABEL_62;
    }

    int v9 = *(_DWORD *)(a1 + 200);
    int v10 = 31 * v9;
    int v11 = v8[16];
    if (v9) {
      BOOL v12 = v11 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    unsigned int v13 = (v11 + v10) >> 1;
    if (v12) {
      unsigned int v13 = v10;
    }
    v8[16] = v13;
    int v14 = *(void **)(a1 + 1056);
    if (v14) {
      ++v14[54];
    }
    int v15 = *(_DWORD *)(a1 + 208);
    int v16 = 62 * v15;
    int v17 = v8[17];
    if (v15) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    unsigned int v19 = (v17 + v16) >> 1;
    if (v18) {
      unsigned int v19 = v16;
    }
    v8[17] = v19;
    if (v14) {
      ++v14[55];
    }
    unsigned int v20 = *(_DWORD *)(a1 + 148);
    unsigned int v21 = v8[14];
    if (!v21) {
      unsigned int v21 = *(_DWORD *)(v3 + 388);
    }
    unsigned int v22 = v21 >> 1;
    if (v20)
    {
      int v23 = v8[15];
      if (v23 || v20 < v22) {
        goto LABEL_52;
      }
    }

    else if (v22)
    {
      int v23 = v8[15];
LABEL_52:
      unsigned int v24 = *(_DWORD *)(a1 + 196);
      unsigned int v25 = (v20 + (v24 >> 1)) / v24;
      if (v25 <= 2) {
        unsigned int v25 = 2;
      }
      if ((v4 & 2) != 0) {
        int v26 = 60;
      }
      else {
        int v26 = 40;
      }
      unsigned int v27 = v25 * (v24 + v26);
      if (v23) {
        unsigned int v27 = (v27 + v23) >> 1;
      }
      v8[15] = v27;
      if (v14) {
        ++v14[56];
      }
    }

    *(_DWORD *)(a1 + 1964) = v8[10];
    tcp_release_route_heuristics((os_log_s *)a1);
    *(void *)(v6 + 1488) = 0LL;
    goto LABEL_62;
  }

  if ((*(_DWORD *)(v6 + 1480) & 0x2000001) == 1 && *(_DWORD *)(v6 + 204)) {
    goto LABEL_25;
  }
LABEL_15:
  *(_DWORD *)(a1 + 12) = 0;
  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v91 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
      {
        int v92 = tcpstates[*(int *)(a1 + 12)];
        *(void *)&uint8_t buf[4] = "tcp_close";
        char v93 = "";
        *(_DWORD *)__int128 buf = 136446722;
        if (v3) {
          char v93 = (const char *)(v3 + 604);
        }
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v93;
        *(_WORD *)&_BYTE buf[22] = 2082;
        __int16 v105 = v92;
        _os_log_impl( &dword_1879E5000,  v91,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
      }
    }
  }

  if (*(void *)(v3 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 0;
    }
  }

LABEL_62:
  if (*(_BYTE *)(v1 + 2000) && (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0))
  {
    unsigned int v28 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      int v29 = "";
      if (v3) {
        int v29 = (const char *)(v3 + 604);
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v29;
      _os_log_impl( &dword_1879E5000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s rt_heur rt_heur_alloc unexpectly set",  buf,  0x16u);
    }
  }

  unsigned int v30 = *(uint64_t **)a1;
  if (*(void *)a1)
  {
    while (1)
    {
      uint64_t v31 = *v30;
      if (*v30) {
        *(void *)(v31 + 8) = v30[1];
      }
      *(void *)v30[1] = v31;
      uint32_t v32 = (void *)v30[4];
      if (v32) {
        break;
      }
LABEL_71:
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      free(v30);
      unsigned int v30 = *(uint64_t **)a1;
      if (!*(void *)a1) {
        goto LABEL_89;
      }
    }

    while (1)
    {
      while (1)
      {
        __int16 v33 = (void (*)(void *, uint64_t, uint64_t))v32[10];
        size_t v34 = (void *)v32[4];
        if (!v33) {
          break;
        }
        uint64_t v35 = v32[11];
        v32[10] = 0LL;
        v32[11] = 0LL;
        v33(v32, 1LL, v35);
        uint32_t v32 = v34;
        if (!v34) {
          goto LABEL_71;
        }
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      uint64_t v36 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v37 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v37, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          unsigned int v38 = v37;
          os_log_type_t v39 = type[0];
          unsigned int v40 = "%{public}s called with null frame->finalizer";
LABEL_84:
          _os_log_impl(&dword_1879E5000, v38, v39, v40, buf, 0xCu);
        }
      }

      else
      {
        uint64_t v41 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v41, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          unsigned int v38 = v41;
          os_log_type_t v39 = type[0];
          unsigned int v40 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_84;
        }
      }

LABEL_89:
  *(_WORD *)(a1 + 224) = 0;
  uint64_t v42 = *(void *)(a1 + 80);
  uint64_t v43 = *(void *)(v42 + 224);
  if (!*(void *)(v43 + 24))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
    os_log_type_t v82 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = type[0];
      if (!os_log_type_enabled(v83, type[0])) {
        goto LABEL_196;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      __int16 v85 = "%{public}s called with null protocol";
    }

    else
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = type[0];
      if (!os_log_type_enabled(v83, type[0])) {
        goto LABEL_196;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      __int16 v85 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    if (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      uint64_t v43 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        uint64_t v44 = (const char *)(a1 + 604);
        if (!a1) {
          uint64_t v44 = "";
        }
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_ip_output_send";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v44;
        _os_log_impl( &dword_1879E5000,  v43,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s failed to get tcp buffer in tcp-ip output",  buf,  0x16u);
      }
    }

    __int16 v45 = (void *)*a3;
    if (!*a3) {
      return 6LL;
    }
    while (1)
    {
      uint64_t v46 = v45[4];
      BOOL v47 = (void *)v45[5];
      if (v46)
      {
        *(void *)(v46 + 40) = v47;
        BOOL v47 = (void *)v45[5];
      }

      else
      {
        a3[1] = v47;
      }

      *BOOL v47 = v46;
      uint64_t v48 = (void (*)(void *, void, uint64_t))v45[10];
      v45[4] = 0LL;
      v45[5] = 0LL;
      if (!v48) {
        break;
      }
      uint64_t v49 = v45[11];
      v45[10] = 0LL;
      v45[11] = 0LL;
      v48(v45, 0LL, v49);
LABEL_101:
      __int16 v45 = (void *)*a3;
      if (!*a3) {
        return 6LL;
      }
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
    uint64_t v79 = OS_LOG_TYPE_ERROR;
    int v78 = 0;
    uint64_t v71 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      if (v79 == OS_LOG_TYPE_FAULT)
      {
        int v69 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v69, v79)) {
          goto LABEL_110;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        unsigned int v50 = v69;
        os_log_type_t v51 = v79;
        int v52 = "%{public}s called with null frame->finalizer";
      }

      else
      {
        int v70 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v70, v79)) {
          goto LABEL_110;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        unsigned int v50 = v70;
        os_log_type_t v51 = v79;
        int v52 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v50, v51, v52, buf, 0xCu);
    }

LABEL_195:
    _os_log_impl(&dword_1879E5000, v83, v84, v85, buf, 0xCu);
    goto LABEL_196;
  }

  uint64_t v44 = nw_protocol_downcast();
  if (v44)
  {
    __int16 v45 = nw_retain(*(void **)(v44 + 5216));
    if (v45)
    {
      uint64_t v46 = v45;
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __tcp_publish_necp_if_stats_block_invoke;
      __int16 v105 = (char *)&__block_descriptor_tmp_15_102;
      uint64_t v106 = v42;
      uint64_t v107 = a1;
      uint64_t v108 = v43;
      nw_path_flow_registration_access_interface_stats();
      nw_release(v46);
    }

    goto LABEL_93;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
  os_log_type_t v82 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = type[0];
      if (!os_log_type_enabled(v83, type[0])) {
        goto LABEL_196;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      __int16 v85 = "%{public}s called with null tcp";
    }

    else
    {
      __int16 v83 = (os_log_s *)__nwlog_obj();
      os_log_type_t v84 = type[0];
      if (!os_log_type_enabled(v83, type[0])) {
        goto LABEL_196;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_copy_flow_registration";
      __int16 v85 = "%{public}s called with null tcp, backtrace limit exceeded";
    }

    goto LABEL_195;
  }

LABEL_196:
  if (v82) {
    free(v82);
  }
LABEL_93:
  for (uint64_t i = *(void **)(a1 + 544); i; uint64_t i = *(void **)(a1 + 544))
  {
    uint64_t v48 = i[2];
    if (*(void **)(a1 + 616) == i)
    {
      *(void *)(a1 + 616) = v48;
      uint64_t v49 = (void *)i[3];
      if (v48)
      {
LABEL_96:
        *(void *)(v48 + 24) = v49;
        uint64_t v49 = (void *)i[3];
        goto LABEL_99;
      }
    }

    else
    {
      uint64_t v49 = (void *)i[3];
      if (v48) {
        goto LABEL_96;
      }
    }

    *(void *)(a1 + 552) = v49;
LABEL_99:
    *uint64_t v49 = v48;
    nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
    free(i);
    --*(_WORD *)(a1 + 538);
    do
      unsigned int v50 = __ldxr((unsigned int *)&tcp_sack_globalholes);
    while (__stxr(v50 - 1, (unsigned int *)&tcp_sack_globalholes));
  }

  *(_OWORD *)(a1 + 616) = 0u;
  os_log_type_t v51 = *(void **)(a1 + 1032);
  if (v51)
  {
    int v52 = (void *)(a1 + 1032);
    do
    {
      unint64_t v54 = (void *)*v52;
      uint64_t v55 = (void *)(a1 + 1032);
      if ((void *)*v52 != v51)
      {
        do
        {
          __int16 v56 = v54;
          unint64_t v54 = (void *)v54[1];
        }

        while (v54 != v51);
        uint64_t v55 = v56 + 1;
      }

      unsigned int v53 = (void *)v51[1];
      void *v55 = v53;
      free(v51);
      os_log_type_t v51 = v53;
    }

    while (v53);
    *(void *)(a1 + 1032) = 0LL;
    *(_BYTE *)(a1 + 732) = 0;
  }

  if (*(void *)(a1 + 768)) {
    *(_DWORD *)(a1 + 740) &= 0xFFFFFFF3;
  }
  int v57 = *(void **)(a1 + 952);
  if (v57)
  {
    int v58 = (void *)(a1 + 952);
    do
    {
      uint64_t v60 = (void *)*v58;
      uint64_t v61 = (void *)(a1 + 952);
      if ((void *)*v58 != v57)
      {
        do
        {
          uint64_t v62 = v60;
          uint64_t v60 = (void *)v60[2];
        }

        while (v60 != v57);
        uint64_t v61 = v62 + 2;
      }

      uint64_t v59 = (void *)v57[2];
      *uint64_t v61 = v59;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      free(v57);
      int v57 = v59;
    }

    while (v59);
  }

  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
  tcp_segs_sent_clean(a1, 1);
  if (!*(void *)(a1 + 632) || v3 && (*(_BYTE *)(v3 + 828) & 2) != 0) {
    goto LABEL_132;
  }
  __nwlog_tcp_log();
  if (v3) {
    int v63 = (const char *)(v3 + 604);
  }
  else {
    int v63 = "";
  }
  *(_DWORD *)__int128 buf = 136446466;
  *(void *)&uint8_t buf[4] = "tcp_close";
  *(_WORD *)&_BYTE buf[12] = 2082;
  *(void *)&buf[14] = v63;
  uint64_t v64 = (void *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  if (__nwlog_fault())
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v65 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v66 = type[0];
      if (!os_log_type_enabled(v65, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v63;
      int v67 = "%{public}s %{public}s t_pktlist is not empty in tcp_close";
    }

    else
    {
      uint64_t v65 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v66 = type[0];
      if (!os_log_type_enabled(v65, type[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_close";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v63;
      int v67 = "%{public}s %{public}s t_pktlist is not empty in tcp_close, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v65, v66, v67, buf, 0x16u);
  }

LABEL_130:
  if (v64) {
    free(v64);
  }
LABEL_132:
  *(_DWORD *)(a1 + 12) = 0;
  if (*(void *)(v3 + 24))
  {
    uint64_t v68 = nw_protocol_tcp_get_all_stats();
    if (v68) {
      *(_DWORD *)(v68 + 136) = 0;
    }
  }

  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  int v69 = *(void (***)(uint64_t))(v3 + 32);
  if (v69)
  {
    if (!*v69 || ((*v69)(v3), (int v69 = *(void (***)(uint64_t))(v3 + 32)) != 0LL))
    {
      int v70 = v69[3];
      if (v70) {
        v70(v3);
      }
    }
  }

  if ((*(_BYTE *)(v3 + 374) & 1) != 0 && *(_DWORD *)(v1 + 232) != 3 && (*(_BYTE *)(v1 + 2232) & 1) == 0) {
    socket_post_kev_msg_closed();
  }
  uint64_t v71 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 32);
  if (v71) {
    v71(a1);
  }
  if (*(void *)(a1 + 840)) {
    *(void *)(a1 + 840) = 0LL;
  }
  *(_BYTE *)(a1 + 264) = 0;
  if (*(void *)(v3 + 24))
  {
    uint64_t v72 = nw_protocol_tcp_get_all_stats();
    if (v72) {
      *(_DWORD *)(v72 + 132) = *(unsigned __int8 *)(a1 + 264);
    }
  }

  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v3 + 369) & 0x40) != 0)
    && off_18C4CE820)
  {
    off_18C4CE820();
  }

  char v73 = *(_BYTE *)(a1 + 988);
  if ((v73 & 2) != 0)
  {
    do
      unsigned int v74 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
    while (__stxr(v74 - 1, (unsigned int *)&tcp_tfo_halfcnt));
    if (tcp_tfo_halfcnt < 0)
    {
      uint64_t v89 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v89, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_close";
      unsigned int v90 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }

      free(v90);
      char v73 = *(_BYTE *)(a1 + 988);
    }

    *(_BYTE *)(a1 + 988) = v73 & 0xFD;
  }

  if ((*(_BYTE *)(v3 + 828) & 6) == 0)
  {
    buf[0] = 1;
    uint64_t v75 = nw_log_ring_copyout();
    int v76 = v75 + 1;
    if ((unint64_t)(v75 + 1) >= 3 && (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      int v77 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        int v78 = *(_DWORD *)(nw_tcp_access_globals(v3) + 316) - *(_DWORD *)(a1 + 1776);
        *(_DWORD *)os_log_type_t type = 136447235;
        __int16 v95 = "tcp_close";
        __int16 v96 = 2082;
        uint64_t v97 = v3 + 604;
        __int16 v98 = 1040;
        int v99 = v76;
        __int16 v100 = 2097;
        __int16 v101 = buf;
        __int16 v102 = 1024;
        int v103 = v78;
        _os_log_impl( &dword_1879E5000,  v77,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s TCP Packets:\n%{private,network:tcp_packets}.*P\n\tLast packet %ums ago.",  (uint8_t *)type,  0x2Cu);
      }
    }
  }

  in_pcbdetach(v1);
  *(_WORD *)(v3 + 376) = *(_WORD *)(v3 + 376) & 0xDFC1 | 0x2030;
  uint64_t v79 = *(void *)(v3 + 32);
  if (v79)
  {
    int v80 = *(void (**)(uint64_t))(v79 + 56);
    if (v80) {
      v80(v3);
    }
  }

  uint64_t v81 = *(void *)(a1 + 1056);
  if (v81) {
    ++*(void *)(v81 + 416);
  }
}

    if (!v41) {
      return;
    }
    unint64_t v54 = (void *)v41;
LABEL_125:
    free(v54);
    return;
  }

  *(_WORD *)(a1 + 376) = v34 | 1;
LABEL_91:
  --*(_DWORD *)(a1 + 360);
  uint64_t v35 = *(void *)(a1 + 8);
  if (v35)
  {
    uint64_t v36 = *(void (**)(uint64_t, void))(v35 + 32);
    if (v36) {
      v36(a1, 0LL);
    }
  }

  sofreelastref(a1);
}

void *__tcp_publish_necp_if_stats_block_invoke(void *result, uint64_t a2)
{
  *(void *)(a2 + 96) = 0LL;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  __int16 v2 = (*(_BYTE *)(result[4] + 2236LL) & 2) == 0;
  *(_WORD *)(a2 + 96) = v2;
  __int16 v3 = *(_WORD *)(result[5] + 90LL) & 2 | v2;
  *(_WORD *)(a2 + 96) = v3;
  __int16 v4 = v3 | (4 * (*(_WORD *)(result[6] + 378LL) == 54));
  *(_WORD *)(a2 + 96) = v4;
  __int16 v5 = v4 | (8 * (*(_WORD *)(result[6] + 378LL) == 60));
  *(_WORD *)(a2 + 96) = v5;
  uint64_t v6 = result[5];
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(v6 + 348);
  int v7 = *(_DWORD *)(v6 + 708);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v6 + 712);
  *(_DWORD *)(a2 + 28) = v7;
  int v8 = *(_DWORD *)(v6 + 996);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(v6 + 720);
  *(_DWORD *)(a2 + 36) = v8;
  *(void *)&__int128 v9 = *(void *)(v6 + 1000);
  *((void *)&v9 + 1) = *(void *)(v6 + 1016);
  *(_OWORD *)(a2 + 40) = v9;
  int v10 = *(_DWORD *)(v6 + 200);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(v6 + 1024);
  *(_DWORD *)(a2 + 60) = v10;
  int v11 = *(_DWORD *)(v6 + 208);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v6 + 240);
  *(_DWORD *)(a2 + 68) = v11;
  uint64_t v12 = *(void *)(*(void *)(v6 + 80) + 496LL);
  if (v12)
  {
    uint64_t v12 = *(void *)(v12 + 1488);
    if (v12) {
      LODWORD(v12) = *(_DWORD *)(v12 + 40);
    }
  }

  *(_DWORD *)(a2 + 72) = v12;
  uint64_t v13 = *(void *)(v6 + 768);
  if (v13)
  {
    *(_DWORD *)(a2 + 76) = *(_DWORD *)(v13 + 32);
    int v14 = *(_DWORD *)(v13 + 36);
    if (v14) {
      goto LABEL_9;
    }
  }

  else
  {
    *(_DWORD *)(a2 + 76) = 0;
  }

  int v14 = 0;
LABEL_9:
  *(_DWORD *)(a2 + 80) = v14;
  uint64_t v15 = result[4];
  int v16 = *(void **)(v15 + 248);
  uint64_t v17 = v16[2];
  *(void *)a2 = *(void *)(result[6] + 744LL);
  *(void *)(a2 + 8) = v17;
  *(void *)(a2 + 16) = *v16;
  uint64_t v18 = *(void *)(v15 + 448);
  if (v18)
  {
    unsigned int v19 = (void *)(v18 + 504);
    unsigned int v20 = (void *)(v18 + 120);
    if ((*(_BYTE *)(v15 + 2236) & 2) != 0) {
      unsigned int v21 = v19;
    }
    else {
      unsigned int v21 = v20;
    }
    uint64_t v22 = v21[8];
    *(_DWORD *)(a2 + 84) = v21[9];
    *(_DWORD *)(a2 + 88) = v22;
    __int16 v23 = v5 | ((v21[17] != 0LL) << 8);
    *(_WORD *)(a2 + 96) = v23;
    *(_WORD *)(a2 + 96) = v23 | ((v21[16] != 0LL) << 9);
  }

  return result;
}

void tcp_segs_sent_clean(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 1984);
  if (v4)
  {
    while (1)
    {
      uint64_t v6 = *(void *)(v4 + 16);
      if (*(_DWORD *)(v4 + 4) - *(_DWORD *)(a1 + 560) >= 0 || (*(_BYTE *)(v4 + 12) & 9) != 0)
      {
        int v7 = *(void **)(v4 + 24);
        if (!v6) {
          goto LABEL_9;
        }
      }

      else
      {
        ++*(_DWORD *)(a1 + 1016);
        int v7 = *(void **)(v4 + 24);
        if (!v6)
        {
LABEL_9:
          *(void *)(a1 + 1992) = v7;
          goto LABEL_10;
        }
      }

      *(void *)(v6 + 24) = v7;
      int v7 = *(void **)(v4 + 24);
LABEL_10:
      *int v7 = v6;
      tcp_seg_sent_tree_head_RB_REMOVE((unint64_t *)(a1 + 2000), (void *)v4);
      if (*(_DWORD *)(a1 + 2040) < 0x40u)
      {
        *(void *)(v4 + 80) = 0LL;
        *(_OWORD *)(v4 + 48) = 0u;
        *(_OWORD *)(v4 + 64) = 0u;
        *(_OWORD *)(v4 + 16) = 0u;
        *(_OWORD *)(v4 + 32) = 0u;
        *(_OWORD *)uint64_t v4 = 0u;
        __int16 v5 = *(void **)(a1 + 2032);
        *(void *)(v4 + 80) = v5;
        *__int16 v5 = v4;
        *(void *)(a1 + 2032) = v4 + 72;
        ++*(_DWORD *)(a1 + 2040);
        uint64_t v4 = v6;
        if (!v6) {
          break;
        }
      }

      else
      {
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
        free((void *)v4);
        uint64_t v4 = v6;
        if (!v6) {
          break;
        }
      }
    }
  }

  if (*(void *)(a1 + 2000))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v16 = "tcp_segs_sent_clean";
    int v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v16 = "tcp_segs_sent_clean";
        _os_log_impl( &dword_1879E5000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s RB tree still contains segments while time ordered list is already empty, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v11) {
      free(v11);
    }
  }

  if (*(void *)(a1 + 2008))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v16 = "tcp_segs_sent_clean";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v14 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v16 = "tcp_segs_sent_clean";
        _os_log_impl( &dword_1879E5000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Segment ACKed list shouldn't contain any segments as they are removed immediately after being ACKed , backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v12) {
      free(v12);
    }
  }

  *(_BYTE *)(a1 + 2069) &= ~0x80u;
  *(_DWORD *)(a1 + 2080) = 0;
  *(void *)(a1 + 2072) = 0LL;
  if (a2)
  {
    int v8 = *(void **)(a1 + 2024);
    if (v8)
    {
      do
      {
        int v10 = (void *)v8[9];
        __int128 v9 = (void *)v8[10];
        if (v10)
        {
          v10[10] = v9;
          __int128 v9 = (void *)v8[10];
        }

        else
        {
          *(void *)(a1 + 2032) = v9;
        }

        *__int128 v9 = v10;
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
        free(v8);
        int v8 = v10;
      }

      while (v10);
    }

    *(_DWORD *)(a1 + 2040) = 0;
  }

void socket_post_kev_msg_closed()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v3 = "socket_post_kev_msg_closed";
  uint64_t v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v3 = "socket_post_kev_msg_closed";
      _os_log_impl( &dword_1879E5000,  v1,  OS_LOG_TYPE_ERROR,  "%{public}s currently not supported, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v0) {
    free(v0);
  }
}

void *tcp_seg_sent_tree_head_RB_REMOVE(unint64_t *a1, void *a2)
{
  unint64_t v2 = a2[5];
  if (!a2[4])
  {
    unint64_t v5 = a2[6] & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v17 = a2[6] & 1LL;
    if (!v2)
    {
      if (!v5)
      {
LABEL_37:
        uint64_t v18 = a1;
        goto LABEL_38;
      }

LABEL_29:
      uint64_t v18 = (unint64_t *)(v5 + 32);
      if (*(void **)(v5 + 32) != a2) {
        uint64_t v18 = (unint64_t *)(v5 + 40);
      }
LABEL_38:
      *uint64_t v18 = v2;
      if (!(_DWORD)v17) {
        goto LABEL_41;
      }
      return a2;
    }

LABEL_136:
          *(void *)(v23 + 48) = *(void *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(void *)(v2 + 48) & 1LL;
          *(void *)(v2 + 48) &= ~1uLL;
          if (v42) {
            *(void *)(v42 + 48) &= ~1uLL;
          }
          unsigned int v53 = (unint64_t *)(v23 + 32);
          uint64_t v54 = *(void *)(v23 + 32);
          *(void *)(v2 + 40) = v54;
          if (v54) {
            goto LABEL_115;
          }
          goto LABEL_119;
        }
      }

      uint64_t v42 = *(void *)(v23 + 40);
      if (v42 && (*(_BYTE *)(v42 + 48) & 1) != 0) {
        goto LABEL_136;
      }
    }

    else
    {
      uint64_t v24 = *(void *)(v23 + 48);
      if ((v24 & 1) != 0)
      {
        *(void *)(v23 + 48) = v24 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v25 = *(void *)(v2 + 48) | 1LL;
        *(void *)(v2 + 48) = v25;
        int v26 = *(void **)(v23 + 40);
        *(void *)(v2 + 32) = v26;
        if (v26)
        {
          if ((v26[6] & 1LL) != 0) {
            uint64_t v27 = v2 | 1;
          }
          else {
            uint64_t v27 = v2;
          }
          v26[6] = v27;
          uint64_t v25 = *(void *)(v2 + 48);
        }

        *(void *)(v23 + 48) = v25 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1LL;
        if ((v25 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v28 = *(void *)(v2 + 48);
          unint64_t v29 = v28 & 0xFFFFFFFFFFFFFFFELL;
          if (v2 == *(void *)((v28 & 0xFFFFFFFFFFFFFFFELL) + 32))
          {
            *(void *)(v29 + 32) = v23;
            int v26 = *(void **)(v2 + 32);
          }

          else
          {
            *(void *)(v29 + 40) = v23;
          }
        }

        else
        {
          *a1 = v23;
          uint64_t v28 = *(void *)(v2 + 48);
          unint64_t v22 = v23;
        }

        *(void *)(v23 + 40) = v2;
        if ((v28 & 1) != 0) {
          v23 |= 1uLL;
        }
        *(void *)(v2 + 48) = v23;
        unint64_t v23 = (unint64_t)v26;
      }

      uint64_t v36 = *(void *)(v23 + 32);
      if (v36)
      {
        uint64_t v37 = *(void *)(v36 + 48);
        if ((v37 & 1) != 0) {
          goto LABEL_85;
        }
      }

      unint64_t v38 = *(void *)(v23 + 40);
      if (v38)
      {
        uint64_t v39 = *(void *)(v38 + 48);
        if ((v39 & 1) != 0)
        {
          if (!v36) {
            goto LABEL_88;
          }
          uint64_t v37 = *(void *)(v36 + 48);
LABEL_85:
          if ((v37 & 1) == 0)
          {
            unint64_t v38 = *(void *)(v23 + 40);
            if (v38)
            {
              uint64_t v39 = *(void *)(v38 + 48);
LABEL_88:
              *(void *)(v38 + 48) = v39 & 0xFFFFFFFFFFFFFFFELL;
            }

            uint64_t v43 = *(void *)(v23 + 48) | 1LL;
            uint64_t v44 = *(void *)(v38 + 32);
            *(void *)(v23 + 40) = v44;
            *(void *)(v23 + 48) = v43;
            if (v44)
            {
              if ((*(void *)(v44 + 48) & 1LL) != 0) {
                uint64_t v45 = v23 | 1;
              }
              else {
                uint64_t v45 = v23;
              }
              *(void *)(v44 + 48) = v45;
              uint64_t v43 = *(void *)(v23 + 48);
            }

            *(void *)(v38 + 48) = v43 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v38 + 48) & 1LL;
            if ((v43 & 0xFFFFFFFFFFFFFFFELL) != 0)
            {
              uint64_t v46 = *(void *)(v23 + 48);
              unint64_t v47 = v46 & 0xFFFFFFFFFFFFFFFELL;
              if (v23 == *(void *)((v46 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
                *(void *)(v47 + 32) = v38;
              }
              else {
                *(void *)(v47 + 40) = v38;
              }
            }

            else
            {
              *a1 = v38;
              uint64_t v46 = *(void *)(v23 + 48);
              unint64_t v22 = v38;
            }

            *(void *)(v38 + 32) = v23;
            if ((v46 & 1) != 0) {
              v38 |= 1uLL;
            }
            *(void *)(v23 + 48) = v38;
            unint64_t v23 = *(void *)(v2 + 32);
            uint64_t v36 = *(void *)(v23 + 32);
          }

          *(void *)(v23 + 48) = *(void *)(v23 + 48) & 0xFFFFFFFFFFFFFFFELL | *(void *)(v2 + 48) & 1LL;
          *(void *)(v2 + 48) &= ~1uLL;
          if (v36) {
            *(void *)(v36 + 48) &= ~1uLL;
          }
          unsigned int v53 = (unint64_t *)(v23 + 40);
          uint64_t v54 = *(void *)(v23 + 40);
          *(void *)(v2 + 32) = v54;
          if (v54)
          {
LABEL_115:
            if ((*(void *)(v54 + 48) & 1LL) != 0) {
              uint64_t v55 = v2 | 1;
            }
            else {
              uint64_t v55 = v2;
            }
            *(void *)(v54 + 48) = v55;
          }

LABEL_119:
          uint64_t v56 = *(void *)(v2 + 48);
          *(void *)(v23 + 48) = v56 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1LL;
          if ((v56 & 0xFFFFFFFFFFFFFFFELL) != 0)
          {
            uint64_t v57 = *(void *)(v2 + 48);
            unint64_t v58 = v57 & 0xFFFFFFFFFFFFFFFELL;
            if (v2 == *(void *)((v57 & 0xFFFFFFFFFFFFFFFELL) + 32)) {
              *(void *)(v58 + 32) = v23;
            }
            else {
              *(void *)(v58 + 40) = v23;
            }
          }

          else
          {
            *a1 = v23;
            uint64_t v57 = *(void *)(v2 + 48);
            unint64_t v22 = v23;
          }

          *unsigned int v53 = v2;
          if ((v57 & 1) != 0) {
            v23 |= 1uLL;
          }
          *(void *)(v2 + 48) = v23;
          unsigned int v20 = (void *)v22;
LABEL_127:
          if (!v20) {
            return a2;
          }
          uint64_t v21 = v20[6];
          break;
        }
      }
    }

    *(void *)(v23 + 48) |= 1uLL;
    unint64_t v5 = *(void *)(v2 + 48) & 0xFFFFFFFFFFFFFFFELL;
  }

  v20[6] = v21 & 0xFFFFFFFFFFFFFFFELL;
  return a2;
}

                int v63 = 1;
                goto LABEL_121;
              }

              *(_DWORD *)(v7 + 36) = v59;
              if (v42 - 1 >= v59)
              {
                uint64_t v42 = v59;
                uint64_t v44 = 5;
              }

              v45 |= 4u;
              *(_WORD *)(v7 + 74) = v45;
              uint64_t v41 = *(_DWORD *)(v22 + 316);
LABEL_113:
              uint64_t v60 = 1;
              uint64_t v61 = *(_DWORD *)(v7 + 40);
              if (v61) {
                goto LABEL_114;
              }
              goto LABEL_119;
            }

            *(_DWORD *)(v7 + 32) = v56;
            if (v42 - 1 >= v56)
            {
              uint64_t v42 = v56;
              uint64_t v44 = 4;
            }

            v45 |= 2u;
            *(_WORD *)(v7 + 74) = v45;
            uint64_t v41 = *(_DWORD *)(v22 + 316);
LABEL_106:
            uint64_t v57 = 1;
            unint64_t v58 = *(_DWORD *)(v7 + 36);
            if (!v58) {
              goto LABEL_113;
            }
            goto LABEL_109;
          }

          *(_DWORD *)(v7 + 28) = v54;
          if (v42 - 1 >= v54)
          {
            uint64_t v42 = v54;
            uint64_t v44 = 3;
          }

          v45 |= 2u;
          *(_WORD *)(v7 + 74) = v45;
          uint64_t v41 = *(_DWORD *)(v22 + 316);
LABEL_99:
          uint64_t v88 = 1;
          uint64_t v55 = *(_DWORD *)(v7 + 32);
          if (!v55) {
            goto LABEL_106;
          }
          goto LABEL_102;
        }

        *(_DWORD *)(v7 + 24) = v51;
        if (v42 - 1 >= v51)
        {
          uint64_t v44 = 2;
          uint64_t v42 = v51;
        }

        uint64_t v45 = 1;
        *(_WORD *)(v7 + 74) = 1;
        uint64_t v41 = *(_DWORD *)(v22 + 316);
LABEL_92:
        unint64_t v52 = 1;
        unsigned int v53 = *(_DWORD *)(v7 + 28);
        if (!v53) {
          goto LABEL_99;
        }
        goto LABEL_95;
      }

      *(_DWORD *)(v7 + 20) = v48;
      if (v42 - 1 >= v48)
      {
        uint64_t v44 = 1;
        uint64_t v42 = v48;
      }

      uint64_t v45 = 1;
      *(_WORD *)(v7 + 74) = 1;
      uint64_t v41 = *(_DWORD *)(v22 + 316);
LABEL_85:
      uint64_t v49 = 1;
      uint64_t v50 = *(_DWORD *)(v7 + 24);
      if (!v50) {
        goto LABEL_92;
      }
      goto LABEL_88;
    }

    uint64_t v16 = *(_DWORD *)(v7 + 88);
    if ((v16 & 0x40000000) != 0)
    {
      uint64_t v17 = *(void *)(v7 + 48);
      *(_DWORD *)(v7 + 88) = v16 & 0xBFFFFFFF;
      if (v17) {
        *(void *)(v17 + 8) = *(void *)(v7 + 56);
      }
      **(void **)(v7 + 56) = v17;
      --*(_DWORD *)(v1 + 280);
      *(void *)(v7 + 48) = 0LL;
      *(void *)(v7 + 56) = 0LL;
    }
  }

  while (v2);
  if (!*(void *)(v1 + 256)) {
    goto LABEL_171;
  }
  if ((v4 & 1) != 0)
  {
    int v76 = 0;
    int v77 = 1;
  }

  else
  {
    unsigned int v74 = *(_DWORD *)(v1 + 296);
    else {
      uint64_t v75 = 4;
    }
    int v76 = (v74 & 1) == 0 && ((v74 | v4) & 2) == 0;
    if ((*(_DWORD *)(v1 + 296) & 1) != 0) {
      int v77 = 1;
    }
    else {
      int v77 = v75;
    }
  }

  *(_DWORD *)(v1 + 304) = 0;
  *(_DWORD *)(v1 + 292) = v77;
  uint64_t v79 = *(_DWORD *)(v1 + 300);
  if (v79 >= v3) {
    int v80 = v3;
  }
  else {
    int v80 = *(_DWORD *)(v1 + 300);
  }
  if (v79) {
    uint64_t v81 = v80;
  }
  else {
    uint64_t v81 = v3;
  }
  if (v81 <= 0x1F4) {
    os_log_type_t v82 = 500;
  }
  else {
    os_log_type_t v82 = v81;
  }
  if (v76) {
    int v78 = v82;
  }
  else {
    int v78 = v81;
  }
LABEL_185:
  tcp_sched_timerlist(v1, v78);
  *(_BYTE *)(v1 + 310) &= ~1u;
  *(void *)(v1 + 296) = 0LL;
  *(_WORD *)(v1 + 308) = 0;
}

void tcp_rxtseg_clean(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 952);
  if (v2)
  {
    unint64_t v3 = (void *)(a1 + 952);
    do
    {
      unint64_t v5 = (void *)*v3;
      unint64_t v6 = (void *)(a1 + 952);
      if ((void *)*v3 != v2)
      {
        do
        {
          int v7 = v5;
          unint64_t v5 = (void *)v5[2];
        }

        while (v5 != v2);
        unint64_t v6 = v7 + 2;
      }

      uint64_t v4 = (void *)v2[2];
      *unint64_t v6 = v4;
      nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      free(v2);
      unint64_t v2 = v4;
    }

    while (v4);
  }

  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
}

uint64_t tcp_next_mtu(int a1, int a2)
{
  if (a1 > 65534)
  {
    if ((a2 & 0x80000000) == 0)
    {
      uint64_t v2 = 0LL;
      goto LABEL_28;
    }

    return 0LL;
  }

  if (a1 > 31999)
  {
    BOOL v3 = 0;
    uint64_t v2 = 1LL;
  }

  else if (a1 > 17913)
  {
    BOOL v3 = 0;
    uint64_t v2 = 2LL;
  }

  else if (a1 > 8165)
  {
    BOOL v3 = 0;
    uint64_t v2 = 3LL;
  }

  else if (a1 > 4351)
  {
    BOOL v3 = 0;
    uint64_t v2 = 4LL;
  }

  else if (a1 > 2001)
  {
    BOOL v3 = 0;
    uint64_t v2 = 5LL;
  }

  else if (a1 > 1491)
  {
    BOOL v3 = 0;
    uint64_t v2 = 6LL;
  }

  else if (a1 > 1005)
  {
    BOOL v3 = 0;
    uint64_t v2 = 7LL;
  }

  else if (a1 > 507)
  {
    BOOL v3 = 0;
    uint64_t v2 = 8LL;
  }

  else if (a1 > 295)
  {
    BOOL v3 = 0;
    uint64_t v2 = 9LL;
  }

  else
  {
    BOOL v3 = a1 < 68;
    uint64_t v2 = 10LL;
    if (a1 < 68) {
      uint64_t v2 = 11LL;
    }
  }

  if (a2 < 0)
  {
    uint64_t v5 = v2 - 1;
    return tcp_next_mtu_mtutab[v5];
  }

  if (v3) {
    return 0LL;
  }
LABEL_28:
  uint64_t v5 = v2 + 1;
  return tcp_next_mtu_mtutab[v5];
}

void tcp_notify(uint64_t a1, int a2)
{
  if (a1 && *(_DWORD *)(a1 + 232) != 3)
  {
    uint64_t v4 = *(void *)(a1 + 240);
    if (!v4)
    {
      unint64_t v6 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      int v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }

      free(v7);
    }

    int v5 = *(_DWORD *)(v4 + 12);
    if (v5 == 4)
    {
      if ((a2 - 51) <= 0xE && ((1 << (a2 - 51)) & 0x6001) != 0)
      {
        if (*(void *)(a1 + 496)) {
          *(void *)(a1 + 496) = 0LL;
        }
        return;
      }
    }

    else if (v5 <= 3 && *(unsigned __int16 *)(v4 + 226) >= 4u && *(_DWORD *)(v4 + 256))
    {
      tcp_drop(v4, a2);
      return;
    }

    *(_DWORD *)(v4 + 256) = a2;
  }

void *tcp_mtudisc(void *result)
{
  uint64_t v1 = result[28];
  uint64_t v2 = result[30];
  if (!v2 || !*(_DWORD *)(v2 + 12)) {
    return result;
  }
  char v3 = *(_BYTE *)(*(void *)(v2 + 80) + 2236LL);
  if ((v3 & 2) != 0) {
    int v4 = -60;
  }
  else {
    int v4 = -40;
  }
  if ((*(_BYTE *)(*(void *)(v2 + 80) + 2236LL) & 2) != 0)
  {
    double result = (void *)tcp_rtlookup6((uint64_t)result, 0LL);
    if (!result) {
      goto LABEL_38;
    }
  }

  else
  {
    double result = (void *)tcp_rtlookup((uint64_t)result, 0LL);
    if (!result) {
      goto LABEL_38;
    }
  }

  uint64_t v5 = result[186];
  if (!v5 || (unsigned int v6 = *(_DWORD *)(v5 + 48)) == 0)
  {
LABEL_38:
    uint64_t v13 = 152LL;
    if ((v3 & 2) == 0) {
      uint64_t v13 = 148LL;
    }
    int v14 = *(_DWORD *)(sysctls + v13);
    *(_DWORD *)(v2 + 196) = v14;
    *(_DWORD *)(v2 + 156) = v14;
    return result;
  }

  int v7 = *(_DWORD *)(v5 + 52);
  if (v6 >= *(_DWORD *)(result[27] + 1044LL)) {
    unsigned int v6 = *(_DWORD *)(result[27] + 1044LL);
  }
  int v8 = v6 + v4;
  if (v8 >= v7) {
    int v9 = v7;
  }
  else {
    int v9 = v8;
  }
  if (v7) {
    int v10 = v9;
  }
  else {
    int v10 = v8;
  }
  if (*(_DWORD *)(v2 + 156) > v10)
  {
    *(_DWORD *)(v2 + 156) = v10;
    if ((*(_DWORD *)(v2 + 88) & 0x188) == 0x180) {
      v10 -= 12;
    }
    if (*(_DWORD *)(v1 + 388) < v10) {
      int v10 = *(_DWORD *)(v1 + 388);
    }
    *(_DWORD *)(v2 + 196) = v10;
    if (!v10)
    {
      uint64_t v17 = v1;
      uint64_t v15 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      uint64_t v16 = (void *)_os_log_send_and_compose_impl();
      double result = (void *)__nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }

      free(v16);
      uint64_t v1 = v17;
    }

    unint64_t v11 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)] + 40);
    if (v11) {
      v11(v2);
    }
    if (*(_DWORD *)(sysctls + 308) == 1
      && (~*(_DWORD *)(v2 + 88) & 0x180) == 0
      && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v1 + 369) & 0x40) != 0)
      && off_18C4CE828)
    {
      off_18C4CE828((_DWORD *)v2);
    }

    uint64_t v12 = *(void *)(v2 + 1056);
    if (v12) {
      ++*(void *)(v12 + 40);
    }
    *(_DWORD *)(v2 + 172) = 0;
    *(_DWORD *)(v2 + 100) = *(_DWORD *)(v2 + 92);
    return (void *)tcp_output(v2);
  }

  return result;
}

void tcp_drop_syn_sent(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 12) == 2) {
      tcp_drop(v2, a2);
    }
  }

void tcp_handle_msgsize(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1 && (*(_DWORD *)(a1 + 1480) & 0x2000001) == 1)
  {
    uint64_t v2 = *(void *)(a1 + 1488);
    if (!v2 || *(_BYTE *)(v2 + 73)) {
      return;
    }
    unsigned int v3 = a2;
    if (a2) {
      goto LABEL_37;
    }
    int v4 = *(_DWORD *)(v2 + 48);
    if (v4 <= 65534)
    {
      if (v4 > 31999)
      {
        uint64_t v5 = 1LL;
      }

      else if (v4 > 17913)
      {
        uint64_t v5 = 2LL;
      }

      else if (v4 > 8165)
      {
        uint64_t v5 = 3LL;
      }

      else if (v4 > 4351)
      {
        uint64_t v5 = 4LL;
      }

      else if (v4 > 2001)
      {
        uint64_t v5 = 5LL;
      }

      else if (v4 > 1491)
      {
        uint64_t v5 = 6LL;
      }

      else if (v4 > 1005)
      {
        uint64_t v5 = 7LL;
      }

      else if (v4 > 507)
      {
        uint64_t v5 = 8LL;
      }

      else if (v4 > 295)
      {
        uint64_t v5 = 9LL;
      }

      else
      {
        if (v4 < 68)
        {
          unsigned int v3 = 0;
LABEL_37:
          uint64_t v8 = *(int *)(sysctls + 164);
          unint64_t v9 = v8 + 40;
          BOOL v10 = (int)v8 < 256;
          unint64_t v11 = 296LL;
          if (!v10) {
            unint64_t v11 = v9;
          }
          if (v11 <= v3)
          {
            if (*(_DWORD *)(v2 + 48) > v3)
            {
              *(_DWORD *)(v2 + 48) = v3;
              if (__nwlog_is_datapath_logging_enabled())
              {
                uint64_t v12 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  int v14 = "tcp_handle_msgsize";
                  __int16 v15 = 1024;
                  LODWORD(v16) = v3;
                  _os_log_impl(&dword_1879E5000, v12, OS_LOG_TYPE_DEBUG, "%{public}s MTU reduced to %d\n", buf, 0x12u);
                }
              }
            }
          }

          else
          {
            *(_BYTE *)(v2 + 73) = 1;
          }

          return;
        }

        uint64_t v5 = 10LL;
      }
    }

    else
    {
      uint64_t v5 = 0LL;
    }

    unsigned int v3 = tcp_next_mtu_mtutab[v5];
    goto LABEL_37;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v14 = "tcp_handle_msgsize";
  unsigned int v6 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    int v7 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v14 = "tcp_handle_msgsize";
      _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s TCP route unusable, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v6) {
    free(v6);
  }
}

uint64_t tcp_rtlookup6(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t *)(a1 + 496);
  uint64_t v5 = *(void *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      uint64_t v7 = *(void *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((uint64_t v8 = *(void *)(v5 + 1488)) == 0 || (*(_BYTE *)(v5 + 1480) & 1) != 0 && !*(_BYTE *)(v8 + 73)))
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }

      else
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }

      *(_DWORD *)(v7 + 88) = v9;
      uint64_t v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(_BYTE *)(v5 + 1484)) {
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        }
        return v5;
      }

      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      int v14 = v13[262];
      if ((*(_BYTE *)(*(void *)(v7 + 80) + 2236LL) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          __int16 v15 = v13 + 265;
          goto LABEL_26;
        }
      }

      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        __int16 v15 = v13 + 264;
LABEL_26:
        unsigned int v16 = *v15;
        if (v16 >= 0xFFFF) {
          int v17 = 0xFFFF;
        }
        else {
          int v17 = v16;
        }
        if (v16) {
          int v18 = v17;
        }
        else {
          int v18 = 0xFFFF;
        }
        *(_DWORD *)(v7 + 692) = v18;
      }

      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(void *)(a1 + 448)) {
        *(void *)(a1 + 448) = *(void *)(v5 + 216);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }

    if (*(_BYTE *)(v5 + 1496))
    {
      unsigned int v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        uint64_t v5 = *v4;
        *(void *)(*v4 + 1488) = 0LL;
      }

      *(_BYTE *)(v5 + 1496) = 0;
    }
  }

  *(_WORD *)(a1 + 2008) = 7708;
  *(_OWORD *)(a1 + 2016) = *(_OWORD *)(a1 + 464);
  if ((*(_BYTE *)(a1 + 2229) & 0x40) != 0) {
    a2 = *(unsigned __int16 *)(*(void *)(a1 + 440) + 1072LL);
  }
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(void *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(_BYTE *)(a1 + 1804) = 6;
  *(void *)(a1 + 1960) = a1 + 1968;
  *(_BYTE *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(void *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *int v4 = 0LL;
  }

  else
  {
    uint64_t v5 = *v4;
    if (*v4) {
      goto LABEL_11;
    }
  }

  uint64_t v10 = *(void *)(a1 + 240);
  int v11 = *(_DWORD *)(v10 + 88);
  uint64_t v5 = 0LL;
  if (*(_DWORD *)(sysctls + 80)) {
    unsigned int v12 = v11 | 0x4000000;
  }
  else {
    unsigned int v12 = v11 & 0xFBFFFFFF;
  }
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

uint64_t tcp_rtlookup(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t *)(a1 + 496);
  uint64_t v5 = *(void *)(a1 + 496);
  if (v5)
  {
    if ((*(_DWORD *)(v5 + 1480) & 0x2000001) == 1)
    {
LABEL_11:
      uint64_t v7 = *(void *)(a1 + 240);
      if (*(_DWORD *)(sysctls + 80)
        && ((uint64_t v8 = *(void *)(v5 + 1488)) == 0 || (*(_BYTE *)(v5 + 1480) & 1) != 0 && !*(_BYTE *)(v8 + 73)))
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) | 0x4000000;
      }

      else
      {
        unsigned int v9 = *(_DWORD *)(v7 + 88) & 0xFBFFFFFF;
      }

      *(_DWORD *)(v7 + 88) = v9;
      uint64_t v13 = *(_DWORD **)(v5 + 216);
      if (!v13)
      {
LABEL_36:
        if (*(_BYTE *)(v5 + 1484)) {
          *(_DWORD *)(v7 + 88) |= 0x20000u;
        }
        return v5;
      }

      *(_DWORD *)(v7 + 88) = v9 & 0xEFFFFFFF;
      int v14 = v13[262];
      if ((*(_BYTE *)(*(void *)(v7 + 80) + 2236LL) & 2) != 0)
      {
        if ((v14 & 0x400000) != 0)
        {
          *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
          __int16 v15 = v13 + 265;
          goto LABEL_26;
        }
      }

      else if ((v14 & 0x200000) != 0)
      {
        *(_DWORD *)(v7 + 88) = v9 | 0x10000000;
        __int16 v15 = v13 + 264;
LABEL_26:
        unsigned int v16 = *v15;
        if (v16 >= 0xFFFF) {
          int v17 = 0xFFFF;
        }
        else {
          int v17 = v16;
        }
        if (v16) {
          int v18 = v17;
        }
        else {
          int v18 = 0xFFFF;
        }
        *(_DWORD *)(v7 + 692) = v18;
      }

      tcp_set_ecn(v7);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 1864));
      if (!*(void *)(a1 + 448)) {
        *(void *)(a1 + 448) = *(void *)(v5 + 216);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 1864));
      goto LABEL_36;
    }

    if (*(_BYTE *)(v5 + 1496))
    {
      unsigned int v6 = *(void **)(v5 + 1488);
      if (v6)
      {
        free(v6);
        uint64_t v5 = *v4;
        *(void *)(*v4 + 1488) = 0LL;
      }

      *(_BYTE *)(v5 + 1496) = 0;
    }
  }

  *(_WORD *)(a1 + 2008) = 528;
  *(_DWORD *)(a1 + 2012) = *(_DWORD *)(a1 + 476);
  if ((*(_BYTE *)(a1 + 2229) & 0x40) != 0) {
    a2 = *(unsigned __int16 *)(*(void *)(a1 + 440) + 1072LL);
  }
  bzero((void *)(a1 + 504), 0x5E0uLL);
  *(_OWORD *)(a1 + 704) = *(_OWORD *)(a1 + 2008);
  *(void *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 1768) = 0u;
  *(_DWORD *)(a1 + 1784) = 0;
  *(_WORD *)(a1 + 1800) = 1;
  *(_BYTE *)(a1 + 1804) = 6;
  *(void *)(a1 + 1960) = a1 + 1968;
  *(_BYTE *)(a1 + 1969) = 2;
  *(_DWORD *)(a1 + 1984) = 1;
  *(void *)(a1 + 496) = a1 + 504;
  if (((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t))(a1 + 2136))(v4, a1 + 504, a2) & 0x80000000) != 0)
  {
    *int v4 = 0LL;
  }

  else
  {
    uint64_t v5 = *v4;
    if (*v4) {
      goto LABEL_11;
    }
  }

  uint64_t v10 = *(void *)(a1 + 240);
  int v11 = *(_DWORD *)(v10 + 88);
  uint64_t v5 = 0LL;
  if (*(_DWORD *)(sysctls + 80)) {
    unsigned int v12 = v11 | 0x4000000;
  }
  else {
    unsigned int v12 = v11 & 0xFBFFFFFF;
  }
  *(_DWORD *)(v10 + 88) = v12;
  return v5;
}

uint64_t tcp_new_isn(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  v9[0] = 0LL;
  v9[1] = 0LL;
  int v1 = *(_DWORD *)(a1 + 12);
  if (v1 == 10 || v1 == 1) {
    return arc4random();
  }
  microuptime((uint64_t)v9);
  arc4random_buf(__buf, 0x40uLL);
  CC_SHA256_Init(&v8);
  CC_SHA256_Update(&v8, __buf, 0x40u);
  CC_SHA256_Update(&v8, (const void *)(*(void *)(a1 + 80) + 2224LL), 2u);
  CC_SHA256_Update(&v8, (const void *)(*(void *)(a1 + 80) + 2226LL), 2u);
  uint64_t v5 = *(_BYTE **)(a1 + 80);
  if ((v5[2236] & 2) != 0)
  {
    CC_SHA256_Update(&v8, v5 + 464, 0x10u);
    unsigned int v6 = (const void *)(*(void *)(a1 + 80) + 480LL);
    CC_LONG v7 = 16;
  }

  else
  {
    CC_SHA256_Update(&v8, v5 + 476, 4u);
    unsigned int v6 = (const void *)(*(void *)(a1 + 80) + 492LL);
    CC_LONG v7 = 4;
  }

  CC_SHA256_Update(&v8, v6, v7);
  CC_SHA256_Final(md, &v8);
  return (*(_DWORD *)md + 1048 * LODWORD(v9[0]));
}

uint64_t tcp_getlock(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (*(void *)a1)
  {
    if ((*(_DWORD *)(a1 + 360) & 0x80000000) == 0) {
      return *(void *)a1 + 24LL;
    }
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v4 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      uint64_t v12 = "tcp_getlock";
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 604;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 1024;
      *(_DWORD *)int v18 = v4;
      *(_WORD *)&v18[4] = 2082;
      *(void *)&v18[6] = "";
      unsigned int v3 = (void *)_os_log_send_and_compose_impl();
      unsigned int v9 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      int v10 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      uint64_t v12 = "tcp_getlock";
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 604;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 1024;
      *(_DWORD *)int v18 = v10;
      *(_WORD *)&v18[4] = 2082;
      *(void *)&v18[6] = "";
      unsigned int v6 = "%{public}s %{public}s tcp_getlock: so=%p usecount=%x lrh= %{public}s, backtrace limit exceeded";
      CC_LONG v7 = v9;
      uint32_t v8 = 48;
LABEL_14:
      _os_log_impl(&dword_1879E5000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
LABEL_15:
      if (v3) {
        free(v3);
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v12 = "tcp_getlock";
    __int16 v13 = 2082;
    uint64_t v14 = a1 + 604;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    __int16 v17 = 2082;
    *(void *)int v18 = "";
    unsigned int v3 = (void *)_os_log_send_and_compose_impl();
    uint64_t v5 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v12 = "tcp_getlock";
    __int16 v13 = 2082;
    uint64_t v14 = a1 + 604;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    __int16 v17 = 2082;
    *(void *)int v18 = "";
    unsigned int v6 = "%{public}s %{public}s tcp_getlock: so=%p NULL so_pcb %{public}s, backtrace limit exceeded";
    CC_LONG v7 = v5;
    uint32_t v8 = 42;
    goto LABEL_14;
  }

  return 0LL;
}

uint64_t tcp_set_max_rwinscale(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(int *)(sysctls + 184);
  unsigned int v3 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(a2 + 537) & 2) != 0) {
    unsigned int v3 = (int *)(a2 + 492);
  }
  int v4 = *v3;
  unsigned int v5 = v2;
  if (v2 <= 0xDu && 0x10000 << v2 < v4)
  {
    do
    {
      LOBYTE(v2) = v5 + 1;
      if (v5 > 0xC) {
        break;
      }
      int v7 = 0x20000 << v5++;
    }

    while (v7 < v4);
  }

  *(_BYTE *)(result + 262) = v2;
  return result;
}

void *tcp_rxtseg_insert(void *result, int a2, int a3)
{
  int v3 = a3;
  int v4 = a2;
  unsigned int v5 = result;
  unsigned int v6 = (void *)result[119];
  if (v6)
  {
    BOOL v7 = *(_DWORD *)v6 - a2 > 0;
    if (*(_DWORD *)v6 - a2 > 0)
    {
      __int16 v8 = 0;
      unsigned int v9 = 0LL;
      goto LABEL_4;
    }

    do
    {
      unsigned int v9 = v6;
      unsigned int v6 = (void *)v6[2];
      if (!v6)
      {
        double result = 0LL;
        goto LABEL_17;
      }
    }

    while (*(_DWORD *)v6 - a2 <= 0);
    double result = v6;
LABEL_17:
    int v11 = *((_DWORD *)v9 + 1);
    if (*(_DWORD *)v9 - a2 <= 0 && ((v11 - a3) & 0x80000000) == 0)
    {
      ++*((_WORD *)v9 + 4);
      return result;
    }

    if (v11 - a2 < 1)
    {
      if (v6)
      {
LABEL_33:
        __int16 v8 = 0;
        goto LABEL_34;
      }

      goto LABEL_31;
    }

    if (*(_DWORD *)v9 == a2 && a3 - v11 >= 1)
    {
      int v4 = v11 + 1;
      ++*((_WORD *)v9 + 4);
      if (v6) {
        goto LABEL_33;
      }
LABEL_31:
      BOOL v7 = 0;
      __int16 v8 = 0;
      goto LABEL_11;
    }

    *((_DWORD *)v9 + 1) = a2 - 1;
    __int16 v8 = *((_WORD *)v9 + 4);
    if (v6)
    {
LABEL_34:
      unsigned int v6 = result;
LABEL_4:
      if (*(_DWORD *)v6 - a3 < 0)
      {
        if (*((_DWORD *)v6 + 1) - a3 <= 0)
        {
          int v3 = *(_DWORD *)v6 - 1;
          ++*((_WORD *)v6 + 4);
        }

        else
        {
          *(_DWORD *)unsigned int v6 = a3 + 1;
          __int16 v8 = *((_WORD *)v6 + 4);
        }
      }

      goto LABEL_11;
    }

    BOOL v7 = 0;
  }

  else
  {
    unsigned int v9 = 0LL;
    __int16 v8 = 0;
    *((_DWORD *)result + 240) = *((_DWORD *)result + 23);
    BOOL v7 = 1;
  }

LABEL_11:
  if (v4 - v3 < 0)
  {
    uint64_t v10 = nw_tcp_access_globals(*(void *)(v5[10] + 224LL));
    double result = malloc(**(void **)(v10 + 56));
    if (result)
    {
      result[2] = 0LL;
      *(void *)((char *)result + 10) = 0LL;
      *(_DWORD *)double result = v4;
      *((_DWORD *)result + 1) = v3;
      *((_WORD *)result + 4) = v8 + 1;
      if (v7)
      {
        result[2] = v5[119];
        v5[119] = result;
      }

      else
      {
        result[2] = v9[2];
        void v9[2] = result;
      }
    }
  }

  return result;
}

uint64_t tcp_seg_sent_tree_head_RB_INSERT_COLOR(uint64_t result, unint64_t a2)
{
  while (1)
  {
    uint64_t v2 = *(void *)(a2 + 48);
    int v3 = (void *)(v2 & 0xFFFFFFFFFFFFFFFELL);
    if ((v2 & 0xFFFFFFFFFFFFFFFELL) == 0) {
      break;
    }
    uint64_t v4 = v3[6];
    if ((v4 & 1) == 0) {
      break;
    }
    unsigned int v5 = (void *)(v4 & 0xFFFFFFFFFFFFFFFELL);
    unsigned int v6 = *(void **)((v4 & 0xFFFFFFFFFFFFFFFELL) + 32);
    if (v6 == v3)
    {
      unsigned int v6 = (void *)v5[5];
      if (v6 && (uint64_t v7 = v6[6], (v7 & 1) != 0))
      {
LABEL_2:
        v6[6] = v7 & 0xFFFFFFFFFFFFFFFELL;
        v3[6] &= ~1uLL;
        v5[6] |= 1uLL;
        a2 = v4 & 0xFFFFFFFFFFFFFFFELL;
      }

      else
      {
        uint64_t v10 = v3[5];
        if (v10 == a2)
        {
          uint64_t v17 = *(void *)(a2 + 32);
          v3[5] = v17;
          if (v17)
          {
            uint64_t v18 = v2 | 1;
            if ((*(void *)(v17 + 48) & 1LL) == 0) {
              uint64_t v18 = (uint64_t)v3;
            }
            *(void *)(v17 + 48) = v18;
            uint64_t v19 = v3[6];
            uint64_t v2 = *(void *)(a2 + 48);
          }

          else
          {
            uint64_t v19 = v4;
          }

          *(void *)(a2 + 48) = v19 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
          if ((v19 & 0xFFFFFFFFFFFFFFFELL) != 0)
          {
            uint64_t v30 = v3[6];
            unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFELL;
            if (*(void **)((v30 & 0xFFFFFFFFFFFFFFFELL) + 32) == v3) {
              *(void *)(v31 + 32) = a2;
            }
            else {
              *(void *)(v31 + 40) = a2;
            }
          }

          else
          {
            *(void *)double result = a2;
            uint64_t v30 = v3[6];
          }

          *(void *)(a2 + 32) = v3;
          if ((v30 & 1) != 0) {
            uint64_t v32 = a2 | 1;
          }
          else {
            uint64_t v32 = a2;
          }
          v3[6] = v32;
          unint64_t v12 = v5[4];
          uint64_t v10 = *(void *)(v12 + 40);
          unint64_t v11 = *(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
          __int16 v13 = (void *)a2;
          a2 = (unint64_t)v3;
        }

        else
        {
          unint64_t v11 = v4 & 0xFFFFFFFFFFFFFFFELL;
          unint64_t v12 = v2 & 0xFFFFFFFFFFFFFFFELL;
          __int16 v13 = v3;
        }

        v13[6] = v11;
        uint64_t v33 = v5[6] | 1LL;
        v5[6] = v33;
        v5[4] = v10;
        if (v10)
        {
          uint64_t v34 = v4 | 1;
          if ((*(void *)(v10 + 48) & 1LL) == 0) {
            uint64_t v34 = (uint64_t)v5;
          }
          *(void *)(v10 + 48) = v34;
          uint64_t v33 = v5[6];
        }

        *(void *)(v12 + 48) = v33 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v12 + 48) & 1LL;
        if ((v33 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v35 = v5[6];
          unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFFELL;
          if (*(void **)((v35 & 0xFFFFFFFFFFFFFFFELL) + 32) == v5) {
            *(void *)(v36 + 32) = v12;
          }
          else {
            *(void *)(v36 + 40) = v12;
          }
        }

        else
        {
          *(void *)double result = v12;
          uint64_t v35 = v5[6];
        }

        *(void *)(v12 + 40) = v5;
        if ((v35 & 1) != 0) {
          uint64_t v37 = v12 | 1;
        }
        else {
          uint64_t v37 = v12;
        }
        v5[6] = v37;
      }
    }

    else
    {
      if (v6)
      {
        uint64_t v7 = v6[6];
        if ((v7 & 1) != 0) {
          goto LABEL_2;
        }
      }

      if (v3[4] == a2)
      {
        uint64_t v14 = *(void *)(a2 + 40);
        v3[4] = v14;
        if (v14)
        {
          uint64_t v15 = v2 | 1;
          if ((*(void *)(v14 + 48) & 1LL) == 0) {
            uint64_t v15 = (uint64_t)v3;
          }
          *(void *)(v14 + 48) = v15;
          uint64_t v16 = v3[6];
          uint64_t v2 = *(void *)(a2 + 48);
        }

        else
        {
          uint64_t v16 = v4;
        }

        *(void *)(a2 + 48) = v16 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
        if ((v16 & 0xFFFFFFFFFFFFFFFELL) != 0)
        {
          uint64_t v20 = v3[6];
          unint64_t v21 = v20 & 0xFFFFFFFFFFFFFFFELL;
          if (*(void **)((v20 & 0xFFFFFFFFFFFFFFFELL) + 32) == v3) {
            *(void *)(v21 + 32) = a2;
          }
          else {
            *(void *)(v21 + 40) = a2;
          }
        }

        else
        {
          *(void *)double result = a2;
          uint64_t v20 = v3[6];
        }

        *(void *)(a2 + 40) = v3;
        if ((v20 & 1) != 0) {
          uint64_t v22 = a2 | 1;
        }
        else {
          uint64_t v22 = a2;
        }
        v3[6] = v22;
        unint64_t v8 = *(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFELL;
        unsigned int v9 = (void *)a2;
        a2 = (unint64_t)v3;
      }

      else
      {
        unint64_t v8 = v4 & 0xFFFFFFFFFFFFFFFELL;
        unsigned int v9 = v3;
      }

      v9[6] = v8;
      uint64_t v23 = v5[5];
      uint64_t v24 = v5[6] | 1LL;
      uint64_t v25 = *(void *)(v23 + 32);
      v5[5] = v25;
      v5[6] = v24;
      if (v25)
      {
        uint64_t v26 = v4 | 1;
        if ((*(void *)(v25 + 48) & 1LL) == 0) {
          uint64_t v26 = (uint64_t)v5;
        }
        *(void *)(v25 + 48) = v26;
        uint64_t v24 = v5[6];
      }

      *(void *)(v23 + 48) = v24 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v23 + 48) & 1LL;
      if ((v24 & 0xFFFFFFFFFFFFFFFELL) != 0)
      {
        uint64_t v27 = v5[6];
        unint64_t v28 = v27 & 0xFFFFFFFFFFFFFFFELL;
        if (*(void **)((v27 & 0xFFFFFFFFFFFFFFFELL) + 32) == v5) {
          *(void *)(v28 + 32) = v23;
        }
        else {
          *(void *)(v28 + 40) = v23;
        }
      }

      else
      {
        *(void *)double result = v23;
        uint64_t v27 = v5[6];
      }

      *(void *)(v23 + 32) = v5;
      if ((v27 & 1) != 0) {
        uint64_t v29 = v23 | 1;
      }
      else {
        uint64_t v29 = v23;
      }
      v5[6] = v29;
    }
  }

  *(void *)(*(void *)result + 48LL) &= ~1uLL;
  return result;
}

uint64_t tcp_seg_len(int *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v3 = *a1;
  int v2 = a1[1];
  uint64_t result = (v2 - *a1);
  if (v2 - v3 < 0)
  {
    __nwlog_obj();
    int v6 = *a1;
    int v5 = a1[1];
    *(_DWORD *)__int128 buf = 136446722;
    unint64_t v12 = "tcp_seg_len";
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    uint64_t v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v10 = *a1;
        int v9 = a1[1];
        *(_DWORD *)__int128 buf = 136446722;
        unint64_t v12 = "tcp_seg_len";
        __int16 v13 = 1024;
        int v14 = v9;
        __int16 v15 = 1024;
        int v16 = v10;
        _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s segment end(%u) can't be smaller than segment start(%u), backtrace limit exceeded",  buf,  0x18u);
      }
    }

    if (v7) {
      free(v7);
    }
    return (a1[1] - *a1);
  }

  return result;
}

uint64_t tcp_process_rxmt_segs_after_rto(uint64_t result, int *a2, int a3, int a4, char a5)
{
  uint64_t v7 = a2;
  uint64_t v8 = result;
  int v9 = *a2;
  if (*a2 - a3 <= 0)
  {
    int v12 = a2[1];
LABEL_24:
    *uint64_t v7 = v9;
    v7[1] = v12;
    v7[2] = a4;
    if (v9 - *(_DWORD *)(v8 + 2060) < 0) {
      *(_DWORD *)(v8 + 2060) = v9;
    }
    char v19 = *((_BYTE *)v7 + 12) | a5;
    *((_BYTE *)v7 + 12) = v19;
    if ((v19 & 4) != 0)
    {
      uint64_t result = tcp_seg_len(v7);
      *(_DWORD *)(v8 + 2076) += result;
    }

    int v20 = *(char *)(v8 + 2069);
    if ((v20 & 0x80000000) == 0) {
      *(_BYTE *)(v8 + 2069) = v20 | (32 * a5) & 0x80;
    }
    if (*(int **)(v8 + 1984) == v7)
    {
      uint64_t v21 = *((void *)v7 + 2);
      uint64_t v22 = (void *)*((void *)v7 + 3);
      if (v21)
      {
        *(void *)(v21 + 24) = v22;
        uint64_t v22 = (void *)*((void *)v7 + 3);
      }

      else
      {
        *(void *)(v8 + 1992) = v22;
      }

      *uint64_t v22 = v21;
      uint64_t v23 = *(int ***)(v8 + 1992);
      *((void *)v7 + 2) = 0LL;
      *((void *)v7 + 3) = v23;
      *uint64_t v23 = v7;
      *(void *)(v8 + 1992) = v7 + 4;
    }
  }

  else
  {
    char v11 = (32 * a5) & 0x80;
    int v12 = a2[1];
    while (1)
    {
      *uint64_t v7 = v9;
      v7[1] = v12;
      v7[2] = a4;
      if (v9 - *(_DWORD *)(v8 + 2060) < 0) {
        *(_DWORD *)(v8 + 2060) = v9;
      }
      char v13 = *((_BYTE *)v7 + 12) | a5;
      *((_BYTE *)v7 + 12) = v13;
      if ((v13 & 4) != 0)
      {
        uint64_t result = tcp_seg_len(v7);
        *(_DWORD *)(v8 + 2076) += result;
      }

      int v14 = *(char *)(v8 + 2069);
      if ((v14 & 0x80000000) == 0) {
        *(_BYTE *)(v8 + 2069) = v14 | v11;
      }
      if (*(int **)(v8 + 1984) == v7)
      {
        uint64_t v15 = *((void *)v7 + 2);
        int v16 = (void *)*((void *)v7 + 3);
        if (v15)
        {
          *(void *)(v15 + 24) = v16;
          int v16 = (void *)*((void *)v7 + 3);
        }

        else
        {
          *(void *)(v8 + 1992) = v16;
        }

        *int v16 = v15;
        uint64_t v17 = *(int ***)(v8 + 1992);
        *((void *)v7 + 2) = 0LL;
        *((void *)v7 + 3) = v17;
        *uint64_t v17 = v7;
        *(void *)(v8 + 1992) = v7 + 4;
      }

      if (!*(void *)(v8 + 2000)) {
        break;
      }
      int v12 = *v7;
      uint64_t v7 = *(int **)(v8 + 2000);
      while (1)
      {
        while (1)
        {
          int v18 = v7[1];
          if (v12 - v18 >= 0) {
            break;
          }
          uint64_t v7 = (int *)*((void *)v7 + 4);
          if (!v7) {
            return result;
          }
        }

        if (v12 == v18) {
          break;
        }
        uint64_t v7 = (int *)*((void *)v7 + 5);
        if (!v7) {
          return result;
        }
      }

      int v9 = *v7;
      if (*v7 - a3 <= 0) {
        goto LABEL_24;
      }
    }
  }

  return result;
}

void tcp_seg_rto_insert_end(uint64_t a1, int a2, int a3, int a4, char a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v10 = *(void **)(a1 + 2024);
  if (v10)
  {
    uint64_t v11 = v10[9];
    int v12 = (void *)v10[10];
    if (v11)
    {
      *(void *)(v11 + 80) = v12;
      int v12 = (void *)v10[10];
    }

    else
    {
      *(void *)(a1 + 2032) = v12;
    }

    *int v12 = v11;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }

  uint64_t v13 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v10 = malloc(**(void **)(v13 + 64));
  if (v10)
  {
LABEL_8:
    v10[10] = 0LL;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *(_OWORD *)int v10 = 0u;
  }

  *(_DWORD *)int v10 = a2;
  *((_DWORD *)v10 + 1) = a3;
  *((_DWORD *)v10 + 2) = a4;
  if (a2 - *(_DWORD *)(a1 + 2060) < 0) {
    *(_DWORD *)(a1 + 2060) = a2;
  }
  char v14 = *((_BYTE *)v10 + 12) | a5;
  *((_BYTE *)v10 + 12) = v14;
  if ((v14 & 4) != 0) {
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v10);
  }
  int v15 = *(char *)(a1 + 2069);
  if ((v15 & 0x80000000) == 0) {
    *(_BYTE *)(a1 + 2069) = v15 | (32 * a5) & 0x80;
  }
  unint64_t v16 = *(void *)(a1 + 2000);
  if (v16)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v17 = v16;
        int v18 = *((_DWORD *)v10 + 1) - *(_DWORD *)(v16 + 4);
        if (v18 >= 0) {
          break;
        }
        unint64_t v16 = *(void *)(v16 + 32);
        if (!v16) {
          goto LABEL_23;
        }
      }

      if (!v18) {
        break;
      }
      unint64_t v16 = *(void *)(v16 + 40);
      if (!v16) {
        goto LABEL_23;
      }
    }

    uint64_t v21 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      int v22 = *(_DWORD *)v17;
      int v23 = *(_DWORD *)(v17 + 4);
      int v24 = 136446978;
      uint64_t v25 = "tcp_seg_rto_insert_end";
      __int16 v26 = 2048;
      unint64_t v27 = v17;
      __int16 v28 = 1024;
      int v29 = v22;
      __int16 v30 = 1024;
      int v31 = v23;
      _os_log_impl( &dword_1879E5000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s segment %p[%u %u) was not inserted in the RB tree",  (uint8_t *)&v24,  0x22u);
    }
  }

  else
  {
    unint64_t v17 = 0LL;
    int v18 = 0;
LABEL_23:
    v10[4] = 0LL;
    v10[5] = 0LL;
    v10[6] = v17 | 1;
    if (v18 < 0) {
      char v19 = (void *)(v17 + 32);
    }
    else {
      char v19 = (void *)(v17 + 40);
    }
    if (!v17) {
      char v19 = (void *)(a1 + 2000);
    }
    *char v19 = v10;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v10);
  }

  v10[2] = 0LL;
  int v20 = *(void **)(a1 + 1992);
  v10[3] = v20;
  *int v20 = v10;
  *(void *)(a1 + 1992) = v10 + 2;
}

void tcp_segs_doack(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (*(void *)(a1 + 1984))
  {
    int v6 = (a3 << 31 >> 31) & a4;
    if ((*(char *)(a1 + 2069) & 0x80000000) == 0)
    {
      uint64_t v7 = **(void **)(*(void *)(a1 + 1992) + 8LL);
      int v8 = *(_DWORD *)(v7 + 4);
      if ((int)a2 - v8 >= 0)
      {
        unsigned int v9 = *(_DWORD *)(v7 + 8);
        int v10 = (*(unsigned __int8 *)(v7 + 12) >> 3) & 1;
        tcp_segs_sent_clean(a1, 0);
        uint64_t v11 = a1;
        int v12 = v6;
        unsigned int v13 = v9;
        int v14 = v8;
LABEL_29:
        tcp_rack_update_segment_acked(v11, v12, v13, v14, v10);
        return;
      }
    }

    uint64_t v15 = *(void *)(a1 + 2000);
    if (v15)
    {
      uint64_t v16 = *(void *)(a1 + 2000);
      do
      {
        while (1)
        {
          int v17 = *(_DWORD *)(v16 + 4);
          uint64_t v16 = *(void *)(v16 + 32);
          if (!v16) {
            goto LABEL_11;
          }
        }

        if ((_DWORD)a2 == v17)
        {
          unsigned int v24 = *(_DWORD *)(v16 + 8);
          int v10 = (*(unsigned __int8 *)(v16 + 12) >> 3) & 1;
          tcp_seg_collect_acked(a1, v15, a2);
          tcp_seg_delete_acked(a1, v24, v6);
          goto LABEL_28;
        }

        uint64_t v16 = *(void *)(v16 + 40);
      }

      while (v16);
LABEL_11:
      unint64_t v18 = *(void *)(a1 + 2000);
      do
      {
        unint64_t v19 = v18;
        unint64_t v18 = *(void *)(v18 + 32);
      }

      while (v18);
      while (1)
      {
        unint64_t v20 = *(void *)(v19 + 40);
        if (v20)
        {
          do
          {
            unint64_t v21 = v20;
            unint64_t v20 = *(void *)(v20 + 32);
          }

          while (v20);
        }

        else
        {
          unint64_t v21 = *(void *)(v19 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v21 || *(void *)(v21 + 32) != v19)
          {
            unint64_t v22 = v19;
            do
            {
              unint64_t v21 = *(void *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
              if (!v21) {
                break;
              }
              BOOL v23 = v22 == *(void *)(v21 + 40);
              unint64_t v22 = *(void *)(v22 + 48) & 0xFFFFFFFFFFFFFFFELL;
            }

            while (v23);
          }
        }

        unint64_t v19 = v21;
        if (!v21) {
          return;
        }
      }

      unsigned int v24 = *(_DWORD *)(v19 + 8);
      int v10 = (*(unsigned __int8 *)(v19 + 12) >> 3) & 1;
      tcp_seg_collect_acked(a1, v15, a2);
      tcp_seg_delete_acked(a1, v24, v6);
      *(_DWORD *)unint64_t v19 = a2;
LABEL_28:
      uint64_t v11 = a1;
      int v12 = v6;
      unsigned int v13 = v24;
      int v14 = a2;
      goto LABEL_29;
    }
  }

uint64_t tcp_seg_collect_acked(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    while (1)
    {
      int v6 = *(void **)(v4 + 32);
      uint64_t v4 = *(void *)(v4 + 32);
      if (!v6) {
        return result;
      }
    }

    tcp_seg_collect_acked_subtree(result, v6);
    uint64_t result = tcp_seg_collect_acked(v5, *(void *)(v4 + 40), a3);
    *(void *)(v4 + 56) = 0LL;
    uint64_t v7 = *(void **)(v5 + 2016);
    *(void *)(v4 + 64) = v7;
    *uint64_t v7 = v4;
    *(void *)(v5 + 2016) = v4 + 56;
  }

  return result;
}

void tcp_seg_delete_acked(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 2008);
  if (v3)
  {
    uint64_t v32 = (unint64_t *)(a1 + 2000);
    while (1)
    {
      uint64_t v7 = *(void *)(v3 + 56);
      unsigned int v8 = *(_DWORD *)(v3 + 8);
      if (v8 > a2) {
        tcp_rack_update_segment_acked(a1, a3, v8, *(_DWORD *)(v3 + 4), (*(unsigned __int8 *)(v3 + 12) >> 3) & 1);
      }
      if (*(_DWORD *)(v3 + 4) - *(_DWORD *)(a1 + 560) < 0 && (*(_BYTE *)(v3 + 12) & 9) == 0) {
        ++*(_DWORD *)(a1 + 1016);
      }
      unsigned int v9 = tcp_seg_len((int *)v3);
      unsigned int v10 = v9;
      char v11 = *(_BYTE *)(v3 + 12);
      if ((v11 & 2) != 0)
      {
        unsigned int v14 = *(_DWORD *)(a1 + 2072);
        if (v14 < v9)
        {
          __nwlog_obj();
          int v15 = *(_DWORD *)(a1 + 2072);
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v34 = "tcp_seg_delete_acked";
          __int16 v35 = 1024;
          int v36 = v15;
          __int16 v37 = 1024;
          unsigned int v38 = v10;
          uint64_t v16 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v17 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              int v18 = *(_DWORD *)(a1 + 2072);
              *(_DWORD *)__int128 buf = 136446722;
              uint64_t v34 = "tcp_seg_delete_acked";
              __int16 v35 = 1024;
              int v36 = v18;
              __int16 v37 = 1024;
              unsigned int v38 = v10;
              _os_log_impl( &dword_1879E5000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded",  buf,  0x18u);
            }
          }

          if (v16) {
            free(v16);
          }
          unsigned int v14 = *(_DWORD *)(a1 + 2072);
          char v11 = *(_BYTE *)(v3 + 12);
        }

        *(_DWORD *)(a1 + 2072) = v14 - v10;
        if ((v11 & 4) == 0)
        {
LABEL_11:
          if ((v11 & 1) == 0) {
            goto LABEL_12;
          }
          goto LABEL_30;
        }
      }

      else if ((*(_BYTE *)(v3 + 12) & 4) == 0)
      {
        goto LABEL_11;
      }

      unsigned int v19 = *(_DWORD *)(a1 + 2076);
      if (v19 < v10)
      {
        __nwlog_obj();
        int v20 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v34 = "tcp_seg_delete_acked";
        __int16 v35 = 1024;
        int v36 = v20;
        __int16 v37 = 1024;
        unsigned int v38 = v10;
        unint64_t v21 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unint64_t v22 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            int v23 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)__int128 buf = 136446722;
            uint64_t v34 = "tcp_seg_delete_acked";
            __int16 v35 = 1024;
            int v36 = v23;
            __int16 v37 = 1024;
            unsigned int v38 = v10;
            _os_log_impl( &dword_1879E5000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_retransmitted (%u) can't be smaller than already retransmited segment length (%u), backtr ace limit exceeded",  buf,  0x18u);
          }
        }

        if (v21) {
          free(v21);
        }
        unsigned int v19 = *(_DWORD *)(a1 + 2076);
        char v11 = *(_BYTE *)(v3 + 12);
      }

      *(_DWORD *)(a1 + 2076) = v19 - v10;
      if ((v11 & 1) == 0)
      {
LABEL_12:
        uint64_t v12 = *(void *)(v3 + 56);
        unsigned int v13 = *(void **)(v3 + 64);
        if (!v12) {
          goto LABEL_38;
        }
        goto LABEL_13;
      }

LABEL_30:
      unsigned int v24 = *(_DWORD *)(a1 + 2080);
      if (v24 < v10)
      {
        __nwlog_obj();
        int v25 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v34 = "tcp_seg_delete_acked";
        __int16 v35 = 1024;
        int v36 = v25;
        __int16 v37 = 1024;
        unsigned int v38 = v10;
        __int16 v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unint64_t v27 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            int v28 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)__int128 buf = 136446722;
            uint64_t v34 = "tcp_seg_delete_acked";
            __int16 v35 = 1024;
            int v36 = v28;
            __int16 v37 = 1024;
            unsigned int v38 = v10;
            _os_log_impl( &dword_1879E5000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded",  buf,  0x18u);
          }
        }

        if (v26) {
          free(v26);
        }
        unsigned int v24 = *(_DWORD *)(a1 + 2080);
      }

      *(_DWORD *)(a1 + 2080) = v24 - v10;
      uint64_t v12 = *(void *)(v3 + 56);
      unsigned int v13 = *(void **)(v3 + 64);
      if (!v12)
      {
LABEL_38:
        *(void *)(a1 + 2016) = v13;
        goto LABEL_39;
      }

uint64_t tcp_seg_collect_acked_subtree(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    tcp_seg_collect_acked_subtree(result, a2[4]);
    uint64_t result = tcp_seg_collect_acked_subtree(v3, a2[5]);
    a2[7] = 0LL;
    uint64_t v4 = *(void **)(v3 + 2016);
    a2[8] = v4;
    *uint64_t v4 = a2;
    *(void *)(v3 + 2016) = a2 + 7;
  }

  return result;
}

void tcp_segs_dosack_matched(uint64_t a1, int *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v8 = (uint64_t)a2;
  int v10 = *a2;
  if (*a2 == a3)
  {
LABEL_13:
    unsigned int v14 = *(unsigned __int8 *)(v8 + 12);
    if (!tcp_seg_mark_sacked((_DWORD *)a1, v8, a5)) {
      return;
    }
    goto LABEL_14;
  }

  while (1)
  {
    unsigned int v11 = *(unsigned __int8 *)(v8 + 12);
    if (a3 - v10 >= 1) {
      break;
    }
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5)) {
      tcp_rack_update_segment_acked(a1, a4, *(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 4), (v11 >> 3) & 1);
    }
    if (!*(void *)(a1 + 2000)) {
      return;
    }
    int v12 = *(_DWORD *)v8;
    uint64_t v8 = *(void *)(a1 + 2000);
    while (1)
    {
      while (1)
      {
        int v13 = *(_DWORD *)(v8 + 4);
        if (v12 - v13 >= 0) {
          break;
        }
        uint64_t v8 = *(void *)(v8 + 32);
        if (!v8) {
          return;
        }
      }

      if (v12 == v13) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 40);
      if (!v8) {
        return;
      }
    }

    int v10 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == a3) {
      goto LABEL_13;
    }
  }

  if ((v11 & 1) == 0)
  {
    tcp_seg_sent_insert_before(a1, v8, v10, a3, *(_DWORD *)(v8 + 8), *(_BYTE *)(v8 + 12));
    *(_DWORD *)uint64_t v8 = a3;
    unsigned int v14 = *(unsigned __int8 *)(v8 + 12);
    if (tcp_seg_mark_sacked((_DWORD *)a1, v8, a5)) {
LABEL_14:
    }
      tcp_rack_update_segment_acked(a1, a4, *(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 4), (v14 >> 3) & 1);
  }

void *tcp_seg_sent_insert_before(uint64_t a1, uint64_t a2, int a3, int a4, int a5, char a6)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  int v12 = *(void **)(a1 + 2024);
  if (v12)
  {
    uint64_t v13 = v12[9];
    unsigned int v14 = (void *)v12[10];
    if (v13)
    {
      *(void *)(v13 + 80) = v14;
      unsigned int v14 = (void *)v12[10];
    }

    else
    {
      *(void *)(a1 + 2032) = v14;
    }

    *unsigned int v14 = v13;
    --*(_DWORD *)(a1 + 2040);
    goto LABEL_8;
  }

  uint64_t v15 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v12 = malloc(**(void **)(v15 + 64));
  if (v12)
  {
LABEL_8:
    v12[10] = 0LL;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *(_OWORD *)int v12 = 0u;
  }

  *(_DWORD *)int v12 = a3;
  *((_DWORD *)v12 + 1) = a4;
  *((_DWORD *)v12 + 2) = a5;
  if (a3 - *(_DWORD *)(a1 + 2060) < 0) {
    *(_DWORD *)(a1 + 2060) = a3;
  }
  char v16 = *((_BYTE *)v12 + 12) | a6;
  *((_BYTE *)v12 + 12) = v16;
  if ((v16 & 4) != 0) {
    *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v12);
  }
  int v17 = *(char *)(a1 + 2069);
  if ((v17 & 0x80000000) == 0) {
    *(_BYTE *)(a1 + 2069) = v17 | (32 * a6) & 0x80;
  }
  unint64_t v18 = *(void *)(a1 + 2000);
  if (v18)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v19 = v18;
        int v20 = *((_DWORD *)v12 + 1) - *(_DWORD *)(v18 + 4);
        if (v20 >= 0) {
          break;
        }
        unint64_t v18 = *(void *)(v18 + 32);
        if (!v18) {
          goto LABEL_23;
        }
      }

      if (!v20) {
        break;
      }
      unint64_t v18 = *(void *)(v18 + 40);
      if (!v18) {
        goto LABEL_23;
      }
    }

    int v23 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = *(_DWORD *)v19;
      int v25 = *(_DWORD *)(v19 + 4);
      int v26 = 136446978;
      unint64_t v27 = "tcp_seg_sent_insert_before";
      __int16 v28 = 2048;
      unint64_t v29 = v19;
      __int16 v30 = 1024;
      int v31 = v24;
      __int16 v32 = 1024;
      int v33 = v25;
      _os_log_impl( &dword_1879E5000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s segment %p[%u %u) was not inserted in the RB tree",  (uint8_t *)&v26,  0x22u);
    }
  }

  else
  {
    unint64_t v19 = 0LL;
    int v20 = 0;
LABEL_23:
    v12[4] = 0LL;
    v12[5] = 0LL;
    v12[6] = v19 | 1;
    if (v20 < 0) {
      unint64_t v21 = (void *)(v19 + 32);
    }
    else {
      unint64_t v21 = (void *)(v19 + 40);
    }
    if (!v19) {
      unint64_t v21 = (void *)(a1 + 2000);
    }
    *unint64_t v21 = v12;
    tcp_seg_sent_tree_head_RB_INSERT_COLOR(a1 + 2000, (unint64_t)v12);
  }

  v12[3] = *(void *)(a2 + 24);
  v12[2] = a2;
  **(void **)(a2 + 24) = v12;
  *(void *)(a2 + 24) = v12 + 2;
  return v12;
}

BOOL tcp_seg_mark_sacked(_DWORD *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  char v3 = *(_BYTE *)(a2 + 12);
  if ((v3 & 1) == 0)
  {
    unsigned int v7 = tcp_seg_len((int *)a2);
    unsigned int v8 = v7;
    char v9 = *(_BYTE *)(a2 + 12);
    if (*(_DWORD *)(a2 + 4) - a1[140] < 0 && (*(_BYTE *)(a2 + 12) & 9) == 0) {
      ++a1[254];
    }
    if ((v9 & 4) != 0)
    {
      if ((v9 & 2) != 0)
      {
        *(_BYTE *)(a2 + 12) = v9 & 0xF9;
        unsigned int v13 = a1[518];
        if (v13 < v7 || (unsigned int v14 = a1[519], v14 < v7))
        {
          __nwlog_obj();
          int v15 = a1[518];
          unsigned int v16 = a1[519];
          *(_DWORD *)__int128 buf = 136446978;
          int v25 = "tcp_seg_mark_sacked";
          __int16 v26 = 1024;
          int v27 = v15;
          __int16 v28 = 1024;
          unsigned int v29 = v16;
          __int16 v30 = 1024;
          LODWORD(v31) = v8;
          int v17 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            unint64_t v18 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              int v19 = a1[518];
              unsigned int v20 = a1[519];
              *(_DWORD *)__int128 buf = 136446978;
              int v25 = "tcp_seg_mark_sacked";
              __int16 v26 = 1024;
              int v27 = v19;
              __int16 v28 = 1024;
              unsigned int v29 = v20;
              __int16 v30 = 1024;
              LODWORD(v31) = v8;
              _os_log_impl( &dword_1879E5000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_lost (%u) and/or bytes_retransmitted (%u) can't be smaller than already lost/retransmit ted segment length (%u), backtrace limit exceeded",  buf,  0x1Eu);
            }
          }

          if (v17) {
            free(v17);
          }
          unsigned int v13 = a1[518];
          unsigned int v14 = a1[519];
        }

        a1[518] = v13 - v8;
        a1[519] = v14 - v8;
      }
    }

    else if ((v9 & 2) != 0)
    {
      *(_BYTE *)(a2 + 12) = v9 & 0xFD;
      unsigned int v10 = a1[518];
      if (v10 < v7)
      {
        __nwlog_obj();
        int v11 = a1[518];
        *(_DWORD *)__int128 buf = 136446722;
        int v25 = "tcp_seg_mark_sacked";
        __int16 v26 = 1024;
        int v27 = v11;
        __int16 v28 = 1024;
        unsigned int v29 = v8;
        int v12 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unint64_t v21 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            int v22 = a1[518];
            *(_DWORD *)__int128 buf = 136446722;
            int v25 = "tcp_seg_mark_sacked";
            __int16 v26 = 1024;
            int v27 = v22;
            __int16 v28 = 1024;
            unsigned int v29 = v8;
            _os_log_impl( &dword_1879E5000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_lost (%u) can't be smaller than already lost segment length (%u), backtrace limit exceeded",  buf,  0x18u);
          }
        }

        if (v12) {
          free(v12);
        }
        unsigned int v10 = a1[518];
      }

      a1[518] = v10 - v8;
    }

    *a3 += v8;
    *(_BYTE *)(a2 + 12) |= 1u;
    a1[520] += v8;
  }

  return (v3 & 1) == 0;
}

void tcp_segs_clear_sacked(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  for (uint64_t i = *(void *)(a1 + 1984); i; uint64_t i = *(void *)(i + 16))
  {
    unsigned int v4 = tcp_seg_len((int *)i);
    if ((*(_BYTE *)(i + 12) & 1) != 0)
    {
      unsigned int v5 = v4;
      *(_BYTE *)(i + 12) &= ~1u;
      unsigned int v3 = *(_DWORD *)(a1 + 2080);
      if (v3 < v4)
      {
        __nwlog_obj();
        int v6 = *(_DWORD *)(a1 + 2080);
        *(_DWORD *)__int128 buf = 136446722;
        int v11 = "tcp_segs_clear_sacked";
        __int16 v12 = 1024;
        int v13 = v6;
        __int16 v14 = 1024;
        unsigned int v15 = v5;
        unsigned int v7 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v8 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            int v9 = *(_DWORD *)(a1 + 2080);
            *(_DWORD *)__int128 buf = 136446722;
            int v11 = "tcp_segs_clear_sacked";
            __int16 v12 = 1024;
            int v13 = v9;
            __int16 v14 = 1024;
            unsigned int v15 = v5;
            _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_sacked (%u) can't be smaller than already SACKed segment length (%u), backtrace limit exceeded",  buf,  0x18u);
          }
        }

        if (v7) {
          free(v7);
        }
        unsigned int v3 = *(_DWORD *)(a1 + 2080);
      }

      *(_DWORD *)(a1 + 2080) = v3 - v5;
    }
  }

void tcp_mark_seg_lost(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unsigned int v4 = tcp_seg_len((int *)a2);
  unsigned int v5 = v4;
  char v6 = *(_BYTE *)(a2 + 12);
  if ((v6 & 2) != 0)
  {
    if ((*(_BYTE *)(a2 + 12) & 4) != 0)
    {
      *(_BYTE *)(a2 + 12) = v6 & 0xFB;
      unsigned int v7 = *(_DWORD *)(a1 + 2076);
      BOOL v8 = v7 >= v4;
      unsigned int v9 = v7 - v4;
      if (v8)
      {
        *(_DWORD *)(a1 + 2076) = v9;
      }

      else
      {
        __nwlog_obj();
        int v10 = *(_DWORD *)(a1 + 2076);
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v15 = "tcp_mark_seg_lost";
        __int16 v16 = 1024;
        int v17 = v10;
        __int16 v18 = 1024;
        unsigned int v19 = v5;
        int v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          __int16 v12 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            int v13 = *(_DWORD *)(a1 + 2076);
            *(_DWORD *)__int128 buf = 136446722;
            unsigned int v15 = "tcp_mark_seg_lost";
            __int16 v16 = 1024;
            int v17 = v13;
            __int16 v18 = 1024;
            unsigned int v19 = v5;
            _os_log_impl( &dword_1879E5000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s bytes_retransmitted (%u) can't be smaller than retransmited segment length (%u), backtrace limit exceeded",  buf,  0x18u);
          }
        }

        if (v11) {
          free(v11);
        }
      }
    }
  }

  else
  {
    *(_BYTE *)(a2 + 12) = v6 | 2;
    *(_DWORD *)(a1 + 2072) += v4;
  }

void tcp_add_notify_ack_marker(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224LL);
  unsigned int v5 = malloc(0x10uLL);
  if (!v5)
  {
    __int16 v14 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    unsigned int v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
LABEL_13:
      __break(1u);
      return;
    }

    free(v15);
  }

  v5[1] = a2;
  int v6 = *(_DWORD *)(v4 + 384) + *(_DWORD *)(a1 + 92);
  *unsigned int v5 = v6;
  unsigned int v7 = (uint64_t *)(a1 + 1032);
  BOOL v8 = *(_DWORD **)(a1 + 1032);
  if (v8)
  {
    do
    {
      int v10 = *v8;
      unsigned int v9 = (uint64_t *)(v8 + 2);
      if (v6 - v10 > 0)
      {
        unsigned int v7 = v9;
        goto LABEL_9;
      }

      BOOL v8 = (_DWORD *)*v9;
    }

    while (v8);
    int v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    __int16 v12 = (void *)_os_log_send_and_compose_impl();
    free(v12);
LABEL_9:
    uint64_t v13 = *v7;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  *((void *)v5 + 1) = v13;
  *unsigned int v7 = (uint64_t)v5;
  ++*(_BYTE *)(a1 + 732);
}

uint64_t tcp_get_notify_ack_count(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 1032);
  if (v2)
  {
    LOBYTE(v3) = 0;
    do
    {
      if (*(_DWORD *)(result + 92) - *(_DWORD *)v2 < 0) {
        break;
      }
      LOBYTE(v3) = v3 + 1;
      uint64_t v2 = *(void *)(v2 + 8);
    }

    while (v2);
  }

  else
  {
    LOBYTE(v3) = 0;
  }

  int v3 = v3;
  int v4 = *(unsigned __int8 *)(result + 732) - v3;
  *a2 = v4;
  a2[1] = v3;
  return result;
}

void *tcp_get_notify_ack_ids(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 1032);
  if (result)
  {
    unint64_t v5 = 0LL;
    int v6 = (void *)(a1 + 1032);
    do
    {
      unsigned int v7 = (void *)result[1];
      *(_DWORD *)(a2 + 4 * v5 + 8) = *((_DWORD *)result + 1);
      BOOL v8 = (void *)*v6;
      unsigned int v9 = (void *)(a1 + 1032);
      if ((void *)*v6 != result)
      {
        do
        {
          int v10 = v8;
          BOOL v8 = (void *)v8[1];
        }

        while (v8 != result);
        unsigned int v9 = v10 + 1;
      }

      ++v5;
      *unsigned int v9 = v7;
      free(result);
      --*(_BYTE *)(a1 + 732);
      uint64_t result = v7;
    }

    while (v7);
  }

  return result;
}

uint64_t tcp_validate_cksum(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = validate_tcp_cksum();
  if ((v5 & 1) == 0)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(a1, *(void *)(a1 + 88)) & 1) == 0)
    {
      *(void *)(a3 + 1056) = 0LL;
    }

    else
    {
      uint64_t v6 = *(void *)(a3 + 1056);
      if (v6) {
        ++*(void *)(v6 + 320);
      }
    }
  }

  return v5;
}

uint64_t tcp_log_packet(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 80) + 224LL);
  if (result && (*(_BYTE *)(result + 828) & 6) == 0)
  {
    uint64_t v3 = nw_tcp_access_globals(result);
    if (*(_DWORD *)(a1 + 1776)) {
      nw_log_ms_to_delta();
    }
    int v4 = *(_DWORD *)(v3 + 316);
    if (!v4) {
      int v4 = -1;
    }
    *(_DWORD *)(a1 + 1776) = v4;
    return nw_log_ring_append();
  }

  return result;
}

uint64_t tcp_prague_init(uint64_t a1)
{
  do
    unsigned int v2 = __ldaxr(dword_18C6E9080);
  while (__stlxr(v2 + 1, dword_18C6E9080));
  uint64_t v3 = *(void *)(a1 + 840);
  if (v3) {
    goto LABEL_3;
  }
  uint64_t v5 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  uint64_t v6 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v6);
    uint64_t v3 = *(void *)(a1 + 840);
LABEL_3:
    *(void *)(v3 + 32) = 0x1000000LL;
    *(_DWORD *)(a1 + 504) = 0;
    **(_WORD **)(a1 + 840) = 0;
    *(_WORD *)(*(void *)(a1 + 840) + 2LL) = 0;
    *(void *)(*(void *)(a1 + 840) + 40LL) = 0x100000LL;
    *(_DWORD *)(*(void *)(a1 + 840) + 76LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 52LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 56LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 48LL) = 0;
    return 0LL;
  }

  __break(1u);
  return result;
}

uint64_t tcp_prague_cleanup()
{
  do
    unsigned int v0 = __ldaxr(dword_18C6E9080);
  while (__stlxr(v0 - 1, dword_18C6E9080));
  return 0LL;
}

void tcp_prague_cwnd_init_or_reset(uint64_t a1)
{
  unsigned int v2 = *(_WORD **)(a1 + 840);
  if (!v2)
  {
    int v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    __int16 v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v12);
    unsigned int v2 = *(_WORD **)(a1 + 840);
  }

  *(_DWORD *)(a1 + 504) = 0;
  *unsigned int v2 = 0;
  *(_WORD *)(*(void *)(a1 + 840) + 2LL) = 0;
  *(void *)(*(void *)(a1 + 840) + 40LL) = 0x100000LL;
  *(_DWORD *)(*(void *)(a1 + 840) + 76LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 52LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 56LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 48LL) = 0;
  uint64_t v3 = (_DWORD *)sysctls;
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v4 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v4 = 10;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    LODWORD(v6) = v5 * v4;
  }

  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 196);
    LODWORD(v6) = 2 * v5;
    else {
      unint64_t v6 = v6;
    }
    if (v6 > 4 * v5) {
      LODWORD(v6) = 4 * v5;
    }
  }

  *(_DWORD *)(a1 + 144) = v6;
  *(void *)(a1 + 980) = 0LL;
  *(_DWORD *)(a1 + 972) = 0;
  *(void *)(a1 + 964) = 0LL;
  *(_BYTE *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    int v7 = v3[4];
  }

  else
  {
    if (!v3[69])
    {
      unint64_t v8 = 4380LL;
      goto LABEL_18;
    }

    int v7 = 10;
  }

  unint64_t v8 = (v5 * v7);
LABEL_18:
  unsigned int v9 = *(_DWORD *)(a1 + 148);
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 248LL) + 24LL) <= v8 && v9 <= 0x3FFFBFFF)
  {
    unsigned int v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }

  *(_DWORD *)(*(void *)(a1 + 840) + 48LL) = v9;
  int v10 = *(_DWORD *)(a1 + 196);
  *(void *)(a1 + 480) = 10LL * *(unsigned int *)(a1 + 144);
  *(_DWORD *)(a1 + 488) = v10;
}

void tcp_prague_ack_rcvd(uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224LL);
  unsigned int v5 = *(_DWORD *)(a1 + 980);
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 144);
    if (v5 < v6 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v6))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }

  unsigned int v7 = *(_DWORD *)(a1 + 740) & 0xFFEFFFFF;
  *(_DWORD *)(a1 + 740) = v7;
  uint64_t v8 = *(void *)(a1 + 840);
  unsigned int v9 = *(_DWORD *)(v8 + 16);
  if (v9)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 144);
    if (v10 >= *(_DWORD *)(a1 + 148))
    {
      if ((*(_BYTE *)(v8 + 28) & 4) == 0)
      {
        if (v5 && v5 < v10 >> 1 && (!v4 || *(_DWORD *)(v4 + 384) <= v10))
        {
          *(_DWORD *)(a1 + 740) = v7 | 0x100000;
        }

        else
        {
          *(_DWORD *)(a1 + 740) = v7;
          *(_DWORD *)(a1 + 288) += v9;
          int v12 = *(_DWORD *)(a1 + 200);
          uint64_t v13 = nw_tcp_access_globals(v4);
          uint64_t v14 = v13;
          uint64_t v10 = *(void *)(a1 + 840);
          if (!*(_DWORD *)(v10 + 52))
          {
            *(_DWORD *)(v10 + 52) = *(_DWORD *)(v13 + 316);
            uint64_t v15 = *(void *)(a1 + 840);
            if (!*(_DWORD *)(v15 + 52))
            {
              *(_DWORD *)(v15 + 52) = 1;
              uint64_t v15 = *(void *)(a1 + 840);
            }

            unsigned int v16 = *(_DWORD *)(a1 + 144);
            unsigned int v17 = *(_DWORD *)(v15 + 48);
            BOOL v18 = v17 >= v16;
            unsigned int v19 = v17 - v16;
            if (v19 != 0 && v18)
            {
              *(float *)(v15 + 76) = cbrtf((float)((float)v19 * 2.5) / (float)*(unsigned int *)(a1 + 196)) * 1000.0;
              uint64_t v29 = *(void *)(a1 + 840);
              int v28 = *(_DWORD *)(v29 + 48);
            }

            else
            {
              *(_DWORD *)(v15 + 76) = 0;
              int v28 = *(_DWORD *)(a1 + 144);
              *(_DWORD *)(*(void *)(a1 + 840) + 48LL) = v28;
              uint64_t v29 = *(void *)(a1 + 840);
            }

            *(_DWORD *)(v29 + 56) = v28;
            uint64_t v10 = *(void *)(a1 + 840);
          }

          int v30 = v12 >> 5;
          unsigned int v31 = *(_DWORD *)(v10 + 56);
          if (!v31)
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v53 = "cubic_target";
            uint64_t v32 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              int v33 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 136446210;
                unsigned int v53 = "cubic_target";
                _os_log_impl( &dword_1879E5000,  v33,  OS_LOG_TYPE_ERROR,  "%{public}s Prague CC: Cubic origin point should be greater than 0, backtrace limit exceeded",  buf,  0xCu);
              }
            }

            if (v32) {
              free(v32);
            }
            uint64_t v10 = *(void *)(a1 + 840);
            unsigned int v31 = *(_DWORD *)(v10 + 56);
          }

          float v34 = (float)(*(_DWORD *)(v14 + 316) - *(_DWORD *)(v10 + 52) + v30) - *(float *)(v10 + 76);
          float v35 = (float)v31
          unsigned int v36 = (int)v35 & ~((int)v35 >> 31);
          unsigned int v37 = *(_DWORD *)(a1 + 144);
          unsigned int v38 = v37;
          if (v36 >= v37)
          {
            unsigned int v38 = ((double)v37 * 1.5);
            if (v36 < v38) {
              unsigned int v38 = (int)v35 & ~((int)v35 >> 31);
            }
          }

          if (!*(_DWORD *)(v10 + 60))
          {
            *(_DWORD *)(v10 + 60) = v37;
            *(_DWORD *)(*(void *)(a1 + 840) + 64LL) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
            uint64_t v10 = *(void *)(a1 + 840);
          }

          *(_DWORD *)(v10 + 64) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
          uint64_t v39 = *(void *)(a1 + 840);
          unint64_t v40 = (_DWORD *)(v39 + 64);
          unsigned int v41 = *(_DWORD *)(v39 + 64);
          for (LODWORD(v10) = *(_DWORD *)(a1 + 144); v41 >= v10; LODWORD(v10) = *(_DWORD *)(a1 + 144))
          {
            *unint64_t v40 = v41 - v10;
            uint64_t v10 = *(void *)(a1 + 840);
            unsigned int v42 = *(_DWORD *)(v10 + 60);
            float v43 = 0.52941;
            if (v42 >= *(_DWORD *)(v10 + 48)) {
              float v43 = 1.0;
            }
            *(_DWORD *)(v10 + 60) = v42 + (float)(v43 * (float)*(unsigned int *)(a1 + 196));
            uint64_t v39 = *(void *)(a1 + 840);
            unint64_t v40 = (_DWORD *)(v39 + 64);
            unsigned int v41 = *(_DWORD *)(v39 + 64);
          }

          uint64_t v44 = *(unsigned int *)(a1 + 196);
          unsigned int v45 = (*(_DWORD *)(v39 + 60) + (v44 >> 1)) / v44 * v44;
          BOOL v18 = v38 >= v10;
          unint64_t v46 = v38 - v10;
          if ((_DWORD)v46 != 0 && v18) {
            unint64_t v47 = v44 * (unint64_t)v10 / v46;
          }
          else {
            unint64_t v47 = 0LL;
          }
          unint64_t v48 = v44 * (unint64_t)v10 / (v45 - v10);
          if (v48 >= v47) {
            unint64_t v48 = v47;
          }
          if (v47)
          {
            unint64_t v49 = *(unsigned int *)(a1 + 288);
            if (v47 <= v49)
            {
              *(_DWORD *)(a1 + 288) = v49 - v47;
              uint64_t v50 = v44 + v10;
              char v51 = *(_BYTE *)(a1 + 260);
              LODWORD(v10) = v44 + v10;
              if (v50 >= 0xFFFFLL << v51) {
                LODWORD(v10) = 0xFFFF << v51;
              }
            }
          }
        }

        goto LABEL_29;
      }

      unint64_t v20 = *(_DWORD *)(a1 + 288) + v9;
      *(_DWORD *)(a1 + 288) = v20;
      unint64_t v21 = (unint64_t)(v10 << 20) / *(void *)(v8 + 40);
      if (v21 > v20)
      {
LABEL_29:
        unint64_t v23 = *(unsigned int *)(a1 + 196);
        int v24 = *(_DWORD *)(a1 + 200);
        LODWORD(v10) = (v10 + (v23 >> 1)) / v23 * v23;
        else {
          uint64_t v10 = v10;
        }
        *(_DWORD *)(a1 + 144) = v10;
        else {
          unint64_t v25 = 100LL;
        }
        unint64_t v26 = 1000 * (v10 << (v10 < *(_DWORD *)(a1 + 148))) / v25;
        *(void *)(a1 + 480) = v26;
        if (v26 >> 12 >= v23) {
          int v27 = v26 >> 12;
        }
        else {
          int v27 = v23;
        }
        *(_DWORD *)(a1 + 488) = v27;
        return;
      }

      *(_DWORD *)(a1 + 288) = v20 - v21;
      unsigned int v9 = *(_DWORD *)(a1 + 196);
LABEL_28:
      LODWORD(v10) = v9 + v10;
      goto LABEL_29;
    }

    if (*(_DWORD *)(sysctls + 304))
    {
      int v11 = *(_DWORD *)(sysctls + 16);
    }

    else
    {
      if (!*(_DWORD *)(sysctls + 276))
      {
        unsigned int v22 = 4380;
LABEL_26:
        if (v9 >= v22) {
          unsigned int v9 = v22;
        }
        goto LABEL_28;
      }

      int v11 = 10;
    }

    unsigned int v22 = *(_DWORD *)(a1 + 196) * v11;
    goto LABEL_26;
  }

uint64_t tcp_prague_pre_fr(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 840) + 52LL) = 0;
  if ((*(_BYTE *)(a1 + 742) & 0x10) != 0)
  {
    uint64_t result = tcp_flight_size((_DWORD *)a1);
    unsigned int v3 = *(_DWORD *)(a1 + 980);
  }

  else
  {
    uint64_t result = 0LL;
    unsigned int v3 = *(_DWORD *)(a1 + 144);
  }

  *(_DWORD *)(a1 + 984) = result;
  uint64_t v4 = *(void *)(a1 + 840);
  float v5 = (float)v3;
  if (v3 < *(_DWORD *)(v4 + 48)) {
    unsigned int v3 = (float)((float)v3 * 0.85);
  }
  *(_DWORD *)(v4 + 48) = v3;
  unsigned int v6 = *(_DWORD *)(a1 + 196);
  unsigned int v7 = ((float)(v5 * 0.7) + (v6 >> 1)) / v6 * v6;
  unsigned int v8 = 2 * v6;
  if (v7 > v8) {
    unsigned int v8 = v7;
  }
  *(_DWORD *)(a1 + 148) = v8;
  unsigned int v9 = *(_DWORD **)(*(void *)(a1 + 80) + 224LL);
  if (v9[97] > v8)
  {
    int v10 = v9[108];
    if ((v10 & 0x400) != 0)
    {
      if (v9[109] > v8)
      {
        if (v8 >= *(_DWORD *)(sysctls + 120)) {
          unsigned int v8 = *(_DWORD *)(sysctls + 120);
        }
        v9[109] = v8;
      }

      v9[108] = v10 | 0x800;
    }
  }

  ++**(_WORD **)(a1 + 840);
  *(_BYTE *)(*(void *)(a1 + 840) + 28LL) |= 2u;
  *(_BYTE *)(*(void *)(a1 + 840) + 28LL) &= ~4u;
  return result;
}

uint64_t tcp_prague_post_fr(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 148);
  *(_DWORD *)(result + 144) = v1;
  unint64_t v3 = *(unsigned int *)(result + 196);
  int v2 = *(_DWORD *)(result + 200);
  else {
    unint64_t v4 = 100LL;
  }
  unint64_t v5 = 1000 * (unint64_t)v1 / v4;
  *(void *)(result + 480) = v5;
  if (v5 >> 12 >= v3) {
    int v6 = v5 >> 12;
  }
  else {
    int v6 = v3;
  }
  *(_DWORD *)(result + 488) = v6;
  *(_DWORD *)(*(void *)(result + 840) + 60LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 64LL) = 0;
  *(_BYTE *)(*(void *)(result + 840) + 28LL) &= ~2u;
  return result;
}

void tcp_prague_after_timeout(uint64_t a1)
{
  if (!*(void *)(a1 + 840))
  {
    int v2 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    unint64_t v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v3);
  }

  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      *(_DWORD *)(a1 + 504) = 0;
      **(_WORD **)(a1 + 840) = 0;
      *(_WORD *)(*(void *)(a1 + 840) + 2LL) = 0;
      *(void *)(*(void *)(a1 + 840) + 40LL) = 0x100000LL;
      *(_DWORD *)(*(void *)(a1 + 840) + 76LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 52LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 56LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 48LL) = 0;
      tcp_prague_pre_fr(a1);
    }

    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }

void tcp_prague_process_ecn(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t v10 = *(void *)(a1 + 840);
  unsigned int v11 = *(_DWORD *)(v10 + 12);
  if (v11 <= a4 && *(_DWORD *)(v10 + 4) <= a5)
  {
    if (v11 >= a4) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v12 = *(void *)(a1 + 840);
  int v13 = *(_DWORD *)(v12 + 12);
  LODWORD(v12) = *(_DWORD *)(v12 + 4);
  *(_DWORD *)__int128 buf = 136447234;
  unint64_t v49 = "tcp_prague_process_ecn";
  __int16 v50 = 1024;
  unsigned int v51 = a4;
  __int16 v52 = 1024;
  int v53 = v13;
  __int16 v54 = 1024;
  unsigned int v55 = a5;
  __int16 v56 = 1024;
  int v57 = v12;
  uint64_t v14 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    unsigned int v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      uint64_t v42 = *(void *)(a1 + 840);
      int v43 = *(_DWORD *)(v42 + 12);
      LODWORD(v42) = *(_DWORD *)(v42 + 4);
      *(_DWORD *)__int128 buf = 136447234;
      unint64_t v49 = "tcp_prague_process_ecn";
      __int16 v50 = 1024;
      unsigned int v51 = a4;
      __int16 v52 = 1024;
      int v53 = v43;
      __int16 v54 = 1024;
      unsigned int v55 = a5;
      __int16 v56 = 1024;
      int v57 = v42;
      _os_log_impl( &dword_1879E5000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s new CE count (%u) can't be less than current CE count (%u)OR newly ACKed (%u) can't be less that curr ent ACKed (%u), backtrace limit exceeded",  buf,  0x24u);
    }
  }

  if (v14) {
    free(v14);
  }
  uint64_t v10 = *(void *)(a1 + 840);
  if (*(_DWORD *)(v10 + 12) < a4)
  {
LABEL_6:
    *(_BYTE *)(v10 + 28) |= 1u;
    uint64_t v10 = *(void *)(a1 + 840);
  }

LABEL_7:
  unsigned int v15 = *(_DWORD *)(v10 + 4);
  BOOL v16 = a5 >= v15;
  unsigned int v17 = a5 - v15;
  if (v17 != 0 && v16)
  {
    int v18 = *(_DWORD *)(v10 + 20);
    if (v18) {
      BOOL v19 = *(_DWORD *)(a2 + 8) - v18 <= 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unint64_t v46 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v49 = "prague_update_alpha";
          _os_log_impl( &dword_1879E5000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s one RTT hasn't elapsed, not updating alpha",  buf,  0xCu);
        }
      }
    }

    else if ((*(_BYTE *)(v10 + 28) & 1) != 0)
    {
      unsigned int v20 = *(_DWORD *)(v10 + 8);
      BOOL v16 = a4 >= v20;
      unsigned int v21 = a4 - v20;
      BOOL v19 = v21 != 0 && v16;
      unsigned int v22 = v21 << 20;
      if (!v19) {
        unsigned int v22 = 0;
      }
      unint64_t v23 = *(void *)(v10 + 32) - (*(void *)(v10 + 32) >> 4) + v22 / v17;
      if (v23 >= 0x1000000) {
        unint64_t v23 = 0x1000000LL;
      }
      *(void *)(v10 + 32) = v23;
      *(_DWORD *)(*(void *)(a1 + 840) + 20LL) = *(_DWORD *)(a1 + 100);
      *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = a4;
      *(_DWORD *)(*(void *)(a1 + 840) + 4LL) = a5;
    }
  }

  if (*(_DWORD *)(*(void *)(a1 + 840) + 12LL) != a4)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v44 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v45 = a4 - *(_DWORD *)(*(void *)(a1 + 840) + 12LL);
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v49 = "tcp_prague_process_ecn";
        __int16 v50 = 1024;
        unsigned int v51 = v45;
        _os_log_impl(&dword_1879E5000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %u packets were newly CE marked", buf, 0x12u);
      }
    }

    uint64_t v24 = *(void *)(a1 + 840);
    unsigned int v25 = *(_DWORD *)(v24 + 16);
    BOOL v16 = v25 >= a3;
    unsigned int v26 = v25 - a3;
    if (!v16) {
      unsigned int v26 = 0;
    }
    *(_DWORD *)(v24 + 16) = v26;
    *(_DWORD *)(*(void *)(a1 + 840) + 12LL) = a4;
    unsigned int v27 = *(_DWORD *)(a1 + 200);
    BOOL v19 = v27 > 0x33F;
    unint64_t v28 = ((((v27 >> 5) * (v27 >> 5)) << 20) | 0x138) / 0x271uLL;
    if (v19) {
      unint64_t v28 = 0x100000LL;
    }
    *(void *)(*(void *)(a1 + 840) + 40LL) = v28;
    uint64_t v29 = *(void *)(a1 + 840);
    int v30 = *(_DWORD *)(v29 + 24);
    if (v30 && *(_DWORD *)(a2 + 8) - v30 <= 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v31 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v49 = "tcp_prague_process_ecn";
          _os_log_impl( &dword_1879E5000,  v31,  OS_LOG_TYPE_DEBUG,  "%{public}s one RTT hasn't elapsed, not doing CWR",  buf,  0xCu);
        }
      }
    }

    else
    {
      if ((*(_BYTE *)(v29 + 28) & 2) != 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          unint64_t v47 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unint64_t v49 = "prague_cwr";
            _os_log_impl( &dword_1879E5000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s currently in loss recovery, no need to do CWR",  buf,  0xCu);
          }
        }
      }

      else
      {
        ++*(_WORD *)(v29 + 2);
        uint64_t v32 = *(void *)(a1 + 840);
        unsigned int v33 = *(_DWORD *)(a1 + 144)
            - (((*(void *)(v32 + 32) >> 4) * (unint64_t)*(unsigned int *)(a1 + 144)) >> 21);
        *(_DWORD *)(a1 + 144) = v33;
        unsigned int v34 = *(_DWORD *)(a1 + 196);
        if (!*(_DWORD *)(v32 + 16))
        {
          unsigned int v33 = (v33 + (v34 >> 1)) / v34 * v34;
          *(_DWORD *)(a1 + 144) = v33;
        }

        unsigned int v35 = 2 * v34;
        if (v33 < v35)
        {
          *(_DWORD *)(a1 + 144) = v35;
          unsigned int v33 = v35;
        }

        *(_DWORD *)(a1 + 148) = v33;
        *(_BYTE *)(v32 + 28) |= 4u;
        unint64_t v37 = *(unsigned int *)(a1 + 196);
        int v36 = *(_DWORD *)(a1 + 200);
        else {
          unint64_t v38 = 100LL;
        }
        unint64_t v39 = 1000
        *(void *)(a1 + 480) = v39;
        if (v39 >> 12 >= v37) {
          int v40 = v39 >> 12;
        }
        else {
          int v40 = v37;
        }
        *(_DWORD *)(a1 + 488) = v40;
      }

      *(_DWORD *)(*(void *)(a1 + 840) + 24LL) = *(_DWORD *)(a1 + 100);
    }
  }

  if (*(_DWORD *)(a1 + 484))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 536);
    if ((v11 & 0x200) == 0) {
      goto LABEL_9;
    }
LABEL_18:
    uint64_t v12 = *(_DWORD *)(a1 + 432);
    if ((v12 & 0x200) != 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  *(_DWORD *)(a1 + 484) = 2048;
  *(_DWORD *)(a1 + 588) = 2048;
  unsigned int v11 = *(_DWORD *)(a1 + 536);
  if ((v11 & 0x200) != 0) {
    goto LABEL_18;
  }
LABEL_9:
  *(_DWORD *)(a1 + 536) = v11 | 0x400;
  uint64_t v12 = *(_DWORD *)(a1 + 432);
  if ((v12 & 0x200) == 0) {
LABEL_19:
  }
    *(_DWORD *)(a1 + 432) = v12 | 0x400;
LABEL_20:
  int v18 = *(_BYTE *)(v10 + 2236);
  if (v2 == 30) {
    BOOL v19 = 2;
  }
  else {
    BOOL v19 = 1;
  }
  unsigned int v20 = v18 | v19;
  *(_BYTE *)(v10 + 2236) = v18 | v19;
  unsigned int v21 = nw_tcp_access_globals(*(void *)(v10 + 224));
  calculate_tcp_clock(v21);
  *(_DWORD *)(v10 + 4104) = 0;
  *(void *)(v10 + 2240) = 0LL;
  unsigned int v22 = (_DWORD *)sysctls;
  unint64_t v23 = 152LL;
  if ((v20 & 2) == 0) {
    unint64_t v23 = 148LL;
  }
  uint64_t v24 = *(_DWORD *)(sysctls + v23);
  *(_DWORD *)(v10 + 2396) = v24;
  *(_DWORD *)(v10 + 2436) = v24;
  *(_DWORD *)(v10 + 2328) = 160;
  unsigned int v25 = *(_DWORD *)(v10 + 2980);
  unsigned int v26 = v25 | 0x20;
  *(_DWORD *)(v10 + 2980) = v25 | 0x20;
  if (v22[83])
  {
    unsigned int v26 = v25 | 0x20000020;
    *(_DWORD *)(v10 + 2980) = v25 | 0x20000020;
  }

  *(void *)(v10 + 2784) = 0LL;
  *(void *)(v10 + 2792) = v10 + 2784;
  *(void *)(v10 + 3192) = 0LL;
  *(void *)(v10 + 4224) = 0LL;
  *(void *)(v10 + 4232) = v10 + 4224;
  *(_OWORD *)(v10 + 4240) = 0u;
  *(void *)(v10 + 4256) = v10 + 4248;
  *(void *)(v10 + 4264) = 0LL;
  *(void *)(v10 + 4272) = v10 + 4264;
  *(void *)(v10 + 3272) = 0LL;
  *(void *)(v10 + 2320) = v10;
  *(_OWORD *)(v10 + 2440) = xmmword_187A43AE0;
  *(_DWORD *)(v10 + 2468) = v22[43];
  *(_DWORD *)(v10 + 2432) = 1000;
  if (v22[5])
  {
    unsigned int v27 = 1;
    *(_BYTE *)(v10 + 2504) = 1;
  }

  else
  {
    if (v22[76])
    {
      unsigned int v27 = 2;
    }

    else if ((v26 & 0x10000000) != 0 || (unsigned int v27 = 4, (v26 & 0x8000000) == 0) && v22[84] != 1 && tcp_do_l4s != 1)
    {
      unsigned int v27 = 3;
    }

    *(_BYTE *)(v10 + 2504) = v27;
    if (!*(void *)(v10 + 3080))
    {
      *(void *)(v10 + 3080) = v10 + 3088;
      *(_OWORD *)(v10 + 3088) = 0u;
      *(_OWORD *)(v10 + 3104) = 0u;
      *(_OWORD *)(v10 + 3120) = 0u;
      *(_OWORD *)(v10 + 3136) = 0u;
      *(_OWORD *)(v10 + 3152) = 0u;
    }
  }

  unsigned int v34 = *(void (**)(uint64_t))(tcp_cc_algo_list[v27] + 24);
  if (v34)
  {
    v34(v10 + 2240);
    unsigned int v22 = (_DWORD *)sysctls;
  }

  if (v22[77] == 1 && (v22[10] == 1 || (*(_BYTE *)(*(void *)(v10 + 224) + 369LL) & 0x40) != 0) && off_18C4CE818)
  {
    off_18C4CE818(v10 + 2240);
    unsigned int v22 = (_DWORD *)sysctls;
  }

  unsigned int v35 = v22[76];
  if (v35)
  {
    int v36 = v22[4];
LABEL_63:
    unint64_t v37 = *(_DWORD *)(v10 + 2436) * v36;
    goto LABEL_64;
  }

  if (v22[69])
  {
    int v36 = 10;
    goto LABEL_63;
  }

  unint64_t v37 = 4380;
LABEL_64:
  *(_DWORD *)(v10 + 2384) = v37;
  *(_DWORD *)(v10 + 2388) = 1073725440;
  *(_DWORD *)(v10 + 2748) = 1073725440;
  unint64_t v38 = *(_DWORD *)(v21 + 316);
  *(_DWORD *)(v10 + 2400) = v38;
  *(_DWORD *)(v10 + 2304) = v38;
  *(_DWORD *)(v10 + 2564) = v38;
  *(_DWORD *)(v10 + 2552) = v22[52];
  *(_DWORD *)(v10 + 2556) = 0;
  unint64_t v39 = *(_DWORD *)(v10 + 2980);
  *(_BYTE *)(v10 + 2550) = 3;
  *(_BYTE *)(v10 + 4308) = 1;
  *(_DWORD *)(v10 + 2420) = v38;
  if (v35)
  {
    int v40 = v22[4];
    unsigned int v41 = *(_DWORD *)(v10 + 2436);
  }

  else
  {
    uint64_t v42 = v22[69];
    unsigned int v41 = *(_DWORD *)(v10 + 2436);
    if (!v42)
    {
      int v43 = 4380;
      goto LABEL_69;
    }

    int v40 = 10;
  }

  int v43 = v41 * v40;
LABEL_69:
  *(_DWORD *)(v10 + 2428) = v43;
  *(_WORD *)(v10 + 2548) = 16;
  *(_DWORD *)(v10 + 4320) = 0;
  *(void *)(v10 + 4312) = 0LL;
  *(_OWORD *)(v10 + 3016) = 0u;
  *(_OWORD *)(v10 + 3032) = 0u;
  *(void *)(v10 + 3048) = 0LL;
  *(void *)(v10 + 3008) = v10 + 3016;
  *(_DWORD *)(v10 + 3028) = 6;
  *(_DWORD *)(v10 + 3036) = 6 * v41;
  *(_DWORD *)(v10 + 2980) = v39 | 0xA;
  *(_OWORD *)(v10 + 3064) = 0u;
  arc4random_buf(&__buf, 4uLL);
  uint64_t v44 = __buf;
  if (__buf <= 1) {
    unsigned int v45 = 1;
  }
  else {
    unsigned int v45 = __buf;
  }
  *(_DWORD *)(v10 + 4116) = v45;
  *(_DWORD *)(v10 + 4120) = *(_DWORD *)(v21 + 316);
  if (*(_DWORD *)(sysctls + 296)) {
    *(_DWORD *)(v10 + 4128) = v44;
  }
  *(void *)(v10 + 2600) = 0x100000001LL;
  *(void *)(v10 + 2872) = 0LL;
  *(void *)(v10 + 2880) = v10 + 2872;
  *(_DWORD *)(v10 + 2888) = 0;
  *(_DWORD *)(v10 + 2540) = 0;
  *(_BYTE *)(v10 + 2237) = 64;
  *(void *)(v10 + 240) = v10 + 2240;
  *(void *)(v10 + 3312) = 680LL;
  *(void *)(v10 + 3328) = 0LL;
  *(void *)(v10 + 3320) = 0LL;
  *(_DWORD *)(v10 + 2252) = 0;
  if (*(void *)(a1 + 24))
  {
    unint64_t v46 = nw_protocol_tcp_get_all_stats();
    if (v46) {
      *(_DWORD *)(v46 + 132) = *(unsigned __int8 *)(v10 + 2504);
    }
    if (*(void *)(a1 + 24))
    {
      unint64_t v47 = nw_protocol_tcp_get_all_stats();
      if (v47) {
        *(_DWORD *)(v47 + 136) = 0;
      }
    }
  }

  if ((*(_BYTE *)(a1 + 372) & 0x80) == 0 || *(_DWORD *)(a1 + 16)) {
    return 0LL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 16) = 120000;
  return result;
}

uint64_t tcp_prague_set_bytes_acked(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 840) + 16LL) = a2;
  return result;
}

void tcp_prague_switch_cc(uint64_t a1)
{
  do
    unsigned int v1 = __ldaxr(dword_18C6E9080);
  while (__stlxr(v1 + 1, dword_18C6E9080));
}

void tcp_enter_fast_recovery(uint64_t a1)
{
  int v2 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
  if (v2) {
    v2(a1);
  }
  *(_DWORD *)(a1 + 88) |= 0x200000u;
  uint64_t v3 = *(void *)(a1 + 80);
  int v4 = *(_DWORD *)(v3 + 2228);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v5 = *(void *)(v3 + 224);
    if ((v4 & 0x10000000) != 0)
    {
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      *(_DWORD *)(v5 + 364) &= ~0x20000u;
      if ((v4 & 0x50000000) == 0) {
        goto LABEL_13;
      }
    }

    else
    {
      int v6 = *(_DWORD *)(v5 + 364);
      *(_DWORD *)(v3 + 2228) = v4 & 0xAFFFFFFF;
      if ((v6 & 0x20000) != 0) {
        *(_DWORD *)(v5 + 364) = v6 & 0xFFFDFFFF;
      }
      if ((v4 & 0x50000000) == 0) {
        goto LABEL_13;
      }
    }

    unsigned int v7 = *(void (***)(void))(v5 + 32);
    if (v7)
    {
      unsigned int v8 = *v7;
      if (v8) {
        v8();
      }
    }
  }

uint64_t tcp_keepalive_reset(uint64_t a1)
{
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v3 = *(_DWORD *)(a1 + 676);
  if (!v3 || (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 372LL) & 8) == 0) {
    int v3 = *(_DWORD *)(sysctls + 192);
  }
  *(_DWORD *)(a1 + 40) = v3 + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 740) &= ~0x80u;
  *(_BYTE *)(a1 + 311) = 0;
  return result;
}

uint64_t tcp_set_finwait_timeout(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(sysctls + 316);
  if (!v2) {
    goto LABEL_6;
  }
  int v3 = *(_DWORD *)(a1 + 688);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 684);
    if (v4) {
      goto LABEL_4;
    }
  }

  else
  {
    int v3 = *(_DWORD *)(sysctls + 200);
    int v4 = *(_DWORD *)(a1 + 684);
    if (v4) {
      goto LABEL_4;
    }
  }

  int v4 = *(_DWORD *)(sysctls + 196);
LABEL_4:
  if (v2 < v4 * v3)
  {
    uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
    int v6 = *(_DWORD *)(sysctls + 316) + *(_DWORD *)(result + 316);
    goto LABEL_11;
  }

LABEL_6:
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v7 = *(_DWORD *)(a1 + 688);
  if (!v7) {
    int v7 = *(_DWORD *)(sysctls + 200);
  }
  int v8 = *(_DWORD *)(a1 + 684);
  if (!v8) {
    int v8 = *(_DWORD *)(sysctls + 196);
  }
  int v6 = *(_DWORD *)(result + 316) + v8 * v7;
LABEL_11:
  *(_DWORD *)(a1 + 44) = v6 - *(_DWORD *)(a1 + 64);
  return result;
}

uint64_t tcp_reset_stretch_ack(uint64_t a1)
{
  *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
  *(void *)(a1 + 328) = 0LL;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(result + 316) + 100;
  *(_DWORD *)(a1 + 740) |= 2u;
  *(_WORD *)(a1 + 344) = 0;
  return result;
}

BOOL tcp_detect_bad_rexmt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v5 = *(_DWORD *)(a1 + 740);
  if ((v5 & 0x10000000) == 0)
  {
    if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v6 = tcp_do_acc_ecn == 1) : (BOOL v6 = 1), v6))
    {
      if ((~*(_DWORD *)(a1 + 348) & 0x300000) == 0 && *(_DWORD *)(a1 + 424)) {
        return 0LL;
      }
    }
  }

  if ((~*(_DWORD *)(a1 + 348) & 3) == 0 && (*(_BYTE *)(a2 + 13) & 0x40) != 0) {
    return 0LL;
  }
  if ((~*(_DWORD *)(a1 + 88) & 0x180) == 0)
  {
    if (!a4) {
      return 0LL;
    }
    if ((*(_BYTE *)a3 & 1) == 0) {
      return 0LL;
    }
    int v7 = *(_DWORD *)(a3 + 8);
    return v7 && v7 - a4 < 0;
  }

  if (*(_WORD *)(a1 + 226) == 1)
  {
    if (!a4) {
      return 0LL;
    }
  }

  else if (!a4 || (v5 & 0x40001000) != 0x40001000)
  {
    return 0LL;
  }

  int v4 = *(_DWORD *)(a1 + 200);
  return *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316) - a4 < v4 >> 6;
}

BOOL tcp_input_get_aggregate_frames(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v16 = 0LL;
  unsigned int v17 = &v16;
  int v19 = 0;
  uint64_t v18 = 0x2000000000LL;
  v14[0] = 0LL;
  v14[1] = v14;
  int v15 = 0;
  v14[2] = 0x2000000000LL;
  uint64_t v10 = 0LL;
  unsigned int v11 = &v10;
  int v13 = 0;
  uint64_t v12 = 0x2000000000LL;
  unsigned int v7 = *(_DWORD *)(a1 + 552);
  if (v7 && *(void *)(a1 + 520))
  {
    if (v7 < a2) {
      a2 = *(_DWORD *)(a1 + 552);
    }
  }

  if (a3) {
    *a3 = *((_DWORD *)v17 + 6);
  }
  if (a4) {
    *a4 = *((_DWORD *)v11 + 6);
  }
  BOOL v8 = *((_DWORD *)v17 + 6) != 0;
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v8;
}

uint64_t __tcp_input_get_aggregate_frames_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
    uint64_t v10 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result) {
      goto LABEL_95;
    }
    free(v10);
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v58 = "__nw_frame_unclaimed_bytes";
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v58 = "__nw_frame_unclaimed_bytes";
        _os_log_impl( &dword_1879E5000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v12) {
      free(v12);
    }
    goto LABEL_17;
  }

  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && *MEMORY[0x189608EF8]
    && !((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88)))
  {
LABEL_17:
    unsigned int v6 = 0;
    goto LABEL_18;
  }

  int v5 = *(_DWORD *)(a2 + 52);
  uint64_t v4 = *(unsigned int *)(a2 + 56);
  if (v5)
  {
    unsigned int v6 = v5 - (v4 + *(_DWORD *)(a2 + 60));
    uint64_t v7 = *(void *)(a2 + 112);
    if (!v7)
    {
LABEL_18:
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v58 = "tcp_input_get_aggregate_frames_block_invoke";
      int v15 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if (!(_DWORD)result)
      {
        free(v15);
        uint64_t v8 = 0LL;
        goto LABEL_20;
      }

uint64_t tcp_input_aggregate_end(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (__nwlog_is_datapath_logging_enabled())
  {
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(_DWORD *)(a1 + 552);
      int v14 = *(_DWORD *)(a1 + 488);
      *(_DWORD *)__int128 buf = 136446722;
      int v18 = "tcp_input_aggregate_end";
      __int16 v19 = 1024;
      int v20 = v13;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_1879E5000, v12, OS_LOG_TYPE_DEBUG, "%{public}s start sb_agg_bytes %u sb_cc %u", buf, 0x18u);
    }
  }

  if (*(_DWORD *)(a1 + 552))
  {
    while (*(void *)(a1 + 520))
    {
      uint64_t v15 = 0LL;
      uint64_t v16 = &v15;
      if (!tcp_input_get_aggregate_frames(a1, *(_DWORD *)(a1 + 824), 0LL, 0LL, (uint64_t)&v15))
      {
        unsigned int v9 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          int v10 = *(_DWORD *)(a1 + 548);
          int v11 = *(_DWORD *)(a1 + 552);
          *(_DWORD *)__int128 buf = 136446722;
          int v18 = "tcp_input_aggregate_end";
          __int16 v19 = 1024;
          int v20 = v10;
          __int16 v21 = 1024;
          int v22 = v11;
          _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s tcp_input_get_aggregate_frame failed, drop %u segments of length %u",  buf,  0x18u);
        }

        tcp_drop(a2, 53);
        return 0xFFFFFFFFLL;
      }

      if (v15)
      {
        **(void **)(a1 + 512) = v15;
        uint64_t v4 = v16;
        *(void *)(v15 + 40) = *(void *)(a1 + 512);
        *(void *)(a1 + 512) = v4;
        uint64_t v15 = 0LL;
        uint64_t v16 = &v15;
      }

      if (__nwlog_is_datapath_logging_enabled())
      {
        int v5 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          int v6 = *(_DWORD *)(a1 + 552);
          int v7 = *(_DWORD *)(a1 + 488);
          *(_DWORD *)__int128 buf = 136446722;
          int v18 = "tcp_input_aggregate_end";
          __int16 v19 = 1024;
          int v20 = v6;
          __int16 v21 = 1024;
          int v22 = v7;
          _os_log_impl( &dword_1879E5000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s added agg frame to sb_mb sb_agg_bytes %u sb_cc %u",  buf,  0x18u);
        }
      }

      if (!*(_DWORD *)(a1 + 552)) {
        break;
      }
    }
  }

  sb_agg_empty_verify((int *)(a1 + 488), (uint64_t)"tcp_input_aggregate_end");
  return 0LL;
}

void *tcp_input(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4, _BYTE *a5, BOOL *a6)
{
  uint64_t v925 = *MEMORY[0x1895F89C0];
  uint64_t v12 = nw_frame_array_first();
  uint64_t v13 = v12;
  uint64_t v14 = *(void *)(a3 + 240);
  uint64_t v15 = *(void *)(a3 + 224);
  uint64_t v896 = 0LL;
  uint64_t v895 = 0LL;
  memset(v894, 0, sizeof(v894));
  if (!v12)
  {
    v825 = a5;
    uint64_t v836 = v14;
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v900 = "__nw_frame_get_ecn_flag";
    __int16 v19 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(v920) = 16;
    v897[0] = OS_LOG_TYPE_DEFAULT;
    if (v920 == 17)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v920;
      if (!os_log_type_enabled(v20, (os_log_type_t)v920)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v900 = "__nw_frame_get_ecn_flag";
      int v22 = "%{public}s called with null frame";
    }

    else
    {
      int v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = v920;
      if (!os_log_type_enabled(v20, (os_log_type_t)v920)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      v900 = "__nw_frame_get_ecn_flag";
      int v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v20, v21, v22, buf, 0xCu);
LABEL_20:
    if (v19) {
      free(v19);
    }
    unsigned int log = 0;
    uint64_t v14 = v836;
    a5 = v825;
    v890 = a6;
    if (a2) {
      goto LABEL_3;
    }
LABEL_23:
    int v17 = 0;
    int v16 = 0;
    BOOL v18 = 0;
    goto LABEL_24;
  }

  unsigned int log = *(_BYTE *)(v12 + 186) & 3;
  v890 = a6;
  if (!a2) {
    goto LABEL_23;
  }
LABEL_3:
  if (*(unsigned __int8 *)(a2 + 1076) == 255 || *(_DWORD *)(a2 + 1024) == 255)
  {
    int v16 = 1;
    goto LABEL_6;
  }

  if (*(_DWORD *)(a2 + 1068) == 3)
  {
    int v16 = 0;
    BOOL v18 = 0;
    int v17 = 1;
  }

  else
  {
    int v16 = 0;
    if (*(_DWORD *)(a2 + 1032) != 3)
    {
LABEL_6:
      int v17 = 0;
      BOOL v18 = *(_DWORD *)(a2 + 1064) == 2 || *(_DWORD *)(a2 + 1028) == 2;
      goto LABEL_24;
    }

    int v17 = 1;
    BOOL v18 = 0;
  }

LABEL_32:
  if (!v13 || !v14) {
    goto LABEL_45;
  }
  v848 = a4;
  uint64_t v28 = *(void *)(v13 + 112);
  uint64_t v29 = (void *)MEMORY[0x189608EF8];
  if (!v28)
  {
LABEL_41:
    if ((*(_WORD *)(v13 + 204) & 0x100) != 0
      && *v29
      && (((uint64_t (*)(uint64_t, void))*v29)(v13, *(void *)(v13 + 88)) & 1) == 0)
    {
      *(void *)(v14 + 1056) = 0LL;
    }

LABEL_45:
    uint64_t v41 = *(void *)(v14 + 1056);
    if (v41)
    {
      ++*(void *)(v41 + 152);
      ++*(void *)(v41 + 232);
    }

    in_pcb_checkstate(a3, 2LL, 1);
    uint64_t v42 = v890;
    int v43 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0) {
      goto LABEL_65;
    }
    uint64_t v44 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_INFO)) {
      goto LABEL_65;
    }
    unsigned int v45 = "";
    if (v15) {
      unsigned int v45 = (const char *)(v15 + 604);
    }
    *(_DWORD *)__int128 buf = 136446466;
    v900 = "tcp_input";
    __int16 v901 = 2082;
    *(void *)v902 = v45;
    unint64_t v46 = "%{public}s %{public}s failed to get tcp header";
    unsigned int v47 = v44;
    os_log_type_t v48 = OS_LOG_TYPE_INFO;
LABEL_63:
    uint32_t v53 = 22;
LABEL_64:
    _os_log_impl(&dword_1879E5000, v47, v48, v46, buf, v53);
LABEL_65:
    int v54 = 0;
    goto LABEL_66;
  }

  if ((*(_WORD *)(v13 + 204) & 0x100) != 0 && *MEMORY[0x189608EF8])
  {
    int v30 = v17;
    int v31 = v16;
    uint64_t v32 = a3;
    BOOL v33 = v18;
    uint64_t v34 = v15;
    uint64_t v35 = v23;
    int v36 = ((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v13, *(void *)(v13 + 88));
    uint64_t v24 = v35;
    uint64_t v15 = v34;
    BOOL v18 = v33;
    a3 = v32;
    int v16 = v31;
    int v17 = v30;
    uint64_t v29 = (void *)MEMORY[0x189608EF8];
    if (v36)
    {
      uint64_t v37 = *(void *)(v13 + 112);
      if (v37)
      {
        uint64_t v38 = *(unsigned int *)(v13 + 56);
        uint64_t v39 = v37 + v38;
        int v40 = *(_DWORD *)(v13 + 52);
        if (!v40) {
          goto LABEL_55;
        }
        goto LABEL_54;
      }
    }

    goto LABEL_41;
  }

  uint64_t v38 = *(unsigned int *)(v13 + 56);
  uint64_t v39 = v28 + v38;
  int v40 = *(_DWORD *)(v13 + 52);
  if (!v40)
  {
LABEL_55:
    uint64_t v50 = *(void *)(v14 + 1056);
    if (v50)
    {
      ++*(void *)(v50 + 152);
      ++*(void *)(v50 + 368);
    }

    in_pcb_checkstate(a3, 2LL, 1);
    uint64_t v42 = v890;
    int v43 = a1;
    if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0) {
      goto LABEL_65;
    }
    uint64_t v51 = (os_log_s *)__nwlog_tcp_log();
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      goto LABEL_65;
    }
    unsigned int v52 = "";
    if (v15) {
      unsigned int v52 = (const char *)(v15 + 604);
    }
    *(_DWORD *)__int128 buf = 136446466;
    v900 = "tcp_input";
    __int16 v901 = 2082;
    *(void *)v902 = v52;
    unint64_t v46 = "%{public}s %{public}s buffer smaller than tcp header";
    unsigned int v47 = v51;
    os_log_type_t v48 = OS_LOG_TYPE_ERROR;
    goto LABEL_63;
  }

LABEL_400:
              int v166 = *(_DWORD *)(v121 + 12);
              if (v166 == 4)
              {
                int v178 = *(_DWORD *)(v121 + 348);
                if ((v178 & 1) == 0)
                {
                  if (log == 3)
                  {
LABEL_411:
                    int v821 = 1;
                    if ((~v178 & 3) == 0 || (v178 & 0x2000) != 0) {
                      goto LABEL_420;
                    }
                    uint64_t v179 = *(void *)(v121 + 1056);
                    if (v179) {
                      ++*(void *)(v179 + 944);
                    }
                    tcp_heuristic_ecn_aggressive(v121);
                    *(_DWORD *)(v121 + 348) |= 0x2000u;
                    int v166 = *(_DWORD *)(v121 + 12);
                    int v821 = 1;
                    uint64_t v164 = v835;
LABEL_418:
                    if (v166 != 4) {
                      goto LABEL_433;
                    }
                    int v178 = *(_DWORD *)(v121 + 348);
LABEL_420:
                    if (v821 && (v178 & 0x2003) == 3)
                    {
                      unsigned int v180 = *(unsigned __int8 *)(v121 + 733);
                      if (**(void **)(a3 + 248) > 9uLL)
                      {
                        if (v180 >= 8)
                        {
                          uint64_t v181 = *(void *)(v121 + 1056);
                          if (v181) {
                            ++*(void *)(v181 + 944);
                          }
                          tcp_heuristic_ecn_aggressive(v121);
                          *(_DWORD *)(v121 + 348) |= 0x2000u;
                          uint64_t v182 = *(void *)(a3 + 448);
                          if (v182)
                          {
                            if ((*(_BYTE *)(a3 + 2236) & 2) != 0) {
                              ++*(void *)(v182 + 640);
                            }
                            else {
                              ++*(void *)(v182 + 256);
                            }
                            int v821 = 1;
                            uint64_t v164 = v835;
                            LOBYTE(v130) = v881;
                          }

                          else
                          {
                            int v821 = 1;
                            uint64_t v164 = v835;
                            LOBYTE(v130) = v881;
                          }

                          goto LABEL_432;
                        }

                        *(_DWORD *)(v121 + 348) = v178 | 0x2000;
                      }

                      else
                      {
                        *(_BYTE *)(v121 + 733) = v180 + 1;
                      }

                      int v821 = 1;
                    }

LABEL_432:
                    int v166 = *(_DWORD *)(v121 + 12);
LABEL_433:
                    *(_DWORD *)(v121 + 160) = *(_DWORD *)(v164 + 316);
                    if (v166 >= 4)
                    {
                      tcp_keepalive_reset(v121);
                      int v166 = *(_DWORD *)(v121 + 12);
                    }

                    if (v166 != 1 && v129)
                    {
                      tcp_dooptions(v121, v129, v830, (uint64_t)&v920, (uint64_t)v894);
                      int v166 = *(_DWORD *)(v121 + 12);
                    }

                    if ((v130 & 2) != 0 && v166 == 2)
                    {
                      if ((v130 & 0x10) != 0
                        && (DWORD2(v920) - *(_DWORD *)(v121 + 112) < 1 || DWORD2(v920) - *(_DWORD *)(v121 + 96) > 0))
                      {
LABEL_461:
                        *(_DWORD *)(v121 + 744) = 0;
                        goto LABEL_462;
                      }

                      tcp_finalize_options(v121, (int *)v894, v838);
                      int v166 = *(_DWORD *)(v121 + 12);
                    }

                    if ((v130 & 0x7F) != 0x10
                      || v166 != 4
                      || (*(_BYTE *)(v121 + 89) & 8) != 0
                      || (v894[0] & 1) != 0 && DWORD1(v894[0]) - *(_DWORD *)(v121 + 276) < 0
                      || DWORD1(v920) != *(_DWORD *)(v121 + 120)
                      || *(void *)v121)
                    {
                      goto LABEL_461;
                    }

                    unsigned int v183 = *(unsigned __int16 *)(v121 + 752);
                    if (v183 <= 0x28) {
                      *(_WORD *)(v121 + 752) = v183 + v823;
                    }
                    int v184 = *(unsigned __int16 *)(v121 + 748);
                    if (*(_WORD *)(v121 + 748) && v843 <= v184)
                    {
                      if (v843 != v184)
                      {
LABEL_456:
                        if (v843 < v184)
                        {
                          unsigned int v186 = (*(_BYTE *)(v121 + 750) + v823);
                          *(_BYTE *)(v121 + 750) += v823;
                          if (v186 < 0x15)
                          {
                            *(_DWORD *)(v121 + 744) = 0;
                          }

                          else
                          {
                            *(_WORD *)(v121 + 748) = v843;
                            *(_DWORD *)(v121 + 744) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v121 + 80)
                                                                                                  + 224LL))
                                                                + 316);
                            *(_BYTE *)(v121 + 750) = 0;
                          }

                          goto LABEL_462;
                        }

                        uint64_t v192 = v121;
                        goto LABEL_530;
                      }

                      int v185 = *(_DWORD *)(v121 + 744);
                      if (v185)
                      {
                        compute_iaj_meat(v121, *(_DWORD *)(v835 + 316) - v185);
                        int v184 = *(unsigned __int16 *)(v121 + 748);
                        goto LABEL_456;
                      }
                    }

                    uint64_t v192 = v121;
LABEL_530:
                    update_iaj_state(v192, v843);
LABEL_462:
                    if (*(_DWORD *)(v121 + 12) != 4) {
                      goto LABEL_553;
                    }
                    if ((v881 & 0xFFFFFFF7) != 0x10) {
                      goto LABEL_553;
                    }
                    if ((*(_WORD *)(v15 + 376) & 0x20) != 0) {
                      goto LABEL_553;
                    }
                    int v187 = *(_DWORD *)(v121 + 88);
                    if ((v187 & 0x800) != 0 || (v894[0] & 1) != 0 && DWORD1(v894[0]) - *(_DWORD *)(v121 + 276) < 0) {
                      goto LABEL_553;
                    }
                    if (DWORD1(v920) != *(_DWORD *)(v121 + 120)) {
                      goto LABEL_553;
                    }
                    if (!v820) {
                      goto LABEL_553;
                    }
                    if (v820 != *(_DWORD *)(v121 + 140)) {
                      goto LABEL_553;
                    }
                    int v188 = *(_DWORD *)(v121 + 100);
                    if (v188 != *(_DWORD *)(v121 + 96)) {
                      goto LABEL_553;
                    }
                    if ((v894[0] & 1) != 0 && DWORD1(v920) - *(_DWORD *)(v837 + 284) <= 0)
                    {
                      *(_DWORD *)(v837 + 280) = *(_DWORD *)(v835 + 316);
                      *(_DWORD *)(v837 + 276) = DWORD1(v894[0]);
                    }

                    int v189 = *(_DWORD *)(v837 + 740);
                    if ((v189 & 0x10000000) == 0
                      && ((v189 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
                    {
                      char v190 = v821 ^ 1;
                      if ((~*(_DWORD *)(v837 + 348) & 0x300000) != 0) {
                        char v190 = 1;
                      }
                      if ((v190 & 1) == 0) {
                        *(_WORD *)(v837 + 306) += v823;
                      }
                    }

                    int v191 = *(_DWORD *)(v837 + 92);
                    if ((_DWORD)v71 == (_DWORD)v846)
                    {
                      uint64_t v121 = v837;
                      if (DWORD2(v920) - v188 <= 0
                        && DWORD2(v920) - v191 >= 1
                        && (v187 & 0x200000) == 0
                        && *(_DWORD *)(v837 + 144) >= *(_DWORD *)(v837 + 148))
                      {
                        if ((v189 & 0x20) != 0)
                        {
                          uint64_t v121 = v837;
                          if (!HIBYTE(v894[0]) && !*(void *)(v837 + 544)) {
                            goto LABEL_1452;
                          }
                        }

                        else
                        {
                          uint64_t v121 = v837;
                          if (*(_DWORD *)(v837 + 8) < (int)*(unsigned __int8 *)(v837 + 310))
                          {
LABEL_1452:
                            uint64_t v564 = *(void *)(v121 + 1056);
                            if (v564) {
                              ++*(void *)(v564 + 544);
                            }
                            tcp_bad_rexmt_check(v837, (uint64_t)&v920, (uint64_t)v894);
                            tcp_compute_rtt(v837, (uint64_t)v894, (uint64_t)&v920);
                            int v565 = DWORD2(v920);
                            int v566 = *(_DWORD *)(v837 + 92);
                            int v567 = DWORD2(v920) - v566;
                            if (DWORD2(v920) - v566 >= 0)
                            {
LABEL_1455:
                              uint64_t v568 = *(void *)(v837 + 1056);
                              if (v568)
                              {
                                uint64_t v569 = *(void *)(v568 + 168) + v567;
                                ++*(void *)(v568 + 160);
                                *(void *)(v568 + 168) = v569;
                              }

                              int v570 = *(_DWORD *)(v837 + 740);
                              if ((v570 & 0x10000000) != 0
                                || (v570 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                                || (~*(_DWORD *)(v837 + 348) & 0x300004) != 0)
                              {
                                goto LABEL_1930;
                              }

                              if ((v570 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
                              {
LABEL_1919:
                                unsigned int v730 = *(_DWORD *)(v837 + 196);
                                if (v567 / v730 * v730 == v567) {
                                  unsigned int v731 = v567 / v730;
                                }
                                else {
                                  unsigned int v731 = v567 / v730 + 1;
                                }
                                *(_DWORD *)(v837 + 296) += v731;
                                if (v565 == v566)
                                {
                                  BOOL v732 = 0;
                                  if ((v894[0] & 1) != 0 && DWORD2(v894[0])) {
                                    BOOL v732 = DWORD2(v894[0]) - *(_DWORD *)(v837 + 400) > 0;
                                  }
                                }

                                else
                                {
                                  BOOL v732 = 0;
                                }

                                if (v567 > 0 || v732) {
                                  tcp_process_accecn(v837, (uint64_t)v894, (uint64_t)&v920, v731, v819);
                                }
LABEL_1930:
                                if ((*(_DWORD *)(v837 + 740) & 0x20400020) == 0x20000020)
                                {
                                  tcp_segs_doack(v837, DWORD2(v920), v894[0], SDWORD2(v894[0]));
                                  if (*(_DWORD *)(v837 + 560) - DWORD2(v920) < 0) {
                                    *(_DWORD *)(v837 + 560) = DWORD2(v920);
                                  }
                                }

                                v733 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v837 + 264)]
                                                                                  + 48);
                                if (v733) {
                                  v733(v837, &v920);
                                }
                                sbdrop((int *)(v15 + 384), v567);
                                tcp_sbsnd_trim(v15 + 384);
                                int v734 = *(_DWORD *)(v837 + 152);
                                int v735 = DWORD2(v920);
                                if (*(_DWORD *)(v837 + 92) - v734 >= 1 && DWORD2(v920) - v734 <= 0) {
                                  *(_DWORD *)(v837 + 152) = DWORD2(v920) - 1;
                                }
                                tcp_update_snd_una(v837, v735);
                                *(_WORD *)(v837 + 226) = 0;
                                *(_DWORD *)(v837 + 248) = 0;
                                *(_DWORD *)(v837 + 108) = DWORD2(v920);
                                if (*(int *)(v837 + 8) >= 1)
                                {
                                  *(_DWORD *)(v837 + 8) = 0;
                                  *(_BYTE *)(v837 + 310) = 3;
                                }

                                *(_DWORD *)(v837 + 628) = 0;
                                if (*(_DWORD *)(v837 + 92) == *(_DWORD *)(v837 + 96))
                                {
                                  *(_DWORD *)(v837 + 16) = 0;
                                  *(void *)(v837 + 24) = 0LL;
                                  *(_BYTE *)(v837 + 2069) &= ~0x80u;
                                }

                                else if (!*(_DWORD *)(v837 + 36))
                                {
                                  *(_DWORD *)(v837 + 28) = *(_DWORD *)(v837 + 192)
                                                         + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v837 + 80) + 224LL))
                                                                     + 316)
                                                         - *(_DWORD *)(v837 + 64);
                                }

                                if (*(void *)(v837 + 952))
                                {
                                  int v736 = *(_DWORD *)(v837 + 960);
                                  if (v736 - *(_DWORD *)(v837 + 96) > 0) {
                                    goto LABEL_1946;
                                  }
                                  unsigned int v737 = *(_DWORD *)(v837 + 140);
                                  if (v737 >= *(_DWORD *)(sysctls + 120)) {
                                    unsigned int v737 = *(_DWORD *)(sysctls + 120);
                                  }
                                  if ((int)(v736 - *(_DWORD *)(v837 + 92) + v737) < 0) {
LABEL_1946:
                                  }
                                    tcp_rxtseg_clean(v837);
                                }

                                if ((*(_BYTE *)(v837 + 740) & 8) != 0 && *(void *)(v837 + 768)) {
                                  tcp_bwmeas_check(v837);
                                }
                                v738 = *(void (***)(uint64_t))(v15 + 32);
                                if (v738)
                                {
                                  v739 = *v738;
                                  if (v739) {
                                    v739(v15);
                                  }
                                }

                                if (!*(_DWORD *)(v15 + 384) && (*(_BYTE *)(v837 + 88) & 1) == 0
                                  || !tcp_output(v837)
                                  || (*(_WORD *)(v13 + 204) & 0x100) == 0
                                  || !*MEMORY[0x189608EF8]
                                  || (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)) & 1) != 0)
                                {
                                  tcp_tfo_rcv_ack(v837, (uint64_t)&v920);
                                  tcp_check_timer_state(v837);
                                  (*(void (**)(uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))(v15, 1LL);
                                  uint64_t result = (void *)*a1;
                                  if (!*a1) {
                                    return result;
                                  }
                                  while (1)
                                  {
                                    v740 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                    v741 = (void *)result[4];
                                    if (!v740) {
                                      break;
                                    }
                                    uint64_t v742 = result[11];
                                    result[10] = 0LL;
                                    result[11] = 0LL;
                                    v740(result, 1LL, v742);
LABEL_1965:
                                    uint64_t result = v741;
                                    if (!v741) {
                                      return result;
                                    }
                                  }

                                  __nwlog_obj();
                                  *(_DWORD *)__int128 buf = 136446210;
                                  v900 = "__nw_frame_finalize";
                                  uint64_t v743 = _os_log_send_and_compose_impl();
                                  type[0] = OS_LOG_TYPE_ERROR;
                                  char v898 = 0;
                                  v889 = (void *)v743;
                                  if (__nwlog_fault())
                                  {
                                    if (type[0] == OS_LOG_TYPE_FAULT)
                                    {
                                      v877 = (os_log_s *)__nwlog_obj();
                                      if (!os_log_type_enabled(v877, type[0])) {
                                        goto LABEL_1981;
                                      }
                                      *(_DWORD *)__int128 buf = 136446210;
                                      v900 = "__nw_frame_finalize";
                                      v744 = v877;
                                      os_log_type_t v745 = type[0];
                                      v746 = "%{public}s called with null frame->finalizer";
                                      goto LABEL_1980;
                                    }

                                    if (!v898)
                                    {
                                      v879 = (os_log_s *)__nwlog_obj();
                                      if (!os_log_type_enabled(v879, type[0])) {
                                        goto LABEL_1981;
                                      }
                                      *(_DWORD *)__int128 buf = 136446210;
                                      v900 = "__nw_frame_finalize";
                                      v744 = v879;
                                      os_log_type_t v745 = type[0];
                                      v746 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                      goto LABEL_1980;
                                    }

                                    backtrace_string = (void *)__nw_create_backtrace_string();
                                    logj = (os_log_s *)__nwlog_obj();
                                    BOOL v747 = os_log_type_enabled(logj, type[0]);
                                    if (backtrace_string)
                                    {
                                      if (v747)
                                      {
                                        *(_DWORD *)__int128 buf = 136446466;
                                        v900 = "__nw_frame_finalize";
                                        __int16 v901 = 2082;
                                        *(void *)v902 = backtrace_string;
                                        _os_log_impl( &dword_1879E5000,  logj,  type[0],  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
                                      }

                                      free(backtrace_string);
                                      goto LABEL_1981;
                                    }

                                    if (v747)
                                    {
                                      *(_DWORD *)__int128 buf = 136446210;
                                      v900 = "__nw_frame_finalize";
                                      v744 = logj;
                                      os_log_type_t v745 = type[0];
                                      v746 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1980:
                                      _os_log_impl(&dword_1879E5000, v744, v745, v746, buf, 0xCu);
                                    }
                                  }

LABEL_1981:
                                  if (v889) {
                                    free(v889);
                                  }
                                  goto LABEL_1965;
                                }

                                if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                {
                                  v800 = (os_log_s *)__nwlog_tcp_log();
                                  if (os_log_type_enabled(v800, OS_LOG_TYPE_INFO))
                                  {
                                    v801 = "";
                                    if (v15) {
                                      v801 = (const char *)(v15 + 604);
                                    }
                                    *(_DWORD *)__int128 buf = 136446466;
                                    v900 = "tcp_input";
                                    __int16 v901 = 2082;
                                    *(void *)v902 = v801;
                                    _os_log_impl( &dword_1879E5000,  v800,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping input packet since frame is no longer valid",  buf,  0x16u);
                                  }
                                }

                                *(void *)(v837 + 1056) = 0LL;
                                int v43 = a1;
                                uint64_t v42 = v890;
                                int v54 = v847;
LABEL_1289:
                                int v131 = v822;
                                goto LABEL_1328;
                              }

                              __nwlog_obj();
                              *(_DWORD *)__int128 buf = 136446210;
                              v900 = "tcp_input";
                              v571 = (void *)_os_log_send_and_compose_impl();
                              type[0] = OS_LOG_TYPE_ERROR;
                              char v898 = 0;
                              if (__nwlog_fault())
                              {
                                if (type[0] == OS_LOG_TYPE_FAULT)
                                {
                                  v572 = (os_log_s *)__nwlog_obj();
                                  os_log_type_t v573 = type[0];
                                  if (!os_log_type_enabled(v572, type[0])) {
                                    goto LABEL_1917;
                                  }
                                  *(_DWORD *)__int128 buf = 136446210;
                                  v900 = "tcp_input";
                                  v574 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not";
LABEL_1915:
                                  v728 = v572;
                                  os_log_type_t v729 = v573;
LABEL_1916:
                                  _os_log_impl(&dword_1879E5000, v728, v729, v574, buf, 0xCu);
                                  goto LABEL_1917;
                                }

                                if (!v898)
                                {
                                  v572 = (os_log_s *)__nwlog_obj();
                                  os_log_type_t v573 = type[0];
                                  if (!os_log_type_enabled(v572, type[0])) {
                                    goto LABEL_1917;
                                  }
                                  *(_DWORD *)__int128 buf = 136446210;
                                  v900 = "tcp_input";
                                  v574 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, backtrace limit exceeded";
                                  goto LABEL_1915;
                                }

                                v706 = (void *)__nw_create_backtrace_string();
                                v707 = (os_log_s *)__nwlog_obj();
                                BOOL v708 = os_log_type_enabled(v707, type[0]);
                                if (v706)
                                {
                                  if (v708)
                                  {
                                    *(_DWORD *)__int128 buf = 136446466;
                                    v900 = "tcp_input";
                                    __int16 v901 = 2082;
                                    *(void *)v902 = v706;
                                    _os_log_impl( &dword_1879E5000,  v707,  type[0],  "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, dumping backtrace:%{public}s",  buf,  0x16u);
                                  }

                                  free(v706);
                                  goto LABEL_1917;
                                }

                                if (v708)
                                {
                                  *(_DWORD *)__int128 buf = 136446210;
                                  v900 = "tcp_input";
                                  v574 = "%{public}s TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not, no backtrace";
                                  v728 = v707;
                                  os_log_type_t v729 = type[0];
                                  goto LABEL_1916;
                                }
                              }

LABEL_1917:
                              if (v571) {
                                free(v571);
                              }
                              goto LABEL_1919;
                            }

                            v795 = (os_log_s *)__nwlog_obj();
                            os_log_type_enabled(v795, OS_LOG_TYPE_ERROR);
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "tcp_input";
                            v796 = (void *)_os_log_send_and_compose_impl();
                            if (!__nwlog_abort())
                            {
                              free(v796);
                              int v565 = DWORD2(v920);
                              int v566 = *(_DWORD *)(v837 + 92);
                              int v567 = DWORD2(v920) - v566;
                              goto LABEL_1455;
                            }

                            goto LABEL_2096;
                          }
                        }
                      }

      if (v870) {
        free(v870);
      }
      unsigned int v25 = (void *)(a1 + 632);
      uint64_t v743 = v946;
      int v124 = a1 + 100;
      if ((_DWORD)v515 == 6) {
        goto LABEL_1903;
      }
      goto LABEL_1920;
    }

LABEL_553:
                      (*(void (**)(uint64_t, void))(*(void *)(v15 + 8) + 32LL))(v15, 0LL);
                      unsigned int v220 = tcp_sbspace(v121);
                      if ((v220 & 0x80000000) == 0)
                      {
                        int v43 = a1;
                        if ((*(_BYTE *)(v121 + 90) & 8) != 0)
                        {
                          int v222 = *(_DWORD *)(sysctls + 48);
                          unsigned int v223 = v220 >= v222 ? *(_DWORD *)(sysctls + 48) : v220;
                          if (v222 > 0) {
                            unsigned int v220 = v223;
                          }
                        }

LABEL_568:
                        int v227 = *(_DWORD *)(v121 + 120);
                        else {
                          unsigned int v228 = v220;
                        }
                        *(_DWORD *)(v121 + 128) = v228;
                        int v229 = *(_DWORD *)(v121 + 12);
                        LODWORD(v130) = v881;
                        switch(v229)
                        {
                          case 1:
                            tcp_dooptions(v121, v129, v830, (uint64_t)&v920, (uint64_t)v894);
                            tcp_finalize_options(v121, (int *)v894, v838);
                            if ((*(_BYTE *)(v121 + 742) & 0x40) != 0) {
                              int v839 = tcp_tfo_syn(v121, (uint64_t)v894);
                            }
                            else {
                              int v839 = 0;
                            }
                            int v245 = tcp_new_isn(v121);
                            int v246 = DWORD1(v920);
                            *(_DWORD *)(v121 + 112) = v245;
                            *(_DWORD *)(v121 + 116) = v246;
                            *(_DWORD *)(v121 + 152) = v245;
                            *(_DWORD *)(v121 + 96) = v245;
                            *(_DWORD *)(v121 + 100) = v245;
                            *(_DWORD *)(v121 + 92) = v245;
                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v247 = nw_protocol_tcp_get_all_stats();
                              int v245 = *(_DWORD *)(v121 + 92);
                              if (v247)
                              {
                                *(_DWORD *)(v247 + 108) = *(_DWORD *)(v121 + 96) - v245;
                                int v245 = *(_DWORD *)(v121 + 92);
                              }
                            }

                            int v248 = *(_DWORD *)(v121 + 116) + 1;
                            *(_DWORD *)(v121 + 1916) = v248;
                            *(_DWORD *)(v121 + 120) = v248;
                            *(_DWORD *)(v121 + 124) = v248;
                            *(_DWORD *)(v121 + 152) = v245;
                            *(_DWORD *)(v121 + 140) = v820;
                            *(_DWORD *)(v121 + 252) = v820;
                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v249 = nw_protocol_tcp_get_all_stats();
                              if (v249) {
                                *(_DWORD *)(v249 + 112) = *(_DWORD *)(v121 + 140);
                              }
                            }

                            *(_DWORD *)(v121 + 88) |= 1u;
                            *(_DWORD *)(v121 + 304) = 0;
                            v250 = (int64x2_t *)v121;
                            *(_DWORD *)(v121 + 12) = 3;
                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                            {
                              if (__nwlog_is_datapath_logging_enabled())
                              {
                                v641 = (os_log_s *)__nwlog_tcp_log();
                                if (os_log_type_enabled(v641, OS_LOG_TYPE_DEBUG))
                                {
                                  v642 = tcpstates[v250->i32[3]];
                                  v900 = "tcp_input";
                                  v643 = "";
                                  *(_DWORD *)__int128 buf = 136446722;
                                  if (v15) {
                                    v643 = (const char *)(v15 + 604);
                                  }
                                  __int16 v901 = 2082;
                                  *(void *)v902 = v643;
                                  *(_WORD *)&v902[8] = 2082;
                                  *(void *)v903 = v642;
                                  _os_log_impl( &dword_1879E5000,  v641,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                }
                              }
                            }

                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v251 = nw_protocol_tcp_get_all_stats();
                              if (v251) {
                                *(_DWORD *)(v251 + 136) = 3;
                              }
                            }

                            uint64_t v244 = (uint64_t)v250;
                            int v252 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(v250[5].i64[0] + 224)) + 316);
                            __int32 v253 = v250[42].i32[2];
                            if (!v253) {
                              __int32 v253 = *(_DWORD *)(sysctls + 188);
                            }
                            v250[2].i32[2] = v253 + v252 - v250[4].i32[0];
                            unsigned int v254 = v881;
                            if (!*(_DWORD *)(a3 + 460))
                            {
                              int v255 = inp_calc_flowhash_flow_hash++;
                              *(_DWORD *)(a3 + 460) = v255;
                            }

                            *(_DWORD *)(v15 + 364) &= ~0x40000u;
                            uint64_t v256 = v250[66].i64[0];
                            if (v256) {
                              ++*(void *)(v256 + 384);
                            }
                            int64x2_t v221 = tcp_input_process_accecn_syn( v250,  ((unsigned __int16)v881 | (unsigned __int16)(BYTE12(v920) << 8)) & 0x1C0,  log);
                            int v822 = 0;
                            uint64_t v257 = v828;
                            goto LABEL_940;
                          case 2:
                            if ((v881 & 0x10) != 0)
                            {
                              if (DWORD2(v920) - *(_DWORD *)(v121 + 112) < 1
                                || DWORD2(v920) - *(_DWORD *)(v121 + 96) > 0)
                              {
                                goto LABEL_647;
                              }

                              if ((v881 & 4) != 0)
                              {
                                if ((*(_DWORD *)(v121 + 740) & 0x1400000) == 0x400000) {
                                  tcp_heuristic_tfo_rst(v121);
                                }
                                int v324 = *(_DWORD *)(v121 + 348);
                                if ((v324 & 0x8001) == 1 || (v324 & 0x108000) == 0x100000) {
                                  tcp_heuristic_ecn_synrst(v121);
                                }
                                tcp_drop(v121, 61);
                                uint64_t v42 = v890;
                                goto LABEL_1288;
                              }

                              uint64_t v42 = v890;
                              LOBYTE(v130) = v881;
                              if ((v881 & 2) == 0) {
                                goto LABEL_1288;
                              }
                            }

                            else if ((v881 & 6) != 2)
                            {
LABEL_621:
                              int v54 = v847;
                              int v131 = v822;
                              goto LABEL_622;
                            }

                            int v238 = HIWORD(v920);
                            *(_DWORD *)(v121 + 140) = HIWORD(v920);
                            *(_DWORD *)(v121 + 252) = v238;
                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v239 = nw_protocol_tcp_get_all_stats();
                              if (v239) {
                                *(_DWORD *)(v239 + 112) = *(_DWORD *)(v121 + 140);
                              }
                            }

                            int v818 = v17;
                            int v240 = DWORD1(v920);
                            int v241 = DWORD1(v920) + 1;
                            *(_DWORD *)(v121 + 1916) = DWORD1(v920) + 1;
                            *(_DWORD *)(v121 + 116) = v240;
                            *(_DWORD *)(v121 + 120) = v241;
                            *(_DWORD *)(v121 + 124) = v241;
                            if ((v130 & 0x10) == 0)
                            {
                              *(_DWORD *)(v121 + 88) |= 1u;
                              *(_DWORD *)(v121 + 28) = 0;
                              uint64_t v242 = v121;
                              *(_DWORD *)(v121 + 12) = 3;
                              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                              {
                                if (__nwlog_is_datapath_logging_enabled())
                                {
                                  v709 = (os_log_s *)__nwlog_tcp_log();
                                  if (os_log_type_enabled(v709, OS_LOG_TYPE_DEBUG))
                                  {
                                    v710 = tcpstates[*(int *)(v242 + 12)];
                                    v900 = "tcp_input";
                                    v711 = "";
                                    *(_DWORD *)__int128 buf = 136446722;
                                    if (v15) {
                                      v711 = (const char *)(v15 + 604);
                                    }
                                    __int16 v901 = 2082;
                                    *(void *)v902 = v711;
                                    *(_WORD *)&v902[8] = 2082;
                                    *(void *)v903 = v710;
                                    _os_log_impl( &dword_1879E5000,  v709,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                  }
                                }
                              }

                              if (*(void *)(v15 + 24))
                              {
                                uint64_t v243 = nw_protocol_tcp_get_all_stats();
                                if (v243) {
                                  *(_DWORD *)(v243 + 136) = 3;
                                }
                              }

                              int v839 = 0;
                              uint64_t v244 = v242;
                              *(_DWORD *)(v242 + 740) &= ~0x400000u;
                              goto LABEL_939;
                            }

                            uint64_t v269 = v121;
                            v270 = *(void **)(v121 + 1056);
                            if (v270) {
                              ++v270[51];
                            }
                            if ((v130 & 0xC0) == 0x40)
                            {
                              int v271 = *(_DWORD *)(v121 + 348);
                              *(_DWORD *)(v121 + 348) = v271 | 2;
                              if ((v271 & 1) != 0)
                              {
                                uint64_t v272 = *(void *)(v121 + 80);
                                buf[0] = 1;
                                (*(void (**)(void, uint8_t *))(*(void *)(v272 + 2136) + 24LL))( *(void *)(v272 + 224),  buf);
                                uint64_t v273 = *(void *)(v121 + 1056);
                                if (v273) {
                                  ++*(void *)(v273 + 776);
                                }
                              }

                              uint64_t v274 = v121;
                              int v275 = *(_DWORD *)(v121 + 348);
                              if ((v275 & 0x100000) != 0)
                              {
                                *(_DWORD *)(v121 + 348) = v275 & 0xFFEFFFFA | 5;
                                if (*(_DWORD *)(v121 + 360) == 2)
                                {
                                  int v276 = 3;
LABEL_808:
                                  *(_DWORD *)(v274 + 360) = v276;
                                }
                              }
                            }

                            else
                            {
                              int v312 = *(_DWORD *)(v121 + 740);
                              if ((v312 & 0x10000000) == 0
                                && ((int v313 = ((unsigned __int16)v881 | (unsigned __int16)(BYTE12(v920) << 8)) & 0x1C0,
                                     uint64_t v314 = sysctls,
                                     *(_DWORD *)(sysctls + 320) == 1)
                                 || tcp_do_acc_ecn == 1
                                 || (v312 & 0x8000000) != 0)
                                && (((unsigned __int16)v881 | (unsigned __int16)(BYTE12(v920) << 8)) & 0x1C0) != 0
                                && v313 != 448)
                              {
                                *(_DWORD *)(v121 + 420) = 5;
                                *(void *)(v121 + 456) = 1LL;
                                *(_OWORD *)(v121 + 464) = xmmword_187A43AD0;
                                int v315 = *(_DWORD *)(v121 + 348);
                                unsigned int v316 = v315 | 0x400000;
                                *(_DWORD *)(v121 + 348) = v315 | 0x400000;
                                switch((v313 - 128) >> 6)
                                {
                                  case 0u:
                                    int v317 = v312 & 0x8000000;
                                    int v318 = *(_DWORD *)(v314 + 336);
                                    if (tcp_do_l4s != 1 && v318 != 1 && v317 == 0) {
                                      int v321 = 0x200000;
                                    }
                                    else {
                                      int v321 = 2097156;
                                    }
                                    v316 |= v321;
                                    *(_DWORD *)(v121 + 348) = v316;
                                    *(_DWORD *)(v121 + 360) = 7;
                                    if (v270) {
                                      ++v270[102];
                                    }
                                    break;
                                  case 1u:
                                    unsigned int v316 = v315 & 0xFF9FFFFB | 0x600000;
                                    *(_DWORD *)(v121 + 348) = v316;
                                    *(_DWORD *)(v121 + 360) = 8;
                                    if (v270) {
                                      ++v270[103];
                                    }
                                    break;
                                  case 2u:
                                    unsigned int v316 = v315 & 0xFF9FFFFB | 0x600000;
                                    *(_DWORD *)(v121 + 348) = v316;
                                    *(_DWORD *)(v121 + 360) = 8;
                                    if (v270) {
                                      ++v270[104];
                                    }
                                    break;
                                  case 4u:
                                    *(_DWORD *)(v121 + 360) = 8;
                                    unsigned int v316 = v315 & 0xFF9FFFFB | 0x600000;
                                    *(_DWORD *)(v121 + 348) = v316;
                                    *(_DWORD *)(v121 + 144) = 2 * *(_DWORD *)(v121 + 196);
                                    if (v270) {
                                      ++v270[105];
                                    }
                                    break;
                                  default:
                                    break;
                                }

                                if ((~v316 & 3) == 0)
                                {
                                  uint64_t v560 = *(void *)(v121 + 80);
                                  buf[0] = 1;
                                  (*(void (**)(void, uint8_t *))(*(void *)(v560 + 2136) + 24LL))( *(void *)(v560 + 224),  buf);
                                  uint64_t v561 = *(void *)(v121 + 1056);
                                  if (v561) {
                                    ++*(void *)(v561 + 776);
                                  }
                                }

                                uint64_t v274 = v121;
                                *(_DWORD *)(v121 + 416) = 5;
                                *(int64x2_t *)(v121 + 432) = vdupq_n_s64(1uLL);
                                *(void *)(v121 + 448) = 0LL;
                                tcp_input_ip_ecn(v121, a3, *(unsigned int *)v897, v823, log);
                                *(_DWORD *)(v121 + 348) |= dword_187A43AF0[log];
                                if ((v894[0] & 1) != 0)
                                {
                                  if (DWORD2(v894[0]))
                                  {
                                    int v562 = *(_DWORD *)(v121 + 400);
                                    if (!v562 || ((DWORD2(v894[0]) - v562) & 0x80000000) == 0) {
                                      *(_DWORD *)(v121 + 400) = DWORD2(v894[0]);
                                    }
                                  }
                                }
                              }

                              else
                              {
                                if ((*(_DWORD *)(v121 + 348) & 0x100001) != 0 && !*(_WORD *)(v121 + 226))
                                {
                                  uint64_t v326 = *(void *)(v121 + 80);
                                  buf[0] = 1;
                                  (*(void (**)(void, uint8_t *))(*(void *)(v326 + 2136) + 24LL))( *(void *)(v326 + 224),  buf);
                                  uint64_t v327 = *(void *)(v121 + 1056);
                                  if (v327) {
                                    ++*(void *)(v327 + 784);
                                  }
                                }

                                int v328 = *(_DWORD *)(v121 + 348);
                                if ((v328 & 0x100001) != 0 && *(_WORD *)(v121 + 226))
                                {
                                  tcp_heuristic_ecn_loss(v121);
                                  int v328 = *(_DWORD *)(v121 + 348);
                                }

                                *(_DWORD *)(v121 + 348) = v328 & 0xFFFFFFFB;
                                if ((v328 & 0x100) != 0
                                  && *(unsigned __int16 *)(v121 + 226) <= 2u
                                  && *(_DWORD *)(v121 + 360) == 2)
                                {
                                  *(_DWORD *)(v121 + 360) = 5;
                                }

                                uint64_t v274 = v121;
                                if (*(_DWORD *)(v121 + 360) == 2)
                                {
                                  int v276 = 4;
                                  goto LABEL_808;
                                }
                              }
                            }

                            int v329 = *(_DWORD *)(v274 + 88);
                            if ((~v329 & 0x60) != 0)
                            {
                              char v330 = *(_BYTE *)(v274 + 261);
                            }

                            else
                            {
                              *(_BYTE *)(v274 + 260) = *(_BYTE *)(v274 + 263);
                              char v330 = *(_BYTE *)(v274 + 262);
                              *(_BYTE *)(v274 + 261) = v330;
                            }

                            uint64_t v331 = 0xFFFFLL << v330;
                            int v332 = 0xFFFF << v330;
                            else {
                              unsigned int v333 = *(_DWORD *)(v274 + 128);
                            }
                            if (*(_DWORD *)(sysctls + 308) == 1
                              && (v329 & 0x180) == 0x180
                              && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v15 + 369) & 0x40) != 0))
                            {
                              if (off_18C4CE838)
                              {
                                unsigned int v334 = off_18C4CE838(v121);
                                unsigned int v335 = v333 >= v334 ? v334 : v333;
                                if (v334) {
                                  unsigned int v333 = v335;
                                }
                              }
                            }

                            *(_DWORD *)(v121 + 124) += v333;
                            int v336 = *(_DWORD *)(v121 + 92) + 1;
                            *(_DWORD *)(v121 + 92) = v336;
                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v337 = nw_protocol_tcp_get_all_stats();
                              int v336 = *(_DWORD *)(v121 + 92);
                              if (v337)
                              {
                                *(_DWORD *)(v337 + 108) = *(_DWORD *)(v121 + 96) - v336;
                                int v336 = *(_DWORD *)(v121 + 92);
                              }
                            }

                            uint64_t v338 = v121;
                            int v339 = *(_DWORD *)(v121 + 100);
                            if (v339 - v336 < 0)
                            {
                              *(_DWORD *)(v121 + 100) = v336;
                              int v339 = v336;
                            }

                            int v340 = DWORD2(v920);
                            if (v339 - DWORD2(v920) >= 1)
                            {
                              if ((*(_BYTE *)(v121 + 743) & 1) == 0 && (*(_WORD *)(v121 + 990) & 0x40) != 0)
                              {
                                unsigned int v341 = *(_DWORD *)(v121 + 96);
                                if (v341 == DWORD2(v920) + 1 && v341 > v336 + 1)
                                {
                                  tcp_heuristic_tfo_middlebox(v121);
                                  *(_WORD *)(v15 + 378) = 96;
                                  user_north_signal_error(v15);
                                  *(_WORD *)(v121 + 990) |= 0x4000u;
                                  int v340 = DWORD2(v920);
                                }
                              }

                              uint64_t v338 = v121;
                              *(_DWORD *)(v121 + 96) = v340;
                              *(_DWORD *)(v121 + 100) = v340;
                            }

                            if (*(void *)(v15 + 24))
                            {
                              uint64_t v342 = nw_protocol_tcp_get_all_stats();
                              if (v342) {
                                *(_DWORD *)(v342 + 108) = *(_DWORD *)(v338 + 96) - *(_DWORD *)(v338 + 92);
                              }
                            }

                            *(_WORD *)(v338 + 304) += v823;
                            int v343 = *(_DWORD *)(v338 + 740);
                            if ((v343 & 0x10000000) == 0
                              && ((v343 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
                            {
                              char v344 = v821 ^ 1;
                              if ((~*(_DWORD *)(v338 + 348) & 0x300000) != 0) {
                                char v344 = 1;
                              }
                              if ((v344 & 1) == 0) {
                                *(_WORD *)(v338 + 306) += v823;
                              }
                            }

                            v345 = *(uint64_t (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v338 + 264)]
                                                                                 + 96);
                            if (v345)
                            {
                              int v346 = v345(v338, &v920);
                              int v347 = *(_DWORD *)(v338 + 88);
                              if (v346 && *(_DWORD *)v897)
                              {
                                uint64_t v348 = v121;
                                if ((v347 & 2) == 0)
                                {
                                  *(_DWORD *)(v121 + 88) = v347 | 2;
                                  *(_DWORD *)(v121 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v121 + 80) + 224LL))
                                                                     + 316)
                                                         - *(_DWORD *)(v121 + 64)
                                                         + 100;
                                }

LABEL_864:
                                *(_DWORD *)(v348 + 168) = *(_DWORD *)(v835 + 316);
                                tcp_sbrcv_tstmp_check(v348);
                                if ((*(_BYTE *)(v348 + 89) & 8) != 0)
                                {
                                  *(_DWORD *)(v348 + 12) = 6;
                                  if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                  {
                                    if (__nwlog_is_datapath_logging_enabled())
                                    {
                                      v725 = (os_log_s *)__nwlog_tcp_log();
                                      if (os_log_type_enabled(v725, OS_LOG_TYPE_DEBUG))
                                      {
                                        v726 = tcpstates[*(int *)(v269 + 12)];
                                        v900 = "tcp_input";
                                        v727 = "";
                                        *(_DWORD *)__int128 buf = 136446722;
                                        if (v15) {
                                          v727 = (const char *)(v15 + 604);
                                        }
                                        __int16 v901 = 2082;
                                        *(void *)v902 = v727;
                                        *(_WORD *)&v902[8] = 2082;
                                        *(void *)v903 = v726;
                                        _os_log_impl( &dword_1879E5000,  v725,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                      }
                                    }
                                  }

                                  if (*(void *)(v15 + 24))
                                  {
                                    uint64_t v357 = nw_protocol_tcp_get_all_stats();
                                    if (v357) {
                                      *(_DWORD *)(v357 + 136) = 6;
                                    }
                                  }

                                  *(_DWORD *)(v269 + 88) &= ~0x800u;
                                  v881 &= ~2u;
                                }

                                else
                                {
                                  *(_DWORD *)(v348 + 12) = 4;
                                  if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                  {
                                    if (__nwlog_is_datapath_logging_enabled())
                                    {
                                      v722 = (os_log_s *)__nwlog_tcp_log();
                                      if (os_log_type_enabled(v722, OS_LOG_TYPE_DEBUG))
                                      {
                                        v723 = tcpstates[*(int *)(v269 + 12)];
                                        v900 = "tcp_input";
                                        v724 = "";
                                        *(_DWORD *)__int128 buf = 136446722;
                                        if (v15) {
                                          v724 = (const char *)(v15 + 604);
                                        }
                                        __int16 v901 = 2082;
                                        *(void *)v902 = v724;
                                        *(_WORD *)&v902[8] = 2082;
                                        *(void *)v903 = v723;
                                        _os_log_impl( &dword_1879E5000,  v722,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                      }
                                    }
                                  }

                                  if (*(void *)(v15 + 24))
                                  {
                                    uint64_t v353 = nw_protocol_tcp_get_all_stats();
                                    if (v353) {
                                      *(_DWORD *)(v353 + 136) = 4;
                                    }
                                  }

                                  int v354 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v269 + 80) + 224LL))
                                                   + 316);
                                  int v355 = *(_DWORD *)(v269 + 676);
                                  if (!v355
                                    || (*(_BYTE *)(*(void *)(*(void *)(v269 + 80) + 224LL) + 372LL) & 8) == 0)
                                  {
                                    int v355 = *(_DWORD *)(sysctls + 192);
                                  }

                                  *(_DWORD *)(v269 + 40) = v355 + v354 - *(_DWORD *)(v269 + 64);
                                  if (*(void *)(v15 + 24))
                                  {
                                    uint64_t v356 = nw_protocol_tcp_get_all_stats();
                                    if (v356) {
                                      ++*(_DWORD *)(v356 + 64);
                                    }
                                  }
                                }

                                uint64_t v244 = v269;
                                *(_WORD *)(v269 + 308) = 16;
                                if ((*(_BYTE *)(v269 + 988) & 0xC) != 0 || (*(_WORD *)(v269 + 990) & 0x40) != 0)
                                {
                                  tcp_tfo_synack(v269, (uint64_t)v894);
                                  __int16 v358 = *(_WORD *)(v269 + 990);
                                  if ((v358 & 0x40) == 0 || *(_DWORD *)(v269 + 92) - DWORD2(v920) >= 0)
                                  {
                                    int v839 = 1;
                                    uint64_t v244 = v269;
                                    goto LABEL_939;
                                  }

                                  *(_WORD *)(v269 + 990) = v358 | 0x80;
                                  uint64_t v372 = *(void *)(v269 + 1056);
                                  if (v372) {
                                    ++*(void *)(v372 + 1128);
                                  }
                                  uint64_t v244 = v269;
                                  tcp_tfo_rcv_probe(v269, *(int *)v897);
                                }

                                int v839 = 1;
LABEL_939:
                                int v17 = v818;
                                uint64_t v257 = v828;
                                unsigned int v254 = v881;
LABEL_940:
                                if ((*(_WORD *)(v13 + 204) & 0x100) == 0
                                  || !*MEMORY[0x189608EF8]
                                  || (v373 = ((uint64_t (*)(uint64_t, void, __n128))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88),  (__n128)v221),  uint64_t v257 = v828,  (v373 & 1) != 0))
                                {
                                  unsigned int v884 = v254;
                                  ++DWORD1(v920);
                                  int v374 = *(_DWORD *)v897;
                                  int v375 = *(_DWORD *)(v244 + 128);
                                  unsigned int v376 = *(_DWORD *)v897 - v375;
                                  int v817 = v17;
                                  if (*(int *)v897 <= v375)
                                  {
LABEL_989:
                                    BOOL v407 = 0;
                                    int v408 = 0;
                                    int v845 = 0;
                                    int v409 = DWORD1(v920);
                                    uint64_t v410 = v837;
                                    *(_DWORD *)(v837 + 104) = DWORD1(v920) - 1;
                                    *(_DWORD *)(v837 + 136) = v409;
                                    int v411 = v884;
                                    if ((v884 & 0x10) == 0) {
                                      goto LABEL_1113;
                                    }
LABEL_990:
                                    unsigned int v881 = v411;
                                    int v412 = DWORD2(v920) - *(_DWORD *)(v410 + 92);
                                    if (v412 >= 0)
                                    {
                                      unint64_t v119 = v410;
                                      uint64_t v413 = *(void *)(v410 + 1056);
                                      if (v413)
                                      {
                                        uint64_t v414 = *(void *)(v413 + 168) + v412;
                                        ++*(void *)(v413 + 160);
                                        *(void *)(v413 + 168) = v414;
                                      }

                                      tcp_bad_rexmt_check(v410, (uint64_t)&v920, (uint64_t)v894);
                                      tcp_compute_rtt(v410, (uint64_t)v894, (uint64_t)&v920);
                                      int v415 = 0;
                                      *(_WORD *)(v410 + 226) = 0;
                                      *(_DWORD *)(v410 + 248) = 0;
                                      uint64_t v416 = *(unsigned int *)(v410 + 228);
                                      int v417 = (*(_DWORD *)(v410 + 208) + (*(int *)(v410 + 200) >> 3)) >> 2;
                                      if (v416 > v417) {
                                        int v417 = *(_DWORD *)(v410 + 228);
                                      }
                                      unsigned int v418 = v417 + v415;
                                      *(_DWORD *)(v410 + 192) = v418;
                                      if (v418 >= v416)
                                      {
                                        if (v418 < 0xFA01) {
                                          goto LABEL_1001;
                                        }
                                        LODWORD(v416) = 64000;
                                      }

                                      *(_DWORD *)(v410 + 192) = v416;
LABEL_1001:
                                      if (DWORD2(v920) == *(_DWORD *)(v410 + 96))
                                      {
                                        *(_DWORD *)(v410 + 16) = 0;
                                        *(void *)(v410 + 24) = 0LL;
                                        *(_BYTE *)(v410 + 2069) &= ~0x80u;
                                        int v845 = 1;
                                      }

                                      else
                                      {
                                        int v845 = 0;
                                        if (!*(_DWORD *)(v410 + 36)) {
                                          *(_DWORD *)(v410 + 28) = *(_DWORD *)(v410 + 192)
                                        }
                                                                 + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v410 + 80) + 224LL))
                                                                             + 316)
                                                                 - *(_DWORD *)(v410 + 64);
                                      }

                                      if (!v412)
                                      {
LABEL_1110:
                                        int v408 = 0;
                                        goto LABEL_1111;
                                      }

                                      if ((*(_DWORD *)(v410 + 740) & 0x20400020) == 0x20000020)
                                      {
                                        tcp_segs_doack(v410, DWORD2(v920), v894[0], SDWORD2(v894[0]));
                                        int v436 = *(_DWORD *)(v410 + 560);
                                        int v437 = v896;
                                        if (v436 - (int)v896 < 0)
                                        {
                                          *(_DWORD *)(v410 + 560) = v896;
                                          int v436 = v437;
                                        }

                                        if (v436 - DWORD2(v920) < 0) {
                                          *(_DWORD *)(v410 + 560) = DWORD2(v920);
                                        }
                                      }

                                      if ((*(_WORD *)(v410 + 990) & 0x40) != 0
                                        && (*(_BYTE *)(v410 + 988) & 0x20) == 0
                                        && (BYTE13(v920) & 2) == 0)
                                      {
                                        *(_BYTE *)(v410 + 988) |= 0x20u;
                                      }

                                      int v438 = *(_DWORD *)(v410 + 348);
                                      if ((v438 & 4) != 0)
                                      {
                                        int v442 = *(_DWORD *)(v410 + 740);
                                        if ((v442 & 0x10000000) == 0
                                          && ((v442 & 0x8000000) != 0
                                           || *(_DWORD *)(sysctls + 320) == 1
                                           || tcp_do_acc_ecn == 1)
                                          && (v411 & 2) == 0
                                          && (v438 & 0x300000) == 0x300000)
                                        {
                                          int v477 = 0;
                                          int v478 = DWORD2(v920);
                                          int v479 = *(_DWORD *)(v410 + 112) + 1;
                                          if (DWORD2(v920) == v479) {
                                            int v412 = 0;
                                          }
                                          unsigned int v480 = *(_DWORD *)(v410 + 196);
                                          if (v412 / v480 * v480 == v412) {
                                            unsigned int v481 = v412 / v480;
                                          }
                                          else {
                                            unsigned int v481 = v412 / v480 + 1;
                                          }
                                          *(_DWORD *)(v410 + 296) += v481;
                                          if (v478 == v479 && !HIDWORD(v896))
                                          {
                                            int v477 = 0;
                                            if ((v894[0] & 1) != 0)
                                            {
                                              if (DWORD2(v894[0]))
                                              {
                                                int v482 = *(_DWORD *)(v410 + 400);
                                                if (v482) {
                                                  BOOL v483 = DWORD2(v894[0]) - v482 <= 0;
                                                }
                                                else {
                                                  BOOL v483 = 0;
                                                }
                                                int v477 = !v483;
                                              }
                                            }
                                          }

                                          if (v412 || HIDWORD(v896) || v477) {
                                            tcp_process_accecn(v410, (uint64_t)v894, (uint64_t)&v920, v481, v819);
                                          }
                                          else {
                                            int v412 = 0;
                                          }
                                        }

                                        else if ((v411 & 0x40) != 0 {
                                               && (*(_DWORD *)(v410 + 348) & 3) == 3
                                        }
                                               && (*(_BYTE *)(v410 + 90) & 0x20) == 0)
                                        {
                                          tcp_enter_fast_recovery(v410);
                                          *(_DWORD *)(v410 + 348) |= 0xA8u;
                                          uint64_t v443 = *(void *)(a3 + 448);
                                          if (v443)
                                          {
                                            uint64_t v444 = 576LL;
                                            if ((*(_BYTE *)(a3 + 2236) & 2) == 0) {
                                              uint64_t v444 = 192LL;
                                            }
                                            ++*(void *)(v443 + v444);
                                          }

                                          uint64_t v445 = *(void *)(v410 + 1056);
                                          if (v445) {
                                            ++*(void *)(v445 + 864);
                                          }
                                          ++*(void *)(v410 + 384);
                                        }
                                      }

                                      if (!(*(_DWORD *)(v410 + 88) & 0x200000 | v407))
                                      {
                                        v439 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v410 + 264)]
                                                                                          + 56);
                                        if (v439) {
                                          v439(v410, &v920);
                                        }
                                      }

                                      int v440 = *(_DWORD *)(v15 + 384);
                                      if (v412 <= v440)
                                      {
                                        sbdrop((int *)(v15 + 384), v412);
                                        tcp_sbsnd_trim(v15 + 384);
                                        uint64_t v121 = v119;
                                        *(_DWORD *)(v119 + 140) -= v412;
                                        if (*(void *)(v15 + 24))
                                        {
                                          uint64_t v446 = nw_protocol_tcp_get_all_stats();
                                          if (v446) {
                                            *(_DWORD *)(v446 + 112) = *(_DWORD *)(v119 + 140);
                                          }
                                        }
                                      }

                                      else
                                      {
                                        *(_DWORD *)(v119 + 140) -= v440;
                                        if (*(void *)(v15 + 24))
                                        {
                                          uint64_t v441 = nw_protocol_tcp_get_all_stats();
                                          if (v441) {
                                            *(_DWORD *)(v441 + 112) = *(_DWORD *)(v119 + 140);
                                          }
                                        }

                                        sbdrop((int *)(v15 + 384), *(_DWORD *)(v15 + 384));
                                        uint64_t v121 = v119;
                                      }

                                      int v447 = *(_DWORD *)(v121 + 88);
                                      int v448 = *(_DWORD *)(v121 + 152);
                                      if ((v447 & 0x200000) != 0)
                                      {
                                        int v449 = DWORD2(v920);
                                        if (DWORD2(v920) - v448 < 0) {
                                          goto LABEL_1065;
                                        }
                                        *(_DWORD *)(v121 + 88) = v447 & 0xFFDFFFFF;
                                        *(_DWORD *)(v121 + 8) = 0;
                                        *(_BYTE *)(v121 + 310) = 3;
                                        *(_DWORD *)(v121 + 288) = 0;
                                        *(_DWORD *)(v121 + 348) &= ~0x20u;
                                        *(_DWORD *)(v121 + 16) = 0;
                                        int v450 = *(_DWORD *)(v121 + 740);
                                        *(_DWORD *)(v121 + 740) = v450 & 0xFFF7FFFF;
                                        *(_DWORD *)(v121 + 984) = 0;
                                        *(_DWORD *)(v121 + 628) = 0;
                                        if ((v450 & 0x20400020) == 0x20000020 && (*(_BYTE *)(v119 + 2069) & 0x1F) != 0)
                                        {
                                          uint64_t v121 = v119;
                                          *(_BYTE *)(v119 + 2069) = *(_BYTE *)(v119 + 2069) & 0xE0 | (*(_BYTE *)(v119 + 2069) - 1) & 0x1F;
                                          goto LABEL_1065;
                                        }
                                      }

                                      else
                                      {
                                        int v449 = DWORD2(v920);
                                        if (*(_DWORD *)(v121 + 92) - v448 >= 1 && DWORD2(v920) - v448 <= 0)
                                        {
                                          uint64_t v121 = v119;
                                          *(_DWORD *)(v119 + 152) = DWORD2(v920) - 1;
                                          goto LABEL_1065;
                                        }
                                      }

                                      uint64_t v121 = v119;
LABEL_1065:
                                      tcp_update_snd_una(v121, v449);
                                      int v451 = *(_DWORD *)(v121 + 740);
                                      int v452 = *(_DWORD *)(v121 + 92);
                                      if ((v451 & 0x20) != 0 && v452 - *(_DWORD *)(v121 + 152) >= 1) {
                                        *(_DWORD *)(v121 + 152) = v452;
                                      }
                                      if (*(_DWORD *)(v121 + 100) - v452 < 0) {
                                        *(_DWORD *)(v121 + 100) = v452;
                                      }
                                      if ((v451 & 0x20400020) == 0x20000020
                                        && tcp_rack_detect_loss_and_arm_timer(v121, 0))
                                      {
                                        if ((*(_BYTE *)(v121 + 90) & 0x20) == 0)
                                        {
                                          tcp_enter_fast_recovery(v119);
                                          uint64_t v453 = *(void *)(v119 + 1056);
                                          if (v453) {
                                            ++*(void *)(v453 + 624);
                                          }
                                          ++*(_DWORD *)(v119 + 1008);
                                        }

                                        uint64_t v121 = v119;
                                        tcp_output(v119);
                                      }

                                      if (*(void *)(v121 + 952))
                                      {
                                        int v454 = *(_DWORD *)(v121 + 960);
                                        if (v454 - *(_DWORD *)(v121 + 96) > 0) {
                                          goto LABEL_1079;
                                        }
                                        unsigned int v455 = *(_DWORD *)(v121 + 140);
                                        if (v455 >= *(_DWORD *)(sysctls + 120)) {
                                          unsigned int v455 = *(_DWORD *)(sysctls + 120);
                                        }
                                        if ((int)(v454 - *(_DWORD *)(v121 + 92) + v455) < 0) {
LABEL_1079:
                                        }
                                          tcp_rxtseg_clean(v121);
                                      }

                                      if ((*(_BYTE *)(v121 + 740) & 8) != 0 && *(void *)(v121 + 768)) {
                                        tcp_bwmeas_check(v121);
                                      }
                                      v456 = *(void (***)(uint64_t))(v15 + 32);
                                      if (v456)
                                      {
                                        v457 = *v456;
                                        if (v457) {
                                          v457(v15);
                                        }
                                      }

                                      int v408 = 0;
                                      int v458 = *(_DWORD *)(v121 + 12);
                                      switch(v458)
                                      {
                                        case 6:
                                          if (v412 <= v440) {
                                            goto LABEL_1110;
                                          }
                                          *(_DWORD *)(v119 + 12) = 9;
                                          if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                          {
                                            if (__nwlog_is_datapath_logging_enabled())
                                            {
                                              v762 = (os_log_s *)__nwlog_tcp_log();
                                              if (os_log_type_enabled(v762, OS_LOG_TYPE_DEBUG))
                                              {
                                                v763 = tcpstates[*(int *)(v119 + 12)];
                                                v900 = "tcp_input";
                                                v764 = "";
                                                *(_DWORD *)__int128 buf = 136446722;
                                                if (v15) {
                                                  v764 = (const char *)(v15 + 604);
                                                }
                                                __int16 v901 = 2082;
                                                *(void *)v902 = v764;
                                                *(_WORD *)&v902[8] = 2082;
                                                *(void *)v903 = v763;
                                                _os_log_impl( &dword_1879E5000,  v762,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                              }
                                            }
                                          }

                                          if (*(void *)(v15 + 24))
                                          {
                                            uint64_t v459 = nw_protocol_tcp_get_all_stats();
                                            if (v459) {
                                              *(_DWORD *)(v459 + 136) = 9;
                                            }
                                          }

                                          if ((*(_WORD *)(v15 + 376) & 0x20) != 0)
                                          {
                                            tcp_set_finwait_timeout(v119);
                                            int v839 = 0;
LABEL_1222:
                                            int v408 = 1;
                                          }

                                          else
                                          {
                                            int v408 = 0;
                                          }

                                          int v458 = *(_DWORD *)(v119 + 12);
LABEL_1224:
                                          if (v458 != 4) {
                                            goto LABEL_1111;
                                          }
                                          if ((*(_DWORD *)(v119 + 740) & 0x20) == 0) {
                                            goto LABEL_1111;
                                          }
                                          if (!HIDWORD(v896)) {
                                            goto LABEL_1111;
                                          }
                                          if (!HIBYTE(v894[0])) {
                                            goto LABEL_1111;
                                          }
                                          if (*(_DWORD *)(v119 + 8)) {
                                            goto LABEL_1111;
                                          }
                                          if (DWORD2(v920) - *(_DWORD *)(v119 + 92) > 0) {
                                            goto LABEL_1111;
                                          }
                                          int v833 = *(_DWORD *)v897;
                                          if (*(_DWORD *)v897 | *(_DWORD *)(v119 + 740) & 0x2000) {
                                            goto LABEL_1111;
                                          }
                                          uint64_t v500 = *(void *)(v119 + 1056);
                                          if (v500) {
                                            ++*(void *)(v500 + 704);
                                          }
                                          uint64_t v410 = v119;
                                          break;
                                        case 7:
                                          if (v412 <= v440) {
                                            goto LABEL_1110;
                                          }
                                          *(_DWORD *)(v119 + 12) = 10;
                                          if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                          {
                                            if (__nwlog_is_datapath_logging_enabled())
                                            {
                                              v765 = (os_log_s *)__nwlog_tcp_log();
                                              if (os_log_type_enabled(v765, OS_LOG_TYPE_DEBUG))
                                              {
                                                v766 = tcpstates[*(int *)(v119 + 12)];
                                                v900 = "tcp_input";
                                                v767 = "";
                                                *(_DWORD *)__int128 buf = 136446722;
                                                if (v15) {
                                                  v767 = (const char *)(v15 + 604);
                                                }
                                                __int16 v901 = 2082;
                                                *(void *)v902 = v767;
                                                *(_WORD *)&v902[8] = 2082;
                                                *(void *)v903 = v766;
                                                _os_log_impl( &dword_1879E5000,  v765,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                              }
                                            }
                                          }

                                          if (*(void *)(v15 + 24))
                                          {
                                            uint64_t v460 = nw_protocol_tcp_get_all_stats();
                                            if (v460) {
                                              *(_DWORD *)(v460 + 136) = 10;
                                            }
                                          }

                                          tcp_canceltimers(v119);
                                          if ((*(_BYTE *)(v119 + 741) & 8) != 0)
                                          {
                                            int v839 = 0;
                                            *(_DWORD *)(v119 + 88) |= 0x8000000u;
                                          }

                                          else
                                          {
                                            add_to_time_wait(v119, 2 * *(_DWORD *)(sysctls + 204));
                                            int v839 = 0;
                                          }

                                          goto LABEL_1222;
                                        case 8:
                                          if (v412 <= v440) {
                                            goto LABEL_1110;
                                          }
                                          if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                          {
                                            if (__nwlog_is_datapath_logging_enabled())
                                            {
                                              v759 = (os_log_s *)__nwlog_tcp_log();
                                              if (os_log_type_enabled(v759, OS_LOG_TYPE_DEBUG))
                                              {
                                                v760 = tcpstates[*(int *)(v119 + 12)];
                                                v900 = "tcp_input";
                                                v761 = "";
                                                *(_DWORD *)__int128 buf = 136446722;
                                                if (v15) {
                                                  v761 = (const char *)(v15 + 604);
                                                }
                                                __int16 v901 = 2082;
                                                *(void *)v902 = v761;
                                                *(_WORD *)&v902[8] = 2082;
                                                *(void *)v903 = v760;
                                                _os_log_impl( &dword_1879E5000,  v759,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s ourfinisacked t_state %{public}s",  buf,  0x20u);
                                              }
                                            }
                                          }

                                          tcp_close(v119);
                                          goto LABEL_1287;
                                        case 10:
                                          add_to_time_wait(v121, 2 * *(_DWORD *)(sysctls + 204));
                                          int v43 = a1;
                                          uint64_t v42 = v890;
                                          goto LABEL_1169;
                                        default:
                                          goto LABEL_1224;
                                      }

                                      goto LABEL_1234;
                                    }

                                    int v419 = v374;
                                    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                    {
                                      __nwlog_tcp_log();
                                      if (v15) {
                                        v420 = (const char *)(v15 + 604);
                                      }
                                      else {
                                        v420 = "";
                                      }
                                      int v421 = *(_DWORD *)(v410 + 12);
                                      int v422 = *(_DWORD *)(v410 + 120);
                                      int v423 = *(_DWORD *)(v410 + 92);
                                      *(_DWORD *)__int128 buf = 136449026;
                                      v900 = "tcp_input";
                                      __int16 v901 = 2082;
                                      *(void *)v902 = v420;
                                      *(_WORD *)&v902[8] = 1024;
                                      *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
                                      *(_WORD *)&v903[4] = 1024;
                                      *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
                                      __int16 v904 = 1024;
                                      *(_DWORD *)v905 = v419;
                                      *(_WORD *)&v905[4] = 1024;
                                      *(_DWORD *)&v905[6] = BYTE13(v920);
                                      __int16 v906 = 1024;
                                      unsigned int v907 = bswap32(DWORD1(v920));
                                      __int16 v908 = 1024;
                                      unsigned int v909 = bswap32(DWORD2(v920));
                                      __int16 v910 = 1024;
                                      unsigned int v911 = bswap32(HIWORD(v920)) >> 16;
                                      __int16 v912 = 1024;
                                      int v913 = v421;
                                      __int16 v914 = 1024;
                                      int v915 = v422;
                                      __int16 v916 = 1024;
                                      int v917 = v423;
                                      v424 = (void *)_os_log_send_and_compose_impl();
                                      type[0] = OS_LOG_TYPE_ERROR;
                                      char v898 = 0;
                                      int v43 = a1;
                                      if (__nwlog_fault())
                                      {
                                        if (type[0] == OS_LOG_TYPE_FAULT)
                                        {
                                          v425 = (os_log_s *)__nwlog_tcp_log();
                                          os_log_type_t v426 = type[0];
                                          if (!os_log_type_enabled(v425, type[0])) {
                                            goto LABEL_1199;
                                          }
                                          int v427 = *(_DWORD *)(v410 + 12);
                                          int v428 = *(_DWORD *)(v410 + 120);
                                          int v429 = *(_DWORD *)(v410 + 92);
                                          *(_DWORD *)__int128 buf = 136449026;
                                          v900 = "tcp_input";
                                          __int16 v901 = 2082;
                                          *(void *)v902 = v420;
                                          *(_WORD *)&v902[8] = 1024;
                                          *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
                                          *(_WORD *)&v903[4] = 1024;
                                          *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
                                          __int16 v904 = 1024;
                                          *(_DWORD *)v905 = *(_DWORD *)v897;
                                          *(_WORD *)&v905[4] = 1024;
                                          *(_DWORD *)&v905[6] = BYTE13(v920);
                                          __int16 v906 = 1024;
                                          unsigned int v907 = bswap32(DWORD1(v920));
                                          __int16 v908 = 1024;
                                          unsigned int v909 = bswap32(DWORD2(v920));
                                          __int16 v910 = 1024;
                                          unsigned int v911 = bswap32(HIWORD(v920)) >> 16;
                                          __int16 v912 = 1024;
                                          int v913 = v427;
                                          __int16 v914 = 1024;
                                          int v915 = v428;
                                          __int16 v916 = 1024;
                                          int v917 = v429;
                                          v430 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->sn"
                                                 "d_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%"
                                                 "u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u";
                                          goto LABEL_1198;
                                        }

                                        if (!v898)
                                        {
                                          v425 = (os_log_s *)__nwlog_tcp_log();
                                          os_log_type_t v426 = type[0];
                                          if (!os_log_type_enabled(v425, type[0])) {
                                            goto LABEL_1199;
                                          }
                                          int v474 = *(_DWORD *)(v410 + 12);
                                          int v475 = *(_DWORD *)(v410 + 120);
                                          int v476 = *(_DWORD *)(v410 + 92);
                                          *(_DWORD *)__int128 buf = 136449026;
                                          v900 = "tcp_input";
                                          __int16 v901 = 2082;
                                          *(void *)v902 = v420;
                                          *(_WORD *)&v902[8] = 1024;
                                          *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
                                          *(_WORD *)&v903[4] = 1024;
                                          *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
                                          __int16 v904 = 1024;
                                          *(_DWORD *)v905 = *(_DWORD *)v897;
                                          *(_WORD *)&v905[4] = 1024;
                                          *(_DWORD *)&v905[6] = BYTE13(v920);
                                          __int16 v906 = 1024;
                                          unsigned int v907 = bswap32(DWORD1(v920));
                                          __int16 v908 = 1024;
                                          unsigned int v909 = bswap32(DWORD2(v920));
                                          __int16 v910 = 1024;
                                          unsigned int v911 = bswap32(HIWORD(v920)) >> 16;
                                          __int16 v912 = 1024;
                                          int v913 = v474;
                                          __int16 v914 = 1024;
                                          int v915 = v475;
                                          __int16 v916 = 1024;
                                          int v917 = v476;
                                          v430 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->sn"
                                                 "d_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%"
                                                 "u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, backtrace limit exceeded";
                                          goto LABEL_1198;
                                        }

                                        v431 = (void *)__nw_create_backtrace_string();
                                        v425 = (os_log_s *)__nwlog_tcp_log();
                                        os_log_type_t v426 = type[0];
                                        BOOL v432 = os_log_type_enabled(v425, type[0]);
                                        if (v431)
                                        {
                                          if (v432)
                                          {
                                            int v433 = *(_DWORD *)(v410 + 12);
                                            int v434 = *(_DWORD *)(v410 + 120);
                                            int v435 = *(_DWORD *)(v410 + 92);
                                            *(_DWORD *)__int128 buf = 136449282;
                                            v900 = "tcp_input";
                                            __int16 v901 = 2082;
                                            *(void *)v902 = v420;
                                            *(_WORD *)&v902[8] = 1024;
                                            *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
                                            *(_WORD *)&v903[4] = 1024;
                                            *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
                                            __int16 v904 = 1024;
                                            *(_DWORD *)v905 = *(_DWORD *)v897;
                                            *(_WORD *)&v905[4] = 1024;
                                            *(_DWORD *)&v905[6] = BYTE13(v920);
                                            __int16 v906 = 1024;
                                            unsigned int v907 = bswap32(DWORD1(v920));
                                            __int16 v908 = 1024;
                                            unsigned int v909 = bswap32(DWORD2(v920));
                                            __int16 v910 = 1024;
                                            unsigned int v911 = bswap32(HIWORD(v920)) >> 16;
                                            __int16 v912 = 1024;
                                            int v913 = v433;
                                            __int16 v914 = 1024;
                                            int v915 = v434;
                                            __int16 v916 = 1024;
                                            int v917 = v435;
                                            __int16 v918 = 2082;
                                            v919 = v431;
                                            _os_log_impl( &dword_1879E5000,  v425,  type[0],  "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->snd_u na) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u stat e=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, dumping backtrace:%{public}s",  buf,  0x5Cu);
                                          }

                                          free(v431);
                                          goto LABEL_1199;
                                        }

                                        if (v432)
                                        {
                                          int v485 = *(_DWORD *)(v410 + 12);
                                          int v486 = *(_DWORD *)(v410 + 120);
                                          int v487 = *(_DWORD *)(v410 + 92);
                                          *(_DWORD *)__int128 buf = 136449026;
                                          v900 = "tcp_input";
                                          __int16 v901 = 2082;
                                          *(void *)v902 = v420;
                                          *(_WORD *)&v902[8] = 1024;
                                          *(_DWORD *)v903 = bswap32((unsigned __int16)v920) >> 16;
                                          *(_WORD *)&v903[4] = 1024;
                                          *(_DWORD *)&v903[6] = bswap32(WORD1(v920)) >> 16;
                                          __int16 v904 = 1024;
                                          *(_DWORD *)v905 = *(_DWORD *)v897;
                                          *(_WORD *)&v905[4] = 1024;
                                          *(_DWORD *)&v905[6] = BYTE13(v920);
                                          __int16 v906 = 1024;
                                          unsigned int v907 = bswap32(DWORD1(v920));
                                          __int16 v908 = 1024;
                                          unsigned int v909 = bswap32(DWORD2(v920));
                                          __int16 v910 = 1024;
                                          unsigned int v911 = bswap32(HIWORD(v920)) >> 16;
                                          __int16 v912 = 1024;
                                          int v913 = v485;
                                          __int16 v914 = 1024;
                                          int v915 = v486;
                                          __int16 v916 = 1024;
                                          int v917 = v487;
                                          v430 = "%{public}s %{public}s assertion failure SEQ_GEQ(tcp_hdr->th_ack, tp->sn"
                                                 "d_una) %u:%u tlen %u, flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%"
                                                 "u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u, no backtrace";
LABEL_1198:
                                          _os_log_impl(&dword_1879E5000, v425, v426, v430, buf, 0x52u);
                                        }
                                      }

LABEL_1199:
                                      if (v424) {
                                        free(v424);
                                      }
LABEL_1201:
                                      uint64_t v42 = v890;
                                      goto LABEL_1288;
                                    }

LABEL_1287:
                                    int v43 = a1;
                                    uint64_t v42 = v890;
                                    goto LABEL_1288;
                                  }

                                  v377 = (void *)*v43;
                                  int v844 = *(_DWORD *)v897 - v375;
                                  if (*v43)
                                  {
                                    if ((*((_WORD *)v377 + 102) & 0x80) != 0)
                                    {
                                      unsigned int v378 = *((unsigned __int16 *)v377 + 98);
                                      if (v376 > v378)
                                      {
                                        int v831 = *(_DWORD *)v897;
                                        int v379 = *(_DWORD *)v897 - v375;
                                        __nwlog_obj();
                                        int v380 = *((unsigned __int16 *)v377 + 98);
                                        *(_DWORD *)__int128 buf = 136446722;
                                        v900 = "__nw_frame_array_claim";
                                        __int16 v901 = 1024;
                                        *(_DWORD *)v902 = v380;
                                        *(_WORD *)&v902[4] = 1024;
                                        *(_DWORD *)&v902[6] = v379;
                                        uint64_t v381 = _os_log_send_and_compose_impl();
                                        type[0] = OS_LOG_TYPE_ERROR;
                                        char v898 = 0;
                                        v382 = (void *)v381;
                                        if (__nwlog_fault())
                                        {
                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                          {
                                            v383 = (os_log_s *)__nwlog_obj();
                                            os_log_type_t v384 = type[0];
                                            if (os_log_type_enabled(v383, type[0]))
                                            {
                                              int v385 = *((unsigned __int16 *)v377 + 98);
                                              *(_DWORD *)__int128 buf = 136446722;
                                              v900 = "__nw_frame_array_claim";
                                              __int16 v901 = 1024;
                                              *(_DWORD *)v902 = v385;
                                              *(_WORD *)&v902[4] = 1024;
                                              *(_DWORD *)&v902[6] = v844;
                                              v386 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_963:
                                              v391 = v383;
LABEL_964:
                                              _os_log_impl(&dword_1879E5000, v391, v384, v386, buf, 0x18u);
                                            }
                                          }

                                          else if (v898)
                                          {
                                            v387 = (void *)__nw_create_backtrace_string();
                                            os_log_type_t v384 = type[0];
                                            v811 = (os_log_s *)__nwlog_obj();
                                            BOOL v388 = os_log_type_enabled(v811, type[0]);
                                            if (v387)
                                            {
                                              if (v388)
                                              {
                                                int v389 = *((unsigned __int16 *)v377 + 98);
                                                *(_DWORD *)__int128 buf = 136446978;
                                                v900 = "__nw_frame_array_claim";
                                                __int16 v901 = 1024;
                                                *(_DWORD *)v902 = v389;
                                                *(_WORD *)&v902[4] = 1024;
                                                *(_DWORD *)&v902[6] = v844;
                                                *(_WORD *)v903 = 2082;
                                                *(void *)&v903[2] = v387;
                                                _os_log_impl( &dword_1879E5000,  v811,  type[0],  "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s",  buf,  0x22u);
                                              }

                                              free(v387);
                                              goto LABEL_965;
                                            }

                                            if (v388)
                                            {
                                              int v496 = *((unsigned __int16 *)v377 + 98);
                                              *(_DWORD *)__int128 buf = 136446722;
                                              v900 = "__nw_frame_array_claim";
                                              __int16 v901 = 1024;
                                              *(_DWORD *)v902 = v496;
                                              *(_WORD *)&v902[4] = 1024;
                                              *(_DWORD *)&v902[6] = v844;
                                              v386 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                              v391 = v811;
                                              goto LABEL_964;
                                            }
                                          }

                                          else
                                          {
                                            v383 = (os_log_s *)__nwlog_obj();
                                            os_log_type_t v384 = type[0];
                                            if (os_log_type_enabled(v383, type[0]))
                                            {
                                              int v390 = *((unsigned __int16 *)v377 + 98);
                                              *(_DWORD *)__int128 buf = 136446722;
                                              v900 = "__nw_frame_array_claim";
                                              __int16 v901 = 1024;
                                              *(_DWORD *)v902 = v390;
                                              *(_WORD *)&v902[4] = 1024;
                                              *(_DWORD *)&v902[6] = v844;
                                              v386 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                              goto LABEL_963;
                                            }
                                          }
                                        }

LABEL_965:
                                        if (v382) {
                                          free(v382);
                                        }
                                        *((_WORD *)v377 + 98) = 0;
                                        unint64_t v119 = 0x18C4CE000LL;
                                        int v374 = v831;
                                        unsigned int v376 = v844;
                                        goto LABEL_968;
                                      }

                                      *((_WORD *)v377 + 98) = v378 - v376;
                                    }

LABEL_954:
                                    if (v374 == v375)
                                    {
LABEL_987:
                                      int v374 = *(_DWORD *)(v837 + 128);
                                      *(_DWORD *)v897 = v374;
                                      v884 &= ~1u;
                                      uint64_t v405 = *(void *)(v837 + 1056);
                                      if (v405)
                                      {
                                        uint64_t v406 = *(void *)(v405 + 280) + (int)v376;
                                        ++*(void *)(v405 + 272);
                                        *(void *)(v405 + 280) = v406;
                                      }

                                      goto LABEL_989;
                                    }

LABEL_968:
                                    unsigned int v392 = 0;
                                    if (v374 == v375 || (uint64_t v393 = **(void **)(a1[1] + 8)) == 0)
                                    {
LABEL_984:
                                      if (v392 != v376)
                                      {
                                        v403 = (os_log_s *)__nwlog_obj();
                                        BOOL v404 = os_log_type_enabled(v403, OS_LOG_TYPE_ERROR);
                                        unsigned int v376 = v844;
                                        if (v404)
                                        {
                                          *(_DWORD *)__int128 buf = 136446722;
                                          v900 = "__nw_frame_array_claim";
                                          __int16 v901 = 1024;
                                          *(_DWORD *)v902 = v392;
                                          *(_WORD *)&v902[4] = 1024;
                                          *(_DWORD *)&v902[6] = v844;
                                          _os_log_impl( &dword_1879E5000,  v403,  OS_LOG_TYPE_ERROR,  "%{public}s end_offset %u != end_bytes %u",  buf,  0x18u);
                                          unsigned int v376 = v844;
                                        }
                                      }
                                    }

                                    else
                                    {
                                      unsigned int v392 = 0;
                                      while (1)
                                      {
                                        int v394 = *(_DWORD *)(v393 + 52);
                                        unsigned int v395 = *(_DWORD *)(v393 + 56);
                                        int v396 = *(_DWORD *)(v393 + 60);
                                        unsigned int v397 = v394 - (v395 + v396);
                                        if (v397 >= v376 - v392) {
                                          unsigned int v397 = v376 - v392;
                                        }
                                        unsigned int v398 = v394 ? v397 : 0;
                                        int v399 = v396 + v398;
                                        if (v395 <= v394 - (v396 + v398))
                                        {
                                          *(_DWORD *)(v393 + 60) = v399;
                                        }

                                        else
                                        {
                                          v400 = (os_log_s *)__nwlog_obj();
                                          BOOL v401 = os_log_type_enabled(v400, OS_LOG_TYPE_ERROR);
                                          unsigned int v376 = v844;
                                          if (v401)
                                          {
                                            int v402 = *(_DWORD *)(v393 + 52);
                                            *(_DWORD *)__int128 buf = 136446978;
                                            v900 = "__nw_frame_claim_internal";
                                            __int16 v901 = 1024;
                                            *(_DWORD *)v902 = v395;
                                            *(_WORD *)&v902[4] = 1024;
                                            *(_DWORD *)&v902[6] = v402;
                                            *(_WORD *)v903 = 1024;
                                            *(_DWORD *)&v903[2] = v399;
                                            _os_log_impl( &dword_1879E5000,  v400,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
                                            unsigned int v376 = v844;
                                          }
                                        }

                                        v392 += v398;
                                        unint64_t v119 = 0x18C4CE000LL;
                                        if (v392 == v376) {
                                          break;
                                        }
                                        if (*(_OWORD *)(v393 + 32) != 0LL && v392 < v376)
                                        {
                                          uint64_t v393 = **(void **)(*(void *)(v393 + 40) + 8LL);
                                          if (v393) {
                                            continue;
                                          }
                                        }

                                        goto LABEL_984;
                                      }
                                    }

                                    goto LABEL_987;
                                  }

                                  int v834 = *(_DWORD *)v897;
                                  __nwlog_obj();
                                  *(_DWORD *)__int128 buf = 136446210;
                                  v900 = "__nw_frame_is_single_ip_aggregate";
                                  v654 = (void *)_os_log_send_and_compose_impl();
                                  type[0] = OS_LOG_TYPE_ERROR;
                                  char v898 = 0;
                                  if (__nwlog_fault())
                                  {
                                    if (type[0] == OS_LOG_TYPE_FAULT)
                                    {
                                      v655 = (os_log_s *)__nwlog_obj();
                                      os_log_type_t v656 = type[0];
                                      if (os_log_type_enabled(v655, type[0]))
                                      {
                                        *(_DWORD *)__int128 buf = 136446210;
                                        v900 = "__nw_frame_is_single_ip_aggregate";
                                        v657 = "%{public}s called with null frame";
LABEL_1876:
                                        v715 = v655;
                                        os_log_type_t v716 = v656;
LABEL_1877:
                                        _os_log_impl(&dword_1879E5000, v715, v716, v657, buf, 0xCu);
                                      }
                                    }

                                    else if (v898)
                                    {
                                      v667 = (void *)__nw_create_backtrace_string();
                                      v812 = (os_log_s *)__nwlog_obj();
                                      BOOL v668 = os_log_type_enabled(v812, type[0]);
                                      if (v667)
                                      {
                                        if (v668)
                                        {
                                          *(_DWORD *)__int128 buf = 136446466;
                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                          __int16 v901 = 2082;
                                          *(void *)v902 = v667;
                                          _os_log_impl( &dword_1879E5000,  v812,  type[0],  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                                        }

                                        free(v667);
                                        goto LABEL_1878;
                                      }

                                      if (v668)
                                      {
                                        *(_DWORD *)__int128 buf = 136446210;
                                        v900 = "__nw_frame_is_single_ip_aggregate";
                                        v657 = "%{public}s called with null frame, no backtrace";
                                        v715 = v812;
                                        os_log_type_t v716 = type[0];
                                        goto LABEL_1877;
                                      }
                                    }

                                    else
                                    {
                                      v655 = (os_log_s *)__nwlog_obj();
                                      os_log_type_t v656 = type[0];
                                      if (os_log_type_enabled(v655, type[0]))
                                      {
                                        *(_DWORD *)__int128 buf = 136446210;
                                        v900 = "__nw_frame_is_single_ip_aggregate";
                                        v657 = "%{public}s called with null frame, backtrace limit exceeded";
                                        goto LABEL_1876;
                                      }
                                    }
                                  }

LABEL_1878:
                                  if (v654) {
                                    free(v654);
                                  }
                                  int v374 = v834;
                                  unsigned int v376 = v844;
                                  goto LABEL_954;
                                }

                                uint64_t v637 = v244;
                                uint64_t v325 = v15;
                                if ((*(_BYTE *)(v15 + 828) & 2) != 0) {
                                  goto LABEL_1681;
                                }
                                v638 = (os_log_s *)__nwlog_tcp_log();
                                if (!os_log_type_enabled(v638, OS_LOG_TYPE_INFO)) {
                                  goto LABEL_1681;
                                }
                                v639 = "";
                                if (v15) {
                                  v639 = (const char *)(v15 + 604);
                                }
                                goto LABEL_1680;
                              }
                            }

                            else
                            {
                              int v347 = *(_DWORD *)(v338 + 88);
                            }

                            uint64_t v348 = v121;
                            *(_DWORD *)(v121 + 88) = v347 | 1;
                            goto LABEL_864;
                          case 3:
                            if ((v881 & 0x10) != 0
                              && (DWORD2(v920) - *(_DWORD *)(v121 + 92) < 1 || DWORD2(v920) - *(_DWORD *)(v121 + 96) > 0))
                            {
                              goto LABEL_647;
                            }

                            if ((v881 & 2) != 0 && *(_DWORD *)(v121 + 116) == DWORD1(v920) && (v894[0] & 0x20) == 0) {
                              *(_DWORD *)(v121 + 88) &= ~0x40u;
                            }
LABEL_585:
                            if ((v881 & 4) == 0)
                            {
                              if ((v894[0] & 1) == 0
                                || (int v231 = *(_DWORD *)(v121 + 276)) == 0
                                || DWORD1(v894[0]) - v231 >= 0)
                              {
LABEL_591:
                                uint64_t v232 = v828;
                                if (v229 == 3 && DWORD1(v920) - *(_DWORD *)(v121 + 116) < 0)
                                {
LABEL_647:
                                  int v131 = v822;
                                  goto LABEL_277;
                                }

                                if ((*(_WORD *)(v13 + 204) & 0x100) != 0 && *MEMORY[0x189608EF8])
                                {
                                  if (!((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)))
                                  {
                                    uint64_t v637 = v121;
                                    uint64_t v325 = v15;
                                    if ((*(_BYTE *)(v15 + 828) & 2) != 0) {
                                      goto LABEL_1681;
                                    }
                                    v638 = (os_log_s *)__nwlog_tcp_log();
                                    if (!os_log_type_enabled(v638, OS_LOG_TYPE_INFO)) {
                                      goto LABEL_1681;
                                    }
                                    v639 = "";
                                    if (v15) {
                                      v639 = (const char *)(v15 + 604);
                                    }
LABEL_1680:
                                    *(_DWORD *)__int128 buf = 136446466;
                                    v900 = "tcp_input";
                                    __int16 v901 = 2082;
                                    *(void *)v902 = v639;
                                    _os_log_impl( &dword_1879E5000,  v638,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping tcp input frame since frame is no longer valid",  buf,  0x16u);
LABEL_1681:
                                    *(void *)(v637 + 1056) = 0LL;
                                    goto LABEL_794;
                                  }

                                  int v227 = *(_DWORD *)(v121 + 120);
                                  uint64_t v232 = v828;
                                }

                                int v233 = v227 - DWORD1(v920);
                                int v234 = v846;
                                int v817 = v17;
                                if (v227 - DWORD1(v920) <= 0)
                                {
                                  unint64_t v258 = *(unsigned int *)v897;
                                  uint64_t v130 = v881;
                                  uint64_t v42 = v890;
LABEL_731:
                                  if ((_DWORD)v258)
                                  {
                                    int v290 = *(_DWORD *)(v15 + 364);
                                    BOOL v291 = (v290 & 0x1000000) == 0
                                        && (*(_WORD *)(v15 + 376) & 1) != 0
                                        && *(_DWORD *)(v121 + 12) > 5;
                                    if (*(_WORD *)(v15 + 376) & 0x20 | v291)
                                    {
                                      uint64_t v300 = *(void *)(v121 + 1056);
                                      if (v300) {
                                        ++*(void *)(v300 + 304);
                                      }
                                      tcp_close(v121);
                                      int v131 = v822;
                                      goto LABEL_278;
                                    }
                                  }

                                  int v292 = DWORD1(v920);
                                  int v293 = *(_DWORD *)(v121 + 120);
                                  int v294 = *(_DWORD *)(v121 + 128);
                                  int v295 = DWORD1(v920) + v258 - (v293 + v294);
                                  LODWORD(v846) = v234;
                                  BOOL v815 = v18;
                                  uint64_t v814 = a3;
                                  if (v295 < 1) {
                                    goto LABEL_1269;
                                  }
                                  v296 = *(void **)(v121 + 1056);
                                  int v883 = DWORD1(v920) + v258 - (v293 + v294);
                                  uint64_t v297 = v130;
                                  if (v296)
                                  {
                                    uint64_t v298 = v296[35];
                                    ++v296[34];
                                    if ((int)v258 > v295)
                                    {
                                      int v299 = v258;
                                      v296[35] = v298 + v295;
                                      goto LABEL_754;
                                    }

                                    v296[35] = v298 + (int)v258;
                                    if (v292 == v293 && !v294)
                                    {
                                      int v299 = v258;
                                      *(_DWORD *)(v837 + 88) |= 1u;
                                      ++v296[36];
LABEL_754:
                                      uint64_t v301 = *v43;
                                      if (*v43)
                                      {
                                        if ((*(_WORD *)(v301 + 204) & 0x80) != 0)
                                        {
                                          v302 = v43;
                                          unsigned int v303 = *(unsigned __int16 *)(v301 + 196);
                                          int v304 = v295;
                                          if (v295 > v303)
                                          {
                                            __nwlog_obj();
                                            int v305 = *(unsigned __int16 *)(v301 + 196);
                                            *(_DWORD *)__int128 buf = 136446722;
                                            v900 = "__nw_frame_array_claim";
                                            __int16 v901 = 1024;
                                            *(_DWORD *)v902 = v305;
                                            *(_WORD *)&v902[4] = 1024;
                                            *(_DWORD *)&v902[6] = v304;
                                            v306 = (void *)_os_log_send_and_compose_impl();
                                            type[0] = OS_LOG_TYPE_ERROR;
                                            char v898 = 0;
                                            if (__nwlog_fault())
                                            {
                                              if (type[0] == OS_LOG_TYPE_FAULT)
                                              {
                                                v307 = (os_log_s *)__nwlog_obj();
                                                os_log_type_t v308 = type[0];
                                                if (os_log_type_enabled(v307, type[0]))
                                                {
                                                  int v309 = *(unsigned __int16 *)(v301 + 196);
                                                  *(_DWORD *)__int128 buf = 136446722;
                                                  v900 = "__nw_frame_array_claim";
                                                  __int16 v901 = 1024;
                                                  *(_DWORD *)v902 = v309;
                                                  *(_WORD *)&v902[4] = 1024;
                                                  *(_DWORD *)&v902[6] = v883;
                                                  v310 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1242:
                                                  v508 = v307;
LABEL_1243:
                                                  _os_log_impl(&dword_1879E5000, v508, v308, v310, buf, 0x18u);
                                                }
                                              }

                                              else if (v898)
                                              {
                                                v359 = (void *)__nw_create_backtrace_string();
                                                os_log_type_t v308 = type[0];
                                                v840 = (os_log_s *)__nwlog_obj();
                                                BOOL v360 = os_log_type_enabled(v840, type[0]);
                                                if (v359)
                                                {
                                                  if (v360)
                                                  {
                                                    int v361 = *(unsigned __int16 *)(v301 + 196);
                                                    *(_DWORD *)__int128 buf = 136446978;
                                                    v900 = "__nw_frame_array_claim";
                                                    __int16 v901 = 1024;
                                                    *(_DWORD *)v902 = v361;
                                                    *(_WORD *)&v902[4] = 1024;
                                                    *(_DWORD *)&v902[6] = v883;
                                                    *(_WORD *)v903 = 2082;
                                                    *(void *)&v903[2] = v359;
                                                    _os_log_impl( &dword_1879E5000,  v840,  type[0],  "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s",  buf,  0x22u);
                                                  }

                                                  free(v359);
                                                  goto LABEL_1244;
                                                }

                                                if (v360)
                                                {
                                                  int v552 = *(unsigned __int16 *)(v301 + 196);
                                                  *(_DWORD *)__int128 buf = 136446722;
                                                  v900 = "__nw_frame_array_claim";
                                                  __int16 v901 = 1024;
                                                  *(_DWORD *)v902 = v552;
                                                  *(_WORD *)&v902[4] = 1024;
                                                  *(_DWORD *)&v902[6] = v883;
                                                  v310 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                  v508 = v840;
                                                  goto LABEL_1243;
                                                }
                                              }

                                              else
                                              {
                                                v307 = (os_log_s *)__nwlog_obj();
                                                os_log_type_t v308 = type[0];
                                                if (os_log_type_enabled(v307, type[0]))
                                                {
                                                  int v507 = *(unsigned __int16 *)(v301 + 196);
                                                  *(_DWORD *)__int128 buf = 136446722;
                                                  v900 = "__nw_frame_array_claim";
                                                  __int16 v901 = 1024;
                                                  *(_DWORD *)v902 = v507;
                                                  *(_WORD *)&v902[4] = 1024;
                                                  *(_DWORD *)&v902[6] = v883;
                                                  v310 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                                                  goto LABEL_1242;
                                                }
                                              }
                                            }

LABEL_1244:
                                            if (v306) {
                                              free(v306);
                                            }
                                            *(_WORD *)(v301 + 196) = 0;
LABEL_1247:
                                            int v43 = v302;
                                            int v295 = v883;
                                            goto LABEL_1248;
                                          }

                                          *(_WORD *)(v301 + 196) = v303 - v295;
                                        }

LABEL_1248:
                                        uint64_t v509 = **(void **)(v43[1] + 8);
                                        if (v509)
                                        {
                                          unsigned int v510 = 0;
                                          uint64_t v130 = v297;
                                          while (1)
                                          {
                                            uint64_t v511 = v130;
                                            int v512 = *(_DWORD *)(v509 + 52);
                                            unsigned int v513 = *(_DWORD *)(v509 + 56);
                                            int v514 = *(_DWORD *)(v509 + 60);
                                            unsigned int v515 = v512 - (v513 + v514);
                                            if (v515 >= v295 - v510) {
                                              unsigned int v515 = v295 - v510;
                                            }
                                            unsigned int v516 = v512 ? v515 : 0;
                                            int v517 = v514 + v516;
                                            if (v513 <= v512 - (v514 + v516))
                                            {
                                              *(_DWORD *)(v509 + 60) = v517;
                                            }

                                            else
                                            {
                                              v518 = (os_log_s *)__nwlog_obj();
                                              BOOL v519 = os_log_type_enabled(v518, OS_LOG_TYPE_ERROR);
                                              int v295 = v883;
                                              if (v519)
                                              {
                                                int v520 = *(_DWORD *)(v509 + 52);
                                                *(_DWORD *)__int128 buf = 136446978;
                                                v900 = "__nw_frame_claim_internal";
                                                __int16 v901 = 1024;
                                                *(_DWORD *)v902 = v513;
                                                *(_WORD *)&v902[4] = 1024;
                                                *(_DWORD *)&v902[6] = v520;
                                                *(_WORD *)v903 = 1024;
                                                *(_DWORD *)&v903[2] = v517;
                                                _os_log_impl( &dword_1879E5000,  v518,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
                                                int v295 = v883;
                                              }
                                            }

                                            v510 += v516;
                                            uint64_t v130 = v511;
                                            if (v510 == v295) {
                                              break;
                                            }
                                            if (*(_OWORD *)(v509 + 32) != 0LL && v510 < v295)
                                            {
                                              uint64_t v509 = **(void **)(*(void *)(v509 + 40) + 8LL);
                                              if (v509) {
                                                continue;
                                              }
                                            }

                                            goto LABEL_1265;
                                          }
                                        }

                                        else
                                        {
                                          unsigned int v510 = 0;
                                          LODWORD(v130) = v297;
LABEL_1265:
                                          if (v510 != v295)
                                          {
                                            v521 = (os_log_s *)__nwlog_obj();
                                            BOOL v522 = os_log_type_enabled(v521, OS_LOG_TYPE_ERROR);
                                            int v295 = v883;
                                            if (v522)
                                            {
                                              *(_DWORD *)__int128 buf = 136446722;
                                              v900 = "__nw_frame_array_claim";
                                              __int16 v901 = 1024;
                                              *(_DWORD *)v902 = v510;
                                              *(_WORD *)&v902[4] = 1024;
                                              *(_DWORD *)&v902[6] = v883;
                                              _os_log_impl( &dword_1879E5000,  v521,  OS_LOG_TYPE_ERROR,  "%{public}s end_offset %u != end_bytes %u",  buf,  0x18u);
                                              int v295 = v883;
                                            }
                                          }
                                        }

                                        unint64_t v258 = (v299 - v295);
                                        *(_DWORD *)v897 = v299 - v295;
                                        LODWORD(v130) = v130 & 0xFFFFFFF6;
                                        uint64_t v121 = v837;
LABEL_1269:
                                        if ((v894[0] & 1) != 0)
                                        {
                                          int v523 = *(_DWORD *)(v121 + 284);
                                          if (DWORD1(v920) - v523 <= 0
                                            && v523 - ((v130 & 3) != 0) - (DWORD1(v920) + (int)v258) <= 0)
                                          {
                                            *(_DWORD *)(v121 + 280) = *(_DWORD *)(v835 + 316);
                                            *(_DWORD *)(v121 + 276) = DWORD1(v894[0]);
                                          }
                                        }

                                        if ((v130 & 2) == 0)
                                        {
                                          unint64_t v119 = v258;
                                          int v524 = *(_DWORD *)(v121 + 12);
                                          if ((v130 & 0x10) == 0) {
                                            goto LABEL_1275;
                                          }
                                          goto LABEL_1282;
                                        }

                                        if ((int)v258 >= 1
                                          && DWORD1(v920) == *(_DWORD *)(v121 + 116)
                                          && !(*(void *)(*(void *)(*(void *)(v121 + 80) + 248LL) + 8LL) >> 31))
                                        {
                                          unint64_t v119 = v258;
                                          ++DWORD1(v920);
                                          LODWORD(v130) = v130 & 0xFFFFFFFD;
                                          int v524 = *(_DWORD *)(v121 + 12);
                                          if ((v130 & 0x10) == 0)
                                          {
LABEL_1275:
                                            if (v524 == 3)
                                            {
                                              uint64_t v410 = v121;
                                              if ((*(_BYTE *)(v121 + 742) & 0x40) != 0)
                                              {
                                                *(_DWORD *)(v121 + 100) = *(_DWORD *)(v121 + 92);
                                                int v845 = (BYTE13(v920) >> 1) & 1;
                                              }

                                              else
                                              {
                                                int v845 = 0;
                                              }

                                              LOBYTE(v411) = v130;
                                              tcp_input_process_accecn_syn( (int64x2_t *)v121,  ((unsigned __int16)v130 | (unsigned __int16)(BYTE12(v920) << 8)) & 0x1C0,  log);
                                              int v408 = 0;
                                              int v839 = 0;
                                              BOOL v18 = v815;
                                              a3 = v814;
                                              unint64_t v119 = 0x18C4CE000LL;
                                              goto LABEL_1113;
                                            }

                                            int v43 = a1;
                                            uint64_t v42 = v890;
                                            int v131 = v822;
                                            if ((*(_BYTE *)(v121 + 88) & 1) != 0) {
                                              goto LABEL_1294;
                                            }
LABEL_1327:
                                            int v54 = v847;
LABEL_1328:
                                            if (v131) {
                                              soabort(v15);
                                            }
                                            goto LABEL_1330;
                                          }

LABEL_1282:
                                          int v525 = v130;
                                          uint64_t v410 = v121;
                                          int v839 = 0;
                                          if (v524 != 3)
                                          {
                                            int v408 = 0;
                                            int v845 = 0;
                                            goto LABEL_1388;
                                          }

                                          uint64_t v538 = *(void *)(v121 + 1056);
                                          if (v538) {
                                            ++*(void *)(v538 + 408);
                                          }
                                          if ((~*(_DWORD *)(v121 + 88) & 0x60) == 0)
                                          {
                                            char v539 = *(_BYTE *)(v121 + 263);
                                            *(_BYTE *)(v121 + 260) = v539;
                                            *(_BYTE *)(v121 + 261) = *(_BYTE *)(v121 + 262);
                                            int v540 = HIWORD(v920) << v539;
                                            *(_DWORD *)(v121 + 140) = v540;
                                            unsigned int v820 = v540;
                                            *(_DWORD *)(v121 + 252) = v540;
                                            if (*(void *)(v15 + 24))
                                            {
                                              uint64_t v541 = nw_protocol_tcp_get_all_stats();
                                              unsigned int v820 = *(_DWORD *)(v121 + 140);
                                              if (v541)
                                              {
                                                *(_DWORD *)(v541 + 112) = v820;
                                                unsigned int v820 = *(_DWORD *)(v121 + 140);
                                              }
                                            }
                                          }

                                          *(_DWORD *)(v121 + 168) = *(_DWORD *)(v835 + 316);
                                          tcp_sbrcv_tstmp_check(v121);
                                          if ((*(_BYTE *)(v121 + 89) & 8) != 0)
                                          {
                                            *(_DWORD *)(v121 + 12) = 6;
                                            if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              if (__nwlog_is_datapath_logging_enabled())
                                              {
                                                v784 = (os_log_s *)__nwlog_tcp_log();
                                                if (os_log_type_enabled(v784, OS_LOG_TYPE_DEBUG))
                                                {
                                                  v785 = tcpstates[*(int *)(v410 + 12)];
                                                  v900 = "tcp_input";
                                                  v786 = "";
                                                  *(_DWORD *)__int128 buf = 136446722;
                                                  if (v15) {
                                                    v786 = (const char *)(v15 + 604);
                                                  }
                                                  __int16 v901 = 2082;
                                                  *(void *)v902 = v786;
                                                  *(_WORD *)&v902[8] = 2082;
                                                  *(void *)v903 = v785;
                                                  _os_log_impl( &dword_1879E5000,  v784,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                                }
                                              }
                                            }

                                            if (*(void *)(v15 + 24))
                                            {
                                              uint64_t v553 = nw_protocol_tcp_get_all_stats();
                                              if (v553) {
                                                *(_DWORD *)(v553 + 136) = 6;
                                              }
                                            }

                                            *(_DWORD *)(v410 + 88) &= ~0x800u;
                                          }

                                          else
                                          {
                                            *(_DWORD *)(v121 + 12) = 4;
                                            if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                            {
                                              if (__nwlog_is_datapath_logging_enabled())
                                              {
                                                v781 = (os_log_s *)__nwlog_tcp_log();
                                                if (os_log_type_enabled(v781, OS_LOG_TYPE_DEBUG))
                                                {
                                                  v782 = tcpstates[*(int *)(v410 + 12)];
                                                  v900 = "tcp_input";
                                                  v783 = "";
                                                  *(_DWORD *)__int128 buf = 136446722;
                                                  if (v15) {
                                                    v783 = (const char *)(v15 + 604);
                                                  }
                                                  __int16 v901 = 2082;
                                                  *(void *)v902 = v783;
                                                  *(_WORD *)&v902[8] = 2082;
                                                  *(void *)v903 = v782;
                                                  _os_log_impl( &dword_1879E5000,  v781,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                                }
                                              }
                                            }

                                            if (*(void *)(v15 + 24))
                                            {
                                              uint64_t v542 = nw_protocol_tcp_get_all_stats();
                                              if (v542) {
                                                *(_DWORD *)(v542 + 136) = 4;
                                              }
                                            }

                                            int v543 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v410 + 80)
                                                                                               + 224LL))
                                                             + 316);
                                            int v544 = *(_DWORD *)(v410 + 676);
                                            if (!v544
                                              || (*(_BYTE *)(*(void *)(*(void *)(v410 + 80) + 224LL) + 372LL) & 8) == 0)
                                            {
                                              int v544 = *(_DWORD *)(sysctls + 192);
                                            }

                                            *(_DWORD *)(v410 + 40) = v544 + v543 - *(_DWORD *)(v410 + 64);
                                            if (*(void *)(v15 + 24))
                                            {
                                              uint64_t v545 = nw_protocol_tcp_get_all_stats();
                                              if (v545) {
                                                ++*(_DWORD *)(v545 + 64);
                                              }
                                            }
                                          }

                                          *(_WORD *)(v410 + 308) = 16;
                                          if (*(void *)v410)
                                          {
                                            v774 = (os_log_s *)__nwlog_obj();
                                            os_log_type_enabled(v774, OS_LOG_TYPE_ERROR);
                                            *(_DWORD *)__int128 buf = 136446210;
                                            v900 = "tcp_input";
                                            v775 = (void *)_os_log_send_and_compose_impl();
                                            free(v775);
                                          }

                                          *(_DWORD *)(v410 + 104) = DWORD1(v920) - 1;
                                          int v554 = *(_DWORD *)(v410 + 740);
                                          if ((v554 & 0x10000000) == 0
                                            && ((v554 & 0x8000000) != 0
                                             || *(_DWORD *)(sysctls + 320) == 1
                                             || tcp_do_acc_ecn == 1)
                                            && (v525 & 0x12) == 0x10)
                                          {
                                            int v555 = *(_DWORD *)(v410 + 348);
                                            if ((v555 & 0x300000) == 0x300000)
                                            {
                                              if ((_DWORD)v119 || HIBYTE(v894[0]))
                                              {
                                                if (!HIBYTE(v894[0]))
                                                {
                                                  *(_DWORD *)(v410 + 420) = 5;
                                                  if (*(_DWORD *)(v410 + 364) == 5) {
                                                    *(_DWORD *)(v410 + 364) = 8;
                                                  }
                                                }
                                              }

                                              else
                                              {
                                                switch(((v525 | (BYTE12(v920) << 8)) >> 6) & 7)
                                                {
                                                  case 0u:
                                                    *(_DWORD *)(v410 + 348) = v555 & 0xFFDFFFF1;
                                                    if ((v555 & 0x200) != 0
                                                      && *(unsigned __int16 *)(v410 + 226) <= 2u
                                                      && (*(_DWORD *)(v410 + 364) & 0xFFFFFFFE) == 4)
                                                    {
                                                      *(_DWORD *)(v410 + 364) = 6;
                                                    }

                                                    if (*(_DWORD *)(v410 + 364) == 5)
                                                    {
                                                      int v669 = 7;
                                                      goto LABEL_1757;
                                                    }

                                                    break;
                                                  case 2u:
                                                    *(_DWORD *)(v410 + 420) = 5;
                                                    if (*(_DWORD *)(v410 + 364) == 5)
                                                    {
                                                      int v669 = 8;
                                                      goto LABEL_1757;
                                                    }

                                                    break;
                                                  case 3u:
                                                  case 4u:
                                                    *(_DWORD *)(v410 + 420) = 5;
                                                    goto LABEL_1753;
                                                  case 6u:
                                                    *(_DWORD *)(v410 + 420) = 6;
                                                    *(_DWORD *)(v410 + 144) = 2 * *(_DWORD *)(v410 + 196);
LABEL_1753:
                                                    if (*(_DWORD *)(v410 + 364) == 5)
                                                    {
                                                      int v669 = 9;
LABEL_1757:
                                                      *(_DWORD *)(v410 + 364) = v669;
                                                    }

                                                    break;
                                                  default:
                                                    *(_DWORD *)(v410 + 420) = 5;
                                                    break;
                                                }

                                                if ((v894[0] & 1) != 0)
                                                {
                                                  if (DWORD2(v894[0]))
                                                  {
                                                    int v670 = *(_DWORD *)(v410 + 400);
                                                    if (!v670 || ((DWORD2(v894[0]) - v670) & 0x80000000) == 0) {
                                                      *(_DWORD *)(v410 + 400) = DWORD2(v894[0]);
                                                    }
                                                  }
                                                }
                                              }

                                              tcp_input_ip_ecn(v410, v814, v119, v823, log);
                                            }
                                          }

                                          char v671 = *(_BYTE *)(v410 + 988);
                                          if ((v671 & 2) == 0)
                                          {
                                            int v839 = 1;
                                            goto LABEL_1769;
                                          }

                                          do
                                            unsigned int v672 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
                                          while (__stxr(v672 - 1, (unsigned int *)&tcp_tfo_halfcnt));
                                          if ((tcp_tfo_halfcnt & 0x80000000) == 0)
                                          {
LABEL_1768:
                                            int v839 = 0;
                                            *(_BYTE *)(v410 + 988) = v671 & 0xFD;
LABEL_1769:
                                            if (*(_DWORD *)(v15 + 384))
                                            {
                                              int v673 = *(_DWORD *)(v410 + 92) + 1;
                                              *(_DWORD *)(v410 + 92) = v673;
                                              if (*(void *)(v15 + 24))
                                              {
                                                uint64_t v674 = nw_protocol_tcp_get_all_stats();
                                                int v673 = *(_DWORD *)(v410 + 92);
                                                if (v674)
                                                {
                                                  *(_DWORD *)(v674 + 108) = *(_DWORD *)(v410 + 96) - v673;
                                                  int v673 = *(_DWORD *)(v410 + 92);
                                                }
                                              }

                                              if (*(_DWORD *)(v410 + 100) - v673 < 0) {
                                                *(_DWORD *)(v410 + 100) = v673;
                                              }
                                              if ((*(_BYTE *)(v410 + 740) & 0x20) != 0
                                                && (HIBYTE(v894[0]) || *(void *)(v410 + 544)))
                                              {
                                                tcp_sack_doack( v410,  (uint64_t)v894,  SDWORD2(v920),  (_DWORD *)&v896 + 1,  &v896);
                                              }

                                              goto LABEL_1779;
                                            }

LABEL_1283:
                                            if (DWORD2(v920) - *(_DWORD *)(v410 + 96) >= 1)
                                            {
                                              uint64_t v526 = *(void *)(v410 + 1056);
                                              if (v526) {
                                                ++*(void *)(v526 + 184);
                                              }
LABEL_1326:
                                              uint64_t v121 = v410;
                                              int is_ack_ratelimited = tcp_is_ack_ratelimited(v410);
                                              uint64_t v42 = v890;
                                              int v131 = v822;
                                              LODWORD(v130) = v525;
                                              int v43 = a1;
                                              if (!is_ack_ratelimited) {
                                                goto LABEL_1294;
                                              }
                                              goto LABEL_1327;
                                            }

                                            if (DWORD2(v920) - *(_DWORD *)(v410 + 92) + *(_DWORD *)(v410 + 252) < 0) {
                                              goto LABEL_1326;
                                            }
                                            char v536 = 1;
                                            if ((*(_BYTE *)(v410 + 740) & 0x20) != 0)
                                            {
                                              if (HIBYTE(v894[0]))
                                              {
                                                if (tcp_sack_process_dsack( v410,  (uint64_t)v894,  (uint64_t)&v920,  &v893))
                                                {
                                                  char v536 = 0;
                                                  if (DWORD2(v920) - *(_DWORD *)(v410 + 92) <= 0 && !HIBYTE(v894[0]))
                                                  {
                                                    tcp_bad_rexmt_check(v410, (uint64_t)&v920, (uint64_t)v894);
                                                    goto LABEL_1287;
                                                  }
                                                }
                                              }
                                            }

                                            int v546 = *(_DWORD *)(v410 + 740);
                                            if ((v546 & 0x20) != 0 && (HIBYTE(v894[0]) || *(void *)(v410 + 544)))
                                            {
                                              tcp_sack_doack( v410,  (uint64_t)v894,  SDWORD2(v920),  (_DWORD *)&v896 + 1,  &v896);
                                              int v546 = *(_DWORD *)(v410 + 740);
                                            }

                                            if ((v546 & 0x20400020) == 0x20000020)
                                            {
                                              if (v893) {
                                                char v547 = 1;
                                              }
                                              else {
                                                char v547 = v536;
                                              }
                                              if ((v547 & 1) == 0) {
                                                *(_BYTE *)(v410 + 2069) |= 0x40u;
                                              }
                                              tcp_rack_update_reordering_window(v410, SDWORD2(v920));
                                            }

                                            tcp_tfo_rcv_ack(v410, (uint64_t)&v920);
                                            if (DWORD2(v920) - *(_DWORD *)(v410 + 92) > 0)
                                            {
                                              int v548 = *(_DWORD *)(v410 + 88);
                                              if ((v548 & 0x200000) != 0)
                                              {
                                                if (DWORD2(v920) - *(_DWORD *)(v410 + 152) >= 0)
                                                {
                                                  BOOL v407 = *(_DWORD *)(sysctls + 276) != 0;
                                                  *(_DWORD *)(v410 + 88) = v548 & 0xFFDFFFFF;
                                                  *(_DWORD *)(v410 + 8) = 0;
                                                  *(_BYTE *)(v410 + 310) = 3;
                                                  *(_DWORD *)(v410 + 288) = 0;
                                                  *(_DWORD *)(v410 + 348) &= ~0x20u;
                                                  *(_DWORD *)(v410 + 16) = 0;
                                                  unsigned int v556 = *(_DWORD *)(v410 + 740) & 0xFFF7FFFF;
                                                  *(_DWORD *)(v410 + 740) = v556;
                                                  *(_DWORD *)(v410 + 984) = 0;
                                                  *(_DWORD *)(v410 + 628) = 0;
                                                  v557 = *(void (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v410 + 264)] + 72);
                                                  if (v557)
                                                  {
                                                    v557(v410, &v920);
                                                    unsigned int v556 = *(_DWORD *)(v410 + 740);
                                                  }

                                                  if ((v556 & 0x20400020) == 0x20000020
                                                    && (*(_BYTE *)(v410 + 2069) & 0x1F) != 0)
                                                  {
                                                    *(_BYTE *)(v410 + 2069) = *(_BYTE *)(v410 + 2069) & 0xE0 | (*(_BYTE *)(v410 + 2069) - 1) & 0x1F;
                                                  }

                                                  *(_DWORD *)(v410 + 972) = 0;
                                                  *(void *)(v410 + 964) = 0LL;
                                                  *(_BYTE *)(v410 + 751) = 0;
                                                  *(void *)(v410 + 980) = 0LL;
                                                  goto LABEL_1780;
                                                }

                                                if ((*(_BYTE *)(v410 + 348) & 0x20) == 0)
                                                {
                                                  int v563 = *(_DWORD *)(v410 + 740);
                                                  if ((v563 & 0x20400020) != 0x20000020)
                                                  {
                                                    if ((v563 & 0x20) != 0) {
                                                      tcp_sack_partialack(v410, (uint64_t)&v920);
                                                    }
                                                    else {
                                                      tcp_newreno_partial_ack((_DWORD *)v410, (uint64_t)&v920);
                                                    }
                                                  }
                                                }
                                              }

                                              else
                                              {
                                                int v549 = *(_DWORD *)(v410 + 740);
                                                if ((~v549 & 0x6000) != 0)
                                                {
                                                  BOOL v407 = 0;
                                                  *(_DWORD *)(v410 + 8) = 0;
                                                  *(_BYTE *)(v410 + 310) = 3;
                                                  goto LABEL_1780;
                                                }

                                                if (DWORD2(v920) - *(_DWORD *)(v410 + 152) >= 0
                                                  || !*(void *)(v410 + 544))
                                                {
                                                  BOOL v407 = 0;
                                                  *(_DWORD *)(v410 + 88) = v548 & 0xFFDFFFFF;
                                                  *(_BYTE *)(v410 + 310) = 3;
                                                  *(_DWORD *)(v410 + 348) &= ~0x20u;
                                                  *(_DWORD *)(v410 + 8) = 0;
                                                  *(_DWORD *)(v410 + 288) = 0;
                                                  *(void *)(v410 + 16) = 0LL;
                                                  *(_DWORD *)(v410 + 740) = v549 & 0xFFF7BFFF;
                                                  *(_DWORD *)(v410 + 984) = 0;
                                                  *(_DWORD *)(v410 + 628) = 0;
LABEL_1780:
                                                  BOOL v18 = v815;
                                                  a3 = v814;
                                                  int v411 = v525;
                                                  int v374 = v119;
                                                  goto LABEL_990;
                                                }
                                              }

LABEL_1779:
                                              BOOL v407 = 0;
                                              goto LABEL_1780;
                                            }

                                            int v550 = *(_DWORD *)(v410 + 740);
                                            if ((~v550 & 0x20000020) == 0
                                              && (v550 & 0x400000) == 0
                                              && HIDWORD(v896)
                                              && *(_DWORD *)(v410 + 560) - (int)v896 < 0)
                                            {
                                              *(_DWORD *)(v410 + 560) = v896;
                                            }

                                            if ((v550 & 0x10000000) == 0
                                              && ((v550 & 0x8000000) != 0
                                               || *(_DWORD *)(sysctls + 320) == 1
                                               || tcp_do_acc_ecn == 1))
                                            {
                                              int v551 = *(_DWORD *)(v410 + 348);
                                              if ((~v551 & 0x300000) == 0 && (v551 & 4) != 0 && !HIDWORD(v896))
                                              {
                                                ++*(_DWORD *)(v410 + 296);
                                                if ((v894[0] & 1) != 0
                                                  && DWORD2(v894[0])
                                                  && DWORD2(v894[0]) - *(_DWORD *)(v410 + 400) >= 1)
                                                {
                                                  tcp_process_accecn(v410, (uint64_t)v894, (uint64_t)&v920, 1u, v819);
                                                }
                                              }
                                            }

                                            if ((_DWORD)v119)
                                            {
                                              int v408 = 0;
                                              int v845 = 0;
                                            }

                                            else
                                            {
                                              if (v820 == *(_DWORD *)(v410 + 140)
                                                || (int v408 = 0, HIBYTE(v894[0])) && HIDWORD(v896))
                                              {
                                                if ((v525 & 1) != 0)
                                                {
                                                  int v833 = 0;
                                                  int v408 = 0;
                                                  int v845 = 0;
                                                  BOOL v18 = v815;
                                                  a3 = v814;
                                                  unint64_t v119 = 0x18C4CE000LL;
                                                  LOBYTE(v411) = v525;
                                                  if (*(int *)(v410 + 12) < 10)
                                                  {
LABEL_1113:
                                                    int v461 = *(_DWORD *)v897;
                                                    char updated = tcp_update_window( v410,  v411,  (uint64_t)&v920,  v820,  *(int *)v897);
                                                    uint64_t v462 = v410;
                                                    char v463 = v411;
                                                    if ((v411 & 0x20) == 0 || !v921 || *(int *)(v462 + 12) > 9)
                                                    {
                                                      int v464 = *(_DWORD *)(v462 + 120);
                                                      if (v464 - *(_DWORD *)(v462 + 136) >= 1) {
                                                        *(_DWORD *)(v462 + 136) = v464;
                                                      }
                                                      uint64_t v42 = v890;
LABEL_1125:
                                                      if (v839)
                                                      {
                                                        soisconnected(v15);
                                                        if (v826) {
                                                          _BYTE *v826 = 1;
                                                        }
                                                      }

                                                      else if (v408)
                                                      {
                                                        *(_WORD *)(v15 + 376) = *(_WORD *)(v15 + 376) & 0xDFC1 | 0x2030;
                                                        uint64_t v465 = *(void *)(v15 + 32);
                                                        if (v465)
                                                        {
                                                          v466 = *(void (**)(uint64_t))(v465 + 56);
                                                          if (v466) {
                                                            v466(v15);
                                                          }
                                                        }
                                                      }

                                                      if (*(_DWORD *)(a3 + 232) == 3)
                                                      {
                                                        int v43 = a1;
LABEL_1288:
                                                        int v54 = v847;
                                                        goto LABEL_1289;
                                                      }

                                                      if (!(v461 | v463 & 1)
                                                        || (int v467 = *(_DWORD *)(v462 + 12), v467 > 9)
                                                        || (BOOL v816 = v18, v467 <= 3)
                                                        && (v467 != 3 || (*(_BYTE *)(v462 + 988) & 2) == 0))
                                                      {
                                                        char v470 = 0;
                                                        v471 = a1;
                                                        int v472 = *(_DWORD *)(v462 + 740);
                                                        if ((v472 & 0x10000000) != 0) {
                                                          goto LABEL_1591;
                                                        }
LABEL_1156:
                                                        if (((v472 & 0x8000000) != 0
                                                           || *(_DWORD *)(*(void *)(v119 + 2528) + 320LL) == 1
                                                           || tcp_do_acc_ecn == 1)
                                                          && (~*(_DWORD *)(v462 + 348) & 0x300000) == 0
                                                          && (*(_DWORD *)(v462 + 12) - 4) <= 5)
                                                        {
                                                          unsigned __int16 v473 = *(_WORD *)(v462 + 306);
                                                          if (v821
                                                            && (v473 += v823,
                                                                *(_WORD *)(v462 + 306) = v473,
                                                                *(_DWORD *)(v462 + 408) != 3)
                                                            || v473 >= 2u
                                                            && (v473 != 2
                                                             || *(_DWORD *)(v462 + 284) != *(_DWORD *)(v462 + 120)))
                                                          {
                                                            *(_DWORD *)(v462 + 88) |= 1u;
                                                          }

                                                          *(_DWORD *)(v462 + 408) = log;
                                                        }

LABEL_1591:
                                                        if ((v470 & 1) != 0)
                                                        {
                                                          int v624 = *(_DWORD *)(v462 + 12);
                                                          if (v624 <= 9)
                                                          {
                                                            *(_WORD *)(v15 + 376) |= 0x20u;
                                                            uint64_t v625 = *(void *)(v15 + 32);
                                                            if (v625)
                                                            {
                                                              v626 = *(void (**)(uint64_t))(v625 + 40);
                                                              if (v626)
                                                              {
                                                                v626(v15);
                                                                int v624 = *(_DWORD *)(v462 + 12);
                                                              }
                                                            }

                                                            *(_WORD *)(v462 + 304) += v823;
                                                            *(_DWORD *)(v462 + 88) |= 1u;
                                                            ++*(_DWORD *)(v462 + 120);
                                                          }

                                                          switch(v624)
                                                          {
                                                            case 3:
                                                              *(_DWORD *)(v462 + 168) = *(_DWORD *)(v835 + 316);
                                                              goto LABEL_1625;
                                                            case 4:
LABEL_1625:
                                                              uint64_t v627 = v462;
                                                              *(_DWORD *)(v462 + 12) = 5;
                                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                              {
                                                                if (__nwlog_is_datapath_logging_enabled())
                                                                {
                                                                  v717 = (os_log_s *)__nwlog_tcp_log();
                                                                  if (os_log_type_enabled(v717, OS_LOG_TYPE_DEBUG))
                                                                  {
                                                                    v718 = tcpstates[*(int *)(v627 + 12)];
                                                                    v900 = "tcp_input";
                                                                    v719 = "";
                                                                    *(_DWORD *)__int128 buf = 136446722;
                                                                    if (v15) {
                                                                      v719 = (const char *)(v15 + 604);
                                                                    }
                                                                    __int16 v901 = 2082;
                                                                    *(void *)v902 = v719;
                                                                    *(_WORD *)&v902[8] = 2082;
                                                                    *(void *)v903 = v718;
                                                                    _os_log_impl( &dword_1879E5000,  v717,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                                                  }
                                                                }
                                                              }

                                                              uint64_t v462 = v627;
                                                              if (*(void *)(v15 + 24))
                                                              {
                                                                uint64_t v628 = nw_protocol_tcp_get_all_stats();
                                                                if (v628) {
                                                                  *(_DWORD *)(v628 + 136) = 5;
                                                                }
                                                              }

                                                              break;
                                                            case 6:
                                                              uint64_t v629 = v462;
                                                              *(_DWORD *)(v462 + 12) = 7;
                                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                              {
                                                                if (__nwlog_is_datapath_logging_enabled())
                                                                {
                                                                  v753 = (os_log_s *)__nwlog_tcp_log();
                                                                  if (os_log_type_enabled(v753, OS_LOG_TYPE_DEBUG))
                                                                  {
                                                                    v754 = tcpstates[*(int *)(v629 + 12)];
                                                                    v900 = "tcp_input";
                                                                    v755 = "";
                                                                    *(_DWORD *)__int128 buf = 136446722;
                                                                    if (v15) {
                                                                      v755 = (const char *)(v15 + 604);
                                                                    }
                                                                    __int16 v901 = 2082;
                                                                    *(void *)v902 = v755;
                                                                    *(_WORD *)&v902[8] = 2082;
                                                                    *(void *)v903 = v754;
                                                                    _os_log_impl( &dword_1879E5000,  v753,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                                                  }
                                                                }
                                                              }

                                                              uint64_t v462 = v629;
                                                              if (*(void *)(v15 + 24))
                                                              {
                                                                uint64_t v630 = nw_protocol_tcp_get_all_stats();
                                                                if (v630) {
                                                                  *(_DWORD *)(v630 + 136) = 7;
                                                                }
                                                              }

                                                              break;
                                                            case 9:
                                                              uint64_t v631 = v462;
                                                              *(_DWORD *)(v462 + 12) = 10;
                                                              if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                              {
                                                                if (__nwlog_is_datapath_logging_enabled())
                                                                {
                                                                  v756 = (os_log_s *)__nwlog_tcp_log();
                                                                  if (os_log_type_enabled(v756, OS_LOG_TYPE_DEBUG))
                                                                  {
                                                                    v757 = tcpstates[*(int *)(v631 + 12)];
                                                                    v900 = "tcp_input";
                                                                    v758 = "";
                                                                    *(_DWORD *)__int128 buf = 136446722;
                                                                    if (v15) {
                                                                      v758 = (const char *)(v15 + 604);
                                                                    }
                                                                    __int16 v901 = 2082;
                                                                    *(void *)v902 = v758;
                                                                    *(_WORD *)&v902[8] = 2082;
                                                                    *(void *)v903 = v757;
                                                                    _os_log_impl( &dword_1879E5000,  v756,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  buf,  0x20u);
                                                                  }
                                                                }
                                                              }

                                                              if (*(void *)(v15 + 24))
                                                              {
                                                                uint64_t v632 = nw_protocol_tcp_get_all_stats();
                                                                if (v632) {
                                                                  *(_DWORD *)(v632 + 136) = 10;
                                                                }
                                                              }

                                                              tcp_canceltimers(v631);
                                                              int v633 = *(_DWORD *)(v631 + 88);
                                                              *(_DWORD *)(v631 + 88) = v633 | 1;
                                                              if ((*(_BYTE *)(v631 + 741) & 8) != 0) {
                                                                *(_DWORD *)(v631 + 88) = v633 | 0x8000001;
                                                              }
                                                              else {
                                                                add_to_time_wait( v631,  2 * *(_DWORD *)(*(void *)(v119 + 2528) + 204LL));
                                                              }
                                                              *(_WORD *)(v15 + 376) = *(_WORD *)(v15 + 376) & 0xDFC1 | 0x2030;
                                                              uint64_t v634 = *(void *)(v15 + 32);
                                                              uint64_t v462 = v631;
                                                              if (v634)
                                                              {
                                                                v635 = *(void (**)(uint64_t))(v634 + 56);
                                                                if (v635) {
                                                                  v635(v15);
                                                                }
                                                              }

                                                              break;
                                                            case 10:
                                                              add_to_time_wait( v462,  2 * *(_DWORD *)(*(void *)(v119 + 2528) + 204LL));
                                                              break;
                                                            default:
                                                              break;
                                                          }
                                                        }

                                                        char v615 = updated;
                                                        if (v845) {
                                                          char v615 = 1;
                                                        }
                                                        if ((v615 & 1) != 0 || (*(_BYTE *)(v462 + 88) & 1) != 0) {
                                                          tcp_output(v462);
                                                        }
                                                        tcp_check_timer_state(v462);
                                                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))( v15,  1LL,  v6);
                                                        BOOL *v890 = v847 != 0;
                                                        uint64_t result = (void *)*v471;
                                                        if (!*v471) {
                                                          return result;
                                                        }
                                                        while (1)
                                                        {
                                                          v616 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                                          v617 = (void *)result[4];
                                                          if (!v616) {
                                                            break;
                                                          }
                                                          uint64_t v618 = result[11];
                                                          result[10] = 0LL;
                                                          result[11] = 0LL;
                                                          v616(result, 1LL, v618);
LABEL_1600:
                                                          uint64_t result = v617;
                                                          if (!v617) {
                                                            return result;
                                                          }
                                                        }

                                                        __nwlog_obj();
                                                        *(_DWORD *)__int128 buf = 136446210;
                                                        v900 = "__nw_frame_finalize";
                                                        uint64_t v619 = _os_log_send_and_compose_impl();
                                                        type[0] = OS_LOG_TYPE_ERROR;
                                                        char v898 = 0;
                                                        v887 = (void *)v619;
                                                        if (__nwlog_fault())
                                                        {
                                                          if (type[0] == OS_LOG_TYPE_FAULT)
                                                          {
                                                            v871 = (os_log_s *)__nwlog_obj();
                                                            os_log_type_t logf = type[0];
                                                            if (!os_log_type_enabled(v871, type[0])) {
                                                              goto LABEL_1616;
                                                            }
                                                            *(_DWORD *)__int128 buf = 136446210;
                                                            v900 = "__nw_frame_finalize";
                                                            v620 = v871;
                                                            os_log_type_t v621 = logf;
                                                            v622 = "%{public}s called with null frame->finalizer";
                                                            goto LABEL_1615;
                                                          }

                                                          if (!v898)
                                                          {
                                                            v873 = (os_log_s *)__nwlog_obj();
                                                            os_log_type_t logh = type[0];
                                                            if (!os_log_type_enabled(v873, type[0])) {
                                                              goto LABEL_1616;
                                                            }
                                                            *(_DWORD *)__int128 buf = 136446210;
                                                            v900 = "__nw_frame_finalize";
                                                            v620 = v873;
                                                            os_log_type_t v621 = logh;
                                                            v622 = "%{public}s called with null frame->finalizer, backtra"
                                                                   "ce limit exceeded";
                                                            goto LABEL_1615;
                                                          }

                                                          v872 = (void *)__nw_create_backtrace_string();
                                                          logg = (os_log_s *)__nwlog_obj();
                                                          os_log_type_t v850 = type[0];
                                                          BOOL v623 = os_log_type_enabled(logg, type[0]);
                                                          if (v872)
                                                          {
                                                            if (v623)
                                                            {
                                                              *(_DWORD *)__int128 buf = 136446466;
                                                              v900 = "__nw_frame_finalize";
                                                              __int16 v901 = 2082;
                                                              *(void *)v902 = v872;
                                                              _os_log_impl( &dword_1879E5000,  logg,  v850,  "%{public}s called with null frame->finalizer, dumping ba cktrace:%{public}s",  buf,  0x16u);
                                                            }

                                                            free(v872);
                                                            goto LABEL_1616;
                                                          }

                                                          if (v623)
                                                          {
                                                            *(_DWORD *)__int128 buf = 136446210;
                                                            v900 = "__nw_frame_finalize";
                                                            v620 = logg;
                                                            os_log_type_t v621 = v850;
                                                            v622 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1615:
                                                            _os_log_impl(&dword_1879E5000, v620, v621, v622, buf, 0xCu);
                                                          }
                                                        }

LABEL_1616:
                                                        if (v887) {
                                                          free(v887);
                                                        }
                                                        goto LABEL_1600;
                                                      }

                                                      int v841 = DWORD1(v920) + v461;
                                                      int v832 = DWORD1(v920);
                                                      if (DWORD1(v920) != *(_DWORD *)(v462 + 120) || *(void *)v462)
                                                      {
                                                        *(_DWORD *)os_log_type_t type = 0;
                                                        if (*(_DWORD *)(v462 + 1916) - v841 < 0)
                                                        {
                                                          *(_DWORD *)(v462 + 1916) = v841;
                                                          if ((v894[0] & 1) != 0) {
                                                            *(_DWORD *)(v462 + 1920) = DWORD1(v894[0]);
                                                          }
                                                        }

                                                        tcp_compute_rcv_rtt(v462, (uint64_t)v894, (uint64_t)&v920);
                                                        uint64_t v468 = sysctls;
                                                        if (*(_DWORD *)(sysctls + 260))
                                                        {
                                                          tcp_sbrcv_grow(v837, v15 + 488, (uint64_t)v894, v461);
                                                          uint64_t v468 = sysctls;
                                                        }

                                                        if (*(_DWORD *)(v468 + 308) == 1
                                                          && (~*(_DWORD *)(v837 + 88) & 0x180) == 0
                                                          && (*(_DWORD *)(v468 + 40) == 1
                                                           || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                                                          && off_18C4CE830)
                                                        {
                                                          off_18C4CE830(v837, (uint64_t)&v920, (uint64_t)v894, v461);
                                                        }

                                                        char v469 = tcp_reass(v837, (int *)v897, a1, v827, v846, v848, type);
                                                        if (*(_DWORD *)type)
                                                        {
                                                          if ((*(_WORD *)(v13 + 204) & 0x100) != 0
                                                            && *MEMORY[0x189608EF8]
                                                            && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)) & 1) == 0)
                                                          {
                                                            if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                            {
                                                              v720 = (os_log_s *)__nwlog_tcp_log();
                                                              if (os_log_type_enabled(v720, OS_LOG_TYPE_INFO))
                                                              {
                                                                v721 = "";
                                                                if (v15) {
                                                                  v721 = (const char *)(v15 + 604);
                                                                }
                                                                *(_DWORD *)__int128 buf = 136446466;
                                                                v900 = "tcp_input";
                                                                __int16 v901 = 2082;
                                                                *(void *)v902 = v721;
                                                                _os_log_impl( &dword_1879E5000,  v720,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s frame no longer valid",  buf,  0x16u);
                                                              }
                                                            }

                                                            *(void *)(v837 + 1056) = 0LL;
                                                          }

                                                          int v54 = 0;
                                                          int v43 = a1;
                                                          uint64_t v42 = v890;
                                                          goto LABEL_1289;
                                                        }

                                                        char v470 = v469;
                                                        *(_DWORD *)(v837 + 88) |= 1u;
                                                        int v461 = *(_DWORD *)v897;
                                                        if (*(int *)v897 > 0)
                                                        {
                                                          int v847 = 0;
                                                          goto LABEL_1585;
                                                        }

                                                        int v847 = 0;
                                                        char v484 = BYTE13(v920);
LABEL_1194:
                                                        if ((v484 & 1) == 0)
                                                        {
                                                          uint64_t v462 = v837;
                                                          tcp_adaptive_rwtimo_check(v837, v461);
                                                          goto LABEL_1590;
                                                        }

LABEL_1585:
                                                        if ((*(_BYTE *)(v837 + 740) & 0x20) != 0) {
                                                          tcp_update_sack_list( (_DWORD *)v837,  v832,  v841 + (BYTE13(v920) & 1));
                                                        }
                                                        uint64_t v462 = v837;
                                                        tcp_adaptive_rwtimo_check(v837, v461);
                                                        if (v461 >= 1 && *(_BYTE *)(v837 + 993)) {
                                                          *(_BYTE *)(v837 + 993) = 0;
                                                        }
LABEL_1590:
                                                        v471 = a1;
                                                        unint64_t v119 = 0x18C4CE000uLL;
                                                        int v472 = *(_DWORD *)(v462 + 740);
                                                        if ((v472 & 0x10000000) != 0) {
                                                          goto LABEL_1591;
                                                        }
                                                        goto LABEL_1156;
                                                      }

                                                      uint64_t v488 = *a1;
                                                      if (*a1)
                                                      {
                                                        if ((*(_WORD *)(v488 + 204) & 0x80) != 0)
                                                        {
                                                          unsigned int v489 = *(unsigned __int16 *)(v488 + 196);
                                                          if (v846 > v489)
                                                          {
                                                            __nwlog_obj();
                                                            int v490 = *(unsigned __int16 *)(v488 + 196);
                                                            *(_DWORD *)__int128 buf = 136446722;
                                                            v900 = "__nw_frame_array_claim";
                                                            __int16 v901 = 1024;
                                                            *(_DWORD *)v902 = v490;
                                                            *(_WORD *)&v902[4] = 1024;
                                                            *(_DWORD *)&v902[6] = v846;
                                                            v491 = (void *)_os_log_send_and_compose_impl();
                                                            type[0] = OS_LOG_TYPE_ERROR;
                                                            char v898 = 0;
                                                            if (__nwlog_fault())
                                                            {
                                                              if (type[0] == OS_LOG_TYPE_FAULT)
                                                              {
                                                                v492 = (os_log_s *)__nwlog_obj();
                                                                os_log_type_t v493 = type[0];
                                                                if (os_log_type_enabled(v492, type[0]))
                                                                {
                                                                  int v494 = *(unsigned __int16 *)(v488 + 196);
                                                                  *(_DWORD *)__int128 buf = 136446722;
                                                                  v900 = "__nw_frame_array_claim";
                                                                  __int16 v901 = 1024;
                                                                  *(_DWORD *)v902 = v494;
                                                                  *(_WORD *)&v902[4] = 1024;
                                                                  *(_DWORD *)&v902[6] = v846;
                                                                  v495 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1529:
                                                                  v594 = v492;
                                                                  os_log_type_t v595 = v493;
LABEL_1530:
                                                                  _os_log_impl( &dword_1879E5000,  v594,  v595,  v495,  buf,  0x18u);
                                                                }
                                                              }

                                                              else if (v898)
                                                              {
                                                                v575 = (void *)__nw_create_backtrace_string();
                                                                v576 = (os_log_s *)__nwlog_obj();
                                                                BOOL v577 = os_log_type_enabled(v576, type[0]);
                                                                if (v575)
                                                                {
                                                                  if (v577)
                                                                  {
                                                                    int v578 = *(unsigned __int16 *)(v488 + 196);
                                                                    *(_DWORD *)__int128 buf = 136446978;
                                                                    v900 = "__nw_frame_array_claim";
                                                                    __int16 v901 = 1024;
                                                                    *(_DWORD *)v902 = v578;
                                                                    *(_WORD *)&v902[4] = 1024;
                                                                    *(_DWORD *)&v902[6] = v846;
                                                                    *(_WORD *)v903 = 2082;
                                                                    *(void *)&v903[2] = v575;
                                                                    _os_log_impl( &dword_1879E5000,  v576,  type[0],  "%{public}s Aggregate buffer length: %u sum: %u, du mping backtrace:%{public}s",  buf,  0x22u);
                                                                  }

                                                                  free(v575);
                                                                  goto LABEL_1531;
                                                                }

                                                                if (v577)
                                                                {
                                                                  int v640 = *(unsigned __int16 *)(v488 + 196);
                                                                  *(_DWORD *)__int128 buf = 136446722;
                                                                  v900 = "__nw_frame_array_claim";
                                                                  __int16 v901 = 1024;
                                                                  *(_DWORD *)v902 = v640;
                                                                  *(_WORD *)&v902[4] = 1024;
                                                                  *(_DWORD *)&v902[6] = v846;
                                                                  v495 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                                                                  v594 = v576;
                                                                  os_log_type_t v595 = type[0];
                                                                  goto LABEL_1530;
                                                                }
                                                              }

                                                              else
                                                              {
                                                                v492 = (os_log_s *)__nwlog_obj();
                                                                os_log_type_t v493 = type[0];
                                                                if (os_log_type_enabled(v492, type[0]))
                                                                {
                                                                  int v593 = *(unsigned __int16 *)(v488 + 196);
                                                                  *(_DWORD *)__int128 buf = 136446722;
                                                                  v900 = "__nw_frame_array_claim";
                                                                  __int16 v901 = 1024;
                                                                  *(_DWORD *)v902 = v593;
                                                                  *(_WORD *)&v902[4] = 1024;
                                                                  *(_DWORD *)&v902[6] = v846;
                                                                  v495 = "%{public}s Aggregate buffer length: %u sum: %u,"
                                                                         " backtrace limit exceeded";
                                                                  goto LABEL_1529;
                                                                }
                                                              }
                                                            }

LABEL_1531:
                                                            if (v491) {
                                                              free(v491);
                                                            }
                                                            *(_WORD *)(v488 + 196) = 0;
LABEL_1534:
                                                            uint64_t v596 = *a1;
                                                            if (*a1)
                                                            {
                                                              unsigned int v597 = 0;
                                                              while (1)
                                                              {
                                                                int v598 = *(_DWORD *)(v596 + 52);
                                                                int v599 = *(_DWORD *)(v596 + 56);
                                                                int v600 = *(_DWORD *)(v596 + 60);
                                                                unsigned int v601 = v598 - (v599 + v600);
                                                                unsigned int v602 = v598 ? v601 : 0;
                                                                int v603 = v599 + v602;
                                                                if (v599 + v602 <= v598 - v600)
                                                                {
                                                                  *(_DWORD *)(v596 + 56) = v603;
                                                                  *(_DWORD *)(v596 + 60) = v600;
                                                                }

                                                                else
                                                                {
                                                                  v604 = (os_log_s *)__nwlog_obj();
                                                                  if (os_log_type_enabled(v604, OS_LOG_TYPE_ERROR))
                                                                  {
                                                                    int v605 = *(_DWORD *)(v596 + 52);
                                                                    *(_DWORD *)__int128 buf = 136446978;
                                                                    v900 = "__nw_frame_claim_internal";
                                                                    __int16 v901 = 1024;
                                                                    *(_DWORD *)v902 = v603;
                                                                    *(_WORD *)&v902[4] = 1024;
                                                                    *(_DWORD *)&v902[6] = v605;
                                                                    *(_WORD *)v903 = 1024;
                                                                    *(_DWORD *)&v903[2] = v600;
                                                                    _os_log_impl( &dword_1879E5000,  v604,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
                                                                  }
                                                                }

                                                                v597 += v602;
                                                                if (v597 == (_DWORD)v846) {
                                                                  break;
                                                                }
                                                                if (v597 < v846)
                                                                {
                                                                  uint64_t v596 = *(void *)(v596 + 32);
                                                                  if (v596) {
                                                                    continue;
                                                                  }
                                                                }

                                                                goto LABEL_1550;
                                                              }
                                                            }

                                                            else
                                                            {
                                                              unsigned int v597 = 0;
LABEL_1550:
                                                              if (v597 != (_DWORD)v846)
                                                              {
                                                                v606 = (os_log_s *)__nwlog_obj();
                                                                if (os_log_type_enabled(v606, OS_LOG_TYPE_ERROR))
                                                                {
                                                                  *(_DWORD *)__int128 buf = 136446722;
                                                                  v900 = "__nw_frame_array_claim";
                                                                  __int16 v901 = 1024;
                                                                  *(_DWORD *)v902 = v597;
                                                                  *(_WORD *)&v902[4] = 1024;
                                                                  *(_DWORD *)&v902[6] = v846;
                                                                  _os_log_impl( &dword_1879E5000,  v606,  OS_LOG_TYPE_ERROR,  "%{public}s start_offset %u != start_bytes %u",  buf,  0x18u);
                                                                }
                                                              }
                                                            }

LABEL_1553:
                                                            if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                            {
                                                              if (__nwlog_is_datapath_logging_enabled())
                                                              {
                                                                v772 = (os_log_s *)__nwlog_tcp_log();
                                                                if (os_log_type_enabled(v772, OS_LOG_TYPE_DEBUG))
                                                                {
                                                                  v773 = (const char *)(v15 + 604);
                                                                  v900 = "tcp_input";
                                                                  *(_DWORD *)__int128 buf = 136446722;
                                                                  if (!v15) {
                                                                    v773 = "";
                                                                  }
                                                                  __int16 v901 = 2082;
                                                                  *(void *)v902 = v773;
                                                                  *(_WORD *)&v902[8] = 1024;
                                                                  *(_DWORD *)v903 = v461;
                                                                  _os_log_impl( &dword_1879E5000,  v772,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s queueing frame of length %u - slowpath",  buf,  0x1Cu);
                                                                }
                                                              }
                                                            }

                                                            *(_WORD *)(v837 + 304) += v823;
                                                            tcp_compute_rcv_rtt(v837, (uint64_t)v894, (uint64_t)&v920);
                                                            v607 = *(unsigned int (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v837 + 264)] + 96);
                                                            if (v607
                                                              && v607(v837, &v920)
                                                              && (int v608 = *(_DWORD *)(v837 + 88), (v608 & 1) == 0))
                                                            {
                                                              if ((v608 & 2) == 0)
                                                              {
                                                                *(_DWORD *)(v837 + 88) = v608 | 2;
                                                                *(_DWORD *)(v837 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v837 + 80) + 224LL)) + 316)
                                                                                       - *(_DWORD *)(v837 + 64)
                                                                                       + 100;
                                                              }
                                                            }

                                                            else
                                                            {
                                                              *(_DWORD *)(v837 + 88) |= 1u;
                                                            }

                                                            int v609 = *(_DWORD *)(v837 + 120) + v461;
                                                            *(_DWORD *)(v837 + 120) = v609;
                                                            if (*(_DWORD *)(v837 + 1916) - v609 < 0)
                                                            {
                                                              *(_DWORD *)(v837 + 1916) = v609;
                                                              if ((v894[0] & 1) != 0) {
                                                                *(_DWORD *)(v837 + 1920) = DWORD1(v894[0]);
                                                              }
                                                            }

                                                            uint64_t v610 = *(void *)(v837 + 1056);
                                                            if (v610)
                                                            {
                                                              uint64_t v611 = *(void *)(v610 + 200) + v461;
                                                              ++*(void *)(v610 + 192);
                                                              *(void *)(v610 + 200) = v611;
                                                            }

                                                            char v612 = BYTE13(v920);
                                                            v613 = *(void **)(a3 + 248);
                                                            ++*v613;
                                                            if (v824)
                                                            {
                                                              ++**(void **)(a3 + 256);
                                                              if (!v817) {
                                                                goto LABEL_1569;
                                                              }
                                                            }

                                                            else if (!v817)
                                                            {
LABEL_1569:
                                                              if (!v816) {
                                                                goto LABEL_1571;
                                                              }
                                                              goto LABEL_1570;
                                                            }

                                                            ++**(void **)(a3 + 264);
                                                            if (!v816)
                                                            {
LABEL_1571:
                                                              v613[1] += v461;
                                                              if (v824)
                                                              {
                                                                *(void *)(*(void *)(a3 + 256) + 8LL) += v461;
                                                                if (!v817) {
                                                                  goto LABEL_1573;
                                                                }
                                                              }

                                                              else if (!v817)
                                                              {
LABEL_1573:
                                                                if (!v816) {
                                                                  goto LABEL_1575;
                                                                }
                                                                goto LABEL_1574;
                                                              }

                                                              *(void *)(*(void *)(a3 + 264) + 8LL) += v461;
                                                              if (!v816)
                                                              {
LABEL_1575:
                                                                char v470 = v612 & 1;
                                                                tcp_sbrcv_grow(v837, v15 + 488, (uint64_t)v894, v461);
                                                                if (*(_DWORD *)(sysctls + 308) == 1
                                                                  && (~*(_DWORD *)(v837 + 88) & 0x180) == 0
                                                                  && (*(_DWORD *)(sysctls + 40) == 1
                                                                   || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                                                                  && off_18C4CE830)
                                                                {
                                                                  off_18C4CE830( v837,  (uint64_t)&v920,  (uint64_t)v894,  v461);
                                                                }

                                                                char v484 = BYTE13(v920);
                                                                *(_DWORD *)(v837 + 740) = *(_DWORD *)(v837 + 740) & 0xFFFFFFEF | (16 * ((BYTE13(v920) >> 3) & 1));
                                                                if (v461 >= 1)
                                                                {
                                                                  unsigned int v614 = tcp_input_sbappendstream( v15,  a1,  v461,  2);
                                                                  int v847 = 0;
                                                                  if (v848 && v614)
                                                                  {
                                                                    int v847 = 0;
                                                                    _BYTE *v848 = 1;
                                                                  }

                                                                  goto LABEL_1585;
                                                                }

                                                                goto LABEL_1194;
                                                              }

LABEL_1574:
                                                              *(void *)(*(void *)(a3 + 272) + 8LL) += v461;
                                                              goto LABEL_1575;
                                                            }

LABEL_1570:
                                                            ++**(void **)(a3 + 272);
                                                            goto LABEL_1571;
                                                          }

                                                          *(_WORD *)(v488 + 196) = v489 - v846;
                                                        }

LABEL_1418:
                                                        if (!(_DWORD)v846) {
                                                          goto LABEL_1553;
                                                        }
                                                        goto LABEL_1534;
                                                      }

                                                      __nwlog_obj();
                                                      *(_DWORD *)__int128 buf = 136446210;
                                                      v900 = "__nw_frame_is_single_ip_aggregate";
                                                      v768 = (void *)_os_log_send_and_compose_impl();
                                                      type[0] = OS_LOG_TYPE_ERROR;
                                                      char v898 = 0;
                                                      if (__nwlog_fault())
                                                      {
                                                        if (type[0] == OS_LOG_TYPE_FAULT)
                                                        {
                                                          v769 = (os_log_s *)__nwlog_obj();
                                                          os_log_type_t v770 = type[0];
                                                          if (!os_log_type_enabled(v769, type[0])) {
                                                            goto LABEL_2047;
                                                          }
                                                          *(_DWORD *)__int128 buf = 136446210;
                                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                                          v771 = "%{public}s called with null frame";
LABEL_2045:
                                                          v787 = v769;
                                                          os_log_type_t v788 = v770;
LABEL_2046:
                                                          _os_log_impl(&dword_1879E5000, v787, v788, v771, buf, 0xCu);
                                                          goto LABEL_2047;
                                                        }

                                                        if (!v898)
                                                        {
                                                          v769 = (os_log_s *)__nwlog_obj();
                                                          os_log_type_t v770 = type[0];
                                                          if (!os_log_type_enabled(v769, type[0])) {
                                                            goto LABEL_2047;
                                                          }
                                                          *(_DWORD *)__int128 buf = 136446210;
                                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                                          v771 = "%{public}s called with null frame, backtrace limit exceeded";
                                                          goto LABEL_2045;
                                                        }

                                                        v776 = (void *)__nw_create_backtrace_string();
                                                        v777 = (os_log_s *)__nwlog_obj();
                                                        BOOL v778 = os_log_type_enabled(v777, type[0]);
                                                        if (v776)
                                                        {
                                                          if (v778)
                                                          {
                                                            *(_DWORD *)__int128 buf = 136446466;
                                                            v900 = "__nw_frame_is_single_ip_aggregate";
                                                            __int16 v901 = 2082;
                                                            *(void *)v902 = v776;
                                                            _os_log_impl( &dword_1879E5000,  v777,  type[0],  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                                                          }

                                                          free(v776);
                                                          goto LABEL_2047;
                                                        }

                                                        if (v778)
                                                        {
                                                          *(_DWORD *)__int128 buf = 136446210;
                                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                                          v771 = "%{public}s called with null frame, no backtrace";
                                                          v787 = v777;
                                                          os_log_type_t v788 = type[0];
                                                          goto LABEL_2046;
                                                        }
                                                      }

LABEL_2047:
                                                      if (v768) {
                                                        free(v768);
                                                      }
                                                      goto LABEL_1418;
                                                    }

                                                    if ((*(_WORD *)(v13 + 204) & 0x100) == 0
                                                      || !*MEMORY[0x189608EF8]
                                                      || (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)) & 1) != 0)
                                                    {
                                                      unsigned __int16 v921 = 0;
                                                      uint64_t v42 = v890;
                                                      v463 &= ~0x20u;
                                                      goto LABEL_1125;
                                                    }

                                                    uint64_t v806 = v462;
                                                    uint64_t v325 = v15;
                                                    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                                                    {
                                                      v807 = (os_log_s *)__nwlog_tcp_log();
                                                      if (os_log_type_enabled(v807, OS_LOG_TYPE_INFO))
                                                      {
                                                        v808 = "";
                                                        if (v15) {
                                                          v808 = (const char *)(v15 + 604);
                                                        }
                                                        *(_DWORD *)__int128 buf = 136446466;
                                                        v900 = "tcp_input";
                                                        __int16 v901 = 2082;
                                                        *(void *)v902 = v808;
                                                        _os_log_impl( &dword_1879E5000,  v807,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping tcp input frame since frame is no longer valid",  buf,  0x16u);
                                                      }
                                                    }

                                                    *(void *)(v806 + 1056) = 0LL;
                                                    int v43 = a1;
LABEL_794:
                                                    uint64_t v42 = v890;
                                                    int v54 = v847;
                                                    uint64_t v15 = v325;
                                                    goto LABEL_1289;
                                                  }
                                                }

                                                else
                                                {
                                                  int v833 = 0;
                                                  int v408 = 0;
                                                  int v845 = 0;
                                                  BOOL v18 = v815;
                                                  a3 = v814;
                                                  LOBYTE(v411) = v525;
                                                }

LABEL_1234:
                                                LOBYTE(v881) = v411;
                                                unint64_t v119 = v410;
                                                int v501 = *(_DWORD *)(v410 + 348);
                                                if ((v501 & 0x20) != 0)
                                                {
                                                  v501 &= ~0x20u;
                                                  *(_DWORD *)(v410 + 348) = v501;
                                                }

                                                unsigned int v502 = *(_DWORD *)(v410 + 8);
                                                uint64_t v503 = *(void *)(v119 + 1056);
                                                if (v503) {
                                                  ++*(void *)(v503 + 176);
                                                }
                                                int v504 = *(_DWORD *)(v119 + 740);
                                                if ((v504 & 0x20) != 0)
                                                {
                                                  unsigned int v506 = HIDWORD(v896);
                                                  unsigned int v558 = *(_DWORD *)(v119 + 196);
                                                  if (v558 <= HIDWORD(v896)) {
                                                    int v559 = HIDWORD(v896) / v558;
                                                  }
                                                  else {
                                                    int v559 = 1;
                                                  }
                                                  unsigned int v505 = v502 + v559;
                                                }

                                                else
                                                {
                                                  unsigned int v505 = v502 + 1;
                                                  unsigned int v506 = HIDWORD(v896);
                                                }

                                                *(_DWORD *)(v119 + 8) = v505;
                                                *(_DWORD *)(v119 + 628) += v506;
                                                if (v506 && (v504 & 0x10000000) == 0)
                                                {
                                                  BOOL v579 = (v504 & 0x8000000) == 0;
                                                  if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                                    BOOL v579 = 0;
                                                  }
                                                  if ((~v501 & 0x300004) == 0 && !v579 && *(_DWORD *)(v119 + 12) == 4)
                                                  {
                                                    unsigned int v581 = *(_DWORD *)(v119 + 196);
                                                    if (v506 / v581 * v581 == v506) {
                                                      unsigned int v582 = v506 / v581;
                                                    }
                                                    else {
                                                      unsigned int v582 = v506 / v581 + 1;
                                                    }
                                                    *(_DWORD *)(v119 + 296) += v582;
                                                    tcp_process_accecn(v119, (uint64_t)v894, (uint64_t)&v920, v582, v819);
                                                  }
                                                }

                                                if (*(_WORD *)(v119 + 268)
                                                  && *(_DWORD *)(v835 + 316) - *(_DWORD *)(v119 + 272) - 60000 >= 0)
                                                {
                                                  *(_WORD *)(v119 + 268) = 0;
                                                }

                                                if ((*(_BYTE *)(v119 + 90) & 0x20) == 0) {
                                                  tcp_early_rexmt_check(v119);
                                                }
                                                BOOL v583 = (*(_DWORD *)(v119 + 740) & 0x20400020) == 0x20000020
                                                    && tcp_rack_detect_loss_and_arm_timer(v119, *(_DWORD *)(v119 + 8));
                                                if (!*(_DWORD *)(v119 + 28)
                                                  || (int v584 = *(_DWORD *)(v119 + 92), DWORD2(v920) != v584) && !v506)
                                                {
                                                  uint64_t v410 = v119;
                                                  *(_DWORD *)(v119 + 8) = 0;
                                                  *(_BYTE *)(v119 + 310) = 3;
                                                  goto LABEL_1112;
                                                }

                                                int v585 = *(_DWORD *)(v119 + 740);
                                                if ((v585 & 0x20400020) != 0x20000020
                                                  && (unsigned int v591 = *(unsigned __int8 *)(v119 + 310),
                                                      *(_DWORD *)(v119 + 8) > (signed int)v591)
                                                  && v502 >= v591
                                                  || (int v586 = *(_DWORD *)(v119 + 88), (v586 & 0x200000) != 0))
                                                {
                                                  if ((v585 & 0x20) == 0) {
                                                    goto LABEL_1519;
                                                  }
                                                  int v636 = *(_DWORD *)(v119 + 88);
                                                  if ((~v585 & 0x6000) == 0 && (v636 & 0x200000) == 0) {
                                                    goto LABEL_1111;
                                                  }
                                                  if ((v636 & 0x200000) != 0)
                                                  {
                                                    int v592 = *(_DWORD *)(v119 + 148);
                                                    if (*(_DWORD *)(v119 + 100)
                                                       - *(_DWORD *)(v119 + 560)
                                                       + *(_DWORD *)(v119 + 624) >= v592)
                                                      goto LABEL_1521;
                                                  }

                                                  else
                                                  {
LABEL_1519:
                                                    int v592 = *(_DWORD *)(v119 + 144) + *(_DWORD *)(v119 + 196);
                                                  }

                                                  *(_DWORD *)(v119 + 144) = v592;
                                                  goto LABEL_1521;
                                                }

                                                if (!v583)
                                                {
                                                  int v644 = *(_DWORD *)(v119 + 8);
                                                  if ((v585 & 0x20400020) == 0x20000020
                                                    || v644 < *(unsigned __int8 *)(v119 + 310))
                                                  {
                                                    if (v644 >= 1)
                                                    {
                                                      int v645 = ~v585 & 0x6000;
                                                      BOOL v646 = (v585 & 0x20) != 0 && v506 == 0;
                                                      BOOL v647 = !v646;
                                                      if (v645
                                                        && v644 < *(unsigned __int8 *)(v119 + 310)
                                                        && v647
                                                        && v584 - *(_DWORD *)(v119 + 96) + *(_DWORD *)(v15 + 384))
                                                      {
                                                        int v648 = *(_DWORD *)(v119 + 196) * v644;
                                                        *(_DWORD *)(v119 + 144) += v648;
                                                        uint64_t v649 = *(void *)(v119 + 1056);
                                                        if (v649) {
                                                          ++*(void *)(v649 + 688);
                                                        }
                                                        if (tcp_output(v119)
                                                          && (*(_WORD *)(v13 + 204) & 0x100) != 0
                                                          && *MEMORY[0x189608EF8]
                                                          && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)) & 1) == 0)
                                                        {
                                                          goto LABEL_2097;
                                                        }

                                                        uint64_t v410 = v119;
                                                        *(_DWORD *)(v119 + 144) -= v648;
                                                        goto LABEL_1112;
                                                      }
                                                    }

                                                    goto LABEL_1111;
                                                  }
                                                }

                                                int v587 = *(_DWORD *)(v119 + 100);
                                                if ((v585 & 0x20) == 0)
                                                {
                                                  if (DWORD2(v920) - *(_DWORD *)(v119 + 152) <= 0)
                                                  {
                                                    uint64_t v410 = v119;
                                                    *(_DWORD *)(v119 + 8) = 0;
                                                    goto LABEL_1112;
                                                  }

LABEL_1719:
                                                  *(_DWORD *)(v119 + 152) = *(_DWORD *)(v119 + 96) + (v586 << 27 >> 31);
                                                  *(_DWORD *)(v119 + 16) = 0;
                                                  *(_DWORD *)(v119 + 172) = 0;
                                                  if ((v585 & 0x6020) == 0x2020
                                                    && *(_WORD *)(v119 + 536)
                                                    && (*(_DWORD *)(v119 + 12) | 2) == 6)
                                                  {
                                                    *(_DWORD *)(v119 + 20) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v119 + 80) + 224LL))
                                                                                       + 316)
                                                    *(_DWORD *)(v119 + 740) |= 0x4000u;
                                                    uint64_t v660 = *(void *)(v119 + 1056);
                                                    if (v660) {
                                                      ++*(void *)(v660 + 984);
                                                    }
                                                    goto LABEL_1111;
                                                  }

                                                  tcp_rexmt_save_state(v119);
                                                  v661 = *(void (**)(unint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v119 + 264)]
                                                                                                 + 64);
                                                  if (v661) {
                                                    v661(v119);
                                                  }
                                                  *(_DWORD *)(v119 + 88) |= 0x200000u;
                                                  uint64_t v662 = *(void *)(v119 + 80);
                                                  if ((*(_BYTE *)(v662 + 2231) & 0x40) != 0) {
                                                    inp_reset_fc_state(v662);
                                                  }
                                                  if (*(void *)(v119 + 952)) {
                                                    tcp_rxtseg_clean(v119);
                                                  }
                                                  *(_DWORD *)(v119 + 28) = 0;
                                                  int v663 = *(_DWORD *)(v119 + 740);
                                                  if ((v663 & 0x10000000) != 0)
                                                  {
                                                    int v666 = *(_DWORD *)(v119 + 348);
                                                  }

                                                  else
                                                  {
                                                    BOOL v665 = tcp_do_acc_ecn != 1
                                                        && *(_DWORD *)(sysctls + 320) != 1
                                                        && (v663 & 0x8000000) == 0;
                                                    int v666 = *(_DWORD *)(v119 + 348);
                                                    if (!v665 && (v666 & 0x300000) == 0x300000)
                                                    {
LABEL_1849:
                                                      if ((v663 & 0x20) == 0)
                                                      {
                                                        *(_DWORD *)(v119 + 100) = DWORD2(v920);
                                                        *(_DWORD *)(v119 + 144) = *(_DWORD *)(v119 + 196);
                                                        *(_DWORD *)(v119 + 740) = v663 & 0xFFEFFFFF;
                                                        if (v820 > *(_DWORD *)(v119 + 140)) {
                                                          tcp_update_window(v119, v411, (uint64_t)&v920, v820, v833);
                                                        }
                                                        tcp_output(v119);
                                                        if ((*(_BYTE *)(v119 + 742) & 0x10) != 0) {
                                                          tcp_cc_adjust_nonvalidated_cwnd(v119);
                                                        }
                                                        else {
                                                          *(_DWORD *)(v119 + 144) = *(_DWORD *)(v119 + 148)
                                                        }
                                                                                  + *(_DWORD *)(v119 + 8)
                                                                                  * *(_DWORD *)(v119 + 196);
                                                        if (v587 - *(_DWORD *)(v119 + 100) >= 1) {
                                                          *(_DWORD *)(v119 + 100) = v587;
                                                        }
                                                        goto LABEL_1287;
                                                      }

                                                      uint64_t v704 = *(void *)(v119 + 1056);
                                                      if ((v663 & 0x20400000) == 0x20000000)
                                                      {
                                                        if (v704) {
                                                          ++*(void *)(v704 + 624);
                                                        }
                                                        ++*(_DWORD *)(v119 + 1008);
                                                      }

                                                      else
                                                      {
                                                        if (v704) {
                                                          ++*(void *)(v704 + 568);
                                                        }
                                                        ++*(_DWORD *)(v119 + 1004);
                                                      }

                                                      *(_DWORD *)(v119 + 144) = *(_DWORD *)(v119 + 148);
                                                      *(_DWORD *)(v119 + 740) = v663 & 0xFFEFFFFF;
LABEL_1521:
                                                      if (v820 > *(_DWORD *)(v119 + 140)) {
                                                        tcp_update_window(v119, v411, (uint64_t)&v920, v820, v833);
                                                      }
                                                      tcp_output(v119);
                                                      goto LABEL_1287;
                                                    }
                                                  }

                                                  if ((~v666 & 3) == 0) {
                                                    *(_DWORD *)(v119 + 348) = v666 | 8;
                                                  }
                                                  goto LABEL_1849;
                                                }

                                                if ((v585 & 0x4000) == 0) {
                                                  goto LABEL_1719;
                                                }
LABEL_1111:
                                                uint64_t v410 = v119;
LABEL_1112:
                                                unint64_t v119 = 0x18C4CE000uLL;
                                                LOBYTE(v411) = v881;
                                                goto LABEL_1113;
                                              }

                                              int v845 = 0;
                                            }

LABEL_1388:
                                            BOOL v18 = v815;
                                            a3 = v814;
                                            unint64_t v119 = 0x18C4CE000LL;
                                            LOBYTE(v411) = v525;
                                            goto LABEL_1113;
                                          }

                                          v779 = (os_log_s *)__nwlog_obj();
                                          os_log_type_enabled(v779, OS_LOG_TYPE_ERROR);
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "tcp_input";
                                          v780 = (void *)_os_log_send_and_compose_impl();
                                          if (!__nwlog_abort())
                                          {
                                            free(v780);
                                            char v671 = *(_BYTE *)(v410 + 988);
                                            goto LABEL_1768;
                                          }

LABEL_2096:
                                          __break(1u);
LABEL_2097:
                                          if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                          {
                                            v809 = (os_log_s *)__nwlog_tcp_log();
                                            if (os_log_type_enabled(v809, OS_LOG_TYPE_INFO))
                                            {
                                              v810 = "";
                                              if (v15) {
                                                v810 = (const char *)(v15 + 604);
                                              }
                                              *(_DWORD *)__int128 buf = 136446466;
                                              v900 = "tcp_input";
                                              __int16 v901 = 2082;
                                              *(void *)v902 = v810;
                                              _os_log_impl( &dword_1879E5000,  v809,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping input packet since frame is no longer valid",  buf,  0x16u);
                                            }
                                          }

                                          *(void *)(v119 + 1056) = 0LL;
                                          goto LABEL_1287;
                                        }

                                        uint64_t v527 = *(void *)(v121 + 1056);
                                        if (v527) {
                                          ++*(void *)(v527 + 104);
                                        }
                                        int v43 = a1;
                                        uint64_t v42 = v890;
                                        int v131 = v822;
LABEL_1294:
                                        if (*(_DWORD *)(v121 + 12) != 3
                                          || (v130 & 0x10) == 0
                                          || *(_DWORD *)(v121 + 92) - DWORD2(v920) <= 0
                                          && DWORD2(v920) - *(_DWORD *)(v121 + 96) <= 0)
                                        {
                                          *(_DWORD *)(v121 + 88) |= 1u;
                                          tcp_output(v121);
                                          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))( v15,  1LL,  v6);
                                          *uint64_t v42 = v847 != 0;
                                          uint64_t result = (void *)*v43;
                                          if (!*v43) {
                                            return result;
                                          }
                                          while (1)
                                          {
                                            v528 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                            v529 = (void *)result[4];
                                            if (!v528) {
                                              break;
                                            }
                                            uint64_t v530 = result[11];
                                            result[10] = 0LL;
                                            result[11] = 0LL;
                                            v528(result, 1LL, v530);
LABEL_1301:
                                            uint64_t result = v529;
                                            if (!v529) {
                                              return result;
                                            }
                                          }

                                          __nwlog_obj();
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "__nw_frame_finalize";
                                          uint64_t v531 = _os_log_send_and_compose_impl();
                                          type[0] = OS_LOG_TYPE_ERROR;
                                          char v898 = 0;
                                          v886 = (void *)v531;
                                          if (__nwlog_fault())
                                          {
                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                            {
                                              v868 = (os_log_s *)__nwlog_obj();
                                              if (!os_log_type_enabled(v868, type[0])) {
                                                goto LABEL_1317;
                                              }
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              v532 = v868;
                                              os_log_type_t v533 = type[0];
                                              v534 = "%{public}s called with null frame->finalizer";
                                              goto LABEL_1316;
                                            }

                                            if (!v898)
                                            {
                                              v870 = (os_log_s *)__nwlog_obj();
                                              if (!os_log_type_enabled(v870, type[0])) {
                                                goto LABEL_1317;
                                              }
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              v532 = v870;
                                              os_log_type_t v533 = type[0];
                                              v534 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                              goto LABEL_1316;
                                            }

                                            v869 = (void *)__nw_create_backtrace_string();
                                            loge = (os_log_s *)__nwlog_obj();
                                            BOOL v535 = os_log_type_enabled(loge, type[0]);
                                            if (v869)
                                            {
                                              if (v535)
                                              {
                                                *(_DWORD *)__int128 buf = 136446466;
                                                v900 = "__nw_frame_finalize";
                                                __int16 v901 = 2082;
                                                *(void *)v902 = v869;
                                                _os_log_impl( &dword_1879E5000,  loge,  type[0],  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
                                              }

                                              free(v869);
                                              goto LABEL_1317;
                                            }

                                            if (v535)
                                            {
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              v532 = loge;
                                              os_log_type_t v533 = type[0];
                                              v534 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1316:
                                              _os_log_impl(&dword_1879E5000, v532, v533, v534, buf, 0xCu);
                                            }
                                          }

LABEL_1317:
                                          if (v886) {
                                            free(v886);
                                          }
                                          goto LABEL_1301;
                                        }

LABEL_278:
                                        if ((v130 & 4) == 0)
                                        {
                                          if ((v130 & 0x10) != 0)
                                          {
                                            unsigned int v135 = DWORD2(v920);
                                            uint64_t v133 = v121;
                                            uint64_t v134 = v13;
                                            unsigned int v132 = 0;
                                            char v136 = 4;
                                          }

                                          else
                                          {
                                            unsigned int v132 = *(_DWORD *)v897 + ((v130 >> 1) & 1) + DWORD1(v920);
                                            uint64_t v133 = v121;
                                            uint64_t v134 = v13;
                                            unsigned int v135 = 0;
                                            char v136 = 20;
                                          }

                                          tcp_respond(v133, &v920, v134, v132, v135, v136, 0LL);
                                          if (v131) {
                                            soabort(v15);
                                          }
                                          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))( v15,  1LL,  v6);
                                          *uint64_t v42 = v847 != 0;
                                          uint64_t result = (void *)*v43;
                                          if (!*v43) {
                                            return result;
                                          }
                                          while (1)
                                          {
                                            __int16 v141 = (void (*)(void *, uint64_t, uint64_t))result[10];
                                            int v142 = (void *)result[4];
                                            if (!v141) {
                                              break;
                                            }
                                            uint64_t v143 = result[11];
                                            result[10] = 0LL;
                                            result[11] = 0LL;
                                            v141(result, 1LL, v143);
LABEL_302:
                                            uint64_t result = v142;
                                            if (!v142) {
                                              return result;
                                            }
                                          }

                                          __nwlog_obj();
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "__nw_frame_finalize";
                                          uint64_t v144 = _os_log_send_and_compose_impl();
                                          type[0] = OS_LOG_TYPE_ERROR;
                                          char v898 = 0;
                                          v882 = (void *)v144;
                                          if (__nwlog_fault())
                                          {
                                            if (type[0] == OS_LOG_TYPE_FAULT)
                                            {
                                              v865 = (os_log_s *)__nwlog_obj();
                                              if (!os_log_type_enabled(v865, type[0])) {
                                                goto LABEL_318;
                                              }
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              __int16 v145 = v865;
                                              os_log_type_t v146 = type[0];
                                              __int16 v147 = "%{public}s called with null frame->finalizer";
                                              goto LABEL_317;
                                            }

                                            if (!v898)
                                            {
                                              v867 = (os_log_s *)__nwlog_obj();
                                              if (!os_log_type_enabled(v867, type[0])) {
                                                goto LABEL_318;
                                              }
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              __int16 v145 = v867;
                                              os_log_type_t v146 = type[0];
                                              __int16 v147 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                                              goto LABEL_317;
                                            }

                                            v866 = (void *)__nw_create_backtrace_string();
                                            logd = (os_log_s *)__nwlog_obj();
                                            BOOL v148 = os_log_type_enabled(logd, type[0]);
                                            if (v866)
                                            {
                                              if (v148)
                                              {
                                                *(_DWORD *)__int128 buf = 136446466;
                                                v900 = "__nw_frame_finalize";
                                                __int16 v901 = 2082;
                                                *(void *)v902 = v866;
                                                _os_log_impl( &dword_1879E5000,  logd,  type[0],  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
                                              }

                                              free(v866);
                                              goto LABEL_318;
                                            }

                                            if (v148)
                                            {
                                              *(_DWORD *)__int128 buf = 136446210;
                                              v900 = "__nw_frame_finalize";
                                              __int16 v145 = logd;
                                              os_log_type_t v146 = type[0];
                                              __int16 v147 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_317:
                                              _os_log_impl(&dword_1879E5000, v145, v146, v147, buf, 0xCu);
                                            }
                                          }

LABEL_318:
                                          if (v882) {
                                            free(v882);
                                          }
                                          goto LABEL_302;
                                        }

                                        goto LABEL_1327;
                                      }

                                      v302 = v43;
                                      __nwlog_obj();
                                      *(_DWORD *)__int128 buf = 136446210;
                                      v900 = "__nw_frame_is_single_ip_aggregate";
                                      v700 = (void *)_os_log_send_and_compose_impl();
                                      type[0] = OS_LOG_TYPE_ERROR;
                                      char v898 = 0;
                                      if (__nwlog_fault())
                                      {
                                        if (type[0] == OS_LOG_TYPE_FAULT)
                                        {
                                          v701 = (os_log_s *)__nwlog_obj();
                                          os_log_type_t v702 = type[0];
                                          if (!os_log_type_enabled(v701, type[0])) {
                                            goto LABEL_1992;
                                          }
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                          v703 = "%{public}s called with null frame";
LABEL_1990:
                                          v751 = v701;
                                          os_log_type_t v752 = v702;
LABEL_1991:
                                          _os_log_impl(&dword_1879E5000, v751, v752, v703, buf, 0xCu);
                                          goto LABEL_1992;
                                        }

                                        if (!v898)
                                        {
                                          v701 = (os_log_s *)__nwlog_obj();
                                          os_log_type_t v702 = type[0];
                                          if (!os_log_type_enabled(v701, type[0])) {
                                            goto LABEL_1992;
                                          }
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                          v703 = "%{public}s called with null frame, backtrace limit exceeded";
                                          goto LABEL_1990;
                                        }

                                        v712 = (void *)__nw_create_backtrace_string();
                                        v713 = (os_log_s *)__nwlog_obj();
                                        BOOL v714 = os_log_type_enabled(v713, type[0]);
                                        if (v712)
                                        {
                                          if (v714)
                                          {
                                            *(_DWORD *)__int128 buf = 136446466;
                                            v900 = "__nw_frame_is_single_ip_aggregate";
                                            __int16 v901 = 2082;
                                            *(void *)v902 = v712;
                                            _os_log_impl( &dword_1879E5000,  v713,  type[0],  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                                          }

                                          free(v712);
                                          goto LABEL_1992;
                                        }

                                        if (v714)
                                        {
                                          *(_DWORD *)__int128 buf = 136446210;
                                          v900 = "__nw_frame_is_single_ip_aggregate";
                                          v703 = "%{public}s called with null frame, no backtrace";
                                          v751 = v713;
                                          os_log_type_t v752 = type[0];
                                          goto LABEL_1991;
                                        }
                                      }

LABEL_1992:
                                      if (v700) {
                                        free(v700);
                                      }
                                      goto LABEL_1247;
                                    }
                                  }

                                  else
                                  {
                                    int v299 = v258;
                                    if (DWORD1(v920) == v293 && !v294)
                                    {
                                      *(_DWORD *)(v837 + 88) |= 1u;
                                      goto LABEL_754;
                                    }
                                  }

                                  uint64_t v42 = v890;
                                  uint64_t v121 = v837;
                                  int v131 = v822;
                                  goto LABEL_1294;
                                }

                                uint64_t v235 = v881;
                                if ((v881 & 2) == 0)
                                {
LABEL_683:
                                  uint64_t v277 = v121;
                                  int v278 = *(_DWORD *)v897;
                                  if (v233 <= *(int *)v897 && ((v235 & 1) != 0 || v233 != *(_DWORD *)v897))
                                  {
                                    uint64_t v286 = *(void *)(v277 + 1056);
                                    if (!v286)
                                    {
                                      uint64_t v284 = v235;
                                      uint64_t v42 = v890;
                                      int v285 = v824;
LABEL_699:
                                      if (v233 >= 2)
                                      {
                                        int v287 = DWORD1(v920);
                                        *(_DWORD *)(v277 + 940) = DWORD1(v920);
                                        *(_DWORD *)(v277 + 944) = v287 + v233;
                                        *(_DWORD *)(v277 + 88) |= 1u;
                                      }

                                      v288 = *(void **)(a3 + 248);
                                      ++*v288;
                                      if (v285)
                                      {
                                        ++**(void **)(a3 + 256);
                                        if (!v817) {
                                          goto LABEL_703;
                                        }
                                      }

                                      else if (!v817)
                                      {
LABEL_703:
                                        if (!v18) {
                                          goto LABEL_705;
                                        }
                                        goto LABEL_704;
                                      }

                                      ++**(void **)(a3 + 264);
                                      if (!v18)
                                      {
LABEL_705:
                                        v288[1] += v233;
                                        if (v285)
                                        {
                                          *(void *)(*(void *)(a3 + 256) + 8LL) += v233;
                                          if (!v817) {
                                            goto LABEL_707;
                                          }
                                        }

                                        else if (!v817)
                                        {
LABEL_707:
                                          if (!v18)
                                          {
LABEL_709:
                                            *(_DWORD *)(v277 + 704) += v233;
                                            if (*(void *)(v15 + 24))
                                            {
                                              uint64_t v289 = nw_protocol_tcp_get_all_stats();
                                              if (v289) {
                                                *(_DWORD *)(v289 + 48) += v233;
                                              }
                                            }

                                            if ((*(_WORD *)(v13 + 204) & 0x100) != 0
                                              && *MEMORY[0x189608EF8]
                                              && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])( v13,  *(void *)(v13 + 88)) & 1) == 0)
                                            {
                                              int v43 = a1;
                                              uint64_t v325 = v15;
                                              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                                              {
                                                v658 = (os_log_s *)__nwlog_tcp_log();
                                                if (os_log_type_enabled(v658, OS_LOG_TYPE_INFO))
                                                {
                                                  v659 = "";
                                                  if (v15) {
                                                    v659 = (const char *)(v15 + 604);
                                                  }
                                                  *(_DWORD *)__int128 buf = 136446466;
                                                  v900 = "tcp_input";
                                                  __int16 v901 = 2082;
                                                  *(void *)v902 = v659;
                                                  _os_log_impl( &dword_1879E5000,  v658,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s dropping tcp input frame since frame is no longer valid",  buf,  0x16u);
                                                }
                                              }

                                              *(void *)(v277 + 1056) = 0LL;
                                              goto LABEL_794;
                                            }

                                            int v234 = v233 + v846;
                                            DWORD1(v920) += v233;
                                            if (&v920 == (__int128 *)v828)
                                            {
                                              unint64_t v258 = (v278 - v233);
                                              *(_DWORD *)v897 = v278 - v233;
                                              if (v233 < v921)
                                              {
                                                v921 -= v233;
                                                goto LABEL_726;
                                              }

                                              uint64_t v130 = v284 & 0xFFFFFFDF;
                                              unsigned __int16 v921 = 0;
                                            }

                                            else
                                            {
                                              *(_DWORD *)(v828 + 4) += v233;
                                              unint64_t v258 = (v278 - v233);
                                              *(_DWORD *)v897 = v278 - v233;
                                              if (v233 < v921)
                                              {
                                                v921 -= v233;
                                                *(_WORD *)(v828 + 18) -= v233;
LABEL_726:
                                                uint64_t v121 = v277;
                                                uint64_t v130 = v284;
LABEL_730:
                                                int v43 = a1;
                                                goto LABEL_731;
                                              }

                                              uint64_t v130 = v284 & 0xFFFFFFDF;
                                              unsigned __int16 v921 = 0;
                                              *(_WORD *)(v828 + 18) = 0;
                                            }

                                            uint64_t v121 = v277;
                                            goto LABEL_730;
                                          }

LABEL_708:
                                          *(void *)(*(void *)(a3 + 272) + 8LL) += v233;
                                          goto LABEL_709;
                                        }

                                        *(void *)(*(void *)(a3 + 264) + 8LL) += v233;
                                        if (!v18) {
                                          goto LABEL_709;
                                        }
                                        goto LABEL_708;
                                      }

LABEL_704:
                                      ++**(void **)(a3 + 272);
                                      goto LABEL_705;
                                    }

                                    ++*(void *)(v286 + 240);
                                    uint64_t v282 = v233;
                                    v283 = (void *)(v286 + 248);
                                    uint64_t v42 = v890;
LABEL_698:
                                    int v285 = v824;
                                    *v283 += v282;
                                    uint64_t v284 = v235;
                                    goto LABEL_699;
                                  }

                                  if ((v881 & 2) != 0)
                                  {
                                    if (tcp_is_ack_ratelimited(v277))
                                    {
LABEL_689:
                                      uint64_t v235 = v235 & 0xFFFFFFFE;
                                      uint64_t v42 = v890;
                                      if (v233 == 1)
                                      {
                                        uint64_t v279 = *(void *)(v15 + 32);
                                        if (v279)
                                        {
                                          v280 = *(void (**)(uint64_t))(v279 + 88);
                                          if (v280) {
                                            v280(v15);
                                          }
                                        }
                                      }

                                      uint64_t v281 = *(void *)(v277 + 1056);
                                      if (!v281)
                                      {
                                        uint64_t v284 = v235;
                                        int v233 = v278;
                                        int v285 = v824;
                                        goto LABEL_699;
                                      }

                                      uint64_t v282 = v278;
                                      ++*(void *)(v281 + 208);
                                      v283 = (void *)(v281 + 216);
                                      int v233 = v278;
                                      goto LABEL_698;
                                    }

                                    uint64_t v311 = *(void *)(v277 + 1056);
                                    if (v311) {
                                      ++*(void *)(v311 + 104);
                                    }
                                  }

                                  *(_DWORD *)(v277 + 88) |= 1u;
                                  goto LABEL_689;
                                }

                                uint64_t v235 = v881 & 0xFFFFFFFD;
                                ++DWORD1(v920);
                                if (&v920 == (__int128 *)v232)
                                {
                                  if (v921 > 1u)
                                  {
                                    --v921;
                                    goto LABEL_682;
                                  }
                                }

                                else
                                {
                                  ++*(_DWORD *)(v232 + 4);
                                  if (v921 > 1u)
                                  {
                                    --v921;
                                    --*(_WORD *)(v232 + 18);
LABEL_682:
                                    --v233;
                                    goto LABEL_683;
                                  }
                                }

                                uint64_t v235 = v881 & 0xDDDDDDDD;
                                goto LABEL_682;
                              }

                              if (*(_DWORD *)(v835 + 316) - *(_DWORD *)(v121 + 280) >= 2073600001)
                              {
                                *(_DWORD *)(v121 + 276) = 0;
                                LODWORD(v130) = v881;
                                goto LABEL_591;
                              }

                              uint64_t v322 = *(void *)(v121 + 1056);
                              if (v322)
                              {
                                ++*(void *)(v322 + 208);
                                ++*(_DWORD *)(v121 + 1000);
                                int64x2_t v323 = vdupq_n_s64(1uLL);
                                v323.i64[0] = v843;
                                *(int64x2_t *)(v322 + 216) = vaddq_s64(*(int64x2_t *)(v322 + 216), v323);
                              }

                              else
                              {
                                ++*(_DWORD *)(v121 + 1000);
                              }

                              int v364 = *(_DWORD *)(v121 + 348);
                              if ((~v364 & 3) == 0) {
                                goto LABEL_2105;
                              }
                              int v367 = *(_DWORD *)(v121 + 740);
                              if ((v367 & 0x10000000) == 0)
                              {
                                BOOL v368 = (v367 & 0x8000000) == 0;
                                if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                  BOOL v368 = 0;
                                }
                                if ((~v364 & 0x300000) == 0 && !v368)
                                {
LABEL_2105:
                                  if (!(*(void *)(*(void *)(a3 + 248) + 8LL) >> 31))
                                  {
                                    uint64_t v365 = *(void *)(a3 + 448);
                                    if (v365)
                                    {
                                      uint64_t v366 = 632LL;
                                      if ((*(_BYTE *)(a3 + 2236) & 2) == 0) {
                                        uint64_t v366 = 248LL;
                                      }
                                      ++*(void *)(v365 + v366);
                                    }

                                    if (v322) {
                                      ++*(void *)(v322 + 936);
                                    }
                                    tcp_heuristic_ecn_aggressive(v121);
                                  }
                                }
                              }

                              v370 = *(void **)(a3 + 248);
                              ++*v370;
                              if (v824)
                              {
                                ++**(void **)(a3 + 256);
                                if (!v17) {
                                  goto LABEL_917;
                                }
                              }

                              else if (!v17)
                              {
LABEL_917:
                                if (!v18) {
                                  goto LABEL_919;
                                }
                                goto LABEL_918;
                              }

                              ++**(void **)(a3 + 264);
                              if (!v18)
                              {
LABEL_919:
                                uint64_t v130 = *(int *)v897;
                                v370[1] += *(int *)v897;
                                if (v824)
                                {
                                  *(void *)(*(void *)(a3 + 256) + 8LL) += v130;
                                  if (!v17) {
                                    goto LABEL_921;
                                  }
                                }

                                else if (!v17)
                                {
LABEL_921:
                                  if (!v18)
                                  {
LABEL_923:
                                    *(_DWORD *)(v121 + 704) += v130;
                                    if (*(void *)(v15 + 24))
                                    {
                                      uint64_t v371 = nw_protocol_tcp_get_all_stats();
                                      if (v371) {
                                        *(_DWORD *)(v371 + 48) += v130;
                                      }
                                    }

                                    BOOL v483 = (int)v130 <= 0;
                                    uint64_t v42 = v890;
                                    int v131 = v822;
                                    LODWORD(v130) = v881;
                                    if (!v483) {
                                      goto LABEL_1294;
                                    }
                                    goto LABEL_1327;
                                  }

LABEL_922:
                                  *(void *)(*(void *)(a3 + 272) + 8LL) += v130;
                                  goto LABEL_923;
                                }

                                *(void *)(*(void *)(a3 + 264) + 8LL) += v130;
                                if (!v18) {
                                  goto LABEL_923;
                                }
                                goto LABEL_922;
                              }

LABEL_918:
                              ++**(void **)(a3 + 272);
                              goto LABEL_919;
                            }

                            int v236 = *(_DWORD *)(v121 + 284);
                            int v131 = v822;
                            if (DWORD1(v920) - v236 >= 0 && (int)(DWORD1(v920) - v236 - v228) < 0)
                            {
                              int v237 = v236 - 1;
                            }

                            else if (v228 && v229 < 5 {
                                   || (int v237 = v236 - 1, DWORD1(v920) != v236) && v237 != DWORD1(v920))
                            }
                            {
LABEL_608:
                              int v54 = v847;
LABEL_622:
                              uint64_t v42 = v890;
                              goto LABEL_1328;
                            }

                            if (DWORD1(v920) != v236 && v237 != DWORD1(v920))
                            {
                              uint64_t v259 = *(void *)(v121 + 1056);
                              if (v259) {
                                ++*(void *)(v259 + 312);
                              }
                              uint64_t v260 = *(void *)(v121 + 1056);
                              if (v260) {
                                ++*(void *)(v260 + 112);
                              }
                              uint64_t v42 = v890;
LABEL_1169:
                              int v131 = v822;
                              LODWORD(v130) = v881;
                              goto LABEL_1294;
                            }

                            break;
                          case 4:
                            if ((v881 & 2) == 0 || v843 > 0) {
                              goto LABEL_585;
                            }
                            uint64_t v230 = *(void *)(v121 + 1056);
                            if (v230) {
                              ++*(void *)(v230 + 104);
                            }
                            int v131 = v822;
                            uint64_t v42 = v890;
                            goto LABEL_1294;
                          default:
                            goto LABEL_585;
                        }

                        int v261 = v229 - 3;
                        uint64_t v262 = v121;
                        __int16 v263 = 61;
                        switch(v261)
                        {
                          case 0:
                            goto LABEL_660;
                          case 1:
                            int v362 = *(_DWORD *)(v121 + 348);
                            if ((~v362 & 3) == 0) {
                              goto LABEL_894;
                            }
                            int v497 = *(_DWORD *)(v121 + 740);
                            if ((v497 & 0x10000000) == 0)
                            {
                              BOOL v498 = (v497 & 0x8000000) == 0;
                              if (*(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1) {
                                BOOL v498 = 0;
                              }
                              if ((~v362 & 0x300000) == 0 && !v498)
                              {
LABEL_894:
                                int v363 = *(_DWORD *)(v121 + 92);
                                if (v363 == *(_DWORD *)(v121 + 112) + 1 && *(_DWORD *)(v121 + 96) - v363 >= 1) {
                                  tcp_heuristic_ecn_droprst(v121);
                                }
                              }
                            }

                            goto LABEL_659;
                          case 2:
                          case 3:
                          case 6:
LABEL_659:
                            __int16 v263 = 54;
LABEL_660:
                            *(_WORD *)(v15 + 378) = v263;
                            if (tcp_perf_measurement)
                            {
                              if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                              {
                                if (__nwlog_is_datapath_logging_enabled())
                                {
                                  v264 = (os_log_s *)__nwlog_tcp_log();
                                  if (os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG))
                                  {
                                    v265 = tcpstates[*(int *)(v262 + 12)];
                                    v900 = "tcp_input";
                                    v266 = "";
                                    *(_DWORD *)__int128 buf = 136446722;
                                    if (v15) {
                                      v266 = (const char *)(v15 + 604);
                                    }
                                    __int16 v901 = 2082;
                                    *(void *)v902 = v266;
                                    *(_WORD *)&v902[8] = 2082;
                                    *(void *)v903 = v265;
                                    v267 = v264;
                                    os_log_type_t v268 = OS_LOG_TYPE_DEBUG;
LABEL_858:
                                    _os_log_impl( &dword_1879E5000,  v267,  v268,  "%{public}s %{public}s ECONNRESET t_state %{public}s",  buf,  0x20u);
                                  }
                                }
                              }
                            }

                            else if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                            {
                              v349 = (os_log_s *)__nwlog_tcp_log();
                              if (os_log_type_enabled(v349, OS_LOG_TYPE_INFO))
                              {
                                v350 = tcpstates[*(int *)(v262 + 12)];
                                v900 = "tcp_input";
                                v351 = "";
                                *(_DWORD *)__int128 buf = 136446722;
                                if (v15) {
                                  v351 = (const char *)(v15 + 604);
                                }
                                __int16 v901 = 2082;
                                *(void *)v902 = v351;
                                *(_WORD *)&v902[8] = 2082;
                                *(void *)v903 = v350;
                                v267 = v349;
                                os_log_type_t v268 = OS_LOG_TYPE_INFO;
                                goto LABEL_858;
                              }
                            }

                            user_north_signal_error(v15);
                            uint64_t v352 = *(void *)(v262 + 1056);
                            if (v352) {
                              ++*(void *)(v352 + 424);
                            }
                            tcp_close(v262);
                            uint64_t v42 = v890;
                            goto LABEL_1288;
                          case 4:
                          case 5:
                            uint64_t v325 = v15;
                            if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                            {
                              if (__nwlog_is_datapath_logging_enabled())
                              {
                                v748 = (os_log_s *)__nwlog_tcp_log();
                                if (os_log_type_enabled(v748, OS_LOG_TYPE_DEBUG))
                                {
                                  v749 = tcpstates[*(int *)(v262 + 12)];
                                  v900 = "tcp_input";
                                  v750 = "";
                                  *(_DWORD *)__int128 buf = 136446722;
                                  if (v15) {
                                    v750 = (const char *)(v15 + 604);
                                  }
                                  __int16 v901 = 2082;
                                  *(void *)v902 = v750;
                                  *(_WORD *)&v902[8] = 2082;
                                  *(void *)v903 = v749;
                                  _os_log_impl( &dword_1879E5000,  v748,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s t_state %{public}s",  buf,  0x20u);
                                }
                              }
                            }

                            tcp_close(v262);
                            goto LABEL_794;
                          default:
                            goto LABEL_608;
                        }
                      }

                      uint64_t v224 = v121;
                      int v43 = a1;
                      if ((*(_BYTE *)(v15 + 828) & 2) == 0)
                      {
                        v225 = (os_log_s *)__nwlog_tcp_log();
                        unsigned int v220 = os_log_type_enabled(v225, OS_LOG_TYPE_ERROR);
                        if (!v220)
                        {
LABEL_567:
                          uint64_t v121 = v224;
                          goto LABEL_568;
                        }

                        v226 = (const char *)(v15 + 604);
                        v900 = "tcp_input";
                        *(_DWORD *)__int128 buf = 136446722;
                        if (!v15) {
                          v226 = "";
                        }
                        __int16 v901 = 2082;
                        *(void *)v902 = v226;
                        *(_WORD *)&v902[8] = 1024;
                        *(_DWORD *)v903 = 0;
                        _os_log_impl( &dword_1879E5000,  v225,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s win is smaller than 0: %d",  buf,  0x1Cu);
                      }

                      unsigned int v220 = 0;
                      goto LABEL_567;
                    }

                    uint64_t v121 = v837;
                    if ((*(_BYTE *)(v837 + 740) & 0x20) != 0 && *(_DWORD *)(v837 + 564))
                    {
                      *(_DWORD *)(v837 + 612) = 0;
                      *(_OWORD *)(v837 + 580) = 0u;
                      *(_OWORD *)(v837 + 596) = 0u;
                      *(_OWORD *)(v837 + 564) = 0u;
                    }

                    __int16 v193 = *(void **)(v837 + 1056);
                    if (v193) {
                      ++v193[69];
                    }
                    int v194 = *(_DWORD *)(v837 + 120) + v843;
                    *(_DWORD *)(v837 + 120) = v194;
                    if (*(_DWORD *)(v837 + 1916) - v194 < 0)
                    {
                      *(_DWORD *)(v837 + 1916) = v194;
                      if ((v894[0] & 1) != 0) {
                        *(_DWORD *)(v837 + 1920) = DWORD1(v894[0]);
                      }
                    }

                    *(_DWORD *)(v837 + 104) = DWORD1(v920);
                    *(_DWORD *)(v837 + 136) = v194;
                    if (v193)
                    {
                      uint64_t v195 = v193[25] + v843;
                      v193[24] += v823;
                      v193[25] = v195;
                    }

                    v196 = *(void **)(a3 + 248);
                    ++*v196;
                    if (v824)
                    {
                      ++**(void **)(a3 + 256);
                      if (!v17) {
                        goto LABEL_510;
                      }
                    }

                    else if (!v17)
                    {
LABEL_510:
                      if (!v18) {
                        goto LABEL_512;
                      }
                      goto LABEL_511;
                    }

                    ++**(void **)(a3 + 264);
                    if (!v18)
                    {
LABEL_512:
                      v196[1] += v843;
                      if (v824)
                      {
                        *(void *)(*(void *)(a3 + 256) + 8LL) += v843;
                        if (!v17) {
                          goto LABEL_514;
                        }
                      }

                      else if (!v17)
                      {
LABEL_514:
                        if (!v18) {
                          goto LABEL_516;
                        }
                        goto LABEL_515;
                      }

                      *(void *)(*(void *)(a3 + 264) + 8LL) += v843;
                      if (!v18)
                      {
LABEL_516:
                        tcp_compute_rcv_rtt(v837, (uint64_t)v894, (uint64_t)&v920);
                        tcp_sbrcv_grow(v837, v15 + 488, (uint64_t)v894, v843);
                        if (*(_DWORD *)(sysctls + 308) == 1
                          && (~*(_DWORD *)(v837 + 88) & 0x180) == 0
                          && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v15 + 369) & 0x40) != 0)
                          && off_18C4CE830)
                        {
                          off_18C4CE830(v837, (uint64_t)&v920, (uint64_t)v894, v843);
                        }

                        uint64_t v197 = *a1;
                        if (*a1)
                        {
                          if ((*(_WORD *)(v197 + 204) & 0x80) == 0) {
                            goto LABEL_1788;
                          }
                          unsigned int v198 = *(unsigned __int16 *)(v197 + 196);
                          BOOL v65 = v198 >= v846;
                          __int16 v199 = v198 - v846;
                          if (v65)
                          {
                            *(_WORD *)(v197 + 196) = v199;
                            goto LABEL_1788;
                          }

                          __nwlog_obj();
                          int v200 = *(unsigned __int16 *)(v197 + 196);
                          *(_DWORD *)__int128 buf = 136446722;
                          v900 = "__nw_frame_array_claim";
                          __int16 v901 = 1024;
                          *(_DWORD *)v902 = v200;
                          *(_WORD *)&v902[4] = 1024;
                          *(_DWORD *)&v902[6] = v846;
                          v201 = (void *)_os_log_send_and_compose_impl();
                          type[0] = OS_LOG_TYPE_ERROR;
                          char v898 = 0;
                          if (type[0] == OS_LOG_TYPE_FAULT)
                          {
                            v202 = (os_log_s *)__nwlog_obj();
                            os_log_type_t v203 = type[0];
                            if (os_log_type_enabled(v202, type[0]))
                            {
                              int v204 = *(unsigned __int16 *)(v197 + 196);
                              *(_DWORD *)__int128 buf = 136446722;
                              v900 = "__nw_frame_array_claim";
                              __int16 v901 = 1024;
                              *(_DWORD *)v902 = v204;
                              *(_WORD *)&v902[4] = 1024;
                              *(_DWORD *)&v902[6] = v846;
                              v205 = "%{public}s Aggregate buffer length: %u sum: %u";
LABEL_1783:
                              v676 = v202;
LABEL_1784:
                              _os_log_impl(&dword_1879E5000, v676, v203, v205, buf, 0x18u);
                            }
                          }

                          else if (v898)
                          {
                            v650 = (void *)__nw_create_backtrace_string();
                            v651 = (os_log_s *)__nwlog_obj();
                            os_log_type_t v203 = type[0];
                            BOOL v652 = os_log_type_enabled(v651, type[0]);
                            if (v650)
                            {
                              if (v652)
                              {
                                int v653 = *(unsigned __int16 *)(v197 + 196);
                                *(_DWORD *)__int128 buf = 136446978;
                                v900 = "__nw_frame_array_claim";
                                __int16 v901 = 1024;
                                *(_DWORD *)v902 = v653;
                                *(_WORD *)&v902[4] = 1024;
                                *(_DWORD *)&v902[6] = v846;
                                *(_WORD *)v903 = 2082;
                                *(void *)&v903[2] = v650;
                                _os_log_impl( &dword_1879E5000,  v651,  type[0],  "%{public}s Aggregate buffer length: %u sum: %u, dumping backtrace:%{public}s",  buf,  0x22u);
                              }

                              free(v650);
                              goto LABEL_1785;
                            }

                            if (v652)
                            {
                              int v705 = *(unsigned __int16 *)(v197 + 196);
                              *(_DWORD *)__int128 buf = 136446722;
                              v900 = "__nw_frame_array_claim";
                              __int16 v901 = 1024;
                              *(_DWORD *)v902 = v705;
                              *(_WORD *)&v902[4] = 1024;
                              *(_DWORD *)&v902[6] = v846;
                              v205 = "%{public}s Aggregate buffer length: %u sum: %u, no backtrace";
                              v676 = v651;
                              goto LABEL_1784;
                            }
                          }

                          else
                          {
                            v202 = (os_log_s *)__nwlog_obj();
                            os_log_type_t v203 = type[0];
                            if (os_log_type_enabled(v202, type[0]))
                            {
                              int v675 = *(unsigned __int16 *)(v197 + 196);
                              *(_DWORD *)__int128 buf = 136446722;
                              v900 = "__nw_frame_array_claim";
                              __int16 v901 = 1024;
                              *(_DWORD *)v902 = v675;
                              *(_WORD *)&v902[4] = 1024;
                              *(_DWORD *)&v902[6] = v846;
                              v205 = "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded";
                              goto LABEL_1783;
                            }
                          }

LABEL_1785:
                          if (v201) {
                            free(v201);
                          }
                          *(_WORD *)(v197 + 196) = 0;
                          goto LABEL_1788;
                        }

                        __nwlog_obj();
                        *(_DWORD *)__int128 buf = 136446210;
                        v900 = "__nw_frame_is_single_ip_aggregate";
                        v789 = (void *)_os_log_send_and_compose_impl();
                        type[0] = OS_LOG_TYPE_ERROR;
                        char v898 = 0;
                        if (__nwlog_fault())
                        {
                          if (type[0] == OS_LOG_TYPE_FAULT)
                          {
                            v790 = (os_log_s *)__nwlog_obj();
                            os_log_type_t v791 = type[0];
                            if (!os_log_type_enabled(v790, type[0])) {
                              goto LABEL_2076;
                            }
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_is_single_ip_aggregate";
                            v792 = "%{public}s called with null frame";
LABEL_2074:
                            v802 = v790;
                            os_log_type_t v803 = v791;
LABEL_2075:
                            _os_log_impl(&dword_1879E5000, v802, v803, v792, buf, 0xCu);
                            goto LABEL_2076;
                          }

                          if (!v898)
                          {
                            v790 = (os_log_s *)__nwlog_obj();
                            os_log_type_t v791 = type[0];
                            if (!os_log_type_enabled(v790, type[0])) {
                              goto LABEL_2076;
                            }
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_is_single_ip_aggregate";
                            v792 = "%{public}s called with null frame, backtrace limit exceeded";
                            goto LABEL_2074;
                          }

                          v797 = (void *)__nw_create_backtrace_string();
                          v798 = (os_log_s *)__nwlog_obj();
                          BOOL v799 = os_log_type_enabled(v798, type[0]);
                          if (v797)
                          {
                            if (v799)
                            {
                              *(_DWORD *)__int128 buf = 136446466;
                              v900 = "__nw_frame_is_single_ip_aggregate";
                              __int16 v901 = 2082;
                              *(void *)v902 = v797;
                              _os_log_impl( &dword_1879E5000,  v798,  type[0],  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                            }

                            free(v797);
                            goto LABEL_2076;
                          }

                          if (v799)
                          {
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_is_single_ip_aggregate";
                            v792 = "%{public}s called with null frame, no backtrace";
                            v802 = v798;
                            os_log_type_t v803 = type[0];
                            goto LABEL_2075;
                          }
                        }

LABEL_2076:
                        if (v789) {
                          free(v789);
                        }
LABEL_1788:
                        uint64_t v677 = *a1;
                        if (*a1)
                        {
                          unsigned int v678 = 0;
                          while (1)
                          {
                            int v679 = *(_DWORD *)(v677 + 52);
                            int v680 = *(_DWORD *)(v677 + 56);
                            int v681 = *(_DWORD *)(v677 + 60);
                            unsigned int v682 = v679 - (v680 + v681);
                            unsigned int v683 = v679 ? v682 : 0;
                            int v684 = v680 + v683;
                            if (v680 + v683 <= v679 - v681)
                            {
                              *(_DWORD *)(v677 + 56) = v684;
                            }

                            else
                            {
                              v685 = (os_log_s *)__nwlog_obj();
                              if (os_log_type_enabled(v685, OS_LOG_TYPE_ERROR))
                              {
                                int v686 = *(_DWORD *)(v677 + 52);
                                *(_DWORD *)__int128 buf = 136446978;
                                v900 = "__nw_frame_claim_internal";
                                __int16 v901 = 1024;
                                *(_DWORD *)v902 = v684;
                                *(_WORD *)&v902[4] = 1024;
                                *(_DWORD *)&v902[6] = v686;
                                *(_WORD *)v903 = 1024;
                                *(_DWORD *)&v903[2] = v681;
                                _os_log_impl( &dword_1879E5000,  v685,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
                              }
                            }

                            v678 += v683;
                            if (v678 == (_DWORD)v846) {
                              break;
                            }
                            if (v678 < v846)
                            {
                              uint64_t v677 = *(void *)(v677 + 32);
                              if (v677) {
                                continue;
                              }
                            }

                            goto LABEL_1804;
                          }
                        }

                        else
                        {
                          unsigned int v678 = 0;
LABEL_1804:
                          if (v678 != (_DWORD)v846)
                          {
                            v687 = (os_log_s *)__nwlog_obj();
                            if (os_log_type_enabled(v687, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)__int128 buf = 136446722;
                              v900 = "__nw_frame_array_claim";
                              __int16 v901 = 1024;
                              *(_DWORD *)v902 = v678;
                              *(_WORD *)&v902[4] = 1024;
                              *(_DWORD *)&v902[6] = v846;
                              _os_log_impl( &dword_1879E5000,  v687,  OS_LOG_TYPE_ERROR,  "%{public}s start_offset %u != start_bytes %u",  buf,  0x18u);
                            }
                          }
                        }

                        if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
                        {
                          if (__nwlog_is_datapath_logging_enabled())
                          {
                            v793 = (os_log_s *)__nwlog_tcp_log();
                            if (os_log_type_enabled(v793, OS_LOG_TYPE_DEBUG))
                            {
                              v794 = "";
                              v900 = "tcp_input";
                              *(_DWORD *)__int128 buf = 136446722;
                              if (v15) {
                                v794 = (const char *)(v15 + 604);
                              }
                              __int16 v901 = 2082;
                              *(void *)v902 = v794;
                              *(_WORD *)&v902[8] = 1024;
                              *(_DWORD *)v903 = *(_DWORD *)v897;
                              _os_log_impl( &dword_1879E5000,  v793,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s queueing frame of length %u - fastpath",  buf,  0x1Cu);
                            }
                          }
                        }

                        *(_DWORD *)(v837 + 740) = *(_DWORD *)(v837 + 740) & 0xFFFFFFEF | (16 * ((BYTE13(v920) >> 3) & 1));
                        int v688 = *(_DWORD *)v897;
                        unsigned int v689 = tcp_input_sbappendstream(v15, a1, *(signed int *)v897, 2);
                        if (v848 && v689) {
                          _BYTE *v848 = 1;
                        }
                        *(_WORD *)(v837 + 304) += v823;
                        v690 = *(unsigned int (**)(uint64_t, __int128 *))(tcp_cc_algo_list[*(unsigned __int8 *)(v837 + 264)]
                                                                                  + 96);
                        if (v690 && v690(v837, &v920))
                        {
                          int v691 = *(_DWORD *)(v837 + 88);
                          if ((v691 & 2) == 0)
                          {
                            *(_DWORD *)(v837 + 88) = v691 | 2;
                            *(_DWORD *)(v837 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v837 + 80)
                                                                                                 + 224LL))
                                                               + 316)
                                                   - *(_DWORD *)(v837 + 64)
                                                   + 100;
                          }
                        }

                        else
                        {
                          *(_DWORD *)(v837 + 88) |= 1u;
                          tcp_output(v837);
                        }

                        tcp_adaptive_rwtimo_check(v837, v688);
                        if (v688 >= 1 && *(_BYTE *)(v837 + 993)) {
                          *(_BYTE *)(v837 + 993) = 0;
                        }
                        tcp_check_timer_state(v837);
                        (*(void (**)(uint64_t, uint64_t))(*(void *)(v15 + 8) + 24LL))(v15, 1LL);
                        BOOL *v890 = 0;
                        uint64_t result = (void *)*a1;
                        if (!*a1) {
                          return result;
                        }
                        while (1)
                        {
                          v692 = (void (*)(void *, uint64_t, uint64_t))result[10];
                          v693 = (void *)result[4];
                          if (!v692) {
                            break;
                          }
                          uint64_t v694 = result[11];
                          result[10] = 0LL;
                          result[11] = 0LL;
                          v692(result, 1LL, v694);
LABEL_1824:
                          uint64_t result = v693;
                          if (!v693) {
                            return result;
                          }
                        }

                        __nwlog_obj();
                        *(_DWORD *)__int128 buf = 136446210;
                        v900 = "__nw_frame_finalize";
                        uint64_t v695 = _os_log_send_and_compose_impl();
                        type[0] = OS_LOG_TYPE_ERROR;
                        char v898 = 0;
                        v888 = (void *)v695;
                        if (__nwlog_fault())
                        {
                          if (type[0] == OS_LOG_TYPE_FAULT)
                          {
                            v874 = (os_log_s *)__nwlog_obj();
                            if (!os_log_type_enabled(v874, type[0])) {
                              goto LABEL_1840;
                            }
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_finalize";
                            v696 = v874;
                            os_log_type_t v697 = type[0];
                            v698 = "%{public}s called with null frame->finalizer";
                            goto LABEL_1839;
                          }

                          if (!v898)
                          {
                            v876 = (os_log_s *)__nwlog_obj();
                            if (!os_log_type_enabled(v876, type[0])) {
                              goto LABEL_1840;
                            }
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_finalize";
                            v696 = v876;
                            os_log_type_t v697 = type[0];
                            v698 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                            goto LABEL_1839;
                          }

                          v875 = (void *)__nw_create_backtrace_string();
                          loguint64_t i = (os_log_s *)__nwlog_obj();
                          BOOL v699 = os_log_type_enabled(logi, type[0]);
                          if (v875)
                          {
                            if (v699)
                            {
                              *(_DWORD *)__int128 buf = 136446466;
                              v900 = "__nw_frame_finalize";
                              __int16 v901 = 2082;
                              *(void *)v902 = v875;
                              _os_log_impl( &dword_1879E5000,  logi,  type[0],  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
                            }

                            free(v875);
                            goto LABEL_1840;
                          }

                          if (v699)
                          {
                            *(_DWORD *)__int128 buf = 136446210;
                            v900 = "__nw_frame_finalize";
                            v696 = logi;
                            os_log_type_t v697 = type[0];
                            v698 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1839:
                            _os_log_impl(&dword_1879E5000, v696, v697, v698, buf, 0xCu);
                          }
                        }

LABEL_1840:
                        if (v888) {
                          free(v888);
                        }
                        goto LABEL_1824;
                      }

LABEL_515:
                      *(void *)(*(void *)(a3 + 272) + 8LL) += v843;
                      goto LABEL_516;
                    }

LABEL_511:
                    ++**(void **)(a3 + 272);
                    goto LABEL_512;
                  }

LABEL_406:
                  int v821 = 0;
                  goto LABEL_432;
                }

                tcp_reset_stretch_ack(v121);
                uint64_t v164 = v835;
                *(_WORD *)(v121 + 308) = 16;
                *(_DWORD *)(v121 + 744) = 0;
                int v166 = *(_DWORD *)(v121 + 12);
              }

              if (log != 3)
              {
                int v821 = 0;
                goto LABEL_418;
              }

              if (v166 == 4)
              {
                int v178 = *(_DWORD *)(v121 + 348);
                goto LABEL_411;
              }

LABEL_416:
              int v821 = 1;
              goto LABEL_433;
            }

            if ((_DWORD)v71 == v150) {
              goto LABEL_373;
            }
            int v165 = DWORD1(v920);
            if (v843 < 1 || (int v172 = *(_DWORD *)(v121 + 284), DWORD1(v920) - v172 < 0))
            {
              uint64_t v164 = v835;
              LOBYTE(v130) = v881;
              goto LABEL_397;
            }

            uint64_t v164 = v835;
            LOBYTE(v130) = v881;
            if (DWORD1(v920) - (v172 + *(_DWORD *)(v121 + 128)) < 0)
            {
LABEL_373:
              tcp_input_ip_ecn(v121, a3, v843, v823, log);
              uint64_t v164 = v835;
              int v165 = DWORD1(v920);
            }

LABEL_397:
            if (v165 == *(_DWORD *)(v121 + 112) + 1 && !v819) {
              *(_DWORD *)(v121 + 360) = 6;
            }
            goto LABEL_400;
          }

          if ((*(_WORD *)(v13 + 204) & 0x100) != 0
            && *MEMORY[0x189608EF8]
            && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v13, *(void *)(v13 + 88)) & 1) == 0)
          {
            *(void *)(v837 + 1056) = 0LL;
            if (!v15) {
              goto LABEL_256;
            }
          }

          else
          {
            uint64_t v126 = *(void *)(v837 + 1056);
            if (v126) {
              ++*(void *)(v126 + 320);
            }
            if (!v15) {
              goto LABEL_256;
            }
          }
        }

        if ((*(_BYTE *)(v15 + 828) & 2) != 0)
        {
LABEL_262:
          in_pcb_checkstate(a3, 2LL, 1);
          int v43 = a1;
          int v54 = v847;
          goto LABEL_66;
        }

LABEL_256:
        __int16 v127 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v127, OS_LOG_TYPE_INFO))
        {
          uint64_t v128 = "";
          if (v15) {
            uint64_t v128 = (const char *)(v15 + 604);
          }
          *(_DWORD *)__int128 buf = 136446466;
          v900 = "tcp_input";
          __int16 v901 = 2082;
          *(void *)v902 = v128;
          _os_log_impl(&dword_1879E5000, v127, OS_LOG_TYPE_INFO, "%{public}s %{public}s invalid checksum", buf, 0x16u);
        }

        goto LABEL_262;
      }

LABEL_168:
      if (v15 && (*(_BYTE *)(v15 + 828) & 2) != 0)
      {
        int v847 = 0;
        int v72 = 1;
        goto LABEL_232;
      }

      __nwlog_tcp_log();
      if (v15) {
        __int16 v102 = (const char *)(v15 + 604);
      }
      else {
        __int16 v102 = "";
      }
      *(_DWORD *)__int128 buf = 136446466;
      v900 = "tcp_compute_segment_length";
      __int16 v901 = 2082;
      *(void *)v902 = v102;
      int v103 = (void *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v898 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v104 = (os_log_s *)__nwlog_tcp_log();
        os_log_type_t v105 = type[0];
        if (os_log_type_enabled(v104, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446466;
          v900 = "tcp_compute_segment_length";
          __int16 v901 = 2082;
          *(void *)v902 = v102;
          uint64_t v106 = "%{public}s %{public}s Segment count is 0 for single-IP frame";
LABEL_179:
          _os_log_impl(&dword_1879E5000, v104, v105, v106, buf, 0x16u);
        }
      }

      else
      {
        int v104 = (os_log_s *)__nwlog_tcp_log();
        os_log_type_t v105 = type[0];
        if (os_log_type_enabled(v104, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446466;
          v900 = "tcp_compute_segment_length";
          __int16 v901 = 2082;
          *(void *)v902 = v102;
          uint64_t v106 = "%{public}s %{public}s Segment count is 0 for single-IP frame, backtrace limit exceeded";
          goto LABEL_179;
        }
      }

LABEL_180:
      if (v103) {
        free(v103);
      }
      int v72 = 1;
      goto LABEL_183;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    v900 = "__nw_frame_get_segment_count";
    uint64_t v89 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v898 = 0;
    if (__nwlog_fault())
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        unsigned int v90 = (os_log_s *)__nwlog_obj();
        os_log_type_t v91 = type[0];
        if (!os_log_type_enabled(v90, type[0])) {
          goto LABEL_166;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_get_segment_count";
        int v92 = "%{public}s Attempt to get segment-count on a chain-member";
      }

      else
      {
        unsigned int v90 = (os_log_s *)__nwlog_obj();
        os_log_type_t v91 = type[0];
        if (!os_log_type_enabled(v90, type[0])) {
          goto LABEL_166;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_get_segment_count";
        int v92 = "%{public}s Attempt to get segment-count on a chain-member, backtrace limit exceeded";
      }

      _os_log_impl(&dword_1879E5000, v90, v91, v92, buf, 0xCu);
    }

LABEL_166:
    if (v89) {
      free(v89);
    }
    goto LABEL_168;
  }

  int v847 = 0;
  LODWORD(v71) = 0;
  int v72 = 0;
  char v73 = (const char *)(v15 + 604);
  if (!v15) {
    char v73 = "";
  }
  v842 = v73;
  char v74 = 1;
  while (1)
  {
    if ((*(_WORD *)(v69 + 204) & 0x4000) == 0)
    {
      if ((v74 & 1) == 0) {
        goto LABEL_124;
      }
LABEL_128:
      int v75 = *(_DWORD *)(v69 + 52);
      if (!v75) {
        goto LABEL_129;
      }
      goto LABEL_108;
    }

    if ((v74 & 1) == 0) {
      break;
    }
    if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
    {
      int v77 = (os_log_s *)__nwlog_tcp_log();
      int v847 = 1;
      if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        v900 = "tcp_compute_segment_length";
        __int16 v901 = 2082;
        *(void *)v902 = v842;
        int v847 = 1;
        _os_log_impl( &dword_1879E5000,  v77,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s first frame is wake packet",  buf,  0x16u);
        int v75 = *(_DWORD *)(v69 + 52);
        if (!v75) {
          goto LABEL_129;
        }
        goto LABEL_108;
      }

      goto LABEL_128;
    }

    int v847 = 1;
    int v75 = *(_DWORD *)(v69 + 52);
    if (!v75)
    {
LABEL_129:
      int v76 = 0;
      goto LABEL_109;
    }

LABEL_108:
    int v76 = v75 - (*(_DWORD *)(v69 + 56) + *(_DWORD *)(v69 + 60));
LABEL_109:
    char v74 = 0;
    uint64_t v71 = (v76 + v71);
    uint64_t v69 = *(void *)(v69 + 32);
    ++v72;
    if (!v69) {
      goto LABEL_228;
    }
  }

  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    int v78 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136446466;
      v900 = "tcp_compute_segment_length";
      __int16 v901 = 2082;
      *(void *)v902 = v842;
      _os_log_impl(&dword_1879E5000, v78, OS_LOG_TYPE_INFO, "%{public}s %{public}s frame is wake packet", buf, 0x16u);
    }
  }

  int v79 = *(_WORD *)(v69 + 204) & 0xBFFF | (*(unsigned __int8 *)(v69 + 206) << 16);
  *(_WORD *)(v69 + 204) &= ~0x4000u;
  *(_BYTE *)(v69 + 206) = BYTE2(v79);
  if (*a1)
  {
    *(_WORD *)(*a1 + 204) |= 0x4000u;
    int v847 = 1;
    goto LABEL_124;
  }

  uint64_t v813 = v13;
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  v900 = "__nw_frame_set_is_wake_packet";
  __int16 v83 = (void *)_os_log_send_and_compose_impl();
  v897[0] = OS_LOG_TYPE_ERROR;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault())
  {
    if (v897[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v84 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v84, v897[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_set_is_wake_packet";
        __int16 v85 = v84;
        os_log_type_t v86 = v897[0];
        unsigned int v87 = "%{public}s called with null frame";
        goto LABEL_138;
      }
    }

    else
    {
      uint64_t v88 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v88, v897[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_set_is_wake_packet";
        __int16 v85 = v88;
        os_log_type_t v86 = v897[0];
        unsigned int v87 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_138:
        _os_log_impl(&dword_1879E5000, v85, v86, v87, buf, 0xCu);
      }
    }
  }

  if (v83) {
    free(v83);
  }
  int v847 = 1;
  uint64_t v13 = v813;
  uint64_t v29 = (void *)MEMORY[0x189608EF8];
LABEL_124:
  int v80 = v29;
  if ((*(_WORD *)(v69 + 204) & 0x80) != 0) {
    *(_WORD *)(v69 + 196) -= v846;
  }
  unsigned int v81 = *(_DWORD *)(v69 + 56) + v846;
  int v82 = *(_DWORD *)(v69 + 60);
  if (v81 <= *(_DWORD *)(v69 + 52) - v82)
  {
    *(_DWORD *)(v69 + 56) = v81;
    uint64_t v29 = v80;
    goto LABEL_128;
  }

  char v93 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
  {
    int v94 = *(_DWORD *)(v69 + 52);
    *(_DWORD *)__int128 buf = 136446978;
    v900 = "__nw_frame_claim_internal";
    __int16 v901 = 1024;
    *(_DWORD *)v902 = v81;
    *(_WORD *)&v902[4] = 1024;
    *(_DWORD *)&v902[6] = v94;
    *(_WORD *)v903 = 1024;
    *(_DWORD *)&v903[2] = v82;
    _os_log_impl( &dword_1879E5000,  v93,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
  }

  int v43 = a1;
  uint64_t v95 = v837;
  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v96 = *(_DWORD *)(v69 + 52);
    if (v96) {
      v96 -= *(_DWORD *)(v69 + 56) + *(_DWORD *)(v69 + 60);
    }
    *(_DWORD *)__int128 buf = 136446978;
    v900 = "tcp_compute_segment_length";
    __int16 v901 = 2082;
    *(void *)v902 = v842;
    *(_WORD *)&v902[8] = 1024;
    *(_DWORD *)v903 = v96;
    *(_WORD *)&v903[4] = 1024;
    *(_DWORD *)&v903[6] = v846;
    uint64_t v97 = (void *)_os_log_send_and_compose_impl();
    v897[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault())
    {
      if (v897[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v98 = (os_log_s *)__nwlog_tcp_log();
        os_log_type_t v99 = v897[0];
        if (os_log_type_enabled(v98, v897[0]))
        {
          int v100 = *(_DWORD *)(v69 + 52);
          if (v100) {
            v100 -= *(_DWORD *)(v69 + 56) + *(_DWORD *)(v69 + 60);
          }
          *(_DWORD *)__int128 buf = 136446978;
          v900 = "tcp_compute_segment_length";
          __int16 v901 = 2082;
          *(void *)v902 = v842;
          *(_WORD *)&v902[8] = 1024;
          *(_DWORD *)v903 = v100;
          *(_WORD *)&v903[4] = 1024;
          *(_DWORD *)&v903[6] = v846;
          __int16 v101 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u";
          goto LABEL_191;
        }
      }

      else
      {
        __int16 v98 = (os_log_s *)__nwlog_tcp_log();
        os_log_type_t v99 = v897[0];
        if (os_log_type_enabled(v98, v897[0]))
        {
          int v107 = *(_DWORD *)(v69 + 52);
          if (v107) {
            v107 -= *(_DWORD *)(v69 + 56) + *(_DWORD *)(v69 + 60);
          }
          *(_DWORD *)__int128 buf = 136446978;
          v900 = "tcp_compute_segment_length";
          __int16 v901 = 2082;
          *(void *)v902 = v842;
          *(_WORD *)&v902[8] = 1024;
          *(_DWORD *)v903 = v107;
          *(_WORD *)&v903[4] = 1024;
          *(_DWORD *)&v903[6] = v846;
          __int16 v101 = "%{public}s %{public}s chained frame len %u is smaller than TCP header size %u, backtrace limit exceeded";
LABEL_191:
          _os_log_impl(&dword_1879E5000, v98, v99, v101, buf, 0x22u);
        }
      }
    }

    if (v97) {
      free(v97);
    }
    uint64_t v95 = v837;
  }

  uint64_t v108 = *(void *)(v95 + 1056);
  if (v108) {
    ++*(void *)(v108 + 152);
  }
  uint64_t v42 = v890;
  if (!v15 || (*(_BYTE *)(v15 + 828) & 2) == 0)
  {
    uint64_t v109 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      v900 = "tcp_input";
      __int16 v901 = 2082;
      *(void *)v902 = v842;
      _os_log_impl(&dword_1879E5000, v109, OS_LOG_TYPE_ERROR, "%{public}s %{public}s invalid frame list", buf, 0x16u);
    }
  }

  in_pcb_checkstate(a3, 2LL, 1);
  int v54 = v847;
LABEL_66:
  *uint64_t v42 = v54 != 0;
  uint64_t result = (void *)*v43;
  if (*v43)
  {
    while (2)
    {
      __int16 v56 = (void (*)(void *, uint64_t, uint64_t))result[10];
      int v57 = (void *)result[4];
      if (v56)
      {
        uint64_t v58 = result[11];
        result[10] = 0LL;
        result[11] = 0LL;
        v56(result, 1LL, v58);
        goto LABEL_69;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      v900 = "__nw_frame_finalize";
      uint64_t v59 = _os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v898 = 0;
      v880 = (void *)v59;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v862 = (os_log_s *)__nwlog_obj();
        os_log_type_t loga = type[0];
        if (os_log_type_enabled(v862, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          v900 = "__nw_frame_finalize";
          uint64_t v60 = v862;
          os_log_type_t v61 = loga;
          uint64_t v62 = "%{public}s called with null frame->finalizer";
          break;
        }

        goto LABEL_85;
      }

      if (v898)
      {
        v863 = (void *)__nw_create_backtrace_string();
        logb = (os_log_s *)__nwlog_obj();
        os_log_type_t v849 = type[0];
        BOOL v63 = os_log_type_enabled(logb, type[0]);
        if (v863)
        {
          if (v63)
          {
            *(_DWORD *)__int128 buf = 136446466;
            v900 = "__nw_frame_finalize";
            __int16 v901 = 2082;
            *(void *)v902 = v863;
            _os_log_impl( &dword_1879E5000,  logb,  v849,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v863);
          goto LABEL_85;
        }

        if (!v63)
        {
LABEL_85:
          if (v880) {
            free(v880);
          }
LABEL_69:
          uint64_t result = v57;
          if (!v57) {
            return result;
          }
          continue;
        }

        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_finalize";
        uint64_t v60 = logb;
        os_log_type_t v61 = v849;
        uint64_t v62 = "%{public}s called with null frame->finalizer, no backtrace";
      }

      else
      {
        v864 = (os_log_s *)__nwlog_obj();
        os_log_type_t logc = type[0];
        if (!os_log_type_enabled(v864, type[0])) {
          goto LABEL_85;
        }
        *(_DWORD *)__int128 buf = 136446210;
        v900 = "__nw_frame_finalize";
        uint64_t v60 = v864;
        os_log_type_t v61 = logc;
        uint64_t v62 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }

      break;
    }

    _os_log_impl(&dword_1879E5000, v60, v61, v62, buf, 0xCu);
    goto LABEL_85;
  }

  return result;
}

BOOL tcp_stretch_ack_enable(uint64_t a1, int a2)
{
  uint64_t v4 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  uint64_t v5 = sysctls;
  if (*(_DWORD *)(a1 + 328) >= (*(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 52)))
  {
    int v7 = *(_DWORD *)(a1 + 324);
    int v6 = *(_DWORD *)(v4 + 316);
    if (v7 - v6 >= 0)
    {
      unsigned int v8 = *(_DWORD *)(a1 + 88) | 0x2000000;
      goto LABEL_6;
    }
  }

  else
  {
    int v6 = *(_DWORD *)(v4 + 316);
    int v7 = *(_DWORD *)(a1 + 324);
  }

  unsigned int v8 = *(_DWORD *)(a1 + 88) & 0xFDFFFFFF;
LABEL_6:
  *(_DWORD *)(a1 + 88) = v8;
  if (v6 - v7 - 200 >= 1)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }

  if ((a2 & 0xFFFFFFEF) != 0)
  {
    v8 &= ~0x2000000u;
    *(_DWORD *)(a1 + 88) = v8;
  }

  int v9 = *(_DWORD *)(a1 + 740);
  if ((v9 & 0x10000) != 0)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 340);
    if (v10 < 0x7D0)
    {
      *(_DWORD *)(a1 + 340) = v10 + 1;
    }

    else
    {
      v9 &= ~0x10000u;
      *(_DWORD *)(a1 + 740) = v9;
      *(void *)(a1 + 336) = 0LL;
    }
  }

  return (v9 & 0x10200) == 0
      && (v8 & 0x2000000) != 0
      && ((v9 & 2) == 0 || *(_DWORD *)(v5 + 76) <= (int)*(unsigned __int16 *)(a1 + 344));
}

uint64_t tcp_input_ip_ecn(uint64_t result, uint64_t a2, unsigned int a3, int a4, int a5)
{
  if (a5 != 3)
  {
    if (a5 == 2)
    {
      *(_DWORD *)(result + 348) |= 0x1000000u;
      uint64_t v5 = (void *)(result + 440);
    }

    else
    {
      if (a5 != 1) {
        return result;
      }
      *(_DWORD *)(result + 348) |= 0x800000u;
      uint64_t v5 = (void *)(result + 432);
    }

    goto LABEL_13;
  }

  *(_DWORD *)(result + 416) += a4;
  *(void *)(result + 448) += a3;
  ++*(_DWORD *)(result + 352);
  uint64_t v6 = *(void *)(result + 1056);
  if (v6) {
    ++*(void *)(v6 + 856);
  }
  uint64_t v7 = *(void *)(a2 + 448);
  if (v7)
  {
    unsigned int v8 = (void *)(v7 + 184);
    uint64_t v5 = (void *)(v7 + 568);
    if ((*(_BYTE *)(a2 + 2236) & 2) == 0) {
      uint64_t v5 = v8;
    }
    a3 = 1;
LABEL_13:
    *v5 += a3;
  }

  return result;
}

uint64_t tcp_dooptions(uint64_t result, unsigned __int8 *a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3 >= 1)
  {
    do
    {
      int v7 = *a2;
      if (v7 == 1)
      {
        unsigned int v5 = 1;
      }

      else
      {
        if (*a2) {
          BOOL v8 = a3 >= 2;
        }
        else {
          BOOL v8 = 0;
        }
        if (!v8) {
          return result;
        }
        unsigned int v5 = a2[1];
        unsigned int v9 = v5 - 2;
        if (v5 < 2 || a3 < v5) {
          return result;
        }
        switch(*a2)
        {
          case 2u:
            if (v5 == 4)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) != 0)
              {
                *(_WORD *)(a5 + 12) = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
                *(_DWORD *)a5 |= 0x10u;
              }

              unsigned int v5 = 4;
            }

            break;
          case 3u:
            if (v5 == 3)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) != 0)
              {
                *(_DWORD *)a5 |= 0x20u;
                unsigned int v16 = a2[2];
                if (v16 >= 0xE) {
                  LOBYTE(v16) = 14;
                }
                *(_BYTE *)(a5 + 14) = v16;
                unsigned int v5 = 3;
              }

              else
              {
                unsigned int v5 = 3;
              }
            }

            break;
          case 4u:
            if (v5 == 2)
            {
              if ((*(_BYTE *)(a4 + 13) & 2) == 0) {
                goto LABEL_48;
              }
              int v12 = *(_DWORD *)a5 | 0x100;
              goto LABEL_44;
            }

            break;
          case 5u:
            if (v5 >= 3 && (v9 & 7) == 0)
            {
              *(_BYTE *)(a5 + 15) = v9 >> 3;
              *(void *)(a5 + 16) = a2 + 2;
              uint64_t v13 = *(void *)(result + 1056);
              if (v13) {
                ++*(void *)(v13 + 592);
              }
            }

            break;
          case 6u:
          case 7u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
          case 0x20u:
          case 0x21u:
            break;
          case 8u:
            if (v5 == 10)
            {
              *(_DWORD *)a5 |= 1u;
              *(_DWORD *)(a5 + 4) = bswap32(*(_DWORD *)(a2 + 2));
              unsigned int v14 = *(_DWORD *)(a2 + 6);
              *(_DWORD *)(a5 + 8) = v14;
              *(_DWORD *)(a5 + 8) = bswap32(v14) - *(_DWORD *)(result + 1888);
              int v15 = *(_DWORD *)(result + 88);
              if ((v15 & 0x80) == 0) {
                *(_DWORD *)(result + 88) = v15 | 0x80;
              }
              unsigned int v5 = 10;
            }

            break;
          case 0x22u:
            if (v5 == 2)
            {
              if (*(_DWORD *)(result + 12) == 1)
              {
                int v12 = *(_DWORD *)a5 | 0x800;
LABEL_44:
                *(_DWORD *)a5 = v12;
                unsigned int v5 = 2;
              }

              else
              {
LABEL_48:
                unsigned int v5 = 2;
              }
            }

            else if ((v5 - 19) >= 0xF3u && (*(_DWORD *)(result + 12) - 1) <= 1)
            {
              *(_DWORD *)a5 |= 0x400u;
              *(void *)(a5 + 24) = a2 + 1;
            }

            break;
          default:
            if ((v7 == 172 || v7 == 174) && v5 >= 5)
            {
              char v11 = (v5 - 2) / 3u;
              if ((-3 * v11) == (2 - v5))
              {
                *(_BYTE *)(a5 + 32) = v11;
                *(void *)(a5 + 40) = a2 + 2;
                *(_BYTE *)(a5 + 48) = v7 == 174;
              }
            }

            break;
        }
      }

      a2 += v5;
      BOOL v6 = __OFSUB__(a3, v5);
      a3 -= v5;
    }

    while (!((a3 < 0) ^ v6 | (a3 == 0)));
  }

  return result;
}

void tcp_finalize_options(uint64_t a1, int *a2, uint64_t a3)
{
  int v6 = *a2;
  if ((*a2 & 1) != 0)
  {
    *(_DWORD *)(a1 + 88) |= 0x100u;
    *(_DWORD *)(a1 + 276) = a2[1];
    *(_DWORD *)(a1 + 280) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
    int v6 = *a2;
    if ((*a2 & 0x10) == 0)
    {
LABEL_3:
      int v7 = *(_DWORD *)(a1 + 740);
      if ((v7 & 0x20) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((v6 & 0x10) == 0)
  {
    goto LABEL_3;
  }

  tcp_mss(a1, *((unsigned __int16 *)a2 + 6), a3);
  int v6 = *a2;
  int v7 = *(_DWORD *)(a1 + 740);
  if ((v7 & 0x20) == 0)
  {
LABEL_4:
    if ((v6 & 0x20) == 0) {
      return;
    }
    goto LABEL_12;
  }

LABEL_12:
  int v8 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = v8 | 0x40;
  *(_BYTE *)(a1 + 263) = *((_BYTE *)a2 + 14);
  if (*(_BYTE *)(a1 + 262)) {
    *(_DWORD *)(a1 + 88) = v8 | 0x60;
  }
}

uint64_t update_iaj_state(uint64_t result, unsigned int a2)
{
  if (*(_WORD *)(result + 748)) {
    BOOL v2 = *(unsigned __int16 *)(result + 748) > a2;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    uint64_t v3 = result;
    *(_WORD *)(result + 748) = a2;
    uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224LL));
    *(_DWORD *)(v3 + 744) = *(_DWORD *)(result + 316);
    *(_BYTE *)(v3 + 750) = 0;
  }

  return result;
}

uint64_t compute_iaj_meat(uint64_t result, unsigned int a2)
{
  int v2 = *(_DWORD *)(result + 756);
  int v3 = *(_DWORD *)(result + 760);
  unsigned int v4 = v3 + v2;
  if (*(unsigned __int16 *)(result + 752) >= 0x29u)
  {
    unsigned int v5 = *(unsigned __int16 *)(result + 754);
    unsigned int v6 = a2 - v4 + v5;
    BOOL v7 = v5 >= 2;
    unsigned int v8 = v5 - 2;
    if (!v7) {
      unsigned int v8 = 0;
    }
    if (a2 <= v4) {
      unsigned int v9 = v8;
    }
    else {
      unsigned int v9 = v6;
    }
    unsigned int v10 = *(_DWORD *)(sysctls + 112) + 100;
    if (v9 < v10) {
      LOWORD(v10) = v9;
    }
    *(_WORD *)(result + 754) = v10;
  }

  *(_DWORD *)(result + 756) = (a2 - v2 + 16 * v2 + 8) >> 4;
  unsigned int v11 = (a2 - v2) * (a2 - v2) - v3 * v3 + 16 * v3 * v3 + 8;
  unsigned int v12 = v11 >> 4;
  if (v11 >= 0x650)
  {
    int v13 = 0;
    char v14 = 15;
    unsigned int v15 = 0x8000;
    do
    {
      unsigned int v16 = (v15 + 2 * v13) << v14;
      if (v12 >= v16)
      {
        unsigned int v17 = v15;
      }

      else
      {
        unsigned int v16 = 0;
        unsigned int v17 = 0;
      }

      v13 += v17;
      if (v15 < 2) {
        break;
      }
      --v14;
      v15 >>= 1;
      v12 -= v16;
    }

    while (v12);
    *(_DWORD *)(result + 760) = v13;
  }

  else if (v12 > 1)
  {
    if (v11 >= 0x40)
    {
      if (v12 == 4)
      {
        *(_DWORD *)(result + 760) = 2;
      }

      else if (v11 >= 0x90)
      {
        if (v12 == 9 || v11 < 0x100)
        {
          *(_DWORD *)(result + 760) = 3;
        }

        else if (v12 == 16 || v11 < 0x190)
        {
          *(_DWORD *)(result + 760) = 4;
        }

        else if (v12 == 25 || v11 < 0x240)
        {
          *(_DWORD *)(result + 760) = 5;
        }

        else if (v12 == 36 || v11 < 0x310)
        {
          *(_DWORD *)(result + 760) = 6;
        }

        else if (v12 == 49 || v11 < 0x400)
        {
          *(_DWORD *)(result + 760) = 7;
        }

        else if (v12 == 64 || v11 < 0x510)
        {
          *(_DWORD *)(result + 760) = 8;
        }

        else if (v12 == 81 || v11 < 0x640)
        {
          *(_DWORD *)(result + 760) = 9;
        }

        else
        {
          *(_DWORD *)(result + 760) = 10;
        }
      }

      else
      {
        *(_DWORD *)(result + 760) = 2;
      }
    }

    else
    {
      *(_DWORD *)(result + 760) = 1;
    }
  }

  else
  {
    *(_DWORD *)(result + 760) = v12;
  }

  return result;
}

void tcp_bad_rexmt_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_WORD *)(a1 + 226) && tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 248)))
  {
    uint64_t v6 = *(void *)(a1 + 1056);
    if (v6) {
      ++*(void *)(v6 + 1312);
    }
    tcp_bad_rexmt_restore_state(a1, a2);
  }

  else if ((~*(_DWORD *)(a1 + 740) & 0x40001000) != 0 {
         || (int v7 = *(_DWORD *)(a1 + 928)) == 0
  }
         || *(_DWORD *)(a2 + 8) - v7 < 0
         || tcp_detect_bad_rexmt(a1, a2, a3, *(_DWORD *)(a1 + 936)))
  {
    uint64_t v8 = *(void *)(a1 + 952);
    if (v8 && *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 152) >= 0)
    {
      unsigned int v9 = (void *)(a1 + 952);
      while ((*(_WORD *)(v8 + 10) & 1) != 0)
      {
        uint64_t v8 = *(void *)(v8 + 16);
        if (!v8)
        {
          uint64_t v10 = *(void *)(a1 + 1056);
          if (v10) {
            ++*(void *)(v10 + 1032);
          }
          tcp_bad_rexmt_restore_state(a1, a2);
          unsigned int v11 = *(void **)(a1 + 952);
          if (v11)
          {
            do
            {
              unsigned int v17 = (void *)*v9;
              BOOL v18 = (void *)(a1 + 952);
              if ((void *)*v9 != v11)
              {
                do
                {
                  __int16 v19 = v17;
                  unsigned int v17 = (void *)v17[2];
                }

                while (v17 != v11);
                BOOL v18 = v19 + 2;
              }

              unsigned int v16 = (void *)v11[2];
              *BOOL v18 = v16;
              nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
              free(v11);
              unsigned int v11 = v16;
            }

            while (v16);
          }

          *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
          break;
        }
      }
    }
  }

  else
  {
    uint64_t v20 = *(void *)(a1 + 1056);
    if (v20) {
      ++*(void *)(v20 + 752);
    }
    int v21 = *(_DWORD *)(a1 + 88);
    if ((v21 & 0x200000) == 0)
    {
      int v22 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 64);
      if (v22)
      {
        v22(a1);
        int v21 = *(_DWORD *)(a1 + 88);
      }

      *(_DWORD *)(a1 + 88) = v21 | 0x200000;
      uint64_t v23 = *(void *)(a1 + 80);
      if ((*(_BYTE *)(v23 + 2231) & 0x40) != 0) {
        inp_reset_fc_state(v23);
      }
      if (*(void *)(a1 + 952)) {
        tcp_rxtseg_clean(a1);
      }
      int v24 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 96) + (v24 << 27 >> 31);
      int v25 = *(_DWORD *)(a1 + 740);
      *(_DWORD *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 172) = 0;
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 148);
      *(_DWORD *)(a1 + 88) = v24 & 0xFFDFFFFF;
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 310) = 3;
      *(_DWORD *)(a1 + 288) = 0;
      *(_DWORD *)(a1 + 348) &= ~0x20u;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 740) = v25 & 0xFFE7FFFF;
      *(_DWORD *)(a1 + 984) = 0;
      *(_DWORD *)(a1 + 628) = 0;
    }
  }

  *(_DWORD *)(a1 + 740) &= ~0x1000u;
  *(_DWORD *)(a1 + 928) = 0;
  *(_DWORD *)(a1 + 936) = 0;
  if (*(_WORD *)(a1 + 226))
  {
    int v12 = *(_DWORD *)(a1 + 88);
    if ((v12 & 0x20000000) != 0)
    {
      int v13 = *(_DWORD *)(a1 + 700);
      if ((~v12 & 0x180) == 0 && v13 != 0 && (*(_BYTE *)a3 & 1) != 0)
      {
        int v15 = *(_DWORD *)(a3 + 8);
        if (v15)
        {
          if (v15 - v13 < 0) {
            tcp_pmtud_revert_segment_size(a1);
          }
        }
      }
    }
  }

  if (*(_DWORD *)(a1 + 700)) {
    *(_DWORD *)(a1 + 700) = 0;
  }
  *(_WORD *)(a1 + 696) = 0;
}

void tcp_compute_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !a3)
  {
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    int v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v21);
  }

  uint64_t v6 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v7 = *(_DWORD *)(a1 + 172);
  if (v7)
  {
    int v8 = *(_DWORD *)(a3 + 8);
    if (v8 - *(_DWORD *)(a1 + 176) >= 1)
    {
      signed int v9 = *(_DWORD *)(v6 + 316) - v7;
      if (v9) {
        signed int v10 = v9;
      }
      else {
        signed int v10 = 1;
      }
      int v11 = v8 - *(_DWORD *)(a1 + 976);
      if (v11 < 1) {
        goto LABEL_23;
      }
      uint64_t v12 = *(unsigned __int8 *)(a1 + 751);
      *(_DWORD *)(a1 + 964 + 4 * v12) = v11;
      *(_BYTE *)(a1 + 751) = (v12 + 1) % 3u;
      unsigned int v13 = *(_DWORD *)(a1 + 964);
      if (v13 <= *(_DWORD *)(a1 + 968)) {
        unsigned int v13 = *(_DWORD *)(a1 + 968);
      }
      if (*(_DWORD *)(a1 + 972) > v13) {
        unsigned int v13 = *(_DWORD *)(a1 + 972);
      }
      if (*(_DWORD *)(sysctls + 304))
      {
        int v14 = *(_DWORD *)(sysctls + 16);
      }

      else
      {
        if (!*(_DWORD *)(sysctls + 276))
        {
          unsigned int v15 = 4380;
          goto LABEL_20;
        }

        int v14 = 10;
      }

      unsigned int v15 = *(_DWORD *)(a1 + 196) * v14;
LABEL_20:
      if (v13 <= v15) {
        unsigned int v13 = 0;
      }
      *(_DWORD *)(a1 + 980) = v13;
LABEL_23:
      *(_DWORD *)(a1 + 172) = 0;
      if ((*(_BYTE *)a2 & 1) == 0) {
        goto LABEL_27;
      }
      goto LABEL_24;
    }
  }

  signed int v10 = 0;
  if ((*(_BYTE *)a2 & 1) == 0) {
    goto LABEL_27;
  }
LABEL_24:
  int v16 = *(_DWORD *)(a2 + 8);
  if (v16)
  {
    int v17 = *(_DWORD *)(v6 + 316) - v16;
    if (v17 >= 0)
    {
      int v18 = *(_DWORD *)(a3 + 8);
      uint64_t v19 = a1;
      signed int v10 = v17;
      goto LABEL_29;
    }
  }

LABEL_27:
  if (v10 < 1) {
    return;
  }
  int v18 = *(_DWORD *)(a3 + 8);
  uint64_t v19 = a1;
  int v16 = 0;
LABEL_29:
  tcp_xmit_timer(v19, v10, v16, v18);
}

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v4);
  return v10;
}

void tcp_process_accecn(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, char a5)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 428) & 1) != 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        int v24 = 136446210;
        int v25 = "tcp_process_accecn";
        _os_log_impl( &dword_1879E5000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s already processed AccECN field/options for this ACK",  (uint8_t *)&v24,  0xCu);
      }
    }
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 472);
    unsigned int v7 = *(unsigned __int8 *)(a2 + 32);
    if (!*(_BYTE *)(a2 + 32)) {
      goto LABEL_6;
    }
    int v8 = *(unsigned __int8 **)(a2 + 40);
    int v9 = *(unsigned __int8 *)(a2 + 48);
    uint64_t v10 = 456LL;
    if (!*(_BYTE *)(a2 + 48)) {
      uint64_t v10 = 464LL;
    }
    *(void *)(a1 + v10) += (((*v8 << 16) | (v8[1] << 8) | v8[2]) - *(void *)(a1 + v10)) & 0xFFFFFF;
    if (v7 != 1)
    {
      uint64_t v11 = (((v8[3] << 16) | (v8[4] << 8) | v8[5]) - (_DWORD)v6) & 0xFFFFFF;
      uint64_t v12 = v6 + v11;
      *(void *)(a1 + 472) = v6 + v11;
      if (v7 >= 3)
      {
        int v19 = (v8[6] << 16) | (v8[7] << 8);
        int v20 = v8[8];
        BOOL v21 = v9 == 0;
        uint64_t v22 = 464LL;
        if (v21) {
          uint64_t v22 = 456LL;
        }
        *(void *)(a1 + v22) += ((v19 | v20) - *(void *)(a1 + v22)) & 0xFFFFFF;
      }
    }

    else
    {
LABEL_6:
      uint64_t v11 = 0LL;
      uint64_t v12 = v6;
    }

    int v13 = *(_DWORD *)(a1 + 420);
    unsigned int v14 = (a5 - (_BYTE)v13) & 7;
    if (a4 >= 8)
    {
      unint64_t v15 = v12 - v6;
      if (v15)
      {
        if (v15 >= (*(_DWORD *)(a1 + 196) * (a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7))) >> 1) {
          unsigned int v14 = a4 - (((_BYTE)a4 - (a5 - (_BYTE)v13)) & 7);
        }
      }
    }

    *(_DWORD *)(a1 + 420) = v14 + v13;
    *(_DWORD *)(a1 + 424) = v14;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      int v16 = *(_DWORD *)(a2 + 8);
      if (v16)
      {
        if (v16 - *(_DWORD *)(a1 + 400) >= 0) {
          *(_DWORD *)(a1 + 400) = v16;
        }
      }
    }

    if (v14)
    {
      *(_DWORD *)(a1 + 348) |= 0x20u;
      *(_DWORD *)(a1 + 292) += v14;
      uint64_t v17 = *(void *)(a1 + 1056);
      if (v17) {
        *(void *)(v17 + 880) += v14;
      }
      *(void *)(a1 + 384) = v14 + v13 - 5;
    }

    int v18 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)]
                                                                           + 104);
    if (v18) {
      v18(a1, a3, v11, *(unsigned int *)(a1 + 292), *(unsigned int *)(a1 + 296));
    }
    *(_BYTE *)(a1 + 428) |= 1u;
  }

uint64_t tcp_sbsnd_trim(uint64_t result)
{
  unsigned int v1 = (_DWORD *)result;
  int v2 = *(_DWORD *)(result + 48);
  if ((~v2 & 0xC00) == 0)
  {
    unsigned int v3 = *(_DWORD *)(result + 52);
    if (v3)
    {
      if (*(_DWORD *)(result + 4) > v3)
      {
        if (*(_DWORD *)result > v3) {
          unsigned int v3 = *(_DWORD *)result;
        }
        if (v3 <= 0x71C71C)
        {
          *(_DWORD *)(result + 4) = v3;
          uint64_t result = *(void *)(*(void *)(result + 72) + 24LL);
          if ((v2 & 4) != 0)
          {
            if (result)
            {
              uint64_t result = nw_protocol_tcp_get_all_stats();
              if (result) {
                *(_DWORD *)(result + 88) = v1[1];
              }
            }
          }

          else if (result)
          {
            uint64_t result = nw_protocol_tcp_get_all_stats();
            if (result) {
              *(_DWORD *)(result + 100) = v1[1];
            }
          }

          unsigned int v4 = v1[1];
          if (v1[2] > v4) {
            v1[2] = v4;
          }
        }
      }
    }
  }

  if (v1[1] <= v1[13]) {
    v1[12] &= ~0x800u;
  }
  return result;
}

uint64_t tcp_update_snd_una(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 92) = a2;
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 24LL);
  if (result)
  {
    uint64_t result = nw_protocol_tcp_get_all_stats();
    if (result) {
      *(_DWORD *)(result + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
    }
  }

  return result;
}

uint64_t tcp_bwmeas_check(uint64_t result)
{
  unsigned int v1 = *(_DWORD **)(result + 768);
  int v2 = *(_DWORD *)(result + 92) - *v1;
  if (v2 >= 1)
  {
    uint64_t v3 = result;
    if ((*(_BYTE *)(result + 740) & 4) != 0 && v2 >= v1[2])
    {
      uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224LL));
      unsigned int v4 = *(_DWORD **)(v3 + 768);
      unsigned int v5 = *(_DWORD *)(result + 316) - v4[1];
      if (v5 && v5 <= v2)
      {
        unsigned int v6 = v2 / v5;
        int v7 = v4[7];
        unsigned int v8 = v4[8];
        if (v7) {
          unsigned int v6 = (v6 - v7 + 8 * v7) >> 3;
        }
        if (v6 <= v8) {
          unsigned int v9 = v4[8];
        }
        else {
          unsigned int v9 = v6;
        }
        if (!v8) {
          unsigned int v9 = v6;
        }
        v4[7] = v6;
        v4[8] = v9;
      }

      *(_DWORD *)(v3 + 740) &= ~4u;
    }
  }

  return result;
}

uint64_t tcp_tfo_rcv_ack(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)(result + 993) == 1)
  {
    int v2 = (_DWORD *)result;
    if (*(_BYTE *)(result + 992))
    {
      int v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(result + 120);
      if (v3)
      {
        if (v3 >= 1)
        {
          *(_BYTE *)(result + 993) = 2;
          uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(result + 80) + 224LL));
          uint64_t v4 = v2[57];
          v2[10] = *(_DWORD *)(result + 316) - v2[16] + v4;
        }
      }

      else
      {
        *(_BYTE *)(result + 993) = 0;
      }
    }
  }

  return result;
}

uint64_t tcp_compute_rcv_rtt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !a3)
  {
    int v16 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    uint64_t v17 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result)
    {
      __break(1u);
      return result;
    }

    free(v17);
  }

  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  if ((*(_BYTE *)a2 & 1) != 0)
  {
    int v11 = *(_DWORD *)(a2 + 8);
    if (v11 && (int v12 = *(_DWORD *)(result + 316), v12 - v11 >= 0))
    {
      if (v12 == v11) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = v12 - v11;
      }
    }

    else
    {
      unsigned int v10 = 0;
    }
  }

  else
  {
    int v6 = *(_DWORD *)(a1 + 1972);
    if (v6)
    {
      int v7 = *(_DWORD *)(a1 + 120);
      if (v7 - *(_DWORD *)(a1 + 1976) < 0) {
        return result;
      }
      int v8 = *(_DWORD *)(result + 316);
      unsigned int v9 = v8 - v6;
      if (v9) {
        unsigned int v10 = v9;
      }
      else {
        unsigned int v10 = 1;
      }
    }

    else
    {
      int v8 = *(_DWORD *)(result + 316);
      int v7 = *(_DWORD *)(a1 + 120);
      unsigned int v10 = 100;
    }

    *(_DWORD *)(a1 + 1972) = v8;
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 128) + v7;
  }

  unsigned int v13 = *(_DWORD *)(a1 + 1968);
  unsigned int v14 = v13 + 4 * v10 - (v13 >> 3);
  if (v14 <= 1) {
    unsigned int v14 = 1;
  }
  if (v13) {
    int v15 = v14;
  }
  else {
    int v15 = 32 * v10;
  }
  *(_DWORD *)(a1 + 1968) = v15;
  *(_DWORD *)(a1 + 236) = v10;
  return update_base_rtt(a1, v10);
}

uint64_t tcp_sbrcv_grow(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 72);
  uint64_t result = nw_tcp_access_globals(v8);
  uint64_t v10 = result;
  if (*(_DWORD *)(sysctls + 68))
  {
    if ((*(_BYTE *)(a2 + 49) & 4) != 0)
    {
      unsigned int v11 = *(_DWORD *)(a2 + 4);
      unsigned int v12 = *(_DWORD *)(sysctls + 72);
      if (v11 < v12
        && (*(_BYTE *)(a1 + 741) & 1) == 0
        && (*(_BYTE *)(v8 + 368) & 0x40) == 0
        && (*(_DWORD *)(sysctls + 260) || !*(void *)a1))
      {
        if ((~*(_DWORD *)(a1 + 88) & 0x180) != 0)
        {
          int v25 = *(_DWORD *)(result + 316);
          int v26 = *(_DWORD *)(a1 + 180) + (*(_DWORD *)(a1 + 1968) >> 5);
          unsigned int v27 = *(_DWORD *)(a1 + 184) + a4;
          *(_DWORD *)(a1 + 184) = v27;
          if (v25 - v26 < 0) {
            return result;
          }
          unsigned int v28 = *(_DWORD *)(a1 + 188);
          if (v27 > v28)
          {
            char v29 = v27 <= v28 + (v28 >> 1) ? 1 : 2;
            unsigned int v30 = v27 << v29;
            int v31 = (v27 << v29) - v11;
            if (v31 >= 1)
            {
              uint64_t result = tcp_sbrcv_reserve( a1,  a2,  v11 + v31 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196),  v30,  v12);
              *(_DWORD *)(a1 + 188) = *(_DWORD *)(a1 + 184);
            }
          }
        }

        else
        {
          int v13 = *(_DWORD *)(a3 + 8);
          if (v13)
          {
            int v14 = *(_DWORD *)(a1 + 180);
            unsigned int v15 = *(_DWORD *)(a1 + 184) + a4;
            *(_DWORD *)(a1 + 184) = v15;
            if (v13 - v14 < 0) {
              return result;
            }
            unsigned int v16 = *(_DWORD *)(a1 + 188);
            if (v15 > v16)
            {
              char v17 = v15 <= v16 + (v16 >> 1) ? 1 : 2;
              unsigned int v18 = v15 << v17;
              int v19 = (v15 << v17) - v11;
              *(_DWORD *)(a1 + 188) = v15;
              if (v19 >= 1) {
                uint64_t result = tcp_sbrcv_reserve( a1,  a2,  v11 + v19 / *(_DWORD *)(a1 + 196) * *(_DWORD *)(a1 + 196),  v18,  v12);
              }
            }

            uint64_t v20 = *(void *)(a1 + 768);
            if (v20)
            {
              unsigned int v21 = *(_DWORD *)(a1 + 184);
              if (v21)
              {
                int v22 = *(_DWORD *)(v10 + 316) - *(_DWORD *)(a1 + 180);
                if (v22 >= 1)
                {
                  unsigned int v23 = *(_DWORD *)(v20 + 36);
                  unsigned int v24 = v21 / v22;
                  if (v23)
                  {
                    if (v23 > v24) {
                      unsigned int v24 = *(_DWORD *)(v20 + 36);
                    }
                  }

                  *(_DWORD *)(v20 + 36) = v24;
                }
              }
            }
          }
        }
      }
    }
  }

  *(void *)(a1 + 180) = *(unsigned int *)(v10 + 316);
  return result;
}

void *tcp_input_sbappendstream(uint64_t a1, uint64_t *a2, signed int a3, char a4)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  uint64_t v8 = *a2;
  if (*a2)
  {
    int v9 = 0;
    uint64_t v10 = *a2;
    do
    {
      int v11 = *(_DWORD *)(v10 + 52);
      if (v11) {
        v11 -= *(_DWORD *)(v10 + 56) + *(_DWORD *)(v10 + 60);
      }
      v9 += v11;
      uint64_t v10 = *(void *)(v10 + 32);
    }

    while (v10);
  }

  else
  {
    int v9 = 0;
  }

  if (v9 != a3 && (!a1 || (*(_BYTE *)(a1 + 828) & 2) == 0))
  {
    __nwlog_tcp_log();
    if (a1) {
      unsigned int v12 = (const char *)(a1 + 604);
    }
    else {
      unsigned int v12 = "";
    }
    uint64_t v13 = *a2;
    if (*a2)
    {
      int v14 = 0;
      do
      {
        int v15 = *(_DWORD *)(v13 + 52);
        if (v15) {
          v15 -= *(_DWORD *)(v13 + 56) + *(_DWORD *)(v13 + 60);
        }
        v14 += v15;
        uint64_t v13 = *(void *)(v13 + 32);
      }

      while (v13);
    }

    else
    {
      int v14 = 0;
    }

    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v60 = "tcp_input_sbappendstream";
    __int16 v61 = 2082;
    uint64_t v62 = v12;
    __int16 v63 = 1024;
    signed int v64 = a3;
    __int16 v65 = 1024;
    int v66 = v14;
    unsigned int v16 = (void *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v17 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        uint64_t v19 = *a2;
        if (*a2)
        {
          int v20 = 0;
          do
          {
            int v21 = *(_DWORD *)(v19 + 52);
            if (v21) {
              v21 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
            }
            v20 += v21;
            uint64_t v19 = *(void *)(v19 + 32);
          }

          while (v19);
        }

        else
        {
          int v20 = 0;
        }

        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        uint64_t v62 = v12;
        __int16 v63 = 1024;
        signed int v64 = a3;
        __int16 v65 = 1024;
        int v66 = v20;
        int v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u";
LABEL_37:
        _os_log_impl(&dword_1879E5000, v17, v18, v25, buf, 0x22u);
      }
    }

    else
    {
      char v17 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        uint64_t v22 = *a2;
        if (*a2)
        {
          int v23 = 0;
          do
          {
            int v24 = *(_DWORD *)(v22 + 52);
            if (v24) {
              v24 -= *(_DWORD *)(v22 + 56) + *(_DWORD *)(v22 + 60);
            }
            v23 += v24;
            uint64_t v22 = *(void *)(v22 + 32);
          }

          while (v22);
        }

        else
        {
          int v23 = 0;
        }

        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        uint64_t v62 = v12;
        __int16 v63 = 1024;
        signed int v64 = a3;
        __int16 v65 = 1024;
        int v66 = v23;
        int v25 = "%{public}s %{public}s tlen %d != __nw_frame_array_unclaimed_length() %u, backtrace limit exceeded";
        goto LABEL_37;
      }
    }

LABEL_38:
    if (v16) {
      free(v16);
    }
    uint64_t v8 = *a2;
  }

  *(void *)os_log_type_t type = 0LL;
  __int16 v56 = type;
  if ((a4 & 2) != 0 && !*(_DWORD *)(a1 + 824))
  {
    uint64_t v26 = nw_protocol_tcp_copy_frame(a1, v8, a3);
    if (v26)
    {
      a4 &= ~2u;
      *(void *)(v26 + 32) = 0LL;
      unsigned int v27 = v56;
      *(void *)(v26 + 40) = v56;
      *unsigned int v27 = v26;
      __int16 v56 = (os_log_type_t *)(v26 + 32);
      goto LABEL_47;
    }

    uint64_t v39 = *(void *)(*(void *)a1 + 240LL);
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      int v40 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v60 = "tcp_input_sbappendstream";
        __int16 v61 = 2082;
        uint64_t v62 = (const char *)(a1 + 604);
        _os_log_impl( &dword_1879E5000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s nw_protocol_tcp_copy_frame failed",  buf,  0x16u);
      }
    }

    if (v8)
    {
      if ((*(_WORD *)(v8 + 204) & 0x100) == 0
        || !*MEMORY[0x189608EF8]
        || (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v8, *(void *)(v8 + 88)) & 1) != 0)
      {
        goto LABEL_79;
      }

      goto LABEL_78;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v60 = "__nw_frame_check_validity";
    uint64_t v41 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t v58 = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault())
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v42 = (os_log_s *)__nwlog_obj();
        os_log_type_t v43 = v58;
        if (!os_log_type_enabled(v42, v58)) {
          goto LABEL_94;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame";
        goto LABEL_93;
      }

      if (!v57)
      {
        uint64_t v42 = (os_log_s *)__nwlog_obj();
        os_log_type_t v43 = v58;
        if (!os_log_type_enabled(v42, v58)) {
          goto LABEL_94;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_93;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v42 = (os_log_s *)__nwlog_obj();
      os_log_type_t v43 = v58;
      BOOL v46 = os_log_type_enabled(v42, v58);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v60 = "__nw_frame_check_validity";
          __int16 v61 = 2082;
          uint64_t v62 = backtrace_string;
          _os_log_impl( &dword_1879E5000,  v42,  v43,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_94;
      }

      if (v46)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v60 = "__nw_frame_check_validity";
        uint64_t v44 = "%{public}s called with null frame, no backtrace";
LABEL_93:
        _os_log_impl(&dword_1879E5000, v42, v43, v44, buf, 0xCu);
      }
    }

          int v24 = v21 + v7;
          if ((v6 & 2) != 0) {
            int v23 = v13[38];
          }
          else {
            int v23 = v13[37];
          }
          if (v24 < v23) {
            LODWORD(v23) = v24;
          }
LABEL_43:
          *(_DWORD *)(a1 + 156) = v12;
          if ((*(_DWORD *)(a1 + 88) & 0x100) != 0 || a2 == -1) {
            uint64_t v26 = v12 - 12;
          }
          else {
            uint64_t v26 = v12;
          }
          if ((*(_DWORD *)(a1 + 88) & 0x88) == 0x80) {
            unsigned int v27 = v26;
          }
          else {
            unsigned int v27 = v12;
          }
          *(_DWORD *)(a1 + 196) = v27;
          unsigned int v28 = v18 + 14;
          char v29 = (_DWORD *)(v11 + 388);
          if (v19) {
            unsigned int v28 = (unsigned int *)(v11 + 388);
          }
          unsigned int v30 = *v28;
          if (v30 <= *(_DWORD *)(v11 + 388)) {
            int v31 = *(_DWORD *)(v11 + 388);
          }
          else {
            int v31 = v30;
          }
          uint64_t v32 = v31;
          if (v31 >= v27)
          {
            uint64_t v32 = (v27 + v31 - 1) / v27 * v27;
            if (v32 <= 0x71C71C)
            {
              *(_DWORD *)(v11 + 388) = v32;
              uint64_t v33 = *(void *)(*(void *)(v11 + 456) + 24LL);
              if ((*(_BYTE *)(v11 + 432) & 4) != 0)
              {
                if (v33)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *v29;
                  }
                }
              }

              else if (v33)
              {
                uint64_t v34 = nw_protocol_tcp_get_all_stats();
                if (v34) {
                  *(_DWORD *)(v34 + 100) = *v29;
                }
              }

              uint64_t v41 = *(_DWORD *)(v11 + 388);
              if (*(_DWORD *)(v11 + 392) > v41) {
                *(_DWORD *)(v11 + 392) = v41;
              }
            }

            int v31 = v27;
          }

          *(_DWORD *)(a1 + 196) = v31;
          if (!v31)
          {
            uint64_t v62 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
            __int16 v63 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort())
            {
              __break(1u);
              return;
            }

            free(v63);
          }

          uint64_t v42 = *(void *)(*(void *)v11 + 240LL);
          if (*(unsigned __int8 *)(v10 + 1076) != 255 && *(_DWORD *)(v10 + 1024) != 255
            || *(int *)(v42 + 12) > 5
            || (*(_BYTE *)(v42 + 91) & 0x20) != 0
            || (*(_BYTE *)(v10 + 9) & 0x80) == 0)
          {
            goto LABEL_108;
          }

          os_log_type_t v43 = *(_DWORD *)(v42 + 156);
          uint64_t v44 = *(_DWORD *)(v42 + 196) - v43;
          unsigned int v45 = *(unsigned __int16 *)(v10 + 72);
          if (v45 == 1200)
          {
            if (v43 <= 0x4B0) {
              goto LABEL_106;
            }
            BOOL v46 = 1200;
          }

          else
          {
            if (v45 != 512)
            {
              if (*(_WORD *)(v10 + 72)
                || (BOOL v46 = *(unsigned __int16 *)(v42 + 734), !*(_WORD *)(v42 + 734))
                || v43 >= v46)
              {
LABEL_106:
                *(_DWORD *)(v42 + 196) = v44 + v43;
LABEL_108:
                unsigned int v52 = *(_DWORD *)(v11 + 492);
                if (v32 > v52) {
                  unsigned int v52 = v32;
                }
                if (v52 > v31)
                {
                  uint32_t v53 = (v31 + (unint64_t)v52 - 1) / v31 * v31;
                  if (v53 <= 0x71C71C)
                  {
                    *(_DWORD *)(v11 + 492) = v53;
                    int v54 = *(void *)(*(void *)(v11 + 560) + 24LL);
                    if ((*(_BYTE *)(v11 + 536) & 4) != 0)
                    {
                      if (v54)
                      {
                        __int16 v56 = nw_protocol_tcp_get_all_stats();
                        if (v56) {
                          *(_DWORD *)(v56 + 88) = *(_DWORD *)(v11 + 492);
                        }
                      }
                    }

                    else if (v54)
                    {
                      unsigned int v55 = nw_protocol_tcp_get_all_stats();
                      if (v55) {
                        *(_DWORD *)(v55 + 100) = *(_DWORD *)(v11 + 492);
                      }
                    }

                    char v57 = *(_DWORD *)(v11 + 492);
                    if (*(_DWORD *)(v11 + 496) > v57) {
                      *(_DWORD *)(v11 + 496) = v57;
                    }
                  }
                }

                set_tcp_stream_priority(v11);
                os_log_type_t v58 = *(void *)(v9 + 1488);
                if (v58 && (uint64_t v59 = *(unsigned int *)(v58 + 60), (_DWORD)v59))
                {
                  *(_DWORD *)(a1 + 148) = v59;
                  uint64_t v60 = *(void *)(a1 + 1056);
                  if (v60) {
                    ++*(void *)(v60 + 1296);
                  }
                }

                else
                {
                  *(_DWORD *)(a1 + 148) = 1073725440;
                }

                __int16 v61 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
                if (v61) {
                  v61(a1);
                }
                if (*(_DWORD *)(sysctls + 308) == 1
                  && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
                  && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v11 + 369) & 0x40) != 0))
                {
                  if (off_18C4CE828) {
                    off_18C4CE828((_DWORD *)a1);
                  }
                }

                return;
              }

LABEL_69:
    if (v54) {
      free(v54);
    }
    goto LABEL_53;
  }

  return result;
}

uint64_t tcp_adaptive_rwtimo_check(uint64_t result, int a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)(result + 80);
  if (*(_BYTE *)(result + 265))
  {
    if (a2 < 1) {
      return result;
    }
  }

  else
  {
    uint64_t v4 = *(void *)(v3 + 448);
    if (!v4 || a2 < 1 || (*(_DWORD *)(v4 + 1052) & 8) == 0) {
      return result;
    }
  }

  if (*(_DWORD *)(result + 12) == 4)
  {
    uint64_t result = nw_tcp_access_globals(*(void *)(v3 + 224));
    uint64_t v5 = *(unsigned int *)(v2 + 228);
    *(_DWORD *)(v2 + 40) = *(_DWORD *)(result + 316) - *(_DWORD *)(v2 + 64) + 2 * v5;
    *(_DWORD *)(v2 + 740) |= 0x80u;
    *(_BYTE *)(v2 + 311) = 0;
  }

  return result;
}

uint64_t tcp_tfo_syn(uint64_t a1, uint64_t a2)
{
  __s1[2] = *MEMORY[0x1895F89C0];
  if ((*(_DWORD *)a2 & 0xC00) == 0 || (*(_BYTE *)(sysctls + 160) & 1) == 0) {
    return 0LL;
  }
  if ((*(_DWORD *)a2 & 0x800) != 0)
  {
    *(_BYTE *)(a1 + 988) |= 1u;
    *(_WORD *)(a1 + 990) |= 2u;
    uint64_t v8 = *(void *)(a1 + 1056);
    if (!v8) {
      return 0LL;
    }
    uint64_t result = 0LL;
    ++*(void *)(v8 + 1088);
  }

  else
  {
    tcp_tfo_gen_cookie(*(void *)(a1 + 80), __s1);
    uint64_t v5 = *(char **)(a2 + 24);
    char v6 = *v5++;
    *(void *)(a2 + 24) = v5;
    if (memcmp(__s1, v5, (v6 - 2)))
    {
      *(_BYTE *)(a1 + 988) |= 1u;
      *(_WORD *)(a1 + 990) |= 8u;
      uint64_t v7 = *(void *)(a1 + 1056);
      if (v7)
      {
        uint64_t result = 0LL;
        ++*(void *)(v7 + 1096);
        return result;
      }

      return 0LL;
    }

    do
    {
      unsigned int v9 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
      signed int v10 = v9 + 1;
    }

    while (__stxr(v10, (unsigned int *)&tcp_tfo_halfcnt));
    if (v10 >= *(_DWORD *)(sysctls + 156))
    {
      uint64_t result = 0LL;
      do
        unsigned int v12 = __ldxr((unsigned int *)&tcp_tfo_halfcnt);
      while (__stxr(v12 - 1, (unsigned int *)&tcp_tfo_halfcnt));
    }

    else
    {
      *(_BYTE *)(a1 + 988) |= 2u;
      *(_WORD *)(a1 + 990) |= 1u;
      uint64_t v11 = *(void *)(a1 + 1056);
      if (v11) {
        ++*(void *)(v11 + 1080);
      }
      return 1LL;
    }
  }

  return result;
}

int64x2_t tcp_input_process_accecn_syn(int64x2_t *a1, int a2, int a3)
{
  if (a2 == 448)
  {
    __int32 v3 = a1[46].i32[1];
    if ((v3 & 0x10000000) == 0
      && ((v3 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v4 = tcp_do_acc_ecn == 1) : (BOOL v4 = 1), v4)))
    {
      switch(a3)
      {
        case 0:
LABEL_22:
          int v7 = a1[21].i32[3] | 0x10000;
          break;
        case 1:
LABEL_24:
          int v7 = a1[21].i32[3] | 0x20000;
          break;
        case 2:
LABEL_25:
          int v7 = a1[21].i32[3] | 0x40000;
          break;
        case 3:
LABEL_26:
          int v7 = a1[21].i32[3] | 0x80000;
          break;
        default:
LABEL_23:
          int v7 = a1[21].i32[3];
          break;
      }

      int64x2_t result = vdupq_n_s64(1uLL);
      a1[21].i32[3] = v7 | 0x200000;
      a1[27] = result;
      a1[28].i64[1] = 1LL;
      a1[29].i64[0] = 1LL;
      a1[22].i32[3] = 5;
    }

    else
    {
      a1[21].i32[3] |= 6u;
    }
  }

  else if (a2 == 192)
  {
    a1[21].i32[3] |= 6u;
    a1[22].i32[3] = 4;
  }

  else if (a2)
  {
    __int32 v5 = a1[46].i32[1];
    if ((v5 & 0x10000000) == 0)
    {
      if ((v5 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v6 = tcp_do_acc_ecn == 1) : (BOOL v6 = 1), v6))
      {
        switch(a3)
        {
          case 0:
            goto LABEL_22;
          case 1:
            goto LABEL_24;
          case 2:
            goto LABEL_25;
          case 3:
            goto LABEL_26;
          default:
            goto LABEL_23;
        }
      }
    }
  }

  else
  {
    a1[22].i32[3] = 3;
  }

  return result;
}

uint64_t tcp_sbrcv_tstmp_check(uint64_t result)
{
  if ((~*(_DWORD *)(result + 88) & 0x180) != 0)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(*(void *)(result + 80) + 224LL);
    int v3 = *(_DWORD *)(v2 + 536);
    if ((v3 & 0x400) != 0)
    {
      unsigned int v4 = 2 * *(_DWORD *)(sysctls + 236);
      char v5 = *(_BYTE *)(result + 261);
      uint64_t v6 = 0xFFFFLL << v5;
      int v7 = 0xFFFF << v5;
      unsigned int v8 = v6 <= v4 ? v7 : 2 * *(_DWORD *)(sysctls + 236);
      if (v8 > *(_DWORD *)(v2 + 492) && v8 <= 0x71C71C)
      {
        *(_DWORD *)(v2 + 492) = v8;
        int64x2_t result = *(void *)(*(void *)(v2 + 560) + 24LL);
        if ((v3 & 4) != 0)
        {
          if (result)
          {
            int64x2_t result = nw_protocol_tcp_get_all_stats();
            if (result) {
              *(_DWORD *)(result + 88) = *(_DWORD *)(v2 + 492);
            }
          }
        }

        else if (result)
        {
          int64x2_t result = nw_protocol_tcp_get_all_stats();
          if (result) {
            *(_DWORD *)(result + 100) = *(_DWORD *)(v2 + 492);
          }
        }

        unsigned int v10 = *(_DWORD *)(v2 + 492);
        if (*(_DWORD *)(v2 + 496) > v10) {
          *(_DWORD *)(v2 + 496) = v10;
        }
        LODWORD(v11) = *(_DWORD *)(v2 + 540);
        else {
          uint64_t v11 = v11;
        }
        char v12 = *(_BYTE *)(v1 + 261);
        uint64_t v13 = 0xFFFFLL << v12;
        int v14 = 0xFFFF << v12;
        if (v13 <= v11) {
          LODWORD(v11) = v14;
        }
        *(_DWORD *)(v2 + 540) = v11;
      }
    }
  }

  return result;
}

uint64_t tcp_tfo_synack(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a2 + 1) & 4) != 0)
  {
    uint64_t v11 = *(unsigned __int8 **)(a2 + 24);
    unsigned int v12 = *v11 - 2;
    if (v12 >= 0x11)
    {
      unsigned int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_tfo_synack";
      char v29 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }

      free(v29);
      uint64_t v11 = *(unsigned __int8 **)(a2 + 24);
    }

    *(void *)(a2 + 24) = v11 + 1;
    uint64_t v13 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    __memcpy_chk();
    buf[16] = v12;
    (*(void (**)(void, uint8_t *))(*(void *)(v13 + 2136) + 56LL))(*(void *)(v13 + 224), buf);
    uint64_t v14 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    __int16 v15 = *(_WORD *)(a1 + 990);
    if ((v15 & 0x40) != 0)
    {
      buf[17] = 1;
      uint8_t v16 = 9;
      if ((v15 & 0x10) == 0) {
        goto LABEL_26;
      }
    }

    else
    {
      uint8_t v16 = 8;
      if ((v15 & 0x10) == 0)
      {
LABEL_26:
        uint64_t result = (*(uint64_t (**)(void, uint8_t *))(*(void *)(v14 + 2136) + 56LL))( *(void *)(v14 + 224),  buf);
        __int16 v22 = *(_WORD *)(a1 + 990);
        *(_WORD *)(a1 + 990) = v22 | 0x20;
        uint64_t v23 = *(void *)(a1 + 1056);
        if (v23)
        {
          ++*(void *)(v23 + 1112);
          if ((*(_BYTE *)(a1 + 988) & 8) == 0) {
            return result;
          }
          ++*(void *)(v23 + 1152);
        }

        else if ((*(_BYTE *)(a1 + 988) & 8) == 0)
        {
          return result;
        }

        *(_WORD *)(a1 + 990) = v22 | 0x220;
        return result;
      }
    }

    buf[17] = v16;
    goto LABEL_26;
  }

  if ((*(_BYTE *)(a1 + 743) & 1) != 0 || (*(_BYTE *)(a1 + 988) & 0x10) == 0)
  {
    __int16 v17 = *(_WORD *)(a1 + 990);
    if ((*(_BYTE *)(a1 + 988) & 4) != 0)
    {
      v17 |= 0x400u;
      *(_WORD *)(a1 + 990) = v17;
      uint64_t v18 = *(void *)(a1 + 1056);
      if (v18) {
        ++*(void *)(v18 + 1160);
      }
    }

    uint64_t v19 = *(void *)(a1 + 80);
    memset(buf, 0, 18);
    if ((v17 & 0x40) != 0)
    {
      buf[17] = 1;
      uint8_t v20 = 9;
      if ((v17 & 0x10) == 0) {
        return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56LL))( *(void *)(v19 + 224),  buf);
      }
    }

    else
    {
      uint8_t v20 = 8;
      if ((v17 & 0x10) == 0) {
        return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56LL))( *(void *)(v19 + 224),  buf);
      }
    }

    buf[17] = v20;
    return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v19 + 2136) + 56LL))(*(void *)(v19 + 224), buf);
  }

  *(_WORD *)(a1 + 990) |= 0x100u;
  uint64_t v3 = *(void *)(a1 + 1056);
  if (v3) {
    ++*(void *)(v3 + 1136);
  }
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  if (tcp_perf_measurement)
  {
    if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v6 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          int v7 = "";
          if (v5) {
            int v7 = (const char *)(v5 + 604);
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_heuristic_tfo_loss";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v7;
          unsigned int v8 = v6;
          os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
LABEL_40:
          _os_log_impl(&dword_1879E5000, v8, v9, "%{public}s %{public}s ", buf, 0x16u);
        }
      }
    }
  }

  else if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
  {
    int v24 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      int v25 = "";
      if (v5) {
        int v25 = (const char *)(v5 + 604);
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "tcp_heuristic_tfo_loss";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v25;
      unsigned int v8 = v24;
      os_log_type_t v9 = OS_LOG_TYPE_INFO;
      goto LABEL_40;
    }
  }

  memset(buf, 0, 18);
  __int16 v26 = *(_WORD *)(a1 + 990);
  if ((v26 & 0x40) == 0)
  {
    uint8_t v27 = 16;
    if ((v26 & 0x10) == 0) {
      return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v4 + 2136) + 56LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  buf);
    }
    goto LABEL_45;
  }

  buf[17] = 2;
  uint8_t v27 = 18;
  if ((v26 & 0x10) != 0) {
LABEL_45:
  }
    buf[17] = v27;
  return (*(uint64_t (**)(void, uint8_t *))(*(void *)(v4 + 2136) + 56LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  buf);
}

void tcp_tfo_rcv_probe(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    *(_BYTE *)(a1 + 993) = 1;
    int v3 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
    uint64_t v4 = *(unsigned int *)(a1 + 228);
    *(_DWORD *)(a1 + 40) = v3 - *(_DWORD *)(a1 + 64) + v4;
    uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 224LL);
    if (!v5 || (*(_BYTE *)(v5 + 828) & 2) == 0)
    {
      uint64_t v6 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = "";
        if (v5) {
          int v7 = (const char *)(v5 + 604);
        }
        int v8 = *(_DWORD *)(a1 + 40);
        unsigned int v9 = *(_DWORD *)(a1 + 1872) - 1;
        if (v9 > 2) {
          unsigned int v10 = "invalid";
        }
        else {
          unsigned int v10 = off_18A0EEAF8[v9];
        }
        int v11 = *(_DWORD *)(a1 + 240);
        int v12 = *(_DWORD *)(a1 + 200);
        int v13 = *(_DWORD *)(a1 + 204);
        int v15 = *(_DWORD *)(a1 + 208);
        int v14 = *(_DWORD *)(a1 + 212);
        int v16 = 136449282;
        __int16 v17 = "tcp_tfo_rcv_probe";
        __int16 v18 = 2082;
        uint64_t v19 = v7;
        __int16 v20 = 1024;
        int v21 = v8;
        __int16 v22 = 2082;
        uint64_t v23 = v10;
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        int v27 = v12 >> 5;
        __int16 v28 = 1024;
        int v29 = ((1000 * v12) >> 5) % 1000;
        __int16 v30 = 1024;
        int v31 = v15 >> 4;
        __int16 v32 = 1024;
        int v33 = ((1000 * v15) >> 4) % 1000;
        __int16 v34 = 1024;
        int v35 = v13 >> 5;
        __int16 v36 = 1024;
        int v37 = ((1000 * v13) >> 5) % 1000;
        __int16 v38 = 1024;
        int v39 = v14 >> 4;
        __int16 v40 = 1024;
        int v41 = ((1000 * v14) >> 4) % 1000;
        _os_log_impl( &dword_1879E5000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s UTCPT_KEEP: %u RTT_Cache: %{public}s, rtt_upd: %d, rtt: %u.%03ums, rtt_var: %u.%03ums rt t_nc: %u.%03ums, rtt_var_nc: %u.%03ums",  (uint8_t *)&v16,  0x5Cu);
      }
    }
  }

uint64_t tcp_is_ack_ratelimited(uint64_t a1)
{
  int v2 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
  int v3 = *(_DWORD *)(a1 + 1044);
  if (!v3 || v2 - v3 >= 1000)
  {
    *(_DWORD *)(a1 + 1044) = v2;
    int v5 = 1;
    goto LABEL_6;
  }

  unsigned int v4 = *(_DWORD *)(a1 + 1048);
  if (v4 < *(_DWORD *)(sysctls + 248))
  {
    int v5 = v4 + 1;
LABEL_6:
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 1048) = v5;
    return result;
  }

  return 1LL;
}

uint64_t tcp_early_rexmt_check(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(*(void *)(result + 80) + 224LL);
  int v3 = *(_DWORD *)(result + 740);
  int v5 = *(_DWORD *)(result + 92);
  int v4 = *(_DWORD *)(result + 96);
  uint64_t result = (v4 - v5);
  if (*(_DWORD *)(v1 + 8) == 1)
  {
    if ((v3 & 0x20400020) != 0x20000020 && ((v3 & 0x20) == 0 || !*(void *)(v1 + 544))) {
      goto LABEL_12;
    }
  }

  else if ((v3 & 0x20) == 0 || !*(void *)(v1 + 544))
  {
    goto LABEL_33;
  }

  uint64_t result = tcp_flight_size((_DWORD *)v1);
  int v5 = *(_DWORD *)(v1 + 92);
  int v4 = *(_DWORD *)(v1 + 96);
LABEL_12:
  unsigned int v6 = *(_DWORD *)(v1 + 140);
  if (*(_DWORD *)(v2 + 384) < v6) {
    unsigned int v6 = *(_DWORD *)(v2 + 384);
  }
  unsigned int v7 = *(_DWORD *)(v1 + 196);
  if (result < 4 * v7 && (int)(v5 - v4 + v6) <= 0)
  {
    unsigned int v8 = result / v7;
    if (v8 <= 3)
    {
      unsigned int v9 = v8 - 1;
      if (v9 <= 1) {
        LOBYTE(v9) = 1;
      }
      *(_BYTE *)(v1 + 310) = v9;
      if (!*(_WORD *)(v1 + 268))
      {
        uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(v1 + 80) + 224LL));
        *(_DWORD *)(v1 + 272) = *(_DWORD *)(result + 316);
      }

      uint64_t v10 = *(void *)(v1 + 1056);
      if ((*(_BYTE *)(v1 + 741) & 0x10) != 0)
      {
        if (v10) {
          ++*(void *)(v10 + 744);
        }
      }

      else
      {
        if (v10) {
          ++*(void *)(v10 + 696);
        }
        ++*(_WORD *)(v1 + 268);
      }
    }
  }

uint64_t tcp_update_window(uint64_t a1, char a2, uint64_t a3, unsigned int a4, int a5)
{
  if ((a2 & 0x10) == 0) {
    return 0LL;
  }
  int v8 = *(_DWORD *)(a1 + 104);
  int v9 = *(_DWORD *)(a3 + 4);
  if (v8 - v9 >= 0)
  {
    if (v8 != v9) {
      return 0LL;
    }
    int v10 = *(_DWORD *)(a1 + 108);
    int v11 = *(_DWORD *)(a3 + 8);
    if (v10 - v11 >= 0 && (v10 != v11 || *(_DWORD *)(a1 + 140) >= a4)) {
      return 0LL;
    }
  }

  if (!a5 && *(_DWORD *)(a1 + 108) == *(_DWORD *)(a3 + 8) && *(_DWORD *)(a1 + 140) < a4)
  {
    uint64_t v12 = *(void *)(a1 + 1056);
    if (v12) {
      ++*(void *)(v12 + 296);
    }
  }

  *(_DWORD *)(a1 + 140) = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 24LL))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    a4 = *(_DWORD *)(a1 + 140);
    if (all_stats)
    {
      *(_DWORD *)(all_stats + 112) = a4;
      a4 = *(_DWORD *)(a1 + 140);
    }
  }

  *(void *)(a1 + 104) = *(void *)(a3 + 4);
  if (a4 > *(_DWORD *)(a1 + 252)) {
    *(_DWORD *)(a1 + 252) = a4;
  }
  return 1LL;
}

uint64_t tcp_newreno_partial_ack(_DWORD *a1, uint64_t a2)
{
  int v4 = a1[25];
  unsigned int v5 = a1[36];
  a1[7] = 0;
  a1[4] = 0;
  a1[43] = 0;
  int v6 = *(_DWORD *)(a2 + 8);
  a1[25] = v6;
  a1[36] = a1[49] + v6 - a1[23];
  uint64_t result = tcp_output((uint64_t)a1);
  if (v4 - a1[25] >= 1) {
    a1[25] = v4;
  }
  unsigned int v8 = *(_DWORD *)(a2 + 8) - a1[23];
  BOOL v9 = v5 >= v8;
  unsigned int v10 = v5 - v8;
  if (!v9) {
    unsigned int v10 = 0;
  }
  a1[36] = v10 + a1[49];
  return result;
}

uint64_t tcp_reass(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4, unsigned int a5, _BYTE *a6, _DWORD *a7)
{
  uint64_t v202 = *MEMORY[0x1895F89C0];
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 224LL);
  uint64_t v182 = *(void *)(a1 + 80);
  if (!a4)
  {
    int type = 0;
    int v184 = 0;
    BOOL v185 = 0;
    goto LABEL_10;
  }

  if (*(unsigned __int8 *)(a4 + 1076) == 255 || *(_DWORD *)(a4 + 1024) == 255)
  {
    int v12 = 1;
  }

  else
  {
    if (*(_DWORD *)(a4 + 1068) == 3)
    {
      BOOL v185 = 0;
      int type = 1;
      int v184 = 0;
      goto LABEL_10;
    }

    int v12 = 0;
    if (*(_DWORD *)(a4 + 1032) == 3)
    {
      int type = 1;
      int v184 = 0;
      BOOL v185 = 0;
      goto LABEL_10;
    }
  }

  int v184 = v12;
  int type = 0;
  BOOL v13 = *(_DWORD *)(a4 + 1064) == 2 || *(_DWORD *)(a4 + 1028) == 2;
  BOOL v185 = v13;
LABEL_10:
  uint64_t v188 = nw_tcp_access_globals(v11);
  if (a7) {
    *a7 = 0;
  }
  uint64_t v186 = *a3;
  uint64_t v190 = nw_protocol_tcp_copy_frame(v11, *a3, *a2 + a5);
  uint64_t v14 = *a3;
  uint64_t v192 = v11;
  int v191 = a2;
  if (!*a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
    int v156 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v161 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
        _os_log_impl( &dword_1879E5000,  v161,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v156)
    {
      free(v156);
      if (!a5) {
        goto LABEL_47;
      }
LABEL_19:
      uint64_t v20 = *a3;
      if (!*a3) {
        goto LABEL_43;
      }
      goto LABEL_20;
    }

LABEL_18:
    if (!a5) {
      goto LABEL_47;
    }
    goto LABEL_19;
  }

  if ((*(_WORD *)(v14 + 204) & 0x80) == 0) {
    goto LABEL_18;
  }
  unsigned int v15 = *(unsigned __int16 *)(v14 + 196);
  BOOL v16 = v15 >= a5;
  __int16 v17 = v15 - a5;
  if (v16)
  {
    *(_WORD *)(v14 + 196) = v17;
    goto LABEL_18;
  }

  __nwlog_obj();
  int v18 = *(unsigned __int16 *)(v14 + 196);
  *(_DWORD *)__int128 buf = 136446722;
  uint64_t v195 = "__nw_frame_array_claim";
  __int16 v196 = 1024;
  *(_DWORD *)uint64_t v197 = v18;
  *(_WORD *)&v197[4] = 1024;
  *(_DWORD *)&v197[6] = a5;
  uint64_t v19 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    __int16 v30 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v31 = *(unsigned __int16 *)(v14 + 196);
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v195 = "__nw_frame_array_claim";
      __int16 v196 = 1024;
      *(_DWORD *)uint64_t v197 = v31;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = a5;
      _os_log_impl( &dword_1879E5000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded",  buf,  0x18u);
    }
  }

  if (v19) {
    free(v19);
  }
  *(_WORD *)(v14 + 196) = 0;
  uint64_t v20 = *a3;
  if (!*a3)
  {
LABEL_43:
    unsigned int v21 = 0;
LABEL_44:
    if (v21 != a5)
    {
      __int16 v32 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v195 = "__nw_frame_array_claim";
        __int16 v196 = 1024;
        *(_DWORD *)uint64_t v197 = v21;
        *(_WORD *)&v197[4] = 1024;
        *(_DWORD *)&v197[6] = a5;
        _os_log_impl( &dword_1879E5000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s start_offset %u != start_bytes %u",  buf,  0x18u);
      }
    }

    goto LABEL_47;
  }

    BOOL v16 = *(void **)(a1 + 952);
    if (v16)
    {
      __int16 v17 = (void *)(a1 + 952);
      do
      {
        uint64_t v19 = (void *)*v17;
        uint64_t v20 = (void *)(a1 + 952);
        if ((void *)*v17 != v16)
        {
          do
          {
            unsigned int v21 = v19;
            uint64_t v19 = (void *)v19[2];
          }

          while (v19 != v16);
          uint64_t v20 = v21 + 2;
        }

        int v18 = (void *)v16[2];
        *uint64_t v20 = v18;
        nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
        free(v16);
        BOOL v16 = v18;
      }

      while (v18);
      *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
    }

    goto LABEL_25;
  }

  int v4 = *(_DWORD *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 96) - v4;
  int v6 = v4 - *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a1 + 508);
  unsigned int v7 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v7) {
    v7(a1);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 144);
  if (v6 < v8) {
    unsigned int v8 = v6;
  }
  BOOL v9 = v5 + v8;
LABEL_26:
  int v22 = sysctls;
  if (*(_DWORD *)(sysctls + 304))
  {
    int v23 = *(_DWORD *)(a1 + 196) * *(_DWORD *)(sysctls + 16);
    if (v9 > v23) {
      goto LABEL_34;
    }
LABEL_31:
    BOOL v9 = v23;
    goto LABEL_34;
  }

  if (*(_DWORD *)(sysctls + 276))
  {
    int v23 = 10 * *(_DWORD *)(a1 + 196);
    if (v9 > v23) {
      goto LABEL_34;
    }
    goto LABEL_31;
  }

  if (v9 <= 0x111C) {
    BOOL v9 = 4380;
  }
LABEL_34:
  *(_DWORD *)(a1 + 144) = v9;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 512);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 96);
  int v24 = *(void *)(*(void *)(a1 + 80) + 224LL);
  unsigned int v25 = *(_DWORD *)(v24 + 432);
  if ((~v25 & 0xC00) == 0)
  {
    unsigned int v26 = *(int *)(v22 + 232);
    int v27 = *(_DWORD *)(v22 + 120);
    *(_DWORD *)(v24 + 436) = v27;
    if (*(_DWORD *)(v24 + 388) <= v27)
    {
      if (v27 <= 0x71C71C)
      {
        *(_DWORD *)(v24 + 388) = v27;
        __int16 v28 = *(void *)(*(void *)(v24 + 456) + 24LL);
        if ((v25 & 4) != 0)
        {
          if (v28)
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats) {
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v24 + 388);
            }
          }
        }

        else if (v28)
        {
          int v29 = nw_protocol_tcp_get_all_stats();
          if (v29) {
            *(_DWORD *)(v29 + 100) = *(_DWORD *)(v24 + 388);
          }
        }

        int v31 = *(_DWORD *)(v24 + 388);
        if (*(_DWORD *)(v24 + 392) > v31) {
          *(_DWORD *)(v24 + 392) = v31;
        }
      }

      *(_DWORD *)(v24 + 432) &= ~0x800u;
    }
  }

  __int16 v32 = *(_DWORD *)(a1 + 740);
  if ((v32 & 0x20400020) == 0x20000020)
  {
    uint64_t v33 = *(_BYTE *)(a1 + 2069);
    if ((v33 & 0x1Fu) >= 0xF) {
      uint64_t v34 = 16;
    }
    else {
      uint64_t v34 = (v33 + 1) & 0x1F;
    }
    *(_BYTE *)(a1 + 2069) = v33 & 0xC0 | v34 | 0x20;
  }

  *(_DWORD *)(a1 + 740) = v32 | 0x40;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  *(_DWORD *)(a1 + 532) = *(_DWORD *)(result + 316);
  *(_DWORD *)(a1 + 172) = 0;
  return result;
}

  if (*(_DWORD *)(a1 + 360) == 1) {
    *(_DWORD *)(a1 + 360) = 2;
  }
  if (*(_DWORD *)(a1 + 364) == 1) {
    *(_DWORD *)(a1 + 364) = 2;
  }
LABEL_22:
  if ((v4 & 0x1C00) == 0x1000
    && *(_DWORD *)(a1 + 112) % 0x64u >= *(_DWORD *)(sysctls + 88)
    && ((v3 & 0x10000000) != 0 || (v3 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1))
  {
    *(_DWORD *)(a1 + 348) = v4 & 0xFFFFEFFF;
  }

  return result;
}

LABEL_211:
      *(void *)(*(void *)(v182 + 272) + 8LL) += v106;
      goto LABEL_212;
    }

LABEL_207:
    ++**(void **)(v182 + 272);
    goto LABEL_208;
  }

  if ((*(_WORD *)(v190 + 204) & 0x80) != 0) {
    *(_WORD *)(v190 + 196) -= v64;
  }
  unsigned int v107 = *(_DWORD *)(v190 + 56) + v64;
  int v108 = *(_DWORD *)(v190 + 60);
  if (v107 <= *(_DWORD *)(v190 + 52) - v108)
  {
    *(_DWORD *)(v190 + 56) = v107;
  }

  else
  {
    uint64_t v109 = (os_log_s *)__nwlog_obj();
    BOOL v110 = os_log_type_enabled(v109, OS_LOG_TYPE_ERROR);
    int v61 = type;
    int v60 = v184;
    BOOL v59 = v185;
    uint64_t v58 = v182;
    if (v110)
    {
      int v111 = *(_DWORD *)(v190 + 52);
      *(_DWORD *)__int128 buf = 136446978;
      uint64_t v195 = "__nw_frame_claim_internal";
      __int16 v196 = 1024;
      *(_DWORD *)uint64_t v197 = v107;
      *(_WORD *)&v197[4] = 1024;
      *(_DWORD *)&v197[6] = v111;
      *(_WORD *)unsigned int v198 = 1024;
      *(_DWORD *)&v198[2] = v108;
      _os_log_impl( &dword_1879E5000,  v109,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
      int v61 = type;
      int v60 = v184;
      BOOL v59 = v185;
      uint64_t v58 = v182;
    }
  }

  int v187 = 0;
  *v191 -= v64;
  int v51 = *(_DWORD *)(v46 + 4) + v64;
  *(_DWORD *)(v46 + 4) = v51;
  int v52 = *(_DWORD *)(a1 + 120);
LABEL_129:
  if (v51 != v52)
  {
    ++*(_DWORD *)(a1 + 996);
    uint64_t v74 = *(void *)(a1 + 1056);
    uint64_t v75 = *v191;
    if (v74)
    {
      uint64_t v76 = *(void *)(v74 + 264) + v75;
      ++*(void *)(v74 + 256);
      *(void *)(v74 + 264) = v76;
    }

    *(_DWORD *)(a1 + 708) += v75;
  }

  int v77 = *(void **)(v58 + 248);
  ++*v77;
  if (v60)
  {
    ++**(void **)(v58 + 256);
    if (!v61) {
      goto LABEL_135;
    }
  }

  else if (!v61)
  {
LABEL_135:
    if (!v59) {
      goto LABEL_137;
    }
    goto LABEL_136;
  }

  ++**(void **)(v58 + 264);
  if (v59) {
LABEL_136:
  }
    ++**(void **)(v58 + 272);
LABEL_137:
  uint64_t v78 = *v191;
  v77[1] += v78;
  if (v60)
  {
    *(void *)(*(void *)(v58 + 256) + 8LL) += v78;
    if (!v61) {
      goto LABEL_139;
    }
  }

  else if (!v61)
  {
LABEL_139:
    if (v59) {
      goto LABEL_140;
    }
    goto LABEL_147;
  }

  *(void *)(*(void *)(v58 + 264) + 8LL) += v78;
  if (v59)
  {
LABEL_140:
    *(void *)(*(void *)(v58 + 272) + 8LL) += v78;
    if (!*(void *)(v192 + 24)) {
      goto LABEL_150;
    }
LABEL_148:
    uint64_t v79 = nw_protocol_tcp_get_all_stats();
    if (v79) {
      *(_DWORD *)(v79 + 52) += *v191;
    }
    goto LABEL_150;
  }

LABEL_147:
  if (*(void *)(v192 + 24)) {
    goto LABEL_148;
  }
LABEL_150:
  if (v57)
  {
    if (v192) {
      int v80 = (const char *)(v192 + 604);
    }
    else {
      int v80 = "";
    }
    do
    {
      int v81 = *v191 + *(_DWORD *)(v46 + 4);
      uint64_t v82 = v57[3];
      int v83 = *(_DWORD *)(v82 + 4);
      uint64_t v84 = (v81 - v83);
      if (v63 || (_DWORD)v84 == 1)
      {
        LODWORD(v85) = *((_DWORD *)v57 + 4);
      }

      else if (*(_DWORD *)(a1 + 940))
      {
        uint64_t v85 = *((int *)v57 + 4);
        if (v84 >= v85) {
          int v86 = *((_DWORD *)v57 + 4);
        }
        else {
          int v86 = v81 - v83;
        }
        *(_DWORD *)(a1 + 944) += v86;
      }

      else
      {
        *(_DWORD *)(a1 + 940) = v83;
        uint64_t v85 = *((int *)v57 + 4);
        if (v84 >= v85) {
          int v87 = *((_DWORD *)v57 + 4);
        }
        else {
          int v87 = v81 - v83;
        }
        *(_DWORD *)(a1 + 944) = v87 + v83;
      }

      if ((int)v85 > (int)v84)
      {
        *(_DWORD *)(v82 + 4) = v81;
        *((_DWORD *)v57 + 4) = v85 - v84;
        uint64_t v101 = v57[4];
        if (v101)
        {
          if ((*(_WORD *)(v101 + 204) & 0x80) != 0)
          {
            unsigned int v102 = *(unsigned __int16 *)(v101 + 196);
            if (v84 <= v102)
            {
              *(_WORD *)(v101 + 196) = v102 - v84;
            }

            else
            {
              __nwlog_obj();
              int v103 = *(unsigned __int16 *)(v101 + 196);
              *(_DWORD *)__int128 buf = 136446722;
              uint64_t v195 = "__nw_frame_array_claim";
              __int16 v196 = 1024;
              *(_DWORD *)uint64_t v197 = v103;
              *(_WORD *)&v197[4] = 1024;
              *(_DWORD *)&v197[6] = v84;
              int v104 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_fault())
              {
                unint64_t v119 = (os_log_s *)__nwlog_obj();
                if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
                {
                  int v120 = *(unsigned __int16 *)(v101 + 196);
                  *(_DWORD *)__int128 buf = 136446722;
                  uint64_t v195 = "__nw_frame_array_claim";
                  __int16 v196 = 1024;
                  *(_DWORD *)uint64_t v197 = v120;
                  *(_WORD *)&v197[4] = 1024;
                  *(_DWORD *)&v197[6] = v84;
                  _os_log_impl( &dword_1879E5000,  v119,  OS_LOG_TYPE_ERROR,  "%{public}s Aggregate buffer length: %u sum: %u, backtrace limit exceeded",  buf,  0x18u);
                }
              }

              if (v104) {
                free(v104);
              }
              *(_WORD *)(v101 + 196) = 0;
            }
          }
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
          uint64_t v170 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            uint64_t v179 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v195 = "__nw_frame_is_single_ip_aggregate";
              _os_log_impl( &dword_1879E5000,  v179,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v170) {
            free(v170);
          }
        }

        uint64_t v121 = v57[4];
        if (v121)
        {
          unsigned int v122 = 0;
          while (1)
          {
            int v123 = *(_DWORD *)(v121 + 52);
            int v124 = *(_DWORD *)(v121 + 56);
            int v125 = *(_DWORD *)(v121 + 60);
            unsigned int v126 = v123 - (v124 + v125);
            unsigned int v127 = v123 ? v126 : 0;
            int v128 = v124 + v127;
            if (v124 + v127 <= v123 - v125)
            {
              *(_DWORD *)(v121 + 56) = v128;
            }

            else
            {
              __int16 v129 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
              {
                int v130 = *(_DWORD *)(v121 + 52);
                *(_DWORD *)__int128 buf = 136446978;
                uint64_t v195 = "__nw_frame_claim_internal";
                __int16 v196 = 1024;
                *(_DWORD *)uint64_t v197 = v128;
                *(_WORD *)&v197[4] = 1024;
                *(_DWORD *)&v197[6] = v130;
                *(_WORD *)unsigned int v198 = 1024;
                *(_DWORD *)&v198[2] = v125;
                _os_log_impl( &dword_1879E5000,  v129,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
              }
            }

            v122 += v127;
            if (v122 == (_DWORD)v84) {
              break;
            }
            if (v122 < v84)
            {
              uint64_t v121 = *(void *)(v121 + 32);
              if (v121) {
                continue;
              }
            }

            goto LABEL_250;
          }
        }

        else
        {
          unsigned int v122 = 0;
LABEL_250:
          int v131 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446722;
            uint64_t v195 = "__nw_frame_array_claim";
            __int16 v196 = 1024;
            *(_DWORD *)uint64_t v197 = v122;
            *(_WORD *)&v197[4] = 1024;
            *(_DWORD *)&v197[6] = v84;
            _os_log_impl( &dword_1879E5000,  v131,  OS_LOG_TYPE_ERROR,  "%{public}s start_offset %u != start_bytes %u",  buf,  0x18u);
          }
        }

        break;
      }

      uint64_t v88 = (void *)*v57;
      if (*v57) {
        v88[1] = v57[1];
      }
      *(void *)v57[1] = v88;
      uint64_t v89 = a1;
      if (!v192 || (*(_BYTE *)(v192 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v96 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
          {
            int v97 = *(_DWORD *)(v57[3] + 4LL);
            int v98 = *(_DWORD *)(v46 + 4);
            int v99 = *((_DWORD *)v57 + 4);
            int v100 = *v191;
            *(_DWORD *)__int128 buf = 136447490;
            uint64_t v195 = "tcp_reass";
            __int16 v196 = 2082;
            *(void *)uint64_t v197 = v80;
            *(_WORD *)&v197[8] = 1024;
            *(_DWORD *)unsigned int v198 = v97;
            *(_WORD *)&v198[4] = 1024;
            *(_DWORD *)&v198[6] = v98;
            *(_WORD *)__int16 v199 = 1024;
            *(_DWORD *)&v199[2] = v99;
            __int16 v200 = 1024;
            int v201 = v100;
            _os_log_impl( &dword_1879E5000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s dropping a completely overlapping segment: tqe_seq %u th_seq %u tqe_len %u tlen %u",  buf,  0x2Eu);
          }
        }
      }

      unsigned int v90 = (void *)v57[4];
      if (v90)
      {
        do
        {
          while (1)
          {
            os_log_type_t v91 = (void (*)(void *, uint64_t, uint64_t))v90[10];
            int v92 = (void *)v90[4];
            if (!v91) {
              break;
            }
            uint64_t v93 = v90[11];
            v90[10] = 0LL;
            v90[11] = 0LL;
            v91(v90, 1LL, v93);
            unsigned int v90 = v92;
            if (!v92) {
              goto LABEL_154;
            }
          }

          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v195 = "__nw_frame_finalize";
          int v94 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            uint64_t v95 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v195 = "__nw_frame_finalize";
              _os_log_impl( &dword_1879E5000,  v95,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v94) {
            free(v94);
          }
          uint64_t v89 = a1;
          unsigned int v90 = v92;
        }

        while (v92);
      }

LABEL_154:
      free(v57);
      --*(_WORD *)(v89 + 224);
      char v57 = v88;
    }

    while (v88);
  }

  *(void *)(v190 + 32) = 0LL;
  *(void *)(v190 + 40) = v189 + 4;
  v189[4] = v190;
  v189[5] = v190 + 32;
  v189[3] = v46;
  *((_DWORD *)v189 + 4) = *v191;
  if (v187)
  {
    uint64_t v34 = a1;
    unsigned int v132 = *(void **)a1;
    void *v189 = *(void *)a1;
    if (v132) {
      v132[1] = v189;
    }
    *(void *)a1 = v189;
    v189[1] = a1;
  }

  else
  {
    uint64_t v133 = *v62;
    void *v189 = *v62;
    uint64_t v34 = a1;
    if (v133) {
      *(void *)(*v62 + 8LL) = v189;
    }
    void *v62 = v189;
    v189[1] = v62;
  }

LABEL_259:
  uint64_t v134 = *(void **)v34;
  if (!*(void *)v34) {
    return 0LL;
  }
  uint64_t v135 = v134[3];
  int v136 = *(_DWORD *)(v135 + 4);
  if (v136 != *(_DWORD *)(v34 + 120)) {
    return 0LL;
  }
  int v137 = *(_DWORD *)(v34 + 740);
  if ((v137 & 0x800000) != 0) {
    return 0LL;
  }
  *(_DWORD *)(v34 + 740) = v137 | 0x800000;
  uint64_t v138 = *(void *)(v34 + 1056);
  if (v138) {
    ++*(void *)(v138 + 1616);
  }
  int v139 = 0;
  if (v192) {
    int v140 = (const char *)(v192 + 604);
  }
  else {
    int v140 = "";
  }
  uint64_t v141 = a1;
  do
  {
    *(_DWORD *)(v141 + 120) = v136 + *((_DWORD *)v134 + 4);
    char v142 = *(_BYTE *)(v135 + 13);
    uint64_t v143 = *v134;
    if (*v134) {
      *(void *)(v143 + 8) = v134[1];
    }
    *(void *)v134[1] = v143;
    if ((*(_WORD *)(v192 + 376) & 0x20) == 0)
    {
      int v144 = *(_DWORD *)(a1 + 740);
      unsigned int v145 = v144 & 0xFFFFFFEF | (16 * ((*(unsigned __int8 *)(v134[3] + 13LL) >> 3) & 1));
      *(_DWORD *)(a1 + 740) = v145;
      if ((v144 & 0x4000000) != 0)
      {
        *(_DWORD *)(a1 + 740) = v145 & 0xFBFFFFFF;
        nw_frame_array_first();
        nw_frame_set_is_wake_packet();
        if ((*(_BYTE *)(v192 + 828) & 2) == 0)
        {
          os_log_type_t v146 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v146, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v195 = "tcp_reass";
            __int16 v196 = 2082;
            *(void *)uint64_t v197 = v140;
            _os_log_impl( &dword_1879E5000,  v146,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s reassembled segment is wake packet",  buf,  0x16u);
          }
        }
      }

      uint64_t v147 = v134[4];
      if (v147)
      {
        signed int v148 = 0;
        do
        {
          int v149 = *(_DWORD *)(v147 + 52);
          if (v149) {
            v149 -= *(_DWORD *)(v147 + 56) + *(_DWORD *)(v147 + 60);
          }
          v148 += v149;
          uint64_t v147 = *(void *)(v147 + 32);
        }

        while (v147);
      }

      else
      {
        signed int v148 = 0;
      }
    }

    int v150 = (void *)v134[4];
    if (v150)
    {
      do
      {
        while (1)
        {
          BOOL v151 = (void (*)(void *, uint64_t, uint64_t))v150[10];
          int v152 = (void *)v150[4];
          if (!v151) {
            break;
          }
          uint64_t v153 = v150[11];
          v150[10] = 0LL;
          v150[11] = 0LL;
          v151(v150, 1LL, v153);
          int v150 = v152;
          if (!v152) {
            goto LABEL_294;
          }
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v195 = "__nw_frame_finalize";
        int v154 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          int v155 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v195 = "__nw_frame_finalize";
            _os_log_impl( &dword_1879E5000,  v155,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        if (v154) {
          free(v154);
        }
        int v150 = v152;
      }

      while (v152);
    }

LABEL_294:
    free(v134);
    uint64_t v141 = a1;
    --*(_WORD *)(a1 + 224);
    uint64_t v134 = *(void **)a1;
    if (!*(void *)a1) {
      break;
    }
    uint64_t v135 = v134[3];
    int v136 = *(_DWORD *)(v135 + 4);
  }

  while (v136 == *(_DWORD *)(a1 + 120));
  uint64_t result = v142 & 1;
  *(_DWORD *)(a1 + 740) &= ~0x800000u;
  if (a6)
  {
    if (v139) {
      *a6 = 1;
    }
  }

  return result;
}

uint64_t tcp_sbrcv_reserve(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  if (a3 >= a5) {
    uint64_t v5 = a5;
  }
  else {
    uint64_t v5 = a3;
  }
  char v6 = *(_BYTE *)(result + 261);
  uint64_t v7 = 0xFFFFLL << v6;
  int v8 = 0xFFFF << v6;
  if (v7 <= v5) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = v5;
  }
  if (v9 > *(_DWORD *)(a2 + 4) && v9 <= 0x71C71C)
  {
    uint64_t v14 = result;
    *(_DWORD *)(a2 + 4) = v9;
    uint64_t result = *(void *)(*(void *)(a2 + 72) + 24LL);
    if ((*(_BYTE *)(a2 + 48) & 4) != 0)
    {
      if (result)
      {
        uint64_t result = nw_protocol_tcp_get_all_stats();
        if (result) {
          *(_DWORD *)(result + 88) = *(_DWORD *)(a2 + 4);
        }
      }
    }

    else if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result) {
        *(_DWORD *)(result + 100) = *(_DWORD *)(a2 + 4);
      }
    }

    unsigned int v15 = *(_DWORD *)(a2 + 4);
    if (*(_DWORD *)(a2 + 8) > v15) {
      *(_DWORD *)(a2 + 8) = v15;
    }
    LODWORD(v16) = *(_DWORD *)(a2 + 52);
    if (a4) {
      unsigned int v17 = a4;
    }
    else {
      unsigned int v17 = v9;
    }
    else {
      uint64_t v16 = v16;
    }
    char v18 = *(_BYTE *)(v14 + 261);
    uint64_t v19 = 0xFFFFLL << v18;
    int v20 = 0xFFFF << v18;
    if (v19 <= v16) {
      LODWORD(v16) = v20;
    }
    *(_DWORD *)(a2 + 52) = v16;
  }

  return result;
}

uint64_t update_base_rtt(uint64_t a1, unsigned int a2)
{
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 496LL);
  if (v5)
  {
    char v6 = *(unsigned int **)(v5 + 1488);
    if (v6)
    {
      if (v6[11])
      {
        int v7 = *(_DWORD *)(a1 + 740);
        if ((v7 & 0x100) != 0
          && *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 1040) >= 5000
          && *(_DWORD *)(a1 + 236) <= *(_DWORD *)(sysctls + 4) + v6[10])
        {
          *(_DWORD *)(a1 + 740) = v7 & 0xFFFFFEFF;
          *(_DWORD *)(a1 + 1040) = 0;
        }

        unsigned int v8 = (*(_DWORD *)(a1 + 1912) + 1) & 3;
        *(_DWORD *)(a1 + 1912) = v8;
        *(_DWORD *)(a1 + 1892 + 4LL * v8) = a2;
        int v9 = *(_DWORD *)(a1 + 1892);
        *(_DWORD *)(a1 + 1908) = v9;
        int v10 = *(_DWORD *)(result + 316) - v6[11];
        if (v10 < 60000)
        {
          unsigned int v24 = v6[*((unsigned __int8 *)v6 + 72)];
          if (v24 >= a2) {
            unsigned int v24 = a2;
          }
          v6[*((unsigned __int8 *)v6 + 72)] = v24;
          unsigned int v25 = v6[10];
          if (v25)
          {
            if (v25 >= a2) {
              unsigned int v25 = a2;
            }
            v6[10] = v25;
          }

          else
          {
            v6[10] = a2;
          }
        }

        else
        {
          unsigned int v11 = v10 / 0xEA60u;
          int v12 = *((unsigned __int8 *)v6 + 72);
          LODWORD(v13) = v12 + 1;
          if (v11 >= 2)
          {
            if (v11 == 2) {
              goto LABEL_22;
            }
            unsigned int v14 = (v11 - 1) & 0xFFFFFFFE;
            unsigned int v15 = v12 + 2;
            unsigned int v16 = v12 + 1;
            unsigned int v17 = v14;
            do
            {
              v6[v16 % 0xA] = 0;
              v6[v15 % 0xA] = 0;
              v16 += 2;
              v15 += 2;
              v17 -= 2;
            }

            while (v17);
            LODWORD(v13) = v13 + v14;
            if (v11 - 1 != v14)
            {
LABEL_22:
              unsigned int v18 = v11 + v12;
              uint64_t v19 = (int *)&v6[v13];
              unint64_t v13 = v13;
              do
              {
                v19[-10 * (v13 / 0xA)] = 0;
                ++v13;
                ++v19;
              }

              while (v13 < v18);
            }
          }

          unsigned int v20 = v13 % 0xA;
          *((_BYTE *)v6 + 72) = v20;
          v6[v20] = a2;
          unsigned int v21 = *(_DWORD *)(result + 316);
          unsigned int v22 = *v6;
          uint64_t result = v6[8];
          if (v6[1] - 1 < *v6 - 1) {
            unsigned int v22 = v6[1];
          }
          if (v6[2] - 1 < v22 - 1) {
            unsigned int v22 = v6[2];
          }
          if (v6[3] - 1 < v22 - 1) {
            unsigned int v22 = v6[3];
          }
          if (v6[4] - 1 < v22 - 1) {
            unsigned int v22 = v6[4];
          }
          if (v6[5] - 1 < v22 - 1) {
            unsigned int v22 = v6[5];
          }
          if (v6[6] - 1 < v22 - 1) {
            unsigned int v22 = v6[6];
          }
          if (v6[7] - 1 < v22 - 1) {
            unsigned int v22 = v6[7];
          }
          if (v6[9] - 1 < v22 - 1) {
            unsigned int v22 = v6[9];
          }
          v6[10] = v22;
          v6[11] = v21;
        }
      }

      else
      {
        unsigned int v23 = *(_DWORD *)(result + 316);
        *((_BYTE *)v6 + 72) = 0;
        *char v6 = a2;
        v6[10] = a2;
        v6[11] = v23;
        *(_DWORD *)(a1 + 1912) = 0;
        *(_DWORD *)(a1 + 1892) = a2;
        *(_DWORD *)(a1 + 1908) = a2;
      }
    }
  }

  return result;
}

void tcp_xmit_timer(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a2 <= 1) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = a2;
  }
  if ((int)v7 >= 60001)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 224LL);
    if (!v8 || (*(_BYTE *)(v8 + 828) & 2) == 0)
    {
      int v9 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v10 = (const char *)(v8 + 604);
        uint64_t v42 = "tcp_xmit_timer";
        int v41 = 136446722;
        if (!v8) {
          int v10 = "";
        }
        __int16 v43 = 2082;
        uint64_t v44 = v10;
        __int16 v45 = 1024;
        unsigned int v46 = v7;
        _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s rtt is %d - maxing it at 4 x MSL\n",  (uint8_t *)&v41,  0x1Cu);
      }
    }

    unsigned int v7 = 60000;
  }

  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 448LL);
  if (!v11 || (*(_BYTE *)(v11 + 1054) & 0x10) == 0 || *(_DWORD *)(a1 + 112) + 1 != a4)
  {
    int v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x40) == 0)
    {
      uint64_t v13 = *(void *)(a1 + 1056);
      if (v13) {
        ++*(void *)(v13 + 464);
      }
      int v14 = *(_DWORD *)(a1 + 240) + 1;
      *(_DWORD *)(a1 + 236) = v7;
      *(_DWORD *)(a1 + 240) = v14;
      update_base_rtt(a1, v7);
      int v15 = *(_DWORD *)(a1 + 200);
      if (v15)
      {
        int v16 = 4 * v7 - (v15 >> 3);
        int v17 = v16 + v15;
        if (v17 <= 1) {
          int v17 = 1;
        }
        *(_DWORD *)(a1 + 200) = v17;
        if (v16 < 0) {
          int v16 = -v16;
        }
        int v18 = *(_DWORD *)(a1 + 208) + v16 - (*(int *)(a1 + 208) >> 2);
        if (v18 <= 1) {
          int v19 = 1;
        }
        else {
          int v19 = v18;
        }
        *(_DWORD *)(a1 + 208) = v19;
        int v20 = *(_DWORD *)(a1 + 232);
        int v21 = v19 + v17;
        if (!v20 || v20 > v21) {
          *(_DWORD *)(a1 + 232) = v21;
        }
      }

      else
      {
        *(_DWORD *)(a1 + 200) = 32 * v7;
        *(_DWORD *)(a1 + 208) = 8 * v7;
        *(_DWORD *)(a1 + 232) = 40 * v7;
        if (!*(_DWORD *)(a1 + 1968)) {
          *(_DWORD *)(a1 + 1968) = 32 * v7;
        }
      }

      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        int v29 = *(_DWORD *)(a1 + 204);
        if (v29)
        {
          int v30 = 4 * v7 - (v29 >> 3);
          int v31 = v30 + v29;
          if (v31 <= 1) {
            int v31 = 1;
          }
          *(_DWORD *)(a1 + 204) = v31;
          if (v30 >= 0) {
            int v32 = v30;
          }
          else {
            int v32 = -v30;
          }
          int v33 = *(_DWORD *)(a1 + 212) + v32 - (*(int *)(a1 + 212) >> 2);
          if (v33 <= 1) {
            int v33 = 1;
          }
        }

        else
        {
          *(_DWORD *)(a1 + 204) = 32 * v7;
          int v33 = 8 * v7;
        }

        *(_DWORD *)(a1 + 212) = v33;
      }

      goto LABEL_59;
    }

    if (a4 - *(_DWORD *)(a1 + 92) >= 1 && a4 - *(_DWORD *)(a1 + 96) <= 0 && (!a3 || a3 - *(_DWORD *)(a1 + 532) >= 0))
    {
      *(_DWORD *)(a1 + 740) = v12 & 0xFFFFFFBF;
      *(_DWORD *)(a1 + 532) = 0;
      uint64_t v22 = *(int *)(a1 + 516);
      if (v22 <= v7) {
        LODWORD(v22) = v7;
      }
      int v23 = 32 * v22;
      *(_DWORD *)(a1 + 200) = v23;
      signed int v24 = *(_DWORD *)(a1 + 524);
      int v25 = 16 * v24;
      *(_DWORD *)(a1 + 208) = v25;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        else {
          unsigned int v26 = *(_DWORD *)(a1 + 520);
        }
        *(_DWORD *)(a1 + 204) = 32 * v26;
        signed int v27 = *(_DWORD *)(a1 + 528);
        *(_DWORD *)(a1 + 212) = 16 * v27;
      }

      int v28 = v23 + v25;
      if (*(_DWORD *)(a1 + 232) > v28) {
        *(_DWORD *)(a1 + 232) = v28;
      }
LABEL_59:
      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 24LL))
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 68) = *(_DWORD *)(a1 + 232);
        }
      }

      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 24LL))
      {
        uint64_t v35 = nw_protocol_tcp_get_all_stats();
        if (v35) {
          *(_DWORD *)(v35 + 72) = *(_DWORD *)(a1 + 200);
        }
      }

      if (*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 24LL))
      {
        uint64_t v36 = nw_protocol_tcp_get_all_stats();
        if (v36) {
          *(_DWORD *)(v36 + 76) = *(_DWORD *)(a1 + 208);
        }
      }

      else {
        int v37 = *(_DWORD *)(sysctls + 176);
      }
      unint64_t v38 = *(unsigned int *)(a1 + 228);
      int v39 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 3)) >> 2;
      unsigned int v40 = v39 + v37;
      *(_DWORD *)(a1 + 192) = v40;
      if (v40 >= v38)
      {
        if (v40 < 0xFA01)
        {
LABEL_79:
          *(_DWORD *)(a1 + 256) = 0;
          return;
        }

        LODWORD(v38) = 64000;
      }

      *(_DWORD *)(a1 + 192) = v38;
      goto LABEL_79;
    }
  }

uint64_t tcp_bad_rexmt_restore_state(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 88);
  if ((~v3 & 0x180) != 0)
  {
    *(void *)(a1 + 144) = *(void *)(a1 + 504);
    if ((v3 & 0x400000) == 0)
    {
LABEL_25:
      *(_DWORD *)(a1 + 984) = 0;
      unsigned int v9 = *(_DWORD *)(a1 + 144);
      goto LABEL_26;
    }

    *(_DWORD *)(a1 + 88) = v3 | 0x200000;
    uint64_t v10 = *(void *)(a1 + 80);
    int v11 = *(_DWORD *)(v10 + 2228);
    if ((v11 & 0x40000000) != 0)
    {
      uint64_t v12 = *(void *)(v10 + 224);
      if ((v11 & 0x10000000) == 0)
      {
        int v13 = *(_DWORD *)(v12 + 364);
        *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
        if ((v13 & 0x20000) != 0) {
          *(_DWORD *)(v12 + 364) = v13 & 0xFFFDFFFF;
        }
        if ((v11 & 0x50000000) == 0) {
          goto LABEL_18;
        }
        goto LABEL_15;
      }

      *(_DWORD *)(v10 + 2228) = v11 & 0xAFFFFFFF;
      *(_DWORD *)(v12 + 364) &= ~0x20000u;
      if ((v11 & 0x50000000) != 0)
      {
LABEL_15:
        int v14 = *(void (***)(void))(v12 + 32);
        if (v14)
        {
          int v15 = *v14;
          if (v15) {
            v15();
          }
        }
      }
    }

void tcp_mss(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 80);
  char v6 = *(_BYTE *)(v3 + 2236);
  if ((v6 & 2) != 0) {
    int v7 = -60;
  }
  else {
    int v7 = -40;
  }
  uint64_t v8 = *(void *)(a1 + 80);
  if ((*(_BYTE *)(v3 + 2236) & 2) != 0)
  {
    uint64_t v9 = tcp_rtlookup6(v8, a3);
    if (v9) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v9 = tcp_rtlookup(v8, a3);
    if (v9)
    {
LABEL_8:
      uint64_t v10 = *(void *)(v9 + 216);
      if (*(_BYTE *)(v10 + 1076) == 23
        && *(int *)(sysctls + 48) >= 1
        && (*(_DWORD *)(v10 + 1040) - 9601) >> 7 <= 0x39C)
      {
        *(_DWORD *)(a1 + 88) |= 0x80000u;
      }

      uint64_t v11 = *(void *)(v3 + 224);
      int v12 = a2;
      if (a2 == -1)
      {
        uint64_t v16 = *(void *)(v9 + 1488);
        if (v16)
        {
          int v12 = *(_DWORD *)(v16 + 52);
          int v13 = (int *)sysctls;
          if (!v12)
          {
LABEL_21:
            uint64_t v17 = 38LL;
            if ((v6 & 2) == 0) {
              uint64_t v17 = 37LL;
            }
            int v12 = v13[v17];
            goto LABEL_29;
          }
        }

        else
        {
          int v13 = (int *)sysctls;
          int v12 = -1;
        }
      }

      else
      {
        int v13 = (int *)sysctls;
        if (!a2) {
          goto LABEL_21;
        }
      }

      if (v12 <= v13[41]) {
        int v12 = v13[41];
      }
      if (v12 <= 64) {
        int v12 = 64;
      }
LABEL_29:
      int v18 = *(_DWORD **)(v9 + 1488);
      BOOL v19 = v18 == 0LL;
      if (!v18)
      {
        *(_DWORD *)(a1 + 228) = 30;
        unsigned int v21 = *(_DWORD *)(v10 + 1044);
        goto LABEL_38;
      }

      v18[13] = v12;
      if (*(_DWORD *)(a1 + 200) || (unsigned int v35 = v18[16]) == 0)
      {
        *(_DWORD *)(a1 + 228) = 30;
        goto LABEL_32;
      }

      if (*(_DWORD *)(a1 + 1872) == 1) {
        goto LABEL_32;
      }
      *(_DWORD *)(a1 + 228) = 30;
      unsigned int v36 = v35 / 0x1F;
      *(_DWORD *)(a1 + 200) = v35 / 0x1F;
      uint64_t v37 = *(void *)(a1 + 1056);
      if (v37)
      {
        ++*(void *)(v37 + 1280);
        unsigned int v38 = v18[17];
        if (v38)
        {
          unsigned int v39 = v38 / 0x3E;
          *(_DWORD *)(a1 + 208) = v38 / 0x3E;
          ++*(void *)(v37 + 1288);
LABEL_91:
          else {
            int v48 = v13[44];
          }
          signed int v49 = (v39 + (v36 >> 3)) >> 2;
          int v50 = 30;
          if (v49 <= 30) {
            signed int v49 = 30;
          }
          unsigned int v51 = v49 + v48;
          *(_DWORD *)(a1 + 192) = v51;
          if (v51 >= 0x1E)
          {
            if (v51 < 0xFA01) {
              goto LABEL_32;
            }
            int v50 = 64000;
          }

          *(_DWORD *)(a1 + 192) = v50;
LABEL_32:
          unsigned int v20 = v18[12];
          unsigned int v21 = *(_DWORD *)(v10 + 1044);
          if (v20)
          {
            BOOL v19 = 0;
            if (v20 >= v21) {
              int v22 = *(_DWORD *)(v10 + 1044);
            }
            else {
              int v22 = v18[12];
            }
            LODWORD(v23) = v22 + v7;
            goto LABEL_43;
          }

void tcp_set_new_cc(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)a1 + 240LL);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 264);
  if ((_DWORD)v3 != a2)
  {
    char v6 = *(void (**)(void))(tcp_cc_algo_list[v3] + 32);
    if (v6) {
      v6(*(void *)(*(void *)a1 + 240LL));
    }
    *(_BYTE *)(v2 + 264) = a2;
    if (*(void *)(a1 + 24))
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 132) = a2;
      }
    }

    uint64_t v8 = *(unsigned __int8 *)(v2 + 264);
    if ((v8 - 2) <= 2 && !*(void *)(v2 + 840))
    {
      *(void *)(v2 + 840) = v2 + 848;
      *(_OWORD *)(v2 + 848) = 0u;
      *(_OWORD *)(v2 + 864) = 0u;
      *(_OWORD *)(v2 + 880) = 0u;
      *(_OWORD *)(v2 + 896) = 0u;
      *(_OWORD *)(v2 + 912) = 0u;
    }

    uint64_t v9 = *(void (**)(uint64_t))(tcp_cc_algo_list[v8] + 120);
    if (v9) {
      v9(v2);
    }
    if ((*(_BYTE *)(a1 + 828) & 2) == 0 && __nwlog_is_datapath_logging_enabled())
    {
      uint64_t v10 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        int v12 = 136446722;
        int v13 = "tcp_set_new_cc";
        __int16 v14 = 2082;
        uint64_t v15 = a1 + 604;
        __int16 v16 = 2082;
        uint64_t v17 = v11;
        _os_log_impl( &dword_1879E5000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s cc_algo %{public}s",  (uint8_t *)&v12,  0x20u);
      }
    }
  }

void tcp_set_foreground_cc(uint64_t a1)
{
  if (*(_DWORD *)(sysctls + 20))
  {
    int v1 = 1;
  }

  else if (*(_DWORD *)(sysctls + 304))
  {
    int v1 = 2;
  }

  else
  {
    int v2 = *(_DWORD *)(*(void *)(*(void *)a1 + 240LL) + 740LL);
    if ((v2 & 0x10000000) == 0
      && ((v2 & 0x8000000) != 0 || (*(_DWORD *)(sysctls + 336) != 1 ? (BOOL v3 = tcp_do_l4s == 1) : (BOOL v3 = 1), v3)))
    {
      int v1 = 4;
    }

    else
    {
      int v1 = 3;
    }
  }

  tcp_set_new_cc(a1, v1);
}

uint64_t tcp_usr_abort(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (!v4) {
    return 0LL;
  }
  tcp_drop(v4, 53);
  int v6 = *((_DWORD *)a1 + 90);
  if (v6 > 0)
  {
LABEL_6:
    uint64_t result = 0LL;
    *((_DWORD *)a1 + 90) = v6 - 1;
    return result;
  }

  int v7 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  uint64_t v8 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v8);
    int v6 = *((_DWORD *)a1 + 90);
    goto LABEL_6;
  }

  __break(1u);
  return result;
}

uint64_t tcp_usr_attach(uint64_t a1)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  int v2 = **(_DWORD **)(*(void *)(a1 + 8) + 8LL);
  uint64_t v3 = nw_tcp_access_globals(a1);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(void *)(v3 + 72);
    if (v5) {
      goto LABEL_3;
    }
  }

  else
  {
    uint64_t v54 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    ____int128 buf = 136446210;
    unint64_t v59 = "tcp_attach";
    uint64_t v55 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result)
    {
LABEL_105:
      __break(1u);
      return result;
    }

    free(v55);
    uint64_t v5 = MEMORY[0x48];
    if (MEMORY[0x48]) {
      goto LABEL_3;
    }
  }

  uint64_t v56 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  ____int128 buf = 136446210;
  unint64_t v59 = "tcp_attach";
  unsigned int v57 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if ((_DWORD)result) {
    goto LABEL_105;
  }
  free(v57);
  uint64_t v5 = *(void *)(v4 + 72);
LABEL_3:
  uint64_t v6 = *(void *)a1;
  *(void *)(v6 + 16) = v5;
  *(void *)(v6 + 224) = a1;
  v7.i64[0] = v6 + 280;
  v7.i64[1] = v6 + 320;
  *(int64x2_t *)(v6 + 248) = vnegq_s64((int64x2_t)vandq_s8( (int8x16_t)vnegq_s64(v7),  (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8LL)));
  *(void *)(v6 + 264) = -(uint64_t)((-360 - v6) & 0xFFFFFFFFFFFFFFF8LL);
  *(void *)(v6 + 272) = -(uint64_t)((-400 - v6) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v8 = *(uint64_t **)(v5 + 32);
  uint64_t v9 = *v8;
  *(void *)uint64_t v6 = *v8;
  if (v9) {
    *(void *)(v9 + 8) = v6;
  }
  *uint64_t v8 = v6;
  *(void *)(v6 + 8) = v8;
  uint64_t v10 = *(void *)a1;
  if (!*(_DWORD *)(a1 + 388) || !*(_DWORD *)(a1 + 492))
  {
    unsigned int v13 = *(_DWORD *)(sysctls + 232);
    if (v13 > 0x71C71C) {
      return 55LL;
    }
    unsigned int v15 = *(_DWORD *)(sysctls + 236);
    *(_DWORD *)(a1 + 388) = v13;
    uint64_t v16 = *(void *)(*(void *)(a1 + 456) + 24LL);
    if ((*(_BYTE *)(a1 + 432) & 4) != 0)
    {
      if (v16)
      {
        uint64_t all_stats = nw_protocol_tcp_get_all_stats();
        if (all_stats) {
          *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 388);
        }
      }
    }

    else if (v16)
    {
      uint64_t v17 = nw_protocol_tcp_get_all_stats();
      if (v17) {
        *(_DWORD *)(v17 + 100) = *(_DWORD *)(a1 + 388);
      }
    }

    unsigned int v29 = *(_DWORD *)(a1 + 388);
    if (*(_DWORD *)(a1 + 392) > v29) {
      *(_DWORD *)(a1 + 392) = v29;
    }
    *(_DWORD *)(a1 + 436) = v13;
    if (v15 > 0x71C71C)
    {
      sbflush(a1 + 384);
      *(_DWORD *)(a1 + 388) = 0;
      uint64_t v30 = *(void *)(*(void *)(a1 + 456) + 24LL);
      if ((*(_BYTE *)(a1 + 432) & 4) != 0)
      {
        if (v30)
        {
          uint64_t v48 = nw_protocol_tcp_get_all_stats();
          if (v48) {
            *(_DWORD *)(v48 + 88) = *(_DWORD *)(a1 + 388);
          }
        }
      }

      else if (v30)
      {
        uint64_t v31 = nw_protocol_tcp_get_all_stats();
        if (v31) {
          *(_DWORD *)(v31 + 100) = *(_DWORD *)(a1 + 388);
        }
      }

      return 55LL;
    }

    *(_DWORD *)(a1 + 492) = v15;
    uint64_t v32 = *(void *)(*(void *)(a1 + 560) + 24LL);
    if ((*(_BYTE *)(a1 + 536) & 4) != 0)
    {
      if (v32)
      {
        uint64_t v49 = nw_protocol_tcp_get_all_stats();
        if (v49) {
          *(_DWORD *)(v49 + 88) = *(_DWORD *)(a1 + 492);
        }
      }
    }

    else if (v32)
    {
      uint64_t v33 = nw_protocol_tcp_get_all_stats();
      if (v33) {
        *(_DWORD *)(v33 + 100) = *(_DWORD *)(a1 + 492);
      }
    }

    unsigned int v50 = *(_DWORD *)(a1 + 496);
    unsigned int v51 = *(_DWORD *)(a1 + 492);
    if (v50 <= v51)
    {
      *(_DWORD *)(a1 + 540) = v15;
      if (!v50)
      {
LABEL_95:
        *(_DWORD *)(a1 + 496) = 1;
        unsigned int v52 = *(_DWORD *)(a1 + 392);
        if (v52) {
          goto LABEL_99;
        }
        goto LABEL_96;
      }
    }

    else
    {
      *(_DWORD *)(a1 + 496) = v51;
      *(_DWORD *)(a1 + 540) = v15;
      if (!v51) {
        goto LABEL_95;
      }
    }

    unsigned int v52 = *(_DWORD *)(a1 + 392);
    if (v52)
    {
LABEL_99:
      unsigned int v53 = *(_DWORD *)(a1 + 388);
      if (v52 > v53) {
        *(_DWORD *)(a1 + 392) = v53;
      }
      goto LABEL_7;
    }

LABEL_96:
    unsigned int v52 = 2048;
    *(_DWORD *)(a1 + 392) = 2048;
    goto LABEL_99;
  }

uint64_t tcp_usr_bind(uint64_t *a1, uint64_t a2)
{
  v7[2] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0)) {
    return 47LL;
  }
  if (*(_WORD *)(v2 + 2226)) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 492)) {
    return 22LL;
  }
  v7[0] = 0LL;
  v7[1] = 0LL;
  if (*(_BYTE *)a2 != 16) {
    return 22LL;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, void *, uint64_t, __n128))(*(void *)(v2 + 2136) + 8LL))( *(void *)(v2 + 224),  a2,  16LL,  v7,  16LL,  v5);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v7[0])) {
      *(_DWORD *)(v2 + 492) = HIDWORD(v7[0]);
    }
    uint64_t result = 0LL;
    *(_WORD *)(v2 + 2226) = WORD1(v7[0]);
  }

  return result;
}

uint64_t tcp_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      uint64_t v5 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      unsigned int v15 = "tcp_usr_connect";
      __int16 v16 = 2082;
      uint64_t v17 = a1 + 604;
      __int16 v18 = 1024;
      int v19 = v4;
      uint64_t v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v12 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v15 = "tcp_usr_connect";
          __int16 v16 = 2082;
          uint64_t v17 = v5;
          __int16 v18 = 1024;
          int v19 = v4;
          _os_log_impl( &dword_1879E5000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }

      if (v6) {
        free(v6);
      }
      return v4;
    }

    return 22LL;
  }

  uint64_t v8 = *(void *)(v2 + 240);
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0 && (*(_BYTE *)(sysctls + 160) & 2) != 0) {
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (*(_BYTE *)(a2 + 1) && (*(_BYTE *)(a2 + 1) != 2 || (*(_DWORD *)(a2 + 4) & 0xF0) == 0xE0)) {
    return 47LL;
  }
  uint64_t v4 = tcp_connect(v8, a2);
  if (!(_DWORD)v4)
  {
    uint64_t v10 = *(void *)(*(void *)a1 + 240LL);
    (*(void (**)(void))(*(void *)(*(void *)(v10 + 80) + 2136LL) + 64LL))(*(void *)(a1 + 24));
    if ((*(_BYTE *)(a1 + 368) & 0x20) == 0) {
      return tcp_output(v10);
    }
    tcp_mss(v10, -1, 0LL);
    uint64_t v4 = 0LL;
    int v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
  }

  return v4;
}

uint64_t tcp_usr_detach(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  (*(void (**)(void))(a1[1] + 32))();
  uint64_t v4 = *(void *)(v1 + 240);
  if (v4)
  {
    uint64_t v5 = nw_tcp_access_globals((uint64_t)a1);
    calculate_tcp_clock(v5);
    tcp_disconnect(v4);
  }

  return 0LL;
}

uint64_t tcp_usr_disconnect(uint64_t *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(void))(a1[1] + 32))();
  if (!v1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  uint64_t v3 = *(void *)(v1 + 240);
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v4);
  if (v3) {
    tcp_disconnect(v3);
  }
  return 0LL;
}

uint64_t tcp_usr_listen(uint64_t *a1)
{
  v8[2] = *MEMORY[0x1895F89C0];
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  double v6 = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226)) {
    goto LABEL_6;
  }
  if (*(_DWORD *)(v1 + 492)) {
    return 22LL;
  }
  v8[0] = 0LL;
  v8[1] = 0LL;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void *, uint64_t, double))(*(void *)(v1 + 2136) + 8LL))( *(void *)(v1 + 224),  0LL,  16LL,  v8,  16LL,  v6);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v8[0])) {
      *(_DWORD *)(v1 + 492) = HIDWORD(v8[0]);
    }
    *(_WORD *)(v1 + 2226) = WORD1(v8[0]);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    uint64_t result = a1[3];
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        uint64_t v7 = result;
        uint64_t result = 0LL;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }

  return result;
}

uint64_t tcp_usr_rcvd(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = *(int **)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  calculate_tcp_clock(v5);
  if (v4)
  {
    if (*(_DWORD *)(sysctls + 68) == 1)
    {
      unsigned int v6 = *((_DWORD *)a1 + 135);
      if (v6)
      {
        unsigned int v7 = *((_DWORD *)a1 + 123);
        int v8 = v7 - v6;
        if (v7 > v6)
        {
          unsigned int v9 = v6 >> 4;
          if (v4[31] - v4[30] > v9) {
            unsigned int v9 = v4[31] - v4[30];
          }
          if (!v9) {
            unsigned int v9 = 8 * v4[49];
          }
          int v10 = v7 - v9 - *((_DWORD *)a1 + 122);
          if (v10 < v8) {
            int v8 = v10;
          }
          if (v8 >= 1)
          {
            unsigned int v11 = v7 - v8;
            if (v11 <= 0x71C71C)
            {
              *((_DWORD *)a1 + 123) = v11;
              uint64_t v12 = *(void *)(a1[70] + 24);
              if ((a1[67] & 4) != 0)
              {
                if (v12)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *((_DWORD *)a1 + 123);
                  }
                }
              }

              else if (v12)
              {
                uint64_t v13 = nw_protocol_tcp_get_all_stats();
                if (v13) {
                  *(_DWORD *)(v13 + 100) = *((_DWORD *)a1 + 123);
                }
              }

              unsigned int v15 = *((_DWORD *)a1 + 123);
              if (*((_DWORD *)a1 + 124) > v15) {
                *((_DWORD *)a1 + 124) = v15;
              }
            }
          }
        }
      }
    }

    if (v4[3] >= 4) {
      tcp_output((uint64_t)v4);
    }
  }

  return 0LL;
}

uint64_t tcp_usr_rcvoob()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v4 = "tcp_usr_rcvoob";
  unsigned int v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v4 = "tcp_usr_rcvoob";
      _os_log_impl( &dword_1879E5000,  v1,  OS_LOG_TYPE_ERROR,  "%{public}s currently not supported, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v0) {
    free(v0);
  }
  return 0LL;
}

uint64_t tcp_usr_send(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)a1;
  if (!*(void *)a1 || *(_DWORD *)(v5 + 232) == 3)
  {
    if (a3)
    {
      unsigned int v7 = (void *)(a3 + 80);
      unsigned int v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 80);
      if (v6)
      {
        uint64_t v8 = *(void *)(a3 + 88);
        *unsigned int v7 = 0LL;
        *(void *)(a3 + 88) = 0LL;
        v6(a3, 1LL, v8);
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        int v26 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v29 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            _os_log_impl( &dword_1879E5000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        if (v26) {
          free(v26);
        }
      }
    }

    if (v5) {
      return 41LL;
    }
    else {
      return 54LL;
    }
  }

  if (a4) {
    BOOL v14 = *(unsigned __int8 *)(a4 + 1) == 30;
  }
  else {
    BOOL v14 = 0;
  }
  unsigned int v15 = *(int **)(v5 + 240);
  uint64_t v16 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v16);
  if ((*(_BYTE *)(a1 + 367) & 1) == 0 || (*(_BYTE *)(a1 + 433) & 0x10) != 0)
  {
    if ((a2 & 1) != 0) {
      goto LABEL_16;
    }
    goto LABEL_17;
  }

  int v27 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "tcp_usr_send";
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v28);
    if ((a2 & 1) != 0)
    {
LABEL_16:
      if ((*(_BYTE *)(a1 + 368) & 0x20) == 0) {
        goto LABEL_36;
      }
    }

LABEL_17:
    *(void *)(a3 + 32) = 0LL;
    *(void *)(a3 + 40) = buf;
    *(void *)__int128 buf = a3;
    *(void *)&buf[8] = a3 + 32;
    int v17 = *(_DWORD *)(a3 + 52);
    if (v17) {
      int v18 = v17 - (*(_DWORD *)(a3 + 56) + *(_DWORD *)(a3 + 60));
    }
    else {
      int v18 = 0;
    }
    sbappendstream((int *)(a1 + 384), (uint64_t *)buf, v18, 0);
    if (a4 && v15[3] <= 1)
    {
      if (v14)
      {
        uint64_t v9 = tcp6_connect((uint64_t)v15, a4);
        if ((_DWORD)v9) {
          return v9;
        }
      }

      else
      {
        uint64_t v9 = tcp_connect((uint64_t)v15, a4);
        if ((_DWORD)v9) {
          return v9;
        }
      }

      v15[35] = 4096;
      v15[63] = 4096;
      tcp_mss((uint64_t)v15, -1, 0LL);
    }

    if ((a2 & 2) != 0)
    {
      *(_WORD *)(a1 + 376) |= 0x10u;
      uint64_t v20 = *(void *)(a1 + 32);
      if (v20)
      {
        uint64_t v21 = *(void (**)(uint64_t))(v20 + 16);
        if (v21) {
          v21(a1);
        }
      }

      unsigned int v15 = (int *)tcp_usrclosed((uint64_t)v15, v19);
    }

    if (v15)
    {
      if ((a2 & 4) != 0)
      {
        v15[22] |= 0x10000u;
        uint64_t v9 = tcp_output((uint64_t)v15);
        v15[22] &= ~0x10000u;
        __int16 v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0) {
          goto LABEL_39;
        }
      }

      else
      {
        uint64_t v9 = tcp_output((uint64_t)v15);
        __int16 v22 = *(_WORD *)(a1 + 376);
        if ((v22 & 4) != 0) {
          goto LABEL_39;
        }
      }

      return v9;
    }

LABEL_36:
    uint64_t v9 = 0LL;
    __int16 v22 = *(_WORD *)(a1 + 376);
    if ((v22 & 4) != 0)
    {
LABEL_39:
      if ((v22 & 0x100) != 0)
      {
        return 35LL;
      }

      else if ((*(_BYTE *)(a1 + 828) & 2) == 0)
      {
        __nwlog_tcp_log();
        uint64_t v23 = a1 + 604;
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_usr_send";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        int v24 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          int v25 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_usr_send";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v23;
            _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s NBIO not set, backtrace limit exceeded",  buf,  0x16u);
          }
        }

        if (v24) {
          free(v24);
        }
      }
    }

    return v9;
  }

  __break(1u);
  return result;
}

                *(_DWORD *)(v12 + 196) = *(_DWORD *)(v12 + 196) - v13 + v17;
LABEL_3:
                uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(v9[1] + 24LL))(v9, 1LL, v2);
                goto LABEL_4;
              default:
LABEL_35:
                int v17 = *(_DWORD *)(v12 + 156);
                goto LABEL_36;
            }

            *(_WORD *)(v12 + 734) = v13;
            goto LABEL_34;
          }
        }

        __clrex();
      }
    }

uint64_t tcp_usr_shutdown(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  if (!*(void *)a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  *(_WORD *)(a1 + 376) |= 0x10u;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void (**)(uint64_t))(v4 + 16);
    if (v5) {
      v5(a1);
    }
  }

  uint64_t v6 = *(void *)(v1 + 240);
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v7);
  uint64_t result = tcp_usrclosed(v6, v8);
  if (result) {
    return tcp_output(result);
  }
  return result;
}

uint64_t tcp_usr_preconnect(_DWORD *a1)
{
  uint64_t result = tcp_output(*(void *)(*(void *)a1 + 240LL));
  if ((a1[92] & 0x30) != 0) {
    a1[92] &= a1[92] & 0x10 ^ 0xFFFFFFDF;
  }
  return result;
}

uint64_t tcp_usrclosed(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v3 = *(_DWORD *)(a1 + 12);
  switch(v3)
  {
    case 0:
    case 1:
    case 2:
      tcp_close(a1);
      return 0LL;
    case 3:
      *(_DWORD *)(a1 + 88) |= 0x800u;
      goto LABEL_17;
    case 4:
      *(_DWORD *)(a1 + 12) = 6;
      uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v12 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v13 = (const char *)(v4 + 604);
            BOOL v14 = tcpstates[*(int *)(v2 + 12)];
            int v18 = 136446722;
            uint64_t v19 = "tcp_usrclosed";
            if (!v4) {
              uint64_t v13 = "";
            }
            __int16 v20 = 2082;
            uint64_t v21 = v13;
            __int16 v22 = 2082;
            uint64_t v23 = v14;
            _os_log_impl( &dword_1879E5000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  (uint8_t *)&v18,  0x20u);
          }
        }
      }

      if (!*(void *)(*(void *)(*(void *)(v2 + 80) + 224LL) + 24LL)) {
        goto LABEL_17;
      }
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats) {
        goto LABEL_17;
      }
      int v6 = 6;
      break;
    case 5:
      *(_DWORD *)(a1 + 12) = 8;
      uint64_t v7 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if (!v7 || (*(_BYTE *)(v7 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          unsigned int v15 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = (const char *)(v7 + 604);
            int v17 = tcpstates[*(int *)(v2 + 12)];
            int v18 = 136446722;
            uint64_t v19 = "tcp_usrclosed";
            if (!v7) {
              uint64_t v16 = "";
            }
            __int16 v20 = 2082;
            uint64_t v21 = v16;
            __int16 v22 = 2082;
            uint64_t v23 = v17;
            _os_log_impl( &dword_1879E5000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s state change to %{public}s",  (uint8_t *)&v18,  0x20u);
          }
        }
      }

      if (!*(void *)(*(void *)(*(void *)(v2 + 80) + 224LL) + 24LL)) {
        goto LABEL_17;
      }
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (!all_stats) {
        goto LABEL_17;
      }
      int v6 = 8;
      break;
    default:
      goto LABEL_18;
  }

  *(_DWORD *)(all_stats + 136) = v6;
LABEL_17:
  int v3 = *(_DWORD *)(v2 + 12);
LABEL_18:
  if (v3 >= 9)
  {
    uint64_t v8 = *(void *)(*(void *)(v2 + 80) + 224LL);
    *(_WORD *)(v8 + 376) = *(_WORD *)(v8 + 376) & 0xDFC1 | 0x2030;
    uint64_t v9 = *(void *)(v8 + 32);
    if (v9)
    {
      int v10 = *(void (**)(uint64_t, uint64_t))(v9 + 56);
      if (v10)
      {
        v10(v8, a2);
        int v3 = *(_DWORD *)(v2 + 12);
      }
    }

    if (v3 == 9) {
      tcp_set_finwait_timeout(v2);
    }
  }

  return v2;
}

uint64_t tcp6_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 480) || *(_DWORD *)(v4 + 484) || *(_DWORD *)(v4 + 488) || *(_DWORD *)(v4 + 492))
    {
      uint64_t v20 = 22LL;
      goto LABEL_49;
    }

    int v25 = 0;
    memset(v24, 0, sizeof(v24));
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void, uint64_t, void *, uint64_t))(*(void *)(v4 + 2136) + 8LL))( v5,  0LL,  28LL,  v24,  28LL);
    if ((_DWORD)v20) {
      goto LABEL_49;
    }
    *(_WORD *)(v4 + 2226) = WORD1(v24[0]);
  }

  if (*(_BYTE *)a2 != 28)
  {
    uint64_t v20 = 22LL;
    if (v5) {
      goto LABEL_44;
    }
    goto LABEL_45;
  }

  if (*(_BYTE *)(a2 + 1) != 30)
  {
    uint64_t v20 = 47LL;
    if (v5) {
      goto LABEL_44;
    }
LABEL_45:
    uint64_t v21 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      __int16 v22 = "";
      if (v5) {
        __int16 v22 = (const char *)(v5 + 604);
      }
      LODWORD(v24[0]) = 136446466;
      *(void *)((char *)v24 + 4) = "tcp6_connect";
      WORD2(v24[1]) = 2082;
      *(void *)((char *)&v24[1] + 6) = v22;
      _os_log_impl( &dword_1879E5000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s ipv6 pcb local address lookup failed",  (uint8_t *)v24,  0x16u);
    }

    goto LABEL_49;
  }

  if (!*(_WORD *)(a2 + 2))
  {
    uint64_t v20 = 49LL;
    if (!v5) {
      goto LABEL_45;
    }
LABEL_44:
    if ((*(_BYTE *)(v5 + 828) & 2) == 0) {
      goto LABEL_45;
    }
LABEL_49:
    tcp_drop(a1, v20);
    return v20;
  }

  *(_OWORD *)(v4 + 464) = *(_OWORD *)(a2 + 8);
  *(_WORD *)(v4 + 2224) = *(_WORD *)(a2 + 2);
  if (!*(_DWORD *)(v4 + 460))
  {
    int v6 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v6;
  }

  uint64_t v7 = *(int *)(sysctls + 184);
  uint64_t v8 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(v5 + 537) & 2) != 0) {
    uint64_t v8 = (int *)(v5 + 492);
  }
  int v9 = *v8;
  unsigned int v10 = v7;
  if (v7 <= 0xDu && 0x10000 << v7 < v9)
  {
    do
    {
      LOBYTE(v7) = v10 + 1;
      if (v10 > 0xC) {
        break;
      }
      int v12 = 0x20000 << v10++;
    }

    while (v12 < v9);
  }

  *(_BYTE *)(a1 + 262) = v7;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  uint64_t v13 = *(void *)(a1 + 1056);
  if (v13) {
    ++*(void *)(v13 + 376);
  }
  *(_DWORD *)(a1 + 12) = 2;
  if (*(void *)(v5 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 2;
    }
  }

  int v15 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
  int v16 = *(_DWORD *)(a1 + 680);
  if (!v16) {
    int v16 = *(_DWORD *)(sysctls + 188);
  }
  *(_DWORD *)(a1 + 40) = v16 + v15 - *(_DWORD *)(a1 + 64);
  int v17 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v17;
  *(_DWORD *)(a1 + 152) = v17;
  *(_DWORD *)(a1 + 96) = v17;
  *(_DWORD *)(a1 + 100) = v17;
  *(_DWORD *)(a1 + 92) = v17;
  if (!*(void *)(v5 + 24)) {
    return 0LL;
  }
  uint64_t v18 = nw_protocol_tcp_get_all_stats();
  if (v18) {
    *(_DWORD *)(v18 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  }
  if (!*(void *)(v5 + 24)) {
    return 0LL;
  }
  uint64_t v19 = nw_protocol_tcp_get_all_stats();
  uint64_t v20 = 0LL;
  if (v19) {
    ++*(_DWORD *)(v19 + 60);
  }
  return v20;
}

uint64_t tcp_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  int v6 = *(unsigned __int16 *)(v4 + 2226);
  if (!*(_WORD *)(v4 + 2226))
  {
    if (*(_DWORD *)(v4 + 492))
    {
LABEL_39:
      uint64_t v24 = 22LL;
LABEL_58:
      tcp_drop(a1, v24);
      return v24;
    }

    *(void *)unsigned int v29 = 0LL;
    *(void *)&v29[8] = 0LL;
    uint64_t v24 = (*(uint64_t (**)(uint64_t, void, uint64_t, _BYTE *, uint64_t))(*(void *)(v4 + 2136) + 8LL))( v5,  0LL,  16LL,  v29,  16LL);
    if ((_DWORD)v24) {
      goto LABEL_58;
    }
    if (*(_DWORD *)&v29[4]) {
      *(_DWORD *)(v4 + 492) = *(_DWORD *)&v29[4];
    }
    int v6 = *(unsigned __int16 *)&v29[2];
    *(_WORD *)(v4 + 2226) = *(_WORD *)&v29[2];
  }

  if (*(_BYTE *)a2 != 16)
  {
    uint64_t v24 = 22LL;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }

  if (*(_BYTE *)(a2 + 1) != 2)
  {
    uint64_t v24 = 47LL;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }

  int v7 = *(unsigned __int16 *)(a2 + 2);
  if (!*(_WORD *)(a2 + 2))
  {
    uint64_t v24 = 49LL;
    if (!v5) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }

  int v8 = *(_DWORD *)(a2 + 4);
  if (v8 == -1)
  {
    int v25 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v29 = 136446210;
      *(void *)&v29[4] = "in_pcbladdr";
      _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s INADDR_BROADCAST destination not supported",  v29,  0xCu);
    }

    uint64_t v24 = 61LL;
    if (!v5) {
      goto LABEL_54;
    }
LABEL_53:
    if ((*(_BYTE *)(v5 + 828) & 2) != 0) {
      goto LABEL_58;
    }
LABEL_54:
    uint64_t v26 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v27 = "";
      if (v5) {
        int v27 = (const char *)(v5 + 604);
      }
      *(_DWORD *)unsigned int v29 = 136446466;
      *(void *)&v29[4] = "tcp_connect";
      *(_WORD *)&v29[12] = 2082;
      *(void *)&v29[14] = v27;
      _os_log_impl( &dword_1879E5000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s ipv4 pcb local address lookup failed",  v29,  0x16u);
    }

    goto LABEL_58;
  }

  if (*(_DWORD *)(v4 + 492) == v8 && v6 == v7) {
    goto LABEL_39;
  }
  *(_DWORD *)(v4 + 476) = v8;
  *(_WORD *)(v4 + 2224) = v7;
  if (!*(_DWORD *)(v4 + 460))
  {
    int v10 = inp_calc_flowhash_flow_hash++;
    *(_DWORD *)(v4 + 460) = v10;
  }

  uint64_t v11 = *(int *)(sysctls + 184);
  int v12 = (int *)(sysctls + 72);
  if ((*(_BYTE *)(v5 + 537) & 2) != 0) {
    int v12 = (int *)(v5 + 492);
  }
  int v13 = *v12;
  unsigned int v14 = v11;
  if (v11 <= 0xDu && 0x10000 << v11 < v13)
  {
    do
    {
      LOBYTE(v11) = v14 + 1;
      if (v14 > 0xC) {
        break;
      }
      int v16 = 0x20000 << v14++;
    }

    while (v16 < v13);
  }

  *(_BYTE *)(a1 + 262) = v11;
  *(_WORD *)(v5 + 376) = *(_WORD *)(v5 + 376) & 0xFFF1 | 4;
  uint64_t v17 = *(void *)(a1 + 1056);
  if (v17) {
    ++*(void *)(v17 + 376);
  }
  *(_DWORD *)(a1 + 12) = 2;
  if (*(void *)(v5 + 24))
  {
    uint64_t all_stats = nw_protocol_tcp_get_all_stats();
    if (all_stats) {
      *(_DWORD *)(all_stats + 136) = 2;
    }
  }

  int v19 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
  int v20 = *(_DWORD *)(a1 + 680);
  if (!v20) {
    int v20 = *(_DWORD *)(sysctls + 188);
  }
  *(_DWORD *)(a1 + 40) = v20 + v19 - *(_DWORD *)(a1 + 64);
  int v21 = tcp_new_isn(a1);
  *(_DWORD *)(a1 + 112) = v21;
  *(_DWORD *)(a1 + 152) = v21;
  *(_DWORD *)(a1 + 96) = v21;
  *(_DWORD *)(a1 + 100) = v21;
  *(_DWORD *)(a1 + 92) = v21;
  if (!*(void *)(v5 + 24)) {
    return 0LL;
  }
  uint64_t v22 = nw_protocol_tcp_get_all_stats();
  if (v22) {
    *(_DWORD *)(v22 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
  }
  if (!*(void *)(v5 + 24)) {
    return 0LL;
  }
  uint64_t v23 = nw_protocol_tcp_get_all_stats();
  uint64_t v24 = 0LL;
  if (v23) {
    ++*(_DWORD *)(v23 + 60);
  }
  return v24;
}

void tcp_disconnect(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 224LL);
  if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v7 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = (const char *)(v2 + 604);
        int v9 = *(_DWORD *)(v2 + 360);
        int v10 = *(_DWORD *)(a1 + 12);
        if (!v2) {
          int v8 = "";
        }
        int v11 = 136446978;
        int v12 = "tcp_disconnect";
        __int16 v13 = 2082;
        unsigned int v14 = v8;
        __int16 v15 = 1024;
        int v16 = v9;
        __int16 v17 = 1024;
        int v18 = v10;
        _os_log_impl( &dword_1879E5000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s so_usecount %u t_state %u",  (uint8_t *)&v11,  0x22u);
      }
    }
  }

  if (*(_DWORD *)(v2 + 488) || *(_WORD *)(a1 + 224) || (*(_BYTE *)(v2 + 368) & 8) != 0) {
    goto LABEL_18;
  }
  if (*(int *)(a1 + 12) <= 3)
  {
    tcp_close(a1);
    return;
  }

  if ((*(_BYTE *)(v2 + 372) & 0x80) != 0 && !*(_DWORD *)(v2 + 16))
  {
LABEL_18:
    tcp_drop(a1, 0);
  }

  else
  {
    *(_WORD *)(v2 + 376) = *(_WORD *)(v2 + 376) & 0xFFC3 | 0x38;
    int v3 = *(void (***)(uint64_t))(v2 + 32);
    if (v3)
    {
      if (!*v3 || ((*v3)(v2), (int v3 = *(void (***)(uint64_t))(v2 + 32)) != 0LL))
      {
        uint64_t v4 = v3[3];
        if (v4) {
          v4(v2);
        }
      }
    }

    tcp_input_aggregate_end(*(void *)(*(void *)(a1 + 80) + 224LL), *(void *)(*(void *)(a1 + 80) + 240LL));
    sbflush(v2 + 488);
    uint64_t v6 = tcp_usrclosed(a1, v5);
    if (v6) {
      tcp_output(v6);
    }
  }

uint64_t tcp6_usr_bind(uint64_t *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *a1;
  if (!*a1 || *(_DWORD *)(v2 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = nw_tcp_access_globals(*(void *)(v2 + 224));
  v5.n128_f64[0] = calculate_tcp_clock(v4);
  char v6 = *(_BYTE *)(v2 + 2236);
  *(_BYTE *)(v2 + 2236) = v6 & 0xFC | 2;
  if ((*(_BYTE *)(v2 + 2229) & 0x80) == 0 && !*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12))
  {
    int v8 = *(_DWORD *)(a2 + 16);
    if (v8 == -65536)
    {
      v10.i64[0] = 0LL;
      LOWORD(v9) = 528;
      WORD1(v9) = *(_WORD *)(a2 + 2);
      HIDWORD(v9) = *(_DWORD *)(a2 + 20);
      *(_BYTE *)(v2 + 2236) = v6 & 0xFC | 1;
      return in_pcbbind(v2, &v9);
    }

    if (!v8 && !*(_DWORD *)(a2 + 20)) {
      *(_BYTE *)(v2 + 2236) = v6 | 3;
    }
  }

  if (*(_WORD *)(v2 + 2226)) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 480)) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 484)) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 488)) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 492)) {
    return 22LL;
  }
  uint64_t v9 = 0LL;
  int32x4_t v10 = 0uLL;
  int v11 = 0;
  if (*(_BYTE *)a2 != 28) {
    return 22LL;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *, uint64_t, __n128))(*(void *)(v2 + 2136) + 8LL))( *(void *)(v2 + 224),  a2,  28LL,  &v9,  28LL,  v5);
  if (!(_DWORD)result)
  {
    uint64_t result = 0LL;
    *(_WORD *)(v2 + 2226) = WORD1(v9);
  }

  return result;
}

uint64_t tcp6_usr_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 22LL;
  }
  if (*(_DWORD *)(v2 + 232) == 3)
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 378);
    if (*(_WORD *)(a1 + 378))
    {
      *(_WORD *)(a1 + 378) = 0;
      __nwlog_obj();
      uint64_t v5 = a1 + 604;
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)__int16 v15 = "tcp6_usr_connect";
      *(_WORD *)&v15[8] = 2082;
      *(void *)&v15[10] = a1 + 604;
      __int16 v16 = 1024;
      int v17 = v4;
      char v6 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v12 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)__int16 v15 = "tcp6_usr_connect";
          *(_WORD *)&v15[8] = 2082;
          *(void *)&v15[10] = v5;
          __int16 v16 = 1024;
          int v17 = v4;
          _os_log_impl( &dword_1879E5000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s this should be handled by user_north_signal_error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }

      if (v6) {
        free(v6);
      }
      return v4;
    }

    return 22LL;
  }

  uint64_t v8 = *(void *)(v2 + 240);
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0 && (*(_BYTE *)(sysctls + 160) & 2) != 0) {
    *(_DWORD *)(v8 + 740) |= 0x400000u;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (!*(_DWORD *)(a2 + 8) && !*(_DWORD *)(a2 + 12) && *(_DWORD *)(a2 + 16) == -65536)
  {
    if ((*(_BYTE *)(v2 + 2229) & 0x80) == 0)
    {
      *(void *)&v15[4] = 0LL;
      *(_WORD *)__int128 buf = 528;
      *(_WORD *)&buf[2] = *(_WORD *)(a2 + 2);
      *(_DWORD *)__int16 v15 = *(_DWORD *)(a2 + 20);
      *(_BYTE *)(v2 + 2236) = *(_BYTE *)(v2 + 2236) & 0xFC | 1;
      uint64_t v4 = tcp_connect(v8, (uint64_t)buf);
      if (!(_DWORD)v4) {
        return tcp_connect_complete(a1);
      }
      return v4;
    }

    return 22LL;
  }

  *(_BYTE *)(v2 + 2236) = *(_BYTE *)(v2 + 2236) & 0xFC | 2;
  uint64_t v4 = tcp6_connect(v8, a2);
  if (!(_DWORD)v4)
  {
    uint64_t v10 = *(void *)(*(void *)a1 + 240LL);
    (*(void (**)(void))(*(void *)(*(void *)(v10 + 80) + 2136LL) + 64LL))(*(void *)(a1 + 24));
    if ((*(_BYTE *)(a1 + 368) & 0x20) == 0) {
      return tcp_output(v10);
    }
    tcp_mss(v10, -1, 0LL);
    uint64_t v4 = 0LL;
    int v13 = *(_DWORD *)(v10 + 196);
    *(_DWORD *)(v10 + 140) = v13;
    *(_DWORD *)(v10 + 252) = v13;
  }

  return v4;
}

uint64_t tcp6_usr_listen(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(_DWORD *)(v1 + 232) == 3) {
    return 22LL;
  }
  uint64_t v4 = *(void *)(v1 + 240);
  uint64_t v5 = nw_tcp_access_globals(*(void *)(v1 + 224));
  v6.n128_f64[0] = calculate_tcp_clock(v5);
  if (*(_WORD *)(v1 + 2226)) {
    goto LABEL_6;
  }
  char v8 = *(_BYTE *)(v1 + 2236);
  *(_BYTE *)(v1 + 2236) = v8 & 0xFE;
  if ((*(_BYTE *)(v1 + 2229) & 0x80) == 0) {
    *(_BYTE *)(v1 + 2236) = v8 | 1;
  }
  if (*(_DWORD *)(v1 + 480) || *(_DWORD *)(v1 + 484) || *(_DWORD *)(v1 + 488) || *(_DWORD *)(v1 + 492)) {
    return 22LL;
  }
  int v11 = 0;
  int32x4_t v10 = 0uLL;
  uint64_t v9 = 0LL;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *, uint64_t, __n128))(*(void *)(v1 + 2136) + 8LL))( *(void *)(v1 + 224),  0LL,  28LL,  &v9,  28LL,  v6);
  if (!(_DWORD)result)
  {
    *(_WORD *)(v1 + 2226) = WORD1(v9);
LABEL_6:
    *(_DWORD *)(v4 + 12) = 1;
    uint64_t result = a1[3];
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result)
      {
        uint64_t v7 = result;
        uint64_t result = 0LL;
        *(_DWORD *)(v7 + 136) = 1;
      }
    }
  }

  return result;
}

uint64_t tcp_connect_complete(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 240LL);
  (*(void (**)(void))(*(void *)(*(void *)(v2 + 80) + 2136LL) + 64LL))(*(void *)(a1 + 24));
  if ((*(_BYTE *)(a1 + 368) & 0x20) == 0) {
    return tcp_output(v2);
  }
  tcp_mss(v2, -1, 0LL);
  int v4 = *(_DWORD *)(v2 + 196);
  *(_DWORD *)(v2 + 140) = v4;
  *(_DWORD *)(v2 + 252) = v4;
  return 0LL;
}

void tcp_fill_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v63 = *MEMORY[0x1895F89C0];
  *(void *)(a4 + 400) = 0LL;
  *(_OWORD *)(a4 + 368) = 0u;
  *(_OWORD *)(a4 + 384) = 0u;
  *(_OWORD *)(a4 + 336) = 0u;
  *(_OWORD *)(a4 + 352) = 0u;
  *(_OWORD *)(a4 + 304) = 0u;
  *(_OWORD *)(a4 + 320) = 0u;
  *(_OWORD *)(a4 + 272) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 240) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 192) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2 && a3)
  {
    char v8 = (os_unfair_lock_s *)(a1 + 1864);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1864));
    int v9 = *(_DWORD *)(a1 + 12);
    *(_BYTE *)a4 = v9;
    *(_DWORD *)(a4 + 280) = *(_DWORD *)(a2 + 460);
    int v10 = *(_DWORD *)(a1 + 88);
    if ((~v10 & 0x180) == 0) {
      *(_BYTE *)(a4 + 1) |= 1u;
    }
    int v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x20) != 0) {
      *(_BYTE *)(a4 + 1) |= 2u;
    }
    if ((~v10 & 0x60) == 0)
    {
      *(_BYTE *)(a4 + 1) |= 4u;
      *(_WORD *)(a4 + 2) = *(_WORD *)(a1 + 260);
    }

    if ((~*(_DWORD *)(a1 + 348) & 3) == 0) {
      *(_BYTE *)(a4 + 1) |= 8u;
    }
    if ((v10 & 0x200000) != 0 || *(_WORD *)(a1 + 226)) {
      *(_DWORD *)(a4 + 4) |= 1u;
    }
    if ((v10 & 0x2000000) != 0) {
      *(_DWORD *)(a4 + 4) |= 2u;
    }
    int v12 = *(_DWORD *)(a1 + 28);
    if (v12) {
      int v12 = *(_DWORD *)(a1 + 192);
    }
    *(_DWORD *)(a4 + 8) = v12;
    int v13 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(a4 + 12) = v13;
    *(_DWORD *)(a4 + 16) = v13;
    *(_DWORD *)(a4 + 20) = *(_DWORD *)(a1 + 236);
    *(_DWORD *)(a4 + 24) = *(int *)(a1 + 200) >> 5;
    *(_DWORD *)(a4 + 292) = *(_DWORD *)(a1 + 1968) >> 5;
    *(_DWORD *)(a4 + 28) = *(int *)(a1 + 208) >> 4;
    *(_DWORD *)(a4 + 32) = *(_DWORD *)(a1 + 232) >> 5;
    *(int32x2_t *)(a4 + 36) = vrev64_s32(*(int32x2_t *)(a1 + 144));
    *(_DWORD *)(a4 + 64) = *(_DWORD *)(a3 + 384);
    unsigned int v15 = *(_DWORD *)(a1 + 120);
    unsigned int v14 = *(_DWORD *)(a1 + 124);
    BOOL v16 = v14 >= v15;
    unsigned int v17 = v14 - v15;
    if (!v16) {
      unsigned int v17 = 0;
    }
    *(_DWORD *)(a4 + 44) = v17;
    *(_DWORD *)(a4 + 48) = *(_DWORD *)(a1 + 140);
    *(_DWORD *)(a4 + 52) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a4 + 56) = v15;
    if ((v11 & 8) != 0)
    {
      uint64_t v18 = *(void *)(a1 + 768);
      if (v18) {
        *(void *)(a4 + 132) = (8000 * *(_DWORD *)(v18 + 28));
      }
    }

    uint64_t v19 = *(void *)(a2 + 448);
    if (v19) {
      LODWORD(v19) = *(unsigned __int16 *)(v19 + 1072);
    }
    *(_DWORD *)(a4 + 60) = v19;
    int v20 = *(_OWORD **)(a2 + 248);
    *(_OWORD *)(a4 + 68) = v20[1];
    *(void *)(a4 + 84) = *(unsigned int *)(a1 + 712);
    *(void *)(a4 + 284) = *(unsigned int *)(a1 + 720);
    *(void *)(a4 + 92) = (*(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92));
    *(_OWORD *)(a4 + 100) = *v20;
    uint64_t v21 = *(void *)(a1 + 704);
    *(void *)&__int128 v22 = v21;
    *((void *)&v22 + 1) = HIDWORD(v21);
    *(_OWORD *)(a4 + 116) = v22;
    if (v9 >= 2) {
      *(_BYTE *)(a4 + 140) = *(_BYTE *)(a1 + 716);
    }
    char v23 = 0;
    uint64_t v24 = *(_OWORD **)(a2 + 256);
    *(_OWORD *)(a4 + 144) = *v24;
    *(_OWORD *)(a4 + 160) = v24[1];
    int v25 = *(_OWORD **)(a2 + 264);
    *(_OWORD *)(a4 + 176) = *v25;
    *(_OWORD *)(a4 + 192) = v25[1];
    uint64_t v26 = *(_OWORD **)(a2 + 272);
    *(_OWORD *)(a4 + 208) = *v26;
    *(_OWORD *)(a4 + 224) = v26[1];
    *(_DWORD *)(a4 + 240) = 0;
    if (*(unsigned __int16 *)(a1 + 226) >= 5u)
    {
      else {
        char v23 = 2;
      }
      *(_BYTE *)(a4 + 240) = v23;
    }

    if (*(unsigned __int8 *)(a1 + 311) >= 5u)
    {
      v23 |= 4u;
      *(_BYTE *)(a4 + 240) = v23;
    }

    uint64_t v27 = *(void *)(a1 + 80);
    if (v27)
    {
      uint64_t v28 = *(void *)(v27 + 448);
      if (v28)
      {
        if ((*(_BYTE *)(v28 + 1052) & 8) != 0) {
          *(_BYTE *)(a4 + 240) = v23 | 1;
        }
      }
    }

    unsigned int v29 = *(_DWORD *)(a4 + 244) & 0xFFFFFFDF | (32 * (*(_WORD *)(a1 + 990) & 1));
    *(_DWORD *)(a4 + 244) = v29;
    unsigned int v30 = v29 & 0xFFFFFFBF | (((*(unsigned __int16 *)(a1 + 990) >> 1) & 1) << 6);
    *(_DWORD *)(a4 + 244) = v30;
    unsigned int v31 = v30 & 0xFFFFFF7F | (((*(unsigned __int16 *)(a1 + 990) >> 2) & 1) << 7);
    *(_DWORD *)(a4 + 244) = v31;
    unsigned int v32 = v31 & 0xFFFFFEFF | (((*(unsigned __int16 *)(a1 + 990) >> 3) & 1) << 8);
    *(_DWORD *)(a4 + 244) = v32;
    unsigned int v33 = v32 & 0xFFFFFFFE | (*(unsigned __int16 *)(a1 + 990) >> 4) & 1;
    *(_DWORD *)(a4 + 244) = v33;
    unsigned int v34 = v33 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)(a1 + 990) >> 5) & 1));
    *(_DWORD *)(a4 + 244) = v34;
    unsigned int v35 = v34 & 0xFFFFFFF7 | (8 * ((*(unsigned __int16 *)(a1 + 990) >> 6) & 1));
    *(_DWORD *)(a4 + 244) = v35;
    unsigned int v36 = v35 & 0xFFFFFFEF | (16 * ((*(unsigned __int16 *)(a1 + 990) >> 7) & 1));
    *(_DWORD *)(a4 + 244) = v36;
    unsigned int v37 = v36 & 0xFFFFFFFB | (4 * (HIBYTE(*(unsigned __int16 *)(a1 + 990)) & 1));
    *(_DWORD *)(a4 + 244) = v37;
    unsigned int v38 = v37 & 0xFFFFFDFF | (((*(unsigned __int16 *)(a1 + 990) >> 9) & 1) << 9);
    *(_DWORD *)(a4 + 244) = v38;
    unsigned int v39 = v38 & 0xFFFFFBFF | (((*(unsigned __int16 *)(a1 + 990) >> 10) & 1) << 10);
    *(_DWORD *)(a4 + 244) = v39;
    unsigned int v40 = v39 & 0xFFFFF7FF | (((*(unsigned __int16 *)(a1 + 990) >> 11) & 1) << 11);
    *(_DWORD *)(a4 + 244) = v40;
    unsigned int v41 = v40 & 0xFFFFEFFF | (((*(unsigned __int16 *)(a1 + 990) >> 12) & 1) << 12);
    *(_DWORD *)(a4 + 244) = v41;
    unsigned int v42 = v41 & 0xFFFFDFFF | (((*(unsigned __int16 *)(a1 + 990) >> 13) & 1) << 13);
    *(_DWORD *)(a4 + 244) = v42;
    unsigned int v43 = v42 & 0xFFFFBFFF | (((*(unsigned __int16 *)(a1 + 990) >> 14) & 1) << 14);
    *(_DWORD *)(a4 + 244) = v43;
    unsigned int v44 = v43 & 0xFFFF7FFF | (((*(_DWORD *)(a1 + 348) & 0x100001) != 0) << 15);
    *(_DWORD *)(a4 + 244) = v44;
    unsigned int v45 = v44 & 0xFFFEFFFF | (((*(_DWORD *)(a1 + 348) & 0x200002) != 0) << 16);
    *(_DWORD *)(a4 + 244) = v45;
    int v46 = *(_DWORD *)(a1 + 348);
    if ((~v46 & 3) != 0)
    {
      int v50 = *(_DWORD *)(a1 + 740);
      if ((v50 & 0x10000000) == 0 && ((v50 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1)) {
        int v47 = ((~v46 & 0x300000) == 0) << 17;
      }
      else {
        int v47 = 0;
      }
    }

    else
    {
      int v47 = 0x20000;
    }

    unsigned int v51 = v47 | v45 & 0xFFFDFFFF;
    *(_DWORD *)(a4 + 244) = v51;
    unsigned int v52 = v51 & 0xFFFBFFFF | (((*(_DWORD *)(a1 + 348) >> 8) & 1) << 18);
    *(_DWORD *)(a4 + 244) = v52;
    unsigned int v53 = v52 & 0xFFF7FFFF | (((*(_DWORD *)(a1 + 348) >> 9) & 1) << 19);
    *(_DWORD *)(a4 + 244) = v53;
    unsigned int v54 = v53 & 0xFFEFFFFF | (((*(_DWORD *)(a1 + 88) >> 17) & 1) << 20);
    *(_DWORD *)(a4 + 244) = v54;
    uint64_t v55 = *(void *)(a2 + 448);
    if (v55)
    {
      if (*(unsigned __int8 *)(v55 + 1076) == 255 || *(_DWORD *)(v55 + 1024) == 255)
      {
        v54 |= 0x200000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
      }

      if (*(_DWORD *)(v55 + 1068) == 3 || *(_DWORD *)(v55 + 1032) == 3)
      {
        v54 |= 0x400000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
      }

      if (*(_DWORD *)(v55 + 1064) == 2 || *(_DWORD *)(v55 + 1028) == 2)
      {
        v54 |= 0x800000u;
        *(_DWORD *)(a4 + 244) = v54;
        uint64_t v55 = *(void *)(a2 + 448);
        if (*(_DWORD *)(v55 + 1064) == 2 && *(_DWORD *)(v55 + 1068) == 3 && (*(_BYTE *)(v55 + 1054) & 0x10) == 0)
        {
          v54 |= 0x1000000u;
          *(_DWORD *)(a4 + 244) = v54;
          uint64_t v55 = *(void *)(a2 + 448);
        }
      }

      if ((*(_BYTE *)(v55 + 1054) & 0x10) != 0)
      {
        v54 |= 0x2000000u;
        *(_DWORD *)(a4 + 244) = v54;
      }
    }

    if (*(_BYTE *)(a1 + 264) == 2)
    {
      v54 |= 0x4000000u;
      *(_DWORD *)(a4 + 244) = v54;
    }

    if (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(a3 + 369) & 0x40) != 0) {
      *(_DWORD *)(a4 + 244) = v54 | 0x8000000;
    }
    *(void *)&__int128 v56 = *(void *)(a1 + 352);
    *((void *)&v56 + 1) = *(void *)(a1 + 996);
    *(_OWORD *)(a4 + 248) = v56;
    *(_DWORD *)(a4 + 264) = *(_DWORD *)(a1 + 1004);
    *(void *)(a4 + 268) = *(void *)(a1 + 1016);
    *(_DWORD *)(a4 + 276) = *(_DWORD *)(a1 + 1024);
    *(void *)(a4 + 296) = *(void *)(a1 + 360);
    *(_OWORD *)(a4 + 304) = *(_OWORD *)(a1 + 368);
    *(_OWORD *)(a4 + 320) = *(_OWORD *)(a1 + 384);
    *(void *)(a4 + 336) = (*(_DWORD *)(a1 + 416) - 5);
    v57.i64[0] = -1LL;
    v57.i64[1] = -1LL;
    int8x16_t v58 = (int8x16_t)vaddq_s64(*(int64x2_t *)(a1 + 432), v57);
    *(int8x16_t *)(a4 + 344) = vextq_s8(v58, v58, 8uLL);
    *(void *)(a4 + 360) = *(void *)(a1 + 448);
    *(void *)(a4 + 368) = *(void *)(a1 + 464) - 1LL;
    *(void *)(a4 + 376) = *(void *)(a1 + 456) - 1LL;
    *(void *)(a4 + 384) = *(void *)(a1 + 472);
    os_unfair_lock_unlock(v8);
  }

  else
  {
    uint64_t v48 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
    {
      uint64_t v49 = "tp";
      if (!a2) {
        uint64_t v49 = "inp";
      }
      if (!a3) {
        uint64_t v49 = "so";
      }
      int v59 = 136446466;
      uint64_t v60 = "tcp_fill_info";
      __int16 v61 = 2082;
      uint64_t v62 = v49;
      _os_log_impl(&dword_1879E5000, v48, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v59, 0x16u);
    }
  }

__n128 tcp_connection_fill_info(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a1 && a2 && a3)
  {
    *(_BYTE *)a4 = a1[1].i32[1];
    __int32 v6 = a1[11].i32[0];
    if ((~v6 & 0x180) != 0)
    {
      int v7 = 0;
      __int32 v8 = a1[92].i32[1];
      if ((v8 & 0x20) == 0) {
        goto LABEL_15;
      }
    }

    else
    {
      int v7 = 1;
      *(_DWORD *)(a4 + 4) = 1;
      __int32 v8 = a1[92].i32[1];
      if ((v8 & 0x20) == 0)
      {
LABEL_15:
        if ((~v6 & 0x60) == 0)
        {
          v7 |= 4u;
          *(_DWORD *)(a4 + 4) = v7;
          *(_WORD *)(a4 + 1) = a1[32].i16[2];
        }

        if ((~a1[43].i32[1] & 3) == 0) {
          *(_DWORD *)(a4 + 4) = v7 | 8;
        }
        if ((v6 & 0x200000) != 0 || a1[28].i16[1])
        {
          *(_DWORD *)(a4 + 8) = 1;
          int v12 = 3;
          if ((v8 & 0x2000) == 0)
          {
LABEL_23:
            __int32 v13 = a1[3].i32[1];
            if (v13) {
              __int32 v13 = a1[24].i32[0];
            }
            *(_DWORD *)(a4 + 12) = v13;
            *(_DWORD *)(a4 + 16) = a1[24].i32[1];
            *(int32x2_t *)(a4 + 20) = vrev64_s32(a1[18]);
            *(_DWORD *)(a4 + 28) = a1[17].i32[1];
            *(_DWORD *)(a4 + 32) = *(_DWORD *)(a3 + 384);
            unsigned __int32 v15 = a1[15].u32[0];
            unsigned __int32 v14 = a1[15].u32[1];
            BOOL v16 = v14 >= v15;
            unsigned __int32 v17 = v14 - v15;
            if (!v16) {
              unsigned __int32 v17 = 0;
            }
            *(_DWORD *)(a4 + 36) = v17;
            *(_DWORD *)(a4 + 40) = a1[29].i32[1];
            *(_DWORD *)(a4 + 44) = a1[25].i32[0] >> 5;
            *(_DWORD *)(a4 + 48) = a1[26].i32[0] >> 4;
            uint64_t v18 = *(void *)(a2 + 248);
            *(_OWORD *)(a4 + 56) = *(_OWORD *)(v18 + 16);
            *(void *)(a4 + 72) = a1[89].u32[0];
            *(void *)(a4 + 104) = a1[90].u32[0];
            __n128 result = *(__n128 *)v18;
            *(_OWORD *)(a4 + 80) = *(_OWORD *)v18;
            *(void *)(a4 + 96) = a1[88].u32[1];
            LOBYTE(v18) = a1[123].i16[3];
            *(_DWORD *)(a4 + 52) = 32 * (v18 & 1);
            int v19 = (32 * a1[123].u16[3]) & 0x40 | (32 * (v18 & 1));
            *(_DWORD *)(a4 + 52) = v19;
            unsigned int v20 = v19 & 0xFFFFFF7F | (((a1[123].u16[3] >> 2) & 1) << 7);
            *(_DWORD *)(a4 + 52) = v20;
            unsigned int v21 = v20 & 0xFFFFFEFF | (((a1[123].u16[3] >> 3) & 1) << 8);
            *(_DWORD *)(a4 + 52) = v21;
            unsigned int v22 = v21 & 0xFFFFFFFE | (a1[123].u16[3] >> 4) & 1;
            *(_DWORD *)(a4 + 52) = v22;
            LODWORD(v18) = v22 | (a1[123].u16[3] >> 4) & 2;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFF7 | (a1[123].u16[3] >> 3) & 8;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFEF | (a1[123].u16[3] >> 3) & 0x10;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFFFB | (a1[123].u16[3] >> 6) & 4;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFDFF | a1[123].i16[3] & 0x200;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFFBFF | a1[123].i16[3] & 0x400;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFF7FF | a1[123].i16[3] & 0x800;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFEFFF | a1[123].i16[3] & 0x1000;
            *(_DWORD *)(a4 + 52) = v18;
            LODWORD(v18) = v18 & 0xFFFFDFFF | a1[123].i16[3] & 0x2000;
            *(_DWORD *)(a4 + 52) = v18;
            *(_DWORD *)(a4 + 52) = v18 & 0xFFFFBFFF | a1[123].i16[3] & 0x4000;
            return result;
          }
        }

        else
        {
          int v12 = 2;
          if ((v8 & 0x2000) == 0) {
            goto LABEL_23;
          }
        }

        *(_DWORD *)(a4 + 8) = v12;
        goto LABEL_23;
      }
    }

    v7 |= 2u;
    *(_DWORD *)(a4 + 4) = v7;
    goto LABEL_15;
  }

  int v9 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v11 = "tp";
    if (!a2) {
      int v11 = "inp";
    }
    if (!a3) {
      int v11 = "so";
    }
    int v23 = 136446466;
    uint64_t v24 = "tcp_connection_fill_info";
    __int16 v25 = 2082;
    uint64_t v26 = v11;
    _os_log_impl(&dword_1879E5000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s is NULL", (uint8_t *)&v23, 0x16u);
  }

  return result;
}

uint64_t tcp_ctloutput(uint64_t a1, uint64_t a2)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1) {
    return 54LL;
  }
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 != 6)
  {
    if (v5 != 0xFFFF || ((int v6 = *(_DWORD *)(a2 + 8), v6 != 4355) ? (v7 = v6 == 4357) : (v7 = 1), !v7))
    {
      int v14 = **(_DWORD **)(*(void *)(a1 + 8) + 8LL);
      __nwlog_obj();
      if (v14 == 30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip6_ctloutput";
        unsigned __int32 v15 = (void *)_os_log_send_and_compose_impl();
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_49;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip6_ctloutput";
      }

      else
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip_ctloutput";
        unsigned __int32 v15 = (void *)_os_log_send_and_compose_impl();
        uint64_t v24 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_49;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "ip_ctloutput";
      }

      _os_log_impl( &dword_1879E5000,  v24,  OS_LOG_TYPE_ERROR,  "%{public}s currently unsupported, backtrace limit exceeded",  buf,  0xCu);
LABEL_49:
      if (v15) {
        free(v15);
      }
      return 0LL;
    }
  }

  uint64_t v8 = *(void *)(v2 + 240);
  if (!v8) {
    return 54LL;
  }
  uint64_t v9 = nw_tcp_access_globals(a1);
  calculate_tcp_clock(v9);
  if (!*(_DWORD *)a2)
  {
    int v16 = *(_DWORD *)(a2 + 8);
    uint64_t result = 42LL;
    if (v16 > 511)
    {
      switch(v16)
      {
        case 512:
          tcp_fill_info(v8, *(void *)a1, a1, (uint64_t)buf);
          unsigned int v20 = *(void **)(a2 + 16);
          uint64_t v21 = *(void *)(a2 + 24);
          BOOL v22 = v21 < 408;
          uint64_t v23 = 408LL;
          goto LABEL_218;
        case 513:
          if ((*(_BYTE *)(a1 + 366) & 8) == 0) {
            goto LABEL_179;
          }
          int v17 = *(_DWORD *)(v8 + 320);
          goto LABEL_216;
        case 514:
          int v17 = *(_DWORD *)(v8 + 740) & 8;
          goto LABEL_216;
        case 515:
          if ((*(_BYTE *)(v8 + 740) & 8) == 0) {
            return 22LL;
          }
          uint64_t v62 = *(void *)(v8 + 768);
          if (!v62) {
            return 22LL;
          }
          *(void *)__int128 buf = *(void *)(v62 + 12);
          unsigned int v20 = *(void **)(a2 + 16);
          uint64_t v21 = *(void *)(a2 + 24);
          BOOL v22 = v21 < 8;
          uint64_t v23 = 8LL;
          goto LABEL_218;
        case 516:
        case 518:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 531:
        case 532:
        case 533:
        case 534:
        case 535:
        case 537:
        case 538:
          return result;
        case 517:
          int v17 = *(unsigned __int8 *)(v8 + 265);
          goto LABEL_216;
        case 519:
          int v17 = *(unsigned __int8 *)(v8 + 266);
          goto LABEL_216;
        case 520:
          int v17 = (*(_DWORD *)(v8 + 740) >> 11) & 1;
          goto LABEL_216;
        case 521:
          if ((*(_BYTE *)(v8 + 742) & 2) != 0) {
            goto LABEL_180;
          }
          goto LABEL_179;
        case 528:
          int v63 = *(_DWORD *)(v8 + 348);
          if ((v63 & 0x400) != 0)
          {
LABEL_180:
            int v17 = 1;
          }

          else
          {
            if ((v63 & 0x800) == 0)
            {
LABEL_179:
              *(_DWORD *)__int128 buf = 0;
              break;
            }

            int v17 = 2;
          }

LABEL_174:
          unint64_t v61 = 274877907LL * v59;
LABEL_175:
          *(_DWORD *)__int128 buf = v61 >> 38;
          break;
        case 32:
          unsigned int v31 = *(_DWORD *)(v8 + 680);
          goto LABEL_132;
        case 64:
          unsigned int v31 = *(_DWORD *)(v8 + 312);
LABEL_132:
          unint64_t v61 = 274877907LL * v31;
          goto LABEL_175;
        default:
          switch(v16)
          {
            case 256:
              int v17 = *(_DWORD *)(v8 + 740) & 1;
              goto LABEL_216;
            case 257:
              unsigned int v59 = *(_DWORD *)(v8 + 684);
              if (v59) {
                goto LABEL_174;
              }
              int v60 = *(_DWORD *)(sysctls + 196);
              goto LABEL_196;
            case 258:
              int v17 = *(_DWORD *)(v8 + 688);
              if (!v17) {
                int v17 = *(_DWORD *)(sysctls + 200);
              }
              goto LABEL_216;
            case 259:
              if ((*(_BYTE *)(v8 + 741) & 2) == 0) {
                goto LABEL_179;
              }
              goto LABEL_180;
            case 260:
              int v17 = (*(_DWORD *)(v8 + 348) >> 10) & 1;
              goto LABEL_216;
            case 261:
              if (*(_DWORD *)(v8 + 12) != 1 || (*(_BYTE *)(sysctls + 160) & 1) == 0) {
                return 45LL;
              }
              int v17 = (*(_DWORD *)(v8 + 740) >> 22) & 1;
              break;
            case 262:
              tcp_connection_fill_info((int32x2_t *)v8, *(void *)a1, a1, (uint64_t)buf);
              unsigned int v20 = *(void **)(a2 + 16);
              uint64_t v21 = *(void *)(a2 + 24);
              BOOL v22 = v21 < 112;
              uint64_t v23 = 112LL;
              goto LABEL_218;
            default:
              if (v16 != 128) {
                return result;
              }
              unsigned int v31 = *(_DWORD *)(v8 + 244);
              goto LABEL_132;
          }

          goto LABEL_216;
      }
    }

    unsigned int v20 = *(void **)(a2 + 16);
    uint64_t v21 = *(void *)(a2 + 24);
    BOOL v22 = v21 < 4;
    uint64_t v23 = 4LL;
LABEL_218:
    if (v22) {
      size_t v77 = v21;
    }
    else {
      size_t v77 = v23;
    }
    *(void *)(a2 + 24) = v77;
LABEL_222:
    memcpy(v20, buf, v77);
    return 0LL;
  }

  if (*(_DWORD *)a2 == 1)
  {
    int v10 = *(_DWORD *)(a2 + 8);
    uint64_t result = 42LL;
    if (v10 <= 512)
    {
      switch(v10)
      {
        case 1:
        case 4:
        case 8:
          if (v10 == 1)
          {
            int v10 = 4;
          }

          else if (v10 == 4)
          {
            int v10 = 4096;
          }

          else if (v10 != 8)
          {
            int v10 = 0;
          }

          uint64_t result = 0LL;
          if (**(_DWORD **)(a2 + 16)) {
            int v74 = *(_DWORD *)(v8 + 88) | v10;
          }
          else {
            int v74 = *(_DWORD *)(v8 + 88) & ~v10;
          }
          *(_DWORD *)(v8 + 88) = v74;
          return result;
        case 2:
          int v32 = **(_DWORD **)(a2 + 16);
          if (v32 >= 1 && v32 <= *(_DWORD *)(v8 + 196) && v32 + 40 >= *(_DWORD *)(sysctls + 164))
          {
            uint64_t result = 0LL;
            *(_DWORD *)(v8 + 196) = v32;
            return result;
          }

          if ((*(_BYTE *)(a1 + 828) & 2) == 0)
          {
            unsigned int v33 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = *(_DWORD *)(v8 + 196);
              int v35 = *(_DWORD *)(sysctls + 164);
              *(_DWORD *)__int128 buf = 136447234;
              *(void *)&uint8_t buf[4] = "tcp_ctloutput";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = a1 + 604;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)&uint8_t buf[24] = v32;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v34;
              *(_WORD *)&_BYTE buf[34] = 1024;
              *(_DWORD *)&buf[36] = v35;
              _os_log_impl( &dword_1879E5000,  v33,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s EINVAL: optval %d t_maxseg %u tcp_minmss %d",  buf,  0x28u);
              return 22LL;
            }
          }

          return 22LL;
        case 3:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
          return result;
        case 16:
          unsigned int v36 = **(_DWORD **)(a2 + 16);
          if (v36 > 0x418937) {
            return 22LL;
          }
          *(_DWORD *)(v8 + 676) = 1000 * v36;
          int v37 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224LL)) + 316);
          int v38 = *(_DWORD *)(v8 + 676);
          if (!v38 || (*(_BYTE *)(*(void *)(*(void *)(v8 + 80) + 224LL) + 372LL) & 8) == 0) {
            int v38 = *(_DWORD *)(sysctls + 192);
          }
          goto LABEL_84;
        case 32:
          unsigned int v39 = **(_DWORD **)(a2 + 16);
          if (v39 > 0x418937) {
            return 22LL;
          }
          *(_DWORD *)(v8 + 680) = 1000 * v39;
          int v37 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224LL)) + 316);
          int v38 = *(_DWORD *)(v8 + 680);
          if (!v38) {
            int v38 = *(_DWORD *)(sysctls + 188);
          }
LABEL_84:
          *(_DWORD *)(v8 + 40) = v38 + v37 - *(_DWORD *)(v8 + 64);
          goto LABEL_246;
        case 64:
          int v40 = **(_DWORD **)(a2 + 16);
          if (v40 < 0) {
            return 22LL;
          }
          uint64_t result = 0LL;
          *(_DWORD *)(v8 + 312) = 1000 * v40;
          return result;
        default:
          switch(v10)
          {
            case 256:
              goto LABEL_57;
            case 257:
              unsigned int v12 = **(_DWORD **)(a2 + 16);
              if (v12 > 0x418937) {
                return 22LL;
              }
              *(_DWORD *)(v8 + 684) = 1000 * v12;
              if (*(_DWORD *)(v8 + 12) != 9) {
                return 0LL;
              }
              int v13 = *(_DWORD *)(v8 + 688);
              if (v13)
              {
                if (v12) {
                  goto LABEL_19;
                }
              }

              else
              {
                int v13 = *(_DWORD *)(sysctls + 200);
                if (v12)
                {
LABEL_19:
                  if (!(1000 * v12 * v13)) {
                    return 0LL;
                  }
                  goto LABEL_241;
                }
              }

              if (!(*(_DWORD *)(sysctls + 196) * v13)) {
                return 0LL;
              }
LABEL_241:
              uint64_t v79 = nw_tcp_access_globals(*(void *)(*(void *)(v8 + 80) + 224LL));
              int v80 = *(_DWORD *)(v8 + 688);
              if (!v80) {
                int v80 = *(_DWORD *)(sysctls + 200);
              }
              int v81 = *(_DWORD *)(v8 + 684);
              if (!v81) {
                int v81 = *(_DWORD *)(sysctls + 196);
              }
              *(_DWORD *)(v8 + 44) = *(_DWORD *)(v79 + 316) + v81 * v80 - *(_DWORD *)(v8 + 64);
LABEL_246:
              tcp_check_timer_state(v8);
              return 0LL;
            case 258:
              int v65 = **(_DWORD **)(a2 + 16);
              if (v65 < 0) {
                return 22LL;
              }
              *(_DWORD *)(v8 + 688) = v65;
              if (*(_DWORD *)(v8 + 12) != 9) {
                return 0LL;
              }
              if (!v65) {
                int v65 = *(_DWORD *)(sysctls + 200);
              }
              int v66 = *(_DWORD *)(v8 + 684);
              if (!v66) {
                int v66 = *(_DWORD *)(sysctls + 196);
              }
              if (!(v66 * v65)) {
                return 0LL;
              }
              goto LABEL_241;
            case 259:
              unsigned int v67 = **(_DWORD **)(a2 + 16);
              if (v67 > 1) {
                return 22LL;
              }
              int v68 = *(_DWORD *)(v8 + 740);
              uint64_t result = 0LL;
              if (v67) {
                unsigned int v69 = v68 | 0x200;
              }
              else {
                unsigned int v69 = v68 & 0xFFFFFDFF;
              }
              *(_DWORD *)(v8 + 740) = v69;
              return result;
            case 260:
              unsigned int v70 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
              uint64_t result = 0LL;
              if (!**(_DWORD **)(a2 + 16)) {
                goto LABEL_209;
              }
              goto LABEL_211;
            case 261:
              if ((*(_BYTE *)(sysctls + 160) & 1) == 0) {
                return 45LL;
              }
              unsigned int v71 = **(_DWORD **)(a2 + 16);
              if (v71 > 1 || *(_DWORD *)(v8 + 12) != 1) {
                return 22LL;
              }
              int v72 = *(_DWORD *)(v8 + 740);
              uint64_t result = 0LL;
              if (v71) {
                unsigned int v73 = v72 | 0x400000;
              }
              else {
                unsigned int v73 = v72 & 0xFFBFFFFF;
              }
              *(_DWORD *)(v8 + 740) = v73;
              return result;
            default:
              if (v10 != 128) {
                return result;
              }
              int v30 = **(_DWORD **)(a2 + 16);
              if (v30 < 0) {
                return 22LL;
              }
              uint64_t result = 0LL;
              *(_DWORD *)(v8 + 244) = 1000 * v30;
              return result;
          }
      }
    }

    switch(v10)
    {
      case 513:
        int v18 = **(_DWORD **)(a2 + 16);
        if (v18 < 0) {
          return 22LL;
        }
        int v19 = *(_DWORD *)(a1 + 364);
        uint64_t result = 0LL;
        if (v18)
        {
          *(_DWORD *)(a1 + 364) = v19 | 0x80000;
          *(_DWORD *)(v8 + 320) = v18;
        }

        else
        {
          *(_DWORD *)(a1 + 364) = v19 & 0xFFF7FFFF;
          *(_DWORD *)(v8 + 320) = 0;
        }

        return result;
      case 514:
        uint64_t result = 0LL;
        if (**(_DWORD **)(a2 + 16))
        {
          *(_OWORD *)(v8 + 776) = 0u;
          *(_OWORD *)(v8 + 792) = 0u;
          *(void *)(v8 + 768) = v8 + 776;
          *(_DWORD *)(v8 + 788) = 6;
          *(_DWORD *)(v8 + 796) = 6 * *(_DWORD *)(v8 + 196);
          *(_DWORD *)(v8 + 740) |= 8u;
          *(void *)(v8 + 808) = 0LL;
        }

        else
        {
          *(_DWORD *)(v8 + 740) &= 0xFFFFFFF3;
        }

        return result;
      case 515:
        if ((*(_BYTE *)(v8 + 740) & 8) == 0) {
          return 22LL;
        }
        unsigned int v41 = *(_DWORD **)(v8 + 768);
        if (!v41) {
          return 22LL;
        }
        unsigned int v42 = *(unsigned int **)(a2 + 16);
        unsigned int v44 = *v42;
        unsigned int v43 = v42[1];
        if (v44)
        {
          if (v43) {
            goto LABEL_93;
          }
        }

        else
        {
          unsigned int v44 = v41[3];
          if (v43)
          {
LABEL_93:
            if (v44 > v43) {
              return 22LL;
            }
            goto LABEL_237;
          }
        }

        unsigned int v43 = v41[4];
        if (v44 > v43) {
          return 22LL;
        }
LABEL_237:
        uint64_t result = 0LL;
        v41[3] = v44;
        v41[4] = v43;
        int v78 = *(_DWORD *)(v8 + 196);
        v41[5] = v78 * v44;
        v41[6] = v78 * v43;
        return result;
      case 516:
      case 518:
      case 522:
      case 523:
      case 524:
      case 525:
      case 526:
      case 527:
      case 531:
      case 532:
      case 533:
      case 534:
      case 535:
      case 537:
      case 538:
        return result;
      case 517:
        unsigned int v45 = **(_DWORD **)(a2 + 16);
        if (v45 > 0xA) {
          return 22LL;
        }
        if (v45)
        {
          uint64_t result = 0LL;
          *(_BYTE *)(v8 + 265) = v45;
          return result;
        }

        *(_BYTE *)(v8 + 265) = 0;
        tcp_keepalive_reset(v8);
        return 0LL;
      case 519:
        unsigned int v46 = **(_DWORD **)(a2 + 16);
        if (v46 > 0xA) {
          return 22LL;
        }
        uint64_t result = 0LL;
        *(_BYTE *)(v8 + 266) = v46;
        return result;
      case 520:
LABEL_57:
        if (v10 == 256) {
          int v28 = 1;
        }
        else {
          int v28 = (v10 == 520) << 11;
        }
        uint64_t result = 0LL;
        if (**(_DWORD **)(a2 + 16)) {
          int v29 = *(_DWORD *)(v8 + 740) | v28;
        }
        else {
          int v29 = *(_DWORD *)(v8 + 740) & ~v28;
        }
        *(_DWORD *)(v8 + 740) = v29;
        return result;
      case 521:
        unsigned int v47 = **(_DWORD **)(a2 + 16);
        if (v47 > 1) {
          return 22LL;
        }
        int v48 = *(_DWORD *)(v8 + 740);
        if (!v47)
        {
          uint64_t result = 0LL;
          *(_DWORD *)(v8 + 740) = v48 & 0xFFFDFFFF;
          return result;
        }

        *(_DWORD *)(v8 + 740) = v48 | 0x20000;
        if ((*(_BYTE *)(v8 + 91) & 0x20) != 0 && *(_WORD *)(v8 + 698)) {
          tcp_pmtud_revert_segment_size(v8);
        }
        return 0LL;
      case 528:
        int v49 = **(_DWORD **)(a2 + 16);
        if (v49 == 2)
        {
          uint64_t result = 0LL;
          unsigned int v70 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_209:
          *(_DWORD *)(v8 + 348) = v70 | 0x800;
        }

        else if (v49 == 1)
        {
          uint64_t result = 0LL;
          unsigned int v70 = *(_DWORD *)(v8 + 348) & 0xFFFFF3FF;
LABEL_211:
          *(_DWORD *)(v8 + 348) = v70 | 0x400;
        }

        else
        {
          if (v49) {
            return 22LL;
          }
          uint64_t result = 0LL;
          *(_DWORD *)(v8 + 348) &= 0xFFFFF3FF;
        }

        return result;
      case 529:
        int v50 = **(_DWORD **)(a2 + 16);
        if (v50 < 0) {
          return 22LL;
        }
        int v51 = *(_DWORD *)(v2 + 2232);
        uint64_t result = 0LL;
        if (v50) {
          unsigned int v52 = v51 | 0x40;
        }
        else {
          unsigned int v52 = v51 & 0xFFFFFFBF;
        }
        *(_DWORD *)(v2 + 2232) = v52;
        return result;
      case 530:
        int v53 = **(_DWORD **)(a2 + 16);
        if (v53 < 1) {
          return 22LL;
        }
        int v75 = *(_DWORD *)(a1 + 384);
        if (!v75) {
          return 55LL;
        }
        uint64_t v76 = *(void *)(v8 + 1032);
        if (!v76)
        {
LABEL_207:
          tcp_add_notify_ack_marker(v8, v53);
          return 0LL;
        }

        while (*(_DWORD *)(v76 + 4) != v53 && *(_DWORD *)v76 != *(_DWORD *)(v8 + 92) + v75)
        {
          uint64_t v76 = *(void *)(v76 + 8);
          if (!v76) {
            goto LABEL_207;
          }
        }

        return 22LL;
      case 536:
        unsigned int v54 = **(_DWORD **)(a2 + 16);
        if (v54 > 1 || *(_DWORD *)(v8 + 12)) {
          return 22LL;
        }
        int v55 = *(_DWORD *)(v8 + 740);
        uint64_t result = 0LL;
        if (v54) {
          unsigned int v56 = v55 | 0x1000000;
        }
        else {
          unsigned int v56 = v55 & 0xFEFFFFFF;
        }
        *(_DWORD *)(v8 + 740) = v56;
        return result;
      case 539:
        unsigned int v57 = **(_DWORD **)(a2 + 16);
        if (v57 > 1) {
          return 22LL;
        }
        if (v57 == 1) {
          int v58 = 0x8000000;
        }
        else {
          int v58 = 0x10000000;
        }
        *(_DWORD *)(v8 + 740) = *(_DWORD *)(v8 + 740) & 0xE7FFFFFF | v58;
        tcp_set_foreground_cc(a1);
        return 0LL;
      default:
        if (v10 == 4355)
        {
          inp_flush();
          return 0LL;
        }

        if (v10 != 4357) {
          return result;
        }
        int v25 = *(_DWORD *)(a1 + 368);
        if (**(_DWORD **)(a2 + 16))
        {
          *(_DWORD *)(a1 + 368) = v25 | 0x2000;
          if (*(void *)(a1 + 24))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              unsigned int v27 = *(_DWORD *)(all_stats + 128) | 1;
LABEL_200:
              *(_DWORD *)(all_stats + 128) = v27;
            }
          }
        }

        else
        {
          *(_DWORD *)(a1 + 368) = v25 & 0xFFFFDFFF;
          if (*(void *)(a1 + 24))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              unsigned int v27 = *(_DWORD *)(all_stats + 128) & 0xFFFFFFFE;
              goto LABEL_200;
            }
          }
        }

        set_tcp_stream_priority(a1);
        break;
    }
  }

  return 0LL;
}

void inp_flush()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v3 = "inp_flush";
  unsigned int v0 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_fault())
  {
    uint64_t v1 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v3 = "inp_flush";
      _os_log_impl( &dword_1879E5000,  v1,  OS_LOG_TYPE_ERROR,  "%{public}s currently unsupported, backtrace limit exceeded",  buf,  0xCu);
    }
  }

  if (v0) {
    free(v0);
  }
}

uint64_t tcp_set_ecn(uint64_t a1)
{
  tcp_do_acc_ecn = network_config_get_tcp_accurate_ecn_enabled();
  tcp_do_l4s = network_config_get_tcp_l4s_enabled();
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 80) + 2136LL) + 16LL))(*(void *)(*(void *)(a1 + 80) + 224LL));
  int v3 = *(_DWORD *)(a1 + 740);
  if ((result & 1) == 0)
  {
    if ((v3 & 0x10000000) != 0
      || (v3 & 0x8000000) == 0 && (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v5 = tcp_do_acc_ecn == 1) : (BOOL v5 = 1), !v5))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 348) & 0xFFFFEFFF;
      *(_DWORD *)(a1 + 348) = v4;
      goto LABEL_22;
    }

    unsigned int v4 = *(_DWORD *)(a1 + 348) | 0x1000;
    *(_DWORD *)(a1 + 348) = v4;
    if ((v3 & 0x8000000) != 0) {
      goto LABEL_18;
    }
    goto LABEL_13;
  }

  unsigned int v4 = *(_DWORD *)(a1 + 348) | 0x1000;
  *(_DWORD *)(a1 + 348) = v4;
  if ((v3 & 0x10000000) != 0) {
    goto LABEL_22;
  }
  if ((v3 & 0x8000000) == 0)
  {
LABEL_13:
    if (*(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1) {
      goto LABEL_22;
    }
  }

uint64_t tcp_flight_size(_DWORD *a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if ((a1[157] & 0x80000000) != 0)
  {
    BOOL v22 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v27 = "tcp_flight_size";
    uint64_t v23 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if ((_DWORD)result) {
      goto LABEL_20;
    }
    free(v23);
    if ((a1[156] & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_18:
    uint64_t v24 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v27 = "tcp_flight_size";
    int v25 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort();
    if (!(_DWORD)result)
    {
      free(v25);
      goto LABEL_3;
    }

uint64_t tcp_output(uint64_t a1)
{
  kern_return_t v461;
  kern_return_t v462;
  os_log_s *v463;
  int v464;
  char v465;
  char v466;
  int v467;
  unsigned int v468;
  int v469;
  int v470;
  int v471;
  int v472;
  unsigned int v473;
  char v474;
  unsigned int v475;
  int v476;
  int v477;
  uint64_t v478;
  uint64_t v479;
  int v480;
  char v481;
  uint64_t (*v482)(uint64_t, uint64_t, void, void);
  char v483;
  int v484;
  int v485;
  os_log_s *v486;
  int v487;
  int v488;
  unsigned int v489;
  int v490;
  int v491;
  int v492;
  uint64_t v493;
  unsigned int v494;
  unsigned int v495;
  int v496;
  unsigned int v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  int v501;
  int v502;
  int v503;
  uint64_t v504;
  int v505;
  uint64_t v506;
  int v507;
  int v508;
  int v509;
  int v510;
  uint64_t v511;
  int v512;
  int v513;
  int v514;
  uint64_t v515;
  int v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t *v519;
  int v520;
  int v521;
  int v522;
  unsigned int v523;
  unsigned int v524;
  unsigned int v525;
  int v526;
  char v527;
  int v528;
  void *v529;
  os_log_s *v530;
  os_log_type_t v531;
  int v532;
  os_log_s *v533;
  os_log_type_t v534;
  const char *v535;
  unint64_t v536;
  uint64_t v537;
  void *v538;
  unint64_t v539;
  uint64_t v540;
  void *v541;
  unint64_t v542;
  unint64_t v543;
  int v544;
  unint64_t v545;
  unint64_t v546;
  unint64_t v547;
  int v548;
  unint64_t v549;
  uint64_t v550;
  void *v551;
  void *v552;
  os_log_s *v553;
  os_log_type_t v554;
  BOOL v555;
  int v556;
  int v557;
  unint64_t v558;
  unint64_t v559;
  int v560;
  unint64_t *v561;
  uint64_t v562;
  void *v563;
  os_log_s *v564;
  int v565;
  int v566;
  unint64_t v567;
  unint64_t *v568;
  uint64_t v569;
  unint64_t v570;
  uint64_t v571;
  unsigned int v572;
  unint64_t v573;
  unint64_t v574;
  int v575;
  unint64_t v576;
  unint64_t v577;
  int v578;
  unint64_t *v579;
  os_log_s *v580;
  int v581;
  int v582;
  os_log_s *v583;
  os_log_type_t v584;
  int v585;
  unint64_t *v586;
  int v587;
  int v588;
  char v589;
  int v590;
  int v591;
  uint64_t v592;
  void *v593;
  void *v594;
  void *v595;
  int v596;
  uint64_t v597;
  os_log_s *v598;
  os_log_type_t v599;
  unint64_t v600;
  uint64_t v601;
  void *v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  int v608;
  int v609;
  void *v610;
  os_log_s *v611;
  os_log_type_t v612;
  uint64_t v613;
  int v614;
  int v615;
  os_log_s *v616;
  os_log_type_t v617;
  const char *v618;
  os_log_s *v619;
  void *v620;
  os_log_s *v621;
  int v622;
  unsigned int v623;
  unsigned int v624;
  unsigned int v625;
  int v626;
  int v627;
  int v628;
  os_log_s *v629;
  os_log_type_t v630;
  os_log_s *v631;
  int v632;
  unsigned int v633;
  unsigned int v634;
  unsigned int v635;
  int v636;
  int v637;
  int v638;
  void *v639;
  os_log_s *v640;
  os_log_type_t v641;
  BOOL v642;
  uint64_t v643;
  int v644;
  int v645;
  int v646;
  void *v647;
  os_log_s *v648;
  os_log_type_t v649;
  int v650;
  os_log_s *v651;
  os_log_type_t v652;
  const char *v653;
  void *v654;
  os_log_s *v655;
  os_log_type_t v656;
  os_log_s *v657;
  os_log_type_t v658;
  const char *v659;
  int v660;
  int v661;
  int v662;
  uint64_t v663;
  int v664;
  void *v665;
  void *v666;
  os_log_s *v667;
  os_log_type_t v668;
  BOOL v669;
  int v670;
  os_log_s *v671;
  os_log_type_t v672;
  uint64_t v673;
  int v674;
  int v675;
  void *v676;
  os_log_s *v677;
  os_log_type_t v678;
  BOOL v679;
  uint64_t v680;
  int v681;
  int v682;
  os_log_s *v683;
  os_log_type_t v684;
  int v685;
  void *v686;
  os_log_s *v687;
  os_log_type_t v688;
  os_log_s *v689;
  os_log_type_t v690;
  const char *v691;
  int v692;
  int64x2_t *v693;
  os_log_s *v694;
  os_log_type_t v695;
  os_log_s *v696;
  const char *v697;
  void *v698;
  os_log_s *v699;
  os_log_type_t v700;
  os_log_s *v701;
  os_log_type_t v702;
  const char *v703;
  void *v704;
  os_log_s *v705;
  os_log_type_t v706;
  BOOL v707;
  void *v708;
  os_log_s *v709;
  os_log_type_t v710;
  os_log_s *v711;
  os_log_type_t v712;
  const char *v713;
  void *v714;
  os_log_s *v715;
  os_log_type_t v716;
  BOOL v717;
  os_log_s *v718;
  os_log_type_t v719;
  void *v720;
  os_log_s *v721;
  os_log_type_t v722;
  os_log_s *v723;
  os_log_type_t v724;
  const char *v725;
  void *v726;
  os_log_s *v727;
  os_log_type_t v728;
  BOOL v729;
  os_log_s *v730;
  os_log_type_t v731;
  int v732;
  int v733;
  void *v734;
  void *v735;
  os_log_s *v736;
  os_log_type_t v737;
  BOOL v738;
  os_log_s *v739;
  os_log_type_t v740;
  os_log_s *v741;
  os_log_type_t v742;
  char v743;
  int v744;
  char v745;
  int v746;
  int v747;
  int v748;
  void *v749;
  int v750;
  char *v751;
  const char *v752;
  void *v753;
  os_log_s *v754;
  os_log_type_t v755;
  const char *v756;
  int v757;
  char *v758;
  const char *v759;
  uint64_t v760;
  void *v761;
  os_log_s *v762;
  void (*v763)(uint64_t, void, uint64_t);
  uint64_t v764;
  os_log_s *v765;
  void (*v766)(uint64_t, void, uint64_t);
  uint64_t v767;
  uint64_t v768;
  void *v769;
  void (*v770)(void *, void, uint64_t);
  uint64_t v771;
  uint64_t v772;
  os_log_s *v773;
  os_log_type_t v774;
  const char *v775;
  BOOL v776;
  os_log_t v777;
  void *v778;
  BOOL v779;
  const char *v780;
  int v781;
  char *v782;
  int v783;
  int v784;
  const char *v785;
  int v786;
  char *v787;
  _BYTE *v788;
  const char *v789;
  int v790;
  char *v791;
  char v792;
  void *v793;
  os_log_s *v794;
  os_log_type_t numer;
  const char *v796;
  os_log_s *v797;
  void *v798;
  os_log_s *v799;
  os_log_type_t v800;
  const char *v801;
  os_log_s *v802;
  void (*v803)(uint64_t, void, uint64_t);
  uint64_t v804;
  void *v805;
  os_log_s *v806;
  os_log_type_t v807;
  BOOL v808;
  const char *v809;
  BOOL v810;
  void *v811;
  os_log_s *v812;
  os_log_type_t v813;
  BOOL v814;
  os_log_s *v815;
  os_log_type_t v816;
  os_log_s *v817;
  void *v818;
  uint64_t v819;
  void *v820;
  void (*v821)(void *, void, uint64_t);
  uint64_t v822;
  uint64_t v823;
  os_log_s *v824;
  os_log_type_t v825;
  const char *v826;
  BOOL v827;
  os_log_s *v828;
  os_log_type_t v829;
  int v830;
  void *v832;
  os_log_s *v833;
  os_log_type_t v834;
  const char *v835;
  void *v836;
  os_log_s *v837;
  os_log_type_t v838;
  BOOL v839;
  void *v840;
  BOOL v841;
  void *v842;
  os_log_s *v843;
  os_log_type_t v844;
  const char *v845;
  void *v846;
  os_log_s *v847;
  os_log_type_t v848;
  BOOL v849;
  void *v850;
  BOOL v851;
  os_log_s *v852;
  os_log_type_t v853;
  os_log_s *v854;
  os_log_type_t v855;
  void *v856;
  os_log_s *v857;
  os_log_type_t v858;
  const char *v859;
  void *v860;
  os_log_s *v861;
  os_log_type_t v862;
  BOOL v863;
  os_log_s *v864;
  os_log_type_t v865;
  os_log_s *v866;
  char *v867;
  void (*v868)(uint64_t, void, uint64_t);
  uint64_t v869;
  void *v870;
  os_log_s *v871;
  os_log_type_t v872;
  const char *v873;
  void *v874;
  os_log_s *v875;
  os_log_type_t v876;
  BOOL v877;
  os_log_s *v878;
  os_log_type_t v879;
  os_log_s *log;
  os_log_t v881;
  os_log_s *v882;
  os_log_s *v883;
  int v884;
  char v885;
  unint64_t v886;
  uint64_t v887;
  unsigned int v888;
  unsigned int v889;
  int v890;
  unsigned int v891;
  uint64_t v892;
  uint64_t v893;
  unint64_t *v894;
  int v895;
  int v896;
  int v897;
  unsigned int *v898;
  int v899;
  int v900;
  unsigned int *v901;
  BOOL v902;
  char v903;
  BOOL v904;
  uint64_t v905;
  int v906;
  int v907;
  unsigned int v908;
  int v909;
  int *v910;
  int v911;
  int v912;
  int v913;
  int v914;
  unsigned int *type;
  os_log_type_t typea;
  signed int v917;
  os_log_t v918;
  os_log_s *v919;
  os_log_type_t v920;
  os_log_s *v921;
  os_log_type_t v922;
  uint64_t v923;
  int v924;
  os_log_t v925;
  int v926;
  int v927;
  os_log_s *v928;
  os_log_s *v929;
  os_log_s *v930;
  os_log_s *v931;
  os_log_t v932;
  os_log_s *v933;
  os_log_type_t v934;
  int v935;
  void *v936;
  os_log_type_t v937;
  os_log_s *v938;
  os_log_type_t v939;
  _BYTE *v940;
  os_log_s *v941;
  void *backtrace_string;
  os_log_s *v943;
  int v944;
  unsigned int v945;
  unsigned int v946;
  unsigned int v947;
  void *v948;
  void *v949;
  mach_timebase_info info;
  mach_timebase_info *p_info;
  char v952;
  os_log_type_t v953;
  _BYTE buf[24];
  _BYTE v955[28];
  char *v956;
  _DWORD v957[3];
  _WORD __src[2];
  unsigned int v959;
  uint64_t v960;
  float32x4x2_t v961;
  float32x4x2_t v962;
  float32x4x2_t v963;
  v960 = *MEMORY[0x1895F89C0];
  int v2 = *(void **)(a1 + 80);
  uint64_t v3 = v2[28];
  v899 = *(_DWORD *)(v3 + 600);
  uint64_t v4 = nw_tcp_access_globals(v3);
  unsigned int v907 = *((_BYTE *)v2 + 2236) & 2;
  int v5 = *(_DWORD *)(a1 + 88);
  if ((v5 & 0x100000) != 0)
  {
    __int16 v910 = (int *)(v4 + 316);
    goto LABEL_5;
  }

  __int16 v910 = (int *)(v4 + 316);
  if (*(_DWORD *)(a1 + 96) == *(_DWORD *)(a1 + 92))
  {
LABEL_5:
    int v7 = *(_DWORD *)(v4 + 316) - *(_DWORD *)(a1 + 160);
    else {
      int v8 = 0;
    }
    if (v7 >= *(_DWORD *)(a1 + 192) + v8)
    {
      int v9 = *(unsigned __int8 *)(a1 + 264);
      int v10 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 80);
      if (v10 && (v9 != 3 && v9 != 4 || v7 > 179999)) {
        v10(a1);
      }
      int v11 = *(void **)(a1 + 952);
      if (v11)
      {
        int v12 = (void *)(a1 + 952);
        do
        {
          int v14 = (void *)*v12;
          int v15 = (void *)(a1 + 952);
          if ((void *)*v12 != v11)
          {
            do
            {
              int v16 = v14;
              int v14 = (void *)v14[2];
            }

            while (v14 != v11);
            int v15 = v16 + 2;
          }

          int v13 = (void *)v11[2];
          *int v15 = v13;
          nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
          free(v11);
          int v11 = v13;
        }

        while (v13);
        *(_DWORD *)(a1 + 960) = *(_DWORD *)(a1 + 96);
      }

      if ((*(_BYTE *)(a1 + 742) & 1) != 0)
      {
        int v17 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
            - *(_DWORD *)(a1 + 336);
        if (v17 < 0) {
          int v17 = -v17;
        }
        if (v17 >= 0xDBBA1)
        {
          *(_DWORD *)(a1 + 740) &= ~0x10000u;
          *(_BYTE *)(a1 + 267) = 0;
          *(_DWORD *)(a1 + 88) &= 0x7DFFFFFFu;
          *(void *)(a1 + 328) = 0LL;
          *(_DWORD *)(a1 + 324) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                                + 100;
          *(_DWORD *)(a1 + 740) |= 2u;
          *(_WORD *)(a1 + 344) = 0;
        }
      }

      *(_WORD *)(a1 + 308) = 16;
      int v5 = *(_DWORD *)(a1 + 88);
    }

    char v6 = 1;
    goto LABEL_28;
  }

  char v6 = 0;
LABEL_28:
  v900 = 0;
  v897 = 0;
  v905 = 0LL;
  __int16 v906 = 0;
  uint64_t v895 = 0;
  v891 = 0;
  uint64_t v18 = 0LL;
  __int16 v908 = 0;
  unsigned int v19 = v5 & 0xFFEFFFFF;
  unsigned int v20 = *(_DWORD *)&v6 & ((v5 & 0x10000u) >> 16);
  if (v20) {
    int v21 = 0x100000;
  }
  else {
    int v21 = 0;
  }
  v885 = v20 ^ v6;
  *(_DWORD *)(a1 + 88) = v19 | v21;
  int type = (unsigned int *)(a1 + 100);
  __int16 v901 = (unsigned int *)(a1 + 940);
  v887 = v3 + 604;
  if (v907) {
    int v22 = -40;
  }
  else {
    int v22 = -20;
  }
  v890 = v22;
  if (v907) {
    int v23 = 40;
  }
  else {
    int v23 = 20;
  }
  if (v907) {
    int v24 = 56;
  }
  else {
    int v24 = 36;
  }
  v888 = v24;
  v889 = v23;
  int v25 = (void *)(a1 + 632);
  v886 = a1 + 568;
  uint64_t v26 = 17LL;
  if (v907)
  {
    uint64_t v27 = 18LL;
  }

  else
  {
    uint64_t v26 = 15LL;
    uint64_t v27 = 16LL;
  }

  v892 = 8 * v27;
  int v893 = 8 * v26;
  v894 = (unint64_t *)(a1 + 2000);
  v949 = (void *)(a1 + 632);
  int8x8_t v923 = v3;
  v940 = v2;
  while (1)
  {
    *(_DWORD *)(a1 + 88) &= ~0x10000000u;
    if (!*(void *)(v3 + 24))
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v793 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (LOBYTE(info.numer) == 17)
      {
        v794 = (os_log_s *)__nwlog_obj();
        numer = info.numer;
        if (os_log_type_enabled(v794, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          v796 = "%{public}s called with null protocol";
LABEL_1749:
          BOOL v815 = v794;
          BOOL v816 = numer;
LABEL_1750:
          _os_log_impl(&dword_1879E5000, v815, v816, v796, buf, 0xCu);
        }

LABEL_1751:
        if (v793) {
          free(v793);
        }
        int v25 = (void *)(a1 + 632);
LABEL_1754:
        if (*(int *)(a1 + 12) >= 5)
        {
          unsigned int v515 = 49LL;
          tcp_drop(a1, 49);
          return v515;
        }

        if ((*(_BYTE *)(v3 + 828) & 2) == 0)
        {
          int v817 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v817, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_output";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v887;
            _os_log_impl( &dword_1879E5000,  v817,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s path is non-viable, dropping output",  buf,  0x16u);
          }
        }

        if (!*(_DWORD *)(a1 + 28))
        {
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                               + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                               - *(_DWORD *)(a1 + 64);
          if (*(_DWORD *)(a1 + 36))
          {
            *(_DWORD *)(a1 + 36) = 0;
            *(_DWORD *)(a1 + 316) = 0;
            *(_WORD *)(a1 + 226) = 0;
            *(_DWORD *)(a1 + 248) = 0;
          }
        }

        int v818 = (void *)*v25;
        if (!*v25)
        {
LABEL_1786:
          *(void *)(a1 + 632) = 0LL;
          *(void *)(a1 + 640) = v949;
          *(_DWORD *)(a1 + 648) = 0;
          *(_DWORD *)(a1 + 300) = 0;
          goto LABEL_1707;
        }

        while (1)
        {
          unsigned int v819 = v818[4];
          unsigned int v820 = (void *)v818[5];
          if (v819)
          {
            *(void *)(v819 + 40) = v820;
            unsigned int v820 = (void *)v818[5];
          }

          else
          {
            *(void *)(a1 + 640) = v820;
          }

          *unsigned int v820 = v819;
          int v821 = (void (*)(void *, void, uint64_t))v818[10];
          v818[4] = 0LL;
          v818[5] = 0LL;
          if (!v821) {
            break;
          }
          int v822 = v818[11];
          v818[10] = 0LL;
          v818[11] = 0LL;
          v821(v818, 0LL, v822);
LABEL_1768:
          int v818 = (void *)*v949;
          if (!*v949) {
            goto LABEL_1786;
          }
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        unsigned int v823 = _os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        v948 = (void *)v823;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) == 17)
          {
            v941 = (os_log_s *)__nwlog_obj();
            v937 = info.numer;
            if (!os_log_type_enabled(v941, info.numer)) {
              goto LABEL_1784;
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v824 = v941;
            v825 = v937;
            v826 = "%{public}s called with null frame->finalizer";
            goto LABEL_1783;
          }

          if (v953 == OS_LOG_TYPE_DEFAULT)
          {
            v943 = (os_log_s *)__nwlog_obj();
            v939 = info.numer;
            if (!os_log_type_enabled(v943, info.numer)) {
              goto LABEL_1784;
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v824 = v943;
            v825 = v939;
            v826 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_1783;
          }

          backtrace_string = (void *)__nw_create_backtrace_string();
          v938 = (os_log_s *)__nwlog_obj();
          v934 = info.numer;
          uint64_t v827 = os_log_type_enabled(v938, info.numer);
          if (backtrace_string)
          {
            if (v827)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_1879E5000,  v938,  v934,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_1784;
          }

          if (v827)
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v824 = v938;
            v825 = v934;
            v826 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1783:
            _os_log_impl(&dword_1879E5000, v824, v825, v826, buf, 0xCu);
          }
        }

LABEL_1784:
        if (v948) {
          free(v948);
        }
        goto LABEL_1768;
      }

      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        v794 = (os_log_s *)__nwlog_obj();
        numer = info.numer;
        if (os_log_type_enabled(v794, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          v796 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_1749;
        }

        goto LABEL_1751;
      }

      v805 = (void *)__nw_create_backtrace_string();
      uint64_t v806 = (os_log_s *)__nwlog_obj();
      v807 = info.numer;
      v808 = os_log_type_enabled(v806, info.numer);
      if (v805)
      {
        if (v808)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v805;
          v809 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_1737:
          _os_log_impl(&dword_1879E5000, v806, v807, v809, buf, 0x16u);
        }

LABEL_1738:
        free(v805);
        goto LABEL_1751;
      }

      if (!v808) {
        goto LABEL_1751;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v796 = "%{public}s called with null protocol, no backtrace";
LABEL_1791:
      BOOL v815 = v806;
      BOOL v816 = v807;
      goto LABEL_1750;
    }

    uint64_t v28 = nw_protocol_downcast();
    if (!v28)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v793 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (LOBYTE(info.numer) == 17)
      {
        v794 = (os_log_s *)__nwlog_obj();
        numer = info.numer;
        if (os_log_type_enabled(v794, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          v796 = "%{public}s called with null tcp";
          goto LABEL_1749;
        }

        goto LABEL_1751;
      }

      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        v794 = (os_log_s *)__nwlog_obj();
        numer = info.numer;
        if (os_log_type_enabled(v794, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          v796 = "%{public}s called with null tcp, backtrace limit exceeded";
          goto LABEL_1749;
        }

        goto LABEL_1751;
      }

      v805 = (void *)__nw_create_backtrace_string();
      uint64_t v806 = (os_log_s *)__nwlog_obj();
      v807 = info.numer;
      v810 = os_log_type_enabled(v806, info.numer);
      if (v805)
      {
        if (v810)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v805;
          v809 = "%{public}s called with null tcp, dumping backtrace:%{public}s";
          goto LABEL_1737;
        }

        goto LABEL_1738;
      }

      if (!v810) {
        goto LABEL_1751;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcp_get_path_is_viable";
      v796 = "%{public}s called with null tcp, no backtrace";
      goto LABEL_1791;
    }

    if (*(void *)(v28 + 5208) && (*(_BYTE *)(v28 + 5309) & 0x20) == 0) {
      goto LABEL_1754;
    }
    uint64_t v29 = v2[62];
    if (v29)
    {
      uint64_t v30 = *(void *)(v29 + 216);
      int v31 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 88) = v31 & 0xEFFFFFFF;
      if ((*(_BYTE *)(*(void *)(a1 + 80) + 2236LL) & 2) != 0)
      {
        if (!v30)
        {
LABEL_68:
          v905 = 0LL;
          __int16 v906 = 0;
          int v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0) {
            goto LABEL_99;
          }
          goto LABEL_73;
        }

        if ((*(_BYTE *)(v30 + 1050) & 0x40) == 0) {
          goto LABEL_63;
        }
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        __int16 v32 = (unsigned int *)(v30 + 1060);
      }

      else
      {
        if (!v30) {
          goto LABEL_68;
        }
        if ((*(_BYTE *)(v30 + 1050) & 0x20) == 0) {
          goto LABEL_63;
        }
        *(_DWORD *)(a1 + 88) = v31 | 0x10000000;
        __int16 v32 = (unsigned int *)(v30 + 1056);
      }

      unsigned int v33 = *v32;
      if (v33 >= 0xFFFF) {
        int v34 = 0xFFFF;
      }
      else {
        int v34 = v33;
      }
      if (v33) {
        int v35 = v34;
      }
      else {
        int v35 = 0xFFFF;
      }
      *(_DWORD *)(a1 + 692) = v35;
LABEL_63:
      if (*(unsigned __int8 *)(v30 + 1076) == 255 || *(_DWORD *)(v30 + 1024) == 255)
      {
        __int16 v906 = 1;
      }

      else
      {
        if (*(_DWORD *)(v30 + 1068) == 3 || *(_DWORD *)(v30 + 1032) == 3)
        {
          __int16 v906 = 0;
          v905 = 0x100000000LL;
          int v37 = *(_DWORD *)(a1 + 740);
          if ((v37 & 0x20) == 0) {
            goto LABEL_99;
          }
          goto LABEL_73;
        }

        __int16 v906 = 0;
      }

      HIDWORD(v905) = 0;
      BOOL v36 = *(_DWORD *)(v30 + 1064) == 2 || *(_DWORD *)(v30 + 1028) == 2;
      LODWORD(v905) = v36;
    }

    int v37 = *(_DWORD *)(a1 + 740);
    if ((v37 & 0x20) == 0) {
      goto LABEL_99;
    }
LABEL_73:
    int v38 = *(_DWORD *)(a1 + 100);
    if (v38 - *(_DWORD *)(a1 + 96) >= 0) {
      goto LABEL_99;
    }
    if ((v37 & 0x20400000) != 0x20000000)
    {
      uint64_t v47 = *(void *)(a1 + 544);
      if (v47)
      {
        unsigned int v48 = *(_DWORD *)(a1 + 560);
        if ((int)(v38 - v48) < 0)
        {
          while (1)
          {
            int v65 = *(_DWORD *)(v47 + 4);
            uint64_t v47 = *(void *)(v47 + 16);
            int v66 = v38 - v65;
            if (!v47) {
              break;
            }
            if (v66 < 0) {
              goto LABEL_317;
            }
            unsigned int v67 = *(_DWORD *)v47;
            if (v38 - *(_DWORD *)v47 < 0)
            {
              *int type = v67;
              __int16 v908 = *(_DWORD *)(v47 + 4) - v67;
              goto LABEL_99;
            }
          }

          if ((v66 & 0x80000000) == 0)
          {
            __int16 v908 = 0;
            *int type = v48;
            goto LABEL_99;
          }

LABEL_317:
          __int16 v908 = v65 - v38;
          goto LABEL_99;
        }
      }

LABEL_99:
    if (*(_DWORD *)(a1 + 140) >= *(_DWORD *)(a1 + 144)) {
      int v49 = *(_DWORD *)(a1 + 144);
    }
    else {
      int v49 = *(_DWORD *)(a1 + 140);
    }
    int v50 = *(_DWORD *)(a1 + 88);
    int v51 = v49;
    if ((v50 & 0x80000) != 0)
    {
      uint64_t v52 = *(unsigned int *)(sysctls + 48);
      if (v49 >= v52) {
        int v53 = *(_DWORD *)(sysctls + 48);
      }
      else {
        int v53 = v49;
      }
      else {
        int v51 = v49;
      }
    }

    int v54 = 0;
    uint64_t v55 = 0LL;
    char v924 = *(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 92);
    int v56 = tcp_outflags[*(int *)(a1 + 12)];
    int v57 = 1;
    if ((*(_BYTE *)(a1 + 740) & 0x20) == 0 || (v50 & 0x200000) == 0)
    {
      unint64_t v61 = 0LL;
      v935 = 0;
      BOOL v62 = 0;
      int v63 = 0;
      goto LABEL_199;
    }

    int v58 = v49 - tcp_flight_size((_DWORD *)a1);
    BOOL v59 = v58 <= 0 && v900 == 0;
    if (v59) {
      int v58 = *(_DWORD *)(a1 + 196);
    }
    unsigned int v60 = v58 & ~(v58 >> 31);
    if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
    {
      uint64_t v55 = *(void *)(a1 + 1984);
      if (!v55)
      {
LABEL_121:
        int v54 = 0;
        goto LABEL_158;
      }

      while ((*(_BYTE *)(v55 + 12) & 7) != 2)
      {
        uint64_t v55 = *(void *)(v55 + 16);
        if (!v55) {
          goto LABEL_121;
        }
      }

      if (*(_DWORD *)(a1 + 196) >= v60) {
        unsigned __int16 v82 = v58 & ~(unsigned __int16)(v58 >> 31);
      }
      else {
        unsigned __int16 v82 = *(_DWORD *)(a1 + 196);
      }
      unsigned int v83 = tcp_seg_len((int *)v55);
      unsigned __int16 v84 = v82;
      if (v83 <= v82) {
        unsigned __int16 v84 = tcp_seg_len((int *)v55);
      }
      int v63 = v84;
      if (v60 < v84) {
        int v63 = v60;
      }
      if (!v63)
      {
        int v54 = 0;
        uint64_t v55 = 0LL;
        unint64_t v61 = 0LL;
        v935 = 0;
        BOOL v62 = 0;
        goto LABEL_160;
      }

      char v924 = *(_DWORD *)v55 - *(_DWORD *)(a1 + 92);
      uint64_t v85 = *(void *)(a1 + 1056);
      if (!v85)
      {
        int v54 = 0;
        unint64_t v61 = 0LL;
        int v57 = 0;
        v900 = 1;
        v935 = 1;
        BOOL v62 = 1;
        goto LABEL_199;
      }

      int v54 = 0;
      unint64_t v61 = 0LL;
      int v86 = (void *)(v85 + 616);
      uint64_t v87 = 1LL;
      BOOL v62 = 1;
LABEL_190:
      int v57 = 0;
      *v86 += v87;
      goto LABEL_198;
    }

    unint64_t v61 = *(int **)(a1 + 544);
    if (!v61)
    {
      int v54 = 0;
      goto LABEL_135;
    }

    int v54 = 0;
    while (2)
    {
      int v64 = v61[2];
      if (v64 - v61[1] >= 0)
      {
        v54 += v64 - *v61;
LABEL_126:
        unint64_t v61 = (int *)*((void *)v61 + 2);
        if (!v61) {
          goto LABEL_135;
        }
        continue;
      }

      break;
    }

    if (v64 - *(_DWORD *)(a1 + 92) < 0) {
      goto LABEL_126;
    }
    int v54 = v64 + v54 - *v61;
LABEL_135:
    uint64_t v68 = *(void *)(a1 + 616);
    v944 = v51;
    if (v68 && *(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) >= 0)
    {
      while (1)
      {
        uint64_t v68 = *(void *)(v68 + 16);
        if (!v68) {
          break;
        }
        if (*(_DWORD *)(v68 + 8) - *(_DWORD *)(v68 + 4) < 0)
        {
          *(void *)(a1 + 616) = v68;
          break;
        }
      }
    }

    int v69 = *(_DWORD *)(a1 + 624);
    int v70 = v54;
    if (v61 != (int *)v68)
    {
      uint64_t v71 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if (!v71 || (*(_BYTE *)(v71 + 828) & 2) == 0)
      {
        int v72 = (os_log_s *)__nwlog_tcp_log();
        BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_ERROR);
        int v54 = v70;
        if (v73)
        {
          int v74 = (const char *)(v71 + 604);
          *(_DWORD *)__int128 buf = 136446466;
          if (!v71) {
            int v74 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_sack_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v74;
          _os_log_impl( &dword_1879E5000,  v72,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s computed sack hole not the same as cached value",  buf,  0x16u);
          int v54 = v70;
        }
      }
    }

    if (v69 != v54)
    {
      uint64_t v75 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if (!v75 || (*(_BYTE *)(v75 + 828) & 2) == 0)
      {
        uint64_t v76 = (os_log_s *)__nwlog_tcp_log();
        BOOL v77 = os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
        int v54 = v70;
        if (v77)
        {
          int v78 = (const char *)(v75 + 604);
          *(_DWORD *)__int128 buf = 136446978;
          if (!v75) {
            int v78 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_sack_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v78;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v955 = v70;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v69;
          _os_log_impl( &dword_1879E5000,  v76,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s computed sack_bytes_retransmitted (%d) not the same as cached value (%d)",  buf,  0x22u);
          int v54 = v70;
        }
      }
    }

    if (!v61)
    {
      uint64_t v55 = 0LL;
      v935 = 0;
      BOOL v62 = 0;
      int v63 = 0;
      v900 = 1;
      int v57 = 1;
      int v2 = v940;
      int v51 = v944;
      goto LABEL_199;
    }

    uint64_t v79 = v61[1];
    uint64_t v80 = *(unsigned int *)(a1 + 152);
    int v2 = v940;
    int v51 = v944;
    if ((int)v79 - (int)v80 < 1)
    {
      uint64_t v88 = v61[2];
      uint64_t v89 = v79 - v88;
      int v90 = v79 - v88;
      if (v89 <= v60) {
        int v63 = v90;
      }
      else {
        int v63 = v60;
      }
      LODWORD(v81) = v61[2];
      if (v63 < 1)
      {
LABEL_194:
        uint64_t v55 = 0LL;
        goto LABEL_159;
      }

LABEL_176:
      char v924 = v81 - *(_DWORD *)(a1 + 92);
      int v91 = *(_DWORD *)(a1 + 100);
      int v92 = v91 - v81;
      BOOL v62 = v91 - *(_DWORD *)(a1 + 96) >= 0 || v92 > 0 || v63 > v908;
      uint64_t v95 = *(void *)(a1 + 1056);
      if (v95)
      {
        uint64_t v55 = 0LL;
        ++*(void *)(v95 + 576);
        LODWORD(v87) = *(_DWORD *)(a1 + 196);
        else {
          uint64_t v87 = v63;
        }
        int v86 = (void *)(v95 + 584);
        goto LABEL_190;
      }

      uint64_t v55 = 0LL;
      int v57 = 0;
LABEL_198:
      v900 = 1;
      v935 = 1;
      goto LABEL_199;
    }

    uint64_t v81 = v61[2];
    if ((int)v81 - (int)v80 < 0)
    {
      uint64_t v96 = v80 - v81;
      int v63 = v80 - v81;
      if (v96 > v60) {
        int v63 = v60;
      }
      if (v63 < 1) {
        goto LABEL_194;
      }
      goto LABEL_176;
    }

    uint64_t v55 = 0LL;
LABEL_158:
    unint64_t v61 = 0LL;
LABEL_159:
    v935 = 0;
    BOOL v62 = 0;
    int v63 = 0;
LABEL_160:
    v900 = 1;
    int v57 = 1;
LABEL_199:
    unsigned int v97 = *(_DWORD *)(a1 + 88);
    int v98 = (v97 >> 11) & 1 | v56;
    int v99 = *(_DWORD *)(a1 + 740);
    unsigned int v911 = v57;
    if ((v99 & 0x8000) == 0)
    {
LABEL_202:
      __int16 v912 = v54;
      if (!v57) {
        goto LABEL_239;
      }
LABEL_203:
      int v100 = (v97 >> 21) & 1;
      if ((v99 & 0x20400020) != 0x20000020) {
        LOBYTE(v100) = 0;
      }
      if (v54 || (v100 & 1) != 0)
      {
        int v102 = *(_DWORD *)(a1 + 144);
        int v103 = v102 - tcp_flight_size((_DWORD *)a1);
        int v104 = v103 & ~(v103 >> 31);
        unsigned int v105 = *(_DWORD *)(v3 + 384);
        if (v105 >= *(_DWORD *)(a1 + 140)) {
          unsigned int v105 = *(_DWORD *)(a1 + 140);
        }
        int v106 = v105 - v924;
        if (v106 >= v104) {
          int v107 = v103 & ~(v103 >> 31);
        }
        else {
          int v107 = v106;
        }
        if (v106 <= 0) {
          int v63 = 0;
        }
        else {
          int v63 = v107;
        }
        if (v63) {
          BOOL v108 = 1;
        }
        else {
          BOOL v108 = v103 < 1;
        }
        if (v108)
        {
          int v54 = v912;
        }

        else
        {
          int v109 = *(_DWORD *)(a1 + 560);
          int v110 = *(_DWORD *)(a1 + 152);
          int v54 = v912;
          int v63 = 0;
          if (v109 - v110 < 0)
          {
            int v111 = *(_DWORD *)(a1 + 740);
            if ((v111 & 0x80000) == 0 && (v111 & 0x20400020) != 0x20000020)
            {
              int v63 = v110 - v109;
              if (v63 >= v104) {
                int v63 = v104;
              }
              v891 = *(_DWORD *)(a1 + 100);
              int v112 = v110 - v63;
              *(_DWORD *)(a1 + 100) = v110 - v63;
              if ((*(_BYTE *)(a1 + 88) & 0x10) != 0 && *(_DWORD *)(a1 + 96) == v110) {
                *int type = --v112;
              }
              BOOL v62 = 0;
              char v924 = v112 - *(_DWORD *)(a1 + 92);
              *(_DWORD *)(a1 + 740) = v111 | 0x80000;
              v897 = 1;
            }
          }
        }
      }

      else
      {
        uint64_t v101 = *(unsigned int *)(v3 + 384);
        if (v101 >= v51) {
          LODWORD(v101) = v51;
        }
        int v63 = v101 - v924;
      }

      goto LABEL_239;
    }

    if (v51)
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 316) = 0;
      *(_WORD *)(a1 + 226) = 0;
      *(_DWORD *)(a1 + 248) = 0;
      goto LABEL_202;
    }

    if (v924 < *(_DWORD *)(v3 + 384)) {
      int v98 = v56 & 0xFE;
    }
    int v51 = 1;
    __int16 v912 = v54;
    if (v57) {
      goto LABEL_203;
    }
LABEL_239:
    if (v63 >= v908) {
      int v113 = v908;
    }
    else {
      int v113 = v63;
    }
    if (v63 > 0 && v908 != 0) {
      int v63 = v113;
    }
    if (*(_BYTE *)(a1 + 264) == 4)
    {
      unsigned int v115 = *(_DWORD *)(a1 + 488);
      BOOL v116 = !v115 || v63 <= 0;
      BOOL v117 = !v116;
      if (v117 && v63 > v115)
      {
        BOOL v62 = 1;
        int v63 = *(_DWORD *)(a1 + 488);
      }
    }

    if ((v98 & 2) == 0 || (v118 = *(_DWORD *)(a1 + 100), int v119 = *(_DWORD *)(a1 + 92), v118 - v119 < 1))
    {
      int v122 = v63;
      goto LABEL_265;
    }

    int v120 = *(_DWORD *)(a1 + 12);
    if (v120 != 3)
    {
      v98 &= ~2u;
      --v924;
      int v122 = v63 + 1;
      if (v63 < 0 || v120 != 2) {
        goto LABEL_265;
      }
      if (*((_BYTE *)v2 + 2238)) {
        goto LABEL_1707;
      }
      v664 = *(_DWORD *)(a1 + 88);
      if (*(void *)(a1 + 632))
      {
        v783 = *(_DWORD *)(a1 + 300);
        if (v54) {
          v784 = 1;
        }
        else {
          v784 = v935;
        }
        *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 88) = v664 & 0xFFFFFFFC;
        *(_DWORD *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 304) = 0;
        tcp_ip_output_send(v3, a1, v949, v783, v784);
        *(void *)(a1 + 632) = 0LL;
        *(void *)(a1 + 640) = v949;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        if (*((_BYTE *)v2 + 2238)) {
          goto LABEL_1707;
        }
        v664 = *(_DWORD *)(a1 + 88);
      }

      if ((v664 & 0x8000000) != 0)
      {
LABEL_1807:
        *(_DWORD *)(a1 + 88) = v664 & 0xF7FFFFFF;
        tcp_close(a1);
        return 0LL;
      }

LABEL_1707:
      tcp_check_timer_state(a1);
      return 0LL;
    }

    int v121 = *(_DWORD *)(a1 + 740);
    if ((v118 != v119 + 1 || (v121 & 0x400000) == 0) && (v121 & 0x400000) != 0) {
      v98 &= ~2u;
    }
    --v924;
    int v122 = v63 + 1;
LABEL_265:
    if ((v98 & 2) != 0)
    {
      int v123 = *(_DWORD *)(a1 + 740);
      if ((v123 & 0x400000) == 0) {
        v98 &= ~1u;
      }
      v122 &= v123 << 9 >> 31;
    }

    if ((v98 & 4) != 0) {
      LODWORD(v124) = 0;
    }
    else {
      LODWORD(v124) = v122;
    }
    if ((v98 & 2) != 0)
    {
      int v125 = *(_DWORD *)(a1 + 740);
      if ((v125 & 0x400000) == 0) {
        goto LABEL_301;
      }
      if ((*(_BYTE *)(a1 + 88) & 8) == 0)
      {
        uint64_t v126 = *(void *)(a1 + 80);
        uint64_t v127 = *(void *)(v126 + 224);
        if ((v125 & 0x1000000) != 0
          || (char v128 = (*(uint64_t (**)(void))(*(void *)(v126 + 2136) + 32LL))(*(void *)(v126 + 224)),
              int v54 = v912,
              (v128 & 1) != 0))
        {
          if ((*(_BYTE *)(v127 + 370) & 1) != 0) {
            goto LABEL_301;
          }
          int v129 = *(_DWORD *)(a1 + 88);
          v945 = *(_DWORD *)(a1 + 740);
          unsigned int v130 = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 80) + 2136LL) + 48LL))(*(void *)(*(void *)(a1 + 80) + 224LL));
          if (!v130)
          {
            LODWORD(v124) = 0;
            uint64_t v3 = v923;
            int v54 = v912;
            goto LABEL_301;
          }

          if ((v129 & 0x20) != 0) {
            int v131 = -8;
          }
          else {
            int v131 = -4;
          }
          if ((v129 & 0x80) != 0) {
            v131 -= 12;
          }
          uint64_t v3 = v923;
          int v54 = v912;
          if (v131 - ((v945 >> 4) & 2) + 40 >= v130
            && *(_DWORD *)(v127 + 384) <= (*(_DWORD *)(a1 + 156) - 40))
          {
            goto LABEL_301;
          }
        }

        else
        {
          *(_WORD *)(a1 + 990) |= 0x800u;
          uint64_t v132 = *(void *)(a1 + 1056);
          if (v132) {
            ++*(void *)(v132 + 1168);
          }
        }
      }

      LODWORD(v124) = 0;
      *(_DWORD *)(a1 + 740) &= ~0x400000u;
      goto LABEL_301;
    }

    if ((int)v124 <= 0)
    {
      if (!v51)
      {
        char v924 = 0;
        LODWORD(v124) = 0;
        *(_DWORD *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_WORD *)(a1 + 226) = 0;
        *(_DWORD *)(a1 + 248) = 0;
        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 36)) {
          goto LABEL_301;
        }
        tcp_setpersist(a1);
        int v54 = v912;
        char v924 = 0;
      }

      LODWORD(v124) = 0;
    }

    else
    {
      LODWORD(v124) = v122;
    }

LABEL_301:
    if ((v940[2231] & 0x50) == 0 && (*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      int v133 = *(_DWORD *)(v3 + 432);
      if ((v133 & 0xC00) == 0x400)
      {
        uint64_t v134 = *(unsigned int *)(v3 + 388);
        if (5 * (*(_DWORD *)(a1 + 140) >> 2) >= v134)
        {
          unsigned int v135 = *(_DWORD *)(v3 + 384);
          if (v135 >= 7 * (v134 >> 3)
            && v51 >= (int)(v135 - *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 92)))
          {
            uint64_t v136 = *(unsigned int *)(sysctls + 116);
            unint64_t v137 = v136 + v134;
            unsigned int v138 = v136 + v134;
            if (v138 <= 0x71C71C)
            {
              *(_DWORD *)(v3 + 388) = v138;
              uint64_t v139 = *(void *)(*(void *)(v3 + 456) + 24LL);
              if ((v133 & 4) != 0)
              {
                if (v139)
                {
                  uint64_t all_stats = nw_protocol_tcp_get_all_stats();
                  int v54 = v912;
                  if (all_stats) {
                    *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v3 + 388);
                  }
                }
              }

              else if (v139)
              {
                uint64_t v140 = nw_protocol_tcp_get_all_stats();
                int v54 = v912;
                if (v140) {
                  *(_DWORD *)(v140 + 100) = *(_DWORD *)(v3 + 388);
                }
              }

              unsigned int v142 = *(_DWORD *)(v3 + 388);
              if (*(_DWORD *)(v3 + 392) > v142) {
                *(_DWORD *)(v3 + 392) = v142;
              }
              *(_DWORD *)(v3 + 436) = v142;
            }
          }
        }
      }
    }

    uint64_t v143 = *(unsigned int *)(a1 + 196);
    if ((int)v124 <= (int)v143)
    {
      int v144 = 0;
    }

    else if ((*(_BYTE *)(a1 + 91) & 0x10) != 0 {
           && *(_DWORD *)(sysctls + 324)
    }
           && !(*(_DWORD *)(a1 + 564) | v935 | v54)
           && !*((void *)v940 + 273))
    {
      BOOL v62 = 0;
      int v144 = 1;
    }

    else
    {
      int v144 = 0;
      BOOL v62 = 1;
      LODWORD(v124) = *(_DWORD *)(a1 + 196);
    }

    int v145 = *(_DWORD *)(a1 + 740);
    if ((v145 & 0x1000) != 0) {
      int v144 = 0;
    }
    __int16 v914 = v144;
    BOOL v146 = (v145 & 0x1000) == 0 && v62;
    int v913 = v146;
    else {
      unint64_t v124 = v143;
    }
    char v898 = (unsigned int *)(v61 + 2);
    if ((v145 & 0x20400020) == 0x20000020) {
      signed int v148 = (_DWORD *)v55;
    }
    else {
      signed int v148 = v61 + 2;
    }
    if (!v935) {
      signed int v148 = (_DWORD *)(a1 + 100);
    }
    else {
      unsigned int v149 = v98 & 0xFFFFFFFE;
    }
    int v150 = tcp_sbspace(a1);
    int v151 = v150;
    if (v150 < *(_DWORD *)(v3 + 492) >> 2)
    {
      if (v150 >= *(_DWORD *)(a1 + 196)) {
        int v151 = v150;
      }
      else {
        int v151 = 0;
      }
    }

    uint64_t v152 = sysctls;
    if (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(v3 + 369) & 0x40) != 0)
    {
      int v153 = *(_DWORD *)(sysctls + 308);
      if (v153 && (v153 == 1 && (~*(_DWORD *)(a1 + 88) & 0x180) == 0 || *(int *)(a1 + 12) <= 3))
      {
        if (v151 >= 1)
        {
          if (off_18C4CE838)
          {
            int v154 = off_18C4CE838(a1);
            if (v151 >= v154) {
              int v151 = v154;
            }
          }
        }

        goto LABEL_389;
      }

      if (v151 < 1) {
        goto LABEL_389;
      }
      if (*(_DWORD *)(sysctls + 124) != 1 || (~*(_DWORD *)(a1 + 88) & 0x180) != 0) {
        goto LABEL_383;
      }
      int v155 = *(_DWORD *)(a1 + 740);
      if ((v155 & 0x100) != 0) {
        goto LABEL_384;
      }
      uint64_t v156 = *(void *)(a1 + 80);
      uint64_t v157 = *(void *)(v156 + 496);
      if (v157
        && (uint64_t v158 = *(void *)(v157 + 1488)) != 0
        && (int v159 = *(_DWORD *)(v158 + 40)) != 0
        && (unsigned int v160 = *(_DWORD *)(a1 + 236)) != 0)
      {
        if (v160 <= *(_DWORD *)(sysctls + 4) + v159) {
          goto LABEL_389;
        }
        unsigned int v161 = v149;
        uint64_t v162 = *(void *)(v156 + 224);
        *(_DWORD *)(a1 + 740) = v155 | 0x100;
        if (!*(_DWORD *)(a1 + 1040))
        {
          *(_DWORD *)(a1 + 1040) = *(_DWORD *)(nw_tcp_access_globals(v162) + 316);
          uint64_t v152 = sysctls;
        }

        unsigned int v163 = *(_DWORD *)(v162 + 540);
        unsigned int v164 = *(_DWORD *)(v152 + 128);
        if (v163 > v164)
        {
          unsigned int v165 = v163 >> 1;
          if (v165 > v164) {
            unsigned int v164 = v165;
          }
          *(_DWORD *)(v162 + 540) = v164;
        }

        unsigned int v149 = v161;
      }

      else
      {
LABEL_383:
      }

LABEL_384:
      int v166 = *(_DWORD *)(a1 + 120);
      int v167 = v166 + *(_DWORD *)(a1 + 196) * *(_DWORD *)(v152 + 108);
      if (*(_DWORD *)(a1 + 124) - v167 >= 0) {
        int v167 = *(_DWORD *)(a1 + 124);
      }
      int v168 = v167 - v166;
      if (v168 >= v151) {
        int v168 = v151;
      }
      int v151 = v168 & ~(v168 >> 31);
    }

LABEL_389:
    char v169 = *(_BYTE *)(a1 + 261);
    int v170 = 0xFFFF << v169;
    if (v151 >= 0xFFFF << v169) {
      int v171 = 0xFFFF << v169;
    }
    else {
      int v171 = v151;
    }
    if ((*(_BYTE *)(v3 + 367) & 2) == 0 && v171 <= *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120)) {
      int v171 = *(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 120);
    }
    unsigned int v909 = v171;
    if (!(_DWORD)v124) {
      goto LABEL_429;
    }
    int v172 = *(_DWORD *)(a1 + 740);
    if ((v172 & 0x8000) != 0) {
      goto LABEL_457;
    }
    uint64_t v174 = *(unsigned int *)(a1 + 96);
    uint64_t v173 = *(unsigned int *)(a1 + 100);
    if ((int)v173 - (int)v174 < 0)
    {
      if ((~v172 & 0x20000020) == 0 && !(v172 & 0x400000 | v935))
      {
        else {
          unint64_t v124 = v124;
        }
      }

      goto LABEL_457;
    }

    if ((v935 & 1) != 0) {
      goto LABEL_457;
    }
    int v175 = *(_DWORD *)(a1 + 12);
    if ((v172 & 0x400000) == 0 || v175 != 3)
    {
      if (v175 == 4 && (*((_DWORD *)v940 + 557) & 0x50000000) != 0)
      {
        uint64_t v176 = *(void *)(a1 + 1056);
        int v171 = v909;
        if (v176) {
          ++*(void *)(v176 + 96);
        }
        goto LABEL_429;
      }

LABEL_413:
      int v177 = *(_DWORD *)(a1 + 88);
      if ((v177 & 0x10000) == 0)
      {
        if (v885 & 1 | ((v177 & 0x1000004) != 0))
        {
          if ((v177 & 0x1000) != 0) {
            goto LABEL_424;
          }
        }

        else
        {
          int v178 = *(_DWORD *)(a1 + 8);
          if (v178 < 1
            || (v177 & 0x1000) != 0
            || (*(_DWORD *)(a1 + 740) & 0x6000) == 0x6000
            || v178 >= *(unsigned __int8 *)(a1 + 310))
          {
            goto LABEL_424;
          }
        }
      }

LABEL_424:
      int v179 = *(_DWORD *)(a1 + 252);
      if (v179 >= 0) {
        int v180 = *(_DWORD *)(a1 + 252);
      }
      else {
        int v180 = v179 + 1;
      }
      int v171 = v909;
LABEL_429:
      if (v171 >= 1)
      {
        if (v171 < v170) {
          int v170 = v171;
        }
        int v181 = *(_DWORD *)(a1 + 120);
        int v182 = *(_DWORD *)(a1 + 124) - v181;
        int v183 = v170 - v182;
        unsigned int v184 = v182 & ~(v182 >> 31);
        int v185 = *(_DWORD *)(sysctls + 288);
        int v186 = 2 * *(_DWORD *)(a1 + 196);
        if (v185)
        {
          if (v183 < v186)
          {
            if ((*(_BYTE *)(a1 + 88) & 2) != 0
              && !*(_DWORD *)(v3 + 488)
              && *(_DWORD *)(a1 + 284) != v181
              && (*(_BYTE *)(a1 + 740) & 0x10) != 0)
            {
              goto LABEL_457;
            }

            goto LABEL_445;
          }

          if (*(_DWORD *)(v3 + 488) >= *(_DWORD *)(v3 + 496)) {
            goto LABEL_445;
          }
        }

        else if (v183 < v186 || (*(_DWORD *)(a1 + 88) & 0x80000000) != 0)
        {
          goto LABEL_445;
        }

LABEL_445:
        if (*(_DWORD *)(v3 + 492) <= 4 * v183) {
          goto LABEL_457;
        }
        if (!v185)
        {
          int v187 = *(_DWORD *)(a1 + 88);
          if ((v187 & 0x80000002) == 0x80000000)
          {
            *(_DWORD *)(a1 + 88) = v187 | 2;
            *(_DWORD *)(a1 + 32) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                                 - *(_DWORD *)(a1 + 64)
                                 + 100;
          }
        }
      }

      int v188 = *(_DWORD *)(a1 + 88);
      if ((v188 & 1) != 0)
      {
        if (*(_WORD *)(a1 + 308)) {
          --*(_WORD *)(a1 + 308);
        }
        goto LABEL_457;
      }

      if ((v149 & 6) != 0 || (v149 & 1) != 0 && ((v188 & 0x10) == 0 || *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92))) {
        goto LABEL_457;
      }
      if ((*(_BYTE *)(a1 + 740) & 0x20) == 0
        || *(int *)(a1 + 12) < 4
        || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) < 1
        || *(_DWORD *)(a1 + 28)
        || *(_DWORD *)(a1 + 36))
      {
        os_log_type_t v788 = v940;
        if (*(_DWORD *)(v3 + 384) && !*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
        {
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
          tcp_setpersist(a1);
        }
      }

      else
      {
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                             - *(_DWORD *)(a1 + 64);
        os_log_type_t v788 = v940;
      }

      if (!v788[2238])
      {
        int v830 = v912 ? 1 : v935;
        tcp_ip_output(v3, a1, v949, *(_DWORD *)(a1 + 300), v830);
        *(void *)(a1 + 632) = 0LL;
        *(void *)(a1 + 640) = v949;
        *(_DWORD *)(a1 + 648) = 0;
        *(_DWORD *)(a1 + 300) = 0;
        if (!v788[2238])
        {
          v664 = *(_DWORD *)(a1 + 88);
          if ((v664 & 0x8000000) != 0) {
            goto LABEL_1807;
          }
        }
      }

      goto LABEL_1707;
    }

    if ((*(_BYTE *)(a1 + 988) & 2) == 0 || (_DWORD)v173 != *(_DWORD *)(a1 + 112) + 1) {
      goto LABEL_413;
    }
LABEL_457:
    int v189 = *(_DWORD *)(a1 + 740);
    if ((v189 & 0x10000000) == 0 && ((v189 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v190 = *(_DWORD *)(a1 + 348);
      if ((~v190 & 0x300000) == 0 && *(_DWORD *)(a1 + 12) == 4)
      {
        int v191 = *(_DWORD *)(a1 + 112);
        if (*(_DWORD *)(a1 + 92) == v191 + 1
          && *(_DWORD *)(a1 + 560) == v191
          && (v190 & 0x2000000) == 0
          && *(_WORD *)(a1 + 226))
        {
          *(_DWORD *)(a1 + 348) = v190 | 0x2000000;
        }
      }
    }

    int v192 = *(_DWORD *)(a1 + 88);
    if ((v149 & 2) == 0
      || (int v193 = *(_DWORD *)(a1 + 112), *(_DWORD *)(a1 + 100) = v193, *(_DWORD *)(a1 + 560) = v193, (v192 & 8) != 0))
    {
      unsigned int v203 = 0;
      if ((v149 & 4) == 0) {
        goto LABEL_487;
      }
    }

    else
    {
      unsigned int v194 = v149;
      __src[0] = 1026;
      uint64_t v195 = *(void *)(a1 + 80);
      char v196 = *(_BYTE *)(v195 + 2236);
      if ((v196 & 2) != 0) {
        int v197 = -60;
      }
      else {
        int v197 = -40;
      }
      if ((*(_BYTE *)(v195 + 2236) & 2) != 0)
      {
        uint64_t v198 = tcp_rtlookup6(v195, 0LL);
        if (v198) {
          goto LABEL_477;
        }
      }

      else
      {
        uint64_t v198 = tcp_rtlookup(v195, 0LL);
        if (v198)
        {
LABEL_477:
          uint64_t v199 = *(void *)(v198 + 216);
          if (*(_BYTE *)(v199 + 1076) == 23
            && *(int *)(sysctls + 48) >= 1
            && (*(_DWORD *)(v199 + 1040) - 9601) >> 7 <= 0x39C)
          {
            *(_DWORD *)(a1 + 88) |= 0x80000u;
          }

          uint64_t v200 = *(void *)(v198 + 1488);
          if (v200 && (unsigned int v201 = *(_DWORD *)(v200 + 48)) != 0)
          {
            unsigned int v202 = *(_DWORD *)(v199 + 1044);
            if (v201 < v202) {
              unsigned int v202 = v201;
            }
          }

          else
          {
            unsigned int v202 = *(_DWORD *)(v199 + 1044);
          }

          unsigned int v220 = v202 + v197;
          goto LABEL_521;
        }
      }

      uint64_t v219 = 152LL;
      if ((v196 & 2) == 0) {
        uint64_t v219 = 148LL;
      }
      unsigned int v220 = *(_DWORD *)(sysctls + v219);
LABEL_521:
      __src[1] = bswap32(v220) >> 16;
      int v192 = *(_DWORD *)(a1 + 88);
      unsigned int v149 = v194;
      if ((v192 & 0x20) != 0 && ((v194 & 0x10) == 0 || (v192 & 0x40) != 0))
      {
        v959 = bswap32(*(unsigned __int8 *)(a1 + 262) | 0x1030300);
        unsigned int v203 = 8;
        if ((v194 & 4) != 0) {
          goto LABEL_491;
        }
      }

      else
      {
        unsigned int v203 = 4;
        if ((v194 & 4) != 0) {
          goto LABEL_491;
        }
      }

LABEL_487:
      if ((v192 & 0x88) == 0x80 && ((v149 & 0x10) == 0 || (v192 & 0x100) != 0))
      {
        int v204 = (_DWORD *)((char *)__src + v203);
        *int v204 = 168296705;
        unsigned int v205 = bswap32(*(_DWORD *)(a1 + 276));
        v204[1] = bswap32(*(_DWORD *)(a1 + 1888) + *v910);
        v204[2] = v205;
        v203 += 12;
      }
    }

LABEL_491:
    int v206 = v149 & 2;
    int v207 = *(_DWORD *)(a1 + 740);
    if ((v207 & 0x20) != 0 && (v149 & 2) != 0 && (v192 & 8) == 0 && ((v149 & 0x10) == 0 || (v192 & 0x200) != 0))
    {
      *(_WORD *)((char *)__src + v203) = 516;
      v203 += 2;
    }

    if ((v207 & 0x400000) == 0)
    {
      unsigned int v208 = 0;
      int v209 = v149 & 0x12;
      goto LABEL_539;
    }

    if ((v149 & 0x12) != 2 || (v192 & 8) != 0)
    {
      if ((v149 & 0x12) == 0x12)
      {
        if ((*(_BYTE *)(a1 + 988) & 1) != 0)
        {
          unsigned int v222 = v203;
          tcp_tfo_gen_cookie(*(void *)(a1 + 80), buf);
          unsigned int v223 = (char *)__src + v222;
          *(_WORD *)unsigned int v223 = 2594;
          *(void *)(v223 + 2) = *(void *)buf;
          *(_WORD *)(a1 + 990) |= 4u;
          uint64_t v224 = *(void *)(a1 + 1056);
          if (v224) {
            ++*(void *)(v224 + 1072);
          }
          unsigned int v208 = 0;
          LOBYTE(v203) = v222 + 10;
          int v207 = *(_DWORD *)(a1 + 740);
        }

        else
        {
          unsigned int v208 = 0;
        }

        BOOL v218 = 1;
        if ((v207 & 0x20) != 0) {
          goto LABEL_540;
        }
      }

      else
      {
        BOOL v218 = 0;
        unsigned int v208 = 0;
        if ((v207 & 0x20) != 0) {
          goto LABEL_540;
        }
      }

LABEL_566:
      if ((v207 & 0x10000000) != 0) {
        goto LABEL_657;
      }
LABEL_567:
      if ((v207 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1) {
        goto LABEL_657;
      }
      int v239 = *(_DWORD *)(a1 + 348);
      if ((~v239 & 0x300000) != 0)
      {
        if ((v239 & 0x2200000) != 0x200000 || !v218) {
          goto LABEL_657;
        }
      }

      else if ((v239 & 0x2000000) != 0)
      {
        goto LABEL_657;
      }

      uint64_t v241 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if ((40 - v203) <= 1u)
      {
        unsigned __int8 v242 = v203;
        if (v241 && (*(_BYTE *)(v241 + 828) & 2) != 0 || !__nwlog_is_datapath_logging_enabled())
        {
LABEL_584:
          uint64_t v3 = v923;
LABEL_585:
          LOBYTE(v203) = v242;
          goto LABEL_657;
        }

        unsigned int v245 = v149;
        v696 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v696, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v697 = (const char *)(v241 + 604);
          *(_DWORD *)__int128 buf = 136446466;
          if (!v241) {
            os_log_type_t v697 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v697;
          _os_log_impl( &dword_1879E5000,  v696,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s not enough space to add any AccECN option",  buf,  0x16u);
        }

LABEL_1495:
        uint64_t v3 = v923;
        unsigned int v149 = v245;
        goto LABEL_585;
      }

      int v243 = *(_DWORD *)(a1 + 432);
      if ((v239 & 0x400000 | v206 || (v239 & 0x1800000) != 0 || *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 112) + 1)
        && (!v218 || !*(_WORD *)(a1 + 226)))
      {
        uint64_t v244 = (_DWORD *)((char *)__src + (v203 | ((unint64_t)v208 << 8)));
        if ((40 - v203) > 4u)
        {
          if ((40 - v203) > 7u)
          {
            int v264 = *(_DWORD *)(a1 + 448) & 0xFFFFFF;
            if ((40 - v203) > 0xAu)
            {
              BOOL v423 = (v239 & 0x800000) == 0;
              if ((v239 & 0x800000) != 0) {
                unsigned int v424 = *(_DWORD *)(a1 + 432);
              }
              else {
                unsigned int v424 = *(_DWORD *)(a1 + 440);
              }
              if (v423) {
                int v425 = -1408565248;
              }
              else {
                int v425 = -1375010816;
              }
              if (!v423) {
                int v243 = *(_DWORD *)(a1 + 440);
              }
              *uint64_t v244 = bswap32(v425 & 0xFFFF0000 | (unsigned __int16)(v424 >> 8));
              v244[1] = bswap32(v264 | (v424 << 24));
              v244[2] = bswap32((v243 << 8) | 1);
              unsigned __int8 v242 = v203 + 12;
              unsigned int v245 = v149;
              os_log_type_t v426 = (os_log_s *)__nwlog_tcp_log();
              if (!os_log_type_enabled(v426, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_1495;
              }
              int v427 = (const char *)(v241 + 604);
              *(_DWORD *)__int128 buf = 136446722;
              if (!v241) {
                int v427 = "";
              }
              *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v427;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)v955 = v242;
              int v248 = v426;
              uint64_t v249 = "%{public}s %{public}s add all 3 counters for AccECN option, optlen=%u";
            }

            else
            {
              BOOL v265 = (v239 & 0x800000) == 0;
              if ((v239 & 0x800000) != 0) {
                unsigned int v266 = *(_DWORD *)(a1 + 432);
              }
              else {
                unsigned int v266 = *(_DWORD *)(a1 + 440);
              }
              if (v265) {
                int v267 = -1408761856;
              }
              else {
                int v267 = -1375207424;
              }
              *uint64_t v244 = bswap32(v267 & 0xFFFF0000 | (unsigned __int16)(v266 >> 8));
              v244[1] = bswap32(v264 | (v266 << 24));
              unsigned __int8 v242 = v203 + 8;
              unsigned int v245 = v149;
              os_log_type_t v268 = (os_log_s *)__nwlog_tcp_log();
              if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_1495;
              }
              uint64_t v269 = (const char *)(v241 + 604);
              *(_DWORD *)__int128 buf = 136446722;
              if (!v241) {
                uint64_t v269 = "";
              }
              *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v269;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)v955 = v242;
              int v248 = v268;
              uint64_t v249 = "%{public}s %{public}s add 2 counters for AccECN option, optlen=%u";
            }
          }

          else
          {
            BOOL v259 = (v239 & 0x800000) == 0;
            if ((v239 & 0x800000) != 0) {
              unsigned int v260 = *(_DWORD *)(a1 + 432);
            }
            else {
              unsigned int v260 = *(_DWORD *)(a1 + 440);
            }
            if (v259) {
              int v261 = -1408958464;
            }
            else {
              int v261 = -1375404032;
            }
            *uint64_t v244 = bswap32(v261 & 0xFFFF0000 | (unsigned __int16)(v260 >> 8));
            v244[1] = bswap32((v260 << 24) | 0x10101);
            unsigned __int8 v242 = v203 + 8;
            unsigned int v245 = v149;
            uint64_t v262 = (os_log_s *)__nwlog_tcp_log();
            if (!os_log_type_enabled(v262, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_1495;
            }
            __int16 v263 = (const char *)(v241 + 604);
            *(_DWORD *)__int128 buf = 136446722;
            if (!v241) {
              __int16 v263 = "";
            }
            *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v263;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)v955 = v242;
            int v248 = v262;
            uint64_t v249 = "%{public}s %{public}s add single counter for AccECN option, optlen=%u";
          }

          goto LABEL_992;
        }

        if (v206)
        {
          *uint64_t v244 = 16843438;
          unsigned __int8 v242 = v203 + 4;
          unsigned int v245 = v149;
          int v246 = (os_log_s *)__nwlog_tcp_log();
          if (!os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_1495;
          }
          uint64_t v247 = (const char *)(v241 + 604);
          *(_DWORD *)__int128 buf = 136446722;
          if (!v241) {
            uint64_t v247 = "";
          }
          *(void *)&uint8_t buf[4] = "tcp_add_accecn_option";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v247;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v955 = v242;
          int v248 = v246;
          uint64_t v249 = "%{public}s %{public}s add empty AccECN option, optlen=%u";
LABEL_992:
          _os_log_impl(&dword_1879E5000, v248, OS_LOG_TYPE_DEBUG, v249, buf, 0x1Cu);
          LOBYTE(v203) = v242;
          uint64_t v3 = v923;
          unsigned int v149 = v245;
          goto LABEL_657;
        }
      }

      uint64_t v3 = v923;
      goto LABEL_657;
    }

    uint64_t v210 = *(void *)(a1 + 80);
    uint64_t v211 = *(void *)(v210 + 224);
    buf[0] = 38 - v203;
    if ((*(_BYTE *)(v211 + 370) & 1) != 0)
    {
      if ((int)v124 >= 1)
      {
        *(_WORD *)(a1 + 990) |= 0x40u;
        uint64_t v217 = *(void *)(a1 + 1056);
        if (v217)
        {
          int v216 = 0;
          goto LABEL_518;
        }
      }

      int v216 = 0;
      goto LABEL_538;
    }

    unsigned int v212 = v149;
    unsigned int v213 = v203;
    os_log_type_t v214 = (char *)__src + v203;
    char v215 = (*(uint64_t (**)(uint64_t, char *))(*(void *)(v210 + 2136) + 40LL))(v211, v214 + 2);
    *os_log_type_t v214 = 34;
    if ((v215 & 1) == 0)
    {
      int v216 = 2;
      v214[1] = 2;
      *(_BYTE *)(a1 + 988) |= 4u;
      *(_WORD *)(a1 + 990) |= 0x10u;
      uint64_t v225 = *(void *)(a1 + 1056);
      if (v225)
      {
        int64x2_t v221 = (void *)(v225 + 1104);
        unsigned int v149 = v212;
        unsigned int v203 = v213;
        goto LABEL_536;
      }

LABEL_537:
      unsigned int v149 = v212;
      unsigned int v203 = v213;
      goto LABEL_538;
    }

    int v216 = buf[0] + 2;
    v214[1] = buf[0] + 2;
    *(_BYTE *)(a1 + 988) |= 8u;
    *(_WORD *)(a1 + 990) |= 0x40u;
    uint64_t v217 = *(void *)(a1 + 1056);
    unsigned int v149 = v212;
    unsigned int v203 = v213;
    if (!v217) {
      goto LABEL_538;
    }
LABEL_518:
    int64x2_t v221 = (void *)(v217 + 1120);
LABEL_536:
    ++*v221;
LABEL_538:
    v203 += v216;
    unsigned int v208 = v203 >> 8;
    int v207 = *(_DWORD *)(a1 + 740);
    int v209 = 2;
LABEL_539:
    BOOL v218 = v209 == 18;
    if ((v207 & 0x20) == 0) {
      goto LABEL_566;
    }
LABEL_540:
    int v226 = *(_DWORD *)(a1 + 88);
    uint64_t v227 = *(int *)(a1 + 564);
    if ((int)v227 <= 0 && (!*v901 || !*(_DWORD *)(a1 + 944))
      || (uint64_t v228 = v203 | (v208 << 8), v229 = 38 - v228, (38 - v228) < 8))
    {
      uint64_t v3 = v923;
      goto LABEL_566;
    }

    v946 = v149;
    unsigned int v230 = v229 >> 3;
    if ((v207 & 0x10000000) == 0
      && v229 >= 0x18
      && ((v207 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v231 = *(_DWORD *)(a1 + 348);
      int v233 = (v231 & 0x1800000) != 0 && (v231 & 0x2300000) == 3145728;
      v230 -= v233;
    }

    unsigned int v234 = *v901;
    if (!*v901)
    {
      if (v230 < v227) {
        goto LABEL_604;
      }
      BOOL v236 = 0;
LABEL_603:
      unsigned int v230 = v227 + v236;
      goto LABEL_604;
    }

    int v235 = *(_DWORD *)(a1 + 944);
    BOOL v59 = v235 == 0;
    BOOL v236 = v235 != 0;
    if (v59) {
      int v237 = *(_DWORD *)(a1 + 564);
    }
    else {
      int v237 = v227 + 1;
    }
LABEL_604:
    int v917 = *(_DWORD *)(a1 + 564);
    v250 = (char *)__src + v228;
    int v251 = (2 - (_BYTE)v203) & 3;
    if (((2 - (_BYTE)v203) & 3) != 0)
    {
      v902 = v218;
      uint64_t v252 = v203 | (v208 << 8);
      int v253 = v206;
      unsigned int v254 = v230;
      memset(v250, 1, (2 - (_BYTE)v203) & 3);
      BOOL v218 = v902;
      unsigned int v230 = v254;
      int v206 = v253;
      LODWORD(v228) = v252;
      v250 = (char *)__src + v252 + (v251 - 1) + 1;
    }

    uint64_t v255 = *(void *)(a1 + 1056);
    if (v255) {
      ++*(void *)(v255 + 600);
    }
    int v256 = (8 * v230) | 2;
    _BYTE *v250 = 5;
    uint64_t v257 = (int8x8_t *)(v250 + 2);
    v250[1] = (8 * v230) | 2;
    if (v234)
    {
      unsigned int v258 = *(_DWORD *)(a1 + 944);
      if (v258)
      {
        if ((int)v230 >= 1)
        {
          if (v917 && v230 < 2)
          {
            unsigned int v230 = 1;
            goto LABEL_646;
          }

          *(_DWORD *)(v250 + 2) = bswap32(v234);
          *(_DWORD *)(v250 + 6) = bswap32(v258);
          if (v255) {
            ++*(void *)(v255 + 1008);
          }
          uint64_t v257 = (int8x8_t *)(v250 + 10);
          ++*(_DWORD *)(a1 + 1020);
          --v230;
        }
      }
    }

    if (!v230) {
      goto LABEL_656;
    }
LABEL_646:
    if (v917 < (int)v230)
    {
      __int16 v904 = v218;
      BOOL v732 = v230;
      unsigned int v884 = v256;
      uint64_t v896 = v251;
      v733 = v228;
      v919 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v919, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_output";
      int v734 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v734);
        LODWORD(v228) = v733;
        int v251 = v896;
        int v256 = v884;
        unsigned int v230 = v732;
        BOOL v218 = v904;
        if (v732 < 1) {
          goto LABEL_656;
        }
LABEL_648:
        uint64_t v270 = v230;
        if (v230 < 8)
        {
          uint64_t v271 = 0LL;
          goto LABEL_650;
        }

        uint64_t v272 = (const float *)(a1 + 568);
        if ((unint64_t)v257 >= v886 + 8LL * v230 || v886 >= (unint64_t)&v257[v230])
        {
          uint64_t v271 = v230 & 0xFFFFFFF8;
          int v419 = (float *)&v257[4];
          uint64_t v420 = v271;
          do
          {
            int v421 = v272;
            v961 = vld2q_f32(v421);
            v421 += 8;
            int v422 = v419 - 8;
            v962 = vld2q_f32(v421);
            v963.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v961.val[0]);
            v963.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v961.val[1]);
            vst2q_f32(v422, v963);
            v961.val[0] = (float32x4_t)vrev32q_s8((int8x16_t)v962.val[0]);
            v961.val[1] = (float32x4_t)vrev32q_s8((int8x16_t)v962.val[1]);
            vst2q_f32(v419, v961);
            v272 += 16;
            v419 += 16;
            v420 -= 8LL;
          }

          while (v420);
          if (v271 == v270) {
            goto LABEL_656;
          }
          v257 += v270 & 0xFFFFFFF8;
LABEL_650:
          uint64_t v272 = (const float *)(a1 + 568);
        }

        else
        {
          uint64_t v271 = 0LL;
        }

        uint64_t v273 = v270 - v271;
        uint64_t v274 = (int8x8_t *)&v272[2 * v271];
        do
        {
          int8x8_t v275 = *v274++;
          *v257++ = vrev32_s8(v275);
          --v273;
        }

        while (v273);
        goto LABEL_656;
      }

LABEL_1896:
      __break(1u);
LABEL_1897:
      *(void *)(a1 + 1056) = 0LL;
      unsigned int v515 = 6LL;
LABEL_1898:
      if ((*(_BYTE *)(v923 + 828) & 2) == 0)
      {
        v866 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v866, OS_LOG_TYPE_INFO))
        {
          v867 = strerror(v515);
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 2080;
          *(void *)v955 = v867;
          _os_log_impl( &dword_1879E5000,  v866,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s failed to finalize tcp checksum, %s",  buf,  0x20u);
        }
      }

      v868 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
      int v25 = (void *)(a1 + 632);
      if (v868)
      {
        v869 = *(void *)(v18 + 88);
        *(void *)(v18 + 80) = 0LL;
        *(void *)(v18 + 88) = 0LL;
        v868(v18, 0LL, v869);
        uint64_t v743 = v946;
        if ((_DWORD)v515 == 6)
        {
LABEL_1903:
          uint64_t v662 = 0;
          goto LABEL_1571;
        }

LABEL_1920:
        uint64_t v662 = *(_DWORD *)(a1 + 648);
        unsigned int v515 = 55LL;
        goto LABEL_1571;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      v870 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v871 = (os_log_s *)__nwlog_obj();
          v872 = info.numer;
          if (!os_log_type_enabled(v871, info.numer)) {
            goto LABEL_1917;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer";
LABEL_1915:
          v878 = v871;
          v879 = v872;
LABEL_1916:
          _os_log_impl(&dword_1879E5000, v878, v879, v873, buf, 0xCu);
          goto LABEL_1917;
        }

        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v871 = (os_log_s *)__nwlog_obj();
          v872 = info.numer;
          if (!os_log_type_enabled(v871, info.numer)) {
            goto LABEL_1917;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_1915;
        }

        v874 = (void *)__nw_create_backtrace_string();
        v875 = (os_log_s *)__nwlog_obj();
        v876 = info.numer;
        v877 = os_log_type_enabled(v875, info.numer);
        if (v874)
        {
          if (v877)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v874;
            _os_log_impl( &dword_1879E5000,  v875,  v876,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v874);
        }

        else if (v877)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v873 = "%{public}s called with null frame->finalizer, no backtrace";
          v878 = v875;
          v879 = v876;
          goto LABEL_1916;
        }
      }

LABEL_656:
    unsigned int v203 = v251 + v228 + v256;
    unsigned int v208 = v203 >> 8;
    int v207 = *(_DWORD *)(a1 + 740);
    uint64_t v3 = v923;
    unsigned int v149 = v946;
    if ((v207 & 0x10000000) == 0) {
      goto LABEL_567;
    }
LABEL_657:
    uint64_t v276 = v203 | (v208 << 8);
    if (v276 <= 0x27)
    {
      int v277 = v203 & 3;
      if ((v203 & 3) != 0)
      {
        unsigned int v278 = v149;
        char v279 = 4 - v277;
        char v280 = v203;
        bzero((char *)__src + v276, (4 - v277));
        unsigned int v208 = 0;
        LOBYTE(v203) = v280 + v279;
        unsigned int v149 = v278;
      }
    }

    int v281 = *(_DWORD *)(a1 + 740);
    if ((v281 & 0x10000000) == 0)
    {
      if ((v281 & 0x8000000) != 0
        || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v282 = tcp_do_acc_ecn == 1) : (BOOL v282 = 1), v282))
      {
        int v283 = *(_DWORD *)(a1 + 348);
      }
    }

    v903 = v203;
    if ((v149 & 0x12) == 2)
    {
      int v286 = *(_DWORD *)(a1 + 348);
      if ((v286 & 0x1000) == 0) {
        goto LABEL_678;
      }
      BOOL v290 = (v286 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
      if ((v286 & 0x100001) == 0 || v290)
      {
        if ((v281 & 0x10000000) != 0
          || (int v292 = 0x100000, v293 = 448, (v281 & 0x8000000) == 0)
          && *(_DWORD *)(sysctls + 320) != 1
          && tcp_do_acc_ecn != 1)
        {
          int v292 = 5;
          int v293 = 192;
        }

        uint64_t v294 = *(void *)(a1 + 1056);
        if (v294) {
          ++*(void *)(v294 + 768);
        }
        v149 |= v293;
        unsigned int v289 = v286 | v292 | 0x4000;
      }

      else
      {
        uint64_t v291 = *(void *)(a1 + 1056);
        if (v291) {
          ++*(void *)(v291 + 792);
        }
        unsigned int v289 = v286 & 0xFFFFFEFB | 0x100;
      }

LABEL_723:
      *(_DWORD *)(a1 + 348) = v289;
    }

    else
    {
      if ((v149 & 0x12) == 0x12)
      {
        int v284 = *(_DWORD *)(a1 + 348);
        if ((v284 & 0x1000) != 0)
        {
          if ((v284 & 0x200002) == 0)
          {
            unsigned int v289 = *(_DWORD *)(a1 + 348);
            goto LABEL_724;
          }

          BOOL v285 = (v284 & 0x100000) != 0 && *(unsigned __int16 *)(a1 + 226) < 2u;
          if ((v284 & 0x100001) != 0 && !v285)
          {
            uint64_t v295 = *(void *)(a1 + 1056);
            if (v295)
            {
              ++*(void *)(v295 + 848);
              --*(void *)(v295 + 808);
            }

            unsigned int v289 = v284 | 0x200;
            *(_DWORD *)(a1 + 348) = v284 | 0x200;
            if ((v281 & 0x10000000) != 0
              || (v281 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1)
            {
              unsigned int v289 = v284 & 0xFFFFFDF1 | 0x200;
              goto LABEL_723;
            }

            goto LABEL_724;
          }

          if ((v281 & 0x10000000) != 0
            || (*(_DWORD *)(sysctls + 320) != 1 ? (BOOL v297 = tcp_do_acc_ecn == 1) : (BOOL v297 = 1),
                !v297 ? (BOOL v298 = (v281 & 0x8000000) == 0) : (BOOL v298 = 0),
                (v284 & 0x200000) == 0 || v298))
          {
            if ((v284 & 2) == 0)
            {
              unsigned int v289 = *(_DWORD *)(a1 + 348);
              goto LABEL_1486;
            }

            v149 |= 0x40u;
            int v299 = 5;
          }

          else
          {
            *(void *)(a1 + 416) = 0x500000005LL;
            *(void *)(a1 + 472) = 0LL;
            *(void *)(a1 + 448) = 0LL;
            if ((v284 & 0x10000) != 0)
            {
              *(_WORD *)(a1 + 404) = 128;
              v149 |= 0x80u;
              v284 &= ~0x10000u;
              *(_DWORD *)(a1 + 348) = v284;
              uint64_t v406 = *(void *)(a1 + 1056);
              if (v406) {
                ++*(void *)(v406 + 816);
              }
            }

            else if ((v284 & 0x20000) != 0)
            {
              *(_WORD *)(a1 + 404) = 192;
              v149 |= 0xC0u;
              v284 &= ~0x20000u;
              unsigned int v597 = *(void *)(a1 + 1056);
              if (v597) {
                ++*(void *)(v597 + 824);
              }
            }

            else if ((v284 & 0x40000) != 0)
            {
              *(_WORD *)(a1 + 404) = 256;
              v149 |= 0x100u;
              v284 &= ~0x40000u;
              int v605 = *(void *)(a1 + 1056);
              if (v605) {
                ++*(void *)(v605 + 832);
              }
            }

            else
            {
              if ((v284 & 0x80000) == 0)
              {
                if (*(_WORD *)(a1 + 404))
                {
                  v149 |= *(unsigned __int16 *)(a1 + 404);
                  goto LABEL_1482;
                }

                v947 = v149;
                if ((*(_BYTE *)(v3 + 828) & 2) == 0)
                {
                  __nwlog_tcp_log();
                  BOOL v646 = *(_DWORD *)(a1 + 348);
                  *(_DWORD *)__int128 buf = 136446722;
                  *(void *)&uint8_t buf[4] = "tcp_output";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v887;
                  *(_WORD *)&_BYTE buf[22] = 1024;
                  *(_DWORD *)v955 = v646;
                  BOOL v647 = (void *)_os_log_send_and_compose_impl();
                  LOBYTE(info.numer) = 16;
                  v953 = OS_LOG_TYPE_DEFAULT;
                  if (LOBYTE(info.numer) != 17)
                  {
                    if (v953)
                    {
                      int v666 = (void *)__nw_create_backtrace_string();
                      v667 = (os_log_s *)__nwlog_tcp_log();
                      BOOL v668 = info.numer;
                      int v669 = os_log_type_enabled(v667, info.numer);
                      if (v666)
                      {
                        if (v669)
                        {
                          int v670 = *(_DWORD *)(a1 + 348);
                          *(_DWORD *)__int128 buf = 136446978;
                          *(void *)&uint8_t buf[4] = "tcp_output";
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v887;
                          *(_WORD *)&_BYTE buf[22] = 1024;
                          *(_DWORD *)v955 = v670;
                          *(_WORD *)&v955[4] = 2082;
                          *(void *)&v955[6] = v666;
                          _os_log_impl( &dword_1879E5000,  v667,  v668,  "%{public}s %{public}s ECN flags (0x%x) not set correctly, dumping backtrace:%{public}s",  buf,  0x26u);
                        }

                        free(v666);
                        uint64_t v3 = v923;
                        goto LABEL_1478;
                      }

                      uint64_t v3 = v923;
                      if (!v669) {
                        goto LABEL_1478;
                      }
                      v692 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)__int128 buf = 136446722;
                      *(void *)&uint8_t buf[4] = "tcp_output";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v887;
                      *(_WORD *)&_BYTE buf[22] = 1024;
                      *(_DWORD *)v955 = v692;
                      v651 = v667;
                      BOOL v652 = v668;
                      int v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, no backtrace";
                    }

                    else
                    {
                      unsigned int v683 = (os_log_s *)__nwlog_tcp_log();
                      int v684 = info.numer;
                      if (!os_log_type_enabled(v683, info.numer)) {
                        goto LABEL_1478;
                      }
                      v685 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)__int128 buf = 136446722;
                      *(void *)&uint8_t buf[4] = "tcp_output";
                      *(_WORD *)&_BYTE buf[12] = 2082;
                      *(void *)&buf[14] = v887;
                      *(_WORD *)&_BYTE buf[22] = 1024;
                      *(_DWORD *)v955 = v685;
                      v651 = v683;
                      BOOL v652 = v684;
                      int v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly, backtrace limit exceeded";
                    }

LABEL_1477:
                    _os_log_impl(&dword_1879E5000, v651, v652, v653, buf, 0x1Cu);
                    goto LABEL_1478;
                  }

                  int v648 = (os_log_s *)__nwlog_tcp_log();
                  uint64_t v649 = info.numer;
                  if (os_log_type_enabled(v648, info.numer))
                  {
                    v650 = *(_DWORD *)(a1 + 348);
                    *(_DWORD *)__int128 buf = 136446722;
                    *(void *)&uint8_t buf[4] = "tcp_output";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = v887;
                    *(_WORD *)&_BYTE buf[22] = 1024;
                    *(_DWORD *)v955 = v650;
                    v651 = v648;
                    BOOL v652 = v649;
                    int v653 = "%{public}s %{public}s ECN flags (0x%x) not set correctly";
                    goto LABEL_1477;
                  }

LABEL_1478:
                  if (v647) {
                    free(v647);
                  }
                  int v284 = *(_DWORD *)(a1 + 348);
                  int v281 = *(_DWORD *)(a1 + 740);
                }

                unsigned int v149 = v947;
                LOBYTE(v203) = v903;
                goto LABEL_1482;
              }

              *(_WORD *)(a1 + 404) = 384;
              v149 |= 0x180u;
              v284 &= ~0x80000u;
              v606 = *(void *)(a1 + 1056);
              if (v606) {
                ++*(void *)(v606 + 840);
              }
            }

LABEL_1482:
            unsigned int v289 = v284 | 0x100000;
            *(_DWORD *)(a1 + 348) = v284 | 0x100000;
            if ((v281 & 0x10000000) != 0
              || (v281 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 336) != 1 && tcp_do_l4s != 1)
            {
LABEL_1486:
              v693 = *(int64x2_t **)(a1 + 1056);
              if (v693) {
                v693[50] = vaddq_s64(v693[50], vdupq_n_s64(1uLL));
              }
              goto LABEL_724;
            }

            int v299 = 1048580;
          }

          unsigned int v289 = v284 | v299;
          *(_DWORD *)(a1 + 348) = v289;
          goto LABEL_1486;
        }
      }

LABEL_678:
      if ((v281 & 0x10000000) != 0)
      {
        unsigned int v289 = *(_DWORD *)(a1 + 348);
        goto LABEL_724;
      }

      BOOL v288 = tcp_do_acc_ecn != 1 && *(_DWORD *)(sysctls + 320) != 1 && (v281 & 0x8000000) == 0;
      unsigned int v289 = *(_DWORD *)(a1 + 348);
      if (!v288
        && (v289 & 0x300000) == 0x300000
        && v149 == 16
        && !(_DWORD)v124
        && (v289 & 0x400000) != 0)
      {
        v149 &= 0xFFFFFE3F;
        if ((v289 & 0x10000) != 0)
        {
          v149 |= 0x80u;
          v289 &= ~0x10000u;
        }

        else if ((v289 & 0x20000) != 0)
        {
          v149 |= 0xC0u;
          v289 &= ~0x20000u;
        }

        else if ((v289 & 0x40000) != 0)
        {
          v149 |= 0x100u;
          v289 &= ~0x40000u;
        }

        else if ((v289 & 0x80000) != 0)
        {
          v149 |= 0x180u;
          v289 &= ~0x80000u;
        }

        v289 &= ~0x400000u;
        *(_DWORD *)(a1 + 348) = v289;
LABEL_753:
        if (!(_DWORD)v124 && (v289 & 0x10) != 0)
        {
          v149 |= 0x40u;
          uint64_t v300 = *(void *)(a1 + 1056);
          if (v300) {
            ++*(void *)(v300 + 872);
          }
        }

        goto LABEL_757;
      }
    }

LABEL_724:
    if (!(_DWORD)v124 || (v289 & 8) == 0) {
      goto LABEL_753;
    }
    char v296 = v935;
    if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
      char v296 = 1;
    }
    if ((v296 & 1) == 0)
    {
      v149 |= 0x80u;
      *(_DWORD *)(a1 + 348) = v289 & 0xFFFFFFF7;
    }

LABEL_757:
    uint64_t v301 = (os_log_s *)(v203 | (v208 << 8));
    *(void *)__int16 v901 = 0LL;
    unsigned int v302 = *(_DWORD *)(a1 + 156);
    if ((int)v301 + (int)v124 <= v302)
    {
      int v306 = v124;
      if ((v281 & 8) != 0) {
        goto LABEL_774;
      }
    }

    else
    {
      v149 &= ~1u;
      if (v914)
      {
        int v303 = *(_DWORD *)(a1 + 692);
        if (!v303) {
          int v303 = 0xFFFF;
        }
        int v304 = v890 - (_DWORD)v301 + v303 - 20;
        if ((int)v124 <= v304)
        {
          int v305 = v913;
          if ((*(_BYTE *)(a1 + 89) & 8) != 0) {
            int v305 = 1;
          }
          int v304 = v124;
        }

        else
        {
          int v305 = 1;
        }

        int v306 = v304 / (v302 - v301) * (v302 - (_DWORD)v301);
        if (v304 == v306) {
          int v307 = v305;
        }
        else {
          int v307 = 1;
        }
        int v913 = v307;
        if ((v281 & 8) != 0)
        {
LABEL_774:
          if ((v281 & 4) == 0)
          {
            uint64_t v308 = *(void *)(a1 + 768);
            if (v308)
            {
              unsigned int v309 = *(_DWORD *)(v3 + 384) - *(_DWORD *)(a1 + 96) + *(_DWORD *)(a1 + 92);
              if (v309 >= *(_DWORD *)(a1 + 144)) {
                unsigned int v309 = *(_DWORD *)(a1 + 144);
              }
              if (v309 >= *(_DWORD *)(a1 + 140)) {
                unsigned int v309 = *(_DWORD *)(a1 + 140);
              }
              unsigned int v310 = *(_DWORD *)(v308 + 20);
              if (v309 < v310 && v310 != 0) {
                unsigned int v309 = 0;
              }
              *(_DWORD *)(v308 + 8) = v309;
              int v312 = *(_DWORD **)(a1 + 768);
              unsigned int v313 = v312[6];
              unsigned int v314 = v312[2];
              if (v313)
              {
                if (v314 >= v313) {
                  unsigned int v314 = v312[6];
                }
                v312[2] = v314;
              }

              if (v314)
              {
                *(_DWORD *)(a1 + 740) |= 4u;
                *int v312 = *(_DWORD *)(a1 + 96);
                v312[1] = *v910;
              }
            }
          }
        }
      }

      else
      {
        int v306 = v302 - (_DWORD)v301;
        int v913 = 1;
        if ((v281 & 8) != 0) {
          goto LABEL_774;
        }
      }
    }

    v946 = v149;
    if (!*((_DWORD *)v940 + 115))
    {
      uint64_t v619 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v619, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_output";
      v620 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort())
      {
        free(v620);
        unsigned int v149 = v946;
        goto LABEL_792;
      }

      goto LABEL_1896;
    }

LABEL_792:
    BOOL v316 = (v149 & 0xFFFFFFEF) != 0 || (int)v124 >= 1 || *(_BYTE *)(a1 + 261) == 0;
    int v317 = !v316;
    if (!v316)
    {
      int v318 = *v910;
      if (*(_DWORD *)(sysctls + 268) + *(_DWORD *)(a1 + 1880) - *v910 < 0)
      {
        int v319 = *(_DWORD *)(a1 + 1876);
        else {
          int v320 = 1;
        }
        *(_DWORD *)(a1 + 1876) = v320;
        *(_DWORD *)(a1 + 1880) = v318;
      }
    }

    unsigned int v321 = (_DWORD)v301 + 20;
    LOBYTE(v896) = v306 != 0;
    __int16 v918 = v301;
    if (!v306)
    {
      if ((*(_BYTE *)(a1 + 88) & 1) != 0)
      {
        uint64_t v329 = *(void *)(a1 + 1056);
        if (v329) {
          ++*(void *)(v329 + 48);
        }
      }

      else
      {
        uint64_t v324 = *(void *)(a1 + 1056);
        if ((v149 & 7) != 0)
        {
          if (v324) {
            ++*(void *)(v324 + 88);
          }
        }

        else if (v324)
        {
          ++*(void *)(v324 + 80);
        }
      }

      if (!v317 || (*(_BYTE *)(a1 + 743) & 2) == 0 || !*(_DWORD *)(a1 + 672)) {
        goto LABEL_900;
      }
      uint64_t v18 = **(void **)(*(void *)(a1 + 664) + 8LL);
      if (v18)
      {
        unsigned int v361 = *(_DWORD *)(v18 + 52);
        goto LABEL_899;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
      v698 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (LOBYTE(info.numer) == 17)
      {
        BOOL v699 = (os_log_s *)__nwlog_obj();
        v700 = info.numer;
        if (os_log_type_enabled(v699, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
          v701 = v699;
          os_log_type_t v702 = v700;
          v703 = "%{public}s called with null frame";
          goto LABEL_1564;
        }

        goto LABEL_1565;
      }

      if (v953 == OS_LOG_TYPE_DEFAULT)
      {
        v741 = (os_log_s *)__nwlog_obj();
        uint64_t v742 = info.numer;
        if (!os_log_type_enabled(v741, info.numer)) {
          goto LABEL_1565;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        v701 = v741;
        os_log_type_t v702 = v742;
        v703 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1564:
        _os_log_impl(&dword_1879E5000, v701, v702, v703, buf, 0xCu);
        goto LABEL_1565;
      }

      int v735 = (void *)__nw_create_backtrace_string();
      int v736 = (os_log_s *)__nwlog_obj();
      unsigned int v737 = info.numer;
      v930 = v736;
      v738 = os_log_type_enabled(v736, info.numer);
      if (v735)
      {
        if (v738)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v735;
          _os_log_impl( &dword_1879E5000,  v930,  v737,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v735);
        goto LABEL_1565;
      }

      if (v738)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        v701 = v930;
        os_log_type_t v702 = v737;
        v703 = "%{public}s called with null frame, no backtrace";
        goto LABEL_1564;
      }

LABEL_1565:
      if (v698) {
        free(v698);
      }
      unsigned int v361 = 0;
      uint64_t v3 = v923;
LABEL_899:
      if (v361 < *(_DWORD *)(v18 + 56) + v321)
      {
LABEL_900:
        uint64_t v362 = *(void *)(v3 + 24);
        uint64_t v363 = *(void *)(v362 + 32);
        *(void *)__int128 buf = 0LL;
        *(void *)&buf[8] = buf;
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(v363 + 24) + 88LL))(v363, v362))
        {
          LOBYTE(v896) = 0;
          unsigned int v515 = 55LL;
          goto LABEL_1691;
        }

        uint64_t v18 = *(void *)buf;
        if (*(void *)buf) {
          goto LABEL_902;
        }
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        v654 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              v676 = (void *)__nw_create_backtrace_string();
              uint64_t v677 = (os_log_s *)__nwlog_obj();
              unsigned int v678 = info.numer;
              int v679 = os_log_type_enabled(v677, info.numer);
              if (v676)
              {
                if (v679)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v676;
                  _os_log_impl( &dword_1879E5000,  v677,  v678,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v676);
                goto LABEL_1508;
              }

              if (!v679) {
                goto LABEL_1508;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              v657 = v677;
              v658 = v678;
              v659 = "%{public}s called with null frame, no backtrace";
            }

            else
            {
              uint64_t v694 = (os_log_s *)__nwlog_obj();
              uint64_t v695 = info.numer;
              if (!os_log_type_enabled(v694, info.numer)) {
                goto LABEL_1508;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              v657 = v694;
              v658 = v695;
              v659 = "%{public}s called with null frame, backtrace limit exceeded";
            }

LABEL_1507:
            _os_log_impl(&dword_1879E5000, v657, v658, v659, buf, 0xCu);
            goto LABEL_1508;
          }

          v655 = (os_log_s *)__nwlog_obj();
          os_log_type_t v656 = info.numer;
          if (os_log_type_enabled(v655, info.numer))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
            v657 = v655;
            v658 = v656;
            v659 = "%{public}s called with null frame";
            goto LABEL_1507;
          }
        }

LABEL_1508:
        if (v654) {
          free(v654);
        }
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
        BOOL v708 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if ((__nwlog_fault() & 1) != 0)
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              BOOL v714 = (void *)__nw_create_backtrace_string();
              v715 = (os_log_s *)__nwlog_obj();
              os_log_type_t v716 = info.numer;
              v717 = os_log_type_enabled(v715, info.numer);
              if (v714)
              {
                if (v717)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v714;
                  _os_log_impl( &dword_1879E5000,  v715,  v716,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v714);
                goto LABEL_1524;
              }

              if (!v717) {
                goto LABEL_1524;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              v711 = v715;
              v712 = v716;
              v713 = "%{public}s called with null frame, no backtrace";
            }

            else
            {
              v718 = (os_log_s *)__nwlog_obj();
              v719 = info.numer;
              if (!os_log_type_enabled(v718, info.numer)) {
                goto LABEL_1524;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              v711 = v718;
              v712 = v719;
              v713 = "%{public}s called with null frame, backtrace limit exceeded";
            }

LABEL_1523:
            _os_log_impl(&dword_1879E5000, v711, v712, v713, buf, 0xCu);
            goto LABEL_1524;
          }

          v709 = (os_log_s *)__nwlog_obj();
          v710 = info.numer;
          if (os_log_type_enabled(v709, info.numer))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
            v711 = v709;
            v712 = v710;
            v713 = "%{public}s called with null frame";
            goto LABEL_1523;
          }
        }

LABEL_1524:
        if (v708) {
          free(v708);
        }
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
        v720 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) != 17)
          {
            if (v953)
            {
              v726 = (void *)__nw_create_backtrace_string();
              v727 = (os_log_s *)__nwlog_obj();
              v728 = info.numer;
              os_log_type_t v729 = os_log_type_enabled(v727, info.numer);
              if (v726)
              {
                if (v729)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v726;
                  _os_log_impl( &dword_1879E5000,  v727,  v728,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v726);
                goto LABEL_1540;
              }

              if (!v729) {
                goto LABEL_1540;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              v723 = v727;
              v724 = v728;
              v725 = "%{public}s called with null frame, no backtrace";
            }

            else
            {
              unsigned int v730 = (os_log_s *)__nwlog_obj();
              unsigned int v731 = info.numer;
              if (!os_log_type_enabled(v730, info.numer)) {
                goto LABEL_1540;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              v723 = v730;
              v724 = v731;
              v725 = "%{public}s called with null frame, backtrace limit exceeded";
            }

LABEL_1539:
            _os_log_impl(&dword_1879E5000, v723, v724, v725, buf, 0xCu);
            goto LABEL_1540;
          }

          v721 = (os_log_s *)__nwlog_obj();
          v722 = info.numer;
          if (os_log_type_enabled(v721, info.numer))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
            v723 = v721;
            v724 = v722;
            v725 = "%{public}s called with null frame";
            goto LABEL_1539;
          }
        }

LABEL_1540:
        if (v720) {
          free(v720);
        }
        uint64_t v18 = 0LL;
        int v433 = 1;
        size_t v345 = (size_t)v918;
        if (!*(void *)(v3 + 24))
        {
LABEL_1014:
          if (v18)
          {
            int v415 = v946;
            goto LABEL_1016;
          }

          LOBYTE(v896) = 0;
LABEL_1620:
          int v25 = (void *)(a1 + 632);
LABEL_1621:
          if ((*(_BYTE *)(v3 + 828) & 2) == 0)
          {
            v765 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v765, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "tcp_output";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v887;
              _os_log_impl( &dword_1879E5000,  v765,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s output buffer is no longer valid",  buf,  0x16u);
            }
          }

          if (v18)
          {
            v766 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
            if (v766)
            {
              v767 = *(void *)(v18 + 88);
              *(void *)(v18 + 80) = 0LL;
              *(void *)(v18 + 88) = 0LL;
              v766(v18, 0LL, v767);
              unsigned int v515 = 6LL;
LABEL_1627:
              v749 = (void *)*v25;
              if (*v25) {
                goto LABEL_1628;
              }
              goto LABEL_1692;
            }

            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v832 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault())
            {
              if (LOBYTE(info.numer) == 17)
              {
                int v833 = (os_log_s *)__nwlog_obj();
                int v834 = info.numer;
                if (!os_log_type_enabled(v833, info.numer)) {
                  goto LABEL_1856;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                uint64_t v835 = "%{public}s called with null frame->finalizer";
                goto LABEL_1854;
              }

              if (v953 == OS_LOG_TYPE_DEFAULT)
              {
                int v833 = (os_log_s *)__nwlog_obj();
                int v834 = info.numer;
                if (!os_log_type_enabled(v833, info.numer)) {
                  goto LABEL_1856;
                }
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                uint64_t v835 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                goto LABEL_1854;
              }

              v840 = (void *)__nw_create_backtrace_string();
              uint64_t v837 = (os_log_s *)__nwlog_obj();
              unsigned int v838 = info.numer;
              int v841 = os_log_type_enabled(v837, info.numer);
              if (v840)
              {
                if (v841)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v840;
                  _os_log_impl( &dword_1879E5000,  v837,  v838,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v840);
                if (!v832) {
                  goto LABEL_1858;
                }
                goto LABEL_1857;
              }

              if (v841)
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                uint64_t v835 = "%{public}s called with null frame->finalizer, no backtrace";
                goto LABEL_1863;
              }
            }
          }

          else
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v832 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (LOBYTE(info.numer) == 17)
            {
              int v833 = (os_log_s *)__nwlog_obj();
              int v834 = info.numer;
              if (!os_log_type_enabled(v833, info.numer)) {
                goto LABEL_1856;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              uint64_t v835 = "%{public}s called with null frame";
LABEL_1854:
              v852 = v833;
              v853 = v834;
LABEL_1855:
              _os_log_impl(&dword_1879E5000, v852, v853, v835, buf, 0xCu);
              goto LABEL_1856;
            }

            if (v953 == OS_LOG_TYPE_DEFAULT)
            {
              int v833 = (os_log_s *)__nwlog_obj();
              int v834 = info.numer;
              if (!os_log_type_enabled(v833, info.numer)) {
                goto LABEL_1856;
              }
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              uint64_t v835 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_1854;
            }

            uint64_t v836 = (void *)__nw_create_backtrace_string();
            uint64_t v837 = (os_log_s *)__nwlog_obj();
            unsigned int v838 = info.numer;
            int v839 = os_log_type_enabled(v837, info.numer);
            if (v836)
            {
              if (v839)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v836;
                _os_log_impl( &dword_1879E5000,  v837,  v838,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v836);
            }

            else if (v839)
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              uint64_t v835 = "%{public}s called with null frame, no backtrace";
LABEL_1863:
              v852 = v837;
              v853 = v838;
              goto LABEL_1855;
            }
          }

LABEL_1856:
          if (!v832)
          {
LABEL_1858:
            unsigned int v515 = 6LL;
LABEL_1691:
            v749 = (void *)*v949;
            if (*v949) {
              goto LABEL_1628;
            }
            goto LABEL_1692;
          }

LABEL_1857:
          free(v832);
          goto LABEL_1858;
        }

LABEL_1007:
        uint64_t v434 = nw_protocol_tcp_get_all_stats();
        if (v434) {
          ++*(void *)(v434 + 32);
        }
        if (!*(void *)(v3 + 24)) {
          goto LABEL_1014;
        }
        uint64_t v435 = nw_protocol_tcp_get_all_stats();
        if (!v435) {
          goto LABEL_1014;
        }
        uint64_t v436 = v435;
        if (!v433)
        {
          uint64_t v437 = *(unsigned int *)(v18 + 52);
LABEL_1013:
          *(void *)(v436 + 40) += v437;
          goto LABEL_1014;
        }

        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
        int v686 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) == 17)
          {
            v687 = (os_log_s *)__nwlog_obj();
            int v688 = info.numer;
            if (os_log_type_enabled(v687, info.numer))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              unsigned int v689 = v687;
              v690 = v688;
              int v691 = "%{public}s called with null frame";
LABEL_1558:
              _os_log_impl(&dword_1879E5000, v689, v690, v691, buf, 0xCu);
            }
          }

          else if (v953)
          {
            uint64_t v704 = (void *)__nw_create_backtrace_string();
            int v705 = (os_log_s *)__nwlog_obj();
            v706 = info.numer;
            v929 = v705;
            v707 = os_log_type_enabled(v705, info.numer);
            if (v704)
            {
              if (v707)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v704;
                _os_log_impl( &dword_1879E5000,  v929,  v706,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v704);
              goto LABEL_1559;
            }

            if (v707)
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              unsigned int v689 = v929;
              v690 = v706;
              int v691 = "%{public}s called with null frame, no backtrace";
              goto LABEL_1558;
            }
          }

          else
          {
            v739 = (os_log_s *)__nwlog_obj();
            v740 = info.numer;
            if (os_log_type_enabled(v739, info.numer))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_effective_length";
              unsigned int v689 = v739;
              v690 = v740;
              int v691 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_1558;
            }
          }
        }

LABEL_1559:
        if (v686) {
          free(v686);
        }
        uint64_t v437 = 0LL;
        size_t v345 = (size_t)v918;
        uint64_t v3 = v923;
        goto LABEL_1013;
      }

      if ((*(_WORD *)(v18 + 204) & 0x40) == 0)
      {
        if (*(_DWORD *)(a1 + 1876) != *(_DWORD *)(v18 + 192)) {
          goto LABEL_900;
        }
LABEL_1390:
        unsigned int v601 = *(void *)(v18 + 32);
        unsigned int v602 = *(void **)(v18 + 40);
        if (v601)
        {
          *(void *)(v601 + 40) = v602;
          unsigned int v602 = *(void **)(v18 + 40);
        }

        else
        {
          *(void *)(a1 + 664) = v602;
        }

        *unsigned int v602 = v601;
        *(void *)(v18 + 32) = 0LL;
        *(void *)(v18 + 40) = 0LL;
        --*(_DWORD *)(a1 + 672);
        if (*(void *)(v3 + 24))
        {
          int v603 = nw_protocol_tcp_get_all_stats();
          if (v603) {
            --*(void *)(v603 + 32);
          }
          if (*(void *)(v3 + 24))
          {
            v604 = nw_protocol_tcp_get_all_stats();
            if (v604) {
              *(void *)(v604 + 40) -= *(unsigned int *)(v18 + 52);
            }
          }
        }

        ++*(_DWORD *)(a1 + 1884);
LABEL_902:
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
          *(_WORD *)(v18 + 196) -= v321;
        }
        int v364 = *(_DWORD *)(v18 + 52);
        unsigned int v365 = *(_DWORD *)(v18 + 56) + v321;
        int v366 = *(_DWORD *)(v18 + 60);
        if (v365 <= v364 - v366)
        {
          *(_DWORD *)(v18 + 56) = v365;
          *(_DWORD *)(v18 + 60) = v366;
        }

        else
        {
          int v367 = (os_log_s *)__nwlog_obj();
          BOOL v368 = os_log_type_enabled(v367, OS_LOG_TYPE_ERROR);
          int v364 = *(_DWORD *)(v18 + 52);
          if (v368)
          {
            *(_DWORD *)__int128 buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v365;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v364;
            *(_WORD *)v955 = 1024;
            *(_DWORD *)&v955[2] = v366;
            _os_log_impl( &dword_1879E5000,  v367,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
            int v364 = *(_DWORD *)(v18 + 52);
          }
        }

        size_t v345 = (size_t)v918;
        if (!v364) {
          goto LABEL_999;
        }
        uint64_t v370 = *(unsigned int *)(v18 + 56);
        size_t v369 = *(unsigned int *)(v18 + 60);
        uint64_t v371 = (v364 - (v369 + v370));
        if (v364 == (_DWORD)v369 + (_DWORD)v370) {
          goto LABEL_999;
        }
        if ((_DWORD)v369)
        {
          uint64_t v372 = *(void *)(v18 + 112);
          if (v372)
          {
            memmove((void *)(v372 + v370), (const void *)(v372 + v370 + v371), v369);
            int v364 = *(_DWORD *)(v18 + 52);
          }
        }

        *(_DWORD *)(v18 + 52) = v364 - v371;
        if ((*(_WORD *)(v18 + 204) & 0x80) == 0
          || (unsigned int v373 = *(unsigned __int16 *)(v18 + 196),
              BOOL v351 = v373 >= v371,
              unsigned int v374 = v373 - v371,
              *(_WORD *)(v18 + 196) = v374,
              v351)
          && v374 < 0x10000)
        {
LABEL_999:
          if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
            *(_WORD *)(v18 + 196) += v321;
          }
          unsigned int v429 = *(_DWORD *)(v18 + 56);
          BOOL v351 = v429 >= v321;
          unsigned int v430 = v429 - v321;
          uint64_t v3 = v923;
          if (v351)
          {
            int v433 = 0;
            *(_DWORD *)(v18 + 56) = v430;
            if (!*(void *)(v923 + 24)) {
              goto LABEL_1014;
            }
          }

          else
          {
            v431 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v431, OS_LOG_TYPE_ERROR))
            {
              int v432 = *(_DWORD *)(v18 + 56);
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
              *(_WORD *)&_BYTE buf[12] = 1024;
              *(_DWORD *)&buf[14] = v321;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v432;
              _os_log_impl( &dword_1879E5000,  v431,  OS_LOG_TYPE_ERROR,  "%{public}s Frame cannot unclaim %u start bytes (has %u left)",  buf,  0x18u);
            }

            int v433 = 0;
            if (!*(void *)(v923 + 24)) {
              goto LABEL_1014;
            }
          }

          goto LABEL_1007;
        }

        __nwlog_obj();
        uint64_t v375 = *(unsigned __int16 *)(v18 + 196);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = "frame->aggregate_buffer_length";
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)v955 = v371;
        *(_WORD *)&v955[8] = 2048;
        *(void *)&v955[10] = v375;
        uint64_t v376 = _os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        uint64_t v925 = (os_log_t)v376;
        if (__nwlog_fault())
        {
          if (LOBYTE(info.numer) == 17)
          {
            v377 = (os_log_s *)__nwlog_obj();
            os_log_type_t v378 = info.numer;
            if (os_log_type_enabled(v377, info.numer))
            {
              uint64_t v379 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v379;
              int v380 = v377;
              os_log_type_t v381 = v378;
              v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_995:
              _os_log_impl(&dword_1879E5000, v380, v381, v382, buf, 0x2Au);
            }
          }

          else if (v953)
          {
            int v394 = (void *)__nw_create_backtrace_string();
            unsigned int v395 = (os_log_s *)__nwlog_obj();
            os_log_type_t v396 = info.numer;
            v882 = v395;
            BOOL v397 = os_log_type_enabled(v395, info.numer);
            if (v394)
            {
              if (v397)
              {
                uint64_t v398 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)__int128 buf = 136447234;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&_BYTE buf[22] = 2048;
                *(void *)v955 = v371;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v398;
                *(_WORD *)&v955[18] = 2082;
                *(void *)&v955[20] = v394;
                _os_log_impl( &dword_1879E5000,  v882,  v396,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v394);
              goto LABEL_996;
            }

            if (v397)
            {
              uint64_t v428 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v428;
              int v380 = v882;
              os_log_type_t v381 = v396;
              v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_995;
            }
          }

          else
          {
            BOOL v407 = (os_log_s *)__nwlog_obj();
            os_log_type_t v408 = info.numer;
            if (os_log_type_enabled(v407, info.numer))
            {
              uint64_t v409 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)v955 = v371;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v409;
              int v380 = v407;
              os_log_type_t v381 = v408;
              v382 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_995;
            }
          }
        }

LABEL_996:
        if (v925) {
          free(v925);
        }
        *(_WORD *)(v18 + 196) = 0;
        size_t v345 = (size_t)v918;
        goto LABEL_999;
      }

      v926 = *(_DWORD *)(a1 + 1876);
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
      BOOL v388 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          int v389 = (os_log_s *)__nwlog_obj();
          os_log_type_t v390 = info.numer;
          if (!os_log_type_enabled(v389, info.numer)) {
            goto LABEL_1387;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          v391 = v389;
          os_log_type_t v392 = v390;
          uint64_t v393 = "%{public}s Attempt to get generation-count on a chain-member";
LABEL_1386:
          _os_log_impl(&dword_1879E5000, v391, v392, v393, buf, 0xCu);
          goto LABEL_1387;
        }

        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          int v598 = (os_log_s *)__nwlog_obj();
          int v599 = info.numer;
          if (!os_log_type_enabled(v598, info.numer)) {
            goto LABEL_1387;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          v391 = v598;
          os_log_type_t v392 = v599;
          uint64_t v393 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          goto LABEL_1386;
        }

        int v402 = (void *)__nw_create_backtrace_string();
        v403 = (os_log_s *)__nwlog_obj();
        os_log_type_t v404 = info.numer;
        int v883 = v403;
        BOOL v405 = os_log_type_enabled(v403, info.numer);
        if (!v402)
        {
          if (!v405) {
            goto LABEL_1387;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          v391 = v883;
          os_log_type_t v392 = v404;
          uint64_t v393 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
          goto LABEL_1386;
        }

        if (v405)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v402;
          _os_log_impl( &dword_1879E5000,  v883,  v404,  "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v402);
      }

LABEL_1387:
      if (v388) {
        free(v388);
      }
      uint64_t v3 = v923;
      if (v926) {
        goto LABEL_900;
      }
      goto LABEL_1390;
    }

    if (!*(_WORD *)(a1 + 696) && *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 92)) {
      *(_WORD *)(a1 + 696) = v306 + (_WORD)v301;
    }
    if (v306 != 1 || (*(_DWORD *)(a1 + 740) & 0x8000) == 0)
    {
      uint64_t v325 = *(void **)(a1 + 1056);
      if (((*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) >= 0) & ~v935) != 0)
      {
        if (v325)
        {
          uint64_t v330 = v325[2] + v306;
          ++v325[1];
          v325[2] = v330;
        }

        uint64_t v331 = *((void *)v940 + 31);
        ++*(void *)(v331 + 16);
        if (v906) {
          ++*(void *)(*((void *)v940 + 32) + 16LL);
        }
        if (HIDWORD(v905)) {
          ++*(void *)(*((void *)v940 + 33) + 16LL);
        }
        if ((_DWORD)v905) {
          ++*(void *)(*((void *)v940 + 34) + 16LL);
        }
        *(void *)(v331 + 24) += v306;
        if (v906) {
          *(void *)(*((void *)v940 + 32) + 24LL) += v306;
        }
        if (HIDWORD(v905)) {
          *(void *)(*((void *)v940 + 33) + 24LL) += v306;
        }
        if ((_DWORD)v905) {
          *(void *)(*((void *)v940 + 34) + 24LL) += v306;
        }
        int64x2_t v323 = (void *)(a1 + 368);
        if ((*(_BYTE *)(a1 + 348) & 4) == 0) {
          goto LABEL_857;
        }
      }

      else
      {
        if (v325)
        {
          uint64_t v326 = v325[4] + v306;
          ++v325[3];
          v325[4] = v326;
        }

        uint64_t v327 = *((void *)v940 + 31);
        ++*(void *)(v327 + 16);
        if (v906) {
          ++*(void *)(*((void *)v940 + 32) + 16LL);
        }
        if (HIDWORD(v905)) {
          ++*(void *)(*((void *)v940 + 33) + 16LL);
        }
        if ((_DWORD)v905) {
          ++*(void *)(*((void *)v940 + 34) + 16LL);
        }
        *(void *)(v327 + 24) += v306;
        if (v906) {
          *(void *)(*((void *)v940 + 32) + 24LL) += v306;
        }
        if (HIDWORD(v905)) {
          *(void *)(*((void *)v940 + 33) + 24LL) += v306;
        }
        if ((_DWORD)v905) {
          *(void *)(*((void *)v940 + 34) + 24LL) += v306;
        }
        *(_DWORD *)(a1 + 712) += v306;
        ++*(_DWORD *)(a1 + 720);
        if (*(void *)(v3 + 24))
        {
          uint64_t v328 = nw_protocol_tcp_get_all_stats();
          if (v328) {
            *(_DWORD *)(v328 + 56) += v306;
          }
        }

        int64x2_t v323 = (void *)(a1 + 392);
        if ((*(_BYTE *)(a1 + 348) & 4) == 0) {
          goto LABEL_857;
        }
      }

LABEL_856:
      ++*v323;
      goto LABEL_857;
    }

    uint64_t v322 = *(void *)(a1 + 1056);
    if (v322)
    {
      int64x2_t v323 = (void *)(v322 + 72);
      goto LABEL_856;
    }

LABEL_857:
    if (!*(void *)(v3 + 400) || v924 < 0)
    {
      if (!v18 || (*(_BYTE *)(v3 + 828) & 2) != 0)
      {
LABEL_1690:
        unsigned int v515 = 0LL;
        LOBYTE(v896) = 1;
        goto LABEL_1691;
      }

      __nwlog_tcp_log();
      v750 = *(_DWORD *)(v3 + 384);
      v751 = tcpstates[*(int *)(a1 + 12)];
      if (*(void *)(v3 + 400)) {
        os_log_type_t v752 = "not";
      }
      else {
        os_log_type_t v752 = "is";
      }
      *(_DWORD *)__int128 buf = 136447746;
      *(void *)&uint8_t buf[4] = "tcp_output";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v887;
      *(_WORD *)&_BYTE buf[22] = 2082;
      *(void *)v955 = v752;
      *(_WORD *)&v955[8] = 1024;
      *(_DWORD *)&v955[10] = v750;
      *(_WORD *)&v955[14] = 1024;
      *(_DWORD *)&v955[16] = v924;
      *(_WORD *)&v955[20] = 1024;
      *(_DWORD *)&v955[22] = v306;
      *(_WORD *)&v955[26] = 2082;
      v956 = v751;
      v753 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault())
      {
        if (LOBYTE(info.numer) == 17)
        {
          v754 = (os_log_s *)__nwlog_tcp_log();
          v755 = info.numer;
          if (!os_log_type_enabled(v754, info.numer)) {
            goto LABEL_1688;
          }
          if (*(void *)(v3 + 400)) {
            v756 = "not";
          }
          else {
            v756 = "is";
          }
          v757 = *(_DWORD *)(v3 + 384);
          v758 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)__int128 buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)v955 = v756;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v757;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v758;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s]";
          goto LABEL_1687;
        }

        if (v953 == OS_LOG_TYPE_DEFAULT)
        {
          v754 = (os_log_s *)__nwlog_tcp_log();
          v755 = info.numer;
          if (!os_log_type_enabled(v754, info.numer)) {
            goto LABEL_1688;
          }
          if (*(void *)(v3 + 400)) {
            v785 = "not";
          }
          else {
            v785 = "is";
          }
          v786 = *(_DWORD *)(v3 + 384);
          v787 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)__int128 buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)v955 = v785;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v786;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v787;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s], backtrace limit exceeded";
          goto LABEL_1687;
        }

        BOOL v778 = (void *)__nw_create_backtrace_string();
        v754 = (os_log_s *)__nwlog_tcp_log();
        v755 = info.numer;
        v779 = os_log_type_enabled(v754, info.numer);
        if (v778)
        {
          if (v779)
          {
            if (*(void *)(v3 + 400)) {
              v780 = "not";
            }
            else {
              v780 = "is";
            }
            v781 = *(_DWORD *)(v3 + 384);
            v782 = tcpstates[*(int *)(a1 + 12)];
            *(_DWORD *)__int128 buf = 136448002;
            *(void *)&uint8_t buf[4] = "tcp_output";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v887;
            *(_WORD *)&_BYTE buf[22] = 2082;
            *(void *)v955 = v780;
            *(_WORD *)&v955[8] = 1024;
            *(_DWORD *)&v955[10] = v781;
            *(_WORD *)&v955[14] = 1024;
            *(_DWORD *)&v955[16] = v924;
            *(_WORD *)&v955[20] = 1024;
            *(_DWORD *)&v955[22] = v306;
            *(_WORD *)&v955[26] = 2082;
            v956 = v782;
            LOWORD(v957[0]) = 2082;
            *(void *)((char *)v957 + 2) = v778;
            _os_log_impl( &dword_1879E5000,  v754,  v755,  "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.sb_c c %u off %d len %d t_state[%{public}s], dumping backtrace:%{public}s",  buf,  0x46u);
          }

          free(v778);
          goto LABEL_1688;
        }

        if (v779)
        {
          if (*(void *)(v3 + 400)) {
            v789 = "not";
          }
          else {
            v789 = "is";
          }
          v790 = *(_DWORD *)(v3 + 384);
          os_log_type_t v791 = tcpstates[*(int *)(a1 + 12)];
          *(_DWORD *)__int128 buf = 136447746;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 2082;
          *(void *)v955 = v789;
          *(_WORD *)&v955[8] = 1024;
          *(_DWORD *)&v955[10] = v790;
          *(_WORD *)&v955[14] = 1024;
          *(_DWORD *)&v955[16] = v924;
          *(_WORD *)&v955[20] = 1024;
          *(_DWORD *)&v955[22] = v306;
          *(_WORD *)&v955[26] = 2082;
          v956 = v791;
          v759 = "%{public}s %{public}s m is non-NULL but there is nothing to send so_snd.sb_mb %{public}s empty so_snd.s"
                 "b_cc %u off %d len %d t_state[%{public}s], no backtrace";
LABEL_1687:
          _os_log_impl(&dword_1879E5000, v754, v755, v759, buf, 0x3Cu);
        }
      }

LABEL_1688:
      if (v753) {
        free(v753);
      }
      goto LABEL_1690;
    }

    uint64_t v332 = *(void *)(v3 + 24);
    uint64_t v333 = *(void *)(v332 + 32);
    info = 0LL;
    p_info = &info;
    unsigned int v334 = v306 + v321;
    if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(v333 + 24) + 88LL))(v333, v332))
    {
      if ((*(_BYTE *)(v923 + 828) & 2) == 0)
      {
        v797 = (os_log_s *)__nwlog_tcp_log();
        v761 = (void *)(a1 + 632);
        if (os_log_type_enabled(v797, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v955 = v306 + v321;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v914;
          _os_log_impl( &dword_1879E5000,  v797,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s no output frames len %d, TSO %d",  buf,  0x22u);
        }

        unsigned int v515 = 55LL;
LABEL_1617:
        LOBYTE(v896) = 1;
        v749 = (void *)*v761;
        if (*v761) {
          goto LABEL_1628;
        }
        goto LABEL_1692;
      }

LABEL_1893:
      unsigned int v515 = 55LL;
      v761 = (void *)(a1 + 632);
      goto LABEL_1617;
    }

    uint64_t v18 = (uint64_t)info;
    if (!*(void *)&info)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
      v798 = (void *)_os_log_send_and_compose_impl();
      v953 = OS_LOG_TYPE_ERROR;
      v952 = 0;
      if (v953 != OS_LOG_TYPE_FAULT)
      {
        if (v952)
        {
          v811 = (void *)__nw_create_backtrace_string();
          v812 = (os_log_s *)__nwlog_obj();
          uint64_t v813 = v953;
          uint64_t v814 = os_log_type_enabled(v812, v953);
          if (v811)
          {
            if (v814)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v811;
              _os_log_impl( &dword_1879E5000,  v812,  v813,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v811);
            goto LABEL_1796;
          }

          if (!v814) {
            goto LABEL_1796;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          v801 = "%{public}s called with null frame, no backtrace";
          uint64_t v828 = v812;
          int v829 = v813;
        }

        else
        {
          BOOL v799 = (os_log_s *)__nwlog_obj();
          v800 = v953;
          if (!os_log_type_enabled(v799, v953)) {
            goto LABEL_1796;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
          v801 = "%{public}s called with null frame, backtrace limit exceeded";
LABEL_1794:
          uint64_t v828 = v799;
          int v829 = v800;
        }

        _os_log_impl(&dword_1879E5000, v828, v829, v801, buf, 0xCu);
        goto LABEL_1796;
      }

      BOOL v799 = (os_log_s *)__nwlog_obj();
      v800 = v953;
      if (os_log_type_enabled(v799, v953))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        v801 = "%{public}s called with null frame";
        goto LABEL_1794;
      }

LABEL_1796:
      if (v798) {
        free(v798);
      }
      v760 = 0LL;
      v761 = (void *)(a1 + 632);
      if ((*(_BYTE *)(v923 + 828) & 2) != 0)
      {
LABEL_1614:
        if (v18)
        {
          v763 = *(void (**)(uint64_t, void, uint64_t))(v760 + 80);
          if (v763)
          {
            v764 = *(void *)(v760 + 88);
            *(void *)(v760 + 80) = 0LL;
            *(void *)(v760 + 88) = 0LL;
            v763(v760, 0LL, v764);
            unsigned int v515 = 6LL;
            goto LABEL_1617;
          }

          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v842 = (void *)_os_log_send_and_compose_impl();
          v953 = OS_LOG_TYPE_ERROR;
          v952 = 0;
          if (v953 == OS_LOG_TYPE_FAULT)
          {
            int v843 = (os_log_s *)__nwlog_obj();
            int v844 = v953;
            if (os_log_type_enabled(v843, v953))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              int v845 = "%{public}s called with null frame->finalizer";
              goto LABEL_1868;
            }

LABEL_1870:
            if (v842) {
LABEL_1871:
            }
              free(v842);
LABEL_1872:
            unsigned int v515 = 6LL;
            v761 = (void *)(a1 + 632);
            goto LABEL_1617;
          }

          if (v952)
          {
            os_log_type_t v850 = (void *)__nw_create_backtrace_string();
            int v847 = (os_log_s *)__nwlog_obj();
            v848 = v953;
            v851 = os_log_type_enabled(v847, v953);
            if (v850)
            {
              if (v851)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v850;
                _os_log_impl( &dword_1879E5000,  v847,  v848,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v850);
              if (v842) {
                goto LABEL_1871;
              }
              goto LABEL_1872;
            }

            if (!v851) {
              goto LABEL_1870;
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v845 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_1877:
            v854 = v847;
            v855 = v848;
LABEL_1869:
            _os_log_impl(&dword_1879E5000, v854, v855, v845, buf, 0xCu);
            goto LABEL_1870;
          }

          int v843 = (os_log_s *)__nwlog_obj();
          int v844 = v953;
          if (!os_log_type_enabled(v843, v953)) {
            goto LABEL_1870;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          int v845 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v842 = (void *)_os_log_send_and_compose_impl();
          v953 = OS_LOG_TYPE_ERROR;
          v952 = 0;
          if (v953 == OS_LOG_TYPE_FAULT)
          {
            int v843 = (os_log_s *)__nwlog_obj();
            int v844 = v953;
            if (os_log_type_enabled(v843, v953))
            {
              *(_DWORD *)__int128 buf = 136446210;
              *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
              int v845 = "%{public}s called with null frame";
              goto LABEL_1868;
            }

            goto LABEL_1870;
          }

          if (v952)
          {
            unint64_t v846 = (void *)__nw_create_backtrace_string();
            int v847 = (os_log_s *)__nwlog_obj();
            v848 = v953;
            os_log_type_t v849 = os_log_type_enabled(v847, v953);
            if (v846)
            {
              if (v849)
              {
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v846;
                _os_log_impl( &dword_1879E5000,  v847,  v848,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v846);
              goto LABEL_1870;
            }

            if (!v849) {
              goto LABEL_1870;
            }
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            int v845 = "%{public}s called with null frame, no backtrace";
            goto LABEL_1877;
          }

          int v843 = (os_log_s *)__nwlog_obj();
          int v844 = v953;
          if (!os_log_type_enabled(v843, v953)) {
            goto LABEL_1870;
          }
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          int v845 = "%{public}s called with null frame, backtrace limit exceeded";
        }

LABEL_1868:
        v854 = v843;
        v855 = v844;
        goto LABEL_1869;
      }

LABEL_1612:
      v762 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v762, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_output";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v887;
        _os_log_impl( &dword_1879E5000,  v762,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s output buffer is no longer valid",  buf,  0x16u);
      }

      goto LABEL_1614;
    }

    if ((*(_WORD *)(*(void *)&info + 204LL) & 0x80) != 0) {
      *(_WORD *)(*(void *)&info + 196LL) -= v321;
    }
    unsigned int v335 = *(_DWORD *)(v18 + 56) + v321;
    int v336 = *(_DWORD *)(v18 + 60);
    if (v335 <= *(_DWORD *)(v18 + 52) - v336)
    {
      *(_DWORD *)(v18 + 56) = v335;
    }

    else
    {
      uint64_t v337 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v337, OS_LOG_TYPE_ERROR))
      {
        int v338 = *(_DWORD *)(v18 + 52);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v335;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v338;
        *(_WORD *)v955 = 1024;
        *(_DWORD *)&v955[2] = v336;
        _os_log_impl( &dword_1879E5000,  v337,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
      }
    }

    uint64_t v339 = *(void *)(v18 + 112);
    if (!v339
      || (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && (!((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v18, *(void *)(v18 + 88))
       || (uint64_t v339 = *(void *)(v18 + 112)) == 0))
    {
      v760 = v18;
      v761 = (void *)(a1 + 632);
      if ((*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        v760 = v18;
        if (*MEMORY[0x189608EF8])
        {
          v760 = v18;
          if ((((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v18, *(void *)(v18 + 88)) & 1) == 0)
          {
            *(void *)(a1 + 1056) = 0LL;
            v760 = v18;
          }
        }
      }

      if ((*(_BYTE *)(v923 + 828) & 2) != 0) {
        goto LABEL_1614;
      }
      goto LABEL_1612;
    }

    if (!nw_protocol_tcp_copy_frame_to_buffer( *(void *)(v923 + 400),  v924,  v306,  (char *)(v339 + *(unsigned int *)(v18 + 56))))
    {
      if ((*(_BYTE *)(v923 + 828) & 2) == 0)
      {
        v802 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v802, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          _os_log_impl( &dword_1879E5000,  v802,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s copy from snd buffer to channel buffer failed",  buf,  0x16u);
        }
      }

      os_log_type_t v803 = *(void (**)(uint64_t, void, uint64_t))(v18 + 80);
      v761 = (void *)(a1 + 632);
      if (v803)
      {
        v804 = *(void *)(v18 + 88);
        *(void *)(v18 + 80) = 0LL;
        *(void *)(v18 + 88) = 0LL;
        v803(v18, 0LL, v804);
        unsigned int v515 = 55LL;
        goto LABEL_1617;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      v856 = (void *)_os_log_send_and_compose_impl();
      v953 = OS_LOG_TYPE_ERROR;
      v952 = 0;
      if (v953 == OS_LOG_TYPE_FAULT)
      {
        v857 = (os_log_s *)__nwlog_obj();
        v858 = v953;
        if (os_log_type_enabled(v857, v953))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v859 = "%{public}s called with null frame->finalizer";
          goto LABEL_1889;
        }

        goto LABEL_1891;
      }

      if (v952)
      {
        v860 = (void *)__nw_create_backtrace_string();
        v861 = (os_log_s *)__nwlog_obj();
        v862 = v953;
        v863 = os_log_type_enabled(v861, v953);
        if (v860)
        {
          if (v863)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v860;
            _os_log_impl( &dword_1879E5000,  v861,  v862,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v860);
          goto LABEL_1891;
        }

        if (!v863)
        {
LABEL_1891:
          if (v856) {
            free(v856);
          }
          goto LABEL_1893;
        }

        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v859 = "%{public}s called with null frame->finalizer, no backtrace";
        v864 = v861;
        v865 = v862;
      }

      else
      {
        v857 = (os_log_s *)__nwlog_obj();
        v858 = v953;
        if (!os_log_type_enabled(v857, v953)) {
          goto LABEL_1891;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v859 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
LABEL_1889:
        v864 = v857;
        v865 = v858;
      }

      _os_log_impl(&dword_1879E5000, v864, v865, v859, buf, 0xCu);
      goto LABEL_1891;
    }

    if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
      *(_WORD *)(v18 + 196) -= v306;
    }
    int v340 = *(_DWORD *)(v18 + 52);
    unsigned int v341 = *(_DWORD *)(v18 + 56) + v306;
    int v342 = *(_DWORD *)(v18 + 60);
    if (v341 <= v340 - v342)
    {
      *(_DWORD *)(v18 + 56) = v341;
    }

    else
    {
      int v343 = (os_log_s *)__nwlog_obj();
      BOOL v344 = os_log_type_enabled(v343, OS_LOG_TYPE_ERROR);
      int v340 = *(_DWORD *)(v18 + 52);
      if (v344)
      {
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "__nw_frame_claim_internal";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v341;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v340;
        *(_WORD *)v955 = 1024;
        *(_DWORD *)&v955[2] = v342;
        _os_log_impl( &dword_1879E5000,  v343,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
        int v340 = *(_DWORD *)(v18 + 52);
      }
    }

    size_t v345 = (size_t)v918;
    if (v340)
    {
      uint64_t v347 = *(unsigned int *)(v18 + 56);
      size_t v346 = *(unsigned int *)(v18 + 60);
      uint64_t v348 = (v340 - (v346 + v347));
      if (v340 != (_DWORD)v346 + (_DWORD)v347)
      {
        if ((_DWORD)v346)
        {
          uint64_t v349 = *(void *)(v18 + 112);
          if (v349)
          {
            memmove((void *)(v349 + v347), (const void *)(v349 + v347 + v348), v346);
            int v340 = *(_DWORD *)(v18 + 52);
          }
        }

        *(_DWORD *)(v18 + 52) = v340 - v348;
        if ((*(_WORD *)(v18 + 204) & 0x80) != 0)
        {
          unsigned int v350 = *(unsigned __int16 *)(v18 + 196);
          BOOL v351 = v350 >= v348;
          unsigned int v352 = v350 - v348;
          *(_WORD *)(v18 + 196) = v352;
          if (!v351 || v352 >= 0x10000)
          {
            __nwlog_obj();
            uint64_t v353 = *(unsigned __int16 *)(v18 + 196);
            *(_DWORD *)__int128 buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = "frame->aggregate_buffer_length";
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)v955 = v348;
            *(_WORD *)&v955[8] = 2048;
            *(void *)&v955[10] = v353;
            uint64_t v354 = _os_log_send_and_compose_impl();
            v953 = OS_LOG_TYPE_ERROR;
            v952 = 0;
            unsigned int v881 = (os_log_t)v354;
            if (v953 != OS_LOG_TYPE_FAULT)
            {
              if (v952)
              {
                v383 = (void *)__nw_create_backtrace_string();
                os_log_type_t v384 = (os_log_s *)__nwlog_obj();
                os_log_type_t v385 = v953;
                os_log_type_t log = v384;
                BOOL v386 = os_log_type_enabled(v384, v953);
                if (v383)
                {
                  if (v386)
                  {
                    uint64_t v387 = *(unsigned __int16 *)(v18 + 196);
                    *(_DWORD *)__int128 buf = 136447234;
                    *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = "frame->aggregate_buffer_length";
                    *(_WORD *)&_BYTE buf[22] = 2048;
                    *(void *)v955 = v348;
                    *(_WORD *)&v955[8] = 2048;
                    *(void *)&v955[10] = v387;
                    *(_WORD *)&v955[18] = 2082;
                    *(void *)&v955[20] = v383;
                    _os_log_impl( &dword_1879E5000,  log,  v385,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v383);
                  goto LABEL_952;
                }

                if (!v386) {
                  goto LABEL_952;
                }
                uint64_t v410 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)__int128 buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&_BYTE buf[22] = 2048;
                *(void *)v955 = v348;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v410;
                __int16 v358 = log;
                os_log_type_t v359 = v385;
                BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              }

              else
              {
                int v399 = (os_log_s *)__nwlog_obj();
                os_log_type_t v400 = v953;
                if (!os_log_type_enabled(v399, v953)) {
                  goto LABEL_952;
                }
                uint64_t v401 = *(unsigned __int16 *)(v18 + 196);
                *(_DWORD *)__int128 buf = 136446978;
                *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = "frame->aggregate_buffer_length";
                *(_WORD *)&_BYTE buf[22] = 2048;
                *(void *)v955 = v348;
                *(_WORD *)&v955[8] = 2048;
                *(void *)&v955[10] = v401;
                __int16 v358 = v399;
                os_log_type_t v359 = v400;
                BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              }

LABEL_951:
              _os_log_impl(&dword_1879E5000, v358, v359, v360, buf, 0x2Au);
              goto LABEL_952;
            }

            int v355 = (os_log_s *)__nwlog_obj();
            os_log_type_t v356 = v953;
            if (os_log_type_enabled(v355, v953))
            {
              uint64_t v357 = *(unsigned __int16 *)(v18 + 196);
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_collapse";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = "frame->aggregate_buffer_length";
              *(_WORD *)&_BYTE buf[22] = 2048;
              *(void *)v955 = v348;
              *(_WORD *)&v955[8] = 2048;
              *(void *)&v955[10] = v357;
              __int16 v358 = v355;
              os_log_type_t v359 = v356;
              BOOL v360 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
              goto LABEL_951;
            }

LABEL_952:
            if (v881) {
              free(v881);
            }
            *(_WORD *)(v18 + 196) = 0;
            size_t v345 = (size_t)v918;
          }
        }
      }
    }

    if ((*(_WORD *)(v18 + 204) & 0x80) != 0) {
      *(_WORD *)(v18 + 196) += v334;
    }
    unsigned int v411 = *(_DWORD *)(v18 + 56);
    BOOL v351 = v411 >= v334;
    unsigned int v412 = v411 - v334;
    if (v351)
    {
      *(_DWORD *)(v18 + 56) = v412;
    }

    else
    {
      uint64_t v413 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v413, OS_LOG_TYPE_ERROR))
      {
        int v414 = *(_DWORD *)(v18 + 56);
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_frame_unclaim_internal";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v334;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v414;
        _os_log_impl( &dword_1879E5000,  v413,  OS_LOG_TYPE_ERROR,  "%{public}s Frame cannot unclaim %u start bytes (has %u left)",  buf,  0x18u);
      }
    }

    uint64_t v3 = v923;
    int v415 = v946;
    if (*(void *)(v923 + 24))
    {
      uint64_t v416 = nw_protocol_tcp_get_all_stats();
      if (v416) {
        ++*(void *)(v416 + 32);
      }
      if (*(void *)(v923 + 24))
      {
        uint64_t v417 = nw_protocol_tcp_get_all_stats();
        if (v417) {
          *(void *)(v417 + 40) += *(unsigned int *)(v18 + 52);
        }
      }
    }

    if ((v946 & 2) == 0 && v306 + v924 == *(_DWORD *)(v923 + 384)) {
      int v415 = v946 | 8;
    }
LABEL_1016:
    v946 = v415;
    uint64_t v438 = *(void *)(v18 + 112);
    if (!v438) {
      goto LABEL_1585;
    }
    LOBYTE(v439) = *(_WORD *)(v18 + 204);
    if ((*(_WORD *)(v18 + 204) & 0x100) == 0 || !*MEMORY[0x189608EF8])
    {
      uint64_t v441 = v438 + *(unsigned int *)(v18 + 56);
      if (v317) {
        goto LABEL_1025;
      }
LABEL_1022:
      if ((v439 & 0x40) == 0)
      {
        *(_DWORD *)(v18 + 192) = 0;
        goto LABEL_1044;
      }

      goto LABEL_1027;
    }

    if (!((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(v18, *(void *)(v18 + 88))
      || (uint64_t v440 = *(void *)(v18 + 112)) == 0)
    {
LABEL_1585:
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0) {
        goto LABEL_1620;
      }
      int v25 = (void *)(a1 + 632);
      if (*MEMORY[0x189608EF8]
        && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v18, *(void *)(v18 + 88)) & 1) == 0)
      {
        *(void *)(a1 + 1056) = 0LL;
      }

      goto LABEL_1621;
    }

    uint64_t v441 = v440 + *(unsigned int *)(v18 + 56);
    __int16 v439 = *(_WORD *)(v18 + 204);
    if (!v317) {
      goto LABEL_1022;
    }
LABEL_1025:
    if ((v439 & 0x40) == 0)
    {
      *(_DWORD *)(v18 + 192) = *(_DWORD *)(a1 + 1876);
      goto LABEL_1044;
    }

LABEL_1027:
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
    int v442 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(info.numer) = 16;
    v953 = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(info.numer) == 17)
    {
      uint64_t v443 = (os_log_s *)__nwlog_obj();
      os_log_type_t v444 = info.numer;
      if (os_log_type_enabled(v443, info.numer))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
        uint64_t v445 = v443;
        os_log_type_t v446 = v444;
        int v447 = "%{public}s Attempt to set generation-count on a chain-member";
        goto LABEL_1040;
      }

      goto LABEL_1041;
    }

    if (v953 == OS_LOG_TYPE_DEFAULT)
    {
      int v452 = (os_log_s *)__nwlog_obj();
      os_log_type_t v453 = info.numer;
      if (!os_log_type_enabled(v452, info.numer)) {
        goto LABEL_1041;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
      uint64_t v445 = v452;
      os_log_type_t v446 = v453;
      int v447 = "%{public}s Attempt to set generation-count on a chain-member, backtrace limit exceeded";
LABEL_1040:
      _os_log_impl(&dword_1879E5000, v445, v446, v447, buf, 0xCu);
      goto LABEL_1041;
    }

    int v448 = (void *)__nw_create_backtrace_string();
    int v449 = (os_log_s *)__nwlog_obj();
    os_log_type_t v450 = info.numer;
    BOOL v451 = os_log_type_enabled(v449, info.numer);
    if (v448)
    {
      if (v451)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v448;
        _os_log_impl( &dword_1879E5000,  v449,  v450,  "%{public}s Attempt to set generation-count on a chain-member, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v448);
      goto LABEL_1041;
    }

    if (v451)
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_set_compression_generation_count";
      uint64_t v445 = v449;
      os_log_type_t v446 = v450;
      int v447 = "%{public}s Attempt to set generation-count on a chain-member, no backtrace";
      goto LABEL_1040;
    }

LABEL_1041:
    if (v442) {
      free(v442);
    }
    size_t v345 = (size_t)v918;
LABEL_1044:
    uint64_t v454 = *(void *)(a1 + 80);
    if ((*(_BYTE *)(v454 + 2236) & 2) != 0) {
      __int16 v455 = in6_pseudo();
    }
    else {
      __int16 v455 = in_pseudo();
    }
    *(_WORD *)(v441 + 16) = v455;
    HIDWORD(v456) = *(_DWORD *)(v454 + 2224);
    LODWORD(v456) = HIDWORD(v456);
    *(_DWORD *)(v441 + 4) = 0;
    *(_DWORD *)(v441 + 8) = 0;
    *(_DWORD *)uint64_t v441 = v456 >> 16;
    *(_BYTE *)(v441 + 12) = 80;
    *(_BYTE *)(v441 + 13) = 0;
    *(_WORD *)(v441 + 14) = 0;
    *(_WORD *)(v441 + 18) = 0;
    int v457 = *(_DWORD *)(a1 + 740);
    int v458 = v911;
    if ((v457 & 0x10000000) == 0
      && ((v457 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 336) == 1 || tcp_do_l4s == 1)
      && ((v457 & 0x8000000) != 0 || *(_DWORD *)(sysctls + 320) == 1 || tcp_do_acc_ecn == 1))
    {
      int v459 = *(_DWORD *)(a1 + 348);
      if ((~v459 & 0x300000) == 0)
      {
        __int16 v460 = v946;
        if ((v459 & 4) == 0 || (v946 & 2) != 0) {
          goto LABEL_1075;
        }
        *(_BYTE *)(v18 + 186) = *(_BYTE *)(v18 + 186) & 0xFC | 1;
        int v461 = mach_timebase_info(&info);
        if (v461)
        {
          uint64_t v462 = v461;
          char v463 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v463, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "microuptime_ns";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v462;
            _os_log_impl( &dword_1879E5000,  v463,  OS_LOG_TYPE_ERROR,  "%{public}s mach_timebase_info returned %u",  buf,  0x12u);
          }

          __int16 v460 = v946;
          int v458 = v911;
          size_t v345 = (size_t)v918;
          goto LABEL_1075;
        }

        uint64_t v569 = mach_absolute_time() * info.numer;
        int v570 = v569 / info.denom;
        if ((_WORD)v306)
        {
          __int16 v460 = v946;
          int v458 = v911;
          if (v569 < info.denom)
          {
            int v600 = v569 / info.denom;
          }

          else
          {
            v571 = *(void *)(a1 + 496);
            if (!v571)
            {
              *(void *)(a1 + 496) = v570;
              *(_DWORD *)(a1 + 492) = (unsigned __int16)v306;
              *(void *)(v18 + 160) = v570;
              goto LABEL_1075;
            }

            v572 = *(_DWORD *)(a1 + 492) + (unsigned __int16)v306;
            *(_DWORD *)(a1 + 492) = v572;
            if (v572 <= *(_DWORD *)(a1 + 488))
            {
              *(void *)(v18 + 160) = v571;
              goto LABEL_1075;
            }

            os_log_type_t v573 = *(void *)(a1 + 480);
            if (v573)
            {
              v574 = 1000000000 * (unint64_t)v572 / v573;
              if (v574 >= 0x989680) {
                v574 = 10000000LL;
              }
              goto LABEL_1465;
            }

            __nwlog_obj();
            v607 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
            int v608 = *(_DWORD *)(a1 + 144);
            int v609 = *(int *)(a1 + 200) >> 5;
            *(_DWORD *)__int128 buf = 136446978;
            *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v607;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)v955 = v608;
            *(_WORD *)&v955[4] = 1024;
            *(_DWORD *)&v955[6] = v609;
            uint64_t v610 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(info.numer) = 16;
            v953 = OS_LOG_TYPE_DEFAULT;
            if (LOBYTE(info.numer) == 17)
            {
              uint64_t v611 = (os_log_s *)__nwlog_obj();
              char v612 = info.numer;
              if (os_log_type_enabled(v611, info.numer))
              {
                v613 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                unsigned int v614 = *(_DWORD *)(a1 + 144);
                char v615 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)__int128 buf = 136446978;
                *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&_BYTE buf[12] = 2080;
                *(void *)&buf[14] = v613;
                *(_WORD *)&_BYTE buf[22] = 1024;
                *(_DWORD *)v955 = v614;
                *(_WORD *)&v955[4] = 1024;
                *(_DWORD *)&v955[6] = v615;
                v616 = v611;
                v617 = v612;
                uint64_t v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms)";
                goto LABEL_1461;
              }

              goto LABEL_1462;
            }

            if (v953 == OS_LOG_TYPE_DEFAULT)
            {
              char v671 = (os_log_s *)__nwlog_obj();
              unsigned int v672 = info.numer;
              if (!os_log_type_enabled(v671, info.numer)) {
                goto LABEL_1462;
              }
              int v673 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              uint64_t v674 = *(_DWORD *)(a1 + 144);
              int v675 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = v673;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)v955 = v674;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v675;
              v616 = v671;
              v617 = v672;
              uint64_t v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), backtrace limit exceeded";
LABEL_1461:
              _os_log_impl(&dword_1879E5000, v616, v617, v618, buf, 0x22u);
              goto LABEL_1462;
            }

            v639 = (void *)__nw_create_backtrace_string();
            int v640 = (os_log_s *)__nwlog_obj();
            v641 = info.numer;
            v928 = v640;
            v642 = os_log_type_enabled(v640, info.numer);
            if (v639)
            {
              if (v642)
              {
                v643 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
                int v644 = *(_DWORD *)(a1 + 144);
                int v645 = *(int *)(a1 + 200) >> 5;
                *(_DWORD *)__int128 buf = 136447234;
                *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
                *(_WORD *)&_BYTE buf[12] = 2080;
                *(void *)&buf[14] = v643;
                *(_WORD *)&_BYTE buf[22] = 1024;
                *(_DWORD *)v955 = v644;
                *(_WORD *)&v955[4] = 1024;
                *(_DWORD *)&v955[6] = v645;
                *(_WORD *)&v955[10] = 2082;
                *(void *)&v955[12] = v639;
                _os_log_impl( &dword_1879E5000,  v928,  v641,  "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), dumping backtrace:%{public}s",  buf,  0x2Cu);
              }

              free(v639);
              goto LABEL_1462;
            }

            if (v642)
            {
              int v680 = tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)];
              int v681 = *(_DWORD *)(a1 + 144);
              unsigned int v682 = *(int *)(a1 + 200) >> 5;
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_pacer_get_packet_interval";
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = v680;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)v955 = v681;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v682;
              v616 = v928;
              v617 = v641;
              uint64_t v618 = "%{public}s pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms), no backtrace";
              goto LABEL_1461;
            }

LABEL_1462:
            if (v610) {
              free(v610);
            }
            v571 = *(void *)(a1 + 496);
            v574 = 10000000LL;
            __int16 v460 = v946;
            int v458 = v911;
            size_t v345 = (size_t)v918;
LABEL_1465:
            int v600 = v571 + v574;
            *(void *)(a1 + 496) = v600;
            *(_DWORD *)(a1 + 492) = 0;
            if (v570 > v600)
            {
              *(void *)(a1 + 496) = v570;
              goto LABEL_1468;
            }
          }
        }

        else
        {
          int v600 = v569 / info.denom;
          __int16 v460 = v946;
          int v458 = v911;
        }

        int v570 = v600;
        if (!v600) {
          goto LABEL_1075;
        }
LABEL_1468:
        *(void *)(v18 + 160) = v570;
        goto LABEL_1075;
      }
    }

    int v464 = (*(unsigned __int8 *)(a1 + 348) >> 2) & 1;
    if (!v306) {
      int v464 = 0;
    }
    __int16 v460 = v946;
    if (!v907)
    {
      if (!v464) {
        goto LABEL_1075;
      }
      uint64_t v465 = v935;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
        uint64_t v465 = 1;
      }
      if ((v465 & 1) != 0 || (v946 & 2) != 0) {
        goto LABEL_1075;
      }
LABEL_1074:
      *(_BYTE *)(v18 + 186) = *(_BYTE *)(v18 + 186) & 0xFC | 2;
      goto LABEL_1075;
    }

    if (v464)
    {
      v466 = v935;
      if (*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 96) < 0) {
        v466 = 1;
      }
      if ((v466 & 1) == 0) {
        goto LABEL_1074;
      }
    }

LABEL_1075:
    unint64_t v124 = a1 + 100;
    if ((v460 & 1) != 0 && (*(_BYTE *)(a1 + 88) & 0x10) != 0)
    {
      int v467 = *(_DWORD *)(a1 + 100);
      if (v467 == *(_DWORD *)(a1 + 96)) {
        *int type = v467 - 1;
      }
    }

    if (!v458)
    {
      char v469 = v306 - 1;
      if ((*(_DWORD *)(a1 + 740) & 0x20400020) == 0x20000020)
      {
        char v470 = *(_DWORD *)v55;
        *(_DWORD *)(v441 + 4) = bswap32(*(_DWORD *)v55);
        tcp_rxtseg_insert((void *)a1, v470, v469 + v470);
      }

      else
      {
        int v472 = *v898;
        *(_DWORD *)(v441 + 4) = bswap32(*v898);
        tcp_rxtseg_insert((void *)a1, v472, v469 + v472);
        *v898 += v306;
        size_t v345 = (size_t)v918;
        *(_DWORD *)(a1 + 624) += v306;
      }

      goto LABEL_1090;
    }

    if (v306 | v460 & 3)
    {
      uint64_t v468 = *(_DWORD *)(a1 + 96);
      goto LABEL_1085;
    }

    uint64_t v468 = *(_DWORD *)(a1 + 96);
    if (*(_DWORD *)(a1 + 36))
    {
LABEL_1085:
      v471 = *type;
      *(_DWORD *)(v441 + 4) = bswap32(*type);
      if ((int)(v471 - v468) < 0)
      {
        if (v306 > 1 && (*(_DWORD *)(a1 + 740) & 0x1020) == 0x20)
        {
          tcp_rxtseg_insert((void *)a1, v471, v306 + v471 - 1);
          goto LABEL_1091;
        }

LABEL_1090:
        if (v306 >= 1) {
LABEL_1091:
        }
          *(_BYTE *)(v18 + 186) |= 4u;
      }
    }

    else
    {
      *(_DWORD *)(v441 + 4) = bswap32(v468);
    }

    unsigned __int16 v473 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)(v441 + 8) = bswap32(v473);
    *(_DWORD *)(a1 + 284) = v473;
    if ((_DWORD)v345)
    {
      memmove((void *)(v441 + 20), __src, v345);
      int v474 = ((4 * v903) & 0xF0) + 80;
    }

    else
    {
      int v474 = *(_BYTE *)(v441 + 12);
    }

    *(_BYTE *)(v441 + 13) = v460;
    *(_BYTE *)(v441 + 12) = v474 & 0xF0 | HIBYTE(v460) & 1;
    int v475 = v909 >> *(_BYTE *)(a1 + 261);
    *(_WORD *)(v441 + 14) = bswap32(v475) >> 16;
    *(_DWORD *)(a1 + 132) = v909;
    if (v909 >= 1)
    {
      int v476 = *(_DWORD *)(a1 + 120) + v909;
      if (*(_DWORD *)(a1 + 124) - v476 < 0) {
        *(_DWORD *)(a1 + 124) = v476;
      }
    }

    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xFFFBFFFF | (((unsigned __int16)v475 == 0) << 18);
    int v477 = *(_DWORD *)(a1 + 12);
    int v478 = *((void *)v940 + 62);
    if (v306 + (_DWORD)v345) {
      *(_WORD *)(v441 + 16) = in_addword();
    }
    if (!v478) {
      goto LABEL_1275;
    }
    int v479 = *(void *)(v478 + 216);
    if (!v479) {
      goto LABEL_1275;
    }
    unsigned int v480 = *(_DWORD *)(v479 + 1048);
    if ((v480 & 0x1000) != 0)
    {
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0) {
        goto LABEL_1121;
      }
      int v482 = (uint64_t (*)(uint64_t, uint64_t, void, void))*MEMORY[0x189608F00];
      if (!*MEMORY[0x189608F00]) {
        goto LABEL_1121;
      }
      *(_BYTE *)(v18 + 203) |= 1u;
      BOOL v483 = 1;
      char v484 = v482(v18, 1LL, v889, v888);
      if (v484)
      {
        int v485 = v484;
        if (v484 != 45 && (*(_BYTE *)(v923 + 828) & 2) == 0)
        {
          int v486 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v486, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_output";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v887;
            *(_WORD *)&_BYTE buf[22] = 1024;
            *(_DWORD *)v955 = v485;
            _os_log_impl( &dword_1879E5000,  v486,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s set internet checksum offload failed (err %d)",  buf,  0x1Cu);
          }
        }

        goto LABEL_1121;
      }

LABEL_1122:
      LOWORD(v487) = v914;
      if (!v914) {
        goto LABEL_1124;
      }
LABEL_1123:
      int v487 = *(_DWORD *)(a1 + 156) - (_DWORD)v918;
      goto LABEL_1124;
    }

    if (!v907)
    {
      if ((((v480 & 2) == 0) & ~v914) == 0 && (*(_WORD *)(v18 + 204) & 0x100) != 0)
      {
        unsigned int v481 = *(_BYTE *)(v18 + 203) | 8;
        goto LABEL_1274;
      }

LABEL_1121:
      BOOL v483 = 0;
      goto LABEL_1122;
    }

    if ((((v480 & 0x20) == 0) & ~v914) != 0 || (*(_WORD *)(v18 + 204) & 0x100) == 0) {
      goto LABEL_1121;
    }
    unsigned int v481 = *(_BYTE *)(v18 + 203) | 0x20;
LABEL_1274:
    *(_BYTE *)(v18 + 203) = v481;
LABEL_1275:
    BOOL v483 = 1;
    LOWORD(v487) = v914;
    if (v914) {
      goto LABEL_1123;
    }
LABEL_1124:
    uint64_t v488 = *(unsigned __int16 *)(v18 + 204);
    *(_WORD *)(v18 + 198) = v487;
    unsigned int v489 = (v488 | (*(unsigned __int8 *)(v18 + 206) << 16)) & 0xFFFDFFFF | (v907 << 16);
    *(_WORD *)(v18 + 204) = v488;
    *(_BYTE *)(v18 + 206) = BYTE2(v489);
    if ((*(_BYTE *)(a1 + 741) & 0x80) != 0 && *(_DWORD *)(a1 + 36))
    {
      int v490 = ((v946 >> 1) & 1) + v306;
      if ((v946 & 1) != 0)
      {
        v491 = *(_DWORD *)(a1 + 88);
        if ((v491 & 0x10) == 0)
        {
          ++v490;
          *(_DWORD *)(a1 + 88) = v491 | 0x10;
        }
      }

      v492 = *(_DWORD *)(a1 + 100);
      if (v492 + v490 - *(_DWORD *)(a1 + 96) >= 1)
      {
        *(_DWORD *)(a1 + 96) = v492 + v306;
        *(_DWORD *)(a1 + 164) = *v910;
        if (*(void *)(v923 + 24))
        {
          os_log_type_t v493 = nw_protocol_tcp_get_all_stats();
          if (v493) {
            *(_DWORD *)(v493 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
          }
        }
      }

      goto LABEL_1184;
    }

    int v494 = *type;
    v495 = *type;
    if ((v946 & 3) != 0)
    {
      v495 = *type;
      if ((v946 & 2) != 0)
      {
        v495 = v494 + 1;
        *int type = v494 + 1;
      }

      if ((v946 & 1) != 0)
      {
        int v496 = *(_DWORD *)(a1 + 88);
        if ((v496 & 0x10) == 0)
        {
          *(_DWORD *)(a1 + 100) = ++v495;
          *(_DWORD *)(a1 + 88) = v496 | 0x10;
        }
      }
    }

    if ((v935 & 1) == 0)
    {
      if (v897 == 1)
      {
        int v497 = v891;
        *(_DWORD *)(a1 + 100) = v891;
        BOOL v498 = *(void *)(a1 + 1056);
        if (v498)
        {
          ++*(void *)(v498 + 760);
          int v497 = v891;
        }
      }

      else
      {
        int v497 = v495 + v306;
        *int type = v497;
      }

      *(_DWORD *)(a1 + 96) = v497;
      *(_DWORD *)(a1 + 164) = *v910;
      if (*(void *)(v923 + 24))
      {
        v499 = nw_protocol_tcp_get_all_stats();
        if (v499) {
          *(_DWORD *)(v499 + 108) = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        }
      }

      if (*(_DWORD *)(a1 + 172))
      {
LABEL_1925:
        if (*(_DWORD *)(a1 + 28))
        {
LABEL_1154:
          v897 = 0;
          goto LABEL_1164;
        }
      }

      else
      {
        *(_DWORD *)(a1 + 172) = *v910;
        *(_DWORD *)(a1 + 176) = v494;
        uint64_t v500 = *(void *)(a1 + 1056);
        if (v500) {
          ++*(void *)(v500 + 472);
        }
        *(_DWORD *)(a1 + 976) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 28)) {
          goto LABEL_1154;
        }
      }

      v897 = 0;
      v495 = *type;
      if ((v946 & 1) != 0) {
        goto LABEL_1161;
      }
      goto LABEL_1160;
    }

    if (!*(_DWORD *)(a1 + 28))
    {
      if (v495 != *(_DWORD *)(a1 + 96) || (v946 & 1) != 0)
      {
LABEL_1161:
        if (*(_DWORD *)(a1 + 36))
        {
          *(_DWORD *)(a1 + 36) = 0;
          *(_DWORD *)(a1 + 316) = 0;
          *(_WORD *)(a1 + 226) = 0;
          *(_DWORD *)(a1 + 248) = 0;
        }

        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                             - *(_DWORD *)(a1 + 64);
        goto LABEL_1164;
      }

LABEL_1160:
      if (v495 != *(_DWORD *)(a1 + 92)) {
        goto LABEL_1161;
      }
    }

LABEL_1164:
    if (v306)
    {
      if (*(_DWORD *)(sysctls + 132))
      {
        if (*(_DWORD *)(a1 + 12) == 4)
        {
          int v501 = *(_DWORD *)(a1 + 740);
          if ((v501 & 0x20) != 0 && (*(_BYTE *)(a1 + 90) & 0x20) == 0)
          {
            unsigned int v502 = *(_DWORD *)(a1 + 100);
            if (v502 == *(_DWORD *)(a1 + 96))
            {
              uint64_t v503 = v502 - *(_DWORD *)(a1 + 92);
              if (v503 >= 1 && (v501 & 0x3000) == 0 && !*(_WORD *)(a1 + 226))
              {
                int v504 = *(void *)(a1 + 80);
                unsigned int v505 = *(_DWORD *)(a1 + 200);
                if (v505 > 0x1F
                  || (unsigned int v506 = *(void *)(v504 + 448)) != 0
                  && *(unsigned __int8 *)(v506 + 1076) != 255
                  && *(_DWORD *)(v506 + 1024) != 255)
                {
                  int v507 = v505 >> 5;
                  else {
                    v508 = 2;
                  }
                  uint64_t v509 = v508 + 2 * v507;
                  if (*(_DWORD *)(a1 + 192) >= v509) {
                    unsigned int v510 = v509;
                  }
                  else {
                    unsigned int v510 = *(_DWORD *)(a1 + 192);
                  }
                  *(_DWORD *)(a1 + 16) = *(_DWORD *)(nw_tcp_access_globals(*(void *)(v504 + 224)) + 316)
                                       + v510
                                       - *(_DWORD *)(a1 + 64);
                }
              }
            }
          }
        }
      }
    }

LABEL_1184:
    uint64_t v511 = *((void *)v940 + 56);
    if (!v511 || (*(_WORD *)(v511 + 1074) & 8) != 0)
    {
      int v514 = v899;
      if (v899 > 499)
      {
        if (v899 <= 699)
        {
          if (v899 == 500)
          {
            int v514 = 2621728;
            goto LABEL_1195;
          }

          if (v899 == 600)
          {
            int v514 = 3146000;
            goto LABEL_1195;
          }
        }

        else
        {
          switch(v899)
          {
            case 700:
              int v514 = 3670272;
              goto LABEL_1195;
            case 800:
              int v514 = 4194688;
              goto LABEL_1195;
            case 900:
              int v514 = 4718992;
              goto LABEL_1195;
          }
        }
      }

      else if (v899 <= 199)
      {
        if (!v899) {
          goto LABEL_1195;
        }
        if (v899 == 100)
        {
          int v514 = 524432;
          goto LABEL_1195;
        }
      }

      else
      {
        switch(v899)
        {
          case 200:
            int v514 = 1048704;
            goto LABEL_1195;
          case 300:
            int v514 = 1572880;
            goto LABEL_1195;
          case 400:
            int v514 = 2097184;
            goto LABEL_1195;
        }
      }

      int v514 = 0;
    }

    else
    {
      if (!v306 && (*(_DWORD *)(v511 + 1052) & 0x200080) == 0x80)
      {
        int v512 = *(unsigned __int8 *)(v441 + 13);
        if (v512 == 16 && *(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 96))
        {
          unsigned int v513 = v895;
          if (!*(_DWORD *)(a1 + 28)) {
            unsigned int v513 = v895 | 2;
          }
          uint64_t v895 = v513;
        }

        v895 |= (2 * v512) & 4;
      }

      *(_DWORD *)__int128 buf = 0;
      set_frame_service_class(v18, v923, v899, v895, (int *)buf);
      int v514 = *(_DWORD *)buf;
    }

LABEL_1195:
    *(_DWORD *)(v18 + 176) = v514;
    *(_DWORD *)(a1 + 648) += v306;
    ++*(_DWORD *)(a1 + 300);
    if ((v483 & 1) != 0) {
      goto LABEL_1204;
    }
    unsigned int v515 = in_finalize_cksum();
    if ((_DWORD)v515
      && (*(_WORD *)(v18 + 204) & 0x100) != 0
      && *MEMORY[0x189608EF8]
      && (((uint64_t (*)(uint64_t, void))*MEMORY[0x189608EF8])(v18, *(void *)(v18 + 88)) & 1) == 0)
    {
      goto LABEL_1897;
    }

    unsigned int v516 = *(_DWORD *)(v18 + 52);
    if (v516)
    {
      int v517 = (v516 - (*(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60)));
      v518 = *(void *)(a1 + 1056);
      if (v518) {
        goto LABEL_1202;
      }
    }

    else
    {
      int v517 = 0LL;
      v518 = *(void *)(a1 + 1056);
      if (v518)
      {
LABEL_1202:
        ++*(void *)(v518 + v893);
        *(void *)(v518 + v892) += v517;
      }
    }

    if ((_DWORD)v515) {
      goto LABEL_1898;
    }
LABEL_1204:
    if ((*(_BYTE *)(v441 + 13) & 0x24) != 0)
    {
      if ((*(_BYTE *)(v923 + 828) & 2) == 0)
      {
        os_log_type_t v621 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v621, OS_LOG_TYPE_ERROR))
        {
          v622 = *(unsigned __int8 *)(v441 + 13);
          BOOL v623 = bswap32(*(_DWORD *)(v441 + 4));
          int v624 = bswap32(*(_DWORD *)(v441 + 8));
          uint64_t v625 = bswap32(*(unsigned __int16 *)(v441 + 14));
          v626 = *(_DWORD *)(a1 + 12);
          uint64_t v627 = *(_DWORD *)(a1 + 120);
          uint64_t v628 = *(_DWORD *)(a1 + 92);
          *(_DWORD *)__int128 buf = 136448258;
          *(void *)&uint8_t buf[4] = "tcp_output";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v887;
          *(_WORD *)&_BYTE buf[22] = 1024;
          *(_DWORD *)v955 = v622;
          *(_WORD *)&v955[4] = 1024;
          *(_DWORD *)&v955[6] = v623;
          *(_WORD *)&v955[10] = 1024;
          *(_DWORD *)&v955[12] = v624;
          *(_WORD *)&v955[16] = 1024;
          *(_DWORD *)&v955[18] = HIWORD(v625);
          *(_WORD *)&v955[22] = 1024;
          *(_DWORD *)&v955[24] = v626;
          LOWORD(v956) = 1024;
          *(_DWORD *)((char *)&v956 + 2) = v627;
          HIWORD(v956) = 1024;
          v957[0] = v628;
          uint64_t v629 = v621;
          uint64_t v630 = OS_LOG_TYPE_ERROR;
          goto LABEL_1417;
        }
      }
    }

    else if ((*(_BYTE *)(v441 + 13) & 3) != 0 && (*(_BYTE *)(v923 + 828) & 2) == 0)
    {
      uint64_t v631 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v631, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v632 = *(unsigned __int8 *)(v441 + 13);
        int v633 = bswap32(*(_DWORD *)(v441 + 4));
        uint64_t v634 = bswap32(*(_DWORD *)(v441 + 8));
        v635 = bswap32(*(unsigned __int16 *)(v441 + 14));
        int v636 = *(_DWORD *)(a1 + 12);
        uint64_t v637 = *(_DWORD *)(a1 + 120);
        v638 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)__int128 buf = 136448258;
        *(void *)&uint8_t buf[4] = "tcp_output";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v887;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v955 = v632;
        *(_WORD *)&v955[4] = 1024;
        *(_DWORD *)&v955[6] = v633;
        *(_WORD *)&v955[10] = 1024;
        *(_DWORD *)&v955[12] = v634;
        *(_WORD *)&v955[16] = 1024;
        *(_DWORD *)&v955[18] = HIWORD(v635);
        *(_WORD *)&v955[22] = 1024;
        *(_DWORD *)&v955[24] = v636;
        LOWORD(v956) = 1024;
        *(_DWORD *)((char *)&v956 + 2) = v637;
        HIWORD(v956) = 1024;
        v957[0] = v638;
        uint64_t v629 = v631;
        uint64_t v630 = OS_LOG_TYPE_DEFAULT;
LABEL_1417:
        _os_log_impl( &dword_1879E5000,  v629,  v630,  "%{public}s %{public}s flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u state=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u",  buf,  0x40u);
      }
    }

    tcp_log_packet(a1);
    *(void *)(v18 + 32) = 0LL;
    BOOL v519 = *(uint64_t **)(a1 + 640);
    *(void *)(v18 + 40) = v519;
    *BOOL v519 = v18;
    *(void *)(a1 + 640) = v18 + 32;
    int v520 = *(_DWORD *)(a1 + 740);
    v521 = v912;
    if ((~v520 & 0x20000020) != 0 || !v306 || (v520 & 0x400000) != 0) {
      goto LABEL_1364;
    }
    BOOL v522 = *(unsigned __int8 *)(v18 + 186);
    if ((v520 & 0x1000) != 0) {
      int v523 = (2 * v522) & 8;
    }
    else {
      int v523 = (v522 << 29 >> 31) & 0xC;
    }
    int v524 = bswap32(*(_DWORD *)(v441 + 4));
    int v525 = v524 + v306;
    uint64_t v526 = *v910;
    if (!v55)
    {
      if (v523 > 7)
      {
        uint64_t v542 = *v894;
        if (!*v894) {
          goto LABEL_1364;
        }
        int v543 = *v894;
        do
        {
          while (1)
          {
            int v544 = *(_DWORD *)(v543 + 4);
            int v543 = *(void *)(v543 + 32);
            if (!v543) {
              goto LABEL_1257;
            }
          }

          if (v525 == v544)
          {
            tcp_process_rxmt_segs_after_rto(a1, (int *)v543, v524, *v910, v523);
            goto LABEL_1346;
          }

          int v543 = *(void *)(v543 + 40);
        }

        while (v543);
        do
        {
LABEL_1257:
          uint64_t v545 = v542;
          uint64_t v542 = *(void *)(v542 + 32);
        }

        while (v542);
        do
        {
          while (1)
          {
LABEL_1266:
            char v547 = v545;
            if ((int)(v525 - *(_DWORD *)(v545 + 4)) < 0 && (int)(v525 - *(_DWORD *)v545) >= 1)
            {
              tcp_seg_rto_insert_end(a1, *(_DWORD *)v545, v524 + v306, *v910, *(_BYTE *)(v545 + 12) | v523);
              v521 = v912;
              int v548 = *(_DWORD *)v547;
              if ((int)(*(_DWORD *)v547 - v524) >= 1)
              {
                int v549 = *v894;
                if (*v894)
                {
                  while (1)
                  {
                    while (1)
                    {
                      uint64_t v596 = *(_DWORD *)(v549 + 4);
                      if (v548 - v596 >= 0) {
                        break;
                      }
                      int v549 = *(void *)(v549 + 32);
                      if (!v549) {
                        goto LABEL_1433;
                      }
                    }

                    if (v548 == v596) {
                      break;
                    }
                    int v549 = *(void *)(v549 + 40);
                    if (!v549) {
                      goto LABEL_1433;
                    }
                  }

                  tcp_process_rxmt_segs_after_rto(a1, (int *)v549, v524, v526, v523);
                  v521 = v912;
                }
              }

LABEL_1433:
              *(_DWORD *)char v547 = v525;
              int v587 = v913;
              if (v913) {
                goto LABEL_1365;
              }
              goto LABEL_1434;
            }

            int v546 = *(void *)(v545 + 40);
            if (!v546) {
              break;
            }
            do
            {
              uint64_t v545 = v546;
              int v546 = *(void *)(v546 + 32);
            }

            while (v546);
          }

          uint64_t v545 = *(void *)(v545 + 48) & 0xFFFFFFFFFFFFFFFELL;
        }

        while (v545 && *(void *)(v545 + 32) == v547);
        while (1)
        {
          uint64_t v545 = *(void *)(v547 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v545) {
            break;
          }
          BOOL v59 = v547 == *(void *)(v545 + 40);
          char v547 = *(void *)(v547 + 48) & 0xFFFFFFFFFFFFFFFELL;
          if (!v59) {
            goto LABEL_1266;
          }
        }

LABEL_1364:
        int v587 = v913;
        if (v913)
        {
LABEL_1365:
          if (*(_DWORD *)(a1 + 12) == 4
            && *(_DWORD *)(a1 + 144) > *(_DWORD *)(a1 + 140) >> 3
            && (*(_BYTE *)(a1 + 88) & 1) == 0
            && (*(_BYTE *)(a1 + 741) & 0x80) == 0
            && *(_DWORD *)(a1 + 300) < *(_DWORD *)(sysctls + 100))
          {
            os_log_type_t v595 = *(void **)(a1 + 1056);
            int v25 = (void *)(a1 + 632);
            uint64_t v3 = v923;
            int v2 = v940;
            if (v595) {
              ++*v595;
            }
            continue;
          }
        }

        goto LABEL_1434;
      }

      char v536 = *(void *)(a1 + 2024);
      if (v536)
      {
        v537 = *(void *)(v536 + 72);
        uint64_t v538 = *(void **)(v536 + 80);
        if (v537)
        {
          *(void *)(v537 + 80) = v538;
          uint64_t v538 = *(void **)(v536 + 80);
        }

        else
        {
          *(void *)(a1 + 2032) = v538;
        }

        *uint64_t v538 = v537;
        --*(_DWORD *)(a1 + 2040);
      }

      else
      {
        int v562 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
        int v563 = malloc(**(void **)(v562 + 64));
        v521 = v912;
        char v536 = (unint64_t)v563;
        if (!v563) {
          goto LABEL_1364;
        }
      }

      *(_OWORD *)(v536 + 72) = 0u;
      *(_OWORD *)(v536 + 60) = 0u;
      *(_OWORD *)(v536 + 44) = 0u;
      *(_OWORD *)(v536 + 28) = 0u;
      *(_OWORD *)(v536 + 12) = 0u;
      *(_DWORD *)char v536 = v524;
      *(_DWORD *)(v536 + 4) = v525;
      *(_DWORD *)(v536 + 8) = v526;
      if ((int)(v524 - *(_DWORD *)(a1 + 2060)) < 0)
      {
        *(_DWORD *)(a1 + 2060) = v524;
        *(_BYTE *)(v536 + 12) = v523;
        if ((v523 & 4) != 0) {
          goto LABEL_1332;
        }
LABEL_1322:
        v575 = *(char *)(a1 + 2069);
        if (v575 < 0)
        {
LABEL_1324:
          v576 = *v894;
          if (*v894)
          {
            while (1)
            {
              while (1)
              {
                BOOL v577 = v576;
                int v578 = *(_DWORD *)(v536 + 4) - *(_DWORD *)(v576 + 4);
                if (v578 >= 0) {
                  break;
                }
                v576 = *(void *)(v576 + 32);
                if (!v576) {
                  goto LABEL_1335;
                }
              }

              if (!v578) {
                break;
              }
              v576 = *(void *)(v576 + 40);
              if (!v576) {
                goto LABEL_1335;
              }
            }

            v580 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v580, OS_LOG_TYPE_ERROR))
            {
              unsigned int v581 = *(_DWORD *)v577;
              unsigned int v582 = *(_DWORD *)(v577 + 4);
              *(_DWORD *)__int128 buf = 136446978;
              *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(void *)&buf[14] = v577;
              *(_WORD *)&_BYTE buf[22] = 1024;
              *(_DWORD *)v955 = v581;
              *(_WORD *)&v955[4] = 1024;
              *(_DWORD *)&v955[6] = v582;
              _os_log_impl( &dword_1879E5000,  v580,  OS_LOG_TYPE_ERROR,  "%{public}s segment %p[%u %u) was not inserted in the RB tree",  buf,  0x22u);
            }
          }

          else
          {
            BOOL v577 = 0LL;
            int v578 = 0;
LABEL_1335:
            *(void *)(v536 + 32) = 0LL;
            *(void *)(v536 + 40) = 0LL;
            *(void *)(v536 + 48) = v577 | 1;
            BOOL v579 = (unint64_t *)(a1 + 2000);
            if (v577)
            {
              if (v578 < 0) {
                BOOL v579 = (unint64_t *)(v577 + 32);
              }
              else {
                BOOL v579 = (unint64_t *)(v577 + 40);
              }
            }

            *BOOL v579 = v536;
            tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v894, v536);
          }

          *(void *)(v536 + 16) = 0LL;
          int v567 = v536 + 16;
          int v586 = *(unint64_t **)(a1 + 1992);
          *(void *)(v536 + 24) = v586;
          *int v586 = v536;
          goto LABEL_1345;
        }
      }

      else
      {
        *(_BYTE *)(v536 + 12) = v523;
        if ((v523 & 4) == 0) {
          goto LABEL_1322;
        }
LABEL_1332:
        *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v536);
        v575 = *(char *)(a1 + 2069);
        if (v575 < 0) {
          goto LABEL_1324;
        }
      }

      *(_BYTE *)(a1 + 2069) = v575 | (32 * v523);
      goto LABEL_1324;
    }

    uint64_t v527 = *(_BYTE *)(v55 + 12) | v523;
    if (*(_DWORD *)(v55 + 4) == v525)
    {
      if (*(_DWORD *)v55 != v524)
      {
        v927 = *v910;
        __nwlog_obj();
        v528 = *(_DWORD *)v55;
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v528;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v524;
        v529 = (void *)_os_log_send_and_compose_impl();
        LOBYTE(info.numer) = 16;
        v953 = OS_LOG_TYPE_DEFAULT;
        if (LOBYTE(info.numer) != 17)
        {
          if (v953)
          {
            int v552 = (void *)__nw_create_backtrace_string();
            uint64_t v553 = (os_log_s *)__nwlog_obj();
            int v554 = info.numer;
            int v555 = os_log_type_enabled(v553, info.numer);
            if (v552)
            {
              if (v555)
              {
                unsigned int v556 = *(_DWORD *)v55;
                *(_DWORD *)__int128 buf = 136446978;
                *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
                *(_WORD *)&_BYTE buf[12] = 1024;
                *(_DWORD *)&buf[14] = v556;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v524;
                *(_WORD *)v955 = 2082;
                *(void *)&v955[2] = v552;
                _os_log_impl( &dword_1879E5000,  v553,  v554,  "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), dumping backtrace:%{public}s",  buf,  0x22u);
              }

              free(v552);
              goto LABEL_1351;
            }

            if (!v555) {
              goto LABEL_1351;
            }
            v588 = *(_DWORD *)v55;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v588;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v524;
            os_log_type_t v533 = v553;
            v534 = v554;
            BOOL v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), no backtrace";
          }

          else
          {
            BOOL v583 = (os_log_s *)__nwlog_obj();
            int v584 = info.numer;
            if (!os_log_type_enabled(v583, info.numer)) {
              goto LABEL_1351;
            }
            int v585 = *(_DWORD *)v55;
            *(_DWORD *)__int128 buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&buf[14] = v585;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v524;
            os_log_type_t v533 = v583;
            v534 = v584;
            BOOL v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u), backtrace limit exceeded";
          }

LABEL_1350:
          _os_log_impl(&dword_1879E5000, v533, v534, v535, buf, 0x18u);
          goto LABEL_1351;
        }

        uint64_t v530 = (os_log_s *)__nwlog_obj();
        uint64_t v531 = info.numer;
        if (os_log_type_enabled(v530, info.numer))
        {
          v532 = *(_DWORD *)v55;
          *(_DWORD *)__int128 buf = 136446722;
          *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v532;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v524;
          os_log_type_t v533 = v530;
          v534 = v531;
          BOOL v535 = "%{public}s Segment start (%u) is not same as retransmitted start sequence number (%u)";
          goto LABEL_1350;
        }

LABEL_1351:
        if (v529) {
          free(v529);
        }
        int v524 = *(_DWORD *)v55;
        int v525 = *(_DWORD *)(v55 + 4);
        v521 = v912;
        uint64_t v526 = v927;
      }

      *(_DWORD *)uint64_t v55 = v524;
      *(_DWORD *)(v55 + 4) = v525;
      *(_DWORD *)(v55 + 8) = v526;
      v589 = *(_BYTE *)(v55 + 12) | v527;
      *(_BYTE *)(v55 + 12) = v589;
      if ((v589 & 4) != 0)
      {
        int v590 = tcp_seg_len((int *)v55);
        v521 = v912;
        *(_DWORD *)(a1 + 2076) += v590;
      }

      unsigned int v591 = *(char *)(a1 + 2069);
      if ((v591 & 0x80000000) == 0) {
        *(_BYTE *)(a1 + 2069) = v591 | (32 * v527) & 0x80;
      }
      int v592 = *(void *)(v55 + 16);
      int v593 = *(void **)(v55 + 24);
      if (v592)
      {
        *(void *)(v592 + 24) = v593;
        int v593 = *(void **)(v55 + 24);
      }

      else
      {
        *(void *)(a1 + 1992) = v593;
      }

      *int v593 = v592;
      *(void *)(v55 + 16) = 0LL;
      v594 = *(void **)(a1 + 1992);
      *(void *)(v55 + 24) = v594;
      os_log_s *v594 = v55;
      *(void *)(a1 + 1992) = v55 + 16;
      goto LABEL_1364;
    }

    char v539 = *(void *)(a1 + 2024);
    if (v539)
    {
      int v540 = *(void *)(v539 + 72);
      uint64_t v541 = *(void **)(v539 + 80);
      if (v540)
      {
        *(void *)(v540 + 80) = v541;
        uint64_t v541 = *(void **)(v539 + 80);
      }

      else
      {
        *(void *)(a1 + 2032) = v541;
      }

      *uint64_t v541 = v540;
      --*(_DWORD *)(a1 + 2040);
    }

    else
    {
      int v550 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      int v551 = malloc(**(void **)(v550 + 64));
      v521 = v912;
      char v539 = (unint64_t)v551;
      if (!v551) {
        goto LABEL_1364;
      }
    }

    *(void *)(v539 + 80) = 0LL;
    *(_OWORD *)(v539 + 48) = 0u;
    *(_OWORD *)(v539 + 64) = 0u;
    *(_OWORD *)(v539 + 16) = 0u;
    *(_OWORD *)(v539 + 32) = 0u;
    *(_OWORD *)char v539 = 0u;
    *(_DWORD *)v55 += v306;
    *(_DWORD *)char v539 = v524;
    *(_DWORD *)(v539 + 4) = v525;
    *(_DWORD *)(v539 + 8) = v526;
    if ((int)(v524 - *(_DWORD *)(a1 + 2060)) >= 0)
    {
      *(_BYTE *)(v539 + 12) = v527;
      if ((v527 & 4) == 0) {
        goto LABEL_1286;
      }
LABEL_1296:
      *(_DWORD *)(a1 + 2076) += tcp_seg_len((int *)v539);
      v557 = *(char *)(a1 + 2069);
      if (v557 < 0) {
        goto LABEL_1288;
      }
LABEL_1287:
      *(_BYTE *)(a1 + 2069) = v557 | (32 * v527) & 0x80;
      goto LABEL_1288;
    }

    *(_DWORD *)(a1 + 2060) = v524;
    *(_BYTE *)(v539 + 12) = v527;
    if ((v527 & 4) != 0) {
      goto LABEL_1296;
    }
LABEL_1286:
    v557 = *(char *)(a1 + 2069);
    if ((v557 & 0x80000000) == 0) {
      goto LABEL_1287;
    }
LABEL_1288:
    unsigned int v558 = *v894;
    if (*v894)
    {
      while (1)
      {
        while (1)
        {
          int v559 = v558;
          uint64_t v560 = *(_DWORD *)(v539 + 4) - *(_DWORD *)(v558 + 4);
          if (v560 >= 0) {
            break;
          }
          unsigned int v558 = *(void *)(v558 + 32);
          if (!v558) {
            goto LABEL_1299;
          }
        }

        if (!v560) {
          break;
        }
        unsigned int v558 = *(void *)(v558 + 40);
        if (!v558) {
          goto LABEL_1299;
        }
      }

      uint64_t v564 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v564, OS_LOG_TYPE_ERROR))
      {
        int v565 = *(_DWORD *)v559;
        int v566 = *(_DWORD *)(v559 + 4);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "tcp_seg_sent_insert";
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v559;
        *(_WORD *)&_BYTE buf[22] = 1024;
        *(_DWORD *)v955 = v565;
        *(_WORD *)&v955[4] = 1024;
        *(_DWORD *)&v955[6] = v566;
        _os_log_impl( &dword_1879E5000,  v564,  OS_LOG_TYPE_ERROR,  "%{public}s segment %p[%u %u) was not inserted in the RB tree",  buf,  0x22u);
      }
    }

    else
    {
      int v559 = 0LL;
      uint64_t v560 = 0;
LABEL_1299:
      *(void *)(v539 + 32) = 0LL;
      *(void *)(v539 + 40) = 0LL;
      *(void *)(v539 + 48) = v559 | 1;
      uint64_t v561 = (unint64_t *)(a1 + 2000);
      if (v559)
      {
        if (v560 < 0) {
          uint64_t v561 = (unint64_t *)(v559 + 32);
        }
        else {
          uint64_t v561 = (unint64_t *)(v559 + 40);
        }
      }

      *uint64_t v561 = v539;
      tcp_seg_sent_tree_head_RB_INSERT_COLOR((uint64_t)v894, v539);
    }

    *(void *)(v539 + 16) = 0LL;
    int v567 = v539 + 16;
    uint64_t v568 = *(unint64_t **)(a1 + 1992);
    *(void *)(v539 + 24) = v568;
    *uint64_t v568 = v539;
LABEL_1345:
    *(void *)(a1 + 1992) = v567;
LABEL_1346:
    v521 = v912;
    int v587 = v913;
    if (v913) {
      goto LABEL_1365;
    }
LABEL_1434:
    uint64_t v660 = v521 ? 1 : v935;
    int v25 = (void *)(a1 + 632);
    uint64_t v3 = v923;
    int v2 = v940;
LABEL_1438:
    if (v940[2238]) {
      goto LABEL_1443;
    }
    if (*v949) {
      break;
    }
    v664 = *(_DWORD *)(a1 + 88);
    if ((v664 & 0x8000000) != 0) {
      goto LABEL_1807;
    }
LABEL_1443:
    BOOL v665 = *(void **)(a1 + 1056);
    if (v665) {
      ++*v665;
    }
    if (!v587) {
      goto LABEL_1707;
    }
  }

  v661 = *(_DWORD *)(a1 + 300);
  uint64_t v662 = *(_DWORD *)(a1 + 648);
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 88) &= 0xFFFFFFFC;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  int v663 = tcp_ip_output_send(v923, a1, v949, v661, v660);
  *(void *)(a1 + 632) = 0LL;
  *(void *)(a1 + 640) = v949;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  if (!(_DWORD)v663) {
    goto LABEL_1438;
  }
  unsigned int v515 = v663;
  if (v940[2238])
  {
    uint64_t v743 = v946;
    unint64_t v124 = a1 + 100;
    goto LABEL_1571;
  }

  v664 = *(_DWORD *)(a1 + 88);
  uint64_t v743 = v946;
  unint64_t v124 = a1 + 100;
  if ((v664 & 0x8000000) != 0) {
    goto LABEL_1807;
  }
LABEL_1571:
  v744 = *(_DWORD *)(a1 + 740);
  if ((v744 & 0x8000) != 0)
  {
    if (!(*(_DWORD *)(a1 + 36) | v743 & 2)) {
      goto LABEL_1575;
    }
    goto LABEL_1627;
  }

  if ((v743 & 2) != 0) {
    goto LABEL_1627;
  }
LABEL_1575:
  BOOL v59 = (v744 & 0x20400020) == 536870944;
  os_log_type_t v745 = v935 ^ 1;
  v746 = *(_DWORD *)(a1 + 92);
  if (v59) {
    os_log_type_t v745 = 1;
  }
  if ((v745 & 1) == 0)
  {
    BOOL v747 = *v898 - v662;
    if (v747 - v746 < 1)
    {
      uint64_t v662 = *v898 - v746;
      if (v746 - *v61 < 0) {
        v746 = *v61;
      }
    }

    else
    {
      v746 = *v61;
      if (v747 - *v61 >= 0) {
        v746 = *v898 - v662;
      }
    }

    *char v898 = v746;
    *(_DWORD *)(a1 + 624) = (*(_DWORD *)(a1 + 624) - v662) & ~((*(_DWORD *)(a1 + 624) - v662) >> 31);
    v749 = (void *)*v25;
    if (!*v25) {
      goto LABEL_1692;
    }
LABEL_1628:
    while (2)
    {
      v768 = v749[4];
      v769 = (void *)v749[5];
      if (v768)
      {
        *(void *)(v768 + 40) = v769;
        v769 = (void *)v749[5];
      }

      else
      {
        *(void *)(a1 + 640) = v769;
      }

      os_log_s *v769 = v768;
      os_log_type_t v770 = (void (*)(void *, void, uint64_t))v749[10];
      v749[4] = 0LL;
      v749[5] = 0LL;
      if (v770)
      {
        v771 = v749[11];
        v749[10] = 0LL;
        v749[11] = 0LL;
        v770(v749, 0LL, v771);
        goto LABEL_1633;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
      v772 = _os_log_send_and_compose_impl();
      LOBYTE(info.numer) = 16;
      v953 = OS_LOG_TYPE_DEFAULT;
      v936 = (void *)v772;
      if (LOBYTE(info.numer) == 17)
      {
        v931 = (os_log_s *)__nwlog_obj();
        __int128 v920 = info.numer;
        if (os_log_type_enabled(v931, info.numer))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          v773 = v931;
          v774 = v920;
          v775 = "%{public}s called with null frame->finalizer";
          break;
        }

        goto LABEL_1649;
      }

      if (v953)
      {
        v932 = (os_log_t)__nw_create_backtrace_string();
        unsigned __int16 v921 = (os_log_s *)__nwlog_obj();
        typea = info.numer;
        v776 = os_log_type_enabled(v921, info.numer);
        v777 = v932;
        if (v932)
        {
          if (v776)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v932;
            _os_log_impl( &dword_1879E5000,  v921,  typea,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
            v777 = v932;
          }

          free(v777);
          goto LABEL_1649;
        }

        if (!v776)
        {
LABEL_1649:
          if (v936) {
            free(v936);
          }
LABEL_1633:
          v749 = (void *)*v949;
          if (!*v949) {
            goto LABEL_1692;
          }
          continue;
        }

        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v773 = v921;
        v774 = typea;
        v775 = "%{public}s called with null frame->finalizer, no backtrace";
      }

      else
      {
        v933 = (os_log_s *)__nwlog_obj();
        int v922 = info.numer;
        if (!os_log_type_enabled(v933, info.numer)) {
          goto LABEL_1649;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        v773 = v933;
        v774 = v922;
        v775 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }

      break;
    }

    _os_log_impl(&dword_1879E5000, v773, v774, v775, buf, 0xCu);
    goto LABEL_1649;
  }

  v748 = *(_DWORD *)v124 - v662;
  if (v748 - v746 < 1)
  {
    *(_DWORD *)unint64_t v124 = v746;
    v749 = (void *)*v25;
    if (*v25) {
      goto LABEL_1628;
    }
  }

  else
  {
    *(_DWORD *)unint64_t v124 = v748;
    v749 = (void *)*v25;
    if (*v25) {
      goto LABEL_1628;
    }
  }

LABEL_1692:
  *(void *)(a1 + 632) = 0LL;
  *(void *)(a1 + 640) = v949;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  switch((int)v515)
  {
    case '(':
      if (v914) {
        *(_DWORD *)(a1 + 88) &= ~0x10000000u;
      }
      tcp_mtudisc(v940);
      goto LABEL_1707;
    case '2':
    case 'A':
      if (*(int *)(a1 + 12) >= 3)
      {
        *(_DWORD *)(a1 + 256) = v515;
        unsigned int v515 = 0LL;
      }

      break;
    case '7':
      if (!*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 36))
      {
        v792 = v896;
        if ((v946 & 3) != 0) {
          v792 = 1;
        }
        if ((v792 & 1) != 0 || *(_DWORD *)(v923 + 384)) {
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 192)
        }
                               + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
                               - *(_DWORD *)(a1 + 64);
      }

      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 288) = 0;
      goto LABEL_1707;
    default:
      break;
  }

  tcp_check_timer_state(a1);
  return v515;
}

uint64_t tcp_ip_output_send(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  uint64_t v10 = *(void *)(a2 + 80);
  uint64_t v11 = *(void *)(v10 + 496);
  int v72 = *(_DWORD *)(v10 + 2228);
  if ((*(_BYTE *)(a2 + 743) & 2) == 0
    || a4 != 1
    || *(_DWORD *)(a2 + 648)
    || *(_DWORD *)(a2 + 672) + 1 >= tcp_batch_ack_max)
  {
    goto LABEL_2;
  }

  int v14 = (void *)*a3;
  if (!*a3) {
    goto LABEL_89;
  }
  uint64_t v15 = v14[14];
  int v16 = (void *)MEMORY[0x189608EF8];
  if (!v15
    || (*((_WORD *)v14 + 102) & 0x100) != 0
    && *MEMORY[0x189608EF8]
    && (!((unsigned int (*)(void, void))*MEMORY[0x189608EF8])(*a3, v14[11]) || (uint64_t v15 = v14[14]) == 0))
  {
    if ((*((_WORD *)v14 + 102) & 0x100) != 0
      && *v16
      && (((uint64_t (*)(void *, void))*v16)(v14, v14[11]) & 1) == 0)
    {
      *(void *)(a2 + 1056) = 0LL;
    }

LABEL_110:
    if (v71) {
      free(v71);
    }
    goto LABEL_101;
  }

  if ((*(_BYTE *)(v15 + *((unsigned int *)v14 + 14) + 13) & 7) == 0)
  {
    if (*a3)
    {
      **(void **)(a2 + 664) = *a3;
      *(void *)(*a3 + 40LL) = *(void *)(a2 + 664);
      *(void *)(a2 + 664) = a3[1];
      *a3 = 0LL;
      a3[1] = a3;
    }

    uint64_t v17 = 0LL;
    ++*(_DWORD *)(a2 + 672);
    return v17;
  }

LABEL_2:
  uint64_t v12 = *(void *)(a2 + 656);
  if (v12)
  {
    if (*a3)
    {
      **(void **)(a2 + 664) = *a3;
      *(void *)(*a3 + 40LL) = *(void *)(a2 + 664);
      *(void *)(a2 + 664) = a3[1];
      *a3 = 0LL;
      a3[1] = a3;
      uint64_t v12 = *(void *)(a2 + 656);
      int v13 = a3;
      if (!v12) {
        goto LABEL_21;
      }
    }

    else
    {
      int v13 = (void *)a3[1];
    }

    void *v13 = v12;
    *(void *)(*(void *)(a2 + 656) + 40LL) = a3[1];
    a3[1] = *(void *)(a2 + 664);
    *(void *)(a2 + 656) = 0LL;
    *(void *)(a2 + 664) = a2 + 656;
LABEL_21:
    *(_DWORD *)(a2 + 672) = 0;
  }

  ++*(_BYTE *)(v10 + 2238);
  if (*(_DWORD *)(sysctls + 104) && !*(_DWORD *)(a1 + 592))
  {
    char v18 = 1;
    if (!a5 && *(_DWORD *)(a2 + 12) == 4 && (*(_BYTE *)(a2 + 90) & 0x20) == 0 && (*(_BYTE *)(a1 + 367) & 1) == 0)
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 0LL, v5);
      char v18 = 0;
    }
  }

  else
  {
    char v18 = 1;
  }

  uint64_t v19 = *(void *)(*(void *)(a1 + 24) + 32LL);
  if (__nwlog_is_datapath_logging_enabled())
  {
    v73[0] = MEMORY[0x1895F87A8];
    v73[1] = 0x40000000LL;
    int v74 = __tcp_ip_output_send_block_invoke;
    uint64_t v75 = &__block_descriptor_tmp_486;
    uint64_t v76 = a2;
    uint64_t v77 = a1;
    uint64_t v56 = *a3;
    do
    {
      if (!v56) {
        break;
      }
      uint64_t v57 = *(void *)(v56 + 32);
      char v58 = ((uint64_t (*)(void *))v74)(v73);
      uint64_t v56 = v57;
    }

    while ((v58 & 1) != 0);
  }

  unsigned int v20 = (void *)MEMORY[0x189608EE0];
  if (*MEMORY[0x189608EE0] != -1LL) {
    dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_487);
  }
  int v21 = (_BYTE *)MEMORY[0x189608ED8];
  if (*MEMORY[0x189608ED8] && kdebug_is_enabled())
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    uint64_t v81 = 0LL;
    nw_frame_array_foreach();
    if (*v20 == -1LL)
    {
      if (*v21) {
        goto LABEL_131;
      }
    }

    else
    {
      dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_487);
      if (*v21)
      {
LABEL_131:
        if (kdebug_is_enabled())
        {
          nw_frame_array_unclaimed_length();
          kdebug_trace();
        }
      }
    }

    _Block_object_dispose(buf, 8);
  }

  if (((*(uint64_t (**)(uint64_t, void *))(*(void *)(v19 + 24) + 96LL))(v19, a3) & 1) == 0)
  {
    int v22 = (void *)*a3;
    if (!*a3) {
      goto LABEL_57;
    }
    while (1)
    {
      uint64_t v23 = v22[4];
      int v24 = (void *)v22[5];
      if (v23)
      {
        *(void *)(v23 + 40) = v24;
        int v24 = (void *)v22[5];
      }

      else
      {
        a3[1] = v24;
      }

      *int v24 = v23;
      int v25 = (void (*)(void *, void, uint64_t))v22[10];
      v22[4] = 0LL;
      v22[5] = 0LL;
      if (!v25) {
        break;
      }
      uint64_t v26 = v22[11];
      v22[10] = 0LL;
      v22[11] = 0LL;
      v25(v22, 0LL, v26);
LABEL_39:
      int v22 = (void *)*a3;
      if (!*a3) {
        goto LABEL_57;
      }
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
    uint64_t v27 = _os_log_send_and_compose_impl();
    os_log_type_t v79 = OS_LOG_TYPE_ERROR;
    char v78 = 0;
    uint64_t v68 = (void *)v27;
    if (__nwlog_fault())
    {
      if (v79 == OS_LOG_TYPE_FAULT)
      {
        int v65 = (os_log_s *)__nwlog_obj();
        os_log_type_t log = v79;
        if (!os_log_type_enabled(v65, v79)) {
          goto LABEL_55;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = v65;
        os_log_type_t v29 = log;
        uint64_t v30 = "%{public}s called with null frame->finalizer";
        goto LABEL_54;
      }

      if (!v78)
      {
        unsigned int v67 = (os_log_s *)__nwlog_obj();
        os_log_type_t logb = v79;
        if (!os_log_type_enabled(v67, v79)) {
          goto LABEL_55;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = v67;
        os_log_type_t v29 = logb;
        uint64_t v30 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_54;
      }

      os_log_t backtrace_string = (os_log_t)__nw_create_backtrace_string();
      os_log_type_t loga = (os_log_s *)__nwlog_obj();
      os_log_type_t type = v79;
      BOOL v31 = os_log_type_enabled(loga, v79);
      os_log_t v32 = backtrace_string;
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_1879E5000,  loga,  type,  "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s",  buf,  0x16u);
          os_log_t v32 = backtrace_string;
        }

        free(v32);
        goto LABEL_55;
      }

      if (v31)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_finalize";
        uint64_t v28 = loga;
        os_log_type_t v29 = type;
        uint64_t v30 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_54:
        _os_log_impl(&dword_1879E5000, v28, v29, v30, buf, 0xCu);
      }
    }

uint64_t tcp_setpersist(uint64_t a1)
{
  int v2 = (*(_DWORD *)(a1 + 208) + (*(int *)(a1 + 200) >> 2)) >> 1;
  if (*(_DWORD *)(a1 + 312) && !*(_DWORD *)(a1 + 36) && !*(_DWORD *)(a1 + 316)) {
    *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 312)
  }
                          + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
  unsigned int v3 = tcp_backoff[*(unsigned __int16 *)(a1 + 226)] * v2;
  *(_DWORD *)(a1 + 36) = v3;
  if (v3 >> 3 >= 0x271)
  {
    if (v3 < 0xEA61) {
      goto LABEL_10;
    }
    int v4 = 60000;
  }

  else
  {
    int v4 = 5000;
  }

  *(_DWORD *)(a1 + 36) = v4;
LABEL_10:
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 36) + *(_DWORD *)(result + 316) - *(_DWORD *)(a1 + 64);
  unsigned int v6 = *(unsigned __int16 *)(a1 + 226);
  if (v6 <= 0xB) {
    *(_WORD *)(a1 + 226) = v6 + 1;
  }
  return result;
}

uint64_t tcp_ip_output(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  if (*a3 || *(void *)(a2 + 656))
  {
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a2 + 120);
    *(_DWORD *)(a2 + 88) &= 0xFFFFFFFC;
    *(_DWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 304) = 0;
    return tcp_ip_output_send(a1, a2, a3, a4, a5);
  }

  return a1;
}

uint64_t __tcp_ip_output_send_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    int v4 = *(_DWORD *)(a2 + 52);
    if (v4)
    {
      int v5 = v4 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60));
      if (!*(void *)(a1 + 32)) {
        return 1LL;
      }
    }

    else
    {
      int v5 = 0;
      if (!*(void *)(a1 + 32)) {
        return 1LL;
      }
    }

    uint64_t v6 = *(void *)(a2 + 112);
    int v7 = (void *)MEMORY[0x189608EF8];
    if (v6
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x189608EF8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88))
       && (uint64_t v6 = *(void *)(a2 + 112)) != 0))
    {
      int v8 = (unsigned __int16 *)(v6 + *(unsigned int *)(a2 + 56));
      uint64_t v9 = *(void *)(a1 + 40);
      if (!v9 || (*(_BYTE *)(v9 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          uint64_t v12 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            if (v9) {
              int v13 = (const char *)(v9 + 604);
            }
            else {
              int v13 = "";
            }
            unsigned int v14 = bswap32(*v8) >> 16;
            unsigned int v15 = bswap32(v8[1]) >> 16;
            int v16 = *((unsigned __int8 *)v8 + 13);
            unsigned int v17 = bswap32(*((_DWORD *)v8 + 1));
            unsigned int v18 = bswap32(*((_DWORD *)v8 + 2));
            unsigned int v19 = bswap32(v8[7]) >> 16;
            unsigned int v20 = *(_DWORD **)(a1 + 32);
            int v21 = v20[3];
            int v24 = v20[30];
            unsigned int v25 = v18;
            int v26 = v20[23];
            int v22 = packet_service_class_to_str(*(_DWORD *)(a2 + 176));
            *(_DWORD *)__int128 buf = 136449282;
            uint64_t v28 = "tcp_ip_output_send_block_invoke";
            __int16 v29 = 2082;
            uint64_t v30 = v13;
            __int16 v31 = 1024;
            unsigned int v32 = v14;
            __int16 v33 = 1024;
            unsigned int v34 = v15;
            __int16 v35 = 1024;
            int v36 = v5;
            __int16 v37 = 1024;
            int v38 = v16;
            __int16 v39 = 1024;
            unsigned int v40 = v17;
            __int16 v41 = 1024;
            unsigned int v42 = v25;
            __int16 v43 = 1024;
            unsigned int v44 = v19;
            __int16 v45 = 1024;
            int v46 = v21;
            __int16 v47 = 1024;
            int v48 = v24;
            __int16 v49 = 1024;
            int v50 = v26;
            __int16 v51 = 2082;
            uint64_t v52 = v22;
            _os_log_impl( &dword_1879E5000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sending frame, %u:%u tlen %u flags=%{network:tcp_flags}x seq=%u, ack=%u, win=%u stat e=%{network:tcp_state}x rcv_nxt=%u, snd_una=%u svc %{public}s",  buf,  0x5Cu);
          }
        }
      }
    }

    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0 {
           && *v7
    }
           && (((uint64_t (*)(uint64_t, void))*v7)(a2, *(void *)(a2 + 88)) & 1) == 0)
    {
      *(void *)(*(void *)(a1 + 32) + 1056LL) = 0LL;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v28 = "__nw_frame_unclaimed_length";
    uint64_t v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v23 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v28 = "__nw_frame_unclaimed_length";
        _os_log_impl( &dword_1879E5000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v11) {
      free(v11);
    }
  }

  return 1LL;
}

uint64_t __tcp_ip_output_send_block_invoke_7(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)(a1 + 40))
  {
    int v4 = (void *)MEMORY[0x189608EF8];
    if (*(void *)(a2 + 112)
      && ((*(_WORD *)(a2 + 204) & 0x100) == 0
       || !*MEMORY[0x189608EF8]
       || ((unsigned int (*)(uint64_t, void))*MEMORY[0x189608EF8])(a2, *(void *)(a2 + 88))
       && *(void *)(a2 + 112)))
    {
      if (*MEMORY[0x189608EE0] != -1LL) {
        dispatch_once(MEMORY[0x189608EE0], &__block_literal_global_487);
      }
    }

    else if ((*(_WORD *)(a2 + 204) & 0x100) != 0 {
           && *v4
    }
           && (((uint64_t (*)(uint64_t, void))*v4)(a2, *(void *)(a2 + 88)) & 1) == 0)
    {
      *(void *)(*(void *)(a1 + 40) + 1056LL) = 0LL;
    }
  }

  return 1LL;
}

uint64_t ____nw_signpost_is_enabled_block_invoke_491()
{
  uint64_t result = networkd_settings_get_BOOL();
  *MEMORY[0x189608ED8] = result;
  return result;
}

void tcp_output_batch_acks_end(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 240);
  uint64_t v3 = *(void *)(a1 + 224);
  if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      int v4 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        int v5 = (const char *)(v3 + 604);
        int v6 = *(_DWORD *)(v2 + 740);
        int v7 = *(_DWORD *)(v2 + 648);
        if (!v3) {
          int v5 = "";
        }
        int v8 = *(_DWORD *)(v2 + 300);
        int v13 = "tcp_output_batch_acks_end";
        BOOL v9 = (v6 & 0x2000000) == 0;
        uint64_t v10 = "off";
        int v12 = 136447234;
        if (!v9) {
          uint64_t v10 = "on";
        }
        __int16 v14 = 2082;
        unsigned int v15 = v5;
        __int16 v16 = 2082;
        unsigned int v17 = v10;
        __int16 v18 = 1024;
        int v19 = v7;
        __int16 v20 = 1024;
        int v21 = v8;
        _os_log_impl( &dword_1879E5000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s t_pktlist_sentlen %d t_lastchain %d",  (uint8_t *)&v12,  0x2Cu);
      }
    }
  }

  *(_DWORD *)(v2 + 740) &= ~0x2000000u;
  if (*(_BYTE *)(a1 + 2238)) {
    goto LABEL_17;
  }
  if (*(void *)(v2 + 632)) {
    goto LABEL_14;
  }
  while (*(void *)(v2 + 656))
  {
LABEL_14:
    tcp_ip_output_send(v3, v2, (void *)(v2 + 632), *(_DWORD *)(v2 + 300), 0);
    *(void *)(v2 + 632) = 0LL;
    *(void *)(v2 + 640) = v2 + 632;
    *(_DWORD *)(v2 + 648) = 0;
    *(_DWORD *)(v2 + 300) = 0;
    if (*(_BYTE *)(a1 + 2238)) {
      goto LABEL_17;
    }
  }

  int v11 = *(_DWORD *)(v2 + 88);
  if ((v11 & 0x8000000) != 0)
  {
    *(_DWORD *)(v2 + 88) = v11 & 0xF7FFFFFF;
    tcp_close(v2);
  }

  else
  {
LABEL_17:
    tcp_check_timer_state(v2);
  }

_DWORD *tcp_update_sack_list(_DWORD *result, int a2, int a3)
{
  uint64_t v3 = result;
  __src[6] = *MEMORY[0x1895F89C0];
  uint64_t v4 = result[141];
  if ((int)v4 < 1)
  {
    int v5 = 0;
  }

  else
  {
    int v5 = 0;
    int v6 = result + 142;
    do
    {
      int v7 = *v6;
      int v8 = HIDWORD(*v6);
      if (v7 - v8 < 0 && v7 - result[30] >= 1)
      {
        if (a2 - v8 > 0 || a3 - v7 < 0)
        {
          __src[v5++] = *v6;
        }

        else
        {
          if (a2 - v7 > 0) {
            a2 = *v6;
          }
          if (a3 - v8 < 0) {
            a3 = HIDWORD(*v6);
          }
        }
      }

      ++v6;
      --v4;
    }

    while (v4);
  }

  if (a2 - result[30] < 1)
  {
    unsigned int v9 = 0;
    if (v5 < 1) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }

  result[142] = a2;
  result[143] = a3;
  v5 -= v5 > 5;
  unsigned int v9 = 1;
  if (v5 >= 1) {
LABEL_17:
  }
    uint64_t result = memcpy(&result[2 * v9 + 142], __src, 8LL * v5);
LABEL_18:
  int v10 = v5 + v9;
  v3[141] = v5 + v9;
  int v11 = v3[22];
  if (v11 < 0 && v10 >= 1)
  {
    v3[22] = v11 & 0x7DFFFFFF;
    *((void *)v3 + 41) = 0LL;
    uint64_t result = (_DWORD *)nw_tcp_access_globals(*(void *)(*((void *)v3 + 10) + 224LL));
    v3[81] = result[79] + 100;
    v3[185] |= 2u;
    *((_WORD *)v3 + 172) = 0;
    int v10 = v3[141];
  }

  if (v10 >= 1)
  {
    *((_WORD *)v3 + 154) = 16;
    if (*((_WORD *)v3 + 377))
    {
      *((_WORD *)v3 + 377) = 0;
      v3[186] = 0;
    }
  }

  return result;
}

void tcp_sack_doack(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, _DWORD *a5)
{
  *(void *)&v73[28] = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)a2 & 1) != 0) {
    int v9 = *(_DWORD *)(a2 + 8);
  }
  else {
    int v9 = 0;
  }
  int v10 = *(_DWORD *)(a1 + 740);
  if ((v10 & 0x20400020) == 0x20000020 || *(_DWORD *)(a1 + 92) - a3 >= 0 || !*(void *)(a1 + 544))
  {
    int v11 = 0;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(_BYTE *)(a2 + 15)) {
      goto LABEL_22;
    }
  }

  else
  {
    v72[0] = *(_DWORD *)(a1 + 92);
    v72[1] = a3;
    int v11 = 1;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 15);
    if (!*(_BYTE *)(a2 + 15)) {
      goto LABEL_22;
    }
  }

  int v13 = *(int8x8_t **)(a2 + 16);
  do
  {
    int8x8_t v14 = vrev32_s8(*v13);
    if (v14.i32[1] - v14.i32[0] >= 1)
    {
      int v15 = *(_DWORD *)(a1 + 92);
      if (v14.i32[0] - v15 >= 1 && v14.i32[0] - a3 >= 1)
      {
        int v17 = *(_DWORD *)(a1 + 96);
        int v18 = v14.i32[1] - v15;
        BOOL v19 = v14.i32[1] - v17 > 0 || v18 < 1;
        if (!v19 && v14.i32[0] - v17 < 0) {
          *(int8x8_t *)&v72[2 * v11++] = v14;
        }
      }
    }

    ++v13;
    --v12;
  }

  while (v12);
LABEL_22:
  if (!v11) {
    return;
  }
  if (v11 >= 6)
  {
    uint64_t v68 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
    int v70 = 136446210;
    uint64_t v71 = "tcp_sack_doack";
    int v69 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v69);
  }

  else if (v11 < 1)
  {
    goto LABEL_33;
  }

  uint64_t v20 = 0LL;
  int v21 = v73;
  uint64_t v22 = 1LL;
  do
  {
    uint64_t v23 = v20 + 1;
    if (v20 + 1 < (unint64_t)v11)
    {
      int v24 = &v72[2 * v20];
      unsigned int v25 = v21;
      uint64_t v26 = v11;
      do
      {
        int v27 = v24[1];
        if (v27 - *v25 >= 1)
        {
          int v28 = *v24;
          *(void *)int v24 = *(void *)(v25 - 1);
          *(v25 - 1) = v28;
          *unsigned int v25 = v27;
        }

        --v26;
        v25 += 2;
      }

      while (v22 != v26);
    }

    ++v22;
    v21 += 8;
    uint64_t v20 = v23;
  }

  while (v23 != v11);
  int v10 = *(_DWORD *)(a1 + 740);
LABEL_33:
  if ((v10 & 0x20400020) == 0x20000020)
  {
    __int16 v29 = &v72[2 * v11 - 2];
    *a5 = v29[1];
    if (v11 >= 1)
    {
      do
      {
        unint64_t v30 = *(void *)(a1 + 2000);
        if (!v30) {
          goto LABEL_37;
        }
        int v32 = *v29;
        int v31 = v29[1];
        uint64_t v33 = *(void *)(a1 + 2000);
        do
        {
          while (1)
          {
            int v34 = *(_DWORD *)(v33 + 4);
            if (v31 - v34 >= 0) {
              break;
            }
            uint64_t v33 = *(void *)(v33 + 32);
            if (!v33) {
              goto LABEL_44;
            }
          }

          if (v31 == v34)
          {
            tcp_segs_dosack_matched(a1, (int *)v33, *v29, v9, a4);
            goto LABEL_37;
          }

          uint64_t v33 = *(void *)(v33 + 40);
        }

        while (v33);
        do
        {
LABEL_44:
          unint64_t v35 = v30;
          unint64_t v30 = *(void *)(v30 + 32);
        }

        while (v30);
        do
        {
          while (1)
          {
LABEL_53:
            unint64_t v38 = v35;
            if (v31 - *(_DWORD *)(v35 + 4) < 0 && v31 - *(_DWORD *)v35 >= 1)
            {
              if (v32 - *(_DWORD *)v35 >= 1) {
                int v39 = *v29;
              }
              else {
                int v39 = *(_DWORD *)v35;
              }
              unsigned int v40 = tcp_seg_sent_insert_before(a1, v35, v39, v29[1], *(_DWORD *)(v35 + 8), *(_BYTE *)(v35 + 12));
              unsigned int v41 = *((unsigned __int8 *)v40 + 12);
              tcp_seg_mark_sacked((_DWORD *)a1, (uint64_t)v40, a4);
              tcp_rack_update_segment_acked(a1, v9, *((_DWORD *)v40 + 2), *((_DWORD *)v40 + 1), (v41 >> 3) & 1);
              int v42 = *(_DWORD *)v38;
              if (v32 != *(_DWORD *)v38)
              {
                if (v32 - *(_DWORD *)v38 >= 1)
                {
                  tcp_seg_sent_insert_before(a1, (uint64_t)v40, v42, v32, *(_DWORD *)(v38 + 8), *(_BYTE *)(v38 + 12));
                  *(_DWORD *)unint64_t v38 = v31;
                  goto LABEL_37;
                }

                uint64_t v43 = *(void *)(a1 + 2000);
                if (v43)
                {
                  while (1)
                  {
                    while (1)
                    {
                      int v44 = *(_DWORD *)(v43 + 4);
                      if (v42 - v44 >= 0) {
                        break;
                      }
                      uint64_t v43 = *(void *)(v43 + 32);
                      if (!v43) {
                        goto LABEL_59;
                      }
                    }

                    if (v42 == v44) {
                      break;
                    }
                    uint64_t v43 = *(void *)(v43 + 40);
                    if (!v43) {
                      goto LABEL_59;
                    }
                  }

                  tcp_segs_dosack_matched(a1, (int *)v43, v32, v9, a4);
                }
              }

_DWORD *tcp_sackhole_insert(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (*(_DWORD *)(sysctls + 140) <= *(__int16 *)(a1 + 538) || tcp_sack_globalholes >= *(_DWORD *)(sysctls + 144))
  {
    uint64_t v16 = *(void *)(a1 + 1056);
    int v10 = 0LL;
    if (v16) {
      ++*(void *)(v16 + 608);
    }
  }

  else
  {
    uint64_t v8 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
    int v9 = malloc(**(void **)(v8 + 40));
    int v10 = v9;
    if (v9)
    {
      *int v9 = a2;
      v9[1] = a3;
      void v9[2] = a2;
      ++*(_WORD *)(a1 + 538);
      do
        unsigned int v11 = __ldxr((unsigned int *)&tcp_sack_globalholes);
      while (__stxr(v11 + 1, (unsigned int *)&tcp_sack_globalholes));
      v9[3] = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
      if (a4)
      {
        uint64_t v13 = *(void *)(a4 + 16);
        uint64_t v12 = (void *)(a4 + 16);
        *((void *)v10 + 2) = v13;
        int8x8_t v14 = (void *)(v13 + 24);
        if (v13) {
          int v15 = v14;
        }
        else {
          int v15 = (void *)(a1 + 552);
        }
        *int v15 = v10 + 4;
        *uint64_t v12 = v10;
        *((void *)v10 + 3) = v12;
        if (!*(void *)(a1 + 616)) {
          goto LABEL_16;
        }
      }

      else
      {
        *((void *)v10 + 2) = 0LL;
        int v18 = *(void **)(a1 + 552);
        *((void *)v10 + 3) = v18;
        *int v18 = v10;
        *(void *)(a1 + 552) = v10 + 4;
        if (!*(void *)(a1 + 616)) {
LABEL_16:
        }
          *(void *)(a1 + 616) = v10;
      }
    }
  }

  return v10;
}

void tcp_sack_detect_reordering(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  if (a2[1] - a4 > 0) {
    return;
  }
  if (*(_WORD *)(a1 + 226)) {
    return;
  }
  int v6 = a2[2];
  if (v6 - a3 >= 0) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 952);
  if (v8)
  {
    int v9 = a3 - 1;
    do
    {
      if (*(_DWORD *)v8 - v9 > 0) {
        break;
      }
      if (*(_DWORD *)(v8 + 4) - v9 >= 0) {
        return;
      }
      uint64_t v8 = *(void *)(v8 + 16);
    }

    while (v8);
  }

  int v10 = *(void **)(a1 + 1056);
  if (v10)
  {
    ++v10[124];
    int v11 = *(_DWORD *)(a1 + 740);
    if ((v11 & 0x2000) == 0)
    {
      *(_DWORD *)(a1 + 740) = v11 | 0x2000;
      ++v10[121];
    }

    ++v10[122];
  }

  else
  {
    int v12 = *(_DWORD *)(a1 + 740);
    if ((v12 & 0x2000) == 0) {
      *(_DWORD *)(a1 + 740) = v12 | 0x2000;
    }
  }

  ++*(_DWORD *)(a1 + 1016);
  if ((~*(_DWORD *)(a1 + 348) & 3) == 0)
  {
    uint64_t v13 = *(void *)(a1 + 80);
    uint64_t v14 = *(void *)(v13 + 448);
    if (v14)
    {
      BOOL v15 = (*(_BYTE *)(v13 + 2236) & 2) == 0;
      uint64_t v16 = 632LL;
      if (v15) {
        uint64_t v16 = 248LL;
      }
      ++*(void *)(v14 + v16);
    }

    if (v10) {
      ++v10[117];
    }
    tcp_heuristic_ecn_aggressive(a1);
    int v6 = a2[2];
  }

  if (a4 - v6 >= 0)
  {
    if (!a2[3]) {
      return;
    }
    goto LABEL_26;
  }

  BOOL v19 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  uint64_t v20 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }

  free(v20);
  if (a2[3])
  {
LABEL_26:
    int v17 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316) - a2[3];
    if (v17 >= 0)
    {
      int v18 = *(_DWORD *)(a1 + 200);
      *(_WORD *)(a1 + 536) = v17;
    }
  }

double tcp_free_sackholes(uint64_t a1)
{
  for (uint64_t i = *(void **)(a1 + 544); i; uint64_t i = *(void **)(a1 + 544))
  {
    uint64_t v3 = i[2];
    if (*(void **)(a1 + 616) == i)
    {
      *(void *)(a1 + 616) = v3;
      uint64_t v4 = (void *)i[3];
      if (v3)
      {
LABEL_4:
        *(void *)(v3 + 24) = v4;
        uint64_t v4 = (void *)i[3];
        goto LABEL_7;
      }
    }

    else
    {
      uint64_t v4 = (void *)i[3];
      if (v3) {
        goto LABEL_4;
      }
    }

    *(void *)(a1 + 552) = v4;
LABEL_7:
    *uint64_t v4 = v3;
    nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
    free(i);
    --*(_WORD *)(a1 + 538);
    do
      unsigned int v5 = __ldxr((unsigned int *)&tcp_sack_globalholes);
    while (__stxr(v5 - 1, (unsigned int *)&tcp_sack_globalholes));
  }

  double result = 0.0;
  *(_OWORD *)(a1 + 616) = 0u;
  return result;
}

uint64_t tcp_sack_partialack(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  int v5 = *(_DWORD *)(a2 + 8);
  if (v4 - v5 < 0) {
    *(_DWORD *)(a1 + 100) = v5;
  }
  char v6 = (v5 - *(_DWORD *)(a1 + 92)) / *(_DWORD *)(a1 + 196) > 2;
  unsigned int v7 = (*(_DWORD *)(a1 + 196) << v6) + tcp_flight_size((_DWORD *)a1);
  int v8 = *(_DWORD *)(a1 + 152);
  if (v7 >= *(_DWORD *)(a1 + 148)) {
    unsigned int v7 = *(_DWORD *)(a1 + 148);
  }
  *(_DWORD *)(a1 + 144) = v7;
  int v9 = *(_DWORD *)(a1 + 560);
  if (v9 - v8 < 0 && v9 == *(_DWORD *)(a2 + 8) && !*(void *)(a1 + 544) && tcp_sackhole_insert(a1, v9, v8, 0LL)) {
    *(_DWORD *)(a1 + 560) = *(_DWORD *)(a1 + 152);
  }
  uint64_t result = tcp_output(a1);
  int v11 = *(_DWORD *)(a1 + 100);
  if ((*(_BYTE *)(a1 + 88) & 0x10) == 0)
  {
    if (v4 - v11 < 1) {
      return result;
    }
LABEL_15:
    *(_DWORD *)(a1 + 100) = v4;
    return result;
  }

  if (v11 != *(_DWORD *)(a1 + 96) - 1 && v4 - v11 > 0) {
    goto LABEL_15;
  }
  return result;
}

uint64_t tcp_sack_process_dsack(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  char v6 = *(unsigned int **)(a2 + 16);
  unsigned int v7 = bswap32(*v6);
  unsigned int v8 = *(unsigned __int8 *)(a2 + 15);
  if (v8 >= 2)
  {
    unsigned int v5 = bswap32(v6[2]);
    unsigned int v4 = bswap32(v6[3]);
  }

  unsigned int v9 = bswap32(v6[1]);
  int v10 = *(_DWORD *)(a3 + 8);
  if (((v7 - v10) & 0x80000000) != 0 && (int)(v9 - v10) <= 0)
  {
    int v11 = *(_DWORD *)(a1 + 96);
    unsigned int v12 = *(_DWORD *)(a1 + 140);
    if (v12 >= *(_DWORD *)(sysctls + 120)) {
      unsigned int v12 = *(_DWORD *)(sysctls + 120);
    }
    int v13 = v12 - v10;
    goto LABEL_24;
  }

  uint64_t v14 = 0LL;
  BOOL v15 = v8 >= 2 && (int)(v5 - v7) <= 0;
  if (v15 && ((v4 - v9) & 0x80000000) == 0)
  {
    if ((int)(v4 - v5) < 1
      || (int)(v5 - v10) < 1
      || (int v16 = *(_DWORD *)(a1 + 92), (int)(v5 - v16) < 1)
      || (int v17 = *(_DWORD *)(a1 + 96), ((v5 - v17) & 0x80000000) == 0)
      || (int)(v4 - v16) < 1
      || (int)(v4 - v17) >= 1)
    {
LABEL_45:
      *(_BYTE *)(a2 + 15) = v8 - 1;
      *(void *)(a2 + 16) = v6 + 2;
      uint64_t v24 = *(void *)(a1 + 1056);
      if (v24) {
        ++*(void *)(v24 + 1048);
      }
      return 1LL;
    }

uint64_t tcp_cc_delay_ack(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(sysctls + 36);
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      if (*(_DWORD *)(sysctls + 288))
      {
        unsigned int v5 = tcp_sbspace(a1);
        unsigned int v6 = 0xFFFF << *(_BYTE *)(a1 + 261);
        if (v5 < v6) {
          unsigned int v6 = v5;
        }
        if ((*(_BYTE *)(a1 + 90) & 4) != 0
          || *(_WORD *)(a1 + 308)
          || *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 488LL) <= *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224LL)
                                                                                         + 496LL)
          || v6 > *(_DWORD *)(a1 + 132))
        {
          return 0LL;
        }

        unsigned int v7 = *(_DWORD *)(a1 + 120) - *(_DWORD *)(a1 + 284);
        unsigned int v8 = *(_DWORD *)(a1 + 196);
        if (v7 <= v8)
        {
          if (v7 >= v6 >> 2) {
            return 0LL;
          }
        }

        else if (v7 >= v6 >> 2 || v6 <= *(_DWORD *)(sysctls + 236) + (*(int *)(sysctls + 236) >> 1))
        {
          return 0LL;
        }

        if (v7 < v8 << 8)
        {
          ++*(_DWORD *)(a1 + 728);
          return 1LL;
        }
      }

      else
      {
        int v9 = *(_DWORD *)(a1 + 88);
        if ((v9 & 0x40000) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0)
        {
          int v10 = *(unsigned __int16 *)(a1 + 304);
          if (v10 == 1 || v9 < 0 && *(_DWORD *)(sysctls + 52) > v10) {
            return 1LL;
          }
        }
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 90) & 4) == 0 && (*(_BYTE *)(a2 + 13) & 8) == 0 && *(_WORD *)(a1 + 304) == 1)
  {
    return 1LL;
  }

  return 0LL;
}

uint64_t tcp_cc_adjust_nonvalidated_cwnd(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 964);
  if (v1 <= *(_DWORD *)(result + 968)) {
    unsigned int v1 = *(_DWORD *)(result + 968);
  }
  if (*(_DWORD *)(result + 972) > v1) {
    unsigned int v1 = *(_DWORD *)(result + 972);
  }
  *(_DWORD *)(result + 980) = v1;
  *(void *)(result + 964) = 0LL;
  *(_DWORD *)(result + 972) = 0;
  *(_BYTE *)(result + 751) = 0;
  *(_DWORD *)(result + 984) = 0;
  unsigned int v2 = v1 >> 1;
  if (*(_DWORD *)(sysctls + 276))
  {
    unsigned int v3 = *(_DWORD *)(result + 196);
    if (v2 <= v3) {
      unsigned int v2 = *(_DWORD *)(result + 196);
    }
  }

  else
  {
    if (v1 <= 0x2239) {
      unsigned int v2 = 4380;
    }
    unsigned int v3 = *(_DWORD *)(result + 196);
  }

  *(_DWORD *)(result + 144) = 3 * v3 + v2;
  *(_DWORD *)(result + 740) &= ~0x100000u;
  return result;
}

uint64_t tcp_lock(uint64_t *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v3 = *((_DWORD *)a1 + 90);
  if (v3 < 0)
  {
    if ((*((_BYTE *)a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v5 = *a1;
      int v6 = *((_DWORD *)a1 + 90);
      *(_DWORD *)__int128 buf = 136447490;
      unsigned int v12 = "tcp_lock";
      __int16 v13 = 2082;
      uint64_t v14 = (uint64_t)a1 + 604;
      __int16 v15 = 2048;
      int v16 = a1;
      __int16 v17 = 2048;
      uint64_t v18 = v5;
      __int16 v19 = 1024;
      int v20 = v6;
      __int16 v21 = 2080;
      unsigned int v22 = "";
      unsigned int v7 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v9 = *a1;
          int v10 = *((_DWORD *)a1 + 90);
          *(_DWORD *)__int128 buf = 136447490;
          unsigned int v12 = "tcp_lock";
          __int16 v13 = 2082;
          uint64_t v14 = (uint64_t)a1 + 604;
          __int16 v15 = 2048;
          int v16 = a1;
          __int16 v17 = 2048;
          uint64_t v18 = v9;
          __int16 v19 = 1024;
          int v20 = v10;
          __int16 v21 = 2080;
          unsigned int v22 = "";
          _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s tcp_lock: so=%p so_pcb=%p ref=%x lrh= %s, backtrace limit exceeded",  buf,  0x3Au);
        }
      }

      if (v7) {
        free(v7);
      }
    }

    return 22LL;
  }

  else
  {
    uint64_t result = 0LL;
    if (a2) {
      *((_DWORD *)a1 + 90) = v3 + 1;
    }
  }

  return result;
}

uint64_t tcp_unlock(uint64_t a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  int v3 = *(_DWORD *)(a1 + 360);
  if (a2) {
    *(_DWORD *)(a1 + 360) = --v3;
  }
  if (v3 < 0)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v5 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v5;
      __int16 v20 = 2080;
      __int16 v21 = "";
      int v6 = (void *)_os_log_send_and_compose_impl();
      unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      int v9 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v9;
      __int16 v20 = 2080;
      __int16 v21 = "";
      int v10 = "%{public}s %{public}s tcp_unlock: so=%p usecount=%x lrh= %s, backtrace limit exceeded";
      goto LABEL_16;
    }
  }

  else
  {
    if (*(void *)a1) {
      return 0LL;
    }
    if ((*(_BYTE *)(a1 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v7 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v7;
      __int16 v20 = 2080;
      __int16 v21 = "";
      int v6 = (void *)_os_log_send_and_compose_impl();
      unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_17;
      }
      int v11 = *(_DWORD *)(a1 + 360);
      *(_DWORD *)__int128 buf = 136447234;
      __int16 v13 = "tcp_unlock";
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v11;
      __int16 v20 = 2080;
      __int16 v21 = "";
      int v10 = "%{public}s %{public}s tcp_unlock: so=%p NO PCB usecount=%x lrh= %s, backtrace limit exceeded";
LABEL_16:
      _os_log_impl(&dword_1879E5000, v8, OS_LOG_TYPE_ERROR, v10, buf, 0x30u);
LABEL_17:
      if (v6) {
        free(v6);
      }
    }
  }

  return 22LL;
}

uint64_t soisconnected(uint64_t result)
{
  unsigned int v2 = (void *)result;
  uint64_t v3 = *(void *)(result + 296);
  __int16 v4 = *(_WORD *)(result + 376);
  __int16 v5 = v4 & 0xFBF1 | 2;
  *(_WORD *)(result + 376) = v5;
  *(_DWORD *)(result + 484) = 0;
  *(_DWORD *)(result + 588) = 0;
  int v6 = v4 & 0x800;
  if (v3) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    uint64_t v8 = *(void *)(result + 32);
    if (v8)
    {
      int v9 = *(uint64_t (**)(uint64_t))(v8 + 24);
      if (!v9 || (result = v9(result), (uint64_t v8 = v2[4]) != 0))
      {
        if (*(void *)v8) {
          return (*(uint64_t (**)(void *))v8)(v2);
        }
      }
    }
  }

  else
  {
    *(_WORD *)(result + 376) = v5 & 0xE3F3 | 0x1000;
    if (*(void *)(*(void *)(v3 + 8) + 32LL))
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)(result + 8) + 24LL))(result, 0LL, v1);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16LL))(v3, 1LL, v1);
    }

    uint64_t v10 = v2[42];
    int v11 = (void *)v2[43];
    if (v10)
    {
      *(void *)(v10 + 344) = v11;
      int v11 = (void *)v2[43];
    }

    else
    {
      *(void *)(v3 + 312) = v11;
    }

    *int v11 = v10;
    --*(_WORD *)(v3 + 356);
    unsigned int v12 = *(void **)(v3 + 328);
    v2[42] = 0LL;
    v2[43] = v12;
    *unsigned int v12 = v2;
    *(void *)(v3 + 328) = v2 + 42;
    uint64_t v13 = *(void *)(v3 + 32);
    if (v13)
    {
      __int16 v14 = *(uint64_t (**)(uint64_t))(v13 + 24);
      if (!v14 || (uint64_t result = v14(v3), (v13 = *(void *)(v3 + 32)) != 0))
      {
        uint64_t v15 = *(uint64_t (**)(uint64_t))(v13 + 48);
        if (v15) {
          uint64_t result = v15(v3);
        }
      }
    }

    uint64_t v16 = *(void *)(v3 + 8);
    if (*(void *)(v16 + 32))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, 1LL, v1);
      return (*(uint64_t (**)(void *, void, uint64_t))(v2[1] + 16LL))(v2, 0LL, v1);
    }
  }

  return result;
}

uint64_t sbappendstream(int *a1, uint64_t *a2, int a3, char a4)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0LL;
  }
  int v6 = a1[12];
  if ((v6 & 0x80) != 0)
  {
    uint64_t result = *a2;
    if (*a2)
    {
      do
      {
        unsigned int v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(result + 80);
        uint64_t v13 = *(void *)(result + 32);
        if (v12)
        {
          uint64_t v14 = *(void *)(result + 88);
          *(void *)(result + 80) = 0LL;
          *(void *)(result + 88) = 0LL;
          v12(result, 1LL, v14);
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v38 = "__nw_frame_finalize";
          unint64_t v36 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            unint64_t v35 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              unint64_t v38 = "__nw_frame_finalize";
              _os_log_impl( &dword_1879E5000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v36) {
            free(v36);
          }
        }

        uint64_t result = v13;
      }

      while (v13);
    }

    return result;
  }

  *a1 += a3;
  uint64_t v9 = *(void *)(*((void *)a1 + 9) + 24LL);
  if ((v6 & 4) != 0)
  {
    if (v9)
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 92) = *a1;
      }
    }
  }

  else if (v9)
  {
    uint64_t v10 = nw_protocol_tcp_get_all_stats();
    if (v10) {
      *(_DWORD *)(v10 + 104) = *a1;
    }
  }

  if ((a4 & 2) != 0)
  {
    if (*a2)
    {
      int v16 = 0;
      int v17 = 0;
      uint64_t v18 = *a2;
      do
      {
        int v19 = *(_DWORD *)(v18 + 52);
        if (v19) {
          v19 -= *(_DWORD *)(v18 + 56) + *(_DWORD *)(v18 + 60);
        }
        v16 += v19;
        ++v17;
        uint64_t v18 = *(void *)(v18 + 32);
      }

      while (v18);
      **((void **)a1 + 5) = *a2;
      *(void *)(*a2 + 40) = *((void *)a1 + 5);
      *((void *)a1 + 5) = a2[1];
      *a2 = 0LL;
      a2[1] = (uint64_t)a2;
      if (v16 == a3) {
        goto LABEL_30;
      }
    }

    else
    {
      int v16 = 0;
      int v17 = 0;
      if (!a3)
      {
LABEL_30:
        int v20 = a1[16] + a3;
        a1[15] += v17;
        a1[16] = v20;
        uint64_t v21 = *((void *)a1 + 9);
        if (v21 && (*(_BYTE *)(v21 + 828) & 2) != 0) {
          return 1LL;
        }
        uint64_t v22 = (os_log_s *)__nwlog_tcp_log();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          return 1LL;
        }
        uint64_t v23 = (const char *)(v21 + 604);
        int v24 = a1[16];
        int v25 = *a1;
        if (!v21) {
          uint64_t v23 = "";
        }
        *(_DWORD *)__int128 buf = 136447490;
        unint64_t v38 = "sbcompress";
        __int16 v39 = 2082;
        *(void *)unsigned int v40 = v23;
        *(_WORD *)&v40[8] = 1024;
        int v41 = v17;
        __int16 v42 = 1024;
        int v43 = a3;
        __int16 v44 = 1024;
        int v45 = v24;
        __int16 v46 = 1024;
        int v47 = v25;
        uint64_t v26 = "%{public}s %{public}s append to aggregate frame count %u length %u sb_agg_bytes %u sb_cc %u";
        goto LABEL_58;
      }
    }

    int v31 = (os_log_s *)__nwlog_obj();
    uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result) {
      goto LABEL_53;
    }
    return result;
  }

  if (*((void *)a1 + 4)
    && tcp_input_aggregate_end( *(void *)(**((void **)a1 + 9) + 224LL),  *(void *)(**((void **)a1 + 9) + 240LL)))
  {
    return 0LL;
  }

  if (*a2)
  {
    int v16 = 0;
    int v27 = 0;
    uint64_t v28 = *a2;
    do
    {
      int v29 = *(_DWORD *)(v28 + 52);
      if (v29) {
        v29 -= *(_DWORD *)(v28 + 56) + *(_DWORD *)(v28 + 60);
      }
      v16 += v29;
      ++v27;
      uint64_t v28 = *(void *)(v28 + 32);
    }

    while (v28);
    **((void **)a1 + 3) = *a2;
    *(void *)(*a2 + 40) = *((void *)a1 + 3);
    *((void *)a1 + 3) = a2[1];
    *a2 = 0LL;
    a2[1] = (uint64_t)a2;
    if (v16 == a3) {
      goto LABEL_43;
    }
  }

  else
  {
    int v16 = 0;
    int v27 = 0;
    if (!a3)
    {
LABEL_43:
      uint64_t v30 = *((void *)a1 + 9);
      if (v30 && (*(_BYTE *)(v30 + 828) & 2) != 0) {
        return 1LL;
      }
      uint64_t v22 = (os_log_s *)__nwlog_tcp_log();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        return 1LL;
      }
      int v32 = (const char *)(v30 + 604);
      int v33 = a1[16];
      int v34 = *a1;
      if (!v30) {
        int v32 = "";
      }
      *(_DWORD *)__int128 buf = 136447490;
      unint64_t v38 = "sbcompress";
      __int16 v39 = 2082;
      *(void *)unsigned int v40 = v32;
      *(_WORD *)&v40[8] = 1024;
      int v41 = v27;
      __int16 v42 = 1024;
      int v43 = a3;
      __int16 v44 = 1024;
      int v45 = v33;
      __int16 v46 = 1024;
      int v47 = v34;
      uint64_t v26 = "%{public}s %{public}s append frame count %u length %u sb_agg_bytes %u sb_cc %u";
LABEL_58:
      _os_log_impl(&dword_1879E5000, v22, OS_LOG_TYPE_DEBUG, v26, buf, 0x2Eu);
      return 1LL;
    }
  }

  int v31 = (os_log_s *)__nwlog_obj();
  uint64_t result = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
LABEL_53:
    *(_DWORD *)__int128 buf = 136446722;
    unint64_t v38 = "sbcompress";
    __int16 v39 = 1024;
    *(_DWORD *)unsigned int v40 = a3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = v16;
    _os_log_impl(&dword_1879E5000, v31, OS_LOG_TYPE_ERROR, "%{public}s len_added %u != len_to_add %u", buf, 0x18u);
    return 0LL;
  }

  return result;
}

uint64_t soabort(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 364);
  if ((v1 & 0x100) == 0)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 364) = v1 | 0x100;
    uint64_t result = (**(uint64_t (***)(void))(*(void *)(result + 8) + 40LL))();
    if ((_DWORD)result)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        __int16 v4 = *(void (**)(uint64_t, void))(v3 + 32);
        if (v4) {
          v4(v2, 0LL);
        }
      }

      return sofreelastref(v2);
    }
  }

  return result;
}

uint64_t sofreelastref(uint64_t result)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(result + 364) & 4) != 0)
  {
    uint64_t v2 = result;
    if ((*(_WORD *)(result + 376) & 1) != 0)
    {
      uint64_t v3 = *(void *)(result + 296);
      if (v3)
      {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)(v3 + 8) + 16LL))( *(void *)(result + 296),  1LL,  v1);
        __int16 v4 = *(_WORD *)(v2 + 376);
        if ((v4 & 0x800) != 0)
        {
          uint64_t v6 = *(void *)(v2 + 336);
          BOOL v7 = *(void **)(v2 + 344);
          if (v6)
          {
            *(void *)(v6 + 344) = v7;
            BOOL v7 = *(void **)(v2 + 344);
          }

          else
          {
            *(void *)(v3 + 312) = v7;
          }

          *BOOL v7 = v6;
          --*(_WORD *)(v3 + 356);
        }

        else
        {
          if ((*(_WORD *)(v2 + 376) & 0x1000) != 0) {
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24LL))(v3, 1LL, v1);
          }
          if ((*(_BYTE *)(v2 + 828) & 2) == 0)
          {
            __nwlog_tcp_log();
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v13 = "sofreelastref";
            __int16 v14 = 2082;
            uint64_t v15 = v2 + 604;
            __int16 v5 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_fault())
            {
              uint64_t v8 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 136446466;
                uint64_t v13 = "sofreelastref";
                __int16 v14 = 2082;
                uint64_t v15 = v2 + 604;
                _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s sofree: not queued, backtrace limit exceeded",  buf,  0x16u);
              }
            }

            if (v5) {
              free(v5);
            }
            __int16 v4 = *(_WORD *)(v2 + 376);
          }
        }

        --*(_WORD *)(v3 + 352);
        *(_WORD *)(v2 + 376) = v4 & 0xF7FF;
        *(void *)(v2 + 296) = 0LL;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 + 8) + 24LL))(v3, 1LL, v1);
      }

      sblock(v2 + 384);
      *(_DWORD *)(v2 + 432) |= 0x80u;
      sbunlock(v2 + 384);
      sbflush(v2 + 384);
      *(_DWORD *)(v2 + 388) = 0;
      uint64_t v9 = *(void *)(*(void *)(v2 + 456) + 24LL);
      if ((*(_BYTE *)(v2 + 432) & 4) != 0)
      {
        if (v9)
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v2 + 388);
          }
        }
      }

      else if (v9)
      {
        uint64_t v10 = nw_protocol_tcp_get_all_stats();
        if (v10) {
          *(_DWORD *)(v10 + 100) = *(_DWORD *)(v2 + 388);
        }
      }

      return sorflush(v2);
    }
  }

  return result;
}

void sblock(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) == 0)
  {
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0)
    {
LABEL_18:
      *(_DWORD *)(a1 + 48) = v3 | 1;
      return;
    }

    while (1)
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)(v2 + 8) + 32LL))(v2, 0LL);
      int v5 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 56) = v5 + 1;
      if (v5 == -1)
      {
        uint64_t v9 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446210;
        int v20 = "sblock";
        uint64_t v18 = (void *)_os_log_send_and_compose_impl();
        free(v18);
      }

      uint64_t v6 = *(void *)(v2 + 32);
      if ((*(_BYTE *)(a1 + 48) & 4) != 0)
      {
        if (v6)
        {
          BOOL v7 = *(void (**)(uint64_t, uint64_t, void))(v6 + 104);
          if (v7) {
LABEL_10:
          }
            v7(v2, v4, 0LL);
        }
      }

      else if (v6)
      {
        BOOL v7 = *(void (**)(uint64_t, uint64_t, void))(v6 + 96);
        if (v7) {
          goto LABEL_10;
        }
      }

      int v8 = *(_DWORD *)(a1 + 56);
      if (!v8)
      {
        uint64_t v10 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        *(_DWORD *)__int128 buf = 136446210;
        int v20 = "sblock";
        int v11 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort())
        {
LABEL_26:
          __break(1u);
          return;
        }

        free(v11);
        int v8 = *(_DWORD *)(a1 + 56);
      }

      *(_DWORD *)(a1 + 56) = v8 - 1;
      int v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 1) == 0) {
        goto LABEL_18;
      }
    }
  }

  if ((*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    int v12 = *(_DWORD *)(a1 + 48);
    int v13 = *(_DWORD *)(v2 + 360);
    *(_DWORD *)__int128 buf = 136447490;
    int v20 = "sblock";
    __int16 v21 = 2082;
    uint64_t v22 = v2 + 604;
    __int16 v23 = 2048;
    uint64_t v24 = a1;
    __int16 v25 = 1024;
    int v26 = v12;
    __int16 v27 = 2048;
    uint64_t v28 = v2;
    __int16 v29 = 1024;
    int v30 = v13;
    __int16 v14 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v15 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v16 = *(_DWORD *)(a1 + 48);
        int v17 = *(_DWORD *)(v2 + 360);
        *(_DWORD *)__int128 buf = 136447490;
        int v20 = "sblock";
        __int16 v21 = 2082;
        uint64_t v22 = v2 + 604;
        __int16 v23 = 2048;
        uint64_t v24 = a1;
        __int16 v25 = 1024;
        int v26 = v16;
        __int16 v27 = 2048;
        uint64_t v28 = v2;
        __int16 v29 = 1024;
        int v30 = v17;
        _os_log_impl( &dword_1879E5000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded",  buf,  0x36u);
      }
    }

    if (v14) {
      free(v14);
    }
  }

void sbunlock(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 72);
  if ((*(_DWORD *)(v2 + 360) & 0x80000000) != 0)
  {
    if ((*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v6 = *(_DWORD *)(a1 + 48);
      int v7 = *(_DWORD *)(v2 + 360);
      *(_DWORD *)__int128 buf = 136447490;
      uint64_t v15 = "sbunlock";
      __int16 v16 = 2082;
      uint64_t v17 = v2 + 604;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      __int16 v20 = 1024;
      int v21 = v6;
      __int16 v22 = 2048;
      uint64_t v23 = v2;
      __int16 v24 = 1024;
      int v25 = v7;
      int v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v9 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          int v10 = *(_DWORD *)(a1 + 48);
          int v11 = *(_DWORD *)(v2 + 360);
          *(_DWORD *)__int128 buf = 136447490;
          uint64_t v15 = "sbunlock";
          __int16 v16 = 2082;
          uint64_t v17 = v2 + 604;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          int v21 = v10;
          __int16 v22 = 2048;
          uint64_t v23 = v2;
          __int16 v24 = 1024;
          int v25 = v11;
          _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s sb=%p sb_flags=0x%x sb_so=%p usecount=%d, backtrace limit exceeded",  buf,  0x36u);
        }
      }

      if (v8) {
        free(v8);
      }
    }
  }

  else
  {
    int v3 = *(_DWORD *)(a1 + 48);
    if ((v3 & 1) == 0 && (*(__int16 *)(v2 + 376) & 0x80000000) == 0 && (*(_BYTE *)(v2 + 368) & 8) == 0)
    {
      int v12 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = "sbunlock";
      int v13 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort())
      {
        __break(1u);
        return;
      }

      free(v13);
      int v3 = *(_DWORD *)(a1 + 48);
    }

    *(_DWORD *)(a1 + 48) = v3 & 0xFFFFFFFE;
    if (*(_DWORD *)(a1 + 56))
    {
      uint64_t v4 = *(void *)(v2 + 32);
      if ((v3 & 4) == 0)
      {
        if (!v4) {
          return;
        }
        int v5 = *(void (**)(uint64_t))(v4 + 8);
        if (!v5) {
          return;
        }
LABEL_15:
        v5(v2);
        return;
      }

      if (v4)
      {
        int v5 = *(void (**)(uint64_t))(v4 + 32);
        if (v5) {
          goto LABEL_15;
        }
      }
    }
  }

void sbflush(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 72);
  sblock(a1);
  if (*(void *)(a1 + 32))
  {
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        __int16 v16 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = "";
          if (v2) {
            uint64_t v17 = (const char *)(v2 + 604);
          }
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v22 = "sbflush";
          __int16 v23 = 2082;
          __int16 v24 = v17;
          _os_log_impl( &dword_1879E5000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s sb_mb_aggregate not empty",  buf,  0x16u);
        }
      }
    }

    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      *(void *)&__int128 v3 = 136446210LL;
      do
      {
        uint64_t v7 = *(void *)(v4 + 32);
        int v8 = *(void **)(v4 + 40);
        uint64_t v9 = (void *)(v4 + 32);
        if (v7)
        {
          *(void *)(v7 + 40) = v8;
          int v8 = *(void **)(v4 + 40);
        }

        else
        {
          *(void *)(a1 + 40) = v8;
        }

        *int v8 = v7;
        *uint64_t v9 = 0LL;
        *(void *)(v4 + 40) = 0LL;
        int v10 = *(_DWORD *)(a1 + 60);
        if (!v10)
        {
          __int128 v20 = v3;
          __int16 v14 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = v20;
          __int16 v22 = "sbflush";
          uint64_t v15 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort())
          {
LABEL_27:
            __break(1u);
            return;
          }

          free(v15);
          int v10 = *(_DWORD *)(a1 + 60);
          __int128 v3 = v20;
        }

        *(_DWORD *)(a1 + 60) = v10 - 1;
        int v11 = *(_DWORD *)(v4 + 52);
        unsigned int v12 = *(_DWORD *)(a1 + 64);
        if (v11)
        {
          unsigned int v5 = v11 - (*(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60));
          if (v12 < v5)
          {
            __int128 v19 = v3;
            int v13 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
            *(_DWORD *)__int128 buf = v19;
            __int16 v22 = "sbflush";
            __int16 v18 = (void *)_os_log_send_and_compose_impl();
            free(v18);
            unsigned int v12 = *(_DWORD *)(a1 + 64);
            __int128 v3 = v19;
          }
        }

        else
        {
          unsigned int v5 = 0;
        }

        *(_DWORD *)(a1 + 64) = v12 - v5;
        *(void *)(v4 + 32) = 0LL;
        int v6 = *(void **)(a1 + 24);
        *(void *)(v4 + 40) = v6;
        *int v6 = v4;
        *(void *)(a1 + 24) = v9;
        uint64_t v4 = *(void *)(a1 + 32);
      }

      while (v4);
    }

    sb_agg_empty_verify((int *)a1, (uint64_t)"sbflush");
  }

  if (nw_frame_array_first()) {
    sbdrop((int *)a1, *(_DWORD *)a1);
  }
  sb_empty_assert((int *)a1, (uint64_t)"sbflush");
  sbunlock(a1);
}

uint64_t sorflush(uint64_t a1)
{
  uint64_t v2 = a1 + 488;
  *(_WORD *)(a1 + 376) |= 0x20u;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void (**)(uint64_t))(v3 + 40);
    if (v4) {
      v4(a1);
    }
  }

  sblock(v2);
  *(_DWORD *)(a1 + 536) |= 0x80u;
  sbunlock(v2);
  sbflush(v2);
  *(_DWORD *)(a1 + 492) = 0;
  uint64_t result = *(void *)(*(void *)(a1 + 560) + 24LL);
  if ((*(_BYTE *)(a1 + 536) & 4) != 0)
  {
    if (result)
    {
      uint64_t result = nw_protocol_tcp_get_all_stats();
      if (result) {
        *(_DWORD *)(result + 88) = *(_DWORD *)(a1 + 492);
      }
    }
  }

  else if (result)
  {
    uint64_t result = nw_protocol_tcp_get_all_stats();
    if (result) {
      *(_DWORD *)(result + 100) = *(_DWORD *)(a1 + 492);
    }
  }

  return result;
}

void sb_agg_empty_verify(int *a1, uint64_t a2)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  if (a1[15])
  {
    if (!a1[16])
    {
      for (uint64_t i = *((void *)a1 + 4); i; uint64_t i = *((void *)a1 + 4))
      {
        int v19 = a1[15];
        if (!v19)
        {
          uint64_t v20 = *((void *)a1 + 9);
          if (v20 && (*(_BYTE *)(v20 + 828) & 2) != 0)
          {
            int v19 = 0;
          }

          else
          {
            int v21 = (os_log_s *)__nwlog_tcp_log();
            os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
            int v22 = a1[12];
            int v23 = *a1;
            __int16 v24 = (const char *)(v20 + 604);
            if (!v20) {
              __int16 v24 = "";
            }
            int v25 = a1[15];
            int v26 = a1[16];
            *(_DWORD *)__int128 buf = 136447746;
            int v54 = "sb_agg_empty_verify";
            __int16 v55 = 2082;
            int v56 = v24;
            __int16 v57 = 2082;
            uint64_t v58 = a2;
            __int16 v59 = 1024;
            int v60 = v22;
            __int16 v61 = 1024;
            int v62 = v23;
            __int16 v63 = 1024;
            int v64 = v25;
            __int16 v65 = 1024;
            int v66 = v26;
            __int16 v27 = (void *)_os_log_send_and_compose_impl();
            free(v27);
            int v19 = a1[15];
          }
        }

        a1[15] = v19 - 1;
        int v28 = *(_DWORD *)(i + 52);
        if (v28)
        {
          int v29 = *(_DWORD *)(i + 60) + *(_DWORD *)(i + 56);
          int v30 = v28 - v29;
          if (v28 != v29)
          {
            uint64_t v31 = *((void *)a1 + 9);
            if (!v31 || (*(_BYTE *)(v31 + 828) & 2) == 0)
            {
              int v32 = (os_log_s *)__nwlog_tcp_log();
              os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
              int v33 = a1[12];
              int v34 = *a1;
              unint64_t v35 = (const char *)(v31 + 604);
              if (!v31) {
                unint64_t v35 = "";
              }
              int v36 = a1[15];
              int v37 = a1[16];
              *(_DWORD *)__int128 buf = 136448002;
              int v54 = "sb_agg_empty_verify";
              __int16 v55 = 2082;
              int v56 = v35;
              __int16 v57 = 2082;
              uint64_t v58 = a2;
              __int16 v59 = 1024;
              int v60 = v30;
              __int16 v61 = 1024;
              int v62 = v33;
              __int16 v63 = 1024;
              int v64 = v34;
              __int16 v65 = 1024;
              int v66 = v36;
              __int16 v67 = 1024;
              LODWORD(v68) = v37;
              unint64_t v38 = (void *)_os_log_send_and_compose_impl();
              free(v38);
            }
          }
        }

        if (nw_frame_is_wake_packet())
        {
          uint64_t v39 = *((void *)a1 + 9);
          if (!v39 || (*(_BYTE *)(v39 + 828) & 2) == 0)
          {
            unsigned int v40 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
            {
              int v41 = (const char *)(v39 + 604);
              *(_DWORD *)__int128 buf = 136446466;
              if (!v39) {
                int v41 = "";
              }
              int v54 = "sb_agg_empty_verify";
              __int16 v55 = 2082;
              int v56 = v41;
              _os_log_impl( &dword_1879E5000,  v40,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s removing empty wake packet",  buf,  0x16u);
            }
          }
        }

        uint64_t v42 = *(void *)(i + 32);
        int v43 = *(void **)(i + 40);
        if (v42)
        {
          *(void *)(v42 + 40) = v43;
          int v43 = *(void **)(i + 40);
        }

        else
        {
          *((void *)a1 + 5) = v43;
        }

        *int v43 = v42;
        __int16 v44 = *(void (**)(uint64_t, uint64_t, uint64_t))(i + 80);
        *(void *)(i + 32) = 0LL;
        *(void *)(i + 40) = 0LL;
        if (v44)
        {
          uint64_t v45 = *(void *)(i + 88);
          *(void *)(i + 80) = 0LL;
          *(void *)(i + 88) = 0LL;
          v44(i, 1LL, v45);
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)__int128 buf = 136446210;
          int v54 = "__nw_frame_finalize";
          __int16 v46 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int v47 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              int v54 = "__nw_frame_finalize";
              _os_log_impl( &dword_1879E5000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
            }
          }

          if (v46) {
            free(v46);
          }
        }
      }
    }
  }

  if (a1[16])
  {
    uint64_t v4 = *((void *)a1 + 9);
    if ((~*(unsigned __int16 *)(v4 + 376) & 0x30) != 0)
    {
      if ((*(_BYTE *)(v4 + 828) & 2) != 0) {
        return;
      }
      int v11 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
      int v12 = a1[12];
      int v13 = *a1;
      int v14 = a1[15];
      int v15 = a1[16];
      *(_DWORD *)__int128 buf = 136447746;
      int v54 = "sb_agg_empty_verify";
      __int16 v55 = 2082;
      int v56 = (const char *)(v4 + 604);
      __int16 v57 = 2082;
      uint64_t v58 = a2;
      __int16 v59 = 1024;
      int v60 = v12;
      __int16 v61 = 1024;
      int v62 = v13;
      __int16 v63 = 1024;
      int v64 = v14;
      __int16 v65 = 1024;
      int v66 = v15;
      uint64_t v16 = _os_log_send_and_compose_impl();
      if (__nwlog_abort()) {
LABEL_54:
      }
        __break(1u);
      uint64_t v17 = (void *)v16;
      goto LABEL_52;
    }

    if ((*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      int v5 = a1[12];
      int v6 = (const char *)(v4 + 604);
      int v7 = *a1;
      int v8 = a1[15];
      int v9 = a1[16];
      *(_DWORD *)__int128 buf = 136447746;
      int v54 = "sb_agg_empty_verify";
      __int16 v55 = 2082;
      int v56 = (const char *)(v4 + 604);
      __int16 v57 = 2082;
      uint64_t v58 = a2;
      __int16 v59 = 1024;
      int v60 = v5;
      __int16 v61 = 1024;
      int v62 = v7;
      __int16 v63 = 1024;
      int v64 = v8;
      __int16 v65 = 1024;
      int v66 = v9;
      uint64_t v10 = _os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        uint64_t v48 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          int v49 = a1[12];
          int v50 = *a1;
          int v51 = a1[15];
          int v52 = a1[16];
          *(_DWORD *)__int128 buf = 136447746;
          int v54 = "sb_agg_empty_verify";
          __int16 v55 = 2082;
          int v56 = v6;
          __int16 v57 = 2082;
          uint64_t v58 = a2;
          __int16 v59 = 1024;
          int v60 = v49;
          __int16 v61 = 1024;
          int v62 = v50;
          __int16 v63 = 1024;
          int v64 = v51;
          __int16 v65 = 1024;
          int v66 = v52;
          _os_log_impl( &dword_1879E5000,  v48,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s %{public}s: sb flags 0x%x cc %d agg_cnt %u agg_bytes %u, backtrace limit exceeded",  buf,  0x38u);
        }
      }

      if (v10)
      {
        uint64_t v17 = (void *)v10;
LABEL_52:
        free(v17);
      }
    }
  }

void sbdrop(int *a1, int a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (*((void *)a1 + 4))
  {
    uint64_t v4 = *((void *)a1 + 9);
    if (tcp_perf_measurement)
    {
      if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
      {
        if (__nwlog_is_datapath_logging_enabled())
        {
          int v5 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            int v6 = "";
            if (v4) {
              int v6 = (const char *)(v4 + 604);
            }
            *(_DWORD *)__int128 buf = 136446466;
            int v36 = "sbdrop";
            __int16 v37 = 2082;
            *(void *)unint64_t v38 = v6;
            int v7 = v5;
            os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
LABEL_16:
            _os_log_impl(&dword_1879E5000, v7, v8, "%{public}s %{public}s sb_mb_aggregate not empty", buf, 0x16u);
          }
        }
      }
    }

    else if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      int v9 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = "";
        if (v4) {
          uint64_t v10 = (const char *)(v4 + 604);
        }
        *(_DWORD *)__int128 buf = 136446466;
        int v36 = "sbdrop";
        __int16 v37 = 2082;
        *(void *)unint64_t v38 = v10;
        int v7 = v9;
        os_log_type_t v8 = OS_LOG_TYPE_INFO;
        goto LABEL_16;
      }
    }
  }

  if ((a2 & 0x80000000) == 0)
  {
    while (1)
    {
      uint64_t v11 = *((void *)a1 + 2);
      if (!v11) {
        break;
      }
      int v12 = *(_DWORD *)(v11 + 52);
      if (v12)
      {
        int v13 = *(_DWORD *)(v11 + 56);
        int v14 = *(_DWORD *)(v11 + 60);
        if (v12 - (v13 + v14) > a2)
        {
          if ((*(_WORD *)(v11 + 204) & 0x80) != 0) {
            *(_WORD *)(v11 + 196) -= a2;
          }
          int v28 = v13 + a2;
          if (v13 + a2 <= (v12 - v14))
          {
            *(_DWORD *)(v11 + 56) = v28;
          }

          else
          {
            int v29 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              int v30 = *(_DWORD *)(v11 + 52);
              *(_DWORD *)__int128 buf = 136446978;
              int v36 = "__nw_frame_claim_internal";
              __int16 v37 = 1024;
              *(_DWORD *)unint64_t v38 = v28;
              *(_WORD *)&v38[4] = 1024;
              *(_DWORD *)&v38[6] = v30;
              *(_WORD *)uint64_t v39 = 1024;
              *(_DWORD *)&v39[2] = v14;
              _os_log_impl( &dword_1879E5000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)",  buf,  0x1Eu);
            }
          }

          *a1 -= a2;
          goto LABEL_58;
        }

        int v15 = v13 - v12 + v14;
      }

      else
      {
        int v15 = 0;
      }

      *a1 += v15;
      uint64_t v16 = *(void *)(*((void *)a1 + 9) + 24LL);
      if ((a1[12] & 4) != 0)
      {
        if (v16)
        {
          uint64_t all_stats = nw_protocol_tcp_get_all_stats();
          if (all_stats) {
            *(_DWORD *)(all_stats + 92) = *a1;
          }
        }
      }

      else if (v16)
      {
        uint64_t v17 = nw_protocol_tcp_get_all_stats();
        if (v17) {
          *(_DWORD *)(v17 + 104) = *a1;
        }
      }

      uint64_t v19 = *(void *)(v11 + 32);
      uint64_t v20 = *(void **)(v11 + 40);
      if (v19)
      {
        *(void *)(v19 + 40) = v20;
        uint64_t v20 = *(void **)(v11 + 40);
      }

      else
      {
        *((void *)a1 + 3) = v20;
      }

      a2 += v15;
      *uint64_t v20 = v19;
      int v21 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 80);
      *(void *)(v11 + 32) = 0LL;
      *(void *)(v11 + 40) = 0LL;
      if (v21)
      {
        uint64_t v22 = *(void *)(v11 + 88);
        *(void *)(v11 + 80) = 0LL;
        *(void *)(v11 + 88) = 0LL;
        v21(v11, 1LL, v22);
        if (a2 < 0) {
          goto LABEL_58;
        }
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        int v36 = "__nw_frame_finalize";
        int v23 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          os_log_type_t log = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446210;
            int v36 = "__nw_frame_finalize";
            _os_log_impl( &dword_1879E5000,  log,  OS_LOG_TYPE_ERROR,  "%{public}s called with null frame->finalizer, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        if (v23) {
          free(v23);
        }
        if (a2 < 0) {
          goto LABEL_58;
        }
      }
    }

    if (*a1)
    {
      uint64_t v24 = *((void *)a1 + 9);
      if (!v24 || (*(_BYTE *)(v24 + 828) & 2) == 0)
      {
        int v25 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          int v26 = (const char *)(v24 + 604);
          int v27 = *a1;
          int v36 = "sbdrop";
          *(_DWORD *)__int128 buf = 136446978;
          if (!v24) {
            int v26 = "";
          }
          __int16 v37 = 2082;
          *(void *)unint64_t v38 = v26;
          *(_WORD *)&v38[8] = 1024;
          *(_DWORD *)uint64_t v39 = a2;
          *(_WORD *)&v39[4] = 1024;
          int v40 = v27;
          _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s sbdrop - count not zero: len %d sb_cc %u",  buf,  0x22u);
        }
      }

      *a1 = 0;
    }
  }

LABEL_58:
  uint64_t v31 = *(void *)(*((void *)a1 + 9) + 24LL);
  if ((a1[12] & 4) != 0)
  {
    if (v31)
    {
      uint64_t v33 = nw_protocol_tcp_get_all_stats();
      if (v33) {
        *(_DWORD *)(v33 + 92) = *a1;
      }
    }
  }

  else
  {
    if (v31)
    {
      uint64_t v32 = nw_protocol_tcp_get_all_stats();
      if (v32) {
        *(_DWORD *)(v32 + 104) = *a1;
      }
    }

    nw_protocol_tcp_update_metadata(*(void *)(*((void *)a1 + 9) + 24LL));
  }

void sb_empty_assert(int *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*a1 || !nw_frame_array_is_empty() || *((void *)a1 + 4))
  {
    uint64_t v4 = *((void *)a1 + 9);
    if (!v4 || (*(_BYTE *)(v4 + 828) & 2) == 0)
    {
      __nwlog_tcp_log();
      uint64_t v5 = *((void *)a1 + 9);
      int v6 = *a1;
      *(_DWORD *)__int128 buf = 136447746;
      if (v4) {
        int v7 = (const char *)(v4 + 604);
      }
      else {
        int v7 = "";
      }
      int v13 = "sb_empty_assert";
      __int16 v14 = 2082;
      int v15 = v7;
      __int16 v16 = 2082;
      uint64_t v17 = a2;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      __int16 v20 = 2048;
      uint64_t v21 = v5;
      __int16 v22 = 1024;
      int v23 = v6;
      __int16 v24 = 2048;
      int v25 = a1 + 4;
      os_log_type_t v8 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_fault())
      {
        int v9 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint64_t v10 = *((void *)a1 + 9);
          int v11 = *a1;
          *(_DWORD *)__int128 buf = 136447746;
          int v13 = "sb_empty_assert";
          __int16 v14 = 2082;
          int v15 = v7;
          __int16 v16 = 2082;
          uint64_t v17 = a2;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 2048;
          uint64_t v21 = v10;
          __int16 v22 = 1024;
          int v23 = v11;
          __int16 v24 = 2048;
          int v25 = a1 + 4;
          _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s %{public}s: sb %p so %p cc %d mb %p, backtrace limit exceeded",  buf,  0x44u);
        }
      }

      if (v8) {
        free(v8);
      }
    }
  }

uint64_t sbreserve(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x71C71C) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 4) = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 24LL);
  if ((*(_BYTE *)(a1 + 48) & 4) != 0)
  {
    if (v4)
    {
      uint64_t all_stats = nw_protocol_tcp_get_all_stats();
      if (all_stats) {
        *(_DWORD *)(all_stats + 88) = *(_DWORD *)(a1 + 4);
      }
    }
  }

  else if (v4)
  {
    uint64_t v5 = nw_protocol_tcp_get_all_stats();
    if (v5) {
      *(_DWORD *)(v5 + 100) = *(_DWORD *)(a1 + 4);
    }
  }

  unsigned int v7 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)(a1 + 8) > v7) {
    *(_DWORD *)(a1 + 8) = v7;
  }
  return 1LL;
}

void set_tcp_stream_priority(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(*(void *)a1 + 232LL) != 3)
  {
    uint64_t v2 = *(void *)(*(void *)a1 + 240LL);
    int v3 = *(unsigned __int8 *)(v2 + 264);
    int v4 = *(_DWORD *)(a1 + 368);
    uint64_t v5 = (unint64_t *)nw_tcp_access_globals(a1);
    unint64_t v6 = *v5;
    if (so_throttle_best_effort(a1)
      || ((int v10 = *(_DWORD *)(a1 + 368), (v10 & 0x2000) != 0) || (v11 = *(_DWORD *)(a1 + 600), v11 == 200) || v11 == 100)
      && ((uint64_t v12 = *(void *)(v2 + 1064)) != 0 ? (v13 = v6 >= 3) : (v13 = 0), v13 && *(void *)(v12 + 8) > *v5 - 2)
      || *(_DWORD *)(a1 + 600) == 100)
    {
      if (v3 != 2) {
        tcp_set_new_cc(a1, 2);
      }
      int v7 = *(_DWORD *)(a1 + 368);
      if ((v7 & 0x4000) == 0)
      {
        *(_DWORD *)(a1 + 368) = v7 | 0x4000;
        if (*(_DWORD *)(sysctls + 308) == 1)
        {
          uint64_t v8 = *(void *)(*(void *)a1 + 240LL);
          if ((~*(_DWORD *)(v8 + 88) & 0x180) == 0 && off_18C4CE848 != 0LL) {
            off_18C4CE848(v8);
          }
        }
      }
    }

    else
    {
      if ((v10 & 0x4000) != 0) {
        *(_DWORD *)(a1 + 368) = v10 & 0xFFFFBFFF;
      }
      if (v3 == 2) {
        tcp_set_foreground_cc(a1);
      }
    }

    int v14 = v4 & 0x4000;
    if ((v3 != *(unsigned __int8 *)(v2 + 264) || v14 != (*(_DWORD *)(a1 + 368) & 0x4000))
      && (*(_BYTE *)(a1 + 828) & 2) == 0
      && __nwlog_is_datapath_logging_enabled())
    {
      int v15 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = tcp_cc_algo_list[*(unsigned __int8 *)(v2 + 264)];
        int v17 = 136446978;
        __int16 v18 = "set_tcp_stream_priority";
        __int16 v19 = 2082;
        uint64_t v20 = a1 + 604;
        __int16 v21 = 2082;
        uint64_t v22 = v16;
        __int16 v23 = 1024;
        int v24 = v14;
        _os_log_impl( &dword_1879E5000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s cc_algo %{public}s recvbg %d",  (uint8_t *)&v17,  0x26u);
      }
    }
  }

void tcp_close_locked(uint64_t a1)
{
  uint64_t v62 = *MEMORY[0x1895F89C0];
  if (!*(_DWORD *)(a1 + 360))
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    __int16 v60 = 2048;
    *(void *)__int16 v61 = a1;
    uint64_t v7 = _os_log_send_and_compose_impl();
    LOBYTE(type.numer) = 16;
    if (LOBYTE(type.numer) == 17)
    {
      uint64_t v8 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t numer = type.numer;
      if (!os_log_type_enabled(v8, type.numer)) {
        goto LABEL_123;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_close_locked";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      __int16 v60 = 2048;
      *(void *)__int16 v61 = a1;
      int v10 = "%{public}s %{public}s soclose: so=%p refcount=0";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t numer = type.numer;
      if (!os_log_type_enabled(v8, type.numer)) {
        goto LABEL_123;
      }
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "tcp_close_locked";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 604;
      __int16 v60 = 2048;
      *(void *)__int16 v61 = a1;
      int v10 = "%{public}s %{public}s soclose: so=%p refcount=0, backtrace limit exceeded";
    }

LABEL_122:
    _os_log_impl(&dword_1879E5000, v8, numer, v10, buf, 0x20u);
    goto LABEL_123;
  }

  if (*(_DWORD *)(a1 + 592))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "soclose_wait_locked";
    int v3 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(type.numer) = 16;
    if (LOBYTE(type.numer) == 17)
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type.numer;
      if (!os_log_type_enabled(v4, type.numer)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "soclose_wait_locked";
      unint64_t v6 = "%{public}s currently not supported";
    }

    else
    {
      int v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type.numer;
      if (!os_log_type_enabled(v4, type.numer)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "soclose_wait_locked";
      unint64_t v6 = "%{public}s currently not supported, backtrace limit exceeded";
    }

    _os_log_impl(&dword_1879E5000, v4, v5, v6, buf, 0xCu);
LABEL_19:
    if (v3) {
      free(v3);
    }
  }

  *(_DWORD *)(a1 + 368) &= ~0x40u;
  int v11 = *(_DWORD *)(a1 + 372);
  if ((v11 & 2) != 0)
  {
    *(_DWORD *)(a1 + 372) = v11 & 0xFFFFFFFD;
    uint64_t v12 = *(void *)(a1 + 304);
    if (v12)
    {
      int v13 = 0;
      do
      {
        uint64_t v14 = v12;
        uint64_t v12 = *(void *)(v12 + 336);
        if ((*(_BYTE *)(v14 + 365) & 2) == 0)
        {
          uint64_t v15 = *(void *)(a1 + 8);
          uint64_t v16 = v12;
          if (*(void *)(v15 + 32))
          {
            (*(void (**)(uint64_t, void, uint64_t))(v15 + 24))(a1, 0LL, v1);
            int v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 + 8) + 16LL))(v14, 1LL, v1);
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 0LL, v1);
            uint64_t v16 = *(void *)(v14 + 336);
          }

          int v17 = *(uint64_t **)(v14 + 344);
          if (v16)
          {
            *(void *)(v16 + 344) = v17;
            int v17 = *(uint64_t **)(v14 + 344);
          }

          else
          {
            *(void *)(a1 + 312) = v17;
          }

          *int v17 = v16;
          --*(_WORD *)(a1 + 356);
          if ((*(_WORD *)(v14 + 376) & 0x800) != 0)
          {
            *(_WORD *)(v14 + 376) &= ~0x800u;
            *(void *)(v14 + 296) = 0LL;
            int v18 = *(_DWORD *)(v14 + 364);
            if ((v18 & 0x100) == 0)
            {
              *(_DWORD *)(v14 + 364) = v18 | 0x100;
              if ((**(unsigned int (***)(uint64_t))(*(void *)(v14 + 8) + 40LL))(v14))
              {
                uint64_t v19 = *(void *)(v14 + 8);
                if (v19)
                {
                  uint64_t v20 = *(void (**)(uint64_t, void))(v19 + 32);
                  if (v20) {
                    v20(v14, 0LL);
                  }
                }

                sofreelastref(v14);
              }
            }
          }

          if (v13)
          {
            int v13 = 1;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v14 + 8) + 24LL))(v14, 1LL, v1);
          }
        }
      }

      while (v12);
    }

    while (1)
    {
      uint64_t v27 = *(void *)(a1 + 320);
      if (!v27) {
        break;
      }
      uint64_t v21 = *(void *)(v27 + 336);
      uint64_t v22 = *(void **)(v27 + 344);
      if (v21)
      {
        *(void *)(v21 + 344) = v22;
        uint64_t v22 = *(void **)(v27 + 344);
      }

      else
      {
        *(void *)(a1 + 328) = v22;
      }

      *uint64_t v22 = v21;
      --*(_WORD *)(a1 + 352);
      uint64_t v23 = *(void *)(a1 + 8);
      if (*(void *)(v23 + 32))
      {
        (*(void (**)(uint64_t, void, uint64_t))(v23 + 24))(a1, 0LL, v1);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v27 + 8) + 16LL))(v27, 1LL, v1);
      }

      if ((*(_WORD *)(v27 + 376) & 0x1000) != 0)
      {
        *(_WORD *)(v27 + 376) &= ~0x1000u;
        *(void *)(v27 + 296) = 0LL;
        int v24 = *(_DWORD *)(v27 + 364);
        if ((v24 & 0x100) == 0)
        {
          *(_DWORD *)(v27 + 364) = v24 | 0x100;
          if ((**(unsigned int (***)(uint64_t))(*(void *)(v27 + 8) + 40LL))(v27))
          {
            uint64_t v25 = *(void *)(v27 + 8);
            if (v25)
            {
              uint64_t v26 = *(void (**)(uint64_t, void))(v25 + 32);
              if (v26) {
                v26(v27, 0LL);
              }
            }

            sofreelastref(v27);
          }
        }
      }

      if (*(void *)(*(void *)(a1 + 8) + 32LL))
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v27 + 8) + 24LL))(v27, 1LL, v1);
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 8) + 16LL))(a1, 0LL, v1);
      }
    }
  }

  if (!*(void *)a1)
  {
    int v33 = *(_DWORD *)(a1 + 364) | 4;
    *(_DWORD *)(a1 + 364) = v33;
LABEL_76:
    *(_WORD *)(a1 + 376) |= 1u;
    if ((v33 & 0x1000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }

  if ((*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v55 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        int v56 = *(_DWORD *)(a1 + 360);
        int v57 = *(__int16 *)(a1 + 376);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        __int16 v60 = 1024;
        *(_DWORD *)__int16 v61 = v56;
        *(_WORD *)&v61[4] = 1024;
        *(_DWORD *)&_BYTE v61[6] = v57;
        _os_log_impl( &dword_1879E5000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s so_usecount %u so_state 0x%x",  buf,  0x22u);
      }
    }
  }

  __int16 v28 = *(_WORD *)(a1 + 376);
  if ((v28 & 2) != 0
    && ((v28 & 8) != 0 || !(*(unsigned int (**)(uint64_t))(*(void *)(*(void *)(a1 + 8) + 40LL) + 40LL))(a1))
    && (*(_BYTE *)(a1 + 372) & 0x80) != 0
    && (~*(unsigned __int16 *)(a1 + 376) & 0x108) != 0)
  {
    uint64_t v37 = *(void *)(a1 + 8);
    else {
      uint64_t v39 = 0LL;
    }
    while ((*(_WORD *)(a1 + 376) & 2) != 0)
    {
      uint64_t v45 = *(void *)(a1 + 32);
      if (v45)
      {
        __int16 v46 = *(unsigned int (**)(uint64_t, uint64_t, _BYTE *))(v45 + 112);
        if (v46)
        {
          if (((int v47 = *(_DWORD *)(a1 + 16), v48 = v47 / 100, v49 = v47 % 100, (v47 + 99) > 0xC6) || v49)
            && !mach_timebase_info(&type))
          {
            uint64_t v51 = mach_absolute_time() * type.numer / type.denom;
            unint64_t v52 = v51 / 0x3B9ACA00;
            int64_t v53 = 10000000LL * v49 + v51 % 0x3B9ACA00;
            *(void *)&buf[8] = v53;
            if (v53 > 999999999)
            {
              *(void *)&buf[8] = v53 - 1000000000;
              ++v52;
            }

            *(void *)__int128 buf = v52 + v48;
            int v50 = buf;
          }

          else
          {
            int v50 = 0LL;
          }

          if (v46(a1, v39, v50)) {
            break;
          }
        }
      }
    }
  }

  int v29 = *(_DWORD *)(a1 + 360);
  if (!v29)
  {
    if ((*(_BYTE *)(a1 + 828) & 2) != 0) {
      return;
    }
    __nwlog_tcp_log();
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "tcp_close_locked";
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = a1 + 604;
    __int16 v60 = 2048;
    *(void *)__int16 v61 = a1;
    uint64_t v7 = _os_log_send_and_compose_impl();
    LOBYTE(type.numer) = 16;
    if (LOBYTE(type.numer) == 17)
    {
      uint64_t v8 = (os_log_s *)__nwlog_tcp_log();
      os_log_type_t numer = type.numer;
      if (os_log_type_enabled(v8, type.numer))
      {
LABEL_82:
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "tcp_close_locked";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = a1 + 604;
        __int16 v60 = 2048;
        *(void *)__int16 v61 = a1;
        int v10 = "%{public}s %{public}s soclose: usecount is zero so=%p";
        goto LABEL_122;
      }

uint64_t tcp_setsockopt(uint64_t a1, int a2, int a3, int *a4)
{
  v22[0] = 1;
  v22[1] = a2;
  v22[2] = a3;
  uint64_t v23 = a4;
  uint64_t v24 = 4LL;
  int v9 = *a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 8) + 16LL))(a1, 1LL, v4, a4);
  if (a2 != 0xFFFF)
  {
    uint64_t v10 = tcp_ctloutput(a1, (uint64_t)v22);
    goto LABEL_27;
  }

  uint64_t v10 = 42LL;
  if (a3 > 2047)
  {
    if (a3 >= 0x2000)
    {
      if (a3 >= 0x8000)
      {
        if (a3 != 0x8000 && a3 != 0x10000) {
          goto LABEL_27;
        }
      }

      else if (a3 != 0x2000 && a3 != 0x4000)
      {
        goto LABEL_27;
      }

      goto LABEL_9;
    }

    if ((a3 - 4097) >= 4)
    {
      if (a3 != 2048) {
        goto LABEL_27;
      }
LABEL_9:
      uint64_t v10 = 0LL;
      if (v9) {
        int v11 = *(_DWORD *)(a1 + 372) | a3;
      }
      else {
        int v11 = *(_DWORD *)(a1 + 372) & ~a3;
      }
      *(_DWORD *)(a1 + 372) = v11;
      goto LABEL_27;
    }

    if (v9 < 1)
    {
LABEL_3:
      uint64_t v10 = 22LL;
      goto LABEL_27;
    }

    if ((a3 - 4097) < 2)
    {
      if (a3 == 4097) {
        uint64_t v14 = a1 + 384;
      }
      else {
        uint64_t v14 = a1 + 488;
      }
      if (v9 <= 0x71C71C)
      {
        *(_DWORD *)(v14 + 4) = v9;
        uint64_t v18 = *(void *)(*(void *)(v14 + 72) + 24LL);
        if ((*(_BYTE *)(v14 + 48) & 4) != 0)
        {
          if (v18)
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats) {
              *(_DWORD *)(all_stats + 88) = *(_DWORD *)(v14 + 4);
            }
          }
        }

        else if (v18)
        {
          uint64_t v19 = nw_protocol_tcp_get_all_stats();
          if (v19) {
            *(_DWORD *)(v19 + 100) = *(_DWORD *)(v14 + 4);
          }
        }

        unsigned int v21 = *(_DWORD *)(v14 + 4);
        if (*(_DWORD *)(v14 + 8) > v21) {
          *(_DWORD *)(v14 + 8) = v21;
        }
        uint64_t v10 = 0LL;
        *(_DWORD *)(v14 + 48) = *(_DWORD *)(v14 + 48) & 0xFFFFF9FF | 0x200;
        *(_DWORD *)(v14 + 52) = v9;
      }

      else
      {
        uint64_t v10 = 55LL;
      }
    }

    else if (a3 == 4099)
    {
      uint64_t v10 = 0LL;
      unsigned int v17 = *(_DWORD *)(a1 + 388) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 388) / 3) {
        unsigned int v17 = v9;
      }
      if (v17 <= 1) {
        unsigned int v17 = 1;
      }
      *(_DWORD *)(a1 + 392) = v17;
    }

    else if (a3 == 4100)
    {
      uint64_t v10 = 0LL;
      signed int v12 = *(_DWORD *)(a1 + 492) / 3u;
      if (v9 <= *(_DWORD *)(a1 + 492) / 3) {
        signed int v12 = v9;
      }
      if (v12 >= 0x4000) {
        signed int v12 = 0x4000;
      }
      *(_DWORD *)(a1 + 496) = v12;
    }

    else
    {
      uint64_t v10 = 0LL;
    }
  }

  else
  {
    if (a3 <= 127)
    {
      goto LABEL_9;
    }

    if (a3 != 128)
    {
      if (a3 != 512 && a3 != 1024) {
        goto LABEL_27;
      }
      goto LABEL_9;
    }

    *(_DWORD *)(a1 + 16) = a4[1];
    int v15 = *(_DWORD *)(a1 + 372);
    uint64_t v10 = 0LL;
    if (*a4) {
      unsigned int v16 = v15 | 0x80;
    }
    else {
      unsigned int v16 = v15 & 0xFFFFFF7F;
    }
    *(_DWORD *)(a1 + 372) = v16;
  }

uint64_t tcp_set_traffic_class(uint64_t a1, int a2)
{
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) == 0 && (*(_BYTE *)(a1 + 365) & 0x20) == 0)
  {
    uint64_t v5 = 22LL;
    goto LABEL_23;
  }

  if (a2 > 9999)
  {
LABEL_22:
    uint64_t v5 = 0LL;
    goto LABEL_23;
  }

  uint64_t v5 = 22LL;
  if (a2 > 499)
  {
    if (a2 <= 699)
    {
      if (a2 != 500 && a2 != 600) {
        goto LABEL_23;
      }
    }

    else if (a2 != 700 && a2 != 900 && a2 != 800)
    {
      goto LABEL_23;
    }

uint64_t tcp_set_keepalive(uint64_t a1, int a2)
{
  if ((~*(unsigned __int16 *)(a1 + 376) & 0x30) != 0 || (*(_BYTE *)(a1 + 365) & 0x20) != 0)
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)(a1 + 372) = *(_DWORD *)(a1 + 372) & 0xFFFFFFF7 | (8 * (a2 != 0));
  }

  else
  {
    uint64_t v5 = 22LL;
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
  return v5;
}

uint64_t tcp_set_keepalive_idle_time(uint64_t a1, int a2)
{
  int v6 = a2;
  int v8 = 16;
  uint64_t v7 = 0x600000001LL;
  int v9 = &v6;
  uint64_t v10 = 4LL;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16LL))();
  else {
    uint64_t v4 = 22LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
  return v4;
}

uint64_t tcp_set_keepalive_interval(uint64_t a1, int a2)
{
  int v6 = a2;
  int v8 = 257;
  uint64_t v7 = 0x600000001LL;
  int v9 = &v6;
  uint64_t v10 = 4LL;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16LL))();
  else {
    uint64_t v4 = 22LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v2);
  return v4;
}

uint64_t tcp_set_background_management(uint64_t a1)
{
  int v5 = 1;
  int v7 = 4357;
  uint64_t v6 = 0xFFFF00000001LL;
  int v8 = &v5;
  uint64_t v9 = 4LL;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16LL))();
  else {
    uint64_t v3 = 22LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 24LL))(a1, 1LL, v1);
  return v3;
}

void tcp_rack_update_segment_acked(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  int v10 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316);
  unsigned int v11 = v10 - a3;
  if (v10 == a3) {
    unsigned int v11 = 1;
  }
  if (!a5) {
    goto LABEL_10;
  }
  if (a2 && (((a2 - a3) & 0x80000000) != 0 || a2 - v10 >= 1))
  {
    uint64_t v12 = *(void *)(a1 + 80);
  }

  else
  {
    uint64_t v12 = *(void *)(a1 + 80);
    uint64_t v13 = *(void *)(v12 + 496);
    if (!v13 || (uint64_t v14 = *(void *)(v13 + 1488)) == 0 || v11 >= *(_DWORD *)(v14 + 40))
    {
LABEL_10:
      unsigned int v15 = *(_DWORD *)(a1 + 2048);
      if (v15 < a3 || (v15 == a3 ? (BOOL v16 = a4 - *(_DWORD *)(a1 + 2052) < 1) : (BOOL v16 = 1), !v16))
      {
        *(_BYTE *)(a1 + 2069) |= 0x20u;
        *(_DWORD *)(a1 + 2048) = a3;
        *(_DWORD *)(a1 + 2052) = a4;
        *(_DWORD *)(a1 + 2056) = v11;
        *(_DWORD *)(a1 + 24) = 0;
      }

      return;
    }
  }

  uint64_t v17 = *(void *)(v12 + 224);
  if (!v17 || (*(_BYTE *)(v17 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      uint64_t v18 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = (const char *)(v17 + 604);
        if (!v17) {
          uint64_t v19 = "";
        }
        uint64_t v20 = *(void *)(*(void *)(a1 + 80) + 496LL);
        if (v20)
        {
          uint64_t v20 = *(void *)(v20 + 1488);
          if (v20) {
            LODWORD(v20) = *(_DWORD *)(v20 + 40);
          }
        }

        int v21 = 136447490;
        uint64_t v22 = "tcp_rack_update_segment_acked";
        __int16 v23 = 2082;
        uint64_t v24 = v19;
        __int16 v25 = 1024;
        int v26 = a2;
        __int16 v27 = 1024;
        unsigned int v28 = a3;
        __int16 v29 = 1024;
        int v30 = v10;
        __int16 v31 = 1024;
        int v32 = v20;
        _os_log_impl( &dword_1879E5000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Spurious inference as eithertsecr (%u) doesn't lie between xmit_ts(%u) and now (%u) ORth e segment was transmitted less than base rtt (%u) ago",  (uint8_t *)&v21,  0x2Eu);
      }
    }
  }

uint64_t tcp_rack_update_reordering_window(uint64_t result, int a2)
{
  char v2 = *(_BYTE *)(result + 2069);
  if (a2 - *(_DWORD *)(result + 2060) < 0)
  {
    v2 &= ~0x40u;
    *(_BYTE *)(result + 2069) = v2;
    if ((v2 & 0x40) == 0)
    {
LABEL_3:
      if ((v2 & 0x1F) == 0) {
        *(_BYTE *)(result + 2068) = 1;
      }
      return result;
    }
  }

  else if ((*(_BYTE *)(result + 2069) & 0x40) == 0)
  {
    goto LABEL_3;
  }

  *(_DWORD *)(result + 2060) = *(_DWORD *)(result + 100);
  __int16 v3 = *(unsigned __int8 *)(result + 2068);
  if (((v3 + 1) & 0x100) != 0) {
    char v4 = -1;
  }
  else {
    char v4 = v3 + 1;
  }
  *(_BYTE *)(result + 2068) = v4;
  *(_BYTE *)(result + 2069) = v2 & 0xA0 | 0x10;
  return result;
}

BOOL tcp_rack_detect_loss_and_arm_timer(uint64_t a1, unsigned int a2)
{
  BOOL result = 0LL;
  char v6 = 0;
  if ((*(_BYTE *)(a1 + 2069) & 0x20) != 0)
  {
    *(_DWORD *)(a1 + 24) = 0;
    int v4 = tcp_rack_detect_loss(a1, a2, &v6);
    if (v4)
    {
      int v5 = v4
         + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 316)
         - *(_DWORD *)(a1 + 64)
         + 2;
      *(_DWORD *)(a1 + 16) = 0;
    }

    else
    {
      int v5 = 0;
    }

    *(_DWORD *)(a1 + 24) = v5;
    return v6 != 0;
  }

  return result;
}

uint64_t tcp_rack_detect_loss(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t v6 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  if (*(_DWORD *)(a1 + 1016) || (*(_BYTE *)(a1 + 90) & 0x20) == 0 && *(unsigned __int8 *)(a1 + 310) > a2)
  {
    int v7 = *(unsigned __int8 *)(a1 + 2068);
    uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 496LL);
    if (v8)
    {
      uint64_t v9 = *(void *)(v8 + 1488);
      if (v9) {
        LODWORD(v9) = *(_DWORD *)(v9 + 40) >> 2;
      }
      unsigned int v10 = v9 * v7;
      unsigned int v11 = *(int *)(a1 + 200) >> 5;
      if (v10 >= v11)
      {
LABEL_16:
        if (v11 <= 2) {
          int v13 = 2;
        }
        else {
          int v13 = v11;
        }
        uint64_t v14 = *(void *)(a1 + 1984);
        if (!v14) {
          return 0LL;
        }
        goto LABEL_20;
      }

      uint64_t v12 = *(void *)(v8 + 1488);
      if (v12) {
        LODWORD(v12) = *(_DWORD *)(v12 + 40) >> 2;
      }
    }

    else
    {
      unsigned int v11 = *(int *)(a1 + 200) >> 5;
      if (!v11) {
        goto LABEL_16;
      }
      LODWORD(v12) = 0;
    }

    unsigned int v11 = v12 * v7;
    goto LABEL_16;
  }

  int v13 = 0;
  uint64_t v14 = *(void *)(a1 + 1984);
  if (!v14) {
    return 0LL;
  }
LABEL_20:
  int v17 = *(_DWORD *)(v6 + 316);
  uint64_t v15 = 0LL;
  if (a3)
  {
    do
    {
      unsigned int v18 = *(_DWORD *)(a1 + 2048);
      unsigned int v19 = *(_DWORD *)(v14 + 8);
      if (v18 <= v19 && (v18 != v19 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1)) {
        break;
      }
      if ((*(_BYTE *)(v14 + 12) & 6) != 2 && (*(_BYTE *)(v14 + 12) & 1) == 0)
      {
        int v22 = v19 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v22 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
          *a3 = 1;
        }

        else
        {
          LODWORD(v23) = v22 - v17;
          else {
            uint64_t v23 = v23;
          }
          if (v22 != v17) {
            uint64_t v15 = v23;
          }
        }
      }

      uint64_t v14 = *(void *)(v14 + 16);
    }

    while (v14);
  }

  else
  {
    do
    {
      unsigned int v24 = *(_DWORD *)(a1 + 2048);
      unsigned int v25 = *(_DWORD *)(v14 + 8);
      if (v24 <= v25 && (v24 != v25 || *(_DWORD *)(a1 + 2052) - *(_DWORD *)(v14 + 4) < 1)) {
        break;
      }
      if ((*(_BYTE *)(v14 + 12) & 6) != 2 && (*(_BYTE *)(v14 + 12) & 1) == 0)
      {
        int v28 = v25 + v13 + *(_DWORD *)(a1 + 2056);
        if (v17 - v28 >= 0)
        {
          tcp_mark_seg_lost(a1, v14);
        }

        else
        {
          LODWORD(v29) = v28 - v17;
          else {
            uint64_t v29 = v29;
          }
          if (v28 != v17) {
            uint64_t v15 = v29;
          }
        }
      }

      uint64_t v14 = *(void *)(v14 + 16);
    }

    while (v14);
  }

  return v15;
}

uint64_t tcp_rack_reordering_timeout(uint64_t a1)
{
  char v8 = 0;
  uint64_t result = tcp_rack_detect_loss(a1, 0, &v8);
  if (v8)
  {
    int v3 = *(_DWORD *)(a1 + 88);
    if ((v3 & 0x200000) == 0)
    {
      if ((~v3 & 0x180) != 0)
      {
        uint64_t v6 = *(void *)(a1 + 144);
        *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 152);
        *(void *)(a1 + 504) = v6;
        *(_DWORD *)(a1 + 88) = v3 & 0xFFBFFFFF;
      }

      else
      {
        unsigned int v4 = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
        int v5 = *(_DWORD *)(a1 + 152);
        if (v4 <= *(_DWORD *)(a1 + 148)) {
          unsigned int v4 = *(_DWORD *)(a1 + 148);
        }
        *(_DWORD *)(a1 + 508) = v4;
        *(_DWORD *)(a1 + 512) = v5;
      }

      *(_DWORD *)(a1 + 516) = (*(int *)(a1 + 200) >> 5) + 2;
      *(_DWORD *)(a1 + 524) = *(int *)(a1 + 208) >> 4;
      if ((*(_DWORD *)(a1 + 1872) & 0xFFFFFFFE) == 2)
      {
        *(_DWORD *)(a1 + 520) = (*(int *)(a1 + 204) >> 5) + 2;
        *(_DWORD *)(a1 + 528) = *(int *)(a1 + 212) >> 4;
      }

      *(_DWORD *)(a1 + 740) &= ~0x40u;
      tcp_enter_fast_recovery(a1);
    }

    uint64_t v7 = *(void *)(a1 + 1056);
    if (v7) {
      ++*(void *)(v7 + 632);
    }
    ++*(_DWORD *)(a1 + 1012);
    return tcp_output(a1);
  }

  return result;
}

void tcp_rack_loss_on_rto(uint64_t a1)
{
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  if (*(_DWORD *)(a1 + 1016))
  {
    int v3 = *(unsigned __int8 *)(a1 + 2068);
    uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 496LL);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 1488);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(v5 + 40) >> 2;
      }
      unsigned int v6 = v5 * v3;
      unsigned int v7 = *(int *)(a1 + 200) >> 5;
      if (v6 >= v7)
      {
LABEL_13:
        if (v7 <= 2) {
          int v9 = 2;
        }
        else {
          int v9 = v7;
        }
        uint64_t v10 = *(void *)(a1 + 1984);
        if (!v10) {
          return;
        }
        goto LABEL_17;
      }

      uint64_t v8 = *(void *)(v4 + 1488);
      if (v8) {
        LODWORD(v8) = *(_DWORD *)(v8 + 40) >> 2;
      }
    }

    else
    {
      unsigned int v7 = *(int *)(a1 + 200) >> 5;
      if (!v7) {
        goto LABEL_13;
      }
      LODWORD(v8) = 0;
    }

    unsigned int v7 = v8 * v3;
    goto LABEL_13;
  }

  int v9 = 0;
  uint64_t v10 = *(void *)(a1 + 1984);
  if (!v10) {
    return;
  }
LABEL_17:
  int v11 = *(_DWORD *)(v2 + 316);
  do
  {
    if (*(_DWORD *)v10 == *(_DWORD *)(a1 + 92)) {
      tcp_mark_seg_lost(a1, v10);
    }
    if ((*(_BYTE *)(v10 + 12) & 6) != 2
      && (*(_BYTE *)(v10 + 12) & 1) == 0
      && v11 - *(_DWORD *)(a1 + 2056) - (v9 + *(_DWORD *)(v10 + 8)) >= 0)
    {
      tcp_mark_seg_lost(a1, v10);
    }

    uint64_t v10 = *(void *)(v10 + 16);
  }

  while (v10);
}

BOOL so_throttle_best_effort(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)(a1 + 600);
  if (v2 && v2 != 400 && v2 != 300) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 240LL);
  uint64_t v4 = (unint64_t *)nw_tcp_access_globals(a1);
  BOOL v8 = *(_DWORD *)(sysctls + 340) == 1
    && ((unint64_t v5 = *v4, (v6 = *(void *)(v3 + 1064)) != 0) ? (v7 = v5 >= 3) : (v7 = 0), v7)
    && *(void *)(v6 + 16) > v5 - 2;
  if (so_throttle_best_effort_old_result != v8 && (*(_BYTE *)(a1 + 828) & 2) == 0)
  {
    int v9 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = "off";
      int v13 = "so_throttle_best_effort";
      int v12 = 136446722;
      if (v8) {
        uint64_t v10 = "on";
      }
      __int16 v14 = 2082;
      uint64_t v15 = a1 + 604;
      __int16 v16 = 2080;
      int v17 = v10;
      _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s throttling is now %s",  (uint8_t *)&v12,  0x20u);
    }
  }

  so_throttle_best_effort_old_uint64_t result = v8;
  return v8;
}

void set_frame_service_class(uint64_t a1, uint64_t a2, int a3, char a4, int *a5)
{
  uint64_t v9 = *(void *)a2;
  if ((a3 + 1) >= 2)
  {
    int v11 = 524432;
    if (a3 <= 499)
    {
      if (a3 > 299)
      {
        if (a3 == 300)
        {
          int v10 = 1572880;
          goto LABEL_3;
        }

        if (a3 == 400)
        {
          int v10 = 2097184;
          goto LABEL_3;
        }
      }

      else
      {
        if (a3 == 100) {
          goto LABEL_11;
        }
        if (a3 == 200)
        {
LABEL_9:
          int v11 = 1048704;
          goto LABEL_11;
        }
      }
    }

    else if (a3 <= 699)
    {
      if (a3 == 500)
      {
        int v10 = 2621728;
        goto LABEL_3;
      }

      if (a3 == 600)
      {
        int v10 = 3146000;
        goto LABEL_3;
      }
    }

    else
    {
      switch(a3)
      {
        case 700:
          int v10 = 3670272;
          goto LABEL_3;
        case 800:
          int v10 = 4194688;
          goto LABEL_3;
        case 900:
          int v10 = 4718992;
          goto LABEL_3;
      }
    }

    uint64_t v24 = *(void *)a2;
    int v22 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    uint64_t v23 = (void *)_os_log_send_and_compose_impl();
    free(v23);
    int v10 = 0;
    uint64_t v9 = v24;
    goto LABEL_3;
  }

  int v10 = 0;
LABEL_3:
  if ((*(_BYTE *)(a2 + 369) & 0x20) != 0) {
    goto LABEL_9;
  }
  if (v10 && v10 != 2097184 && v10 != 1572880 || !*(void *)(v9 + 448))
  {
    int v11 = v10;
    goto LABEL_11;
  }

  int v11 = v10;
  if (so_throttle_best_effort(a2)) {
    goto LABEL_9;
  }
LABEL_11:
  if ((*(_BYTE *)(a2 + 369) & 0x20) != 0 || (int v12 = *(_DWORD *)(a2 + 600), v12 == 200) || v12 == 100)
  {
    *(_BYTE *)(a1 + 186) |= 0x10u;
    int v12 = *(_DWORD *)(a2 + 600);
  }

  if ((a4 & 6) != 0) {
    int v13 = 4718992;
  }
  else {
    int v13 = v11;
  }
  if (v11 == 1048704) {
    int v14 = 1048704;
  }
  else {
    int v14 = v13;
  }
  if (v11 == 524432) {
    int v15 = 524432;
  }
  else {
    int v15 = v14;
  }
  set_tcp_stream_priority(a2);
  uint64_t v16 = (unsigned __int16)v15 >> 7;
  uint64_t v20 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  int v21 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
LABEL_55:
    __break(1u);
    return;
  }

  free(v21);
LABEL_27:
  uint64_t v17 = a2 + 32 * v16;
  ++*(void *)(v17 + 712);
  int v18 = *(_DWORD *)(a1 + 52);
  if (v18) {
    uint64_t v19 = (v18 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60)));
  }
  else {
    uint64_t v19 = 0LL;
  }
  *(void *)(v17 + 720) += v19;
  *a5 = v15;
}

const char *packet_service_class_to_str(int a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (a1 <= 2621727)
  {
    if (a1 <= 1048703)
    {
      if (!a1) {
        return "be";
      }
      if (a1 == 524432) {
        return "bk_sys";
      }
    }

    else
    {
      switch(a1)
      {
        case 1048704:
          return "bk";
        case 1572880:
          return "rd";
        case 2097184:
          return "oam";
      }
    }
  }

  else if (a1 > 3670319)
  {
    switch(a1)
    {
      case 3670320:
        return "sig";
      case 4194688:
        return "vo";
      case 4718992:
        return "ctl";
    }
  }

  else
  {
    switch(a1)
    {
      case 2621728:
        return "av";
      case 3146000:
        return "rv";
      case 3670272:
        return "vi";
    }
  }

  uint64_t v3 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136446466;
    unint64_t v5 = "packet_service_class_to_str";
    __int16 v6 = 1024;
    int v7 = a1;
    _os_log_impl( &dword_1879E5000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s invalid packet service class %d",  (uint8_t *)&v4,  0x12u);
  }

  return "unknown";
}

void add_to_time_wait(uint64_t a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL)) + 72);
  unint64_t v5 = *(uint64_t **)(a1 + 80);
  uint64_t v6 = v5[28];
  if ((*(_BYTE *)(v6 + 374) & 1) != 0)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v31 = "socket_post_kev_msg_closed";
    int v7 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v31 = "socket_post_kev_msg_closed";
        _os_log_impl( &dword_1879E5000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s currently not supported, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v7) {
      free(v7);
    }
    unint64_t v5 = *(uint64_t **)(a1 + 80);
    uint64_t v6 = v5[28];
  }

  uint64_t v9 = nw_tcp_access_globals(v6);
  uint64_t v10 = v9;
  int v11 = *((_DWORD *)v5 + 558);
  if ((v11 & 1) != 0)
  {
    uint64_t v13 = *(void *)(a1 + 824);
    int v14 = *(void **)(a1 + 832);
    if (v13)
    {
      *(void *)(v13 + 832) = v14;
      int v14 = *(void **)(a1 + 832);
    }

    else
    {
      *(void *)(v9 + 136) = v14;
    }
  }

  else
  {
    ++*(_DWORD *)(*(void *)(v9 + 72) + 64LL);
    uint64_t v12 = *(void *)(a1 + 1056);
    if (v12) {
      ++*(void *)(v12 + 1696);
    }
    *((_DWORD *)v5 + 558) = v11 | 1;
    uint64_t v13 = *v5;
    if (*v5) {
      *(void *)(v13 + 8) = v5[1];
    }
    int v14 = (void *)v5[1];
  }

  *int v14 = v13;
  int v15 = *(_DWORD *)(v9 + 316) + a2;
  if ((*(_BYTE *)(a1 + 91) & 0x40) != 0)
  {
    uint64_t v16 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
    (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 8LL) + 32LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  0LL);
    int v17 = *(_DWORD *)(a1 + 88);
    if ((v17 & 0x40000000) != 0)
    {
      int v18 = *(uint64_t **)(v16 + 264);
      uint64_t v19 = (uint64_t *)(a1 + 48);
      if (v18) {
        BOOL v20 = v18 == v19;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20) {
        *(void *)(v16 + 264) = *v18;
      }
      uint64_t v21 = *v19;
      if (*v19) {
        *(void *)(v21 + 8) = *(void *)(a1 + 56);
      }
      **(void **)(a1 + 56) = v21;
      *(_DWORD *)(a1 + 88) = v17 & 0xBFFFFFFF;
      --*(_DWORD *)(v16 + 280);
      *uint64_t v19 = 0LL;
      *(void *)(a1 + 56) = 0LL;
    }
  }

  *(_DWORD *)(a1 + 44) = v15;
  uint64_t v22 = v5[28];
  if (!v22 || (*(_BYTE *)(v22 + 828) & 2) == 0)
  {
    if (__nwlog_is_datapath_logging_enabled())
    {
      __int16 v27 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        int v28 = (const char *)(v22 + 604);
        int v29 = *(_DWORD *)(v5[28] + 360);
        if (!v22) {
          int v28 = "";
        }
        *(_DWORD *)__int128 buf = 136446978;
        __int16 v31 = "add_to_time_wait_locked";
        __int16 v32 = 2082;
        uint64_t v33 = v28;
        __int16 v34 = 1024;
        int v35 = v29;
        __int16 v36 = 1024;
        int v37 = a2;
        _os_log_impl( &dword_1879E5000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s so_usecount %u added to TIME_WAIT delay %u",  buf,  0x22u);
      }
    }
  }

  *(void *)(a1 + 824) = 0LL;
  uint64_t v23 = *(void **)(v10 + 136);
  *(void *)(a1 + 832) = v23;
  *uint64_t v23 = a1;
  *(void *)(v10 + 136) = a1 + 824;
  uint64_t v24 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  *(_BYTE *)(v24 + 328) |= 2u;
  unsigned int v25 = (unsigned int *)(v4 + 40);
  do
    unsigned int v26 = __ldaxr(v25);
  while (__stlxr(v26 + 1, v25));
  if ((*(_BYTE *)(v24 + 328) & 1) == 0 && (*(_BYTE *)(v24 + 328) & 6) != 0)
  {
    *(_BYTE *)(v24 + 328) = *(_BYTE *)(v24 + 328) & 0xF6 | 1;
    nw_protocol_timer_run_inner(v24, 1000000000LL);
  }

void tcp_gc(uint64_t a1, unsigned int *a2)
{
  *(_BYTE *)(a1 + 328) |= 0x20u;
  uint64_t v4 = *(void **)(a1 + 104);
  if (v4)
  {
    unint64_t v5 = a2 + 11;
    do
    {
      uint64_t v6 = (uint64_t)v4;
      uint64_t v4 = (void *)*v4;
      if (tcp_garbage_collect(v6, 0))
      {
        do
          unsigned int v7 = __ldaxr(v5);
        while (__stlxr(v7 + 1, v5));
      }
    }

    while (v4);
  }

  uint64_t v8 = *(void *)(a1 + 128);
  if (v8)
  {
    uint64_t v9 = a2 + 10;
    do
    {
      uint64_t v10 = v8;
      uint64_t v8 = *(void *)(v8 + 824);
      if (!*(_DWORD *)(v10 + 12) || *(_DWORD *)(a1 + 316) - *(_DWORD *)(v10 + 44) >= 0)
      {
        if (tcp_garbage_collect(*(void *)(v10 + 80), 1))
        {
          do
            unsigned int v11 = __ldaxr(v9);
          while (__stlxr(v11 + 1, v9));
        }
      }
    }

    while (v8);
  }

  unsigned int v12 = a2[16];
  uint64_t v13 = a2 + 10;
  do
    unsigned int v14 = __ldaxr(v13);
  while (__stlxr(v14 + v12, v13));
}

uint64_t tcp_garbage_collect(uint64_t a1, int a2)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 224);
  uint64_t v5 = *(void *)(a1 + 240);
  uint64_t v6 = nw_tcp_access_globals(v4);
  int v7 = *(_DWORD *)(v4 + 360);
  if (v7 >= 2) {
    return *(_DWORD *)(a1 + 456) == 0xFFFF;
  }
  if (!a2)
  {
    if (v7 != 1) {
      goto LABEL_15;
    }
    if (!v5) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  if (*(_DWORD *)(v6 + 316) - *(_DWORD *)(v5 + 44) >= 0 && *(_DWORD *)(v5 + 12))
  {
    tcp_close(v5);
    int v7 = *(_DWORD *)(v4 + 360);
  }

  if (v7 == 1)
  {
    if ((*(_BYTE *)(v4 + 365) & 2) != 0)
    {
LABEL_9:
      if (*(_DWORD *)(a1 + 232) == 3)
      {
        int v9 = 1;
      }

      else
      {
        in_pcbdetach(a1);
        int v9 = *(_DWORD *)(v4 + 360);
        if (v9 <= 0 && (*(_BYTE *)(v4 + 828) & 2) == 0)
        {
          __nwlog_tcp_log();
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v68 = "tcp_garbage_collect";
          __int16 v69 = 2082;
          uint64_t v70 = v4 + 604;
          BOOL v20 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_fault())
          {
            int64_t v53 = (os_log_s *)__nwlog_tcp_log();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446466;
              uint64_t v68 = "tcp_garbage_collect";
              __int16 v69 = 2082;
              uint64_t v70 = v4 + 604;
              _os_log_impl( &dword_1879E5000,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s so->so_usecount <= 0, backtrace limit exceeded",  buf,  0x16u);
            }
          }

          if (v20) {
            free(v20);
          }
          int v9 = *(_DWORD *)(v4 + 360);
        }
      }

      *(_DWORD *)(v4 + 360) = v9 - 1;
      return *(_DWORD *)(a1 + 456) == 0xFFFF;
    }

uint64_t tcp_canceltimers(uint64_t a1)
{
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 8LL) + 32LL))();
  int v3 = *(_DWORD *)(a1 + 88);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v4 = *(uint64_t **)(v2 + 264);
    uint64_t v5 = (uint64_t *)(a1 + 48);
    if (v4) {
      BOOL v6 = v4 == v5;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      *(void *)(v2 + 264) = *v4;
    }
    uint64_t v7 = *v5;
    if (*v5) {
      *(void *)(v7 + 8) = *(void *)(a1 + 56);
    }
    **(void **)(a1 + 56) = v7;
    *(_DWORD *)(a1 + 88) = v3 & 0xBFFFFFFF;
    --*(_DWORD *)(v2 + 280);
    *uint64_t v5 = 0LL;
    *(void *)(a1 + 56) = 0LL;
  }

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t result = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(result + 316);
  *(_WORD *)(a1 + 72) = 8;
  return result;
}

uint64_t tcp_rexmt_save_state(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 88);
  if ((~v1 & 0x180) != 0)
  {
    uint64_t v4 = *(void *)(result + 144);
    *(_DWORD *)(result + 512) = *(_DWORD *)(result + 152);
    *(void *)(result + 504) = v4;
    if ((v1 & 0x200000) != 0) {
      unsigned int v5 = v1 | 0x400000;
    }
    else {
      unsigned int v5 = v1 & 0xFFBFFFFF;
    }
    *(_DWORD *)(result + 88) = v5;
  }

  else
  {
    unsigned int v2 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    int v3 = *(_DWORD *)(result + 152);
    if (v2 <= *(_DWORD *)(result + 148)) {
      unsigned int v2 = *(_DWORD *)(result + 148);
    }
    *(_DWORD *)(result + 508) = v2;
    *(_DWORD *)(result + 512) = v3;
  }

  *(_DWORD *)(result + 516) = (*(int *)(result + 200) >> 5) + 2;
  *(_DWORD *)(result + 524) = *(int *)(result + 208) >> 4;
  if ((*(_DWORD *)(result + 1872) & 0xFFFFFFFE) == 2)
  {
    *(_DWORD *)(result + 520) = (*(int *)(result + 204) >> 5) + 2;
    *(_DWORD *)(result + 528) = *(int *)(result + 212) >> 4;
  }

  *(_DWORD *)(result + 740) &= ~0x40u;
  return result;
}

void tcp_pmtud_revert_segment_size(uint64_t a1)
{
  int v2 = *(unsigned __int16 *)(a1 + 698);
  if (!*(_WORD *)(a1 + 698))
  {
    BOOL v14 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    uint64_t v15 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v15);
    int v2 = *(unsigned __int16 *)(a1 + 698);
  }

  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 88) & 0xDBFFFFFF | 0x4000000;
  int v3 = *(_DWORD *)(a1 + 196) - *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v2;
  *(_DWORD *)(a1 + 196) = v3 + v2;
  uint64_t v4 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(a1 + 264)] + 40);
  if (v4) {
    v4(a1);
  }
  if (*(_DWORD *)(sysctls + 308) == 1
    && (~*(_DWORD *)(a1 + 88) & 0x180) == 0
    && (*(_DWORD *)(sysctls + 40) == 1 || (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 369LL) & 0x40) != 0)
    && off_18C4CE828)
  {
    off_18C4CE828((_DWORD *)a1);
  }

  *(_DWORD *)(a1 + 700) = 0;
  uint64_t v5 = *(void *)(a1 + 1056);
  if (v5) {
    ++*(void *)(v5 + 1056);
  }
  uint64_t v6 = **(void **)(*(void *)(a1 + 80) + 224LL);
  uint64_t v7 = *(void *)(v6 + 448);
  if (v7)
  {
    uint64_t v8 = *(void *)(v6 + 240);
    if ((*(unsigned __int8 *)(v7 + 1076) == 255 || *(_DWORD *)(v7 + 1024) == 255)
      && *(int *)(v8 + 12) <= 5
      && (*(_BYTE *)(v8 + 91) & 0x20) == 0
      && (*(_BYTE *)(v7 + 9) & 0x80) != 0)
    {
      unsigned int v9 = *(_DWORD *)(v8 + 156);
      unsigned int v10 = *(_DWORD *)(v8 + 196) - v9;
      int v11 = *(unsigned __int16 *)(v7 + 72);
      if (v11 == 1200)
      {
        if (v9 <= 0x4B0) {
          goto LABEL_33;
        }
        unsigned int v12 = 1200;
      }

      else
      {
        if (v11 != 512)
        {
          if (v11) {
            goto LABEL_33;
          }
          unsigned int v12 = *(unsigned __int16 *)(v8 + 734);
          if (!*(_WORD *)(v8 + 734) || v9 >= v12) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }

        if (v9 < 0x201) {
          goto LABEL_33;
        }
        unsigned int v12 = 512;
      }

      *(_WORD *)(v8 + 734) = v9;
LABEL_32:
      *(_DWORD *)(v8 + 156) = v12;
      unsigned int v9 = v12;
LABEL_33:
      *(_DWORD *)(v8 + 196) = v10 + v9;
    }
  }

uint64_t tcp_timers(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  uint64_t v165 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 448);
  uint64_t v6 = *(void *)(v4 + 224);
  uint64_t v7 = nw_tcp_access_globals(v6);
  uint64_t v8 = v7;
  int v9 = *(_DWORD *)(v7 + 316);
  int v10 = v9 - *(_DWORD *)(v3 + 160);
  switch(a2)
  {
    case 0:
      int v11 = *(_DWORD *)(v3 + 740);
      unsigned int v12 = v11 & 0xFFFFEFFF;
      *(_DWORD *)(v3 + 740) = v11 & 0xFFFFEFFF;
      if (*(_DWORD *)(v3 + 12) == 4 && (!*(_WORD *)(v3 + 226) || (v11 & 0x200000) != 0))
      {
        int v13 = *(_DWORD *)(v3 + 96);
        unsigned int v14 = v13 - *(_DWORD *)(v3 + 92);
        if (v14)
        {
          if ((v11 & 0x20) != 0 && (*(_BYTE *)(v3 + 90) & 0x20) == 0)
          {
            unsigned int v15 = *(_DWORD *)(v6 + 384);
            if (v15 >= *(_DWORD *)(v3 + 140)) {
              unsigned int v15 = *(_DWORD *)(v3 + 140);
            }
            if ((int)(v15 - v14) < 1)
            {
              unsigned int v106 = *(_DWORD *)(v3 + 196);
              if (v14 < v106) {
                unsigned int v106 = v13 - *(_DWORD *)(v3 + 92);
              }
              v13 -= v106;
              unsigned int v16 = v12 | 0x40000000;
            }

            else
            {
              unsigned int v16 = v11 & 0xBFFFEFFF;
            }

            *(_DWORD *)(v3 + 100) = v13;
            uint64_t v107 = *(void *)(v3 + 1056);
            if (v107)
            {
              ++*(void *)(v107 + 712);
              if ((v16 & 0x200000) != 0) {
                ++*(void *)(v107 + 728);
              }
            }

            *(_DWORD *)(v3 + 172) = 0;
            *(_DWORD *)(v3 + 740) = v16 | 0x1000;
            *(_DWORD *)(v3 + 936) = v9;
            *(_DWORD *)(v3 + 144) += *(_DWORD *)(v3 + 196);
            *(_DWORD *)(v3 + 28) = 0;
            tcp_output(v3);
            *(_DWORD *)(v3 + 144) -= *(_DWORD *)(v3 + 196);
            int v108 = *(_DWORD *)(v3 + 100);
            *(_DWORD *)(v3 + 928) = v108;
            *(_DWORD *)(v3 + 932) = v108;
          }
        }
      }

      return v3;
    case 1:
      int v37 = *(_DWORD *)(v3 + 740);
      *(_DWORD *)(v3 + 740) = v37 & 0xFFFFBFFF;
      if ((*(_BYTE *)(v3 + 90) & 0x20) != 0
        || *(_DWORD *)(v3 + 92) - *(_DWORD *)(v3 + 152) >= 0
        || *(_WORD *)(v3 + 226))
      {
        return v3;
      }

      if ((v37 & 0x20) != 0) {
        goto LABEL_69;
      }
      uint64_t v157 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v157, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_timers";
      uint64_t v158 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort();
      if ((_DWORD)result)
      {
        __break(1u);
        return result;
      }

      free(v158);
LABEL_69:
      tcp_rexmt_save_state(v3);
      uint64_t v38 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 64);
      if (v38)
      {
        if ((v38(v3), int v39 = *(_DWORD *)(v3 + 740), (v39 & 0x10000000) != 0)
          || (v39 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
          || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
        {
          int v40 = *(_DWORD *)(v3 + 348);
          if ((~v40 & 3) == 0) {
            *(_DWORD *)(v3 + 348) = v40 | 8;
          }
        }
      }

      *(_DWORD *)(v3 + 88) |= 0x200000u;
      uint64_t v41 = *(void *)(v3 + 80);
      if ((*(_BYTE *)(v41 + 2231) & 0x40) != 0) {
        inp_reset_fc_state(v41);
      }
      if (*(void *)(v3 + 952)) {
        tcp_rxtseg_clean(v3);
      }
      *(_DWORD *)(v3 + 28) = 0;
      uint64_t v42 = *(void *)(v3 + 1056);
      if (v42) {
        ++*(void *)(v42 + 568);
      }
      ++*(_DWORD *)(v3 + 1004);
      *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
      goto LABEL_366;
    case 2:
      if ((*(_DWORD *)(v3 + 740) & 0x20400020) == 0x20000020) {
        tcp_rack_reordering_timeout(v3);
      }
      return v3;
    case 3:
      unsigned __int16 v22 = *(_WORD *)(v3 + 226) + 1;
      *(_WORD *)(v3 + 226) = v22;
      if (v22 > 0xCu) {
        goto LABEL_164;
      }
      unsigned int v23 = *(_DWORD *)(v3 + 244);
      if (v23)
      {
        int v24 = *(_DWORD *)(v3 + 248);
        if (v24)
        {
          if (v9 - v24 >= v23) {
            goto LABEL_164;
          }
        }
      }

      if ((*(_BYTE *)(v3 + 740) & 1) == 0 || (*(_BYTE *)(v3 + 88) & 0x10) == 0)
      {
        if (v22 < 5u) {
          goto LABEL_192;
        }
        int v25 = *(_DWORD *)(v3 + 12);
        if (v25 >= 4 && v5)
        {
          if ((*(_BYTE *)(v5 + 1052) & 8) != 0)
          {
            if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224LL) + 24LL))
            {
              uint64_t all_stats = nw_protocol_tcp_get_all_stats();
              if (all_stats)
              {
                char v27 = 2;
LABEL_191:
                *(_BYTE *)(all_stats + 96) |= v27;
              }
            }
          }
        }

        else if (v25 <= 3)
        {
          if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224LL) + 24LL))
          {
            uint64_t all_stats = nw_protocol_tcp_get_all_stats();
            if (all_stats)
            {
              char v27 = 8;
              goto LABEL_191;
            }
          }
        }

LABEL_192:
        uint64_t v83 = *(void *)(v3 + 1056);
        if (v83) {
          ++*(void *)(v83 + 480);
        }
        *(void *)(v3 + 216) = 0LL;
        if (*(_WORD *)(v3 + 226) == 1 && *(_DWORD *)(v3 + 12) == 4)
        {
          *(_DWORD *)(v3 + 248) = *(_DWORD *)(v8 + 316);
          tcp_rexmt_save_state(v3);
        }

        if (*(_BYTE *)(v3 + 266))
        {
          if (*(unsigned __int16 *)(v3 + 226) > *(unsigned __int8 *)(v3 + 266) && *(int *)(v3 + 12) >= 4)
          {
            if (v6)
            {
              uint64_t v84 = *(void *)(v6 + 32);
              if (v84)
              {
                uint64_t v85 = *(void (**)(uint64_t))(v84 + 80);
                if (v85) {
                  v85(v6);
                }
              }
            }
          }
        }

        int v86 = *(_DWORD *)(v3 + 740);
        if ((v86 & 0x1000) != 0)
        {
          v86 &= ~0x1000u;
          *(_DWORD *)(v3 + 740) = v86;
          uint64_t v87 = *(void *)(v3 + 1056);
          if (v87) {
            ++*(void *)(v87 + 720);
          }
        }

        if ((v86 & 0x4000) != 0)
        {
          *(_WORD *)(v3 + 536) = 0;
          *(_DWORD *)(v3 + 20) = 0;
          v86 &= ~0x4000u;
          *(_DWORD *)(v3 + 740) = v86;
        }

        if ((v86 & 0x1000000) == 0 && *(_DWORD *)(v3 + 12) == 3)
        {
          v86 &= ~0x400000u;
          *(_DWORD *)(v3 + 740) = v86;
        }

        if ((v86 & 0x1000000) == 0
          && (*(_BYTE *)(v3 + 988) & 0x40) == 0
          && (*(_BYTE *)(v3 + 988) & 0x20) == 0
          && (*(_WORD *)(v3 + 990) & 0x40) != 0)
        {
          unsigned int v88 = *(unsigned __int16 *)(v3 + 226);
          if (*(_DWORD *)(v3 + 12) == 2)
          {
            if (v88 < 5) {
              goto LABEL_272;
            }
          }

          else if (v88 <= 1)
          {
            goto LABEL_272;
          }

          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          int v109 = *(void (***)(uint64_t))(v6 + 32);
          if (v109)
          {
            int v110 = v109[3];
            if (!v110 || (v110(v6), (int v109 = *(void (***)(uint64_t))(v6 + 32)) != 0LL))
            {
              int v111 = *v109;
              if (v111) {
                v111(v6);
              }
            }
          }

          *(_WORD *)(v3 + 990) |= 0x1000u;
          uint64_t v112 = *(void *)(v3 + 1056);
          if (v112) {
            ++*(void *)(v112 + 1176);
          }
        }

LABEL_272:
        if ((*(_BYTE *)(v3 + 743) & 1) == 0
          && (*(_BYTE *)(v3 + 988) & 0x40) == 0
          && (*(_WORD *)(v3 + 990) & 0x80) != 0
          && *(unsigned __int16 *)(v3 + 226) >= 4u
          && *(_DWORD *)(v3 + 164) - *(_DWORD *)(v3 + 160) - 10000 >= 1)
        {
          tcp_heuristic_tfo_middlebox(v3);
          *(_WORD *)(v6 + 378) = 96;
          user_north_signal_error(v6);
          int v113 = *(void (***)(uint64_t))(v6 + 32);
          if (v113)
          {
            __int16 v114 = v113[3];
            if (!v114 || (v114(v6), (int v113 = *(void (***)(uint64_t))(v6 + 32)) != 0LL))
            {
              unsigned int v115 = *v113;
              if (v115) {
                v115(v6);
              }
            }
          }
        }

        int v116 = *(_DWORD *)(v3 + 12);
        uint64_t v117 = *(unsigned int *)(v3 + 228);
        int v118 = (*(_DWORD *)(v3 + 208) + (*(int *)(v3 + 200) >> 3)) >> 2;
        if (v117 > v118) {
          int v118 = *(_DWORD *)(v3 + 228);
        }
        uint64_t v119 = *(unsigned __int16 *)(v3 + 226);
        if (v116 == 2)
        {
          int v120 = v118 * tcp_syn_backoff[v119];
          *(_BYTE *)(v3 + 716) = v119;
          int v121 = *(_DWORD *)(v3 + 740);
          if ((v121 & 0x1400000) == 0x400000)
          {
            int v122 = 0;
            *(_DWORD *)(v3 + 740) = v121 & 0xFFBFFFFF;
            *(_BYTE *)(v3 + 988) |= 0x10u;
            goto LABEL_290;
          }
        }

        else
        {
          int v120 = v118 * tcp_backoff[v119];
          if (v116 >= 4)
          {
            int v122 = *(_DWORD *)(sysctls + 176);
            goto LABEL_290;
          }
        }

        int v122 = 0;
LABEL_290:
        unsigned int v123 = v122 + v120;
        *(_DWORD *)(v3 + 192) = v123;
        if (v123 >= v117)
        {
          if (v123 < 0xFA01) {
            goto LABEL_294;
          }
          LODWORD(v117) = 64000;
        }

        *(_DWORD *)(v3 + 192) = v117;
LABEL_294:
        *(_DWORD *)(v3 + 28) = *(_DWORD *)(v3 + 192)
                             + *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL)) + 316)
                             - *(_DWORD *)(v3 + 64);
        if ((*(_BYTE *)(*(void *)(v3 + 80) + 2231LL) & 0x50) != 0)
        {
LABEL_366:
          tcp_output(v3);
          return v3;
        }

        tcp_free_sackholes(v3);
        int v124 = *(_DWORD *)(v3 + 740);
        if ((v124 & 0x20400020) == 0x20000020)
        {
          tcp_segs_clear_sacked(v3);
          tcp_rack_loss_on_rto(v3);
          int v124 = *(_DWORD *)(v3 + 740);
        }

        if ((v124 & 0x20000) == 0)
        {
          int v125 = *(_DWORD *)(v3 + 12);
          if (v125 != 4) {
            goto LABEL_324;
          }
          int v126 = *(_DWORD *)(v3 + 88);
          if ((v126 & 0x4000000) == 0) {
            goto LABEL_321;
          }
          unsigned int v127 = *(_DWORD *)(v3 + 156);
          uint64_t v128 = sysctls;
          unsigned int v129 = *(_DWORD *)(sysctls + 228);
          unsigned int v130 = v129;
          if (v127 <= v129)
          {
            uint64_t v131 = 148LL;
            if ((*(_BYTE *)(*(void *)(v3 + 80) + 2236LL) & 1) == 0) {
              uint64_t v131 = 152LL;
            }
            unsigned int v130 = *(_DWORD *)(sysctls + v131);
          }

          if (v130 < *(unsigned __int16 *)(v3 + 696) && *(_WORD *)(v3 + 226) == 2)
          {
            *(_DWORD *)(v3 + 88) = v126 & 0xDBFFFFFF | 0x20000000;
            unsigned int v132 = *(_DWORD *)(v3 + 196) - v127;
            *(_WORD *)(v3 + 698) = v127;
            unsigned int v133 = *(_DWORD *)(v8 + 316);
            if (v133 <= 1) {
              unsigned int v133 = 1;
            }
            *(_DWORD *)(v3 + 700) = v133;
            if (v127 <= v129)
            {
              uint64_t v134 = 148LL;
              if ((*(_BYTE *)(*(void *)(v3 + 80) + 2236LL) & 1) == 0) {
                uint64_t v134 = 152LL;
              }
              unsigned int v129 = *(_DWORD *)(v128 + v134);
            }

            *(_DWORD *)(v3 + 156) = v129;
            unsigned int v135 = v132 + v129;
            *(_DWORD *)(v3 + 196) = v135;
            uint64_t v136 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 40);
            if (v136)
            {
              v136(v3);
              unsigned int v135 = *(_DWORD *)(v3 + 196);
              uint64_t v128 = sysctls;
            }

            *(_DWORD *)(v3 + 144) = v135;
            if (*(_DWORD *)(v128 + 308) == 1
              && (~*(_DWORD *)(v3 + 88) & 0x180) == 0
              && (*(_DWORD *)(v128 + 40) == 1 || (*(_BYTE *)(v6 + 369) & 0x40) != 0)
              && off_18C4CE828)
            {
              off_18C4CE828((_DWORD *)v3);
            }
          }

          else
          {
LABEL_321:
            if ((v126 & 0x20000000) != 0 && *(unsigned __int16 *)(v3 + 226) >= 5u)
            {
              tcp_pmtud_revert_segment_size(v3);
              *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 196);
            }
          }
        }

        int v125 = *(_DWORD *)(v3 + 12);
LABEL_324:
        unsigned int v137 = *(unsigned __int16 *)(v3 + 226);
        if (v125 == 2)
        {
          if (*(_DWORD *)(sysctls + 220) == v137) {
            *(_DWORD *)(v3 + 88) &= 0xFFFFFF5F;
          }
          if (v137 <= 2)
          {
            if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
            {
              unsigned int v138 = (os_log_s *)__nwlog_tcp_log();
              if (os_log_type_enabled(v138, OS_LOG_TYPE_INFO))
              {
                uint64_t v139 = (const char *)(v6 + 604);
                int v140 = *(unsigned __int16 *)(v3 + 226);
                *(void *)&uint8_t buf[4] = "tcp_timers";
                *(_DWORD *)__int128 buf = 136446722;
                if (!v6) {
                  uint64_t v139 = "";
                }
                *(_WORD *)&_BYTE buf[12] = 2082;
                *(void *)&buf[14] = v139;
                *(_WORD *)&_BYTE buf[22] = 1024;
                *(_DWORD *)&_BYTE buf[24] = v140;
                uint64_t v141 = "%{public}s %{public}s retransmit SYN %u";
                unsigned int v142 = v138;
                os_log_type_t v143 = OS_LOG_TYPE_INFO;
                uint32_t v144 = 28;
LABEL_343:
                _os_log_impl(&dword_1879E5000, v142, v143, v141, buf, v144);
                goto LABEL_344;
              }
            }

            goto LABEL_344;
          }
        }

        else if (v137 < 3)
        {
          goto LABEL_347;
        }

        if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
        {
          int v145 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v146 = (const char *)(v6 + 604);
            uint64_t v147 = "";
            int v148 = *(_DWORD *)(v3 + 92);
            if (!v6) {
              BOOL v146 = "";
            }
            BOOL v33 = *(_DWORD *)(v3 + 12) == 2;
            int v149 = *(unsigned __int16 *)(v3 + 226);
            *(void *)&uint8_t buf[4] = "tcp_timers";
            *(_DWORD *)__int128 buf = 136447234;
            if (v33) {
              uint64_t v147 = " SYN";
            }
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v146;
            *(_WORD *)&_BYTE buf[22] = 2082;
            *(void *)&_BYTE buf[24] = v147;
            LOWORD(v161) = 1024;
            *(_DWORD *)((char *)&v161 + 2) = v148;
            HIWORD(v161) = 1024;
            LODWORD(v162) = v149;
            uint64_t v141 = "%{public}s %{public}s retransmit%{public}s seq=%u %u";
            unsigned int v142 = v145;
            os_log_type_t v143 = OS_LOG_TYPE_DEFAULT;
            uint32_t v144 = 44;
            goto LABEL_343;
          }
        }

LABEL_344:
        unsigned int v137 = *(unsigned __int16 *)(v3 + 226);
        if (v137 >= 4)
        {
          *(_DWORD *)(v3 + 208) += *(int *)(v3 + 200) >> 5;
          *(_DWORD *)(v3 + 200) = 0;
          if ((*(_DWORD *)(v3 + 1872) & 0xFFFFFFFE) == 2)
          {
            *(_DWORD *)(v3 + 212) += *(int *)(v3 + 204) >> 5;
            *(_DWORD *)(v3 + 204) = 0;
          }
        }

LABEL_347:
        int v150 = *(_DWORD *)(v3 + 88);
        *(_DWORD *)(v3 + 100) = *(_DWORD *)(v3 + 92);
        *(_DWORD *)(v3 + 152) = *(_DWORD *)(v3 + 96);
        *(_DWORD *)(v3 + 88) = v150 | 1;
        if ((v150 & 0x200000) != 0)
        {
          if (v137 == 1)
          {
LABEL_357:
            uint64_t v152 = *(void (**)(uint64_t))(tcp_cc_algo_list[*(unsigned __int8 *)(v3 + 264)] + 88);
            if (v152)
            {
              if ((v152(v3), int v153 = *(_DWORD *)(v3 + 740), (v153 & 0x10000000) != 0)
                || (v153 & 0x8000000) == 0 && *(_DWORD *)(sysctls + 320) != 1 && tcp_do_acc_ecn != 1
                || (~*(_DWORD *)(v3 + 348) & 0x300000) != 0)
              {
                int v154 = *(_DWORD *)(v3 + 348);
                if ((~v154 & 3) == 0) {
                  *(_DWORD *)(v3 + 348) = v154 | 8;
                }
              }
            }
          }
        }

        else if (v137 == 1)
        {
          uint64_t v151 = *(void *)(v3 + 1056);
          if (v151) {
            ++*(void *)(v151 + 1608);
          }
          goto LABEL_357;
        }

        *(_DWORD *)(v3 + 88) &= ~0x200000u;
        *(_DWORD *)(v3 + 8) = 0;
        *(_BYTE *)(v3 + 310) = 3;
        *(_DWORD *)(v3 + 288) = 0;
        *(_DWORD *)(v3 + 348) &= ~0x20u;
        *(_DWORD *)(v3 + 16) = 0;
        int v155 = *(_DWORD *)(v3 + 740);
        *(_DWORD *)(v3 + 984) = 0;
        *(_DWORD *)(v3 + 628) = 0;
        *(_DWORD *)(v3 + 740) = v155 & 0xFFE7FFFF;
        goto LABEL_366;
      }

      if (v22 < 4u) {
        goto LABEL_192;
      }
LABEL_164:
      uint64_t v74 = *(void *)(v3 + 1056);
      if ((*(_BYTE *)(v3 + 740) & 1) != 0)
      {
        if (v74) {
          ++*(void *)(v74 + 496);
        }
      }

      else if (v74)
      {
        ++*(void *)(v74 + 488);
      }

      int v75 = *(_DWORD *)(v3 + 348) & 3;
      if (v22 < 0xCu) {
        goto LABEL_178;
      }
      uint64_t v76 = *(void *)(v3 + 80);
      __int16 v77 = *(void **)(v76 + 448);
      if (v75 == 3)
      {
        if (!v77)
        {
          *(_WORD *)(v3 + 226) = 12;
LABEL_179:
          if (*(_DWORD *)(v3 + 12) == 4) {
            tcp_heuristic_ecn_droprxmt(v3);
          }
          goto LABEL_183;
        }

        char v78 = *(_BYTE *)(v76 + 2236);
        __int16 v79 = v77 + 45;
        int v80 = v77 + 93;
      }

      else
      {
        if (!v77)
        {
          *(_WORD *)(v3 + 226) = 12;
          goto LABEL_183;
        }

        char v78 = *(_BYTE *)(v76 + 2236);
        __int16 v79 = v77 + 58;
        int v80 = v77 + 106;
      }

      if ((v78 & 2) == 0) {
        int v80 = v79;
      }
      ++*v80;
LABEL_178:
      *(_WORD *)(v3 + 226) = 12;
      if (v75 == 3) {
        goto LABEL_179;
      }
LABEL_183:
      if (*(_DWORD *)(v3 + 256)) {
        int v81 = *(_DWORD *)(v3 + 256);
      }
      else {
        int v81 = 60;
      }
      uint64_t v82 = v3;
      goto LABEL_256;
    case 4:
      uint64_t v17 = sysctls;
      if (!*(_DWORD *)(sysctls + 36)) {
        return v3;
      }
      int v18 = *(_DWORD *)(v3 + 88);
      if ((v18 & 2) == 0) {
        return v3;
      }
      *(_DWORD *)(v3 + 32) = 0;
      *(_DWORD *)(v3 + 88) = v18 & 0xFFFFFFFC | 1;
      if (v18 < 0)
      {
        unsigned int v19 = *(unsigned __int16 *)(v3 + 304);
        if (*(unsigned __int8 *)(v3 + 267) >= 6u)
        {
          *(_DWORD *)(v3 + 740) |= 0x10000u;
          *(_DWORD *)(v3 + 336) = *(_DWORD *)(v7 + 316);
          uint64_t v20 = *(void *)(v3 + 1056);
          if (v20) {
            ++*(void *)(v20 + 1624);
          }
          *(_BYTE *)(v3 + 267) = 0;
          *(_DWORD *)(v3 + 340) = 0;
        }

        tcp_reset_stretch_ack(v3);
      }

      *(_WORD *)(v3 + 308) = 16;
      *(_DWORD *)(v3 + 744) = 0;
      uint64_t v21 = *(void *)(v3 + 1056);
      if (v21) {
        ++*(void *)(v21 + 56);
      }
      ++*(_DWORD *)(v3 + 724);
      goto LABEL_366;
    case 5:
      uint64_t v43 = *(void *)(v3 + 1056);
      if (v43) {
        ++*(void *)(v43 + 504);
      }
      if (*(_WORD *)(v3 + 226) != 12) {
        goto LABEL_92;
      }
      if (v10 <= 7199999)
      {
        uint64_t v44 = *(unsigned int *)(v3 + 228);
        if (v10 < 511 * (int)v44)
        {
LABEL_92:
          int v45 = *(_DWORD *)(v3 + 316);
          if (!v45 || v45 - v9 > 0)
          {
            tcp_setpersist(v3);
            *(_DWORD *)(v3 + 740) |= 0x8000u;
            tcp_output(v3);
            *(_DWORD *)(v3 + 740) &= ~0x8000u;
            return v3;
          }
        }
      }

      if (v43) {
        ++*(void *)(v43 + 512);
      }
      goto LABEL_255;
    case 6:
      uint64_t v46 = *(void *)(v3 + 1056);
      if (v46) {
        ++*(void *)(v46 + 520);
      }
      int v47 = *(_DWORD *)(v3 + 12);
      if (v47 <= 3)
      {
        if (v47 != 1 || v6 && (*(_BYTE *)(v6 + 828) & 2) != 0) {
          goto LABEL_253;
        }
        __nwlog_tcp_log();
        if (v6) {
          int v48 = (const char *)(v6 + 604);
        }
        else {
          int v48 = "";
        }
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "tcp_timers";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = v48;
        uint64_t v49 = (void *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v50 = (os_log_s *)__nwlog_tcp_log();
          os_log_type_t v51 = type[0];
          if (!os_log_type_enabled(v50, type[0])) {
            goto LABEL_251;
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v48;
          uint32_t v52 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connection";
        }

        else
        {
          int v50 = (os_log_s *)__nwlog_tcp_log();
          os_log_type_t v51 = type[0];
          if (!os_log_type_enabled(v50, type[0])) {
            goto LABEL_251;
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v48;
          uint32_t v52 = "%{public}s %{public}s TCP listener failed to receive inbound connection within timeout, dropping connect"
                "ion, backtrace limit exceeded";
        }

        _os_log_impl(&dword_1879E5000, v50, v51, v52, buf, 0x16u);
LABEL_251:
        if (v49) {
          free(v49);
        }
        goto LABEL_253;
      }

      uint64_t v53 = *(void *)(v3 + 80);
      uint64_t v54 = *(void *)(v53 + 224);
      int v55 = *(_DWORD *)(v54 + 372);
      if ((v55 & 8) == 0 && (*(_BYTE *)(v3 + 740) & 0x80) == 0 && *(_BYTE *)(v3 + 993) != 1
        || (v47 - 4) >= 4 && v47 != 9)
      {
        int v66 = *(_DWORD *)(nw_tcp_access_globals(v54) + 316);
        int v67 = *(_DWORD *)(v3 + 676);
        if (!v67 || (*(_BYTE *)(*(void *)(*(void *)(v3 + 80) + 224LL) + 372LL) & 8) == 0) {
          int v67 = *(_DWORD *)(sysctls + 192);
        }
LABEL_149:
        *(_DWORD *)(v3 + 40) = v67 + v66 - *(_DWORD *)(v3 + 64);
        if (v5)
        {
          if ((*(_BYTE *)(v5 + 1052) & 8) != 0 && *(unsigned __int8 *)(v3 + 311) >= 5u)
          {
            if (*(void *)(*(void *)(*(void *)(v3 + 80) + 224LL) + 24LL))
            {
              uint64_t v69 = nw_protocol_tcp_get_all_stats();
              if (v69) {
                *(_BYTE *)(v69 + 96) |= 4u;
              }
            }
          }
        }

        int v70 = *(_DWORD *)(v3 + 740);
        if ((v70 & 0x80) == 0) {
          goto LABEL_229;
        }
        if (*(_BYTE *)(v3 + 265))
        {
          unsigned int v71 = *(unsigned __int8 *)(v3 + 311);
          if (v71 > *(unsigned __int8 *)(v3 + 265))
          {
            if (v6)
            {
              uint64_t v72 = *(void *)(v6 + 32);
              if (v72)
              {
                __int16 v73 = *(void (**)(uint64_t))(v72 + 72);
                if (v73) {
                  v73(v6);
                }
              }
            }

            tcp_keepalive_reset(v3);
            goto LABEL_229;
          }
        }

        else if (!v5 || (*(_BYTE *)(v5 + 1052) & 8) == 0 || (unsigned int v71 = *(unsigned __int8 *)(v3 + 311), v71 >= 6))
        {
          *(_DWORD *)(v3 + 740) = v70 & 0xFFFFFF7F;
LABEL_229:
          int v92 = *(unsigned __int8 *)(v3 + 993);
          if (v92 == 1)
          {
            unsigned int v93 = ++*(_BYTE *)(v3 + 992);
            if (v93 >= 0xC) {
              int v94 = 12;
            }
            else {
              int v94 = v93;
            }
            int v95 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL)) + 316);
            int v96 = tcp_backoff[v94];
            uint64_t v97 = *(unsigned int *)(v3 + 228);
            unsigned int v98 = v95 - *(_DWORD *)(v3 + 64) + v97 * v96;
            unsigned int v99 = *(_DWORD *)(v3 + 40);
            if (v98 < v99)
            {
              int v100 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL)) + 316);
              uint64_t v101 = *(unsigned int *)(v3 + 228);
              unsigned int v99 = v100 - *(_DWORD *)(v3 + 64) + v101 * v96;
            }

            *(_DWORD *)(v3 + 40) = v99;
          }

          else if ((*(_BYTE *)(v3 + 743) & 1) == 0 && v92 == 2 && (*(_BYTE *)(v3 + 988) & 0x40) == 0)
          {
            tcp_heuristic_tfo_middlebox(v3);
            *(_WORD *)(v6 + 378) = 96;
            user_north_signal_error(v6);
            uint64_t v102 = *(void *)(v6 + 32);
            if (v102)
            {
              int v103 = *(void (**)(uint64_t))(v102 + 24);
              if (v103) {
                v103(v6);
              }
            }

            *(_WORD *)(v3 + 990) |= 0x2000u;
            uint64_t v104 = *(void *)(v3 + 1056);
            if (v104) {
              ++*(void *)(v104 + 1144);
            }
          }

          return v3;
        }

        if (v71 >= 0xC) {
          int v89 = 12;
        }
        else {
          int v89 = v71;
        }
        uint64_t v90 = nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL));
        uint64_t v91 = *(unsigned int *)(v3 + 228);
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v90 + 316) - *(_DWORD *)(v3 + 64) + v91 * tcp_backoff[v89];
        goto LABEL_229;
      }

      if ((v55 & 8) != 0 && (int v56 = *(_DWORD *)(v3 + 676)) != 0)
      {
        int v57 = *(_DWORD *)(v3 + 688);
        if (v57) {
          goto LABEL_116;
        }
      }

      else
      {
        int v56 = *(_DWORD *)(sysctls + 192);
        int v57 = *(_DWORD *)(v3 + 688);
        if (v57)
        {
LABEL_116:
          int v58 = *(_DWORD *)(v3 + 684);
          if (v58) {
            goto LABEL_117;
          }
          goto LABEL_133;
        }
      }

      int v57 = *(_DWORD *)(sysctls + 200);
      int v58 = *(_DWORD *)(v3 + 684);
      if (v58) {
        goto LABEL_117;
      }
LABEL_133:
      int v58 = *(_DWORD *)(sysctls + 196);
LABEL_117:
      if (v10 < v56 + v58 * v57)
      {
        uint64_t v161 = 0LL;
        memset(buf, 0, sizeof(buf));
        *(void *)mach_timebase_info type = 0x1000000000LL;
        if (v46) {
          ++*(void *)(v46 + 528);
        }
        if ((*(_BYTE *)(v53 + 2236) & 2) != 0) {
          __int16 v59 = in6_pseudo();
        }
        else {
          __int16 v59 = in_pseudo();
        }
        __int16 v163 = v59;
        HIDWORD(v68) = *(_DWORD *)(v53 + 2224);
        LODWORD(v68) = HIDWORD(v68);
        *(void *)&__int128 v162 = (v68 >> 16);
        *((void *)&v162 + 1) = 0x5000000000LL;
        __int16 v164 = 0;
        tcp_respond(v3, &v162, 0LL, *(_DWORD *)(v3 + 120), *(_DWORD *)(v3 + 92) - 1, 0, (uint64_t)type);
        if ((*(_BYTE *)(v3 + 740) & 0x80) != 0) {
          ++*(_BYTE *)(v3 + 311);
        }
        int v66 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL)) + 316);
        int v67 = *(_DWORD *)(v3 + 684);
        if (!v67) {
          int v67 = *(_DWORD *)(sysctls + 196);
        }
        goto LABEL_149;
      }

      if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
      {
        int v64 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v65 = "";
          if (v6) {
            __int16 v65 = (const char *)(v6 + 604);
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "tcp_timers";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v65;
          _os_log_impl( &dword_1879E5000,  v64,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s dropping connection on keepalive timeout",  buf,  0x16u);
        }
      }

LABEL_253:
      uint64_t v105 = *(void *)(v3 + 1056);
      if (v105) {
        ++*(void *)(v105 + 536);
      }
LABEL_255:
      uint64_t v82 = v3;
      int v81 = 60;
LABEL_256:
      tcp_drop(v82, v81);
      return 0LL;
    case 7:
      int v28 = *(void **)(v3 + 544);
      if (!v28) {
        goto LABEL_50;
      }
      break;
    default:
      return v3;
  }

  while (1)
  {
    uint64_t v29 = v28[2];
    if (*(void **)(v3 + 616) == v28)
    {
      *(void *)(v3 + 616) = v29;
      int v30 = (void *)v28[3];
      if (v29)
      {
LABEL_44:
        *(void *)(v29 + 24) = v30;
        int v30 = (void *)v28[3];
        goto LABEL_47;
      }
    }

    else
    {
      int v30 = (void *)v28[3];
      if (v29) {
        goto LABEL_44;
      }
    }

    *(void *)(v3 + 552) = v30;
LABEL_47:
    *int v30 = v29;
    nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL));
    free(v28);
    --*(_WORD *)(v3 + 538);
    do
      unsigned int v31 = __ldxr((unsigned int *)&tcp_sack_globalholes);
    while (__stxr(v31 - 1, (unsigned int *)&tcp_sack_globalholes));
    int v28 = *(void **)(v3 + 544);
    if (!v28)
    {
LABEL_50:
      *(_OWORD *)(v3 + 616) = 0u;
      int v32 = *(_DWORD *)(v3 + 12);
      BOOL v33 = v32 == 10 || v32 == 9;
      if (v33 || v10 < 1) {
        goto LABEL_373;
      }
      int v60 = *(_DWORD *)(v3 + 688);
      if (!v60) {
        int v60 = *(_DWORD *)(sysctls + 200);
      }
      int v61 = *(_DWORD *)(v3 + 684);
      if (!v61) {
        int v61 = *(_DWORD *)(sysctls + 196);
      }
      if (v10 >= v61 * v60)
      {
LABEL_373:
        if (!v6 || (*(_BYTE *)(v6 + 828) & 2) == 0)
        {
          int v35 = (os_log_s *)__nwlog_tcp_log();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            int v36 = "";
            if (v6) {
              int v36 = (const char *)(v6 + 604);
            }
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "tcp_timers";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v36;
            _os_log_impl( &dword_1879E5000,  v35,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}s dropping connection on 2 MSL timeout",  buf,  0x16u);
          }
        }

        tcp_close(v3);
        return 0LL;
      }

      else
      {
        int v62 = *(_DWORD *)(nw_tcp_access_globals(*(void *)(*(void *)(v3 + 80) + 224LL)) + 316);
        int v63 = *(_DWORD *)(v3 + 684);
        if (!v63) {
          int v63 = *(_DWORD *)(sysctls + 196);
        }
        *(_DWORD *)(v3 + 44) = v63 + v62 - *(_DWORD *)(v3 + 64);
      }

      return v3;
    }
  }

void tcp_coalesce_timer_updates_end(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 288);
  if (!v2)
  {
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v4);
    int v2 = *(_DWORD *)(a1 + 288);
  }

  int v5 = v2 - 1;
  *(_DWORD *)(a1 + 288) = v5;
  if (!v5 && (*(_BYTE *)(a1 + 310) & 4) != 0) {
    tcp_process_timerlist(a1);
  }
}

void tcp_process_timerlist(uint64_t a1)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 310) & 1) != 0) {
    return;
  }
  uint64_t v1 = a1;
  *(_BYTE *)(a1 + 310) = *(_BYTE *)(a1 + 310) & 0xFA | 1;
  int v2 = *(void **)(a1 + 256);
  if (!v2)
  {
LABEL_171:
    unsigned int v78 = tcp_timerlist_max_offset;
    goto LABEL_185;
  }

  unsigned int v3 = 0;
  uint64_t v4 = 0LL;
  do
  {
    int v5 = v2;
    int v2 = (void *)*v2;
    if (*((unsigned __int16 *)v5 + 12) <= 7u)
    {
      int v6 = *((_DWORD *)v5 + 5) - *(_DWORD *)(v1 + 316);
      if (v6 >= 1)
      {
        if (v3 - 1 >= v6) {
          unsigned int v3 = *((_DWORD *)v5 + 5) - *(_DWORD *)(v1 + 316);
        }
        uint64_t v4 = *((unsigned __int16 *)v5 + 13) | v4;
        continue;
      }
    }

    uint64_t v7 = (uint64_t)(v5 - 6);
    uint64_t v8 = (unsigned int *)(v5[4] + 456LL);
LABEL_12:
    unsigned int v9 = *v8;
    if (*(_WORD *)v8 != 0xFFFF)
    {
      do
      {
        unsigned int v10 = __ldxr(v8);
        if (v10 != v9)
        {
          __clrex();
          goto LABEL_12;
        }
      }

      while (__stxr(v9 + 1, v8));
      uint64_t v11 = v4;
      int v13 = (uint64_t *)(v7 + 48);
      uint64_t v12 = *(void *)(v7 + 48);
      if (v12 && *(uint64_t **)(v12 + 8) != v13)
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v91 = "tcp_process_timerlist";
        __int16 v92 = 2048;
        uint64_t v93 = v7 + 48;
        unsigned int v14 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v15 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v91 = "tcp_process_timerlist";
            __int16 v92 = 2048;
            uint64_t v93 = v7 + 48;
            _os_log_impl( &dword_1879E5000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded",  buf,  0x16u);
          }
        }

        if (v14) {
          free(v14);
        }
      }

      if (**(uint64_t ***)(v7 + 56) != v13)
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v91 = "tcp_process_timerlist";
        __int16 v92 = 2048;
        uint64_t v93 = v7 + 48;
        int v18 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_fault())
        {
          unsigned int v19 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v91 = "tcp_process_timerlist";
            __int16 v92 = 2048;
            uint64_t v93 = v7 + 48;
            _os_log_impl( &dword_1879E5000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded",  buf,  0x16u);
          }
        }

        if (v18) {
          free(v18);
        }
      }

      int v20 = *(unsigned __int16 *)(v1 + 308);
      (*(void (**)(void, uint64_t))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224LL) + 8LL) + 16LL))( *(void *)(*(void *)(v7 + 80) + 224LL),  1LL);
      uint64_t v21 = *(void *)(*(void *)(v7 + 80) + 224LL);
      uint64_t v22 = nw_tcp_access_globals(v21);
      if (in_pcb_checkstate(*(void *)(v7 + 80), 2LL, 1) == 0xFFFF)
      {
        if ((*(_BYTE *)(v7 + 91) & 0x40) != 0)
        {
          uint64_t v23 = nw_tcp_access_globals(*(void *)(*(void *)(v7 + 80) + 224LL));
          (*(void (**)(void, void))(*(void *)(*(void *)(*(void *)(v7 + 80) + 224LL) + 8LL) + 32LL))( *(void *)(*(void *)(v7 + 80) + 224LL),  0LL);
          int v24 = *(_DWORD *)(v7 + 88);
          uint64_t v4 = v11;
          if ((v24 & 0x40000000) != 0)
          {
            uint64_t v29 = *(uint64_t **)(v23 + 264);
            uint64_t v30 = *v13;
            if (v29) {
              BOOL v31 = v29 == v13;
            }
            else {
              BOOL v31 = 0;
            }
            if (v31) {
              *(void *)(v23 + 264) = v30;
            }
            if (v30) {
              *(void *)(v30 + 8) = *(void *)(v7 + 56);
            }
            int v25 = 0;
            int v26 = 0;
            **(void **)(v7 + 56) = v30;
            *(_DWORD *)(v7 + 88) = v24 & 0xBFFFFFFF;
            --*(_DWORD *)(v23 + 280);
            uint64_t *v13 = 0LL;
            *(void *)(v7 + 56) = 0LL;
            goto LABEL_55;
          }

          goto LABEL_37;
        }

        goto LABEL_43;
      }

      if (v20)
      {
        uint64_t v27 = *(void *)(*(void *)(v7 + 80) + 448LL);
        if (v27)
        {
          if (*(unsigned __int16 *)(v27 + 1072) == v20)
          {
            *(_DWORD *)(v7 + 740) |= 0x200000u;
            tcp_timers(v7, 0);
            *(_DWORD *)(v7 + 16) = 0;
            *(_DWORD *)(v7 + 740) &= 0x200000u;
          }
        }
      }

      int v28 = *(unsigned __int16 *)(v7 + 72);
      if (v28 == 8)
      {
LABEL_43:
        int v25 = 0;
        int v26 = 0;
        uint64_t v4 = v11;
        goto LABEL_55;
      }

      int v26 = *(_DWORD *)(v7 + 68) - *(_DWORD *)(v22 + 316);
      if (v26 >= 1)
      {
        int v25 = *(unsigned __int16 *)(v7 + 74);
        uint64_t v4 = v11;
        goto LABEL_55;
      }

      uint64_t v38 = v7 + 4LL * *(unsigned __int16 *)(v7 + 72);
      int v39 = *(_DWORD *)(v38 + 16);
      *(_DWORD *)(v38 + 16) = 0;
      if (v39)
      {
        uint64_t v7 = tcp_timers(v7, v28);
        if (!v7)
        {
          int v25 = 0;
          int v26 = 0;
          uint64_t v4 = v11;
          goto LABEL_67;
        }
      }

      *(_WORD *)(v7 + 74) = 0;
      int v40 = *(_DWORD *)(v7 + 16);
      int v41 = *(_DWORD *)(v22 + 316);
      if (v40)
      {
        int v42 = *(_DWORD *)(v7 + 64) + v40 - v41;
        int v43 = 1;
        if (v42 < 1)
        {
          int v45 = 0;
          char v46 = 0;
          int v42 = 0;
          unsigned int v44 = 8;
          int v47 = *(_DWORD *)(v7 + 20);
          if (!v47) {
            goto LABEL_85;
          }
        }

        else
        {
          unsigned int v44 = 0;
          *(_DWORD *)(v7 + 16) = v42;
          *(_WORD *)(v7 + 74) = 1;
          int v41 = *(_DWORD *)(v22 + 316);
          int v45 = 1;
          char v46 = 1;
          int v43 = 0;
          int v47 = *(_DWORD *)(v7 + 20);
          if (!v47) {
            goto LABEL_85;
          }
        }
      }

      else
      {
        int v45 = 0;
        int v43 = 0;
        int v42 = 0;
        unsigned int v44 = 8;
        char v46 = 1;
        int v47 = *(_DWORD *)(v7 + 20);
        if (!v47) {
          goto LABEL_85;
        }
      }

      int v48 = *(_DWORD *)(v7 + 64) + v47 - v41;
      if (v48 < 1)
      {
        char v49 = 0;
        ++v43;
        int v50 = *(_DWORD *)(v7 + 24);
        if (!v50) {
          goto LABEL_92;
        }
LABEL_88:
        int v51 = *(_DWORD *)(v7 + 64) + v50 - v41;
        if (v51 < 1)
        {
          char v52 = 0;
          ++v43;
          int v53 = *(_DWORD *)(v7 + 28);
          if (!v53) {
            goto LABEL_99;
          }
LABEL_95:
          int v54 = *(_DWORD *)(v7 + 64) + v53 - v41;
          if (v54 < 1)
          {
            char v88 = 0;
            ++v43;
            int v55 = *(_DWORD *)(v7 + 32);
            if (!v55) {
              goto LABEL_106;
            }
LABEL_102:
            int v56 = *(_DWORD *)(v7 + 64) + v55 - v41;
            if (v56 < 1)
            {
              char v57 = 0;
              ++v43;
              int v58 = *(_DWORD *)(v7 + 36);
              if (!v58) {
                goto LABEL_113;
              }
LABEL_109:
              int v59 = *(_DWORD *)(v7 + 64) + v58 - v41;
              if (v59 < 1)
              {
                char v60 = 0;
                ++v43;
                int v61 = *(_DWORD *)(v7 + 40);
                if (v61)
                {
LABEL_114:
                  int v62 = *(_DWORD *)(v7 + 64) + v61 - v41;
                  if (v62 < 1)
                  {
                    char v63 = 0;
                    ++v43;
                  }

                  else
                  {
                    *(_DWORD *)(v7 + 40) = v62;
                    if (v42 - 1 >= v62)
                    {
                      int v42 = v62;
                      unsigned int v44 = 6;
                    }

                    v45 |= 4u;
                    *(_WORD *)(v7 + 74) = v45;
                    int v41 = *(_DWORD *)(v22 + 316);
                    char v63 = 1;
                  }

LABEL_121:
                  int v64 = *(_DWORD *)(v7 + 44);
                  BOOL v65 = v64 == 0;
                  if (v64)
                  {
                    int v66 = *(_DWORD *)(v7 + 64) + v64 - v41;
                    if (v66 >= 1)
                    {
                      *(_DWORD *)(v7 + 44) = v66;
                      *(_WORD *)(v7 + 74) = v45 | 4;
                      int v41 = *(_DWORD *)(v22 + 316);
                      *(_DWORD *)(v7 + 64) = v41;
                      if (v42 - 1 >= v66)
                      {
                        unsigned int v44 = 7;
                        *(_WORD *)(v7 + 72) = 7;
                        BOOL v65 = 1;
                        uint64_t v4 = v11;
                      }

                      else
                      {
                        *(_WORD *)(v7 + 72) = v44;
                        BOOL v65 = 1;
                        uint64_t v4 = v11;
                        if (v44 == 8) {
                          goto LABEL_136;
                        }
                      }

void tcp_set_lotimer_index(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 20);
  int v4 = *(_DWORD *)(a1 + 24);
  unsigned int v5 = *(_DWORD *)(a1 + 28);
  BOOL v6 = (v4 | v2) != 0;
  if (v3) {
    BOOL v6 = 1;
  }
  if (v3 - 1 >= (v2 - 1))
  {
    int v7 = 8 * (v2 == 0);
  }

  else
  {
    int v2 = *(_DWORD *)(a1 + 20);
    int v7 = 1;
  }

  if (v4 - 1 < (v2 - 1))
  {
    int v2 = *(_DWORD *)(a1 + 24);
    int v7 = 2;
  }

  int v8 = v6 | 2;
  if (v2 - 1 >= v5) {
    int v9 = *(_DWORD *)(a1 + 28);
  }
  else {
    int v9 = v2;
  }
  if (v2 - 1 >= v5) {
    int v10 = 3;
  }
  else {
    int v10 = v7;
  }
  if (v5) {
    int v2 = v9;
  }
  else {
    int v8 = v6;
  }
  if (v5) {
    int v7 = v10;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 32);
  unsigned int v12 = *(_DWORD *)(a1 + 36);
  if (v2 - 1 >= v11) {
    int v13 = *(_DWORD *)(a1 + 32);
  }
  else {
    int v13 = v2;
  }
  if (v2 - 1 >= v11) {
    int v14 = 4;
  }
  else {
    int v14 = v7;
  }
  if (v11)
  {
    int v2 = v13;
    v8 |= 2u;
    int v7 = v14;
  }

  if (v2 - 1 >= v12) {
    int v15 = *(_DWORD *)(a1 + 36);
  }
  else {
    int v15 = v2;
  }
  if (v2 - 1 >= v12) {
    int v16 = 5;
  }
  else {
    int v16 = v7;
  }
  if (v12)
  {
    int v2 = v15;
    v8 |= 4u;
    int v17 = v16;
  }

  else
  {
    int v17 = v7;
  }

  unsigned int v19 = *(_DWORD *)(a1 + 40);
  unsigned int v18 = *(_DWORD *)(a1 + 44);
  if (v2 - 1 >= v19) {
    int v20 = *(_DWORD *)(a1 + 40);
  }
  else {
    int v20 = v2;
  }
  if (v2 - 1 >= v19) {
    int v21 = 6;
  }
  else {
    int v21 = v17;
  }
  if (v19) {
    v8 |= 4u;
  }
  else {
    int v20 = v2;
  }
  if (v19) {
    unsigned int v22 = v21;
  }
  else {
    unsigned int v22 = v17;
  }
  if (v18)
  {
    __int16 v23 = v8 | 4;
    if (v20 - 1 >= v18) {
      unsigned int v22 = 7;
    }
    *(_WORD *)(a1 + 72) = v22;
    *(_WORD *)(a1 + 74) = v23;
    if (v22 == 8) {
      return;
    }
    goto LABEL_58;
  }

  *(_WORD *)(a1 + 72) = v22;
  *(_WORD *)(a1 + 74) = v8;
  if (v22 == 8 || v8 != 0)
  {
    if (v22 == 8) {
      return;
    }
    goto LABEL_58;
  }

  uint64_t v27 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  int v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort())
  {
    __break(1u);
    return;
  }

  free(v28);
  unsigned int v22 = *(unsigned __int16 *)(a1 + 72);
  if (v22 != 8)
  {
LABEL_58:
    unsigned int v25 = *(_DWORD *)(a1 + 4LL * v22 + 16) + *(_DWORD *)(a1 + 64);
    if (v25 != *(_DWORD *)(a1 + 68))
    {
      if (v25 <= 1) {
        unsigned int v25 = 1;
      }
      *(_DWORD *)(a1 + 68) = v25;
      uint64_t v26 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
      if (*(_DWORD *)(v26 + 288)) {
        *(_BYTE *)(v26 + 310) |= 4u;
      }
    }
  }

void tcp_sched_timerlist(uint64_t a1, unsigned int a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 288)) {
    return;
  }
  int v3 = tcp_timerlist_max_offset;
  if (tcp_timerlist_max_offset >= a2) {
    unsigned int v4 = a2;
  }
  else {
    unsigned int v4 = tcp_timerlist_max_offset;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 316);
  unsigned int v6 = v5 + v4;
  if ((*(_BYTE *)(a1 + 310) & 2) == 0 || (unsigned int v7 = *(_DWORD *)(a1 + 272), v6 < v7))
  {
    *(_DWORD *)(a1 + 272) = v6;
    if (!v6)
    {
      *(_DWORD *)(a1 + 272) = 1;
      ++v4;
    }

    goto LABEL_17;
  }

  if (v7 <= v5 && v6 > v5)
  {
    *(_DWORD *)(a1 + 272) = v6;
LABEL_17:
    *(_DWORD *)(a1 + 276) = v5;
    if (v4 == v3)
    {
      if (__nwlog_is_datapath_logging_enabled()
        && (int v15 = v3, v16 = (os_log_s *)__nwlog_obj(), os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)))
      {
        int v17 = *(_DWORD *)(a1 + 292);
        int v18 = *(_DWORD *)(a1 + 276);
        int v19 = *(_DWORD *)(a1 + 272);
        int v26 = 136447234;
        uint64_t v27 = "tcp_sched_timerlist";
        __int16 v28 = 1024;
        int v29 = v17;
        __int16 v30 = 1024;
        int v31 = v18;
        __int16 v32 = 1024;
        int v33 = v19;
        __int16 v34 = 1024;
        unsigned int v35 = v15;
        _os_log_impl( &dword_1879E5000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s mode %d schedtime %u runtime %u offset %u, deadline set to forever",  (uint8_t *)&v26,  0x24u);
        int64_t v14 = -1LL;
      }

      else
      {
        int64_t v14 = -1LL;
      }
    }

    else
    {
      int64_t v14 = 1000000LL * v4;
      if (__nwlog_is_datapath_logging_enabled())
      {
        unsigned int v20 = v4;
        int v21 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          int v22 = *(_DWORD *)(a1 + 292);
          int v23 = *(_DWORD *)(a1 + 276);
          int v24 = *(_DWORD *)(a1 + 272);
          int v26 = 136447234;
          uint64_t v27 = "tcp_sched_timerlist";
          __int16 v28 = 1024;
          int v29 = v22;
          __int16 v30 = 1024;
          int v31 = v23;
          __int16 v32 = 1024;
          int v33 = v24;
          __int16 v34 = 1024;
          unsigned int v35 = v20;
          unsigned int v25 = v21;
          unsigned int v4 = v20;
          _os_log_impl( &dword_1879E5000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s mode %d schedtime %u runtime %u offset %u",  (uint8_t *)&v26,  0x24u);
        }

        else
        {
          unsigned int v4 = v20;
        }
      }
    }

    nw_protocol_timer_run_inner(a1, v14);
    if (v4 != tcp_timerlist_max_offset) {
      *(_BYTE *)(a1 + 310) |= 2u;
    }
    return;
  }

  if (__nwlog_is_datapath_logging_enabled())
  {
    int v9 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(a1 + 292);
      int v11 = *(_DWORD *)(a1 + 276);
      int v12 = *(_DWORD *)(a1 + 272);
      int v13 = *(_DWORD *)(a1 + 316);
      int v26 = 136447746;
      uint64_t v27 = "tcp_sched_timerlist";
      __int16 v28 = 1024;
      int v29 = v10;
      __int16 v30 = 1024;
      int v31 = v11;
      __int16 v32 = 1024;
      int v33 = v12;
      __int16 v34 = 1024;
      unsigned int v35 = v6;
      __int16 v36 = 1024;
      int v37 = v13;
      __int16 v38 = 1024;
      unsigned int v39 = v4;
      _os_log_impl( &dword_1879E5000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s mode %d schedtime %u runtime %u new_runtime %u tcp_now %u offset %u, not pushing timer out",  (uint8_t *)&v26,  0x30u);
    }
  }

void tcp_check_timer_state(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 8LL) + 32LL))();
  if ((*(_BYTE *)(*(void *)(a1 + 80) + 2232LL) & 1) != 0) {
    return;
  }
  tcp_set_lotimer_index(a1);
  uint64_t v2 = nw_tcp_access_globals(*(void *)(*(void *)(a1 + 80) + 224LL));
  uint64_t v3 = a1 + 48;
  uint64_t v4 = *(void *)(a1 + 80);
  if (*(_DWORD *)(v4 + 232) == 3)
  {
    if ((*(_BYTE *)(a1 + 91) & 0x40) == 0) {
      return;
    }
    goto LABEL_6;
  }

  if (*(_WORD *)(a1 + 72) == 8)
  {
LABEL_6:
    uint64_t v5 = nw_tcp_access_globals(*(void *)(v4 + 224));
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 8LL) + 32LL))();
    int v6 = *(_DWORD *)(a1 + 88);
    if ((v6 & 0x40000000) != 0)
    {
      uint64_t v7 = *(void *)(v5 + 264);
      uint64_t v8 = *(void *)v3;
      if (v7) {
        BOOL v9 = v7 == v3;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9) {
        *(void *)(v5 + 264) = v8;
      }
      if (v8) {
        *(void *)(v8 + 8) = *(void *)(a1 + 56);
      }
      **(void **)(a1 + 56) = v8;
      *(_DWORD *)(a1 + 88) = v6 & 0xBFFFFFFF;
      --*(_DWORD *)(v5 + 280);
      *(void *)uint64_t v3 = 0LL;
      *(void *)(a1 + 56) = 0LL;
    }

    return;
  }

  uint64_t v10 = v2;
  int v11 = *(unsigned __int16 *)(a1 + 74);
  int v12 = *(_DWORD *)(a1 + 68);
  if (v12 - *(_DWORD *)(v2 + 316) <= 1) {
    unsigned int v13 = 1;
  }
  else {
    unsigned int v13 = v12 - *(_DWORD *)(v2 + 316);
  }
  int v14 = *(_DWORD *)(a1 + 88);
  if ((v14 & 0x40000000) != 0)
  {
    char v17 = *(_BYTE *)(v2 + 310);
  }

  else
  {
    uint64_t v15 = *(void *)(v2 + 256);
    *(void *)uint64_t v3 = v15;
    if (v15) {
      *(void *)(v15 + 8) = v3;
    }
    *(void *)(v2 + 256) = v3;
    *(void *)(a1 + 56) = v2 + 256;
    *(_DWORD *)(a1 + 88) = v14 | 0x40000000;
    unsigned int v16 = *(_DWORD *)(v2 + 280) + 1;
    *(_DWORD *)(v2 + 280) = v16;
    if (v16 > *(_DWORD *)(v2 + 284)) {
      *(_DWORD *)(v2 + 284) = v16;
    }
    char v17 = *(_BYTE *)(v2 + 310);
    if ((v17 & 2) == 0) {
      goto LABEL_52;
    }
  }

  if ((v17 & 3) == 2)
  {
    unsigned int v18 = *(_DWORD *)(v2 + 272) - v12;
    if ((v11 & 1) != 0)
    {
      if (v18 < 0xB) {
        return;
      }
    }

    else if ((v11 & 2) != 0)
    {
      if (v18 < 0x65) {
        return;
      }
    }

    else if (v18 < 0x1F5)
    {
      return;
    }
  }

  if (*(void *)v3 && *(void *)(*(void *)v3 + 8LL) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v28 = "tcp_sched_timers";
    __int16 v29 = 2048;
    uint64_t v30 = a1 + 48;
    int v19 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      unsigned int v20 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v28 = "tcp_sched_timers";
        __int16 v29 = 2048;
        uint64_t v30 = a1 + 48;
        _os_log_impl( &dword_1879E5000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s Bad link elm %p next->prev != elm, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    if (v19) {
      free(v19);
    }
  }

  if (**(void **)(a1 + 56) != v3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v28 = "tcp_sched_timers";
    __int16 v29 = 2048;
    uint64_t v30 = a1 + 48;
    int v21 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v22 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v28 = "tcp_sched_timers";
        __int16 v29 = 2048;
        uint64_t v30 = v3;
        _os_log_impl( &dword_1879E5000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s Bad link elm %p prev->next != elm, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    if (v21) {
      free(v21);
    }
  }

  if ((*(_BYTE *)(v10 + 310) & 1) == 0)
  {
LABEL_52:
    if ((v11 & 1) != 0)
    {
      *(_DWORD *)(v10 + 292) = 1;
      *(_DWORD *)(v10 + 304) = 0;
      BOOL v23 = v13 >= 0xA;
      int v24 = 10;
    }

    else
    {
      if ((v11 & 2) == 0)
      {
LABEL_67:
        tcp_sched_timerlist(v10, v13);
        return;
      }

      if (*(_DWORD *)(v10 + 292) >= 3u) {
        *(_DWORD *)(v10 + 292) = 2;
      }
      *(_DWORD *)(v10 + 304) = 0;
      BOOL v23 = v13 >= 0x64;
      int v24 = 100;
    }

    if (v23) {
      unsigned int v13 = v24;
    }
    goto LABEL_67;
  }

  *(_DWORD *)(v10 + 296) |= v11;
  int v25 = *(_DWORD *)(v10 + 300);
  if (v25) {
    BOOL v26 = (int)v13 < v25;
  }
  else {
    BOOL v26 = 1;
  }
  if (v26) {
    *(_DWORD *)(v10 + 300) = v13;
  }
}

uint64_t tcp_itimer(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(result + 328) |= 0x10u;
  uint64_t v4 = *(void **)(result + 104);
  while (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    uint64_t v4 = (void *)*v4;
    if (*(void *)(v5 + 240))
    {
      int v6 = (unsigned int *)(v5 + 456);
      while (1)
      {
        unsigned int v7 = *v6;
        while (1)
        {
          unsigned int v8 = __ldxr(v6);
          if (v8 != v7) {
            break;
          }
          if (!__stxr(v7 + 1, v6))
          {
            BOOL v9 = *(void **)(v5 + 224);
            (*(void (**)(void *, uint64_t, uint64_t))(v9[1] + 16LL))(v9, 1LL, v2);
            int v10 = in_pcb_checkstate(v5, 2LL, 1);
            if (v10 == 0xFFFF) {
              goto LABEL_3;
            }
            if ((*(_BYTE *)(a2 + 68) & 1) == 0) {
              goto LABEL_3;
            }
            uint64_t v11 = *(void *)(*v9 + 448LL);
            if (!v11) {
              goto LABEL_3;
            }
            uint64_t v12 = *(void *)(*v9 + 240LL);
            unsigned int v13 = *(_DWORD *)(v12 + 156);
            int v14 = *(unsigned __int16 *)(v11 + 72);
            switch(v14)
            {
              case 1200:
                if (v13 <= 0x4B0) {
                  goto LABEL_35;
                }
                unsigned int v15 = 1200;
                break;
              case 512:
                if (v13 < 0x201) {
                  goto LABEL_35;
                }
                unsigned int v15 = 512;
                break;
              case 0:
                unsigned int v15 = *(unsigned __int16 *)(v12 + 734);
                if (*(_WORD *)(v12 + 734)) {
                  BOOL v16 = v13 >= v15;
                }
                else {
                  BOOL v16 = 1;
                }
                unsigned int v17 = *(_DWORD *)(v12 + 156);
                if (!v16)
                {
LABEL_34:
                  *(_DWORD *)(v12 + 156) = v15;
                  unsigned int v17 = v15;
                }

uint64_t tcp_heuristic_tfo_middlebox(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          *(_DWORD *)uint64_t v11 = 136446466;
          *(void *)&v11[4] = "tcp_heuristic_tfo_middlebox";
          *(_WORD *)&v11[12] = 2082;
          *(void *)&v11[14] = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", v11, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = "";
      if (v3) {
        BOOL v9 = (const char *)(v3 + 604);
      }
      *(_DWORD *)uint64_t v11 = 136446466;
      *(void *)&v11[4] = "tcp_heuristic_tfo_middlebox";
      *(_WORD *)&v11[12] = 2082;
      *(void *)&v11[14] = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  *(_BYTE *)(a1 + 988) |= 0x40u;
  *(void *)uint64_t v11 = 0LL;
  *(void *)&v11[8] = 0LL;
  *(_WORD *)&v11[16] = 1024;
  return (*(uint64_t (**)(void, _BYTE *))(*(void *)(v2 + 2136) + 56LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  v11);
}

uint64_t tcp_heuristic_tfo_rst(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          *(_DWORD *)unsigned int v13 = 136446466;
          *(void *)&v13[4] = "tcp_heuristic_tfo_rst";
          *(_WORD *)&v13[12] = 2082;
          *(void *)&v13[14] = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", v13, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = "";
      if (v3) {
        BOOL v9 = (const char *)(v3 + 604);
      }
      *(_DWORD *)unsigned int v13 = 136446466;
      *(void *)&v13[4] = "tcp_heuristic_tfo_rst";
      *(_WORD *)&v13[12] = 2082;
      *(void *)&v13[14] = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  memset(v13, 0, 18);
  __int16 v10 = *(_WORD *)(a1 + 990);
  if ((v10 & 0x40) == 0)
  {
    char v11 = 64;
    if ((v10 & 0x10) == 0) {
      return (*(uint64_t (**)(void, _BYTE *))(*(void *)(v2 + 2136) + 56LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  v13);
    }
    goto LABEL_20;
  }

  v13[17] = 32;
  char v11 = 96;
  if ((v10 & 0x10) != 0) {
LABEL_20:
  }
    v13[17] = v11;
  return (*(uint64_t (**)(void, _BYTE *))(*(void *)(v2 + 2136) + 56LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  v13);
}

uint64_t tcp_heuristic_ecn_loss(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_loss";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = "";
      if (v3) {
        BOOL v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_loss";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  LOBYTE(v11) = 2;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  &v11);
}

uint64_t tcp_heuristic_ecn_droprst(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_droprst";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = "";
      if (v3) {
        BOOL v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_droprst";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  LOBYTE(v11) = 4;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  &v11);
}

uint64_t tcp_heuristic_ecn_droprxmt(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_droprxmt";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          int v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      BOOL v9 = "";
      if (v3) {
        BOOL v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_droprxmt";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      int v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  LOBYTE(v11) = 8;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  &v11);
}

uint64_t tcp_heuristic_ecn_synrst(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 224LL);
  if (tcp_perf_measurement)
  {
    if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v3 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v4 = "";
          if (v2) {
            uint64_t v4 = (const char *)(v2 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_synrst";
          __int16 v13 = 2082;
          uint64_t v14 = v4;
          uint64_t v5 = v3;
          os_log_type_t v6 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v5, v6, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }

  else if (!v2 || (*(_BYTE *)(v2 + 828) & 2) == 0)
  {
    os_log_type_t v7 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      unsigned int v8 = "";
      if (v2) {
        unsigned int v8 = (const char *)(v2 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_synrst";
      __int16 v13 = 2082;
      uint64_t v14 = v8;
      uint64_t v5 = v7;
      os_log_type_t v6 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  uint64_t v9 = *(void *)(a1 + 80);
  LOBYTE(v11) = 32;
  return (*(uint64_t (**)(void, int *))(*(void *)(v9 + 2136) + 24LL))(*(void *)(v9 + 224), &v11);
}

uint64_t tcp_heuristic_ecn_aggressive(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 224);
  if (tcp_perf_measurement)
  {
    if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
    {
      if (__nwlog_is_datapath_logging_enabled())
      {
        uint64_t v4 = (os_log_s *)__nwlog_tcp_log();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v5 = "";
          if (v3) {
            uint64_t v5 = (const char *)(v3 + 604);
          }
          int v11 = 136446466;
          uint64_t v12 = "tcp_heuristic_ecn_aggressive";
          __int16 v13 = 2082;
          uint64_t v14 = v5;
          os_log_type_t v6 = v4;
          os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_15:
          _os_log_impl(&dword_1879E5000, v6, v7, "%{public}s %{public}s ", (uint8_t *)&v11, 0x16u);
        }
      }
    }
  }

  else if (!v3 || (*(_BYTE *)(v3 + 828) & 2) == 0)
  {
    unsigned int v8 = (os_log_s *)__nwlog_tcp_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = "";
      if (v3) {
        uint64_t v9 = (const char *)(v3 + 604);
      }
      int v11 = 136446466;
      uint64_t v12 = "tcp_heuristic_ecn_aggressive";
      __int16 v13 = 2082;
      uint64_t v14 = v9;
      os_log_type_t v6 = v8;
      os_log_type_t v7 = OS_LOG_TYPE_INFO;
      goto LABEL_15;
    }
  }

  LOBYTE(v11) = 16;
  return (*(uint64_t (**)(void, int *))(*(void *)(v2 + 2136) + 24LL))( *(void *)(*(void *)(a1 + 80) + 224LL),  &v11);
}

uint64_t tcp_get_heuristics(uint64_t a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t result = nw_tcp_access_globals(*(void *)(a1 + 224));
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  if (!*(void *)(result + 32)) {
    return 0LL;
  }
  memset(v26, 0, 60);
  uint64_t v6 = *(void *)(*(void *)(a1 + 496) + 216LL);
  DWORD1(v26[3]) = *(unsigned __int16 *)(v6 + 1072);
  if ((*(_BYTE *)(a1 + 2236) & 2) != 0)
  {
    BYTE8(v26[3]) = 30;
    __int128 v8 = *(_OWORD *)(a1 + 464);
    *(_OWORD *)((char *)&v26[1] + 4) = *(_OWORD *)(a1 + 480);
    *(_OWORD *)((char *)&v26[2] + 4) = v8;
  }

  else
  {
    BYTE8(v26[3]) = 2;
    int v7 = *(_DWORD *)(a1 + 476);
    DWORD1(v26[1]) = *(_DWORD *)(a1 + 492);
    DWORD1(v26[2]) = v7;
  }

  uint64_t v9 = ((unsigned int (*)(_OWORD *, uint64_t, void))*MEMORY[0x189608F48])( v26,  60LL,  *(unsigned int *)(v5 + 312))
     % 0x64;
  uint64_t v10 = *(void *)(v5 + 32);
  uint64_t result = *(void *)(v10 + 8LL * v9);
  if (!result)
  {
    if (a2)
    {
LABEL_49:
      int v11 = calloc(1uLL, 0x98uLL);
      if (!v11)
      {
        int v24 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
        int v27 = 136446722;
        __int16 v28 = "strict_calloc";
        __int16 v29 = 2048;
        uint64_t v30 = 1LL;
        __int16 v31 = 2048;
        uint64_t v32 = 152LL;
        int v25 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort();
        if ((_DWORD)result)
        {
          __break(1u);
          return result;
        }

        free(v25);
        int v11 = 0LL;
      }

      *(void *)int v11 = *(void *)(v10 + 8 * v9);
      *(void *)(v10 + 8 * v9) = v11;
      goto LABEL_51;
    }

    return 0LL;
  }

  int v11 = 0LL;
  unsigned int v12 = 0;
  unsigned int v13 = -1;
  do
  {
    if (*(void *)(result + 8) == *(void *)&v26[0]
      && *(void *)(result + 16) == *((void *)&v26[0] + 1)
      && *(void *)(result + 24) == *(void *)&v26[1]
      && *(void *)(result + 32) == *((void *)&v26[1] + 1)
      && *(void *)(result + 40) == *(void *)&v26[2]
      && *(void *)(result + 48) == *((void *)&v26[2] + 1)
      && *(void *)(result + 56) == *(void *)&v26[3]
      && *(_DWORD *)(result + 64) == (unint64_t)DWORD2(v26[3]))
    {
      if (!*(_DWORD *)(result + 148) && (*(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144)) >= 0xE10)
      {
        *(_OWORD *)(result + 128) = 0u;
        *(_OWORD *)(result + 116) = 0u;
        *(_OWORD *)(result + 100) = 0u;
        *(_OWORD *)(result + 84) = 0u;
        *(_OWORD *)(result + 68) = 0u;
      }

      goto LABEL_52;
    }

    if (!*(_DWORD *)(result + 148) && *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144) > v12)
    {
      unsigned int v12 = *(_DWORD *)(v5 + 316) - *(_DWORD *)(result + 144);
      int v11 = (_OWORD *)result;
    }

    uint64_t result = *(void *)result;
    ++v13;
  }

  while (result);
  if (!a2) {
    return 0LL;
  }
  if (v13 < 9) {
    goto LABEL_49;
  }
  if (!v11) {
    return 0LL;
  }
  v11[8] = 0u;
  *(_OWORD *)((char *)v11 + 116) = 0u;
  *(_OWORD *)((char *)v11 + 100) = 0u;
  *(_OWORD *)((char *)v11 + 84) = 0u;
  *(_OWORD *)((char *)v11 + 68) = 0u;
LABEL_51:
  __int128 v21 = v26[0];
  __int128 v22 = v26[1];
  __int128 v23 = v26[2];
  *(_OWORD *)((char *)v11 + 52) = *(_OWORD *)((char *)&v26[2] + 12);
  *(_OWORD *)((char *)v11 + 40) = v23;
  *(_OWORD *)((char *)v11 + 24) = v22;
  *(_OWORD *)((char *)v11 + 8) = v21;
  uint64_t result = (uint64_t)v11;
LABEL_52:
  *(_DWORD *)(result + 144) = *(_DWORD *)(v5 + 316);
  return result;
}

void tcp_release_route_heuristics(os_log_s *a1)
{
  uint64_t v1 = a1;
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t heuristics = tcp_get_heuristics(*((void *)a1 + 10), 0);
  if (heuristics)
  {
    uint64_t v3 = heuristics;
    int v4 = *(_DWORD *)(heuristics + 148);
    *(_DWORD *)(heuristics + 148) = v4 - 1;
    if (v4 > 0) {
      return;
    }
    uint64_t v5 = *(void *)(*((void *)v1 + 10) + 224LL);
    if (v5)
    {
      if ((*(_BYTE *)(v5 + 828) & 2) != 0) {
        return;
      }
    }

    uint64_t v1 = (os_log_s *)__nwlog_tcp_log();
    os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
    uint64_t v6 = (const char *)(v5 + 604);
    unsigned int v13 = "tcp_release_route_heuristics";
    int v7 = *(_DWORD *)(v3 + 148);
    *(_DWORD *)__int128 buf = 136446722;
    if (!v5) {
      uint64_t v6 = "";
    }
    __int16 v14 = 2082;
    uint64_t v15 = (void *)v6;
    __int16 v16 = 1024;
    LODWORD(v17) = v7;
    __int128 v8 = (void *)_os_log_send_and_compose_impl();
    __break(1u);
  }

  uint64_t v9 = *(void *)(*((void *)v1 + 10) + 224LL);
  if (!v9 || (*(_BYTE *)(v9 + 828) & 2) == 0)
  {
    __nwlog_tcp_log();
    uint64_t v10 = v9 ? (char *)(v9 + 604) : "";
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v13 = "tcp_release_route_heuristics";
    __int16 v14 = 2082;
    uint64_t v15 = v10;
    __int128 v8 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_fault())
    {
      int v11 = (os_log_s *)__nwlog_tcp_log();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v13 = "tcp_release_route_heuristics";
        __int16 v14 = 2082;
        uint64_t v15 = v10;
        _os_log_impl( &dword_1879E5000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s tcp get heuristics failed, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    if (v8) {
LABEL_18:
    }
      free(v8);
  }

uint64_t tcp_cubic_init(uint64_t a1)
{
  do
    unsigned int v2 = __ldaxr(dword_18C4CE8E0);
  while (__stlxr(v2 + 1, dword_18C4CE8E0));
  float v3 = 0.3;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v3 = 0.2;
  }
  float v4 = 0.85;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v4 = 0.875;
  }
  float v5 = 0.7;
  if (!*(_DWORD *)(sysctls + 280)) {
    float v5 = 0.8;
  }
  tcp_cubic_backoff = LODWORD(v3);
  tcp_cubic_fast_convergence_factor = LODWORD(v4);
  tcp_cubic_beta = LODWORD(v5);
  uint64_t v6 = *(_DWORD **)(a1 + 840);
  if (v6) {
    goto LABEL_9;
  }
  __int128 v8 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  uint64_t v9 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort();
  if (!(_DWORD)result)
  {
    free(v9);
    uint64_t v6 = *(_DWORD **)(a1 + 840);
LABEL_9:
    *uint64_t v6 = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 4LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 12LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 16LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 840) + 28LL) = 0;
    return 0LL;
  }

  __break(1u);
  return result;
}

uint64_t tcp_cubic_cleanup()
{
  do
    unsigned int v0 = __ldaxr(dword_18C4CE8E0);
  while (__stlxr(v0 - 1, dword_18C4CE8E0));
  return 0LL;
}

void tcp_cubic_cwnd_init_or_reset(uint64_t a1)
{
  unsigned int v2 = *(_DWORD **)(a1 + 840);
  if (!v2)
  {
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    int v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v11);
    unsigned int v2 = *(_DWORD **)(a1 + 840);
  }

  *unsigned int v2 = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 4LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 12LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 16LL) = 0;
  *(_DWORD *)(*(void *)(a1 + 840) + 28LL) = 0;
  float v3 = (_DWORD *)sysctls;
  if (*(_DWORD *)(sysctls + 276))
  {
    if (*(_DWORD *)(sysctls + 304)) {
      int v4 = *(_DWORD *)(sysctls + 16);
    }
    else {
      int v4 = 10;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 196);
    LODWORD(v6) = v5 * v4;
  }

  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 196);
    LODWORD(v6) = 2 * v5;
    else {
      unint64_t v6 = v6;
    }
    if (v6 > 4 * v5) {
      LODWORD(v6) = 4 * v5;
    }
  }

  *(_DWORD *)(a1 + 144) = v6;
  *(void *)(a1 + 980) = 0LL;
  *(_DWORD *)(a1 + 972) = 0;
  *(void *)(a1 + 964) = 0LL;
  *(_BYTE *)(a1 + 751) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if (v3[76])
  {
    int v7 = v3[4];
  }

  else
  {
    if (!v3[69])
    {
      unint64_t v8 = 4380LL;
      goto LABEL_18;
    }

    int v7 = 10;
  }

  unint64_t v8 = (v5 * v7);
LABEL_18:
  unsigned int v9 = *(_DWORD *)(a1 + 148);
  if (*(void *)(*(void *)(*(void *)(a1 + 80) + 248LL) + 24LL) <= v8 && v9 <= 0x3FFFBFFF)
  {
    unsigned int v9 = 1073725440;
    *(_DWORD *)(a1 + 148) = 1073725440;
  }

  **(_DWORD **)(a1 + 840) = v9;
}

void tcp_cubic_congestion_avd(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(void *)(v4 + 224);
  unsigned int v6 = *(_DWORD *)(a1 + 980);
  if (v6)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 144);
    if (v6 < v7 >> 1 && (!v5 || *(_DWORD *)(v5 + 384) <= v7))
    {
      *(_DWORD *)(a1 + 740) |= 0x100000u;
      return;
    }
  }

  *(_DWORD *)(a1 + 740) &= ~0x100000u;
  *(_DWORD *)(a1 + 288) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
  uint64_t v8 = *(void *)(v4 + 496);
  if (v8 && (uint64_t v9 = *(void *)(v8 + 1488)) != 0) {
    unsigned int v10 = *(_DWORD *)(v9 + 40);
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v11 = nw_tcp_access_globals(v5);
  uint64_t v12 = v11;
  unsigned int v13 = *(_DWORD *)(a1 + 144);
  if (v13 >= *(_DWORD *)(a1 + 140)) {
    unsigned int v13 = *(_DWORD *)(a1 + 140);
  }
  uint64_t v14 = *(void *)(a1 + 840);
  if (!*(_DWORD *)v14)
  {
    *(_DWORD *)uint64_t v14 = *(_DWORD *)(a1 + 148);
    uint64_t v14 = *(void *)(a1 + 840);
  }

  if (!*(_DWORD *)(v14 + 4))
  {
    *(_DWORD *)(v14 + 4) = *(_DWORD *)(v11 + 316);
    uint64_t v15 = *(unsigned int **)(a1 + 840);
    if (!v15[1])
    {
      v15[1] = 1;
      uint64_t v15 = *(unsigned int **)(a1 + 840);
    }

    if (*v15 <= v13)
    {
      v15[7] = 0;
      uint64_t v17 = *(unsigned int **)(a1 + 840);
    }

    else
    {
      if (*(_DWORD *)(sysctls + 276)) {
        float v16 = (float)((float)((float)*v15 - (float)v13) * 2.5) / (float)*(unsigned int *)(a1 + 196);
      }
      else {
        float v16 = (float)((*v15 - v13) / *(_DWORD *)(a1 + 196)) * 2.5;
      }
      *((float *)v15 + 7) = cbrtf(v16) * 1000.0;
      uint64_t v17 = *(unsigned int **)(a1 + 840);
      unsigned int v13 = *v17;
    }

    v17[2] = v13;
    uint64_t v14 = *(void *)(a1 + 840);
  }

  unsigned int v18 = *(_DWORD *)(v14 + 8);
  if (!v18)
  {
    int v66 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    int v67 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v67);
    uint64_t v14 = *(void *)(a1 + 840);
    unsigned int v18 = *(_DWORD *)(v14 + 8);
  }

  int v19 = *(_DWORD *)(v12 + 316);
  int v20 = *(_DWORD *)(v14 + 4);
  uint64_t v21 = sysctls;
  uint64_t v22 = *(int *)(sysctls + 32);
  if (v22 <= v10) {
    unsigned int v23 = v10;
  }
  else {
    unsigned int v23 = *(_DWORD *)(sysctls + 32);
  }
  if ((_DWORD)v22) {
    unsigned int v24 = v23;
  }
  else {
    unsigned int v24 = v10;
  }
  float v25 = *(float *)(v14 + 28);
  unsigned int v26 = *(_DWORD *)(a1 + 196);
  if (*(_DWORD *)(v14 + 12))
  {
    *(_DWORD *)(v14 + 16) += *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    uint64_t v27 = *(void *)(a1 + 840);
    unsigned int v30 = *(_DWORD *)(v27 + 16);
    __int16 v28 = (unsigned int *)(v27 + 16);
    unsigned int v29 = v30;
    if (*(_DWORD *)(v21 + 276))
    {
      unsigned int v31 = *(_DWORD *)(a1 + 144);
      if (v29 >= v31)
      {
        float v32 = 3.0 - (float)(*(float *)&tcp_cubic_beta * 3.0);
        float v33 = 1.0 / (float)(*(float *)&tcp_cubic_beta + 1.0);
        do
        {
          *__int16 v28 = v29 - v31;
          int v37 = *(_DWORD **)(a1 + 840);
          if (*(_DWORD *)(a1 + 144) < *v37 && *(_DWORD *)(v21 + 280)) {
            unsigned int v34 = (float)((float)(v32 * (float)*(unsigned int *)(a1 + 196)) * v33);
          }
          else {
            unsigned int v34 = *(_DWORD *)(a1 + 196);
          }
          v37[3] += v34;
          uint64_t v35 = *(void *)(a1 + 840);
          unsigned int v36 = *(_DWORD *)(v35 + 16);
          __int16 v28 = (unsigned int *)(v35 + 16);
          unsigned int v29 = v36;
          unsigned int v31 = *(_DWORD *)(a1 + 144);
        }

        while (v36 >= v31);
      }
    }

    else
    {
      unsigned int v39 = *(_DWORD *)(*(void *)(a1 + 840) + 12LL);
      BOOL v40 = v29 >= v39;
      unsigned int v41 = v29 - v39;
      if (v40)
      {
        *__int16 v28 = v41;
        *(_DWORD *)(*(void *)(a1 + 840) + 12LL) += *(_DWORD *)(a1 + 196);
      }
    }
  }

  else
  {
    unsigned int v38 = *(_DWORD *)(a1 + 144);
    if (v38 >= *(_DWORD *)(a1 + 140)) {
      unsigned int v38 = *(_DWORD *)(a1 + 140);
    }
    *(_DWORD *)(v14 + 12) = v38;
    if (*(_DWORD *)(v21 + 276)) {
      *(_DWORD *)(*(void *)(a1 + 840) + 16LL) = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    }
    else {
      *(_DWORD *)(*(void *)(a1 + 840) + 16LL) = 0;
    }
  }

  uint64_t v42 = *(void *)(a1 + 840);
  unsigned int v43 = *(_DWORD *)(v42 + 12);
  uint64_t v44 = *(unsigned int *)(a1 + 144);
  if (v44 < v43
    && !*(_DWORD *)(v21 + 276)
    && (*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 224LL) + 600LL) - 801) <= 0xFFFFFED2
    && *(_DWORD *)(v42 + 24) > (2 * *(_DWORD *)(a1 + 196)))
  {
    unsigned int v45 = *(_DWORD *)(a1 + 288);
    *(_DWORD *)(a1 + 288) = v45 - v44;
LABEL_59:
    char v54 = *(_BYTE *)(a1 + 260);
    uint64_t v55 = 0xFFFFLL << v54;
    int v56 = 0xFFFF << v54;
    if (v55 > v43) {
      int v56 = v43;
    }
LABEL_72:
    *(_DWORD *)(a1 + 144) = v56;
    return;
  }

  float v46 = (float)((float)(v24 + v19 - v20) - v25) * 0.001;
  unsigned int v47 = (float)((float)v18 + (float)((float)((float)(v46 * v46) * (float)((float)v26 * 0.4)) * v46));
  if (v47 <= v44)
  {
    int v51 = *(_DWORD *)(v21 + 276);
    unint64_t v52 = 0xFFFFFFFFLL;
  }

  else
  {
    unsigned int v48 = *(_DWORD *)(a1 + 196);
    unint64_t v49 = v48 * (unint64_t)v44;
    unint64_t v50 = v47 - v44;
    int v51 = *(_DWORD *)(v21 + 276);
    unint64_t v52 = v49 / v50;
    if (!v51 && v49 >= v50)
    {
      unint64_t v53 = *(unsigned int *)(a1 + 288);
      if (v52 > v53) {
        return;
      }
      *(_DWORD *)(a1 + 288) = v53 - v52;
      unsigned int v43 = v48 + v44;
      goto LABEL_59;
    }
  }

  if (v51)
  {
    uint64_t v57 = *(unsigned int *)(a1 + 196);
    unsigned int v58 = (v43 + (v57 >> 1)) / v57 * v57;
    if (v58 > v44)
    {
      unint64_t v59 = v57 * (unint64_t)v44 / (v58 - v44);
      if (v59 < v52) {
        unint64_t v52 = v59;
      }
    }

    if (v52)
    {
      unint64_t v60 = *(unsigned int *)(a1 + 288);
      if (v52 <= v60)
      {
        *(_DWORD *)(a1 + 288) = v60 - v52;
        uint64_t v61 = v57 + v44;
        char v62 = *(_BYTE *)(a1 + 260);
        uint64_t v63 = 0xFFFFLL << v62;
        int v64 = v57 + v44;
        int v65 = 0xFFFF << v62;
        if (v61 >= v63) {
          int v56 = v65;
        }
        else {
          int v56 = v64;
        }
        goto LABEL_72;
      }
    }
  }

void tcp_cubic_ack_rcvd(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 980);
  if (v2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 144);
    if (v2 < v3 >> 1)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 224LL);
      if (!v4 || *(_DWORD *)(v4 + 384) <= v3)
      {
        *(_DWORD *)(a1 + 740) |= 0x100000u;
        return;
      }
    }

    *(_DWORD *)(a1 + 740) &= ~0x100000u;
  }

  else
  {
    *(_DWORD *)(a1 + 740) &= ~0x100000u;
    unsigned int v3 = *(_DWORD *)(a1 + 144);
  }

  if (v3 >= *(_DWORD *)(a1 + 148))
  {
    tcp_cubic_congestion_avd(a1, a2);
  }

  else
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 92);
    if (*(_DWORD *)(sysctls + 276))
    {
      if (*(_DWORD *)(sysctls + 304)) {
        int v6 = *(_DWORD *)(sysctls + 16);
      }
      else {
        int v6 = 10;
      }
      unsigned int v7 = *(_DWORD *)(a1 + 196) * v6;
    }

    else
    {
      unsigned int v7 = *(_DWORD *)(a1 + 196) << (*(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 96));
    }

    if (v5 >= v7) {
      unsigned int v5 = v7;
    }
    uint64_t v8 = v5 + v3;
    char v9 = *(_BYTE *)(a1 + 260);
    uint64_t v10 = 0xFFFFLL << v9;
    int v11 = 0xFFFF << v9;
    if (v10 <= v8) {
      LODWORD(v8) = v11;
    }
    *(_DWORD *)(a1 + 144) = v8;
  }

uint64_t tcp_cubic_pre_fr(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 840) + 4LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 12LL) = 0;
  *(_DWORD *)(*(void *)(result + 840) + 16LL) = 0;
  if ((*(_BYTE *)(result + 742) & 0x10) != 0)
  {
    unsigned int v1 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    unsigned int v3 = *(_DWORD *)(result + 980);
    if (v3 <= v1) {
      unsigned int v3 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    }
    unsigned int v2 = v3 >> (*(_DWORD *)(sysctls + 292) == 0);
  }

  else
  {
    unsigned int v1 = 0;
    unsigned int v2 = *(_DWORD *)(result + 144);
    if (v2 >= *(_DWORD *)(result + 140)) {
      unsigned int v2 = *(_DWORD *)(result + 140);
    }
  }

  *(_DWORD *)(result + 984) = v1;
  uint64_t v4 = *(unsigned int **)(result + 840);
  unsigned int v5 = v2;
  if (v2 < *v4)
  {
    unsigned int v5 = v2;
    if (*(_DWORD *)(sysctls + 276)) {
      unsigned int v5 = (float)(*(float *)&tcp_cubic_fast_convergence_factor * (float)v2);
    }
  }

  *uint64_t v4 = v5;
  int v6 = *(unsigned int **)(result + 840);
  if (*v6)
  {
    unsigned int v7 = v6[5];
    if (v7)
    {
LABEL_12:
      unsigned int v8 = (*v6 - v7 + (v7 << 6)) >> 6;
      goto LABEL_15;
    }
  }

  else
  {
    *int v6 = *(_DWORD *)(result + 96) - *(_DWORD *)(result + 92);
    int v6 = *(unsigned int **)(result + 840);
    unsigned int v7 = v6[5];
    if (v7) {
      goto LABEL_12;
    }
  }

  unsigned int v8 = *v6;
LABEL_15:
  v6[5] = v8;
  char v9 = *(_DWORD **)(result + 840);
  int v10 = v9[6];
  int v11 = v9[5] - *v9;
  if (v11 < 0) {
    int v11 = *v9 - v9[5];
  }
  if (v10) {
    int v11 = (v11 - v10 + 16 * v10) >> 4;
  }
  v9[6] = v11;
  unsigned int v12 = *(_DWORD *)(result + 196);
  unsigned int v13 = ((float)((float)v2 - (float)(*(float *)&tcp_cubic_backoff * (float)v2)) + (v12 >> 1)) / v12 * v12;
  unsigned int v14 = 2 * v12;
  if (v13 > v14) {
    unsigned int v14 = v13;
  }
  *(_DWORD *)(result + 148) = v14;
  uint64_t v15 = *(_DWORD **)(*(void *)(result + 80) + 224LL);
  if (v15[97] > v14)
  {
    int v16 = v15[108];
    if ((v16 & 0x400) != 0)
    {
      if (v15[109] > v14)
      {
        unsigned int v17 = *(_DWORD *)(sysctls + 120);
        if (v14 < v17) {
          unsigned int v17 = v14;
        }
        v15[109] = v17;
      }

      v15[108] = v16 | 0x800;
    }
  }

  return result;
}

uint64_t tcp_cubic_post_fr(uint64_t result, uint64_t a2)
{
  unsigned int v2 = (int *)(a2 + 8);
  if (!a2) {
    unsigned int v2 = (int *)(result + 92);
  }
  int v3 = *v2;
  int v4 = *(_DWORD *)(result + 96);
  int v5 = *(_DWORD *)(sysctls + 276);
  if (v3 - v4 <= 0)
  {
    if (!v5 || *(_DWORD *)(sysctls + 292))
    {
      unsigned int v6 = v4 - v3;
      if ((*(_BYTE *)(result + 740) & 0x20) == 0) {
        goto LABEL_28;
      }
      goto LABEL_12;
    }

    goto LABEL_5;
  }

  if (v5)
  {
LABEL_5:
    unsigned int v6 = *(_DWORD *)(result + 148);
    int v5 = 1;
    if ((*(_BYTE *)(result + 740) & 0x20) == 0) {
      goto LABEL_28;
    }
    goto LABEL_12;
  }

  unsigned int v6 = 0;
  if ((*(_BYTE *)(result + 740) & 0x20) == 0) {
    goto LABEL_28;
  }
LABEL_12:
  unsigned int v7 = *(_DWORD *)(result + 984);
  if (v7 && !v5)
  {
    uint64_t v8 = *(void *)(result + 952);
    if (v8)
    {
      unsigned int v9 = 0;
      do
      {
        unsigned int v9 = v9 + *(_DWORD *)(v8 + 4) - *(_DWORD *)v8 + 1;
        uint64_t v8 = *(void *)(v8 + 16);
      }

      while (v8);
    }

    else
    {
      unsigned int v9 = 0;
    }

    if (*(_DWORD *)(result + 980) > v7) {
      unsigned int v7 = *(_DWORD *)(result + 980);
    }
    if (v9 <= v7) {
      unsigned int v10 = v9;
    }
    else {
      unsigned int v10 = 0;
    }
    unsigned int v11 = v7 - v10;
    if (v11 >= *(_DWORD *)(result + 196) << 6) {
      unsigned int v11 = *(_DWORD *)(result + 196) << 6;
    }
    unsigned int v12 = v11 >> 1;
    if (v12 > v6) {
      unsigned int v6 = v12;
    }
  }

void tcp_cubic_after_timeout(uint64_t a1)
{
  if (!*(void *)(a1 + 840))
  {
    unsigned int v2 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    int v3 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort())
    {
      __break(1u);
      return;
    }

    free(v3);
  }

  if (*(int *)(a1 + 12) > 3 || *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92) >= 2)
  {
    if ((*(_BYTE *)(a1 + 90) & 0x20) == 0)
    {
      **(_DWORD **)(a1 + 840) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 4LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 8LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 12LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 16LL) = 0;
      *(_DWORD *)(*(void *)(a1 + 840) + 28LL) = 0;
      tcp_cubic_pre_fr(a1);
    }

    *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 196);
  }

void tcp_cubic_switch_cc(uint64_t a1)
{
  do
    unsigned int v1 = __ldaxr(dword_18C4CE8E0);
  while (__stlxr(v1 + 1, dword_18C4CE8E0));
}

CCCryptorStatus CCCryptorCreate( CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x1895F80B0](*(void *)&op, *(void *)&alg, *(void *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorUpdate( CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x1895F8130](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82D8](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82E0](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82E8](c, data, *(void *)&len);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1895F8930]();
}

uint64_t __nw_create_backtrace_string()
{
  return MEMORY[0x189608E40]();
}

uint64_t __nwlog_abort()
{
  return MEMORY[0x189608E48]();
}

uint64_t __nwlog_fault()
{
  return MEMORY[0x189608E50]();
}

uint64_t __nwlog_is_datapath_logging_enabled()
{
  return MEMORY[0x189608E60]();
}

uint64_t __nwlog_obj()
{
  return MEMORY[0x189608E68]();
}

uint64_t __nwlog_tcp_log()
{
  return MEMORY[0x189608E78]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1895F8D88]();
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1895F8DE0]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x1895F94C0]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1895F9710](__count, __size);
}

float cbrtf(float a1)
{
  return result;
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1895FAEE8](when, delta);
}

void free(void *a1)
{
}

uint64_t in6_pseudo()
{
  return MEMORY[0x189608F08]();
}

uint64_t in_addword()
{
  return MEMORY[0x189608F10]();
}

uint64_t in_finalize_cksum()
{
  return MEMORY[0x189608F18]();
}

uint64_t in_pseudo()
{
  return MEMORY[0x189608F20]();
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x1895FB838](*(void *)&a1, a2, a3, *(void *)&a4);
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x1895FB8B0]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1895FB8C0]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1895FBA98]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1895FBBF8](info);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1895FBC88](__size);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1895FBE08](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1895FBE18](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1895FBE30](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1895FBE48](__b, *(void *)&__c, __len);
}

uint64_t network_config_get_tcp_accurate_ecn_enabled()
{
  return MEMORY[0x189608F88]();
}

uint64_t network_config_get_tcp_l4s_enabled()
{
  return MEMORY[0x189608F90]();
}

uint64_t networkd_settings_get_BOOL()
{
  return MEMORY[0x189608FD8]();
}

uint64_t networkd_settings_get_int64_with_default()
{
  return MEMORY[0x189608FE0]();
}

uint64_t nw_array_append()
{
  return MEMORY[0x189609060]();
}

uint64_t nw_array_create()
{
  return MEMORY[0x189609070]();
}

uint64_t nw_connection_client_accurate_ecn_state_to_string()
{
  return MEMORY[0x189609138]();
}

uint64_t nw_connection_server_accurate_ecn_state_to_string()
{
  return MEMORY[0x1896092D8]();
}

uint64_t nw_context_128k_buffer_length()
{
  return MEMORY[0x1896093B0]();
}

uint64_t nw_context_128k_buffer_manager()
{
  return MEMORY[0x1896093B8]();
}

uint64_t nw_context_16k_buffer_length()
{
  return MEMORY[0x1896093C0]();
}

uint64_t nw_context_16k_buffer_manager()
{
  return MEMORY[0x1896093C8]();
}

uint64_t nw_context_2k_buffer_length()
{
  return MEMORY[0x1896093D0]();
}

uint64_t nw_context_2k_buffer_manager()
{
  return MEMORY[0x1896093D8]();
}

uint64_t nw_context_64k_buffer_length()
{
  return MEMORY[0x1896093E0]();
}

uint64_t nw_context_64k_buffer_manager()
{
  return MEMORY[0x1896093E8]();
}

uint64_t nw_context_8k_buffer_length()
{
  return MEMORY[0x1896093F0]();
}

uint64_t nw_context_8k_buffer_manager()
{
  return MEMORY[0x1896093F8]();
}

uint64_t nw_context_get_globals_for_protocol()
{
  return MEMORY[0x189609438]();
}

uint64_t nw_context_get_logging_disabled()
{
  return MEMORY[0x189609448]();
}

uint64_t nw_dispatch_data_copyout_from_offset()
{
  return MEMORY[0x1896094D0]();
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return (char *)MEMORY[0x1896094E0](endpoint);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return (const sockaddr *)MEMORY[0x189609538](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x189609570](endpoint);
}

uint64_t nw_frame_array_first()
{
  return MEMORY[0x189609620]();
}

uint64_t nw_frame_array_foreach()
{
  return MEMORY[0x189609630]();
}

uint64_t nw_frame_array_is_empty()
{
  return MEMORY[0x189609650]();
}

uint64_t nw_frame_array_remove()
{
  return MEMORY[0x189609680]();
}

uint64_t nw_frame_array_unclaimed_length()
{
  return MEMORY[0x189609688]();
}

uint64_t nw_frame_create()
{
  return MEMORY[0x1896096C0]();
}

uint64_t nw_frame_create_external()
{
  return MEMORY[0x1896096C8]();
}

uint64_t nw_frame_is_wake_packet()
{
  return MEMORY[0x189609708]();
}

uint64_t nw_frame_set_is_wake_packet()
{
  return MEMORY[0x189609730]();
}

uint64_t nw_interface_get_subtype()
{
  return MEMORY[0x189609820]();
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  return MEMORY[0x189609828](interface);
}

uint64_t nw_interface_supports_ack_priority()
{
  return MEMORY[0x189609830]();
}

uint64_t nw_interface_supports_carrier_aggregation()
{
  return MEMORY[0x189609838]();
}

uint64_t nw_interface_supports_tx_start()
{
  return MEMORY[0x189609840]();
}

uint64_t nw_ip_metadata_get_dscp_value()
{
  return MEMORY[0x189609868]();
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x189609870](metadata);
}

uint64_t nw_ip_metadata_get_fragmentation_value()
{
  return MEMORY[0x189609878]();
}

nw_service_class_t nw_ip_metadata_get_service_class(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x189609880](metadata);
}

uint64_t nw_link_get_flow_control_status()
{
  return MEMORY[0x189609890]();
}

uint64_t nw_log_ms_to_delta()
{
  return MEMORY[0x189609908]();
}

uint64_t nw_log_ring_append()
{
  return MEMORY[0x189609910]();
}

uint64_t nw_log_ring_copyout()
{
  return MEMORY[0x189609918]();
}

uint64_t nw_mem_buffer_allocate()
{
  return MEMORY[0x189609928]();
}

uint64_t nw_mem_buffer_free()
{
  return MEMORY[0x189609930]();
}

uint64_t nw_parameters_copy_context()
{
  return MEMORY[0x189609998]();
}

uint64_t nw_parameters_copy_protocol_options_legacy()
{
  return MEMORY[0x1896099D0]();
}

uint64_t nw_parameters_get_discretionary()
{
  return MEMORY[0x189609A30]();
}

uint64_t nw_parameters_get_ecn_mode()
{
  return MEMORY[0x189609A40]();
}

BOOL nw_parameters_get_fast_open_enabled(nw_parameters_t parameters)
{
  return MEMORY[0x189609A58](parameters);
}

uint64_t nw_parameters_get_logging_disabled()
{
  return MEMORY[0x189609A70]();
}

uint64_t nw_parameters_get_sensitive_redacted()
{
  return MEMORY[0x189609A90]();
}

uint64_t nw_parameters_get_server_mode()
{
  return MEMORY[0x189609AA0]();
}

uint64_t nw_parameters_is_fallback()
{
  return MEMORY[0x189609AC0]();
}

uint64_t nw_path_copy_delegate_interface()
{
  return MEMORY[0x189609CD8]();
}

uint64_t nw_path_copy_direct_interface()
{
  return MEMORY[0x189609CE8]();
}

uint64_t nw_path_copy_flow_registration()
{
  return MEMORY[0x189609D00]();
}

uint64_t nw_path_flow_registration_access_interface_stats()
{
  return MEMORY[0x189609D98]();
}

uint64_t nw_path_flow_registration_ecn_enabled()
{
  return MEMORY[0x189609DA0]();
}

uint64_t nw_path_flow_registration_fast_open_blocked()
{
  return MEMORY[0x189609DA8]();
}

uint64_t nw_path_flow_registration_get_advisory_region()
{
  return MEMORY[0x189609DB0]();
}

uint64_t nw_path_flow_registration_get_ctl_command()
{
  return MEMORY[0x189609DB8]();
}

uint64_t nw_path_flow_registration_get_nexus_instance()
{
  return MEMORY[0x189609DC0]();
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload()
{
  return MEMORY[0x189609DC8]();
}

uint64_t nw_path_flow_registration_get_stats_area()
{
  return MEMORY[0x189609DD0]();
}

uint64_t nw_path_flow_registration_get_stats_region()
{
  return MEMORY[0x189609DD8]();
}

uint64_t nw_path_flow_registration_get_tfo_cookie()
{
  return MEMORY[0x189609DE0]();
}

uint64_t nw_path_flow_registration_get_tfo_cookie_len()
{
  return MEMORY[0x189609DE8]();
}

uint64_t nw_path_flow_registration_set_ecn_cache()
{
  return MEMORY[0x189609DF0]();
}

uint64_t nw_path_flow_registration_set_tfo_cache()
{
  return MEMORY[0x189609DF8]();
}

uint64_t nw_path_get_csum_flags()
{
  return MEMORY[0x189609E00]();
}

uint64_t nw_path_get_effective_traffic_class()
{
  return MEMORY[0x189609E08]();
}

uint64_t nw_path_get_interface_index()
{
  return MEMORY[0x189609E20]();
}

uint64_t nw_path_get_ipv4_network_signature()
{
  return MEMORY[0x189609E28]();
}

uint64_t nw_path_get_ipv6_network_signature()
{
  return MEMORY[0x189609E30]();
}

uint64_t nw_path_get_mtu()
{
  return MEMORY[0x189609E38]();
}

uint64_t nw_path_get_recommended_mss()
{
  return MEMORY[0x189609E50]();
}

uint64_t nw_path_get_rtt_values()
{
  return MEMORY[0x189609E58]();
}

uint64_t nw_path_get_sysctls_region()
{
  return MEMORY[0x189609E70]();
}

uint64_t nw_path_get_tso_max_segment_size_v4()
{
  return MEMORY[0x189609E78]();
}

uint64_t nw_path_get_tso_max_segment_size_v6()
{
  return MEMORY[0x189609E80]();
}

uint64_t nw_path_is_defunct()
{
  return MEMORY[0x189609E98]();
}

uint64_t nw_path_is_direct()
{
  return MEMORY[0x189609EA0]();
}

uint64_t nw_path_is_local()
{
  return MEMORY[0x189609EB8]();
}

uint64_t nw_path_is_traffic_mgmt_background()
{
  return MEMORY[0x189609EC8]();
}

uint64_t nw_path_is_viable()
{
  return MEMORY[0x189609ED0]();
}

uint64_t nw_path_should_probe_connectivity()
{
  return MEMORY[0x189609F00]();
}

uint64_t nw_protocol_callbacks_set_add_input_handler()
{
  return MEMORY[0x189609F18]();
}

uint64_t nw_protocol_callbacks_set_connect()
{
  return MEMORY[0x189609F20]();
}

uint64_t nw_protocol_callbacks_set_connected()
{
  return MEMORY[0x189609F28]();
}

uint64_t nw_protocol_callbacks_set_copy_info()
{
  return MEMORY[0x189609F30]();
}

uint64_t nw_protocol_callbacks_set_disconnect()
{
  return MEMORY[0x189609F38]();
}

uint64_t nw_protocol_callbacks_set_disconnected()
{
  return MEMORY[0x189609F40]();
}

uint64_t nw_protocol_callbacks_set_error()
{
  return MEMORY[0x189609F48]();
}

uint64_t nw_protocol_callbacks_set_finalize_output_frames()
{
  return MEMORY[0x189609F50]();
}

uint64_t nw_protocol_callbacks_set_get_input_frames()
{
  return MEMORY[0x189609F58]();
}

uint64_t nw_protocol_callbacks_set_get_message_properties()
{
  return MEMORY[0x189609F60]();
}

uint64_t nw_protocol_callbacks_set_get_output_frames()
{
  return MEMORY[0x189609F68]();
}

uint64_t nw_protocol_callbacks_set_input_available()
{
  return MEMORY[0x189609F70]();
}

uint64_t nw_protocol_callbacks_set_input_flush()
{
  return MEMORY[0x189609F78]();
}

uint64_t nw_protocol_callbacks_set_link_state()
{
  return MEMORY[0x189609F80]();
}

uint64_t nw_protocol_callbacks_set_output_available()
{
  return MEMORY[0x189609F88]();
}

uint64_t nw_protocol_callbacks_set_output_finished()
{
  return MEMORY[0x189609F90]();
}

uint64_t nw_protocol_callbacks_set_register_notification()
{
  return MEMORY[0x189609F98]();
}

uint64_t nw_protocol_callbacks_set_remove_input_handler()
{
  return MEMORY[0x189609FA0]();
}

uint64_t nw_protocol_callbacks_set_replace_input_handler()
{
  return MEMORY[0x189609FA8]();
}

uint64_t nw_protocol_callbacks_set_reset()
{
  return MEMORY[0x189609FB0]();
}

uint64_t nw_protocol_callbacks_set_unregister_notification()
{
  return MEMORY[0x189609FB8]();
}

uint64_t nw_protocol_callbacks_set_updated_path()
{
  return MEMORY[0x189609FC0]();
}

uint64_t nw_protocol_callbacks_set_waiting_for_output()
{
  return MEMORY[0x189609FC8]();
}

uint64_t nw_protocol_connect_quiet()
{
  return MEMORY[0x189609FD0]();
}

uint64_t nw_protocol_connected()
{
  return MEMORY[0x189609FD8]();
}

uint64_t nw_protocol_connected_quiet()
{
  return MEMORY[0x189609FE0]();
}

uint64_t nw_protocol_copy_info_quiet()
{
  return MEMORY[0x189609FE8]();
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x18960A018]();
}

BOOL nw_protocol_definition_is_equal( nw_protocol_definition_t definition1, nw_protocol_definition_t definition2)
{
  return MEMORY[0x18960A088](definition1, definition2);
}

uint64_t nw_protocol_destroy()
{
  return MEMORY[0x18960A190]();
}

uint64_t nw_protocol_disconnect_quiet()
{
  return MEMORY[0x18960A198]();
}

uint64_t nw_protocol_disconnected()
{
  return MEMORY[0x18960A1A0]();
}

uint64_t nw_protocol_disconnected_is_valid()
{
  return MEMORY[0x18960A1A8]();
}

uint64_t nw_protocol_downcast()
{
  return MEMORY[0x18960A1B0]();
}

uint64_t nw_protocol_error()
{
  return MEMORY[0x18960A1B8]();
}

uint64_t nw_protocol_error_quiet()
{
  return MEMORY[0x18960A1C0]();
}

uint64_t nw_protocol_establishment_report_create()
{
  return MEMORY[0x18960A1C8]();
}

uint64_t nw_protocol_establishment_report_set_client_accurate_ecn_state()
{
  return MEMORY[0x18960A1D0]();
}

uint64_t nw_protocol_establishment_report_set_server_accurate_ecn_state()
{
  return MEMORY[0x18960A1E0]();
}

uint64_t nw_protocol_get_flow_id()
{
  return MEMORY[0x18960A1E8]();
}

uint64_t nw_protocol_get_identifier()
{
  return MEMORY[0x18960A1F0]();
}

uint64_t nw_protocol_get_input_frames()
{
  return MEMORY[0x18960A1F8]();
}

uint64_t nw_protocol_get_input_handler()
{
  return MEMORY[0x18960A200]();
}

uint64_t nw_protocol_get_local_endpoint()
{
  return MEMORY[0x18960A208]();
}

uint64_t nw_protocol_get_output_handler()
{
  return MEMORY[0x18960A210]();
}

uint64_t nw_protocol_get_parameters()
{
  return MEMORY[0x18960A218]();
}

uint64_t nw_protocol_get_path()
{
  return MEMORY[0x18960A220]();
}

uint64_t nw_protocol_get_remote_endpoint()
{
  return MEMORY[0x18960A228]();
}

uint64_t nw_protocol_input_available()
{
  return MEMORY[0x18960A250]();
}

uint64_t nw_protocol_input_available_is_valid()
{
  return MEMORY[0x18960A258]();
}

uint64_t nw_protocol_input_finished_quiet()
{
  return MEMORY[0x18960A260]();
}

uint64_t nw_protocol_input_handler_is_connection_flow()
{
  return MEMORY[0x18960A268]();
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  return (nw_protocol_definition_t)MEMORY[0x18960A410](metadata);
}

uint64_t nw_protocol_metadata_copy_identifier()
{
  return MEMORY[0x18960A418]();
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x18960A438](metadata);
}

uint64_t nw_protocol_new()
{
  return MEMORY[0x18960A460]();
}

uint64_t nw_protocol_notification_type_to_string()
{
  return MEMORY[0x18960A468]();
}

uint64_t nw_protocol_notify_quiet()
{
  return MEMORY[0x18960A470]();
}

uint64_t nw_protocol_one_to_one_callbacks_new()
{
  return MEMORY[0x18960A478]();
}

uint64_t nw_protocol_options_get_log_id_num()
{
  return MEMORY[0x18960A498]();
}

uint64_t nw_protocol_options_get_log_id_str()
{
  return MEMORY[0x18960A4A0]();
}

uint64_t nw_protocol_options_is_tcp()
{
  return MEMORY[0x18960A4B0]();
}

uint64_t nw_protocol_output_available_quiet()
{
  return MEMORY[0x18960A4B8]();
}

uint64_t nw_protocol_register_extended()
{
  return MEMORY[0x18960A4D0]();
}

uint64_t nw_protocol_release()
{
  return MEMORY[0x18960A4D8]();
}

uint64_t nw_protocol_remove_input_handler()
{
  return MEMORY[0x18960A4E0]();
}

uint64_t nw_protocol_remove_input_handler_is_valid()
{
  return MEMORY[0x18960A4E8]();
}

uint64_t nw_protocol_retain()
{
  return MEMORY[0x18960A4F8]();
}

uint64_t nw_protocol_set_flow_id_from_protocol()
{
  return MEMORY[0x18960A508]();
}

uint64_t nw_protocol_set_input_handler()
{
  return MEMORY[0x18960A510]();
}

uint64_t nw_protocol_set_output_handler()
{
  return MEMORY[0x18960A518]();
}

uint64_t nw_protocol_supports_external_data()
{
  return MEMORY[0x18960A560]();
}

uint64_t nw_protocol_supports_external_data_is_valid()
{
  return MEMORY[0x18960A568]();
}

uint64_t nw_protocol_upcast()
{
  return MEMORY[0x18960A570]();
}

uint64_t nw_protocol_updated_path()
{
  return MEMORY[0x18960A578]();
}

uint64_t nw_protocol_updated_path_is_valid()
{
  return MEMORY[0x18960A580]();
}

uint64_t nw_queue_activate_source()
{
  return MEMORY[0x18960A5E0]();
}

uint64_t nw_queue_cancel_source()
{
  return MEMORY[0x18960A5E8]();
}

uint64_t nw_queue_context_async()
{
  return MEMORY[0x18960A5F0]();
}

uint64_t nw_queue_context_create_source()
{
  return MEMORY[0x18960A608]();
}

uint64_t nw_queue_set_timer_values()
{
  return MEMORY[0x18960A620]();
}

uint64_t nw_queue_source_set_qos_class_fallback()
{
  return MEMORY[0x18960A628]();
}

void nw_release(void *obj)
{
}

void *__cdecl nw_retain(void *obj)
{
  return (void *)MEMORY[0x18960AA20](obj);
}

uint64_t nw_tcp_create_metadata()
{
  return MEMORY[0x18960AAA8]();
}

uint64_t nw_tcp_options_get_connection_timeout()
{
  return MEMORY[0x18960AAB0]();
}

uint64_t nw_tcp_options_get_disable_ack_stretching()
{
  return MEMORY[0x18960AAB8]();
}

uint64_t nw_tcp_options_get_disable_blackhole_detection()
{
  return MEMORY[0x18960AAC0]();
}

uint64_t nw_tcp_options_get_enable_background_traffic_management()
{
  return MEMORY[0x18960AAC8]();
}

uint64_t nw_tcp_options_get_enable_fast_open()
{
  return MEMORY[0x18960AAD0]();
}

uint64_t nw_tcp_options_get_enable_keepalive()
{
  return MEMORY[0x18960AAD8]();
}

uint64_t nw_tcp_options_get_enable_l4s()
{
  return MEMORY[0x18960AAE0]();
}

uint64_t nw_tcp_options_get_fast_open_force_enable()
{
  return MEMORY[0x18960AAE8]();
}

uint64_t nw_tcp_options_get_keepalive_count()
{
  return MEMORY[0x18960AAF0]();
}

uint64_t nw_tcp_options_get_keepalive_idle_time()
{
  return MEMORY[0x18960AAF8]();
}

uint64_t nw_tcp_options_get_keepalive_interval()
{
  return MEMORY[0x18960AB00]();
}

uint64_t nw_tcp_options_get_maximum_segment_size()
{
  return MEMORY[0x18960AB08]();
}

uint64_t nw_tcp_options_get_no_delay()
{
  return MEMORY[0x18960AB10]();
}

uint64_t nw_tcp_options_get_no_fast_open_cookie()
{
  return MEMORY[0x18960AB18]();
}

uint64_t nw_tcp_options_get_no_options()
{
  return MEMORY[0x18960AB20]();
}

uint64_t nw_tcp_options_get_no_push()
{
  return MEMORY[0x18960AB28]();
}

uint64_t nw_tcp_options_get_no_timewait()
{
  return MEMORY[0x18960AB30]();
}

uint64_t nw_tcp_options_get_persist_timeout()
{
  return MEMORY[0x18960AB38]();
}

uint64_t nw_tcp_options_get_reduce_buffering()
{
  return MEMORY[0x18960AB40]();
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time()
{
  return MEMORY[0x18960AB48]();
}

uint64_t nw_tcp_options_get_retransmit_fin_drop()
{
  return MEMORY[0x18960AB50]();
}

uint64_t nw_tcp_set_callbacks()
{
  return MEMORY[0x18960AB80]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1895FC470](oslog, type);
}

uint64_t os_nexus_flow_set_wake_from_sleep()
{
  return MEMORY[0x1895FC4E0]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1895FCF90](__str, __size, __format);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1895FD080](*(void *)&__errnum);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1895FD4B8](uu1, uu2);
}

void uuid_generate(uuid_t out)
{
}